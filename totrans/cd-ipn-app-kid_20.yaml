- en: '17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ADJUSTING DIFFICULTY, COLLECTING GEMS, AND KEEPING SCORE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll add a whole bunch of game elements to make Schoolhouse
    Skateboarder more challenging and fun. We’ll speed the game up and add multilevel
    platforms, gems to collect, and a scoring system.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPEEDING THINGS UP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t want our game to be too easy, or the player will get bored. One way
    to ramp up the difficulty is to have the game speed up. (Also, when you’re playing
    on your iPhone or iPad, a game that lasts a couple of minutes is more practical
    than a game that lasts an hour.) We can speed up the game by increasing the scrollSpeed
    variable by a little bit in our game loop method. Add the following code to the
    update(_:) method in the GameScene class.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: ADJUSTING DIFFICULTY, COLLECTING GEMS, AND KEEPING SCORE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll add a whole bunch of game elements to make Schoolhouse
    Skateboarder more challenging and fun. We’ll speed the game up and add multilevel
    platforms, gems to collect, and a scoring system.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPEEDING THINGS UP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t want our game to be too easy, or the player will get bored. One way
    to ramp up the difficulty is to have the game speed up. (Also, when you’re playing
    on your iPhone or iPad, a game that lasts a couple of minutes is more practical
    than a game that lasts an hour.) We can speed up the game by increasing the scrollSpeed
    variable by a little bit in our game loop method. Add the following code to the
    update(_:) method in the GameScene class.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll add a whole bunch of game elements to make Schoolhouse
    Skateboarder more challenging and fun. We’ll speed the game up and add multilevel
    platforms, gems to collect, and a scoring system.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPEEDING THINGS UP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t want our game to be too easy, or the player will get bored. One way
    to ramp up the difficulty is to have the game speed up. (Also, when you’re playing
    on your iPhone or iPad, a game that lasts a couple of minutes is more practical
    than a game that lasts an hour.) We can speed up the game by increasing the scrollSpeed
    variable by a little bit in our game loop method. Add the following code to the
    update(_:) method in the GameScene class.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll add a whole bunch of game elements to make Schoolhouse
    Skateboarder more challenging and fun. We’ll speed the game up and add multilevel
    platforms, gems to collect, and a scoring system.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPEEDING THINGS UP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t want our game to be too easy, or the player will get bored. One way
    to ramp up the difficulty is to have the game speed up. (Also, when you’re playing
    on your iPhone or iPad, a game that lasts a couple of minutes is more practical
    than a game that lasts an hour.) We can speed up the game by increasing the scrollSpeed
    variable by a little bit in our game loop method. Add the following code to the
    update(_:) method in the GameScene class.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPEEDING THINGS UP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t want our game to be too easy, or the player will get bored. One way
    to ramp up the difficulty is to have the game speed up. (Also, when you’re playing
    on your iPhone or iPad, a game that lasts a couple of minutes is more practical
    than a game that lasts an hour.) We can speed up the game by increasing the scrollSpeed
    variable by a little bit in our game loop method. Add the following code to the
    update(_:) method in the GameScene class.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want our game to be too easy, or the player will get bored. One way
    to ramp up the difficulty is to have the game speed up. (Also, when you’re playing
    on your iPhone or iPad, a game that lasts a couple of minutes is more practical
    than a game that lasts an hour.) We can speed up the game by increasing the scrollSpeed
    variable by a little bit in our game loop method. Add the following code to the
    update(_:) method in the GameScene class.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: This line increases the scrollSpeed by 0.01 every time update(_:) is called.
    Now the further the player makes it in the game, the faster it’ll go, making things
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MULTILEVEL PLATFORMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Another way we can increase the game’s difficulty is by varying the y-position
    of the sidewalk bricks. We’ll make some sections of brick higher so that the player
    will have to jump up to reach them, as shown in [Figure 17-1](text00029.html#ch17fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-1: Multilevel sidewalk platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we’ll have two categories of bricks: low and high. The
    bricks at the usual y-position, like those on the left side of [Figure 17-1](text00029.html#ch17fig1)
    , are the low bricks, and the raised bricks, like those on the right side of the
    figure, are the high bricks. We’ll need to assign each brick one of these categories
    as well as a y-position based on the category it’s in. We could make CGFloat variables
    with the y-positions and assign them to the bricks, but using CGFloat variables
    in that way might become confusing. If we had a lot of other variables, it would
    be harder for us to read the code and find those CGFloat variables if we needed
    to change them. So instead of using regular variables, we’ll use something new
    called an enumeration to make our brick categories.'
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: An *enumeration* , often called an *enum* for short, is a way to make a new
    data type that groups related values. Once you define an enum, you can use it
    just as you would any other data type when defining new variables, constants,
    and functions. By making an enum for the brick level, we can create a new data
    type that stores all the brick levels together so that our code will be easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING MULTIPLE BRICK LEVELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to create an enum to describe two different brick levels. Each value
    in an enum is called a *case* , which is what our low and high brick levels will
    be. We’ll assign each brick an enum case, and then we’ll set the y-position of
    each brick to be the same as its enum case value. In order to do this, we need
    the enum to be a CGFloat to match the y-position’s data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the enum, add the following code inside the GameScene class declaration
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the enum. An enum definition is similar to a class or struct
    definition. The line at ➊ starts with the keyword enum , followed by the enumeration
    name. Like a class or struct, the enum name should always start with an uppercase
    letter. We’ll call this enum BrickLevel because it describes the two different
    types of brick levels we’ll have in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋ , we add a colon (: ) after the enum name, followed by the data type CGFloat
    , which makes the enum the same data type as the y-position of the bricks. When
    you define an enum, you can give it a *raw value* (as we’ll do next), but enums
    don’t have to have raw values. The raw value can be of any data type, but that
    data type must be the same for all of the enum cases. We defined the enum to be
    a CGFloat , so all the enums’ raw values will be CGFloat s. We’ll access the values
    later using the enum’s rawValue property.'
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The enum definition sits inside a pair of braces where you define the cases
    of the enumeration. For BrickLevel , we have just two cases, low and high , but
    an enum can have an unlimited number of cases. Our normal sidewalk will be made
    of low bricks that spawn with a y value of 0.0 , so at ➌ we define our low case
    and set its raw value to 0.0 . Our upper platform will be made up of high bricks
    that spawn with a y value of 100.0 , so at ➍ we create a high case with a raw
    value of 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll access the value of an enum by creating a property to hold the
    current brick level. Add this to the GameScene :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Here we create a variable called brickLevel and set it to BrickLevel.low . The
    brickLevel property will track the current state of our sidewalk as it changes
    from low to high and back. We want to always start with low bricks, so we give
    brickLevel a starting value of low . You can access an enum’s case using dot notation
    by writing the enum name, followed by a period, followed by the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other spot where we need to set the brickLevel before we can start
    using it. Add this line of code to the method startGame() :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now whenever the game starts over, the brickLevel will reset to low . You may
    have noticed here that we left off the BrickLevel part before .low . What gives?
    When we created the brickLevel property, Swift used type inference to figure out
    that brickLevel must be of type BrickLevel . When we use brickLevel here, Swift
    knows what data type it is, so we don’t need to write out BrickLevel . We can
    access the case by just typing a period followed by low . Swifty!
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHANGING HOW BRICKS SPAWN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve established a way to track the brick level, let’s use it to
    determine the y-position where each brick will be spawned. Find the updateBricks(withScrollAmount:)
    method, and change the line of code for brickY to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now when new sidewalk bricks are spawned, the y-position will be adjusted by
    the CGFloat raw values we set up in the BrickLevel enum, depending on what the
    current brickLevel is. Notice how easy it is to access the raw value of an enum.
    It’s contained in the property called rawValue , so you just put a period after
    the enum variable, followed by rawValue . When brickLevel is .low , this will
    be 0.0 . When brickLevel is .high , it will be 100.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need brickLevel to change every now and then. We could randomly change
    brickLevel every time a new brick spawns, but that would look a bit odd, as [Figure
    17-2](text00029.html#ch17fig2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-2: How it would look to randomly spawn low and high bricks*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, that setup might be a little *too* hard for the player. It’s
    not going to work if we randomly switch back and forth between low and high bricks.
    We do want to introduce a bit of randomness here, but we need to be smarter about
    how we do it. What we’ll do is add a 5 percent chance that brickLevel will change
    every time a brick spawns. Once brickLevel changes, it’ll stay in the new position
    until that 5 percent chance is encountered again. This means the sidewalk will
    stay at the low level for a while, then at the high level for a while, then go
    back to the low level, and so on, without so many jumps. Add the following else-if
    block to the updateBricks(withScrollAmount:) method, incorporating the randomNumber
    constant that we generated there earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now, every time a new brick spawns, there is a small chance that the sidewalk
    level will switch from low to high or high to low . You may be wondering why the
    line at ➊ , which checks if randomNumber is less than 10 , results in a 5 percent
    chance of a brick level change. The randomNumber constant was created to be a
    random number between 0 and 99 , so there are 100 possible values. On the first
    line of the if statement that we added previously, the code checks if randomNumber
    is less than 5 , so there are 5 possible values out of 100 that will create a
    gap in the bricks. The else-if condition that we added at ➊ will only be checked
    if randomNumber was not less than 5 . This means the code in the else-if block
    will be run only if randomNumber is between 5 and 9 , or 5 values out of the possible
    100, which results in a 5 percent chance of a brick level change. Run the game
    now and try it out, and then read on to learn about another way to increase the
    game’s difficulty!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING GEMS TO COLLECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collectable item to a game can also give the player more of a challenge.
    Let’s add some gems for the player to collect. Instead of just jumping over the
    gaps in the sidewalk, the player also will have to decide when it’s worth the
    risk to try to grab a gem. We’ll start by adding an array to hold the gem sprites,
    and then we’ll write some code to spawn, move, and remove gems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00308.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPAWNING AND TRACKING THE GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we spawn the gems, we’ll need an array to keep track of each gem that’s
    currently on the screen. Add this gems array declaration to the GameScene class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1207]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1208]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1209]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1210]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1211]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1212]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1213]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each gem will be a sprite, so gems is an array of SKSpriteNode elements. Now
    that we have an array to hold gems, we can create our method to spawn new gems.
    Add this method after the existing spawnBrick(atPosition:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1214]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1215]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1216]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1217]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1218]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1219]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1220]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1221]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1222]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1223]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1224]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1225]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1226]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1227]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1228]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ defines the method to spawn gems, which is very similar to the
    method to spawn bricks. It has a CGPoint passed in for position so that the gem
    can be placed there. Just like most of our other sprites, we create the gem sprite
    using the SKSpriteNode(imageNamed:) initializer ➋ . The image name, *gem* , matches
    the name of the graphic file (*gem.png* ) we added to the asset catalog in “[Adding
    Images](text00026.html#ch14lev1sec4) ” on [page 206](text00026.html#page_206)
    . Once the gem sprite is created, we set its position equal to the position that
    was passed in to the method. Then we set a zPosition of 9 , so it’ll be behind
    the skater but in front of the bricks. Next, we add the gem sprite as a child
    of the scene so it’ll show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The player collects gems by touching them, so each gem sprite needs to be added
    to the physics simulation so we’ll know when the skater has made contact with
    a gem. To do this, we set the gem sprite’s physicsBody equal to a new SKPhysicsBody
    ➌ , which we create using a rectangle equal to the size of the gem sprite, positioned
    at its center. Then at ➍ , we set the categoryBitMask for the gem sprite’s physics
    body equal to the .gem value that we defined in the PhysicsCategory struct. This
    way we can tell when the skater contacts a gem by inspecting the categoryBitMask
    of the bodies in the didBegin(_:) method. The last thing we need to do for the
    physics body is make sure it won’t be affected by gravity ➎ , since we want the
    gems to float in the air.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1287]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1288]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1289]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1290]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1291]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1292]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1293]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1294]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1295]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the gem sprite is all set up, we simply add it to our gems array ➏
    that keeps track of all the gems currently being displayed. This method is now
    ready to be called any time we want to spawn a new gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1296]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1297]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1298]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1299]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1300]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1301]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1302]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1303]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1304]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1305]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1306]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1307]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1308]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1309]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1310]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1311]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1312]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1313]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1314]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1315]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIDING WHEN TO SPAWN A GEM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1316]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1317]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1318]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1319]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1320]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1321]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1322]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1323]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1324]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1325]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1326]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1327]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1328]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1329]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1330]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1331]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1332]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1333]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1334]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1335]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the updateBricks(withScrollAmount:) method, just below the code that
    adjusts the brickX to add gaps, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1336]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1337]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1338]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1339]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1340]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1341]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1342]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1343]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1344]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1345]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1346]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1347]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1348]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1349]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1350]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1351]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1352]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1353]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1354]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1355]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1356]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1357]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1358]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1359]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1360]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1361]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1362]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1363]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1364]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1365]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1366]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1367]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1368]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1369]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1370]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1371]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1372]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1373]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1374]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1375]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1376]'
  prefs: []
  type: TYPE_PRE
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1377]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1378]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1379]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1380]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1381]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1382]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1383]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1384]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1385]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1386]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1387]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1388]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1389]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1390]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1391]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1392]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1393]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1394]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1395]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The method that updates the bricks already has code for determining when to
    make a gap in the bricks that the skater has to jump over. We’re going to use
    this code to spawn a gem every time there’s a gap in the bricks. Since the player
    is already jumping over the gap, this is a natural spot to put a gem. We do this
    inside the if statement ➊ that includes our code to create a 5 percent chance
    of something happening. At ➋ , we calculate a randomized y-position for the new
    gem by generating a random number between 0 and 150 and converting it to a CGFloat
    . Then at ➌ , we add the brickY and the skater sprite’s height to that random
    amount. This will give us a y-position for the gem that is up above where the
    skater is so that the player has to jump to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1396]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1397]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1398]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1399]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1400]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1401]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1402]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1403]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1404]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1405]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1406]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1407]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1408]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1409]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1410]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1411]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1412]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1413]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1414]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1415]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1416]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1417]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1418]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1419]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1420]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1421]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1422]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1423]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1424]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1425]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1426]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1427]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1428]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1429]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1430]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1431]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1432]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1433]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we calculate an x-position, newGemX , that places the gem in the middle
    of the sidewalk gap ➍ . Then at ➎ , we call the spawnGem(atPosition:) method,
    passing in the newGemX and newGemY values we just calculated. Now that we’re creating
    gems, let’s add a way to remove them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1434]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1435]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1436]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1437]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1438]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1439]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1440]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1441]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1442]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1443]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1444]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1445]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1446]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1447]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1448]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1449]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1450]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1451]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1452]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1453]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1454]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1455]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1456]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1457]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1458]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1459]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1460]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1461]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1462]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1463]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1464]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1465]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1466]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1467]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1468]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1469]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1470]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1471]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: When a gem goes off the screen or is collected by the skater, we’ll need to
    remove the gem sprite from the screen and also from our gems array. Add the following
    method right after the spawnGem(atPosition:) method you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1472]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1473]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1474]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1475]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1476]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1477]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1478]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1479]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1480]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1481]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1482]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1483]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1484]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1485]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1486]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1487]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1488]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1489]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1490]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1491]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1492]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1493]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1494]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1495]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1496]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1497]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1498]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1499]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1500]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1501]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1502]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1503]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1504]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1505]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1506]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1507]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1508]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1509]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1510]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1511]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1512]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1513]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1514]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1515]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1516]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1517]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1518]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1519]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1520]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1521]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1522]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1523]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1524]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1525]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1526]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1527]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1528]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: This method allows you to pass in the gem sprite that should be removed. At
    ➊ , we call removeFromParent() on the gem sprite to remove it from the scene we
    previously added it to as a child when it spawned. This makes it disappear from
    the screen, but it’s still taking up space in our gems array. In order to remove
    it from the array, we need to find its position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1529]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1530]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1531]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1532]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1533]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1534]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1535]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1536]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1537]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1538]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1539]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1540]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1541]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1542]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1543]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1544]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1545]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1546]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use an if-let statement to create the gemIndex constant. If the gem
    sprite is found in the array with the array’s index(of:) method, then the if-let
    statement will assign gemIndex the index of the gem sprite. An if-let statement
    must be used here because the index(of:) method returns an optional index—it’s
    possible the item we’re looking for in the array won’t be found there. In our
    case, we’re sure the gem sprite is in the array, but Swift requires you to check
    first, just to be safe. If the gem sprite isn’t found in the array, then the gemIndex
    will be nil , and the code inside the braces of the if-let statement won’t be
    called. If the index is found, then the array’s remove(at:) method is called with
    the gemIndex we just discovered as an argument ➌ . This method removes the gem
    sprite from the gems array at the index it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1547]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1548]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1549]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1550]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1551]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1552]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1553]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1554]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1555]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1556]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1557]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1558]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1559]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1560]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1561]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1562]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1563]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1564]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an easy way to remove gems, we should add some code to remove
    all the gems whenever a new game starts so that gems from the previous game don’t
    stick around. Add this code to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1565]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1566]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1567]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1568]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1569]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1570]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1571]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1572]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1573]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1574]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1575]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1576]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1577]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1578]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1579]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1580]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1581]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1582]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1583]'
  prefs: []
  type: TYPE_PRE
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1584]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1585]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1586]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1587]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1588]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1589]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1590]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1591]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1592]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1593]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1594]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1595]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1596]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1597]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1598]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1599]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1600]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: This for-in loop simply loops through all the gem sprites (if there are any)
    in the gems array and calls our handy removeGem(_:) method on each gem .
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1601]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1602]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1603]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1604]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1605]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1606]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1607]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1608]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1609]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1610]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1611]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1612]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1613]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1614]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1615]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1616]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1617]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1618]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1619]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1620]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1621]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1622]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1623]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1624]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1625]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1626]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1627]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1628]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1629]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1630]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1631]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1632]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1633]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1634]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can spawn and remove gems, we need a method to handle updating
    their position so they move to the left and match the speed of the bricks. We’ll
    also need to remove any gems that move off the left edge of the screen. Add this
    method just after the updateBricks(withScrollAmount:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1635]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1636]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1637]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1638]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1639]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1640]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1641]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1642]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1643]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1644]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1645]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1646]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1647]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1648]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1649]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1650]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1651]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1652]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1653]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1654]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1655]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1656]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1657]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1658]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1659]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1660]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1661]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1662]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1663]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1664]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1665]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1666]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1667]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1668]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1669]'
  prefs: []
  type: TYPE_PRE
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1670]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1671]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1672]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1673]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1674]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1675]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1676]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1677]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1678]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1679]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1680]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1681]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1682]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1683]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1684]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1685]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The updateGems method ➊ takes the currentScrollAmount as an input parameter
    so we know how much to move each gem . We loop through the gems array and do some
    work for each gem . At ➋ , we calculate a new x-position, thisGemX , by subtracting
    the scroll amount from the gem ’s current x-position. Then, at ➌ we set a new
    position on the gem using this newly calculated x-position, but we keep the same
    y-position. This will make the gem sprite move to the left at the same speed as
    the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1686]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1687]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1688]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1689]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1690]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1691]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1692]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1693]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1694]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1695]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1696]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1697]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1698]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1699]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1700]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1701]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➍ , we check if this new x-position is less than 0.0 . If so, it has
    moved too far to the left and is about to go offscreen, so we remove the gem by
    calling our removeGem(_:) method. Now that we have the code to update the gems,
    we need to use it by calling updateGems(withScrollAmount:) from our main game
    loop, which is the update(_:) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1702]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1703]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1704]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1705]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1706]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1707]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1708]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1709]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1710]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1711]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1712]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1713]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1714]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1715]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1716]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1717]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1718]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1719]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1720]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1721]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1722]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1723]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1724]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1725]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1726]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1727]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1728]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1729]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1730]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1731]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1732]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1733]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1734]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1735]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1736]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1737]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1738]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1739]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1740]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1741]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1742]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1743]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1744]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1745]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1746]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1747]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1748]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1749]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now, every time our update(_:) method is called, the gems will move just like
    the bricks. Try running the game now, and you should see the gems appearing over
    sidewalk gaps, as shown in [Figure 17-3](text00029.html#ch17fig3) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1750]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1751]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1752]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1753]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1754]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1755]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1756]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1757]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1758]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1759]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1760]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1761]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1762]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1763]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1764]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1765]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1766]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1767]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1768]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1769]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1770]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1771]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1772]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1773]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1774]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1775]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1776]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1777]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1778]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1779]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-3: Gems now appear over the sidewalk gaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1780]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1781]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1782]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1783]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1784]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1785]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1786]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1787]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1788]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1789]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1790]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1791]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1792]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1793]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1794]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: If you make the skater jump and hit any of the gems, you’ll notice they just
    get pushed around. That’s not quite right—we want the gems to disappear when the
    skater touches them so it’ll look like she collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1795]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1796]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1797]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1798]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1799]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1800]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1801]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1802]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1803]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1804]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1805]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1806]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1807]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1808]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1809]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLECTING GEMS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1810]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1811]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1812]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1813]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1814]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1815]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1816]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1817]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1818]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1819]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1820]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1821]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1822]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1823]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1824]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the code to collect the gems is simple because we already added them
    to the physics simulation, and we already added a method to remove them. Inside
    the existing method didBegin(_:) , add the following code to collect gems that
    are touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1825]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1826]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1827]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1828]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1829]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1830]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1831]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1832]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1833]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1834]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1835]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1836]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1837]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1838]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1839]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1840]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1841]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1842]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1843]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1844]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1845]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1846]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1847]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1848]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1849]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1850]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1851]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1852]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1853]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1854]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1855]'
  prefs: []
  type: TYPE_PRE
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1856]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1857]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1858]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1859]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1860]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1861]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1862]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1863]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1864]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1865]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1866]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1867]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1868]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1869]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: When two physics bodies touch each other, this method gets called. So all we
    have to do is have the method check if the physics bodies that touched are the
    skater and a gem. Line ➊ adds an else-if to our existing if statement and checks
    if bodyA is a skater and bodyB is a gem by comparing their categoryBitMask properties.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1870]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1871]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1872]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1873]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1874]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1875]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1876]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1877]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1878]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1879]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1880]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1881]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1882]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1883]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the gem, we need to get a reference to the actual gem sprite.
    The contact object in this method has a reference to the two physics bodies, bodyA
    and bodyB . We already know that bodyB is our gem’s physics body and that the
    sprite is attached to it, so we can get the physics body’s sprite reference via
    the physics body’s node property. The node is an SKNode object, which is the superclass
    of SKSpriteNode . The if-let statement at ➋ gives us the reference to the gem
    sprite by downcasting the node to an SKSpriteNode . Now we can pass this gem into
    our removeGem(_:) method and it’ll disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1884]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1885]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1886]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1887]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1888]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1889]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1890]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1891]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1892]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1893]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1894]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1895]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1896]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1897]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game again now, you should find that when the skater jumps into
    a gem, it disappears!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1898]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1899]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1900]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1901]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1902]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1903]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1904]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1905]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1906]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1907]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1908]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1909]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1910]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1911]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING SCORING AND LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1912]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1913]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1914]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1915]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1916]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1917]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1918]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1919]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1920]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1921]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1922]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1923]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1924]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1925]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: What’s even better than collecting gems for fun? Collecting gems for a high
    score! It’s fun to see if you can beat your high score or your friends’ scores.
    Adding a score-keeping mechanism will make players want to play your game again
    and again. In this section, we’ll add a simple scoring system and labels to display
    the player’s current score and all-time high score.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1926]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1927]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1928]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1929]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1930]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1931]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1932]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1933]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1934]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1935]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1936]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1937]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1938]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1939]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1940]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1941]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1942]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1943]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1944]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1945]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1946]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1947]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1948]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1949]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1950]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1951]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1952]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1953]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start keeping track of the player’s score, we need to add some labels
    to display the current score and the high score on the screen. We’ll add four
    labels, as shown in [Figure 17-4](text00029.html#ch17fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1954]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1955]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1956]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1957]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1958]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1959]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1960]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1961]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1962]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1963]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1964]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1965]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1966]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1967]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1968]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1969]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1970]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1971]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1972]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1973]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1974]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1975]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1976]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1977]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1978]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1979]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1980]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1981]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-4: The four scoring labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1982]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1983]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1984]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1985]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1986]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1987]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1988]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1989]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1990]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1991]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1992]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1993]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1994]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1995]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The player’s current score will be at the top left of the screen, and the high
    score will be at the top right. We’ll use two labels for each score. Label 1 is
    the string "score" and will never change. Label 2 is the actual score for the
    current game. This label will keep changing to reflect the player’s score. Label
    3 is the string "high score" and will never change. And finally, label 4 displays
    the player’s high score. At the end of each game, that label should be updated
    if the player got a new high score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1996]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1997]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1998]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1999]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2000]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2001]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2002]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2003]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2004]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2005]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2006]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2007]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2008]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2009]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these labels, we’ll add a method, setupLabels() , just after the
    resetSkater() method. We’ll only need to call this method once, when the game
    is first run. It will create the four labels, set them up properly, and add them
    as children of the scene. Let’s start by creating the first label. Add the following
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2010]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2011]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2012]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2013]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2014]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2015]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2016]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2017]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2018]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2019]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2020]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2021]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2022]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2023]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2024]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2025]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2026]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2027]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2028]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2029]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2030]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2031]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2032]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2033]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2034]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2035]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2036]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2037]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2038]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2039]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2040]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2041]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2042]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2043]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2044]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2045]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2046]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2047]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2048]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2049]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2050]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2051]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go over everything that’s new here. First, we’re creating an SKLabelNode
    , which is the label class in SpriteKit. It’s similar to a UILabel , but it’s
    a type of SpriteKit node, so it can be used in SpriteKit scenes with animations
    and physics. We won’t be animating these particular labels or adding them to the
    physics simulation. They’re just going to hang there in the sky. At ➊ , we use
    the initializer SKLabelNode(text:) , which creates the label and gives it a starting
    text string. This is the string that the label will display on the screen. Since
    we decided this label would always just display the word score , we’ll never have
    to change this text again.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2052]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2053]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2054]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2055]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2056]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2057]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2058]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2059]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2060]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2061]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2062]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2063]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2064]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we set the position of the label by creating a CGPoint with an x-position
    of 14.0 and a y-position of the scene’s height minus 20.0 . This will position
    the label in the upper left of the screen. If we set the y-position equal to the
    height of the scene’s frame, then the label would be just off the top of the screen.
    Subtracting 20.0 from the height positions it near the top of the scene instead.
    At ➌ , we set the label’s horizontalAlignmentMode to .left . This makes the label’s
    text hug the left side, so it will always be lined up properly. See [Figure 17-5](text00029.html#ch17fig5)
    for examples of left and right text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2065]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2066]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2067]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2068]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2069]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2070]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2071]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2072]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2073]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2074]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2075]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2076]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2077]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2078]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2079]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2080]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2081]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2082]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2083]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2084]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2085]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2086]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2087]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2088]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2089]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2090]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-5: Labels that are left-aligned and right-aligned*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2091]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2092]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2093]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2094]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2095]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2096]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2097]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2098]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2099]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2100]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2101]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2102]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2103]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code to finish setting up this first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2104]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2105]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2106]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2107]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2108]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2109]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2110]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2111]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2112]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2113]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2114]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2115]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2116]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2117]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2118]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2119]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2120]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2121]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2122]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2123]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2124]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2125]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2126]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2127]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2128]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2129]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we set up the font for the label. You’ve got a lot of choices with iOS,
    but we picked Courier Bold. To see the full list of available fonts, visit *[http://www.iosfonts.com/](http://www.iosfonts.com/)*
    . At ➋ , we set the font size to 14.0 . This makes the label pretty small but
    still easily readable, which is what we want. It’s not recommended to use font
    sizes any smaller than about 10.0 , or the label may be too hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2130]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2131]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2132]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2133]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2134]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2135]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2136]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2137]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2138]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2139]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2140]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2141]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we never set a frame for the label. We didn’t set a width and height,
    just a position. An SKLabelNode is sized automatically based on the font size
    you pick and the text you need to display, which in this case is score .
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2142]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2143]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2144]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2145]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2146]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2147]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2148]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2149]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2150]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2151]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2152]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2153]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , we set a zPosition of 20 so that the label will always be on top of everything
    else we’ve added in the game scene. And finally, don’t forget to add the label
    as a child of the scene, or it won’t show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2154]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2155]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2156]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2157]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2158]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2159]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2160]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2161]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2162]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2163]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2164]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2165]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three labels are created and set up in a very similar way to the
    first one, so we won’t walk you through each line of this code. For the other
    three labels, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2166]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2167]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2168]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2169]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2170]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2171]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2172]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2173]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2174]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2175]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2176]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2177]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2178]'
  prefs: []
  type: TYPE_PRE
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2179]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2180]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2181]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2182]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2183]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2184]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2185]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2186]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2187]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2188]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2189]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Each label is initialized with a different text string ➊ and given a different
    position ➋ . Notice that the labels we placed on the left side of the screen have
    a horizontalAlignmentMode of .left ➌ while the labels we placed on the right have
    .right ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2190]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2191]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2192]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2193]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2194]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2195]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2196]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2197]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2198]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2199]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2200]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one new step: we set a name property on the scoreLabel ➍ and highScoreLabel
    ➏ . Giving a label a name doesn’t change anything about how the label is displayed.
    It simply gives you, the programmer, an easy way to get a reference to that particular
    label later in the code. Any object in your scene that is a type of SpriteKit
    node, such as an SKSpriteNode or SKLabelNode , can be given a name. Instead of
    keeping a class property for every node in your scene, you can assign names to
    the nodes and then get references to them later by using their name properties.
    You’ll see how this works in the next section, when we update the text of these
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2201]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2202]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2203]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2204]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2205]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2206]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2207]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2208]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2209]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2210]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2211]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method to create and set up the four labels, we just need
    to call this method within our didMove(to:) method. Add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2212]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2213]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2214]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2215]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2216]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2217]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2218]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2219]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2220]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2221]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2222]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2223]'
  prefs: []
  type: TYPE_PRE
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2224]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2225]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2226]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2227]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2228]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2229]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2230]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2231]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2232]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2233]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now when the game first starts, the labels will be created and added to the
    scene. Run the game now to make sure they show up.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2234]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2235]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2236]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2237]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2238]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2239]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2240]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2241]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2242]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2243]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2244]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2245]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2246]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2247]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2248]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2249]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2250]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2251]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2252]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2253]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the player’s score changes, we’ll need a way to update the labels to reflect
    the new score. First, let’s add some new class properties to keep track of the
    score. Add the following code near the top of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2254]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2255]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2256]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2257]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2258]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2259]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2260]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2261]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2262]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2263]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2264]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2265]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2266]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2267]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2268]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2269]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2270]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2271]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2272]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2273]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2274]'
  prefs: []
  type: TYPE_PRE
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2275]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2276]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2277]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2278]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2279]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2280]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2281]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2282]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2283]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a score integer we’ll use to track the current score ➊ , a highScore
    integer we’ll use to track the player’s highest score ➋ , and a TimeInterval called
    lastScoreUpdateTime ➌ . A TimeInterval is a type of Double used to track how much
    time has passed in seconds. Inside our game loop, we’ll be updating the score
    label, but we don’t want to update the label every single time our game loop runs
    (remember, that’s usually 30 or 60 times per second). Instead, we’ll update the
    label once a second using this TimeInterval to track the elapsed time between
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2284]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2285]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2286]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2287]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2288]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2289]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2290]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2291]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2292]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2293]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2294]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2295]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2296]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2297]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2298]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2299]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2300]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2301]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING LABELS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2302]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2303]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2304]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2305]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2306]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2307]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2308]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2309]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2310]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll be using the score variable to update the score label’s text, let’s
    write a quick method to do that update. Add the following new method just after
    the existing setupLabels() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2311]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2312]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2313]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2314]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2315]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2316]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2317]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2318]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2319]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2320]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2321]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2322]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2323]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2324]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2325]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2326]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2327]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2328]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2329]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2330]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2331]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2332]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2333]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2334]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2335]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2336]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2337]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ finds a child node of the scene that has the name "scoreLabel"
    . When we created the score label, we set its name property to "scoreLabel" .
    Then, as with the other labels, we added the label as a child of the scene. We
    can call the childNode(withName:) method on any node (whether it’s a scene, sprite,
    or label) to find a child node that has a particular name. Doing this means we
    didn’t have to create a class property to keep track of this label. We simply
    look it up by name when we need to use it. It’s good practice to keep the number
    of class properties you create to a minimum, and using this technique for nodes
    that we won’t need to refer to very often does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2338]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2339]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2340]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2341]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2342]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2343]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2344]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2345]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the text of the scoreLabel to a new string that we create
    using our score variable. The String initializer, String(format:) , creates a
    new string using a string format specifier to display variables in a specific
    way. In this case, we want to display the score always as four digits, adding
    zeros to the front of the string when needed, such as 0230 instead of 230 when
    the player has 230 points. In the format string %04d , the % specifies that we’ll
    be inserting a variable here, the 04 specifies that we want the string to always
    be four digits long with zeros in front, and the d specifies that the variable
    we’re inserting is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2346]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2347]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2348]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2349]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2350]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2351]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2352]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2353]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](text00029.html#ch17tab1) lists some examples of common string
    format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2354]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2355]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2356]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2357]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2358]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2359]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2360]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2361]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Common String Format Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2362]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2363]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2364]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2365]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2366]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2367]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2368]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2369]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Used to insert an Integer |'
  prefs: []
  type: TYPE_TB
- en: '| %f | Used to insert a Double , Float , or CGFloat |'
  prefs: []
  type: TYPE_TB
- en: '| %@ | Used to insert a String or other object |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Used to insert a percent sign into the string |'
  prefs: []
  type: TYPE_TB
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2370]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2371]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2372]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2373]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2374]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2375]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2376]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2377]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-2](text00029.html#ch17tab2) lists a few examples of string format
    specifiers used to get different number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2378]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2379]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2380]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2381]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2382]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2383]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2384]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2385]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** String Format Specifiers in Action'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2386]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2387]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2388]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2389]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2390]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2391]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2392]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2393]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %05d | 123 | 00123 |'
  prefs: []
  type: TYPE_TB
- en: '| %.2f | 1.0 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| %.3f | 33.0 | 33.000 |'
  prefs: []
  type: TYPE_TB
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2394]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2395]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2396]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2397]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2398]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2399]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2400]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2401]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Using the String(format:) method is a handy way to get labels to look the way
    you want them to. Forcing our score label to always show four digits ensures that
    it will look consistent as the score changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2402]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2403]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2404]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2405]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2406]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2407]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2408]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2409]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE PLAYER’S SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2410]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2411]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2412]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2413]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2414]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2415]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2416]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2417]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: whenever a new game starts, the score should be 0 . Add
    this line to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2418]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2419]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2420]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2421]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2422]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2423]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2424]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2425]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2426]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2427]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2428]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2429]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2430]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2431]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2432]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2433]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2434]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2435]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2436]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2437]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2438]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2439]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2440]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2441]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next let’s create a method that can add some points to the player’s score based
    on how long they’ve survived. Add the following method after the updateSkater()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2442]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2443]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2444]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2445]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2446]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2447]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2448]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2449]'
  prefs: []
  type: TYPE_PRE
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2450]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2451]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2452]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2453]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2454]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2455]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Since we only want to update the score label once per second, we’ve declared
    this method to take a parameter of the currentTime . The currentTime is passed
    automatically by SpriteKit into the update(_:) method, so we’ll just pass that
    currentTime into this scoring method when we call it. We use the currentTime to
    calculate how much time has elapsed since the last time we updated the score label
    ➊ . If more than one second has elapsed, then we increase the player’s score by
    adding the scrollSpeed ➋ . We could just add an amount like 10 to the score, but
    using the scrollSpeed makes the player’s score go up faster as they get further
    into the game, because the scrollSpeed keeps increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2456]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2457]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2458]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2459]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2460]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2461]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Then at ➌ , we set our lastScoreUpdateTime tracker equal to the current time.
    This way, next time we calculate the elapsed time, we’ll be able to check if one
    second has passed since the current time. Finally, we make a call to our updateScoreLabelText()
    method, which will make the score label display the new score .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2462]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2463]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2464]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2465]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2466]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2467]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is call the updateScore(withCurrentTime) method from
    within our main game loop, or update(_:) method. Add this line of code into the
    update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2468]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2469]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2470]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2471]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2472]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2473]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2474]'
  prefs: []
  type: TYPE_PRE
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2475]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2476]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2477]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2478]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2479]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: This will call the new method to update the score every time update(_:) is called.
    Run the game now, and watch the score go up! You may notice that collecting gems
    doesn’t increase the score. Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2480]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2481]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2482]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2483]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2484]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE GEMS VALUABLE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2485]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2486]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2487]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2488]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2489]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all of our score tracking and updating is set up, adding new scoring
    elements is simple. We already know when the player collects a gem because of
    the work we did in the didBegin(_:) method. Add this code to the didBegin(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2490]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2491]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2492]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2493]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2494]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2495]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2496]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2497]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2498]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2499]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2500]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2501]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2502]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2503]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2504]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Simple, right? At the point in the code where we know the player got a gem ,
    we just add 50 to the score variable and call our updateScoreLabelText() method.
    Now collecting gems pays.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2505]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2506]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2507]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2508]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you may have noticed is that our high score just sits there
    at 0 . Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2509]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2510]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2511]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2512]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE HIGH SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2513]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2514]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2515]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2516]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the high score label, add the following method just after the updateScoreLabelText()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2517]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2518]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2519]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2520]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2521]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2522]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2523]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2524]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2525]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2526]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2527]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2528]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is exactly the same as the updateScoreLabelText() method you added
    before, but it handles the high score. We only need to check if the player got
    a new high score at the end of every game. The gameOver() method we created is
    perfect for that. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2529]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2530]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2531]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2532]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2533]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2534]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: This code is pretty straightforward. When the game is over, we check if score
    is higher than the current highScore . If it is, then we set the highScore equal
    to the new score , and we update the high score label text. Try playing the game
    a few times now, and you should see the high score being tracked and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2535]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2536]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWEAKING THE GAMEPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2537]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2538]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Right now the game is pretty difficult. What if we wanted to make it easier?
    It’s our game, and we can change whatever we want, so let’s do it! The first thing
    we need to address is that when you start a game, there are sometimes gaps and
    multilevel platforms right away, so it’s impossible to survive more than a few
    seconds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2539]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2540]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our code that determines when to add a gap in the sidewalk so
    that there will be no gaps during the start of the game. The player’s score starts
    at 0 , so we can add a check for the player’s score being greater than 10 before
    we start adding gaps. Let’s also make it so the player’s score has to be greater
    than 20 before we start changing the platform level. And while we’re changing
    that code, we’ll also decrease the 5 percent chance for the gaps and the level
    changes to a 2 percent chance. Modify the updateBricks(withScrollAmount:) method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2541]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2542]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2543]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2544]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2545]'
  prefs: []
  type: TYPE_PRE
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2546]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now there will be fewer gaps and level changes, and they won’t show up right
    at the start of the game anymore. Run the game and see if it’s easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2547]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick change that will make the gameplay even easier is keeping the
    skater from being able to tip over. In the *Skater.swift* file, change the allowsRotation
    property of the physics body to false :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2548]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2549]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2550]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, you will probably survive a lot longer and get a higher
    score than before!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a whole bunch of game elements. You
    added varying sidewalk levels to force the player to jump up, gems the player
    can collect, a scoring system, and high-score tracking. You also learned about
    using random numbers to add variation to the gameplay and how to use labels to
    display information for the player.
  prefs: []
  type: TYPE_NORMAL
