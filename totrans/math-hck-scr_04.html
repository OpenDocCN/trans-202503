<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2-h" id="ch04"><span class="color2"><strong>4</strong></span></h2>&#13;
<h2 class="h2-hd"><span epub:type="pagebreak" id="page_59"/><strong>Finding Patterns in Sequences</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent">Humans are hardwired to look for patterns and predict what comes next. Patterns can be complicated in the real world, with lots of variables and outcomes in time (when will the moon be full again?) or space (is there a bear in that cave?). In this chapter, we’ll explore the patterns found in sequences of numbers. You’ll learn how to uncover the rules for how a sequence is formed and how to predict later numbers in the sequence.</p>&#13;
<h3 class="h3a" id="ch04lev1">What Are Sequences?</h3>&#13;
<p class="noindent">A <em>sequence</em> is just a list of numbers. The numbers are listed in a particular order—there’s a first number, a second number, a third number, and so on—so we can say that sequences are ordered, or <em>indexed</em>, by the positive integers. When we write about the mathematics of sequences, we often show the index numbers as subscripts. For example, we might write a sequence as <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, . . . , where each <em>a</em> is a value in the sequence, known as a <em>term</em> or an <em>element</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>Often, the numbers in a sequence tell a story about how they were generated. Maybe there’s a rule that describes a formula for taking an index number and manipulating it to produce the corresponding element of the sequence. For example, if we wanted to study the sequence of odd numbers (1, 3, 5, 7, . . .), we might describe the <em>n</em>th odd number as 2<em>n</em> – 1. We could arrive at this formula by thinking about the even numbers as multiples of 2 and odd numbers as 1 less than even numbers. We can do a quick check to make sure this works: the first odd number is when index <em>n</em> = 1, and 2 ⋅ 1 – 1 = 1. Next, when <em>n</em> = 2, we get 2<em>n</em> – 1 = 2 ⋅ 2 – 1 = 3, and so on. We can make the pattern explicit by saying <em>a</em><sub><em>n</em></sub> = 2<em>n</em> – 1, or, in words, <em>double the index and subtract one</em>.</p>&#13;
<p class="indent">Maybe each index <em>n</em> represents a mathematical object, like a geometric shape, and the corresponding number in the sequence can be found by examining or counting some feature of the object. For example, if we let each <em>n</em> represent a square of side length <em>n</em>, we might be interested in the sequence of the squares’ areas (1, 4, 9, 16, . . .). Or maybe we’d want the sequence of the squares’ perimeters instead (4, 8, 12, 16, . . .).</p>&#13;
<h4 class="h4o" id="ch04lev2">Finding the Next Value in a Sequence</h4>&#13;
<p class="noindent">It may be possible to find a formula for a sequence like the ones just described that’s based on a geometric or logical pattern. That formula can then give us useful insight into what’s going on with the sequence. For example, we might notice that the numbers in the area sequence are all perfect squares and recognize that this has to do with a square’s area being a product of its length and width. Likewise, we might notice that the numbers in the perimeter sequence are all multiples of 4 and find a reason for this in a square’s four equal sides. If we write the sequence of areas as <em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>3</sub>, . . . , and the sequence of perimeters as <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, <em>p</em><sub>3</sub>, . . . , we might then find the formulas <em>s</em><sub><em>n</em></sub> = <em>n</em><sup>2</sup> and <em>p</em><sub><em>n</em></sub> = 4<em>n</em>. These formulas are correct algebraically, but we arrived at them based on the geometric descriptions of the sequences.</p>&#13;
<p class="indent">Sometimes a sequence’s pattern is best described by providing a recipe to produce later terms in the sequence based on earlier terms. A <em>recurrence</em> does this by giving a formula for <em>a</em><sub><em>n</em></sub> that’s based not on the index <em>n</em> but on the values of previous elements. For example, the perimeter sequence could be generated by noting that <em>p</em><sub>1</sub> = 4 and that each perimeter is 4 more than the previous one. The element before the element with index <em>n</em> has index <em>n</em> – 1, so the formula could be <em>p</em><sub><em>n</em></sub> = <em>p</em><sub><em>n</em> – 1</sub> + 4. As long as we have the starting value (which is <em>p</em><sub>1</sub>), we can generate the rest of the sequence.</p>&#13;
<p class="indent">The sequence of square areas also follows its own, more subtle recurrence. Given the starting element <em>s</em><sub>1</sub> = 1, any later element <em>s</em><sub><em>n</em></sub> can be calculated as <em>s</em><sub><em>n</em> – 1</sub> + 2<em>n</em> – 1. This gives us another way to describe the sequence. In general, to specify a sequence by a recurrence you must provide an initial value (such as <em>p</em><sub>1</sub> = 4) and a rule of formation (such as <em>p</em><sub><em>n</em></sub> = <em>p</em><sub><em>n</em> – 1</sub> + 4). Recurrences can sometimes depend on two or more preceding terms instead of just one, in which case two or more initial values must be given. A famous example is the Fibonacci sequence, which we’ll explore soon.</p>&#13;
<h4 class="h4o" id="ch04lev3"><span epub:type="pagebreak" id="page_61"/>Making Sequences in Scratch</h4>&#13;
<p class="noindent">In Scratch, we can represent sequences as lists. A Scratch list can hold numbers or strings and can be up to 200,000 items long, which is generous for exploring patterns. Unlike many other programming languages, which index list items starting from 0, Scratch indexes its lists starting from 1. This quirk makes Scratch lists especially useful for representing sequences, which are also typically indexed starting from 1. As mentioned in <a href="ch03.xhtml#ch03">Chapter 3</a>, when Scratch displays a list on the stage, it includes the index numbers down the left side, so you can easily see an item’s position in the sequence. If the list is too long to fit on the stage, you can scroll down to see the later entries.</p>&#13;
<p class="indent">The Scratch blocks for working with lists are shown in <a href="ch04.xhtml#ch4fig1">Figure 4-1</a>. These blocks are available in the Variables section of the block palette.</p>&#13;
<div class="image"><img id="ch4fig1" src="../images/pg81_Image_85.jpg" alt="Image" width="666" height="489"/></div>&#13;
<p class="figcap"><em>Figure 4-1: Scratch’s list manipulation blocks</em></p>&#13;
<p class="indent">Notice that, as well as adding items at the end of a list, we can insert items at any position in the list, which causes the indices of later items to shift (increase) by 1. We can delete list items, which also shifts the later index numbers (reducing them by 1), and we can replace list items with other items, which leaves the later indices unchanged. We can look up an item’s index to see where in the list it occurs, and we can check if an item occurs in the list at all. We can also see how long the list is.</p>&#13;
<h4 class="h4" id="ch04lev4">Project 14: Fibonacci’s Rabbits</h4>&#13;
<p class="noindent">In this project, we’ll explore the <em>Fibonacci numbers</em>, a famous sequence described by a <em>two-term recurrence</em>. This means each number in the sequence is calculated based on the previous two. The sequence was first mentioned in western Europe in the book <em>Liber Abaci</em>, written by an Italian mathematician named Fibonacci in 1202. Fibonacci used the sequence to describe the growth of a population of rabbits.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_62"/>After we’re given the first two numbers in the Fibonacci sequence, <em>f</em><sub>1</sub> = 1 and <em>f</em><sub>2</sub> = 1, every other number is found using this rule of formation:</p>&#13;
<div class="imagec"><img src="../images/pg82_Image_86.jpg" alt="Image" width="180" height="23"/></div>&#13;
<p class="noindent">In other words, we add the two previous numbers in the sequence to get the next one. The third number is 1 + 1 = 2, the fourth is 1 + 2 = 3, the fifth is 2 + 3 = 5, and so on. For more, we can let Scratch do the work, as in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>.</p>&#13;
<div class="image"><img id="ch4fig2" src="../images/pg82_Image_87.jpg" alt="Image" width="407" height="685"/></div>&#13;
<p class="figcap"><em>Figure 4-2: Generating the Fibonacci sequence using a two-term recurrence</em></p>&#13;
<p class="indent">Notice in this code that to generate numbers in a two-term recurrence, we need to keep track of only the previous two values to calculate the next one. We first set the variables named <code>oldold</code> and <code>old</code> to the starting values (<code>1</code> and <code>1</code>). Then, in a loop <span class="ent">❶</span>, we assign the <code>new</code> variable their sum, replace <code>oldold</code> with <code>old</code>, and replace <code>old</code> with <code>new</code>. With these replacements, we’re ready to calculate the next value of <code>new</code> the next time through the loop.</p>&#13;
<h4 class="h4" id="ch04lev5">Project 15: The Golden Ratio</h4>&#13;
<p class="noindent">An interesting fact about the Fibonacci sequence is that the ratios of successive numbers approach a limiting value, meaning the value of <em>f</em><sub><em>n</em></sub> divided by <em>f</em><sub><em>n</em> – 1</sub> gets closer and closer to a particular number (the <em>limit</em>) as the sequence goes on, <span epub:type="pagebreak" id="page_63"/>without ever quite reaching it. This is known as a <em>convergent ratio</em>. For Fibonacci numbers, the limit is a famous mathematical constant called the <em>golden ratio</em>. Its exact value is:</p>&#13;
<div class="imagec"><img src="../images/pg83_Image_88.jpg" alt="Image" width="220" height="62"/></div>&#13;
<p class="indent">To prove that the Fibonacci numbers have a convergent ratio, we can modify the code from the previous project, adding another list that keeps track of the ratios of each number with the previous number in the sequence. <a href="ch04.xhtml#ch4fig3">Figure 4-3</a> shows how.</p>&#13;
<div class="image"><img id="ch4fig3" src="../images/pg83_Image_89.jpg" alt="Image" width="463" height="747"/></div>&#13;
<p class="figcap"><em>Figure 4-3: Tracking the ratios of successive Fibonacci terms</em></p>&#13;
<p class="indent">The code is similar to <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>, but with an extra list to keep track of the <code>Fibonacci ratio</code>. We update this list with the value of <code>old / oldold</code> before calculating the next term in the sequence <span class="ent">➋</span>. We let the list go through 40 iterations <span class="ent">➊</span> because that’s where the value of the ratio stabilizes.</p>&#13;
<h5 class="h5" id="ch04lev6">The Results</h5>&#13;
<p class="noindent"><a href="ch04.xhtml#ch4fig4">Figure 4-4</a> shows the initial results in the two lists after running the code shown in <a href="ch04.xhtml#ch4fig3">Figure 4-3</a>. You’ll have to scroll down to see the later values in the lists.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_64"/><img id="ch4fig4" src="../images/pg84_Image_90.jpg" alt="Image" width="580" height="629"/></div>&#13;
<p class="figcap"><em>Figure 4-4: The first Fibonacci numbers and their ratios</em></p>&#13;
<p class="indent">The <code>Fibonacci</code> list shows the Fibonacci sequence itself, while the <code>Fibonacci ratio</code> list shows the ratio between each term and the one that follows it. As you can see, the ratios bounce around above and below their limiting value. If you wanted to stop the program early, taking the average of two successive list elements in <code>Fibonacci ratio</code> would give a better approximation of the limiting value than either element alone.</p>&#13;
<h5 class="h5" id="ch04lev7">Hacking the Code</h5>&#13;
<p class="noindent">We used a <code>repeat</code> loop to give the program what seemed like a reasonable number of terms to calculate, but it may be better to let it decide for itself how many terms it needs. For instance, we could have the program stop calculating Fibonacci numbers when the ratios have sufficiently converged to the limiting value. We could define this as the point when the ratio values are no longer changing, or when they change by less than a specified amount. <a href="ch04.xhtml#ch4fig5">Figure 4-5</a> shows a modified Fibonacci program that uses this approach.</p>&#13;
<p class="indent">This program no longer stores the Fibonacci numbers in a list, since we’re interested only in how long it takes for the ratios to converge. We use a <code>repeat until</code> loop <span class="ent">➊</span> to monitor the ratios as more terms are calculated, stopping when the difference between the current and previous ratio is less than <code>0.0000001</code>. This accuracy level is configurable, but if we use too many digits (too small a number), we’ll run into the limitations of the IEEE 754 floating-point representation.</p>&#13;
<p class="indent">Notice that the <code>repeat until</code> condition uses an absolute value function (<code>abs</code>). This is necessary because the ratios seesaw around the limiting value, alternately too big and too small. This means the difference we calculate is alternately positive and negative, so <code>abs</code> converts the negative values to positive.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_65"/><img id="ch4fig5" src="../images/pg85_Image_91.jpg" alt="Image" width="767" height="663"/></div>&#13;
<p class="figcap"><em>Figure 4-5: Stopping the program when the ratio converges</em></p>&#13;
<p class="indent">The program includes a variable called <code>count</code> to keep track of how many terms we need to get to the specified accuracy level. After the loop ends, the program stores the final ratio in the <code>ratio</code> variable <span class="ent">➋</span>. On the stage, only the first few digits of the ratio are shown, but you can click the ratio in the coding area to see all the digits that were calculated, as shown in <a href="ch04.xhtml#ch4fig6">Figure 4-6</a>.</p>&#13;
<div class="image"><img id="ch4fig6" src="../images/pg85_Image_92.jpg" alt="Image" width="455" height="137"/></div>&#13;
<p class="figcap"><em>Figure 4-6: Calculating the Fibonacci ratio</em></p>&#13;
<p class="indent">As an experiment, you might try setting the accuracy level to different values (<code>0.01</code>, <code>0.001</code>, . . .) to see how many terms it takes to reach that level of accuracy.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>4.1</strong></span> Try changing the starting conditions for the Fibonacci recurrence by using different initial values for <code>old</code> and <code>oldold</code> in the original Fibonacci <span epub:type="pagebreak" id="page_66"/>program (<a href="ch04.xhtml#ch4fig2">Figure 4-2</a>). Setting <code>old</code> to <code>2</code> and <code>oldold</code> to <code>1</code> wouldn’t be very interesting, since that just gives the Fibonacci sequence shifted by one number. Setting <code>old</code> to <code>1</code> and <code>oldold</code> to <code>2</code>, however, gives a different sequence, called the <em>Lucas sequence</em>. See if you can find any relationships between Lucas numbers and Fibonacci numbers.</p>&#13;
<p class="indentib"><span class="blue"><strong>4.2</strong></span> How could you make sense of Fibonacci numbers going backward? What should <em>f</em><sub>0</sub> be to preserve the recurrence? How about <em>f</em><sub>–1</sub> and <em>f</em><sub>–2</sub>? Program a recurrence for negative integers.</p>&#13;
<p class="indentib"><span class="blue"><strong>4.3</strong></span> Play with the code in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a> to explore its limits. How far can the Fibonacci sequence go before the numbers it generates exceed flintmax? How far before the numbers exceed the absolute limit for Scratch’s floating-point representation and are reported as <code>Infinity</code>? The rate of growth is exponential, so it doesn’t take many steps before flintmax is exceeded!</p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev8">Figurate Numbers</h3>&#13;
<p class="noindent"><em>Figurate numbers</em> come from sequences that count how many points it takes to build nested geometric figures. For example, in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a> we have squares that fit (“nest”) inside one another. The blue points are the points we want to count, in this case positioned on a grid. By drawing connections between the points, starting from the bottom-left corner, we can create increasingly larger squares that encompass more and more of the points.</p>&#13;
<div class="image"><img id="ch4fig7" src="../images/pg86_Image_93.jpg" alt="Image" width="273" height="272"/></div>&#13;
<p class="figcap"><em>Figure 4-7: Nested squares as figurate numbers</em></p>&#13;
<p class="indent">The word <em>square</em> can be a noun or a verb. As a noun, it names a geometric object, a polygon with four equal sides and four equal angles. As a verb, it’s more often used for arithmetic, to describe the process of multiplying a number by itself. Of course, the arithmetic and geometry are related. The formula <em>A</em> = <em>s</em><sup>2</sup>, used to calculate the area of a (geometric) square by multiplying the length of a side <em>s</em> by itself, interprets the arithmetic in a geometrical way. Numbers are squares if they’re the result of multiplying a positive integer by itself (1<sup>2</sup> = 1, 2<sup>2</sup> = 4, 3<sup>2</sup> = 9, 16, 25, . . .).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/><a href="ch04.xhtml#ch4fig7">Figure 4-7</a> shows how we can arrange square numbers of points to form ever-growing geometric squares. We have a square with 4 points (2 rows of 2) inside a square with 9 points (3 rows of 3) inside a square with 16 points (4 rows of 4) inside a square with 25 points (5 rows of 5). You can think of the bottom-left point itself as a square with 1 point, too. Each larger square adds a new set of connected points around the edges of the previous square.</p>&#13;
<p class="indent">In fact, any kind of polygon can be nested to make a sequence of figurate numbers like the sequence of squares, as we’ll explore next.</p>&#13;
<h4 class="h4" id="ch04lev9">Project 16: Square, Triangular, and Pentagonal Numbers?</h4>&#13;
<p class="noindent">The Scratch program in the next three figures draws nested <em>s</em>-sided polygons and counts the newly added points around the edges to generate a sequence. So far, we haven’t used many of Scratch’s graphics capabilities, but in this program we use the Pen extension to animate the drawing of various figures. (Click the <strong>Add Extensions</strong> icon in the bottom-left corner to add these Pen blocks.) Our program starts with the initial setup in <a href="ch04.xhtml#ch4fig8">Figure 4-8</a>.</p>&#13;
<div class="image"><img id="ch4fig8" src="../images/pg87_Image_94.jpg" alt="Image" width="674" height="709"/></div>&#13;
<p class="figcap"><em>Figure 4-8: The setup code for drawing nested polygons</em></p>&#13;
<p class="indent">This <code>initial setup</code> block erases previous drawings from the screen and asks the user for the number of sides (in the variable <code>number of sides</code>) and the number of polygons to nest (in the variable <code>reps</code>) <span class="ent">❶</span>. The calculation of <code>side length</code> <span class="ent">➋</span>, which is the distance on the stage between two adjacent points, makes sure the polygons will fit on the stage.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/><a href="ch04.xhtml#ch4fig9">Figure 4-9</a> shows the main logic of the program.</p>&#13;
<div class="image"><img id="ch4fig9" src="../images/pg88_Image_95.jpg" alt="Image" width="600" height="1027"/></div>&#13;
<p class="figcap"><em>Figure 4-9: Drawing the polygons</em></p>&#13;
<p class="indent">We draw the nested polygons in a loop that repeats <code>reps</code> times. We start drawing each polygon from the bottom-left corner, using the <code>go to</code> block to skip any dots that we’ve already drawn (since the polygons all share the same base). After drawing the first side with a custom <code>Draw n segment(s)</code> block, we rotate the pen <span class="ent">❶</span> depending on the number of sides of the polygon. The <code>counter</code> variable keeps track of the total number of points drawn. Once the current polygon is complete, we add <code>counter</code> to <code>end point list</code> <span class="ent">➋</span>. This list keeps track of how many points we’ve drawn at the end of each completed polygon, building up our figurate number sequence. We use a custom <code>Highlight point</code> block to specify how the points are drawn. <a href="ch04.xhtml#ch4fig10">Figure 4-10</a> shows these two custom blocks.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_69"/><img id="ch4fig10" src="../images/pg89_Image_96.jpg" alt="Image" width="841" height="763"/></div>&#13;
<p class="figcap"><em>Figure 4-10: Drawing points and lines</em></p>&#13;
<p class="indent">The <code>Draw n segment(s)</code> block takes <code>n</code> steps along the side of a polygon, first drawing a large dot (<code>pen size 5</code>) and then drawing a thin line (<code>pen size 1</code>) to connect with the next dot. The <code>wait</code> block calculates a pause between each step <span class="ent">❶</span>, but if you get tired of watching the drawing happen, you can speed it up by lowering the value in the numerator.</p>&#13;
<p class="indent">The custom <code>Highlight point</code> block simply changes the pen color to red and increases its size to mark the final dot in each polygon. Then, it changes the pen color back to blue and reduces the size again.</p>&#13;
<h5 class="h5" id="ch04lev10">The Results</h5>&#13;
<p class="noindent">Let’s use the drawing program to generate some sequences. For the number of sides <em>s</em> = 4 we get squares, both geometrically and arithmetically, as shown in <a href="ch04.xhtml#ch4fig11">Figure 4-11</a>. Geometrically, each added layer of dots around the existing ones forms a new, larger square. Arithmetically, the numbers accumulated in the <code>end point list</code> sequence are all perfect squares. We arrived at these numbers by counting points, starting from the lower-left corner and moving counterclockwise, expanding outward with each layer of nesting. As mentioned earlier, when we complete a square, the number of points counted so far is added to the list and the point is highlighted in red.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_70"/><img id="ch4fig11" src="../images/pg90_Image_97.jpg" alt="Image" width="572" height="547"/></div>&#13;
<p class="figcap"><em>Figure 4-11: Square figurate numbers</em></p>&#13;
<p class="indent">There’s no need to restrict ourselves to squares. <em>Triangular numbers</em> are the sequence generated by arranging points in nested equilateral triangles, as shown in <a href="ch04.xhtml#ch4fig12">Figure 4-12</a>.</p>&#13;
<div class="image"><img id="ch4fig12" src="../images/pg90_Image_98.jpg" alt="Image" width="621" height="535"/></div>&#13;
<p class="figcap"><em>Figure 4-12: Triangular figurate numbers</em></p>&#13;
<p class="indent">Notice that each triangular number is built by adding the next integer to the triangular number that came before: 1, 1 + 2 = 3, 1 + 2 + 3 = 6, 1 + 2 + 3 + 4 = 10, and so on. In other words, the <em>n</em>th triangular number is the sum of all the integers from 1 to <em>n</em>.</p>&#13;
<p class="indent">How can we describe the pattern of the sequence of triangular numbers with a formula? Think about putting a copy of the <em>n</em>th triangle next to itself, rotated to make a parallelogram, as shown in <a href="ch04.xhtml#ch4fig13">Figure 4-13</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_71"/><img id="ch4fig13" src="../images/pg91_Image_99.jpg" alt="Image" width="639" height="348"/></div>&#13;
<p class="figcap"><em>Figure 4-13: We can make a formula for triangular numbers by thinking about two triangles arranged to make a parallelogram.</em></p>&#13;
<p class="indent">The parallelogram has <em>n</em> + 1 dots across the bottom and <em>n</em> rows of dots, so there are <em>n</em>(<em>n</em> + 1) dots in all. Since the parallelogram was made with two copies of the triangle, each triangle has <em>n</em>(<em>n</em> + 1) / 2 dots in it. There’s the formula for the <em>n</em>th triangular number.</p>&#13;
<p class="indent">We can make another sequence of figurate numbers, which will be of use in <a href="ch07.xhtml#ch07">Chapter 7</a>, by counting points in nested pentagons. <a href="ch04.xhtml#ch4fig14">Figure 4-14</a> shows the sequence of <em>pentagonal numbers</em>.</p>&#13;
<div class="image"><img id="ch4fig14" src="../images/pg91_Image_100.jpg" alt="Image" width="732" height="523"/></div>&#13;
<p class="figcap"><em>Figure 4-14: Pentagonal figurate numbers</em></p>&#13;
<p class="indent">There are other interesting sequences hidden in the nested pentagons. For example, if you count the points and write down just the numbers of those along the green path in <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>, you get 1, 2, 6, 13, 23, 36, . . . , as the sequence. Another path that gives a sequence we’ll need in <a href="ch07.xhtml#ch07">Chapter 7</a> starts at 2 and goes up and to the right, along the purple path in <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>. Counting around the nested pentagons gives the numbers 2, 7, 15, 26, 40, 57, . . . , as the sequence.</p>&#13;
<h5 class="h5" id="ch04lev11"><span epub:type="pagebreak" id="page_72"/>Hacking the Code</h5>&#13;
<p class="noindent">Even if you set the wait time in the <code>Draw n segment(s)</code> block (<a href="ch04.xhtml#ch4fig10">Figure 4-10</a> <span class="ent">❶</span>) to <code>0</code>, there’s still a delay in drawing the polygons and reporting the values of the sequence of figurate numbers. If you want the results right away, you can speed up the program by using Turbo Mode (see <a href="ch04.xhtml#ch4fig15">Figure 4-15</a>).</p>&#13;
<div class="image"><img id="ch4fig15" src="../images/pg92_Image_101.jpg" alt="Image" width="798" height="135"/></div>&#13;
<p class="figcap"><em>Figure 4-15: Turning on Turbo Mode</em></p>&#13;
<p class="indent">Turbo Mode is a feature that eliminates the short pause that Scratch usually inserts after running blocks that update the screen. To turn it on, select <strong>Edit ▸ Turn on Turbo Mode</strong> in the Scratch Editor or hold down <small>SHIFT</small> while clicking the green flag button. When Turbo Mode is activated, there’s an indication in the menu bar.</p>&#13;
<h3 class="h3" id="ch04lev12">Predicting Values in a Sequence</h3>&#13;
<p class="noindent">Whenever you see the first few terms in a sequence, a natural question is “What comes next?” One possible answer is “Whatever you want!” If all you know is that there are some numbers listed one after the other, then any number can come next. But if you assume that the numbers mean something—that they’re generated by following some kind of rule—then figuring out what comes next requires discovering the rule and applying it to generate the later terms. There may be more than one rule that works, in which case you can pick the one that seems most natural or useful to you.</p>&#13;
<p class="indent">For example, consider the sequence of square numbers in <a href="ch04.xhtml#ch4fig11">Figure 4-11</a>. We could predict the next number in the sequence by finding the rule that the <em>n</em>th element in the sequence is <em>n</em><sup>2</sup>. The element after 9<sup>2</sup> = 81 should, then, be 10<sup>2</sup> = 100. Alternatively, we could notice that for each new (geometric) square, we’re building on the squares that came before by adding another shell of dots along the top and right sides. The <em>n</em>th shell adds the <em>n</em>th odd number (2<em>n</em> – 1) of points to the total (so the sequence could be described as 1, 1 + 3, 1 + 3 + 5, 1 + 3 + 5 + 7, . . .). This is an example of an <em>addition rule</em>, and it highlights a different aspect of the pattern. Thinking this way, we would get from the ninth number in the sequence (81) to the tenth number by adding (2 ⋅ 10) – 1 = 19, giving us 81 + 19 = 100. Either way, we make the same prediction, but we describe what’s going on differently.</p>&#13;
<h4 class="h4" id="ch04lev13">Project 17: Difference Tables Make All the Difference</h4>&#13;
<p class="noindent">One way to understand the pattern in a sequence built with some sort of addition rule is to undo the addition by doing a subtraction. A <em>difference table</em> for a sequence is another sequence built by subtracting each term of the original <span epub:type="pagebreak" id="page_73"/>sequence from the next one. In this project, we’ll explore how to use Scratch to create difference tables.</p>&#13;
<p class="indent">If one difference table isn’t enough to reveal a sequence’s pattern, we can create a second difference table by finding the differences between adjacent numbers in the first difference table. These are known as the <em>second differences</em> of the original sequence. If necessary, we can then make a third difference table based on the second, and so on. Sometimes, interesting patterns emerge from this process.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig16">Figure 4-16</a> shows some Scratch code to take in a sequence and generate its difference table.</p>&#13;
<div class="image"><img id="ch4fig16" src="../images/pg93_Image_102.jpg" alt="Image" width="833" height="825"/></div>&#13;
<p class="figcap"><em>Figure 4-16: Building a difference table to analyze a sequence</em></p>&#13;
<p class="indent">First, the <code>initialize</code> block clears out the data from the last time the program was run. Then, the <code>repeat until</code> loop <span class="ent">➊</span> prompts us to enter a sequence, one number at a time, until we let Scratch know we’re done by entering an <code>x</code>. The sequence is stored in the <code>seq</code> list. We then build the first difference table in the <code>1st</code> list by calculating the differences between adjacent values in the sequence <span class="ent">➋</span>.</p>&#13;
<p class="indent">The additional code in <a href="ch04.xhtml#ch4fig17">Figure 4-17</a> finds the second and third differences, storing them in the <code>2nd</code> and <code>3rd</code> lists.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_74"/><img id="ch4fig17" src="../images/pg94_Image_103.jpg" alt="Image" width="747" height="769"/></div>&#13;
<p class="figcap"><em>Figure 4-17: Calculating the second and third differences</em></p>&#13;
<p class="indent">This code segment follows the same pattern we used to calculate the first difference table, except we use the <code>1st</code> and <code>2nd</code> lists as input instead of using <code>seq</code>.</p>&#13;
<h5 class="h5" id="ch04lev14">The Results</h5>&#13;
<p class="noindent"><a href="ch04.xhtml#ch4fig18">Figure 4-18</a> shows the result of running the difference table program for the first several values from the sequence of squares: 1, 4, 9, 16, 25, 36, 49, 64, and 81.</p>&#13;
<div class="image"><img id="ch4fig18" src="../images/pg94_Image_104.jpg" alt="Image" width="744" height="457"/></div>&#13;
<p class="figcap"><em>Figure 4-18: Difference tables for the sequence of squares</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_75"/>The first difference table confirms what we discussed earlier: the differences are successive odd numbers, meaning the <em>n</em>th number in the sequence is the sum of the first <em>n</em> odd numbers. The second differences are constant: they’re all equal to 2, since successive odd numbers are always 2 apart. The third differences are all 0.</p>&#13;
<p class="indent">Third differences of 0 are a dead giveaway that the sequence’s underlying rule of formation can be given as a <em>quadratic polynomial</em>, an expression of the form <em>ax</em><sup>2</sup> + <em>bx</em> + <em>c</em>. Writing the rule of formation then becomes a matter of determining the values of <em>a</em>, <em>b</em>, and <em>c</em>, known as <em>coefficients</em>. For the sequence of square numbers, it’s especially easy to write the quadratic polynomial: we can use <em>a</em> = 1, <em>b</em> = 0, and <em>c</em> = 0. This gives us:</p>&#13;
<div class="imagec"><img src="../images/pg95_Image_105.jpg" alt="Image" width="197" height="25"/></div>&#13;
<p class="indent">For the triangular numbers from <a href="ch04.xhtml#ch4fig13">Figure 4-13</a>, we can use <em>a</em> = 1/2, <em>b</em> = 1/2, and <em>c</em> = 0. Then we get:</p>&#13;
<div class="imagec"><img src="../images/pg95_Image_106.jpg" alt="Image" width="383" height="62"/></div>&#13;
<p class="noindent">This is the same rule we arrived at before by treating two copies of the triangle as a parallelogram.</p>&#13;
<h5 class="h5" id="ch04lev15">Hacking the Code</h5>&#13;
<p class="noindent">Here’s a Scratch trick to make programs with lists easier to use. Suppose you have a list of numbers from another program—for example, the pentagonal numbers you generated with the code from <a href="ch04.xhtml#ch04lev9">Project 16</a> (<a href="ch04.xhtml#ch4fig14">Figure 4-14</a>)—and you want to bring them into your difference table program for analysis. Rather than copying over the numbers by hand, one by one, you can export the whole list from that project by right-clicking it and selecting <strong>Export</strong> (see <a href="ch04.xhtml#ch4fig19">Figure 4-19</a>). This will save the list as a text file called <em>end point list.txt</em> (or whatever the name of the list is) in your default directory.</p>&#13;
<div class="image"><img id="ch4fig19" src="../images/pg95_Image_107.jpg" alt="Image" width="725" height="573"/></div>&#13;
<p class="figcap"><em>Figure 4-19: Saving a list for later use</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>To use that list in the difference table program, ignore the prompt to enter a number and instead right-click the <code>seq</code> list on the stage. Click <strong>Import</strong>, as shown in <a href="ch04.xhtml#ch4fig20">Figure 4-20</a>, and select the file you just saved to upload it.</p>&#13;
<div class="image"><img id="ch4fig20" src="../images/pg96_Image_108.jpg" alt="Image" width="791" height="498"/></div>&#13;
<p class="figcap"><em>Figure 4-20: Recovering a list for further work</em></p>&#13;
<p class="indent">The <code>seq</code> list will now be populated with the pentagonal numbers, so you need to enter only an <code>x</code> into the prompt to have the differences calculated. <a href="ch04.xhtml#ch4fig21">Figure 4-21</a> shows the results.</p>&#13;
<div class="image"><img id="ch4fig21" src="../images/pg96_Image_109.jpg" alt="Image" width="794" height="472"/></div>&#13;
<p class="figcap"><em>Figure 4-21: Difference tables for the sequence of pentagonal numbers</em></p>&#13;
<p class="indent">What do you know? Again, the third differences are all 0, so the sequence of pentagonal numbers can be generated using a quadratic polynomial too!</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><span epub:type="pagebreak" id="page_77"/><img class="middle" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>4.4</strong></span> Write a Scratch program that takes any sequence with third differences of 0 and recovers the coefficients <em>a</em>, <em>b</em>, and <em>c</em> for that sequence’s quadratic polynomial, <em>ax</em><sup>2</sup> + <em>bx</em> + <em>c</em>. Use the program to find the coefficients for the pentagonal numbers. If all you want is the pentagonal number formula, it might help to draw the <em>n</em>th pentagon the way a young child draws a house, as a square with a triangular roof on top, and see it as the <em>n</em>th square with the (<em>n</em> – 1)st triangle on top.</p>&#13;
<p class="indentib"><span class="blue"><strong>4.5</strong></span> If you exported the list of primes generated by the sieving program from <a href="ch02.xhtml#ch02lev10">Project 7</a>, import it into the difference table program and see what happens. The first few results are shown here. As you can see, there isn’t such a neat pattern of differences. Write some code to find the largest difference in the table of first differences.</p>&#13;
<div class="image"><img src="../images/pg97_Image_110.jpg" alt="Image" width="793" height="631"/></div>&#13;
<p class="indentib"><span class="blue"><strong>4.6</strong></span> Generate a sequence with this rule: the <em>n</em>th term of the sequence is the number of occurrences of the digit 1 in the binary representation of <em>n</em>. This sequence starts 1, 1, 2, 1, 2, 2, 3, . . . , (from counting 1s in the binary sequence 1, 10, 11, 100, 101, 110, 111, . . .). Write a Scratch program to calculate a few hundred terms of this sequence and see if you can find either a formula or a recurrence relation to predict future terms.</p>&#13;
<p class="indentib"><span epub:type="pagebreak" id="page_78"/><span class="blue"><strong>4.7</strong></span> What happens when you make a difference table of the Fibonacci sequence?</p>&#13;
<p class="indentib"><span class="blue"><strong>4.8</strong></span> What happens when you make a difference table of the sequence of powers of 2?</p>&#13;
<p class="indentib"><span class="blue"><strong>4.9</strong></span> Try creating a difference table of the sequence of cubes (1, 8, 27, 64, 125, . . .). You can extend the code from <a href="ch04.xhtml#ch4fig17">Figure 4-17</a> to get higher differences to explore difference tables for higher-degree polynomials.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev16">Conclusion</h3>&#13;
<p class="noindent">Lists in Scratch are great for keeping track of sequences of numbers, and list arithmetic helps us make sense of the patterns that show up. Scratch graphics use geometry to animate sequences of figurate numbers, and difference tables make the patterns in these sequences easier to see. Scratch Cat has all the answers—your job is to ask the questions!</p>&#13;
</div>
</div>
</body></html>