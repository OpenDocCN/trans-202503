- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 12 MIC AND WEBCAM MONITOR
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12 麦克风和摄像头监控
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In “Shut Up and Dance,” a poignant episode of the TV show *Black Mirror*, hackers
    infect a young teenager’s computer with malware, spy on him through his webcam,
    then blackmail him into performing criminal acts. Coincidentally, shortly before
    the episode aired, I found myself reverse engineering an intriguing piece of Mac
    malware known as FruitFly that did something very similar.^([1](#chapter12-1))
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在电视剧《黑镜》中的一集感人剧集《闭嘴并跳舞》中，黑客通过恶意软件感染一名年轻少年的电脑，通过摄像头监视他，然后勒索他实施犯罪行为。巧合的是，就在该剧集播出前，我开始逆向工程一个名为FruitFly的Mac恶意软件，它做的事情与此非常相似。^([1](#chapter12-1))
- en: This persistent backdoor had many capabilities, including the ability to spy
    on its victims’ webcams by leveraging archaic QuickTime APIs. Although these APIs
    activated a camera’s LED indicator light, the malware had a rather insidious trick
    up its sleeve to attempt to remain undetected; it waited until the victim was
    inactive before triggering the spying logic. As a result, the victim likely didn’t
    notice that their webcam had been surreptitiously activated.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个持久的后门程序具有多种功能，其中之一就是通过利用过时的QuickTime API来监视受害者的摄像头。虽然这些API会激活摄像头的LED指示灯，但恶意软件有一个相当阴险的手段，试图保持不被发现；它会等到受害者处于非活动状态后才触发监视逻辑。结果，受害者很可能没有注意到他们的摄像头已经被悄悄激活。
- en: My investigation of the malware intersected with an FBI operation that led to
    the arrest of the alleged creator and revealed FruitFly’s insidious reach. According
    to a Justice Department press release and indictment, the creator had installed
    FruitFly on thousands of computers over the course of 13 years.^([2](#chapter12-2))
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我对该恶意软件的调查与FBI的行动交集，最终导致了涉嫌创建者的逮捕，并揭示了FruitFly的深远影响。根据司法部的新闻稿和起诉书，该创建者在13年的时间里在数千台计算机上安装了FruitFly。^([2](#chapter12-2))
- en: Apple eventually took steps to mitigate this threat, such as creating XProtect
    detection signatures. Even so, FruitFly remains a stark reminder of the very real
    dangers Mac users can face, despite Apple’s best efforts. FruitFly isn’t even
    the only Mac malware that spies on its victims through the webcam. Others include
    Mokes, Eleanor, and Crisis.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，苹果采取了措施来缓解这一威胁，例如创建了XProtect检测签名。即便如此，FruitFly依然是一个鲜明的警示，提醒Mac用户即使苹果尽最大努力，仍可能面临非常现实的风险。FruitFly甚至不是唯一一个通过摄像头监视受害者的Mac恶意软件。其他包括Mokes、Eleanor和Crisis。
- en: To address these threats, I released OverSight, a utility that monitors a Mac’s
    built-in mic and webcam, as well as any external connected audio and video devices,
    and alerts the user about any unauthorized access. In this chapter, I’ll explain
    how OverSight monitors these devices. I’ll also demonstrate how this tool ingests
    system log messages filtered via custom predicates to identify the process responsible
    for the device access.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些威胁，我发布了OverSight，一款监控Mac内置麦克风和摄像头，以及任何外部连接的音频和视频设备的工具，能够在检测到未经授权的访问时提醒用户。在本章中，我将解释OverSight是如何监控这些设备的。我还将演示这个工具是如何通过自定义谓词过滤系统日志消息，以识别负责设备访问的进程。
- en: You can find OverSight’s full source code in the Objective-See GitHub repository
    at [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/OverSight*](https://github.com/objective-see/OverSight).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Objective-See的GitHub仓库中找到OverSight的完整源代码：[*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/OverSight*](https://github.com/objective-see/OverSight)。
- en: Tool Design
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具设计
- en: In a nutshell, OverSight alerts the user whenever their Mac’s mic or webcam
    activates and, most importantly, identifies the responsible process. Thus, whenever
    malware such as FruitFly attempts to access the camera or mic, this action will
    trigger an OverSight alert. While OverSight doesn’t attempt to classify the process
    as benign or malicious by design, it provides options for users to either allow
    or block the process or to exempt trusted processes ([Figure 12-1](chapter12.xhtml#fig12-1)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，OverSight会在Mac的麦克风或摄像头被激活时提醒用户，并且最重要的是，它能够识别出负责的进程。因此，每当像FruitFly这样的恶意软件试图访问摄像头或麦克风时，都会触发OverSight的警报。虽然OverSight的设计并不试图对进程进行良性或恶性分类，但它提供了选项让用户允许或阻止进程，或者豁免受信任的进程（[图12-1](chapter12.xhtml#fig12-1)）。
- en: '![](../images/Figure12-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-1.jpg)'
- en: 'Figure 12-1: OverSight provides the option to always allow a certain tool to
    access the mic and webcam.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1：OverSight提供了一个选项，允许某个工具始终访问麦克风和摄像头。
- en: The Allow (Once) option essentially takes no action, as OverSight receives notifications
    once the device activation has already occurred. However, the Allow (Always) option
    provides a simple way for users to create rules that keep trusted processes, such
    as FaceTime or Zoom, from generating alerts in the future. Finally, the Block
    option will terminate the process by sending it a kill signal (SIGKILL).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 允许（一次）选项本质上不执行任何操作，因为 OverSight 会在设备激活后收到通知。然而，允许（始终）选项提供了一种简单的方法，允许用户创建规则，以防止将来受信任的进程（如
    FaceTime 或 Zoom）生成警报。最后，阻止选项将通过向进程发送终止信号（SIGKILL）来终止该进程。
- en: Compared to tools such as BlockBlock, which contains various components and
    XPC communications, OverSight is relatively simple. It’s a self-contained, stand-alone
    app able to perform its mic and webcam monitoring duties with standard user privileges.
    Let’s explore exactly how OverSight achieves this monitoring and, more importantly,
    identifies the responsible process. We’ll see that the former is easy thanks to
    various CoreAudio and CoreMediaIO APIs, while the latter is a more challenging
    task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与包含各种组件和 XPC 通信的工具（如 BlockBlock）相比，OverSight 相对简单。它是一个自包含的独立应用程序，能够在标准用户权限下执行麦克风和摄像头的监控任务。让我们深入探讨一下
    OverSight 如何实现这些监控功能，更重要的是，如何识别负责的进程。我们会发现，前者通过各种 CoreAudio 和 CoreMediaIO API
    变得容易，而后者则是一个更具挑战性的任务。
- en: Mic and Camera Enumeration
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 麦克风和摄像头枚举
- en: To receive a notification that a process has activated or deactivated each connected
    mic or webcam, OverSight adds to each device what is known as a property listener
    for the “is running somewhere” property, kAudioDevicePropertyDeviceIsRunningSomewhere.
    Because the APIs to add such a listener require a device ID, let’s first look
    at how we can enumerate mic and camera devices and then extract each device’s
    ID.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收关于每个连接的麦克风或摄像头已激活或已停用的通知，OverSight 会为每个设备添加一个属性监听器，该监听器用于监听“某处正在运行”属性，kAudioDevicePropertyDeviceIsRunningSomewhere。由于添加此类监听器的
    API 需要设备 ID，我们首先来看看如何枚举麦克风和摄像头设备，并提取每个设备的 ID。
- en: The AVFoundation^([3](#chapter12-3)) class AVCaptureDevice^([4](#chapter12-4))
    exposes the class method devicesWithMediaType:, which takes a media type as an
    argument ([Listing 12-1](chapter12.xhtml#Lis12-1)). To enumerate audio devices
    such as mics, we use the constant AVMediaTypeAudio. To enumerate video devices,
    we use AVMediaTypeVideo. The method returns an array of AVCaptureDevice objects
    that match the specified media type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: AVFoundation^([3](#chapter12-3)) 类 AVCaptureDevice^([4](#chapter12-4)) 提供了一个类方法
    devicesWithMediaType:，该方法以媒体类型作为参数（见 [列表 12-1](chapter12.xhtml#Lis12-1)）。要枚举音频设备（如麦克风），我们使用常量
    AVMediaTypeAudio。要枚举视频设备，我们使用 AVMediaTypeVideo。该方法返回一个 AVCaptureDevice 对象的数组，这些对象与指定的媒体类型匹配。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 12-1: Enumerating all audio and video devices'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-1：枚举所有音频和视频设备
- en: 'Compiling and running the code in [Listing 12-1](chapter12.xhtml#Lis12-1) outputs
    the following on my system, which shows my Mac’s built-in microphone and webcam
    and also a pair of connected headphones:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行 [列表 12-1](chapter12.xhtml#Lis12-1) 中的代码，在我的系统上输出如下，显示了我的 Mac 内建的麦克风和摄像头，以及一副连接的耳机：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can access the device’s name, such as FaceTime HD Camera, in the localizedName
    property of each AVCaptureDevice object. You may also want to make use of other
    object properties such as modelID, manufacturer, and deviceType to monitor only
    a subset of devices. For example, you might choose to monitor only devices built
    into your Mac.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过每个 AVCaptureDevice 对象的 localizedName 属性访问设备的名称，如 FaceTime HD Camera。你也可以利用其他对象属性，如
    modelID、manufacturer 和 deviceType，仅监控部分设备。例如，你可能只选择监控你 Mac 内建的设备。
- en: Audio Monitoring
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 音频监控
- en: 'To set a property listener on each audio device so you can receive activation
    and deactivation notifications, OverSight implements a helper method named watchAudioDevice:
    that takes a pointer to an AVCaptureDevice object. For each device of type AVMediaTypeAudio,
    OverSight invokes this helper.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '为了在每个音频设备上设置属性监听器，以便接收激活和停用通知，OverSight 实现了一个名为 watchAudioDevice: 的辅助方法，该方法接受一个指向
    AVCaptureDevice 对象的指针。对于每个 AVMediaTypeAudio 类型的设备，OverSight 会调用这个辅助方法。'
- en: 'At the core of this method is a call to the AVFoundation AudioObjectAddPropertyListenerBlock
    function, defined in the AVFoundation *AudioHardware.h* header file as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的核心是调用 AVFoundation 中的 AudioObjectAddPropertyListenerBlock 函数，该函数在 *AudioHardware.h*
    头文件中定义如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first parameter is an ID for the audio object, for which we can register
    a property listener. Each AVCaptureDevice object has an object property named
    connectionID containing this required ID, but it isn’t publicly exposed. This
    means we can’t access it directly by writing code such as audioDevice.connectionID.
    However, as noted elsewhere in this book, you can access private properties either
    by extending the object’s definition or by using the performSelector:withObject:
    method.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是音频对象的ID，我们可以为其注册属性监听器。每个`AVCaptureDevice`对象都有一个名为`connectionID`的对象属性，包含所需的ID，但该属性没有公开。这意味着我们不能通过编写诸如`audioDevice.connectionID`这样的代码直接访问它。然而，正如本书其他地方所提到的，您可以通过扩展对象的定义或使用`performSelector:withObject:`方法来访问私有属性。
- en: 'OverSight uses the latter approach. You’ll find the logic to obtain the private
    device ID from an AVCaptureDevice object in a helper method named getAVObjectID:
    ([Listing 12-2](chapter12.xhtml#Lis12-2)).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverSight`使用了后一种方法。您可以在名为`getAVObjectID:`的辅助方法中找到从`AVCaptureDevice`对象获取私有设备ID的逻辑（[示例
    12-2](chapter12.xhtml#Lis12-2)）。'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 12-2: Obtaining a device’s private ID'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-2：获取设备的私有ID
- en: In Objective-C, you can access object properties, including private ones, by
    invoking a method on the object that matches the property’s name. You can refer
    to these methods, or indeed any methods, by their names using selectors. Represented
    by the SEL type, Objective-C selectors are really just pointers to strings that
    represent the name of the method. In [Listing 12-2](chapter12.xhtml#Lis12-2),
    you can see that the code first creates a selector for the connectionID property
    using the NSSelectorFromString API ❶.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，您可以通过调用与属性名称匹配的对象方法来访问对象属性，包括私有属性。您可以通过选择器按名称引用这些方法，或者任何方法。`SEL`类型表示的Objective-C选择器实际上只是指向表示方法名称的字符串的指针。在[示例
    12-2](chapter12.xhtml#Lis12-2)中，您可以看到代码首先使用`NSSelectorFromString`API❶为`connectionID`属性创建了一个选择器。
- en: 'Because connectionID is a private property, nothing is stopping Apple from
    renaming it or removing it altogether. For that reason, the code invokes the respondsToSelector:
    method to make sure it’s still found on the AVCaptureDevice object; if not, it
    bails. You should always make use of the respondsToSelector: method before attempting
    to access private properties or invoking private methods; otherwise, your program
    risks crashing with a doesNotRecognizeSelector exception.^([5](#chapter12-5))'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`connectionID`是一个私有属性，所以没有什么能阻止Apple重命名或完全移除它。因此，代码调用`respondsToSelector:`方法来确保它仍然存在于`AVCaptureDevice`对象上；如果没有找到，它就会退出。在尝试访问私有属性或调用私有方法之前，您应该始终使用`respondsToSelector:`方法；否则，您的程序可能会因为`doesNotRecognizeSelector`异常而崩溃。^([5](#chapter12-5))
- en: 'Next, the code makes use of various #pragma directives to save the diagnostic
    state and tell the compiler to ignore warnings that would otherwise be shown ❷.
    These warnings get raised when we invoke the performSelector:withObject: method
    ❸, as the compiler has no way of knowing what object it returns and thus can’t
    know how to manage its memory.^([6](#chapter12-6)) Because the connectionID is
    just an unsigned 32-bit integer, it doesn’t need memory management.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码利用了各种`#pragma`指令来保存诊断状态，并告诉编译器忽略本应显示的警告❷。当我们调用`performSelector:withObject:`方法❸时，这些警告就会被抛出，因为编译器无法知道它返回的是哪个对象，因此也不知道如何管理其内存。^([6](#chapter12-6))
    由于`connectionID`只是一个无符号32位整数，它不需要内存管理。
- en: 'Finally, the code accesses the connectionID property via the selector created
    earlier. It accomplishes this in the aforementioned performSelector:withObject:
    method, which allows you to invoke an arbitrary selector on an arbitrary object.
    With the device’s identifier in hand, the helper function restores the previous
    diagnostic state ❹ and returns the device’s ID to the caller.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码通过之前创建的选择器访问`connectionID`属性。它通过上述的`performSelector:withObject:`方法来实现，这个方法允许您在任意对象上调用任意选择器。获得设备标识符后，辅助函数恢复了先前的诊断状态❹，并将设备ID返回给调用者。
- en: The second argument to the AudioObjectAddPropertyListenerBlock function is a
    pointer to an AudioObjectPropertyAddress structure, which identifies the property
    we’re interested in receiving a notification about. OverSight initializes the
    structure, as shown in [Listing 12-3](chapter12.xhtml#Lis12-3).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioObjectAddPropertyListenerBlock`函数的第二个参数是一个指向`AudioObjectPropertyAddress`结构体的指针，该结构体标识我们感兴趣的需要接收通知的属性。`OverSight`初始化了该结构，如[示例
    12-3](chapter12.xhtml#Lis12-3)所示。'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 12-3: Initializing an AudioObjectPropertyAddress structure'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-3：初始化`AudioObjectPropertyAddress`结构体
- en: We specify that we’re interested in the kAudioDevicePropertyDeviceIsRunningSomewhere
    property, which relates to device activation and deactivation by any process on
    the system. The other elements of the structure indicate that the property we
    specified applies globally to the entire device, not just to a particular input
    or output. As a result, once we’ve added the property listener block, OverSight
    will receive notifications when the specified audio device’s run state changes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了关注的属性是kAudioDevicePropertyDeviceIsRunningSomewhere，它与系统中任何进程对设备的激活和停用相关。结构体中的其他元素表示我们指定的属性适用于整个设备，而不仅仅是某个特定的输入或输出。因此，一旦我们添加了属性监听器块，OverSight将在指定的音频设备运行状态变化时收到通知。
- en: 'The function’s third argument is a standard dispatch queue on which to execute
    the listener block (described next). We can either create a dedicated queue via
    the dispatch_queue_create API or use dispatch_get_global_queue, for example, with
    the DISPATCH_QUEUE_PRIORITY_DEFAULT constant, to make use of an existing global
    queue. The final argument to the function is a block of type AudioObjectPropertyListenerBlock
    that the Core Audio framework will automatically invoke whenever the specified
    property changes on the specified device. Here is the listener block’s type definition,
    also found in *AudioHardware.h*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第三个参数是一个标准的调度队列，用于执行监听器块（接下来会描述）。我们可以通过dispatch_queue_create API创建一个专用队列，或者使用dispatch_get_global_queue，例如，使用DISPATCH_QUEUE_PRIORITY_DEFAULT常量，来利用现有的全局队列。该函数的最后一个参数是一个类型为AudioObjectPropertyListenerBlock的块，当指定设备上的指定属性发生变化时，Core
    Audio框架会自动调用该块。下面是该监听器块的类型定义，也可以在*AudioHardware.h*中找到：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As multiple properties could change all at once if specified to receive notifications,
    the listener block gets invoked with an array of AudioObjectPropertyAddress objects
    and the number of elements in this array. OverSight is only interested in a single
    property, so it ignores these parameters. For completeness, [Listing 12-4](chapter12.xhtml#Lis12-4)
    shows OverSight’s watchAudioDevice: method, which contains the core logic for
    specifying the property of interest, defining a listener block for notifications,
    and then adding it to the specified audio device.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于如果指定接收通知的属性发生变化，多个属性可能会同时变化，因此监听器块会被调用，并传递一个AudioObjectPropertyAddress对象的数组以及该数组中的元素个数。OverSight只对一个属性感兴趣，因此它会忽略这些参数。为了完整性，[示例12-4](chapter12.xhtml#Lis12-4)展示了OverSight的watchAudioDevice:方法，该方法包含了指定感兴趣的属性、定义通知的监听器块，并将其添加到指定音频设备的核心逻辑。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 12-4: Setting up a listener block for an audio device’s run state changes'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-4：设置音频设备运行状态变化的监听器块
- en: The OverSight code in the listener block queries the device to determine its
    current state, as the notification tells us that the run state changed, but not
    to what state. If it finds the audio device turned on, OverSight consults its
    log monitor to determine the identity of the process responsible for accessing
    and activating the device. This step, discussed in more detail in “Responsible
    Process Identification” on [page 288](chapter12.xhtml#pg_288), is unfortunately
    necessary, because although Apple provides APIs to receive notifications about
    the state changes of an audio device, they provide no information about the responsible
    process. Lastly, the listener block alerts the user, providing information about
    the audio device, its state, and, in activation cases, the responsible process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器块中的OverSight代码查询设备，以确定其当前状态，因为通知告诉我们运行状态发生了变化，但没有具体说明变化到了哪个状态。如果发现音频设备已开启，OverSight会查询其日志监视器，以确定负责访问和激活该设备的进程身份。这个步骤在“负责任的进程识别”一节中有更详细的讨论（见[第288页](chapter12.xhtml#pg_288)）。遗憾的是，这一步是必要的，因为虽然苹果提供了API来接收音频设备状态变化的通知，但它们并没有提供关于负责进程的任何信息。最后，监听器块会提醒用户，提供有关音频设备、其状态以及在激活情况下负责的进程的信息。
- en: 'To determine whether the device was activated or deactivated, OverSight invokes
    the AudioDeviceGetProperty API within a helper method it names getMicState: ([Listing
    12-5](chapter12.xhtml#Lis12-5)).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定设备是被激活还是被停用，OverSight在它名为getMicState:的辅助方法中调用了AudioDeviceGetProperty API（[示例12-5](chapter12.xhtml#Lis12-5)）。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 12-5: Determining the current state of an audio device'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-5：确定音频设备的当前状态
- en: 'After declaring a few necessary variables, this method invokes the getAVObjectID:
    helper method discussed earlier to extract the private device ID from the AVCaptureDevice
    object that triggered the notification ❶. It then passes this value, along with
    the kAudioDevicePropertyDeviceIsRunningSomewhere constant, a size, and an out
    pointer for the result, to the AudioDeviceGetProperty function ❷. As a result
    of this call, we’ll know whether the notification we received in the callback
    block occurred due to a device activation or a less interesting deactivation.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在声明了几个必要的变量之后，该方法调用前面讨论过的 getAVObjectID: 辅助方法，从触发通知的 AVCaptureDevice 对象中提取私有设备
    ID ❶。然后，它将这个值与 kAudioDevicePropertyDeviceIsRunningSomewhere 常量、大小和结果的输出指针一起传递给
    AudioDeviceGetProperty 函数 ❷。通过此调用，我们将知道我们在回调块中收到的通知是由于设备激活还是由于不太重要的停用。'
- en: Next, I’ll show you how to monitor video devices, such as the built-in webcam.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向你展示如何监控视频设备，例如内置的摄像头。
- en: Camera Monitoring
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 摄像头监控
- en: To detect the run-state changes of video devices, which are of type AVMediaTypeVideo,
    we can follow an approach similar to the audio device monitoring code. However,
    we’ll use APIs in the *CoreMediaIO* framework and register a property listener
    with the CMIOObjectAddPropertyListenerBlock API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测视频设备的运行状态变化，这些设备的类型为 AVMediaTypeVideo，我们可以采用类似于音频设备监控代码的方法。然而，我们将使用 *CoreMediaIO*
    框架中的 API，并通过 CMIOObjectAddPropertyListenerBlock API 注册一个属性监听器。
- en: 'OverSight monitors video devices for run-state changes in its watchVideoDevice:
    method ([Listing 12-6](chapter12.xhtml#Lis12-6)).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'OverSight 在其 watchVideoDevice: 方法中监控视频设备的运行状态变化（[Listing 12-6](chapter12.xhtml#Lis12-6)）。'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-6: Setting up a listener block for a video device’s run-state changes'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-6: 设置视频设备运行状态变化的监听器块'
- en: As when monitoring audio devices, the code initializes a property structure
    to specify the property for which we’re interested in receiving notifications
    ❶. Notice that we use the same constants as for audio devices ❷. Apple’s header
    files don’t appear to define a video device–specific constant.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像监控音频设备一样，代码初始化一个属性结构来指定我们感兴趣的接收通知的属性 ❶。请注意，我们使用的常量与音频设备相同 ❷。苹果的头文件似乎没有定义特定于视频设备的常量。
- en: 'Next, we get the video device’s ID using OverSight’s getAVObjectID: helper
    method ❸. We also implement a listener block of type CMIOObjectPropertyListenerBlock
    ❹, then invoke the CMIOObjectAddPropertyListenerBlock function ❺. Once we’ve made
    this call, the *CoreMediaIO* framework will automatically invoke the listener
    block whenever a monitored video device activates or deactivates.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们使用 OverSight 的 getAVObjectID: 辅助方法获取视频设备的 ID ❸。我们还实现了一个类型为 CMIOObjectPropertyListenerBlock
    的监听器块 ❹，然后调用 CMIOObjectAddPropertyListenerBlock 函数 ❺。一旦我们调用了这个函数，*CoreMediaIO*
    框架会在监控的视频设备激活或停用时自动调用监听器块。'
- en: 'As with audio devices, we must manually query the device to learn whether it
    was activated or deactivated. You can find this logic in OverSight’s getCameraState:
    method, which uses CoreMediaIO APIs but is otherwise nearly identical to the getMicState:
    method. As such, I won’t cover it here.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '与音频设备一样，我们必须手动查询设备以了解它是否已被激活或禁用。你可以在 OverSight 的 getCameraState: 方法中找到这一逻辑，该方法使用
    CoreMediaIO API，但与 getMicState: 方法几乎完全相同。因此，我在这里就不再详细介绍了。'
- en: Device Connections and Disconnections
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设备连接与断开
- en: So far, we’ve enumerated the audio and video devices currently connected to
    the system. For each device, we’ve added a property listener block that will receive
    a notification whenever the device activates or deactivates. This is all well
    and good, but we also need to handle cases in which currently monitored devices
    disconnect and reconnect, as well as situations in which a user plugs in a new
    device during the monitoring. For example, imagine that the user regularly connects
    or disconnects their laptop to an Apple Cinema display. These displays have built-in
    webcams that OverSight should monitor for unauthorized activations, so we must
    be able to handle devices that come and go.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经列出了当前连接到系统的音频和视频设备。对于每个设备，我们都添加了一个属性监听器块，它将在设备激活或停用时接收通知。一切顺利，但我们还需要处理当前监控的设备断开和重新连接的情况，以及用户在监控期间插入新设备的情况。例如，假设用户经常将笔记本电脑连接或断开连接到
    Apple Cinema 显示器。这些显示器内置有摄像头，OverSight 应该监控这些摄像头以防止未经授权的激活，因此我们必须能够处理那些不断连接和断开的设备。
- en: Luckily, this is relatively straightforward thanks to the macOS NSNotificationCenter
    dispatch mechanism. Part of the *Foundation* framework, it allows clients to register
    themselves as observers for events of interest, then receive notifications whenever
    these events occur. To learn about audio or video device connections and disconnections,
    we’ll subscribe to the events AVCaptureDeviceWasConnectedNotification and AVCaptureDeviceWasDisconnectedNotification,
    which we can register with the code in [Listing 12-7](chapter12.xhtml#Lis12-7).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于 macOS 的 NSNotificationCenter 调度机制，这个过程相对简单。它是 *Foundation* 框架的一部分，允许客户端注册自己为感兴趣事件的观察者，然后在这些事件发生时接收通知。为了了解音频或视频设备的连接和断开，我们将订阅
    AVCaptureDeviceWasConnectedNotification 和 AVCaptureDeviceWasDisconnectedNotification
    事件，并可以通过 [Listing 12-7](chapter12.xhtml#Lis12-7) 中的代码进行注册。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-7: Registering for device connections and disconnections'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-7：注册设备连接和断开的事件
- en: 'OverSight makes two calls to the addObserver:selector:name:object: method to
    register itself for the events of interest. Let’s take a closer look at the arguments
    passed to this method. First is the object, or *observer*, used to handle the
    notification. OverSight specifies self to indicate that the object registering
    for the notifications is the same as the object that will handle them. As the
    second argument, OverSight uses the @selector keyword to specify the name of the
    method to invoke on the observer object and handle the notification. For new device
    connections, we use an OverSight method named handleConnectedDeviceNotification:,
    and for disconnections, we use handleDisconnectedDeviceNotification:. We’ll look
    at these methods shortly.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'OverSight 调用了两次 addObserver:selector:name:object: 方法来注册自己监听感兴趣的事件。让我们仔细看看传递给这个方法的参数。第一个参数是用于处理通知的对象或
    *观察者*。OverSight 指定 self，表示注册通知的对象与处理通知的对象相同。作为第二个参数，OverSight 使用 @selector 关键字指定在观察者对象上调用的处理通知的方法名称。对于新设备连接，我们使用名为
    handleConnectedDeviceNotification: 的 OverSight 方法，对于设备断开，则使用 handleDisconnectedDeviceNotification:
    方法。我们稍后会查看这些方法。'
- en: Next, we specify the event of interest, such as device connection or disconnection.
    The constants for these events can be found in Apple’s *AVCaptureDevice.h* file.
    The last argument allows you to specify an additional object to deliver along
    with the notification. OverSight doesn’t make use of this and, as such, simply
    passes nil.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定感兴趣的事件，比如设备连接或断开。这些事件的常量可以在 Apple 的 *AVCaptureDevice.h* 文件中找到。最后一个参数允许你指定一个附加对象，随通知一起传递。OverSight
    没有使用这个参数，因此简单地传递 nil。
- en: 'Once OverSight has invoked addObserver:selector:name:object: twice, whenever
    a device connects or disconnects, the notification center will invoke our corresponding
    observer method. The single parameter it passes to this method is a pointer to
    an NSNotification object. In the case of device connection or disconnection, this
    object contains a pointer to the AVCaptureDevice.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦 OverSight 调用了 addObserver:selector:name:object: 方法两次，每当设备连接或断开时，通知中心将触发我们相应的观察者方法。它传递给该方法的唯一参数是一个指向
    NSNotification 对象的指针。在设备连接或断开的情况下，这个对象包含一个指向 AVCaptureDevice 的指针。'
- en: Both notification observer methods first extract the device from the notification
    object and then determine its type (audio or video). Next, the code invokes OverSight’s
    device type–specific methods to either start or stop the monitoring, depending
    on whether the device was connected or disconnected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 两个通知观察者方法首先从通知对象中提取设备，然后确定其类型（音频或视频）。接下来，代码根据设备是连接还是断开，调用 OverSight 的特定方法来开始或停止监控。
- en: 'As an example, [Listing 12-8](chapter12.xhtml#Lis12-8) shows the implementation
    of the handleConnectedDeviceNotification: method.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '作为一个示例，[Listing 12-8](chapter12.xhtml#Lis12-8) 展示了 handleConnectedDeviceNotification:
    方法的实现。'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 12-8: When a new device connects, OverSight will begin monitoring it
    for run-state changes.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-8：当一个新设备连接时，OverSight 将开始监视它的运行状态变化。
- en: 'The method extracts the device that triggered the notification by accessing
    the object property of the NSNotification object passed into it ❶. If this just-connected
    device is an audio device, the code invokes OverSight’s watchAudioDevice: method,
    discussed earlier, to register a property listener block for state changes ❷.
    For video devices, the code invokes the watchVideoDevice: method ❸. The method
    to handle device disconnections is identical, except it invokes the relevant OverSight
    *unwatch* methods, discussed in “Stopping” on [page 293](chapter12.xhtml#pg_293),
    which stop the monitoring of audio or video devices.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '该方法通过访问传入的 NSNotification 对象的对象属性来提取触发通知的设备 ❶。如果这个新连接的设备是音频设备，代码会调用 OverSight
    的 watchAudioDevice: 方法，如前文所述，用于注册状态变化的属性监听块 ❷。对于视频设备，代码会调用 watchVideoDevice: 方法
    ❸。处理设备断开连接的方法是相同的，不同之处在于它调用相关的 OverSight *unwatch* 方法，详见《停止》章节 [第 293 页](chapter12.xhtml#pg_293)，用于停止音频或视频设备的监控。'
- en: If we were solely interested in the fact that a video or audio device had activated
    or deactivated, we’d be done. However, these events have limited utility for malware
    detection if they don’t include the process responsible for triggering it. So,
    we have more work cut out for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅仅对视频或音频设备是否被激活或停用感兴趣，那么就此为止。然而，如果没有包含触发该事件的责任进程，这些事件在恶意软件检测中的作用非常有限。因此，我们还需要做更多工作。
- en: Responsible Process Identification
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 责任进程识别
- en: Many legitimate activities could activate your mic or camera (for example, hopping
    on a conference call). A security tool must be able to identify the process accessing
    a device so it can ignore the ones it trusts and generate alerts for any it doesn’t
    recognize.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 许多合法活动可能会激活你的麦克风或摄像头（例如，参加视频会议）。安全工具必须能够识别访问设备的进程，以便能够忽略它信任的进程，并对任何不认识的进程发出警报。
- en: In previous chapters, I mentioned that Endpoint Security APIs can identify the
    process responsible for many events of interest. Unfortunately, Endpoint Security
    doesn’t report on mic and camera access yet (although I’ve begged Apple to add
    this feature many a time). While we’ve shown that the CoreAudio and CoreMediaIO
    APIs can provide notifications about changes to a device’s run state, they don’t
    contain information about the responsible process.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我提到过 Endpoint Security API 可以识别许多感兴趣事件的责任进程。不幸的是，Endpoint Security 目前并未报告麦克风和摄像头的访问情况（尽管我多次恳求
    Apple 添加这个功能）。虽然我们已经展示了 CoreAudio 和 CoreMediaIO API 可以提供设备运行状态变化的通知，但它们并不包含关于责任进程的信息。
- en: Over the years, OverSight has taken various roundabout approaches to accurately
    identify the responsible process. Initially, it took advantage of the fact that
    frameworks within processes accessing the mic or webcam would send various Mach
    messages to the core macOS camera and audio assistant daemons. When it received
    a device run-state change notification, OverSight would enumerate any Mach message
    senders. It also supplemented this information by extracting responsible candidate
    processes from the I/O registry.^([7](#chapter12-7)) Unfortunately, even this
    combined approach often yielded more than one candidate process. So, OverSight
    executed the macOS sample utility, which provided stack traces of the candidate
    processes. By examining these stack traces, it could identify whether a process
    was actively interacting with an audio or video device.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，OverSight 采取了各种迂回的方法来准确识别责任进程。最初，它利用了这样一个事实：访问麦克风或摄像头的进程框架会向 macOS 核心摄像头和音频助手守护进程发送各种
    Mach 消息。当收到设备运行状态变化通知时，OverSight 会列举出所有 Mach 消息的发送者。它还通过从 I/O 注册表中提取潜在的责任进程来补充这一信息。^([7](#chapter12-7))
    不幸的是，即使采用这种结合的方法，通常也会得到多个候选进程。因此，OverSight 执行了 macOS 样本工具，该工具提供了候选进程的堆栈跟踪。通过检查这些堆栈跟踪，它可以识别出某个进程是否正在与音频或视频设备进行交互。
- en: This approach wasn’t the most efficient (and the sample utility is a touch invasive,
    as it briefly suspends the target process), but it could consistently identify
    the responsible process. At the time, OverSight was the only tool on the market
    able to provide this feature, making it a hit not only with users but also with
    commercial entities, who reverse engineered the tool to steal this capability
    for their own purposes—bugs and all! When I confronted the companies with proof
    of this transgression, all eventually admitted fault, apologized, and made amends.^([8](#chapter12-8))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然效率不高（且样本实用性有点侵入性，因为它会短暂地暂停目标进程），但它能够持续地识别出负责的进程。当时，OverSight 是市场上唯一能够提供此功能的工具，这使得它不仅受到用户的欢迎，也吸引了商业实体的关注，这些公司反向工程了该工具，将这项功能盗用为己所用——包括所有的漏洞！当我拿出这项违规行为的证据与公司对质时，所有公司最终都承认了过错，表示道歉，并做出了赔偿。^([8](#chapter12-8))
- en: NOTE
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注释
- en: '*Interestingly, one of the developers who copied OverSight’s proprietary logic
    began working for Apple shortly thereafter. Coincidentally or not, more recent
    versions of macOS now alert you when a process initially attempts to access the
    mic or camera. As they say, imitation is the sincerest form of flattery.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*有趣的是，其中一位复制了 OverSight 专有逻辑的开发人员不久后就开始为 Apple 工作。是否巧合，macOS 的更新版本现在在进程首次尝试访问麦克风或摄像头时会发出提醒。正如他们所说，模仿是最真诚的恭维方式。*'
- en: As macOS changed, OverSight’s initial method of identifying the responsible
    process began to show its age. Luckily the introduction of the universal log provides
    a more efficient solution. In [Chapter 6](chapter6.xhtml), I showed how to use
    the universal log’s private APIs and frameworks for ingesting streaming log messages,
    among other tasks. OverSight uses these same APIs and frameworks, coupled with
    custom filter predicates, to identify the process responsible for triggering any
    mic or camera state changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 macOS 的变化，OverSight 最初用来识别负责进程的方法逐渐显得过时。幸运的是，通用日志的引入提供了一个更高效的解决方案。在[第 6 章](chapter6.xhtml)中，我展示了如何使用通用日志的私有
    API 和框架来摄取流式日志消息等任务。OverSight 使用了这些相同的 API 和框架，并结合自定义的筛选谓词，来识别触发任何麦克风或摄像头状态变化的进程。
- en: '> NOTE'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注释'
- en: '*Messages in the log can change at any time. In this section, I focus on the
    messages present in macOS 14 and 15\. While future versions of the operating system
    could replace these messages, you should be able to identify the new ones and
    swap them in.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*日志中的消息随时可能发生变化。在这一部分中，我重点讨论的是 macOS 14 和 15 中存在的消息。虽然未来的操作系统版本可能会替换这些消息，但你应该能够识别出新的消息并进行替换。*'
- en: 'The universal log contains many messages continually streaming from all corners
    of the system. To identify relevant messages (for example, those pertaining to
    processes accessing the camera), let’s start a log stream, then fire up an application
    such as FaceTime that makes use of the webcam:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通用日志包含了从系统各个角落不断流出的许多消息。为了识别相关的消息（例如，涉及访问摄像头的进程），我们可以先启动一个日志流，然后打开一个使用网络摄像头的应用程序，如
    FaceTime：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the stream, you can see messages related to the camera access. These contain
    references to a process with the PID of 901 or emanating from that process. In
    this example, that PID maps to the process avconferenced, which accesses the webcam
    on behalf of FaceTime. Let’s try another application (say, Zoom) to see what shows
    up in the logs:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在流中，你可以看到与摄像头访问相关的消息。这些消息包含指向 PID 为 901 的进程的引用，或者是由该进程发出的。在这个例子中，PID 映射到 avconferenced
    进程，它代表 FaceTime 访问网络摄像头。让我们尝试另一个应用程序（比如 Zoom），看看日志中显示了什么：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We receive the exact same messages, except this time they contain a process
    ID of 17873, which belongs to Zoom. You can perform a similar experiment to identify
    log messages containing information about processes accessing the mic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了完全相同的消息，只不过这次它们包含了一个进程 ID 17873，它属于 Zoom。你可以进行类似的实验，识别出包含有关访问麦克风的进程信息的日志消息。
- en: To programmatically interact with the universal log, OverSight implements a
    custom class named LogMonitor. The code in this class interfaces with APIs found
    within the private *LoggingSupport* framework. Since [Chapter 6](chapter6.xhtml)
    covered this strategy, I won’t repeat the detail here. If you’re interested in
    the full code, take a look at the *LogMonitor.m* file in the *OverSight* project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了程序化地与通用日志进行交互，OverSight 实现了一个名为 LogMonitor 的自定义类。该类中的代码与 *LoggingSupport*
    框架中的私有 API 进行了接口交互。由于[第 6 章](chapter6.xhtml)已经详细介绍了这一策略，这里就不再重复。如果你对完整的代码感兴趣，可以查看
    *OverSight* 项目中的 *LogMonitor.m* 文件。
- en: OverSight’s LogMonitor class exposes a method with the definition shown in [Listing
    12-9](chapter12.xhtml#Lis12-9).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: OverSight 的 LogMonitor 类暴露了一个方法，其定义如 [列表 12-9](chapter12.xhtml#Lis12-9) 所示。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 12-9: LogMonitor’s method to start a log stream filtered by a specified
    level and predicate'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-9：LogMonitor 的方法，通过指定的级别和谓词启动日志流
- en: Given a predicate and a log level (such as default or debug), this method activates
    a streaming log session. It will pass log messages of type OSLogEvent that match
    the specified predicate to the caller using the specified callback block.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个谓词和一个日志级别（例如默认或调试），此方法激活一个流式日志会话。它将传递与指定谓词匹配的 OSLogEvent 类型的日志消息给调用者，使用指定的回调块。
- en: OverSight uses a predicate that matches all log messages from either the core
    media I/O subsystem or the core media subsystem, because these subsystems generate
    the specific log messages that contain the PID of the responsible process ([Listing
    12-10](chapter12.xhtml#Lis12-10)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: OverSight 使用一个谓词，该谓词匹配来自核心媒体 I/O 子系统或核心媒体子系统的所有日志消息，因为这些子系统生成包含负责进程 PID 的特定日志消息（[列表
    12-10](chapter12.xhtml#Lis12-10)）。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 12-10: Filtering messages from the cmio and coremedia subsystems'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-10：过滤来自 cmio 和 coremedia 子系统的消息
- en: We intentionally leave these predicates broad to ensure that macOS performs
    the predicate matching within the system log daemon’s instance of the logging
    framework, rather than in the instance of the same framework loaded in OverSight.
    This avoids the significant overhead of copying and transmitting all system log
    messages between the two processes. The only downside to using a broader predicate
    is that OverSight must then filter out irrelevant messages. As neither of the
    two specified subsystems generates a significant number of log messages, however,
    this additional processing doesn’t introduce much overhead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意让这些谓词尽可能宽泛，以确保 macOS 在系统日志守护进程的日志框架实例中执行谓词匹配，而不是在 OverSight 加载的同一框架实例中执行。这避免了在两个进程之间复制和传输所有系统日志消息的重大开销。然而，使用更宽泛的谓词的唯一缺点是
    OverSight 必须筛选掉不相关的消息。不过，由于这两个指定子系统生成的日志消息数量不多，因此这种额外的处理不会引入太多开销。
- en: For each message from the subsystems, OverSight checks whether it contains the
    PID of the process that triggered the device’s run-state change. [Listing 12-11](chapter12.xhtml#Lis12-11)
    shows the code to do this for camera events.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自子系统的每条消息，OverSight 检查它是否包含触发设备运行状态变化的进程 PID。[列表 12-11](chapter12.xhtml#Lis12-11)
    展示了处理摄像头事件的代码。
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 12-11: Parsing cmio messages to detect the responsible process'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-11：解析 cmio 消息以检测负责的进程
- en: For camera events, we look for a message from the com.apple.cmio subsystem ending
    with added <private> endpoint <private> camera <private> ❷. To extract the PID
    for this process, OverSight uses a regular expression, which it initializes prior
    to the message processing to avoid reinitialization ❶, then applies it to the
    candidate messages ❸. If the regular expression doesn’t match, the callback exits
    with a return statement. Otherwise, it extracts the PID as an integer and saves
    it into an instance variable named lastCameraClient ❹. OverSight references this
    variable when it receives a camera run-state change notification and builds an
    alert to show the user ([Listing 12-12](chapter12.xhtml#Lis12-12)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于摄像头事件，我们查找来自 com.apple.cmio 子系统的消息，该消息以添加的 <private> 端点 <private> 摄像头 <private>
    ❷ 结尾。为了提取该进程的 PID，OverSight 使用一个正则表达式，它会在消息处理之前初始化，以避免重新初始化 ❶，然后将其应用于候选消息 ❸。如果正则表达式不匹配，回调函数将通过返回语句退出。否则，它会提取
    PID 作为整数，并将其保存到一个名为 lastCameraClient 的实例变量中 ❹。OverSight 在收到摄像头运行状态变更通知时引用该变量，并构建一个警报以显示给用户（[列表
    12-12](chapter12.xhtml#Lis12-12)）。
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 12-12: Creating an object encapsulating the responsible process'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-12：创建一个封装负责进程的对象
- en: For mic events, the approach is similar, except OverSight looks for messages
    from the com.apple.coremedia subsystem that start with -MXCoreSession- -[MXCoreSession
    beginInterruption] and end with Recording = YES> is going active.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于麦克风事件，方法类似，除了 OverSight 查找来自 com.apple.coremedia 子系统的消息，这些消息以 -MXCoreSession-
    -[MXCoreSession beginInterruption] 开头，以 Recording = YES> is going active 结尾。
- en: Using the universal log to identify processes responsible for mic and camera
    access has proven effective. The strategy’s main downside is that Apple occasionally
    changes or removes relevant log messages. For example, OverSight used different
    log messages to identify responsible processes in earlier versions of macOS, forcing
    me to update the tool when Apple removed them. You can see these updates by viewing
    the *AVMonitor.m* commit history in OverSight’s GitHub repository.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用日志来识别负责麦克风和摄像头访问的进程已经证明是有效的。这种策略的主要缺点是 Apple 偶尔会更改或删除相关的日志信息。例如，OverSight
    在 macOS 的早期版本中使用了不同的日志信息来识别负责的进程，这迫使我在 Apple 删除这些日志信息后更新工具。你可以通过查看 OverSight GitHub
    仓库中的 *AVMonitor.m* 提交历史记录来看到这些更新。
- en: Triggering Scripts
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发脚本
- en: When I introduced OverSight in 2015, macOS provided no restrictions on mic or
    webcam access, meaning any malware that infected the system could trivially access
    either. Recent versions of macOS have addressed this shortcoming by prompting
    the user the first time any application attempts to access these devices. Unfortunately,
    this approach relies on the operating system’s Transparency, Consent, and Control
    (TCC) mechanism, which hackers and malware often bypass, as noted in [Chapter
    6](chapter6.xhtml).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 2015 年介绍 OverSight 时，macOS 对麦克风或摄像头的访问没有任何限制，这意味着任何感染系统的恶意软件都可以轻松访问这些设备。近期版本的
    macOS 已经解决了这个问题，当任何应用程序首次尝试访问这些设备时，会提示用户。不幸的是，这种方法依赖于操作系统的透明度、同意和控制（TCC）机制，而黑客和恶意软件常常绕过该机制，正如
    [第 6 章](chapter6.xhtml) 所述。
- en: Besides providing an additional layer of defense, OverSight offers features
    that users have leveraged creatively. For example, it provides a mechanism to
    take additional actions whenever a process accesses the mic or camera. If you
    open OverSight’s preferences and click the Action tab, you’ll see that you can
    specify a path to an external script or binary. If a user provides such an executable,
    OverSight will execute it upon each activation event.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供额外的防御层，OverSight 还提供了用户创造性地利用的功能。例如，它提供了一个机制，当某个进程访问麦克风或摄像头时，可以采取额外的行动。如果你打开
    OverSight 的偏好设置并点击“操作”标签，你会看到可以指定一个外部脚本或二进制文件的路径。如果用户提供了这样的可执行文件，OverSight 会在每次激活事件时执行它。
- en: To further enhance this capability, another option allows users to enable arguments
    to provide to the script, including the device, state, and responsible process.
    This makes OverSight relatively easy to integrate into other security tools (although
    users have frequently used the feature for more practical reasons, such as turning
    on an external light outside their home office whenever they activate their mic
    or camera).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步增强这一功能，另一个选项允许用户启用参数以提供给脚本，包括设备、状态和负责的进程。这使得 OverSight 相对容易集成到其他安全工具中（尽管用户经常出于更实际的原因使用这一功能，比如每次激活麦克风或摄像头时，打开家办公室外的外部灯）。
- en: OverSight’s code to execute external scripts or binaries is fairly straightforward,
    though the handling of arguments requires a few nuances. Over- Sight makes use
    of the NSUserDefaults class to persistently store settings and preferences, including
    any user-specified script or binary. [Listing 12-13](chapter12.xhtml#Lis12-13)
    shows the code that saves the path of an item when the user interacts with the
    Browse button.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: OverSight 执行外部脚本或二进制文件的代码相当简单，尽管处理参数时需要注意一些细节。OverSight 使用 NSUserDefaults 类来持久化存储设置和偏好，包括任何用户指定的脚本或二进制文件。[列表
    12-13](chapter12.xhtml#Lis12-13) 显示了当用户与浏览按钮交互时，保存项目路径的代码。
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 12-13: The NSUserDefaults class used to store user preferences'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-13：用于存储用户偏好的 NSUserDefaults 类
- en: 'We save the path of the item the user selected via the user interface ❶, then
    set a flag indicating that the user specified an action ❷ and save the item’s
    path ❸. Note that panel is an NSOpenPanel object containing the item the user
    selected. We set the flag using the setBool: method of the NSUserDefaults’s standardUserDefaults
    object and set the item path using the setObject: method. Finally, we synchronize
    to trigger a save ❹.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过用户界面 ❶ 保存用户选择的项目路径，然后设置一个标志，表示用户指定了一个操作 ❷，并保存该项目的路径 ❸。请注意，panel 是一个 NSOpenPanel
    对象，包含用户选择的项目。我们使用 NSUserDefaults 的 standardUserDefaults 对象的 setBool: 方法设置标志，并使用
    setObject: 方法设置项目路径。最后，我们同步操作以触发保存 ❹。'
- en: 'When the user specifies an external item to run, OverSight invokes a helper
    function named executeUserAction: to run the item when a run-state change occurs
    to a mic or camera ([Listing 12-14](chapter12.xhtml#Lis12-14)).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '当用户指定要运行的外部项时，OverSight 会调用一个名为 executeUserAction: 的辅助函数，在麦克风或摄像头的运行状态更改时执行该项（[清单
    12-14](chapter12.xhtml#Lis12-14)）。'
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 12-14: Executing a user-specified item with arguments'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-14：执行用户指定的带参数项
- en: 'The executeUserAction: method first extracts the path of the user-specified
    item to execute from the saved preference ❶. Then it checks whether the user has
    opted to pass arguments to the item ❷. If so, it dynamically builds a string containing
    the arguments, including the device that triggered the event and the responsible
    process ❸. Finally, it executes the item and any arguments via the shell using
    the execTask helper function ❹ discussed in previous chapters.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'executeUserAction: 方法首先从保存的偏好设置中提取用户指定的要执行项的路径 ❶。然后它检查用户是否选择了传递参数给该项 ❷。如果是，它动态构建一个包含参数的字符串，其中包括触发事件的设备和负责的进程
    ❸。最后，它通过 shell 使用之前章节中讨论的 execTask 辅助函数执行该项及其任何参数 ❹。'
- en: You might be wondering why OverSight executes the user-specified item via */bin/bash*
    instead of just executing the item directly. Well, as the shell supports the execution
    of both scripts and stand-alone executables, this means users can specify either
    in OverSight.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 OverSight 通过 */bin/bash* 执行用户指定的项，而不是直接执行该项。嗯，因为 shell 支持执行脚本和独立的可执行文件，这意味着用户可以在
    OverSight 中指定任一项。
- en: Stopping
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 停止
- en: It’s nice to provide users with an easy way to pause or fully disable a security
    tool they have installed. I’ll end this chapter by looking at OverSight’s code
    to stop the device and log monitor. I won’t cover the UI components and logic
    that expose this ability, but you can find them implemented as a macOS status
    bar menu in OverSight’s *Application/StatusBarItem.m* file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为用户提供一个简单的方式来暂停或完全禁用他们安装的安全工具是很好的。我将在本章结束时查看 OverSight 的代码，以停止设备和日志监控。我不会涵盖暴露此功能的
    UI 组件和逻辑，但你可以在 OverSight 的*Application/StatusBarItem.m* 文件中找到它们作为 macOS 状态栏菜单的实现。
- en: When a user disables or stops OverSight, it first stops its log monitor by calling
    a stop method that the custom log monitor exposes. This method ends the stream
    that ingests log messages by invoking the OSLogEventLiveStream object’s invalidate
    method. Once the log monitor has stopped, OverSight stops monitoring all audio
    and video devices in two loops ([Listing 12-15](chapter12.xhtml#Lis12-15)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户禁用或停止 OverSight 时，它首先通过调用自定义日志监控器暴露的停止方法来停止日志监控器。该方法通过调用 OSLogEventLiveStream
    对象的 invalidate 方法结束接收日志消息的流。一旦日志监控器停止，OverSight 会在两个循环中停止监控所有音频和视频设备（[清单 12-15](chapter12.xhtml#Lis12-15)）。
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 12-15: Ending the monitoring of all devices'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-15：结束对所有设备的监控
- en: 'One loop iterates over all audio devices, calling OverSight’s unwatchAudioDevice:
    method, and a second loop iterates over video devices to invoke unwatchVideoDevice:
    on them. The code in these methods, which remove listener blocks, is nearly identical
    to the watch* monitoring methods covered earlier in this chapter, as you can see
    in this snippet from the unwatchAudioDevice method ([Listing 12-16](chapter12.xhtml#Lis12-16)).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '一个循环遍历所有音频设备，调用 OverSight 的 unwatchAudioDevice: 方法，另一个循环遍历视频设备，调用 unwatchVideoDevice:
    方法。这些方法中的代码移除监听器块，与本章早些时候涵盖的 watch* 监控方法几乎完全相同，正如你在来自 unwatchAudioDevice 方法的这段代码中所看到的（[清单
    12-16](chapter12.xhtml#Lis12-16)）。'
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 12-16: Removing a property listener block from an audio device'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-16：从音频设备中移除属性监听器块
- en: The code in this listing first gets the specified device’s ID and then initializes
    an AudioObjectPropertyAddress that describes the previously added property listener
    ❶. It passes these, along with the listener block stored in the dictionary named
    audioListeners, to the AudioObjectRemovePropertyListenerBlock function. This fully
    removes the property listener block, ending OverSight’s monitoring of the device.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先获取指定设备的 ID，然后初始化一个描述先前添加的属性监听器的 AudioObjectPropertyAddress ❶。它将这些内容与存储在名为
    audioListeners 的字典中的监听器块一起传递给 AudioObjectRemovePropertyListenerBlock 函数。这将完全移除属性监听器块，结束
    OverSight 对设备的监控。
- en: Conclusion
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Some of the most insidious threats targeting Mac users spy on their victim using
    the mic or camera. Instead of trying to detect specific malware specimens, OverSight
    counters all of them by taking the simple, albeit powerful, heuristic-based approach
    of detecting unauthorized mic and camera access.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些针对Mac用户的最隐蔽的威胁通过麦克风或摄像头监视受害者。OverSight并不试图检测特定的恶意软件样本，而是通过采用简单但强大的启发式方法来检测未经授权的麦克风和摄像头访问，从而对抗所有这类威胁。
- en: In this chapter, I first showed you how OverSight leverages various CoreAudio
    and CoreMediaIO APIs to register for notifications about mic and camera activations
    and deactivations. Then we explored the tool’s use of a custom log monitor to
    identify the process responsible for the event. Finally, I showed you how users
    can easily extend OverSight to execute external scripts or binaries as it detects
    events and the logic behind stopping OverSight.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我首先向你展示了OverSight如何利用各种CoreAudio和CoreMediaIO API注册关于麦克风和摄像头激活和停用的通知。接着，我们探讨了该工具如何使用自定义日志监视器来识别负责该事件的进程。最后，我向你展示了用户如何轻松扩展OverSight，以便在检测到事件时执行外部脚本或二进制文件，以及停止OverSight的逻辑。
- en: In the next chapter, we’ll continue to explore the building of robust security
    tools by looking at how to create a DNS monitor capable of detecting and blocking
    unauthorized network access.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索构建强大安全工具的方法，重点介绍如何创建一个DNS监视器，能够检测并阻止未经授权的网络访问。
- en: Notes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[  1](#chapter12_1).  Selena Larson, “Mac Malware Caught Silently Spying on
    Computer Users,” CNN Money, July 24, 2017, [*https://money.cnn.com/2017/07/24/technology/mac-fruitfly-malware-spying/index.html*.](https://money.cnn.com/2017/07/24/technology/mac-fruitfly-malware-spying/index.html)'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter12_1).  Selena Larson, “Mac恶意软件悄悄监视计算机用户，”CNN Money，2017年7月24日，[*https://money.cnn.com/2017/07/24/technology/mac-fruitfly-malware-spying/index.html*.](https://money.cnn.com/2017/07/24/technology/mac-fruitfly-malware-spying/index.html)'
- en: '[  2](#chapter12_2).  US Department of Justice, Office of Public Affairs, “Ohio
    Computer Programmer Indicted for Infecting Thousands of Computers with Malicious
    Software and Gaining Access to Victims’ Communications and Personal Information,”
    press release no. 18-21, January 10, 2018, [*https://<wbr>www<wbr>.justice<wbr>.gov<wbr>/opa<wbr>/pr<wbr>/ohio<wbr>-computer<wbr>-programmer<wbr>-indicted<wbr>-infecting<wbr>-thousands<wbr>-computers<wbr>-malicious<wbr>-software<wbr>-and*](https://www.justice.gov/opa/pr/ohio-computer-programmer-indicted-infecting-thousands-computers-malicious-software-and).'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter12_2).  美国司法部，公共事务办公室，“俄亥俄州计算机程序员因感染成千上万台计算机并获取受害者通信及个人信息而被起诉，”新闻稿编号18-21，2018年1月10日，[*https://<wbr>www<wbr>.justice<wbr>.gov<wbr>/opa<wbr>/pr<wbr>/ohio<wbr>-computer<wbr>-programmer<wbr>-indicted<wbr>-infecting<wbr>-thousands<wbr>-computers<wbr>-malicious<wbr>-software<wbr>-and*](https://www.justice.gov/opa/pr/ohio-computer-programmer-indicted-infecting-thousands-computers-malicious-software-and).'
- en: '[  3](#chapter12_3).  “AVFoundation,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/avfoundation<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/avfoundation?language=objc).'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter12_3).  “AVFoundation，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/avfoundation<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/avfoundation?language=objc).'
- en: '[  4](#chapter12_4).  “AVCapture Device,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/avfoundation<wbr>/avcapturedevice<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/avfoundation/avcapturedevice?language=objc).'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter12_4).  “AVCapture Device，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/avfoundation<wbr>/avcapturedevice<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/avfoundation/avcapturedevice?language=objc).'
- en: '[  5](#chapter12_5).  “doesNotRecognizeSelector:,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/objectivec<wbr>/nsobject<wbr>/1418637<wbr>-doesnotrecognizeselector<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/objectivec/nsobject/1418637-doesnotrecognizeselector?language=objc).'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter12_5).  “doesNotRecognizeSelector:，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/objectivec<wbr>/nsobject<wbr>/1418637<wbr>-doesnotrecognizeselector<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/objectivec/nsobject/1418637-doesnotrecognizeselector?language=objc).'
- en: '[  6](#chapter12_6).  “performSelector May Cause a Leak Because Its Selector
    Is Unknown,” Stack Overflow, November 18, 2018, [*https://<wbr>stackoverflow<wbr>.com<wbr>/a<wbr>/20058585*](https://stackoverflow.com/a/20058585).'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter12_6).  “performSelector 可能会导致内存泄漏，因为它的选择器未知，”Stack Overflow，2018年11月18日，[*https://<wbr>stackoverflow<wbr>.com<wbr>/a<wbr>/20058585*](https://stackoverflow.com/a/20058585).'
- en: '[  7](#chapter12_7).  “The I/O Registry,” Apple Documentation Archive, last
    updated April 9, 2014, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/DeviceDrivers<wbr>/Conceptual<wbr>/IOKitFundamentals<wbr>/TheRegistry<wbr>/TheRegistry<wbr>.html*](https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/TheRegistry/TheRegistry.html).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter12_7).  《I/O 注册表》，苹果文档档案，最后更新于2014年4月9日，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/DeviceDrivers<wbr>/Conceptual<wbr>/IOKitFundamentals<wbr>/TheRegistry<wbr>/TheRegistry<wbr>.html*](https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/TheRegistry/TheRegistry.html)。'
- en: '[  8](#chapter12_8).  You can read more about this series of events in Corin
    Faife, “This Mac Hacker’s Code Is So Good, Corporations Keep Stealing It,” The
    Verge, August 11, 2022, [*https://<wbr>www<wbr>.theverge<wbr>.com<wbr>/2022<wbr>/8<wbr>/11<wbr>/23301130<wbr>/patrick<wbr>-wardle<wbr>-mac<wbr>-code<wbr>-corporations<wbr>-stealing<wbr>-black<wbr>-hat*](https://www.theverge.com/2022/8/11/23301130/patrick-wardle-mac-code-corporations-stealing-black-hat).'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  8](#chapter12_8).  你可以在 Corin Faife 的文章“这位 Mac 黑客的代码如此优秀，以至于企业不断窃取”中了解更多这一系列事件的细节，发表于《The
    Verge》，2022年8月11日，[*https://<wbr>www<wbr>.theverge<wbr>.com<wbr>/2022<wbr>/8<wbr>/11<wbr>/23301130<wbr>/patrick<wbr>-wardle<wbr>-mac<wbr>-code<wbr>-corporations<wbr>-stealing<wbr>-black<wbr>-hat*](https://www.theverge.com/2022/8/11/23301130/patrick-wardle-mac-code-corporations-stealing-black-hat)。'
