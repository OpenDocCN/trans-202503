["```\n$(info $(FOO))\n```", "```\n$(info $(FOO) **$(origin FOO)**)\n```", "```\n**FOO=bar**\n$(info $(FOO) $(origin FOO))\n```", "```\n**override** FOO=bar\n$(info $(FOO) $(origin FOO))\n```", "```\nFOO=bar\n$(info $(FOO) $(origin FOO))\n```", "```\n**override**\nFOO=bar $(info $(FOO) $(origin FOO))\n```", "```\n$ **make BUILD_DEBUG=no**\n```", "```\nBUILD_DEBUG := yes\n.PHONY: all\nall: ; @echo BUILD_DEBUG is $(BUILD_DEBUG)\n```", "```\nBUILD_DEBUG := yes\n.PHONY: all\nall:\n→ @echo BUILD_DEBUG is $(BUILD_DEBUG)\n```", "```\n$ **make**\nBUILD_DEBUG is yes\n$ **make BUILD_DEBUG=no**\nBUILD_DEBUG is no\n$ **export BUILD_DEBUG=no**\n$ **make**\nBUILD_DEBUG is yes\n```", "```\n$ **export BUILD_DEBUG=no**\n$ **make**\nBUILD_DEBUG is yes\n$ **make -e**\nBUILD_DEBUG is no\n$ **make -e BUILD_DEBUG=maybe**\nBUILD_DEBUG is maybe\n```", "```\nifndef BUILD_DEBUG\nBUILD_DEBUG := yes\nendif\n```", "```\nBUILD_DEBUG ?= yes\n.PHONY: all\nall: ; @echo BUILD_DEBUG is $(BUILD_DEBUG)\n```", "```\n$ **make**\nBUILD_DEBUG is yes\n$ **make BUILD_DEBUG=no**\nBUILD_DEBUG is no\n$ **export BUILD_DEBUG=no**\n$ **make**\nBUILD_DEBUG is no\n```", "```\n$ **export BUILD_DEBUG=no**\n$ **make BUILD_DEBUG=aardvark**\nBUILD_DEBUG is aardvark\n```", "```\nFOO=bar\n\nall: ; @echo FOO is $$FOO\n```", "```\n$ **export FOO=foo**\n$ **make**\nFOO is bar\n```", "```\n**export** FOO=bar\n\nall: ; @echo FOO is $$FOO\n```", "```\nFOO=bar\n**unexport FOO**\n\nall: ; @echo FOO is $$FOO\n```", "```\nexport FOO=bar\n\nall: export FOO=just for all\n\nall: ; @echo FOO is $$FOO\n```", "```\nexport FOO=bar\n\n$(info $(shell printenv | grep FOO))\n\nall: ; @printenv | grep FOO\n```", "```\n$ **export FOO=foo**\n$ **make**\nFOO=foo\nFOO=bar\n```", "```\nexport FOO=$(shell echo fooey)\nall: ; @echo FOO is $$FOO\n```", "```\nexport FOO=bar\n\n$(info $(shell **FOO=$(FOO)** printenv | grep FOO))\n\nall: ; @printenv | grep FOO\n```", "```\n$ **make**\nFOO=bar\nFOO=bar\n```", "```\nenv_file = /tmp/env\nenv_shell = $(shell rm -f $(env_file))$(foreach V,$1,$(shell echo export\n$V=$($V) >> $(env_file)))$(shell echo '$2' >> $(env_file))$(shell /bin/bash -e\n$(env_file))\n```", "```\nexport FOO=bar\n\n$(info $(**call env_shell,FOO,printenv** | grep FOO))\n\nall: ; @printenv | grep FOO\n```", "```\n$ **make**\nFOO=bar\nFOO=bar\n```", "```\nexport FOO=bar\nprintenv | grep FOO\n```", "```\n   .PHONY: all foo bar baz\n\n➊ VAR = global scope\n\n   all: foo bar\n   all: ; @echo In $@ VAR is $(VAR)\n\n   foo: ; @echo In $@ VAR is $(VAR)\n\n➋ bar: VAR = local scope\n   bar: baz\n   bar: ; @echo In $@ VAR is $(VAR)\n\n   baz: ; @echo In $@ VAR is $(VAR)\n```", "```\n$ **make**\nIn foo VAR is global scope\nIn baz VAR is local scope\nIn bar VAR is local scope\nIn all VAR is global scope\n```", "```\nall foo bar baz: ; @echo In $@ VAR is $(VAR)\n```", "```\n   .PHONY: all foo bar baz\n\n   VAR = global scope\n\n   all: foo bar\n   all: ; @echo In $@ VAR is $(VAR)\n\n   foo: ; @echo In $@ VAR is $(VAR)\n\n   bar: VAR = local scope\n   bar: baz\n   bar: ; @echo In $@ VAR is $(VAR)\n\n   baz: ; @echo In $@ VAR is $(VAR)\n\n➊ f%: VAR = starts with f\n```", "```\n$ **make**\nIn foo VAR is starts with f\nIn baz VAR is local scope\nIn bar VAR is local scope\nIn all VAR is global scope\n```", "```\n%.o: %.c\n#  commands to execute (built-in):\n→ $(COMPILE.c) $(OUTPUT_OPTION) $<\n```", "```\n%.o: CFLAGS += -g\n```", "```\n   lib1_SRCS := $(wildcard lib1/*.c)\n   lib2_SRCS := $(wildcard lib2/*.c)\n\n   lib1_OBJS := $(lib1_SRCS:.c=.o)\n   lib2_OBJS := $(lib2_SRCS:.c=.o)\n\n   .PHONY: all\n   all: $(lib1_OBJS) $(lib2_OBJS)\n\n➊ %.o: %.c ; @$(COMPILE.C) -o $@ $<\n```", "```\nlib1/special.o: CPPFLAGS += -Wcomment\n```", "```\nlib1/%.o: CPPFLAGS += -fast\n```", "```\n.PHONY: all\nall: ; @echo $(MAKE_VERSION)\n```", "```\n$ **make**\n3.80\n```", "```\nneed := 3.80\nok := $(filter $(need),$(firstword $(sort $(MAKE_VERSION) $(need))))\n```", "```\nis_feature = $(if $(filter $1,$(.FEATURES)),T)\n```", "```\n.PHONY: all\nall: ; @echo archives are $(if $(call is_feature,archives),,not )available\n```", "```\n$ **make**\narchives are available\n```", "```\nhas_features := $(if $(filter default,$(origin .FEATURES)),$(if $(.FEATURES),T))\n```", "```\n$(eval eval_available := T)\n```", "```\nifneq ($(eval_available),T)\n$(error This makefile only works with a Make program that supports $$(eval))\nendif\n```", "```\nEMPTY =\nVAR = $(EMPTY)\n$(if $(VAR),$(info if-part),$(info else-part))\n```", "```\nHAS_A_VALUE = I'm not empty\n$(if $(HAS_A_VALUE),$(info if-part),$(info else-part))\n```", "```\nifdef VAR\nif-part...\nelse\nelse-part...\nendif\n```", "```\nVAR =\nifdef VAR\n$(info VAR is defined)\nelse\n$(info VAR is undefined)\nendif\n```", "```\nEMPTY =\nVAR = $(EMPTY)\nifdef VAR\n$(info VAR is defined)\nelse\n$(info VAR is not defined)\nendif\n```", "```\nVAR_NAME = VAR\nVAR = some value\nifdef $(VAR_NAME)\n$(info VAR is defined)\nelse\n$(info VAR is not defined)\nendif\n```", "```\nVAR = some value\nifdef VAR\n$(info VAR is defined)\nelse\n$(info VAR is not defined)\nendif\n```", "```\nmake-truth = $(if $1,T)\n```", "```\n➊ $(call make-truth, )\n   $(call make-truth,true)\n   $(call make-truth,a b c)\n```", "```\n➋ $(call make-truth,)\n   EMPTY =\n   $(call make-truth,$(EMPTY))\n   VAR = $(EMPTY)\n   $(call make-truth,$(VAR))\n```", "```\nor = $1$2\n```", "```\nor = $(call make-truth,$1$2)\n```", "```\nor = $(if $1$2,T).\n```", "```\n$(call or, , )\n$(call or,T,)\n$(call or, ,)\n$(call or,hello,goodbye my friend)\n```", "```\nEMPTY=\n$(call or,$(EMPTY),)\n```", "```\nand = $(if $1,$(if $2,T))\n```", "```\nnot = $(if $1,,T)\n```", "```\nnand = $(call not,$(call and,$1,$2)) nor = $(call not,$(call or,$1,$2))\nxor = $(call and,$(call or,$1,$2),$(call not,$(call and,$1,$2)))\n```", "```\nnand = $(if $1,$(if $2,,T),T)\nnor = $(if $1$2,,T)\nxor = $(if $1,$(if $2,,T),$(if $2,T))\n```", "```\nhave_native_and := $(and T,T)\nhave_native_or := $(or T,T)\n```", "```\nifneq ($(have_native_and),T)\nand = $(if $1,$(if $2,T))\nendif\nifneq ($(have_native_or),T)\nor = $(if $1$2,T)\nendif\n\n$(info This will be T: $(call and,T,T))\n```", "```\nHAVE_CURL := $(shell which curl)\n```", "```\nifndef HAVE_CURL\n$(error curl is missing)\nendif\n```", "```\nassert-command-present = $(if $(shell which $1),,$(error '$1' missing and needed for this build))\n\n$(call assert-command-present,curl)\n$(call assert-command-present,curly)\n```", "```\n$ **make**\nMakefile:4: *** 'curly' missing and needed for this build. Stop.\n```", "```\nall: ; @echo Do all...\n\ndownload: export _check = $(call assert-command-present,curly)\ndownload: ; @echo Download stuff...\n```", "```\n$ **make**\nDo all...\n$ **make download**\nMakefile:5: *** 'curly' missing and needed for this build. Stop.\n```", "```\nBAR = before\nFOO := $(BAR) the rain\nBAR = after\n```", "```\nBAR = before\nFOO = $(BAR) the rain\nBAR = after\n```", "```\nSHALIST = $(shell find . -name '*.c' | xargs shasum)\n```", "```\nSHALIST = $(eval SHALIST := $(shell find . -name '*.c' | xargs shasum))$(SHALIST)\n```", "```\n   SHALIST = $(eval SHALIST := $(shell find . -name '*.c' | xargs\n   shasum))$(SHALIST)\n\n   $(info Before use SHALIST is: $(value SHALIST))\n➊ $(info SHALIST is: $(SHALIST))\n   $(info After use SHALIST is: $(value SHALIST))\n```", "```\n$ **make**\nBefore use SHALIST is: $(eval SHALIST := $(shell find . -name '*.c' | xargs\nshasum))$(SHALIST)\nSHALIST is: 3405ad0433933b9b489756cb3484698ac57ce821 ./foo.c\nAfter use SHALIST is: 3405ad0433933b9b489756cb3484698ac57ce821 ./foo.c\n```", "```\nMY_LIST = a program for directed compilation\n$(info The first word is $(firstword $(MY_LIST)))\n```", "```\n➊ lastword = $(if $1,$(word $(words $1),$1))\n   MY_LIST = a program for directed compilation\n   $(info The last word is $(call lastword,$(MY_LIST)))\n```", "```\nnotfirst = $(wordlist 2,$(words $1),$1)\nMY_LIST = a program for directed compilation\n$(info $(call notfirst,$(MY_LIST)))\n```", "```\nnotlast = $(wordlist 2,$(words $1),dummy $1)\nMY_LIST = a program for directed compilation\n$(info $(call notlast,$(MY_LIST)))\n```", "```\nmake_date = $1/$2/$3\n```", "```\ntoday := $(call make_date,5,5,2014)\n```", "```\nunix_to_dos = $(subst /,\\,$1)\n```", "```\nswap = $2 $1\n```", "```\nFIRST := first,argument\nSWAPPED := $(call swap,$(FIRST),second)\n```", "```\nc := ,\nSWAPPED := $(call swap,first$cargument,second)\n```", "```\n, := ,\nSWAPPED := $(call swap,first$(,)argument,second)\n```", "```\n$(call info,message)\n```", "```\nmap = $(foreach a,$2,$(call $1,$a))\n```", "```\nprint_variable = $(info $1 ($(value $1) -> $($1)) )\n\nprint_variables = $(call map,print_variable,$1)\nVAR1 = foo\nVAR2 = $(VAR1)\nVAR3 = $(VAR2) $(VAR1)\n\n$(call print_variables,VAR1 VAR2 VAR3)\n```", "```\n$ **make**\nVAR1 (foo -> foo) VAR2 ($(VAR1) -> foo) VAR3 ($(VAR2) $(VAR1) -> foo foo)\n```", "```\nreduce = $(if $(strip $2),$(call reduce,$1,$(wordlist 2,$(words $2),$2), \\\n$(call $1,$(firstword $2),$3)),$3)\n```", "```\ncheck_uniq = $(if $(filter $1,$2),$2,$2 $1)\nuniq = $(call reduce,check_uniq,$1)\n$(info $(call uniq,c b a a c c b a c b a))\n```", "```\ncheck_uniq = $(info check_uniq ($1) ($2))$(if $(filter $1,$2),$2,$2 $1)\nuniq = $(call reduce,check_uniq,$1)\n$(info $(call uniq,c b a a c c b a c b a))\n```", "```\n$ make\ncheck_uniq (c) ()\ncheck_uniq (b) ( c)\ncheck_uniq (a) ( c b)\ncheck_uniq (a) ( c b a)\ncheck_uniq (c) ( c b a)\ncheck_uniq (c) ( c b a)\ncheck_uniq (b) ( c b a)\ncheck_uniq (a) ( c b a)\ncheck_uniq (c) ( c b a)\ncheck_uniq (b) ( c b a)\ncheck_uniq (a) ( c b a)\nc b a\n```", "```\nfoo:foo.c\n```", "```\n.SECONDEXPANSION:\n\nFOO = foo\n\nall: $$(FOO)\nall: ; @echo Making $@ from $?\n\nbar: ; @echo Making $@\n\nFOO = bar\n```", "```\n$ **make**\nMaking bar\nMaking all from bar\n```", "```\nifdef FOO\n$(info FOO defined)\nelse ifdef BAR\n$(info BAR defined)\nelse\n$(info BAR not defined)\nendif\n```", "```\nifdef FOO\n$(info FOO defined)\nelse\nifdef BAR\n$(info BAR defined)\nelse\n$(info BAR not defined)\nendif\nendif\n```", "```\n$(info $(.INCLUDE_DIRS))\nall: ; @true\n```", "```\nhas-order-only := $(filter order-only,$(.FEATURES))\n```", "```\nfail: ; $(error wrong)\n.DEFAULT_GOAL = all\nall: ; $(info right)\n```", "```\n    $(info Hello, World!)\n    all: ; @true\n    ```", "```\n    REC = foo\n    SIM := foo\n    $(info REC is $(flavor REC))\n    $(info SIM is $(flavor SIM))\n\n    all: ; @true\n    ```", "```\n    $(info $(abspath foo/./..//////bar))\n\n    all: ; @true\n    ```", "```\n    $(info $(realpath ../jgc/./bar))\n\n    all: ; @true\n    ```", "```\n    all: ; @echo \"hello\"\n    ```", "```\n    myfile.out %.out: ; @echo Do stuff with $@\n    ```", "```\n    all: odd\\=name\n\n    odd%: ; @echo Make $@\n    ```", "```\n    eq := =\n\n    all: odd$(eq)name\n    odd%: ; @echo Make $@\n    ```", "```\n    has space := variable with space in name\n    $(info $(has space))\n    ```", "```\n    sp :=\n    sp +=\n    has$(sp)space := variable with space in name\n\n    $(info $(has space))\n    ```", "```\n    all: output.o\n\n    out%.o: ; @echo Using out%.o rule\n    outp%.o: ; @echo Using outp%.o rule\n    ```", "```\n    $ make-3.81\n    Using out%.o rule\n    ```", "```\n    $ make-3.82\n    Using outp%.o rule\n    ```", "```\nall: ; @echo FOO has value $(FOO)\n```", "```\n    .RECIPEPREFIX = >\n\n    all:\n    > @echo Making all\n    ```", "```\nall:\n→ @cd /tmp\n→ @pwd\n```", "```\n.ONESHELL:\nall:\n→ @cd /tmp\n→ @pwd\n```", "```\nDEBUG=0\n\nfoo.o: private DEBUG=1\nfoo.o: foo.c\n→ @echo DEBUG is $(DEBUG) for $@\n\nfoo.c: foo.in\n→ @echo DEBUG is $(DEBUG) for $@\n```", "```\nSPECIAL_FLAGS := xyz\n$(info SPECIAL_FLAGS $(SPECIAL_FLAGS))\nundefine SPECIAL_FLAGS\n$(info SPECIAL_FLAGS $(SPECIAL_FLAGS))\n```", "```\nEMPTY :=\n$(info $(flavor EMPTY))\nundefine EMPTY\n$(info $(flavor EMPTY))\n```", "```\nFILE = foo.c\n\ndefine COMMANDS\nwc -l $(FILE)\nshasum $(FILE)\nendef\n```", "```\n   FILE = foo.c\n\n   define COMMANDS :=\n   wc -l $(FILE)\n   shasum $(FILE)\n   endef\n\n   define COMMANDS +=\n➊\n   wc -c $(FILE)\n   endef\n   $(info $(COMMANDS))\n```", "```\n$(if $(guile (access? \"foo.c\" R_OK)),$(info foo.c exists))\n```", "```\nall: one two three four\n\none two:\n→ @echo $@ line start\n→ @sleep 0.1s\n→ @echo $@ line middle\n→ @echo $@ line finish\n\nthree four:\n→ @echo $@ line start\n→ @sleep 0.2s\n→ @echo $@ line middle\n→ @echo $@ line finish\n```", "```\n$ **make -j4**\none line start\nthree line start\nfour line start\ntwo line start\none line middle\ntwo line middle\none line finish\ntwo line finish\nfour line middle\nthree line middle\nthree line finish\nfour line finish\n```", "```\n$ **make -j4 -Otarget**\ntwo line start\ntwo line middle\ntwo line finish\none line start\none line middle\none line finish\nfour line start\nfour line middle\nfour line finish\nthree line start\nthree line middle\nthree line finish\n```", "```\nall: part-one part-two\n\npart-one: part-three\n→ @echo Make $@\n\npart-two:\n→ @echo Make $@\n\npart-three:\n→ @echo Make $@\n```", "```\n$ **make --trace**\nmakefile:10: target 'part-three' does not exist\necho Make part-three\nMake part-three\nmakefile:4: update target 'part-one' due to: part-three\necho Make part-one\nMake part-one\nmakefile:7: target 'part-two' does not exist\necho Make part-two\nMake part-two\n```", "```\nCURRENTLY != date\n```", "```\nLOG = make.log\n\n$(file > $(LOG),Start)\n\nall: part-one part-two\n\npart-one: part-three\n→ @$(file >> $(LOG),$@)\n→ @echo Make $@\n\npart-two:\n→ @$(file >> $(LOG),$@)\n→ @echo Make $@\n\npart-three:\n→ @$(file >> $(LOG),$@)\n→ @echo Make $@\n```", "```\n$ **make**\nMake part-three\nMake part-one\nMake part-two\n$ **cat make.log**\nStart\npart-three\npart-one\npart-two\n```"]