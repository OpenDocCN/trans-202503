- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**WEBMASTER HACKS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to offering a great environment for building nifty command line
    tools that work with various websites, shell scripts can change the way your own
    site works. You can use shell scripts to write simple debugging tools, create
    web pages on demand, or even build a photo album browser that automatically incorporates
    new images uploaded to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts in this chapter are all *Common Gateway Interface (CGI)* scripts,
    generating dynamic web pages. As you write CGI scripts, you should always be conscious
    of possible security risks. One of the most common hacks that can catch a web
    developer unawares is an attacker accessing and exploiting the command line via
    a vulnerable CGI or other web language script.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the seemingly benign example of a web form that collects a user’s email
    address shown in [Listing 8-1](ch08.xhtml#ch8ex1). The script to process the form
    stores the user’s information in a local database and emails an acknowledgment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Sending an email to a web form user’s address*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Seems innocent, doesn’t it? Now imagine what would happen if, instead of a
    normal email address like *[taylor@intuitive.com](mailto:taylor@intuitive.com)*,
    the user entered something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Can you see the danger lurking in that? Rather than just sending the short email
    to the address, this sends a copy of your */etc/passwd* file to a delinquent at
    *[@das-hak.de](mailto:@das-hak.de)*, perhaps to be used as the basis of a determined
    attack on your system security.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, many CGI scripts are written in more security-conscious environments—notably
    `-w`-enabled Perl in the shebang (the `!#` at the top of shell scripts) so the
    script fails if data is used from an external source without being scrubbed or
    checked.
  prefs: []
  type: TYPE_NORMAL
- en: But a shell script’s lack of security features doesn’t preclude its being an
    equal partner in the world of web security. It just means you need to be conscious
    of where problems might creep in and eliminate them. For example, a tiny change
    in [Listing 8-1](ch08.xhtml#ch8ex1) would prevent potential hooligans from providing
    bad external data, as shown in [Listing 8-2](ch08.xhtml#ch8ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Sending an email using* `*-t*`'
  prefs: []
  type: TYPE_NORMAL
- en: The `-t` flag to `sendmail` tells the program to scan the message itself for
    a valid destination email address. The backquoted material never sees the light
    of a command line, as it’s interpreted as an invalid email address within the
    `sendmail` queuing system. It safely ends up as a file in your home directory
    called *dead.message* and is dutifully logged in a system error file.
  prefs: []
  type: TYPE_NORMAL
- en: Another safety measure would be to encode information sent from the web browser
    to the server. An encoded backquote, for example, would actually be sent to the
    server (and handed off to the CGI script) as `%60`, which can certainly be handled
    by a shell script without danger.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common characteristic of all the CGI scripts in this chapter is that they
    do very, very limited decoding of the encoded strings: spaces are encoded with
    a `+` for transmission, so translating them back to spaces is safe. The `@` character
    in email addresses is sent as `%40`, so that’s safely transformed back, too. Other
    than that, the scrubbed string can harmlessly be scanned for the presence of a
    `%` and generate an error if encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, sophisticated websites will use more robust tools than the shell,
    but as with many of the solutions in this book, a 20- to 30-line shell script
    can often be enough to validate an idea, prove a concept, or solve a problem in
    a fast, portable, and reasonably efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Scripts in This Chapter**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run the CGI shell scripts in this chapter, we’ll need to do a bit more than
    just name the script appropriately and save it. We must also place the script
    in the proper location, as determined by the configuration of the web server running.
    To do that, we can install the Apache web server with the system’s package manager
    and set it up to run our new CGI scripts. Here’s how to do so with the `apt` package
    manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Installing via the `yum` package manager should be very similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once it’s installed and configured, you should be able to start developing our
    scripts in the default *cgi-bin* directory for your chosen operating system (*/usr/lib/cgi-bin/*
    for Ubuntu or Debian and */var/www/cgi-bin/* on CentOS), and then view them in
    a web browser at *http://<ip>/cgi-bin/script.cgi*. If the scripts still show up
    in plaintext in your browser, ensure that they are executable with the command
    `chmod +x script.cgi`.
  prefs: []
  type: TYPE_NORMAL
- en: '**#63 Seeing the CGI Environment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we were developing some of the scripts for this chapter, Apple released
    the latest version of its Safari web browser. Our immediate question was, “How
    does Safari identify itself within the `HTTP_USER_AGENT` string?” Finding the
    answer is simple for a CGI script written in the shell, as in [Listing 8-3](ch08.xhtml#ch8ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: The* `*showCGIenv*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a query comes from a web client to a web server, the query sequence includes
    a number of environment variables that the web server (Apache, in this instance)
    hands to the script or program specified (the CGI). This script displays this
    data by using the shell `env` command ➊—to be maximally portable, it’ll use `printenv`
    if the `env` invocation fails, the purpose of the `||` notation—and the rest of
    the script is necessary wrapper information to have the results fed back through
    the web server to the remote browser.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run the code you need to have the script executable located on your web server.
    (See “[Running the Scripts in This Chapter](ch08.xhtml#ch08lev1sec01)” on [page
    201](ch08.xhtml#page_201) for more details.) Then simply request the saved *.cgi*
    file from within a web browser. The results are shown in [Figure 8-1](ch08.xhtml#ch8fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: The CGI runtime environment, from a shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Knowing how Safari identifies itself through the `HTTP_USER_AGENT` variable
    is quite useful, as [Listing 8-4](ch08.xhtml#ch8ex4) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: The* `*HTTP_USER_AGENT*` *environment variable in the CGI script*'
  prefs: []
  type: TYPE_NORMAL
- en: So Safari version 601.2.7 is in the class of Mozilla 5.0 browsers, running on
    Intel on OS X 10.11.1 using the KHTML rendering engine. All that information,
    tucked into a single variable!
  prefs: []
  type: TYPE_NORMAL
- en: '**#64 Logging Web Events**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A cool use of a shell-based CGI script is to log events by using a wrapper.
    Suppose that you’d like to have a DuckDuckGo search box on your web page. Rather
    than feed the queries directly to DuckDuckGo, you’d like to log them first to
    see if what visitors are searching for is related to the content on your site.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, a bit of HTML and CGI is necessary. Input boxes on web pages are
    created with the HTML `<form>` tag, and when the form is submitted by clicking
    the form’s button, it sends the user input to a remote web page specified in the
    value of the form’s `action` attribute. The DuckDuckGo query box on any web page
    can be reduced to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than hand the search pattern directly to DuckDuckGo, we want to feed
    it to a script on our own server, which will log the pattern and then redirect
    the query to the DuckDuckGo server. The form therefore changes in only one small
    regard: the `action` field becomes a local script rather than a direct call to
    DuckDuckGo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `log-duckduckgo-search` CGI script is remarkably simple, as [Listing 8-5](ch08.xhtml#ch8ex5)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: The* `*log-duckduckgo-search*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most notable elements of the script have to do with how web servers and
    web clients communicate. The information entered into the search box is sent to
    the server as the variable `QUERY_STRING` ➊, encoded by replacing spaces with
    the `+` sign and other non-alphanumeric characters with the appropriate character
    sequences. Then, when the search pattern is logged, all `+` signs are translated
    back into spaces safely and simply. Otherwise the search pattern is not decoded,
    to protect against any tricky hacks a user might attempt. (See the introduction
    to this chapter for more details.)
  prefs: []
  type: TYPE_NORMAL
- en: Once logged, the web browser is redirected to the actual DuckDuckGo search page
    with the `Location:` header value. Notice that simply appending `?$QUERY_STRING`
    is sufficient to relay the search pattern to its final destination, however simple
    or complex the pattern may be.
  prefs: []
  type: TYPE_NORMAL
- en: The log file produced by this script prefaces each query string with the current
    date and time to build up a data file that not only shows popular searches but
    can also be analyzed by the time of day, the day of the week, the month, and so
    forth. There’s lots of information that this script could reveal about a busy
    site!
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To really use this script, you need to create the HTML form, and you need to
    have the script executable and located on your server. (See “[Running the Scripts
    in This Chapter](ch08.xhtml#ch08lev1sec01)” on [page 201](ch08.xhtml#page_201)
    for more details.) However, we can test the script by using `curl`. To test the
    script, perform an HTTP request with `curl` that has a `q` parameter with the
    search query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, verify that the search was logged by printing the contents of our search
    log to the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Opening the script in a web browser, the results are from DuckDuckGo, exactly
    as expected, as shown in [Figure 8-2](ch08.xhtml#ch8fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: DuckDuckGo search results appear, but the search was logged!*'
  prefs: []
  type: TYPE_NORMAL
- en: On a busy website, you will doubtless find that monitoring searches with the
    command `tail -f searchlog.txt` is quite informative, as you learn what people
    seek online.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the search box is used on every page of the website, then it would be useful
    to know what page the user was on when they performed the search. This could lead
    to good insights about whether particular pages explain themselves well enough.
    For instance, do users always search for more clarification on a topic from a
    given page? Logging the extra information about which page the user is searching
    from like the `Referer` HTTP header would be a great addition to the script.
  prefs: []
  type: TYPE_NORMAL
- en: '**#65 Building Web Pages on the Fly**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many websites have graphics and other elements that change on a daily basis.
    Web comics like Bill Holbrook’s *Kevin & Kell* are a good example of this. On
    his site, the home page always features the most recent strip, and it turns out
    that the image-naming convention the site uses for individual comics is easy to
    reverse engineer, allowing you to include the cartoon on your own page, as [Listing
    8-6](ch08.xhtml#ch8ex6) details.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Word from Our Lawyers: there are a lot of copyright issues to consider when
    scraping the content off another website for your own. For this example, we received
    explicit permission from Bill Holbrook to include his comic strip in this book.
    We encourage you to get permission to reproduce any copyrighted materials on your
    own site before you dig yourself into a deep hole surrounded by lawyers.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: The* `*kevin-and-kell*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A quick View Source of the home page for *Kevin & Kell* reveals that the URL
    for a given comic is built from the current year, month, and day, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To build a page that includes this strip on the fly, the script needs to ascertain
    the current year (as a two-digit value), month, and day (both with a leading zero,
    if needed). The rest of the script is just HTML wrapper to make the page look
    nice. In fact, this is a remarkably simple script, given the resultant functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like the other CGI scripts in this chapter, this script must be placed in an
    appropriate directory so that it can be accessed via the web, with the appropriate
    file permissions. Then it’s just a matter of invoking the proper URL from a browser.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The web page changes every day, automatically. For the strip of August 4, 2016,
    the resulting page is shown in [Figure 8-3](ch08.xhtml#ch8fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: The* Kevin & Kell *web page, built on the fly*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This concept can be applied to almost anything on the web if you’re so inspired.
    You could scrape the headlines from CNN or the *South China Morning Post*, or
    get a random advertisement from a cluttered site. Again, if you’re going to make
    the content an integral part of your site, make sure that it’s public domain or
    that you’ve arranged for permission.
  prefs: []
  type: TYPE_NORMAL
- en: '**#66 Turning Web Pages into Email Messages**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By combining the method of reverse engineering file-naming conventions with
    the website-tracking utility shown in [Script #62](ch07.xhtml#ch07lev1sec10) on
    [page 194](ch07.xhtml#page_194), you can email yourself a web page that updates
    not only its content but also its filename. This script does not require the use
    of a web server to be useful and can be run like the rest of the scripts we have
    written so far in the book. A word of caution, however: Gmail and other email
    providers may filter emails sent from a local Sendmail utility. If you do not
    receive the emails from the following script, try using a service like Mailinator
    (*[http://mailinator.com/](http://mailinator.com/)*) for testing purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an example, we’ll use *The Straight Dope*, a witty column Cecil Adams writes
    for the *Chicago Reader.* It’s straightforward to have the new *Straight Dope*
    column automatically emailed to a specified address, as [Listing 8-7](ch08.xhtml#ch8ex7)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: The* `*getdope*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The page with the latest column has a URL that you need to extract from the
    home page, but examination of the source code reveals that each column is identified
    in the source with a `class"="teaser"` and that the most recent column is always
    first on the page. This means that the simple command sequence starting at ➊ should
    extract the URL of the latest column.
  prefs: []
  type: TYPE_NORMAL
- en: The `curl` command grabs the source to the home page, the `grep` command outputs
    each matching “teaser” line along with the line immediately after, and `sed` makes
    it easy to grab the second line of the resultant output so we can pull the latest
    article.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To extract just the URL, simply omit everything before the first double quote
    and everything after the resultant first quote. Test it on the command line, piece
    by piece, to see what each step accomplishes.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While succinct, this script demonstrates a sophisticated use of the web, extracting
    information from one web page to use as the basis of a subsequent invocation.
  prefs: []
  type: TYPE_NORMAL
- en: The resultant email therefore includes everything on the page, including menus,
    images, and all the footer and copyright information, as shown in [Figure 8-4](ch08.xhtml#ch8fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: Getting the latest* Straight Dope *article delivered straight
    to your inbox*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you might want to sit down for an hour or two on the weekend and read
    the past week’s articles, rather than retrieve one email daily. These types of
    aggregate emails are generally called *email digests* and can be easier to go
    through in one sitting. A good hack would be to update the script to take the
    article for the last seven days and send them all in one email at the end of the
    week. It also cuts back on all those emails you get during the week!
  prefs: []
  type: TYPE_NORMAL
- en: '**#67 Creating a Web-Based Photo Album**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CGI shell scripts aren’t limited to working with text. A common use of websites
    is as a photo album that allows you to upload lots of pictures and has some sort
    of software to help organize everything and make it easy to browse. Surprisingly,
    a basic “proof sheet” of photos in a directory is quite easy to produce with a
    shell script. The script shown in [Listing 8-8](ch08.xhtml#ch8ex8) is only 44
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: The* `*album*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Almost all of the code here is HTML to create an attractive output format. Take
    out the `echo` statements, and there’s a simple `for` loop that iterates through
    each file in the */var/www/html* directory ➊ (which is the default web root on
    Ubuntu 14.04), identifying the files that are images through use of the `file`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: This script works best with a file-naming convention in which every filename
    has dashes where it would otherwise have spaces. For example, the `name` value
    of *sunset-at-home.jpg* is transformed into the `nicename` ➋ of *sunset at home*.
    It’s a simple transformation, but one that allows each picture in the album to
    have an attractive, human-readable name rather than something unsightly like *DSC00035.JPG*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run this script, drop it into a directory full of JPEG images, naming the
    script *index.cgi*. If your web server is configured properly, requesting to view
    that directory automatically invokes *index.cgi*, as long as no *index.html* file
    is present. Now you have an instant, dynamic photo album.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given a directory of landscape shots, the results are quite pleasing, as shown
    in [Figure 8-5](ch08.xhtml#ch8fig5). Notice that *header.html* and *footer.html*
    files are present in the same directory, so they are automatically included in
    the output too.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: An instant online photo album created with 44 lines of shell script!*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One limitation of this script is that the full-size version of each picture
    must be downloaded for the photo album view to be shown. If you have a dozen 100MB
    picture files, that could take quite a while for someone on a slow connection.
    The thumbnails aren’t really any smaller. The solution is to automatically create
    scaled versions of each image, which can be done within a script by using a tool
    like ImageMagick (see [Script #97](ch14.xhtml#ch14lev1sec04) on [page 322](ch14.xhtml#page_322)).
    Unfortunately, very few Unix installations include sophisticated graphics tools
    of this nature, so if you’d like to extend this photo album in that direction,
    start by learning more about the ImageMagick tool at *[http://www.imagemagick.org/](http://www.imagemagick.org/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to extend this script would be to teach it to show a clickable folder
    icon for any subdirectories so that the album acts as an entire file system or
    tree of photographs, organized into portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: This photo album script is a longtime favorite. What’s delightful about having
    this as a shell script is that it’s incredibly easy to extend the functionality
    in any of a thousand ways. For example, by using a script called `showpic` to
    display the larger images rather than just linking to the JPEG images, it would
    take about 15 minutes to implement a per-image counter system so that people could
    see which images were most popular.
  prefs: []
  type: TYPE_NORMAL
- en: '**#68 Displaying Random Text**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A lot of web servers offer built-in *server-side include (SSI)* capability,
    which allows you to invoke a program to add one or more lines of text to a web
    page as it’s being served to the visitor. This offers some wonderful ways to extend
    your web pages. One of our favorites is the ability to change an element of a
    web page each time the page is loaded. The element might be a graphic, a news
    snippet, a featured subpage, or a tagline for the site itself that’s slightly
    different on each visit, to keep the reader coming back for more.
  prefs: []
  type: TYPE_NORMAL
- en: What’s remarkable is that this trick is quite easy to accomplish with a shell
    script containing an `awk` program only a few lines long, invoked from within
    a web page via a SSI or an *iframe* (a way to have a portion of a page served
    up by a URL that’s different from the rest of the page). The script is shown in
    [Listing 8-9](ch08.xhtml#ch8ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: The* `*randomquote*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the name of a data file, this script first checks that the file exists
    and is readable. Then it feeds the entire file to a short `awk` script, which
    stores each line in an array, counts the lines, and then randomly picks one of
    the lines in the array and prints it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The script can be incorporated into an SSI-compliant web page with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Most servers require an *.shtml* file extension, rather than the more traditional
    *.html* or *.htm*, for the web page that contains this server-side include. With
    that simple change, the output of the `randomquote` command is incorporated into
    the content of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can test this script on the command line by calling it directly, as shown
    in [Listing 8-10](ch08.xhtml#ch8ex10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: Running the* `*randomquote*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It would be simple to have the data file that `randomquote` uses contain a list
    of graphic image names. Then you could use this script to rotate through a set
    of graphics. Once you think about it, you’ll realize there’s quite a bit you can
    do with this idea.
  prefs: []
  type: TYPE_NORMAL
