["```\n#include <sys/types.h>        /* For portability */\n#include <sys/shm.h>\n\nint `shmget`(key_t *key*, size_t *size*, int *shmflg*);\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/shm.h>\n\nvoid *`shmat`(int *shmid*, const void **shmaddr*, int *shmflg*);\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/shm.h>\n\nint `shmdt`(const void **shmaddr*);\n```", "```\n`svshm/svshm_xfr.h`\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/sem.h>\n#include <sys/shm.h>\n#include \"binary_sems.h\"        /* Declares our binary semaphore functions */\n#include \"tlpi_hdr.h\"\n\n#define SHM_KEY 0x1234          /* Key for shared memory segment */\n#define SEM_KEY 0x5678          /* Key for semaphore set */\n\n#define OBJ_PERMS (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)\n                                /* Permissions for our IPC objects */\n\n#define WRITE_SEM 0             /* Writer has access to shared memory */\n#define READ_SEM 1              /* Reader has access to shared memory */\n\n#ifndef BUF_SIZE                /* Allow \"cc -D\" to override definition */\n#define BUF_SIZE 1024           /* Size of transfer buffer */\n#endif\n\nstruct shmseg {                 /* Defines structure of shared memory segment */\n    int cnt;                    /* Number of bytes used in 'buf' */\n    char buf[BUF_SIZE];         /* Data being transferred */\n};\n      `svshm/svshm_xfr.h`\n```", "```\n`svshm/svshm_xfr_writer.c`\n    #include \"semun.h\"              /* Definition of semun union */\n    #include \"svshm_xfr.h\"\n\n    int\n    main(int argc, char *argv[])\n    {\n        int semid, shmid, bytes, xfrs;\n        struct shmseg *shmp;\n        union semun dummy;\n\n    semid = semget(SEM_KEY, 2, IPC_CREAT | OBJ_PERMS);\n        if (semid == -1)\n            errExit(\"semget\");\n\n            if (initSemAvailable(semid, WRITE_SEM) == -1)\n            errExit(\"initSemAvailable\");\n        if (initSemInUse(semid, READ_SEM) == -1)\n            errExit(\"initSemInUse\");\n\n    shmid = shmget(SHM_KEY, sizeof(struct shmseg), IPC_CREAT | OBJ_PERMS);\n        if (shmid == -1)\n            errExit(\"shmget\");\n\n        shmp = shmat(shmid, NULL, 0);\n        if (shmp == (void *) -1)\n            errExit(\"shmat\");\n\n        /* Transfer blocks of data from stdin to shared memory */\n\n    for (xfrs = 0, bytes = 0; ; xfrs++, bytes += shmp->cnt) {\n\n        if (reserveSem(semid, WRITE_SEM) == -1)         /* Wait for our turn */\n                errExit(\"reserveSem\");\n\n        shmp->cnt = read(STDIN_FILENO, shmp->buf, BUF_SIZE);\n            if (shmp->cnt == -1)\n                errExit(\"read\");\n\n        if (releaseSem(semid, READ_SEM) == -1)          /* Give reader a turn */\n                errExit(\"releaseSem\");\n\n            /* Have we reached EOF? We test this after giving the reader\n               a turn so that it can see the 0 value in shmp->cnt. */\n\n        if (shmp->cnt == 0)\n                break;\n        }\n\n        /* Wait until reader has let us have one more turn. We then know\n           reader has finished, and so we can delete the IPC objects. */\n\n    if (reserveSem(semid, WRITE_SEM) == -1)\n            errExit(\"reserveSem\");\n\n    if (semctl(semid, 0, IPC_RMID, dummy) == -1)\n            errExit(\"semctl\");\n        if (shmdt(shmp) == -1)\n            errExit(\"shmdt\");\n        if (shmctl(shmid, IPC_RMID, 0) == -1)\n            errExit(\"shmctl\");\n\n        fprintf(stderr, \"Sent %d bytes (%d xfrs)\\n\", bytes, xfrs);\n        exit(EXIT_SUCCESS);\n    }\n          `svshm/svshm_xfr_writer.c`\n```", "```\n`svshm/svshm_xfr_reader.c`\n    #include \"svshm_xfr.h\"\n\n    int\n    main(int argc, char *argv[])\n    {\n        int semid, shmid, xfrs, bytes;\n        struct shmseg *shmp;\n\n        /* Get IDs for semaphore set and shared memory created by writer */\n\n    semid = semget(SEM_KEY, 0, 0);\n        if (semid == -1)\n            errExit(\"semget\");\n\n        shmid  = shmget(SHM_KEY, 0, 0);\n        if (shmid == -1)\n            errExit(\"shmget\");\n\n    shmp = shmat(shmid, NULL, SHM_RDONLY);\n        if (shmp == (void *) -1)\n            errExit(\"shmat\");\n\n        /* Transfer blocks of data from shared memory to stdout */\n\n    for (xfrs = 0, bytes = 0; ; xfrs++) {\n\n        if (reserveSem(semid, READ_SEM) == -1)          /* Wait for our turn */\n                errExit(\"reserveSem\");\n\n        if (shmp->cnt == 0)                    /* Writer encountered EOF */\n                break;\n            bytes += shmp->cnt;\n\n        if (write(STDOUT_FILENO, shmp->buf, shmp->cnt) != shmp->cnt)\n                fatal(\"partial/failed write\");\n\n        if (releaseSem(semid, WRITE_SEM) == -1)         /* Give writer a turn */\n                errExit(\"releaseSem\");\n        }\n\n    if (shmdt(shmp) == -1)\n            errExit(\"shmdt\");\n\n        /* Give writer one more turn, so it can clean up */\n\n    if (releaseSem(semid, WRITE_SEM) == -1)\n            errExit(\"releaseSem\");\n\n        fprintf(stderr, \"Received %d bytes (%d xfrs)\\n\", bytes, xfrs);\n        exit(EXIT_SUCCESS);\n    }\n          `svshm/svshm_xfr_reader.c`\n```", "```\n$ `wc -c /etc/services`                               *Display size of test file*\n764360 /etc/services\n$ `./svshm_xfr_writer < /etc/services &`\n[1] 9403\n$ `./svshm_xfr_reader > out.txt`\nReceived 764360 bytes (747 xfrs)                    *Message from reader*\nSent 764360 bytes (747 xfrs)                        *Message from writer*\n[1]+  Done              ./svshm_xfr_writer < /etc/services\n$ `diff /etc/services out.txt`\n$\n```", "```\n$ `./svshm_create -p 102400`\n9633796\n$ `./svshm_create -p 3276800`\n9666565\n$ `./svshm_create -p 102400`\n1015817\n$ `./svshm_create -p 3276800`\n1048586\n```", "```\n$ `./svshm_attach 9633796:0 9666565:0`\nSHMLBA = 4096 (0x1000), PID = 9903\n1: 9633796:0 ==> 0xb7f0d000\n2: 9666565:0 ==> 0xb7bed000\nSleeping 5 seconds\n```", "```\n*Type Control-Z to suspend program*\n[1]+  Stopped           ./svshm_attach 9633796:0 9666565:0\n$ `cat /proc/9903/maps`\n```", "```\n$ `cat /proc/9903/maps`\n\n    08048000-0804a000 r-xp 00000000 08:05 5526989  /home/mtk/svshm_attach\n    0804a000-0804b000 r--p 00001000 08:05 5526989  /home/mtk/svshm_attach\n    0804b000-0804c000 rw-p 00002000 08:05 5526989  /home/mtk/svshm_attach\n b7bed000-b7f0d000 rw-s 00000000 00:09 9666565  /SYSV00000000 (deleted)\n    b7f0d000-b7f26000 rw-s 00000000 00:09 9633796  /SYSV00000000 (deleted)\n    b7f26000-b7f27000 rw-p b7f26000 00:00 0\n b7f27000-b8064000 r-xp 00000000 08:06 122031   /lib/libc-2.8.so\n    b8064000-b8066000 r--p 0013d000 08:06 122031   /lib/libc-2.8.so\n    b8066000-b8067000 rw-p 0013f000 08:06 122031   /lib/libc-2.8.so\n    b8067000-b806b000 rw-p b8067000 00:00 0\n    b8082000-b8083000 rw-p b8082000 00:00 0\n b8083000-b809e000 r-xp 00000000 08:06 122125   /lib/ld-2.8.so\n    b809e000-b809f000 r--p 0001a000 08:06 122125   /lib/ld-2.8.so\n    b809f000-b80a0000 rw-p 0001b000 08:06 122125   /lib/ld-2.8.so\n bfd8a000-bfda0000 rw-p bffea000 00:00 0        [stack]\n ffffe000-fffff000 r-xp 00000000 00:00 0        [vdso]\n```", "```\n*p = target;                    /* Place pointer in *p (WRONG!) */\n```", "```\n*p = (target - baseaddr);       /* Place offset in *p */\n```", "```\ntarget = baseaddr + *p;         /* Interpret offset */\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/shm.h>\n\nint `shmctl`(int *shmid*, int *cmd*, struct shmid_ds **buf*);\n```", "```\nstruct shmid_ds {\n    struct ipc_perm shm_perm;   /* Ownership and permissions */\n    size_t   shm_segsz;         /* Size of segment in bytes */\n    time_t   shm_atime;         /* Time of last shmat() */\n    time_t   shm_dtime;         /* Time of last shmdt() */\n    time_t   shm_ctime;         /* Time of last change */\n    pid_t    shm_cpid;          /* PID of creator */\n    pid_t    shm_lpid;          /* PID of last shmat() / shmdt() */\n    shmatt_t shm_nattch;        /* Number of currently attached processes */\n};\n```", "```\n$ `cd /proc/sys/kernel`\n$ `cat shmmni`\n4096\n$ `cat shmmax`\n33554432\n$ `cat shmall`\n2097152\n```", "```\nstruct shminfo buf;\n\nshmctl(0, IPC_INFO, (struct shmid_ds *) &buf);\n```", "```\n    for (xfrs = 0, bytes = 0; shmp->cnt != 0; xfrs++, bytes += shmp->cnt) {\n        reserveSem(semid, READ_SEM);            /* Wait for our turn */\n\n        if (write(STDOUT_FILENO, shmp->buf, shmp->cnt) != shmp->cnt)\n            fatal(\"write\");\n\n        releaseSem(semid, WRITE_SEM);           /* Give writer a turn */\n    }\n    ```"]