<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch9" epub:type="chapter" role="doc-chapter">
<span aria-label="157" epub:type="pagebreak" id="pg_157" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch9">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">9</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">FILES AND DIRECTORIES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">Many applications require you to read or write data to and from files. In this chapter, we’ll explore how to interact with files via PHP scripts. We’ll focus primarily on simple <i>.txt</i> files, though we’ll also touch on how PHP handles other common text file formats.</p>
<p class="TX">PHP provides many built-in functions for working with files. Some read or write files all in one go, while other, lower-level functions provide more granular control, allowing you to open and close files and selectively read or write at specific locations. Not all web applications will require you to work with external files, but knowing your way around these functions is still useful, in case the need arises. Outside of web applications, for example, you may find yourself needing to reformat the data inside files or to move and rename files and directories. With the functions we’ll discuss here, you can write a PHP script to automate that process.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="158" epub:type="pagebreak" id="pg_158" role="doc-pagebreak"/>
<h3 class="H1" id="sec1"><span id="toc-link_128"/><span class="SANS_Futura_Std_Bold_B_11">Reading a File into a String</span></h3>
<p class="TNI1">If you know a file exists and you want to read all its contents into your script as a single string, you can do so in a single statement, simply by calling the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> function. To illustrate, let’s first create a file to be read in. <a href="#lis9-1">Listing 9-1</a> shows a file containing a programming haiku by Jorge Suarez (found at <i><a href="http://selavo.lv/wiki/index.php/Programming_haiku">http://selavo.lv/wiki/index.php/Programming_haiku</a></i>). Create a new file named <i>data.txt</i> containing these lines.</p>
<span id="lis9-1"/>
<pre><code>what is with this code?&#13;
oh my, looks like I wrote it&#13;
what was I thinking?</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-1: The text file</span> <span class="SANS_Futura_Std_Book_11">data.txt</span> <span class="SANS_Futura_Std_Book_Oblique_11">containing a programming poem</span></p>
<p class="BodyContinued">This file contains three lines of text. The line breaks are a sign that the first two lines end with an invisible newline character.</p>
<p class="TX">Now that we have a file to work with, we can write a script to read and print its contents. Create a <i>main.php</i> file in the same directory as <i>data.txt</i> and enter the code in <a href="#lis9-2">Listing 9-2</a>.</p>
<span id="lis9-2"/>
<pre><code>&lt;?php&#13;
$file = __DIR__ . '/data.txt';&#13;
&#13;
$text = file_get_contents($file);&#13;
print $text;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-2: A</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to read and print the contents of a file</span></p>
<p class="TX">First, we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">$file</span> variable containing the path and filename for our text file. Since the text file and main script are in the same directory, we create this file location string by concatenating the <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> magic constant (the path to the location of the main script) with a forward slash and the <i>data.txt</i> filename. We then use <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> to read the contents of the file into the <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> variable. Finally, we print out the string containing the file contents.</p>
<p class="TX">Run the main script at the terminal and you should see the haiku printed across three lines, just as it appears in <a href="#lis9-1">Listing 9-1</a>. This is because the invisible newline characters in the file made it into the <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> string, just like the visible characters. We can prove these invisible characters exist in a couple of ways: by checking the size of the text file or by replacing the newlines with visible characters in the string read from the file. To make it really easy to see how newline characters are part of a text file, let’s replace the contents of <i>data.txt</i> with that of <a href="#lis9-3">Listing 9-3</a>.</p>
<span id="lis9-3"/>
<pre><code>a&#13;
b</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-3: A simplified</span> <span class="SANS_Futura_Std_Book_11">data.txt</span> <span class="SANS_Futura_Std_Book_Oblique_11">file</span></p>
<p class="TX"><span aria-label="159" epub:type="pagebreak" id="pg_159" role="doc-pagebreak"/>Now that the file consists of just two characters, each on a separate line, we can more easily examine the contents of the file. Update <i>main.php</i> to match <a href="#lis9-4">Listing 9-4</a>.</p>
<span id="lis9-4"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$file = __DIR__ . '/data.txt';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$text = file_get_contents($file);</span>&#13;
&#13;
$numBytes = filesize($file);&#13;
$newlinesChanged = str_replace("\n", 'N', $text);&#13;
&#13;
print "numBytes = $numBytes\n";&#13;
print $newlinesChanged;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-4: An updated</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to prove the existence of newline characters</span></p>
<p class="TX">As before, we first read the contents of the file into the <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> variable. Then we read the size of the file with the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">filesize()</span> function, which returns the file’s number of bytes. In a text file with basic ASCII characters, each character (including invisible characters) takes up 1 byte, so we should expect the result to be <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>. Next, we generate another string that replaces each newline character (<span class="SANS_TheSansMonoCd_W5Regular_11">"\n"</span>) in <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> with a capital letter <span class="SANS_TheSansMonoCd_W5Regular_11">N</span>, storing the result in the <span class="SANS_TheSansMonoCd_W5Regular_11">$newLinesChanged</span> variable. Finally, we print the file size and the updated string. Here’s the output of running this script at the terminal:</p>
<pre><code>numBytes = 3&#13;
aNb</code></pre>
<p class="TX">The first line confirms that the file contains just three characters (bytes) of data: the letter <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>, a newline character, and the letter <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>. The second line is the string representing the contents of the file with the newlines made visible: <span class="SANS_TheSansMonoCd_W5Regular_11">aNb</span> again confirms that the file contains just three characters, with a newline character between the two letters.</p>
<p class="TX">Confirming that the newlines exist isn’t a trivial exercise: later in the chapter, we’ll explore functions that work with a file’s contents line by line. These functions rely on invisible newlines to know where one line ends and the next begins.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">file_get_contents()</span> <i>function can also read files from the web rather than from your local machine if you pass it a full URL to the file’s location. For example, try storing the URL</i> <span class="note_LinkURL"><a href="https://filesamples.com/samples/document/txt/sample1.txt">https://filesamples.com/samples/document/txt/sample1.txt</a></span> <i>in the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$file</span> <i>variable and then calling</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">file_get_contents($file)</span> <i>as in <a href="#lis9-2">Listing 9-2</a>. You should get back a string of nonsensical Latin text.</i></p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_129"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Confirming That a File Exists</span></h4>
<p class="TNI1">The previous examples assume that a file named <i>data.txt</i> exists. In practice, however, it’s a good idea to test that a file exists before attempting to read <span aria-label="160" epub:type="pagebreak" id="pg_160" role="doc-pagebreak"/>its contents. Otherwise, if you attempt to open or read a file that can’t be found, you’ll get a runtime warning such as the following:</p>
<pre><code>PHP Warning:  file_get_contents(/Users/matt/nofile.txt): Failed to open&#13;
stream: No such file or directory in /Users/matt/main.php on line 4</code></pre>
<p class="TX">Execution will continue after the warning, which can lead to further warnings and errors if the script attempts to manipulate the contents of the nonexistent file. To make your code more robust and able to cope with a missing file, you can use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">file_exists()</span> function. It returns a Boolean value confirming whether the provided file exists. Let’s try it out by updating <i>main.php</i> with the contents of <a href="#lis9-5">Listing 9-5</a>.</p>
<span id="lis9-5"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$file = __DIR__ . '/data.txt';</span>&#13;
$file2 = __DIR__ . '/data2.txt';&#13;
&#13;
$text = "file not found: $file";&#13;
$text2 = "file not found: $file2";&#13;
&#13;
if (file_exists($file)) {&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    $text = file_get_contents($file);</span>&#13;
}&#13;
&#13;
if (file_exists($file2)) {&#13;
    $text2 = file_get_contents($file2);&#13;
}&#13;
&#13;
print $text . "\n";&#13;
print $text2 . "\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-5: An updated</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to confirm the existence of a file before reading it</span></p>
<p class="TX">Here we add <span class="SANS_TheSansMonoCd_W5Regular_11">$file2</span>, a second variable holding a path to a nonexistent file, <i>data2.txt</i>. Before attempting to read anything, we assign a default <span class="SANS_TheSansMonoCd_W5Regular_11">file not found</span> message to the <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$text2</span> variables. This way, these variables will still hold something, even if we fail to read the contents of a file. We next use the <span class="SANS_TheSansMonoCd_W5Regular_11">file_exists()</span> function in two successive <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements to ensure that we attempt to read the contents of <i>data.txt</i> and <i>data2.txt</i> only if those files can be found. Then we print the contents of <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$text2</span>, each followed by a newline character. Here’s the result:</p>
<pre><code>a&#13;
b&#13;
file not found: /Users/matt/data2.txt</code></pre>
<p class="TX">Since <i>data.txt</i> can be found, its contents have been read into <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> (replacing the default <span class="SANS_TheSansMonoCd_W5Regular_11">file not found</span> message) and printed out. Meanwhile, since <i>data2.txt</i> doesn’t exist, printing <span class="SANS_TheSansMonoCd_W5Regular_11">$text2</span> ends up displaying a message indicating that the file can’t be found.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<span aria-label="161" epub:type="pagebreak" id="pg_161" role="doc-pagebreak"/>
<h4 class="H2" id="sec3"><span id="toc-link_130"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">“Touching” a File</span></h4>
<p class="TNI1">Linux and macOS have a <span class="SANS_TheSansMonoCd_W5Regular_11">touch</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">file</span> terminal command that either updates the last accessed or modified timestamp of the specified file to the current datetime or creates an empty file if that file doesn’t already exist. PHP offers the almost identical <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> function, which provides another way to ensure that a file exists before trying to access it. If you don’t mind a file’s contents being empty, you can replace the default <span class="SANS_TheSansMonoCd_W5Regular_11">file not found</span> messages and <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements from <a href="#lis9-5">Listing 9-5</a> with simple <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> statements, as shown in <a href="#lis9-6">Listing 9-6</a>.</p>
<span id="lis9-6"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$file = __DIR__ . '/data.txt';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$file2 = __DIR__ . '/data2.txt';</span>&#13;
&#13;
touch($file);&#13;
touch($file2);&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$text1 = file_get_contents($file);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$text2 = file_get_contents($file2);</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print $text1 . "\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print $text2 . "\n";</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-6: An updated</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to “touch” files before reading them</span></p>
<p class="TX">We now pass each filename to <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> before using <span class="SANS_TheSansMonoCd_W5Regular_11">file_read_contents()</span> to read the files. This lets us safely read the files without <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements and <span class="SANS_TheSansMonoCd_W5Regular_11">file_exists()</span>, since we know <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> will create the files (albeit empty ones) if they don’t already exist.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="toc-link_131"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Ensuring That a Directory Exists</span></h4>
<p class="TNI1">We’ve so far been working with files in the same directory as the executing script, but a file could also be in a different directory. In that case, it’s important to confirm that the directory exists (and perhaps create it if it doesn’t), since just like a missing file, a nonexistent directory will trigger a runtime warning. PHP has two built-in functions for this: <span class="SANS_TheSansMonoCd_W5Regular_11">is_dir()</span> returns a Boolean value confirming whether a specified directory path can be found, and <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir()</span> attempts to create a directory at the specified path.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mkdir()</span> <i>function will throw a runtime warning if the directory it’s trying to create already exists or if it can’t be created based on the current permissions settings. For more on permissions, see “Directory and File Permissions” on <a href="#pg_163">page 163</a>.</i></p>
<p class="TX">To try these functions, update the contents of <i>main.php</i> as shown in <a href="#lis9-7">Listing 9-7</a>.</p>
<span id="lis9-7"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
$dir = __DIR__ . '/var';&#13;
$file = $dir . '/data.txt';&#13;
&#13;
<span aria-label="162" epub:type="pagebreak" id="pg_162" role="doc-pagebreak"/>if (!is_dir($dir)) {&#13;
    mkdir($dir);&#13;
}&#13;
&#13;
touch($file);&#13;
&#13;
$text = file_get_contents($file);&#13;
print $text;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-7: An updated</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to create a directory if it doesn’t exist</span></p>
<p class="TX">We break the desired path and filename into two variables: <span class="SANS_TheSansMonoCd_W5Regular_11">$dir</span> holds the path to the directory where the file is to be read from, and <span class="SANS_TheSansMonoCd_W5Regular_11">$file</span> holds the path plus the filename. We set <span class="SANS_TheSansMonoCd_W5Regular_11">$dir</span> to the <i>/var</i> subdirectory within the directory where our script is executing (<span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span>); this subdirectory doesn’t exist. The <span class="SANS_TheSansMonoCd_W5Regular_11">if (!is_dir($dir))</span> statement checks whether <span class="SANS_TheSansMonoCd_W5Regular_11">$dir</span> is <i>not</i> a valid directory path and calls <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir()</span> to create the directory if it isn’t. We’re then safe to call <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> on the file, since we now know the directory exists, and then to read the file, since <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> creates the file if it, too, doesn’t exist.</p>
<p class="TX">The default option for <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir()</span> is that the function isn’t recursive: it will fail to create a directory if the parent of that directory doesn’t exist. However, the function has an optional <span class="SANS_TheSansMonoCd_W5Regular_11">recursive</span> parameter; if it’s set to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, the function will create any missing parent directories as well. <a href="#lis9-8">Listing 9-8</a> shows an example.</p>
<span id="lis9-8"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
$dir = __DIR__ . '/sub/subsub';&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$file = $dir . '/data.txt';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">if (!is_dir($dir)) {</span>&#13;
    mkdir($dir, recursive: true);&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">touch($file);</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$text = file_get_contents($file);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print $text;</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-8: An updated</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to recursively create directories if they’re missing</span></p>
<p class="TX">The directory path now includes a <i>/subsub</i> directory inside a <i>/sub</i> directory inside the current directory of the executing script. Inside the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement, we call <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir()</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">recursive</span> argument set to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. This ensures that the function won’t create just the <i>/subsub</i> directory but also its parent <i>/sub</i> directory if necessary. We have to set <span class="SANS_TheSansMonoCd_W5Regular_11">recursive</span> as a named argument, since <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir()</span> takes another optional argument to set the new directory’s permissions, and this argument comes before <span class="SANS_TheSansMonoCd_W5Regular_11">recursive</span> in the function signature.</p>
<aside aria-labelledby="box-7" class="box">
<span aria-label="163" epub:type="pagebreak" id="pg_163" role="doc-pagebreak"/>
<h5 class="BoxTitle" id="box-7"><span class="SANS_Dogma_OT_Bold_B_11">DIRECTORY AND FILE PERMISSIONS</span></h5>
<p class="BoxBodyFirst"><span class="SANS_Futura_Std_Book_11">The default permission setting for a directory created with</span> <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir()</span> <span class="SANS_Futura_Std_Book_11">is full</span> <span class="SANS_Futura_Std_Book_Oblique_11">read-write-execute</span><span class="SANS_Futura_Std_Book_11">, meaning anyone can read, write, or execute files in that directory. The best practice, however, is to use the minimum required permissions. To apply a different setting, use the function’s optional</span> <span class="SANS_TheSansMonoCd_W5Regular_11">permissions</span> <span class="SANS_Futura_Std_Book_11">argument. You can also change the permissions for an existing file or directory by using the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">chmod(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">file</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">permissions</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> <span class="SANS_Futura_Std_Book_11">function. In both cases, you specify the permission as an octal (base-8) integer. Octal numbers are prefixed with either</span> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <span class="SANS_Futura_Std_Book_11">(zero) or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">0o</span> <span class="SANS_Futura_Std_Book_11">(zero and a lowercase letter o). Here are the octal codes for some commonly used permissions:</span></p>
<p class="BoxRunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">0o777</span><span class="SANS_Futura_Std_Book_11">   Everyone can read, write, and execute (default for the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir()</span> <span class="SANS_Futura_Std_Book_11">function).</span></p>
<p class="BoxRunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">0o600</span><span class="SANS_Futura_Std_Book_11">   The file owner can read and write; no access is given to anyone else.</span></p>
<p class="BoxRunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">0o664</span><span class="SANS_Futura_Std_Book_11">   The file owner and group can read and write; any other user can only read.</span></p>
</aside>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="toc-link_132"/><span class="SANS_Futura_Std_Bold_B_11">Writing a String to a Text File</span></h3>
<p class="TNI1">Just as you can use <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> to read the contents of a file into a string, you can write the contents of a string to a text file by using the reciprocal <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> function. This function automatically creates the file being written to if it doesn’t exist, so you don’t need to worry about testing the filename first. The updated <i>main.php</i> script in <a href="#lis9-9">Listing 9-9</a> shows how it works.</p>
<span id="lis9-9"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
$content = &lt;&lt;&lt;CONTENT&#13;
    the cat&#13;
    sat&#13;
    on the mat!&#13;
    CONTENT;&#13;
&#13;
$file = __DIR__ . '/newfile.txt';&#13;
&#13;
file_put_contents($file, $content);&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$text = file_get_contents($file);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print $text;</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-9: A</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script writing data from a string to a file</span></p>
<p class="TX">First, we declare a three-line heredoc string, <span class="SANS_TheSansMonoCd_W5Regular_11">$content</span>, using <span class="SANS_TheSansMonoCd_W5Regular_11">CONTENT</span> as the delimiter. Then we set the <span class="SANS_TheSansMonoCd_W5Regular_11">$file</span> variable to the current directory path plus the filename <i>newfile.txt</i>. Next, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> function, passing it the destination file and the text to write to that file. This should create a file <i>newfile.txt</i> containing the text from the <span class="SANS_TheSansMonoCd_W5Regular_11">$content</span> heredoc. <span aria-label="164" epub:type="pagebreak" id="pg_164" role="doc-pagebreak"/>To confirm that the file has been created with the text content, we use <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> to read the text back out of the file and into the <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> variable, which we then print. Here’s the result:</p>
<pre><code>the cat&#13;
sat&#13;
on the mat!</code></pre>
<p class="BodyContinued">The output matches the original heredoc string, indicating we successfully wrote the string to <i>newfile.txt</i> and read it back out again.</p>
<p class="TX">If the file you’re trying to write to already exists, the default behavior of <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> is to completely replace (overwrite) the contents of that file. To avoid this, call the function with the <span class="SANS_TheSansMonoCd_W5Regular_11">FILE_APPEND</span> option. This adds the new text to the end of the file after its existing content. <a href="#lis9-10">Listing 9-10</a> shows an example, updated from <a href="#lis9-9">Listing 9-9</a>.</p>
<span id="lis9-10"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
$newContent = &lt;&lt;&lt;CONTENT&#13;
    the rat&#13;
    spat&#13;
    on the cat!&#13;
    CONTENT;&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$file = __DIR__ . '/newfile.txt';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">file_put_contents($file,</span> $newContent, FILE_APPEND);&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$text = file_get_contents($file);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print $text;</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-10: A</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script appending text to the end of a file</span></p>
<p class="TX">This time we create a different heredoc string and add it to <i>newfile.txt</i> by calling <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">FILE_APPEND</span> as a third argument. This should append the string after the current contents of the file, as the output confirms:</p>
<pre><code>the cat&#13;
sat&#13;
on the mat!&#13;
the rat&#13;
spat&#13;
on the cat!</code></pre>
<p class="TX">Try running the code in <a href="#lis9-10">Listing 9-10</a> again without the <span class="SANS_TheSansMonoCd_W5Regular_11">FILE_APPEND</span> option. You’ll find that only the text from <span class="SANS_TheSansMonoCd_W5Regular_11">$newContent</span> appears in the output, since the existing text in the file is overwritten.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="toc-link_133"/><span class="SANS_Futura_Std_Bold_B_11">Managing Files and Directories</span></h3>
<p class="TNI1">Beyond reading from and writing to files, PHP offers functions to help manage existing files and directories. For example, you can delete a file <span aria-label="165" epub:type="pagebreak" id="pg_165" role="doc-pagebreak"/>with the <span class="SANS_TheSansMonoCd_W5Regular_11">unlink()</span> function or delete a whole directory with <span class="SANS_TheSansMonoCd_W5Regular_11">rmdir()</span>. Both functions return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> if successful or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> otherwise. As with reading files, it’s important to test for the existence of a file or directory before attempting to delete it. Otherwise, if you call <span class="SANS_TheSansMonoCd_W5Regular_11">unlink()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">rmdir()</span> on a file or directory that doesn’t exist, you’ll get a warning (but execution will continue). <a href="#lis9-11">Listing 9-11</a> shows these functions in action.</p>
<span id="lis9-11"/>
<pre><code>&lt;?php&#13;
$dir = __DIR__ . '/var';&#13;
$file = $dir . '/data.txt';&#13;
&#13;
if (!is_dir($dir)) {&#13;
    mkdir($dir);&#13;
}&#13;
&#13;
touch($file);&#13;
&#13;
var_dump(is_dir($dir));&#13;
var_dump(file_exists($file));&#13;
&#13;
unlink($file);&#13;
rmdir($dir);&#13;
&#13;
var_dump(file_exists($file));&#13;
var_dump(is_dir($dir));</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-11: A</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to create and then delete a directory and a file</span></p>
<p class="TX">As in some earlier examples, we declare the target directory and filename in two variables, <span class="SANS_TheSansMonoCd_W5Regular_11">$dir</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$file</span>. We then create the directory if it doesn’t already exist and <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> the file. At this point, we should be confident that a <i>data.txt</i> file exists in a <i>/var</i> directory; we confirm this by <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump</span>ing the results of calling <span class="SANS_TheSansMonoCd_W5Regular_11">is_dir()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file_exists()</span>. Next, we use <span class="SANS_TheSansMonoCd_W5Regular_11">unlink($file)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rmdir($dir)</span> to delete the file and its directory. Finally, we make the same <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> calls again to make sure that neither the directory nor the file exists when the script finishes execution. If you run this script, you should see <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> displayed, confirming that the directory and file existed and then were successfully deleted.</p>
<p class="TX">Another useful file-management function is <span class="SANS_TheSansMonoCd_W5Regular_11">rename()</span>, which changes the name of a file or directory. For example, you could rename <i>oldfile.txt</i> to <i>newfile.txt</i> with this statement:</p>
<pre><code>rename('oldfile.txt', 'newfile.txt');</code></pre>
<p class="TX">You need to be careful with this function, testing that the old file or directory exists first. It’s also important to be mindful about the new file or directory. If you’re renaming a file and another file already exists with that name, it will be overwritten with no error or warning, which could be problematic if you need the contents of that overwritten file. If you’re renaming a directory and the new directory already exists, a warning will be generated, which is also not ideal, since it’s best to avoid warnings. <span aria-label="166" epub:type="pagebreak" id="pg_166" role="doc-pagebreak"/>If you’re renaming a file into a different directory, you also should ensure that the new directory exists and, if appropriate, is writable (which is required by Windows). See <i><a href="https://www.php.net/manual/en/function.rename.php">https://www.php.net/manual/en/function.rename.php</a></i> for more about this function.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="toc-link_134"/><span class="SANS_Futura_Std_Bold_B_11">Reading a File into an Array</span></h3>
<p class="TNI1">PHP’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">file()</span> function reads the contents of a file into an array rather than a single string, with one array element for each line in the file. This is useful when you want to perform an action for each line (such as displaying the line’s contents alongside its line number, as in the following example), or when each line represents one item in a set of data to be processed, such as the data in a comma-separated values (CSV) file. <a href="#lis9-12">Listing 9-12</a> shows a main script demonstrating the <span class="SANS_TheSansMonoCd_W5Regular_11">file()</span> function.</p>
<span id="lis9-12"/>
<pre><code>&lt;?php&#13;
$file = __DIR__ . '/data.txt';&#13;
&#13;
$lines = file($file);&#13;
&#13;
foreach ($lines as $key =&gt; $line) {&#13;
    print "[$key]$line";&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-12: A</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to loop through and print each line of a text file</span></p>
<p class="TX">We pass the file information (in the <span class="SANS_TheSansMonoCd_W5Regular_11">$file</span> variable) to the <span class="SANS_TheSansMonoCd_W5Regular_11">file()</span> function, which reads the contents of <i>data.txt</i> line by line into an array called <span class="SANS_TheSansMonoCd_W5Regular_11">$lines</span>. Then we use a <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop to print each element of the array (a line from the file) individually, along with its numeric key. If <i>data.txt</i> contains the three-line haiku from <a href="#lis9-1">Listing 9-1</a>, the output should look as follows:</p>
<pre><code>[0]what is with this code?&#13;
[1]oh my, looks like I wrote it&#13;
[2]what was I thinking?</code></pre>
<p class="TX">You can pass optional flags as a second argument to the <span class="SANS_TheSansMonoCd_W5Regular_11">file()</span> function to, for example, exclude the newline character at the end of each line (<span class="SANS_TheSansMonoCd_W5Regular_11">FILE_IGNORE_NEW_LINES</span>) or completely ignore empty lines in the file (<span class="SANS_TheSansMonoCd_W5Regular_11">FILE_SKIP_EMPTY_LINES</span>).</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="toc-link_135"/><span class="SANS_Futura_Std_Bold_B_11">Using Lower-Level File Functions</span></h3>
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> functions take care of all the steps of working with a file for you, such as opening the file, accessing its contents, and closing the file again. In most situations, those functions are all you need. Sometimes, however, you may need to work with files at a lower level, perhaps processing them one line, or even one character, at a time. <span aria-label="167" epub:type="pagebreak" id="pg_167" role="doc-pagebreak"/>In those cases, you might need to explicitly manage the various file-access steps in your code through a series of separate, lower-level function calls.</p>
<p class="TX">PHP’s lower-level file functions require you to work with a <i>filesystem pointer</i> (or just <i>file pointer</i>), a reference to a location in the file’s data. Internally, PHP treats a file as a <i>bytestream</i> (a resource object that can be read from and written to in a linear fashion), and the file pointer provides access to that stream. You obtain a file pointer by calling <span class="SANS_TheSansMonoCd_W5Regular_11">fopen()</span> with a path to the file you want to access. You also have to pass in a string specifying <i>how</i> you want to interact with the file; for example, files can be opened only for reading, only for writing, for both reading and writing, and so on. <a href="#tab9-1">Table 9-1</a> shows the strings for specifying some common <span class="SANS_TheSansMonoCd_W5Regular_11">fopen()</span> modes.</p>
<p class="TT"><a id="tab9-1"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 9-1:</span></span> <span class="SANS_Futura_Std_Book_11">Common</span> <span class="SANS_TheSansMonoCd_W5Regular_11">fopen()</span> <span class="SANS_Futura_Std_Book_11">Modes</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Mode string</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Position of file pointer</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Outcome if file doesn’t exist</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">'r'</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Read only</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Beginning of file</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Warning</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">'r+'</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Read and write (overwrite)</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Beginning of file</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Warning</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">'w'</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Write only (overwrite)</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Beginning of file (and</span> <span class="SANS_Futura_Std_Book_Oblique_11">truncate</span> <span class="SANS_Futura_Std_Book_11">the file by removing any existing content)</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Attempt to create a file</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">'a'</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Write only (append)</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">End of file</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Attempt to create a file</span></p></td>
</tr>
</tbody>
</table>
<p class="TX">The typical sequence of actions when working with a file is as follows:</p>
<p class="ListNumberF">1.   Open a file in the appropriate mode and get a file pointer.</p>
<p class="ListNumber">2.   Change the location of the file pointer in the file if necessary.</p>
<p class="ListNumber">3.   Read or write at the location of the file pointer.</p>
<p class="ListNumber">4.   Repeat steps 2 and 3 as required.</p>
<p class="ListNumberL">5.   Close the file pointer.</p>
<p class="TX"><a href="#lis9-13">Listing 9-13</a> demonstrates this process. This script achieves the same results as <a href="#lis9-2">Listing 9-2</a> (reading the contents of a file to a string) by using the lower-level <span class="SANS_TheSansMonoCd_W5Regular_11">fopen()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">fread()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">fclose()</span> functions.</p>
<span id="lis9-13"/>
<pre><code>&lt;?php&#13;
$file = __DIR__ . '/data.txt';&#13;
&#13;
$fileHandle = fopen($file, 'r');&#13;
$filesizeBytes = filesize($file);&#13;
$text = fread($fileHandle, $filesizeBytes);&#13;
fclose($fileHandle);&#13;
&#13;
print $text;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-13: Using lower-level functions to read a file</span></p>
<p class="TX"><span aria-label="168" epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/>First, we use <span class="SANS_TheSansMonoCd_W5Regular_11">fopen()</span> to open <i>data.txt</i>, using the string <span class="SANS_TheSansMonoCd_W5Regular_11">'r'</span> to specify read-only mode. The function returns a file pointer located at the beginning of the file, which we store in the <span class="SANS_TheSansMonoCd_W5Regular_11">$fileHandle</span> variable. Next, we call <span class="SANS_TheSansMonoCd_W5Regular_11">filesize()</span> to look up the size of the file (in bytes). We then call the <span class="SANS_TheSansMonoCd_W5Regular_11">fread()</span> function, passing it the file pointer and the size of the file (<span class="SANS_TheSansMonoCd_W5Regular_11">$filesizeBytes</span>) to read the entire contents of the file into the <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> variable. If we wanted to read only part of the file, we could specify a different number of bytes as the second argument to the <span class="SANS_TheSansMonoCd_W5Regular_11">fread()</span> function. (We’d also want to specify a different number of bytes if the file pointer were located somewhere other than the beginning of the file.) To finish up, we close the file by passing the file pointer to the <span class="SANS_TheSansMonoCd_W5Regular_11">fclose()</span> function. Closing the file enables it to be used by other system processes and protects it from being corrupted if any errors occur in the script currently being executed.</p>
<p class="TX">This example illustrates some of the most common low-level file functions, but PHP has many others. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">fgets()</span> reads one line of a file (up to the next newline) from the current file-pointer location, and <span class="SANS_TheSansMonoCd_W5Regular_11">fgetc()</span> reads just one character from the current file-pointer location. The <span class="SANS_TheSansMonoCd_W5Regular_11">feof()</span> function takes in a file pointer and returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> based on whether the pointer is at the end of the file. This is useful for loops such as the following:</p>
<pre><code>while (!feof($fileResource)) {&#13;
    // Do something at current file pointer position&#13;
}</code></pre>
<p class="TX">Here we use the NOT operator (<span class="SANS_TheSansMonoCd_W5Regular_11">!</span>) to negate the result of <span class="SANS_TheSansMonoCd_W5Regular_11">feof()</span>, so the loop will keep repeating until the pointer gets to the end of the file. Inside this kind of loop, we might read a line from the file with <span class="SANS_TheSansMonoCd_W5Regular_11">fgets()</span>, read the next character with <span class="SANS_TheSansMonoCd_W5Regular_11">fgetc()</span>, or read a fixed number of bytes with <span class="SANS_TheSansMonoCd_W5Regular_11">fread()</span>. Logic in the loop would then process the data (if successfully read), and if we reach the end of the file while reading, the loop would terminate.</p>
<p class="TX">Some functions are just for working with and changing the file pointer. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">rewind()</span> moves the file pointer back to the beginning of the file, and <span class="SANS_TheSansMonoCd_W5Regular_11">ftell()</span> returns the current location of the pointer, specified as the number of bytes from the start of the file. The <span class="SANS_TheSansMonoCd_W5Regular_11">fseek()</span> function moves the file pointer to a given position in the file specified relative to its current position, the beginning or the end of the file.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="toc-link_136"/><span class="SANS_Futura_Std_Bold_B_11">Processing Multiple Files</span></h3>
<p class="TNI1">Let’s combine a lot of what we’ve discussed so far in this chapter in a more sophisticated example that programmatically extracts data from multiple files and collects it all in a new summary file. We’ll attempt to gather the names and game scores of three players, each in a separate file (<i>joe.txt</i>, <i>matt.txt</i>, and <i>sinead.txt</i>), reformat the data, and write it to a single output file called <i>total.txt</i>. <a href="#lis9-14">Listings 9-14</a> through <a href="#lis9-16">9-16</a> show the three raw data files we want to process.</p>
<span id="lis9-14"/>
<pre><code><span aria-label="169" epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/>Joe&#13;
O'Brien&#13;
&#13;
55</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-14:</span> <span class="SANS_Futura_Std_Book_11">joe.txt</span></p>
<span id="lis9-15"/>
<pre><code>Matthew&#13;
&#13;
Smith&#13;
&#13;
99</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-15:</span> <span class="SANS_Futura_Std_Book_11">matt.txt</span></p>
<span id="lis9-16"/>
<pre><code>&#13;
Sinead&#13;
Murphy&#13;
&#13;
101</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-16:</span> <span class="SANS_Futura_Std_Book_11">sinead.txt</span></p>
<p class="TX">Notice that the content in each data file is a little messy, with randomly located blank lines: <a href="#lis9-15">Listing 9-15</a> ends with a blank line, and <a href="#lis9-16">Listing 9-16</a> starts and ends with two blank lines. That said, each data file has the same sequence of content: a line containing the player’s first name, a line with their last name, and a line with their integer score.</p>
<p class="TX">In the output file, we want to consolidate all the data about each player onto a single line, as well as display the total of all three players’ scores. <a href="#lis9-17">Listing 9-17</a> shows how the resulting <i>total.txt</i> file should appear.</p>
<span id="lis9-17"/>
<pre><code>Player = Joe O'Brien / Score = 55&#13;
Player = Matthew Smith / Score = 99&#13;
Player = Sinead Murphy / Score = 101&#13;
total of all scores = 255</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-17: The consolidated</span> <span class="SANS_Futura_Std_Book_11">total.txt</span> <span class="SANS_Futura_Std_Book_Oblique_11">file we want to create</span></p>
<p class="TX">To achieve this final result, we’ll need to handle each part of the data files differently, so we can’t simply load a whole file into a string with <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span>. It will be better to use <span class="SANS_TheSansMonoCd_W5Regular_11">file()</span> to read in each file as an array of individual lines.</p>
<p class="TX">When working with multiple files, PHP’s oddly named <span class="SANS_TheSansMonoCd_W5Regular_11">glob()</span> function is a powerful tool. It returns an array of file and directory paths that match a given pattern. This is particularly helpful for identifying and then looping through all the data files in a given location. For example, the following <span aria-label="170" epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>statement provides an array of paths to all <i>.txt</i> files in the <i>/data</i> subfolder relative to the location of the executing script:</p>
<pre><code>$files = glob(__DIR__ . '/data/*.txt')</code></pre>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">*</span> is a wildcard representing any number of characters, so <span class="SANS_TheSansMonoCd_W5Regular_11">'/data/*.txt'</span> will match any filename with a <i>.txt</i> extension in the given folder. That’s exactly what we’ll need to gather the player data files in this example.</p>
<p class="TX">Start a new project and create a <i>/data</i> subfolder containing the text files <i>joe.txt</i>, <i>matt.txt</i>, and <i>sinead.txt</i> shown previously in <a href="#lis9-14">Listings 9-14</a> through <a href="#lis9-16">9-16</a>. Then, in the main project folder, create a <i>main.php</i> script with the contents of <a href="#lis9-18">Listing 9-18</a>.</p>
<span id="lis9-18"/>
<pre><code>&lt;?php&#13;
$dir = __DIR__ . '/data/';&#13;
$fileNamePattern = '*.txt';&#13;
$files = glob($dir . $fileNamePattern); <span aria-label="annotation1" class="codewide_CodeAnnotation">❶</span>&#13;
&#13;
$outputFile = __DIR__ . '/total.txt';&#13;
touch($outputFile);&#13;
unlink($outputFile);&#13;
&#13;
$total = 0;&#13;
foreach ($files as $file) {<span aria-label="annotation2" class="codewide_CodeAnnotation">❷</span>&#13;
    $lines = file($file, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);&#13;
    $firstName = $lines[0];&#13;
    $lastName = $lines[1];&#13;
    $scoreString = $lines[2];&#13;
    $score = intval($scoreString);&#13;
&#13;
    $outputFileHandle = fopen($outputFile, 'a');&#13;
    fwrite($outputFileHandle, "Player = $firstName $lastName / Score = $score\n"); <span aria-label="annotation3" class="codewide_CodeAnnotation">❸</span>&#13;
    fclose($outputFileHandle);&#13;
&#13;
    $total += $score;&#13;
}&#13;
&#13;
$outputFileHandle = fopen($outputFile, 'a');&#13;
fwrite($outputFileHandle, "total of all scores = $total");&#13;
fclose($outputFileHandle);&#13;
&#13;
print file_get_contents($outputFile); <span aria-label="annotation4" class="codewide_CodeAnnotation">❹</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-18: A script processing multiple files</span></p>
<p class="TX">We first assign the path to the <i>/data</i> subfolder from the location of the executing script to the <span class="SANS_TheSansMonoCd_W5Regular_11">$dir</span> variable, and the filename pattern string <span class="SANS_TheSansMonoCd_W5Regular_11">'*.txt'</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">$fileNamePattern</span>, using the <span class="SANS_TheSansMonoCd_W5Regular_11">*</span> wildcard to represent any <i>.txt</i> file. We then call <span class="SANS_TheSansMonoCd_W5Regular_11">glob()</span> to get an array of all the files in <span class="SANS_TheSansMonoCd_W5Regular_11">$dir</span> matching the pattern in <span class="SANS_TheSansMonoCd_W5Regular_11">$fileNamePattern</span>, storing the result in the <span class="SANS_TheSansMonoCd_W5Regular_11">$files</span> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Thanks to <span class="SANS_TheSansMonoCd_W5Regular_11">glob()</span>, we know that all the files in the <span class="SANS_TheSansMonoCd_W5Regular_11">$files</span> array exist, so we can avoid the ordeal of checking whether they exist before trying to read them.</p>
<p class="TX"><span aria-label="171" epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/>Next, we assign a path to <i>total.txt</i> to the <span class="SANS_TheSansMonoCd_W5Regular_11">$outputFile</span> variable. This file may or may not exist already, but we want a fresh output file each time we run the script. We therefore <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> the file, which creates it if it doesn’t exist already, and then use <span class="SANS_TheSansMonoCd_W5Regular_11">unlink()</span> to delete the file. Now we can be sure that we’re writing to an empty file when it comes time to gather the data into <i>total.txt</i>.</p>
<p class="TX">After initializing the <span class="SANS_TheSansMonoCd_W5Regular_11">$total</span> variable to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, we use a <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop <span aria-label="annotation2" class="CodeAnnotation">❷</span> to iterate over the filepaths in the <span class="SANS_TheSansMonoCd_W5Regular_11">$files</span> array, storing each path in a temporary <span class="SANS_TheSansMonoCd_W5Regular_11">$file</span> variable. For each file, we use <span class="SANS_TheSansMonoCd_W5Regular_11">file()</span> to read the contents into an array called <span class="SANS_TheSansMonoCd_W5Regular_11">$lines</span>. Calling the function with the <span class="SANS_TheSansMonoCd_W5Regular_11">FILE_IGNORE_NEW_LINES</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">FILE_SKIP_EMPTY_LINES</span> flags ensures that end-of-line characters will be ignored and that empty lines will be excluded from the resulting array. Knowing what we know about each data file, this means that <span class="SANS_TheSansMonoCd_W5Regular_11">$lines</span> should be a three-element array: the first element is the player’s first name, the second element is their last name, and the third element is their score (represented as a string). We read these values from the array into separate <span class="SANS_TheSansMonoCd_W5Regular_11">$firstName</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">$lastName</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">$scoreString</span> variables and use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">intval()</span> function to convert the score from a string to an integer.</p>
<p class="TX">Still within the <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop, we call <span class="SANS_TheSansMonoCd_W5Regular_11">fopen()</span> to get a file pointer to the output file (<i>total.txt</i>) in write-append mode (specified with the <span class="SANS_TheSansMonoCd_W5Regular_11">'a'</span> mode string), meaning the pointer will be located at the end of the file. The first time through the loop, <i>total.txt</i> won’t exist, so <span class="SANS_TheSansMonoCd_W5Regular_11">fopen()</span> will create the file. We then use <span class="SANS_TheSansMonoCd_W5Regular_11">fwrite()</span> to append a string to the output file, summarizing the player’s name and score and ending with a newline character (<span class="SANS_TheSansMonoCd_W5Regular_11">\n</span>) <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We close the output file with <span class="SANS_TheSansMonoCd_W5Regular_11">fclose()</span> and add the current player’s score to the <span class="SANS_TheSansMonoCd_W5Regular_11">$total</span> variable.</p>
<p class="TX">Finally, after the <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop has completed, we once again access the output file in write-append mode and append a final string including the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$total</span>. Then, to make sure this has all worked, we call <span class="SANS_TheSansMonoCd_W5Regular_11">file_get _contents()</span> to read the output file into a string and print the result <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Notice that we call the function directly from the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement, instead of storing the string in a variable first.</p>
<p class="TX">If you run the <i>main.php</i> script, you should get the <i>total.txt</i> file shown previously in <a href="#lis9-17">Listing 9-17</a>. In fact, you can run this script as many times as you want and the result will always be the same, since any existing <i>total.txt</i> file is deleted with the combination of the <span class="SANS_TheSansMonoCd_W5Regular_11">touch()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">unlink()</span> functions.</p>
<p class="TX">Strictly speaking, our <i>main.php</i> script isn’t the most efficient way to code the desired logic. We don’t need to open and close the output file each time during the <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop; we could open it just once before the loop and then close it once after appending the total score. However, opening it each time through the loop illustrates the value of write-append mode, which places the file pointer at the end of the file. This way, any new content written to the file is added after any existing content.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="toc-link_137"/><span class="SANS_Futura_Std_Bold_B_11">JSON and Other File Types</span></h3>
<p class="TNI1">PHP can work with more than <i>.txt</i> files. For example, it can also work with JavaScript Object Notation (JSON) and other text-based data formats. For <span aria-label="172" epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>JSON data, the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">json_encode()</span> function can turn a PHP array into a JSON string, and the <span class="SANS_TheSansMonoCd_W5Regular_11">json_decode()</span> function does the opposite. This type of conversion is particularly smooth since JSON data, like PHP arrays, revolves around key/value pairs. <a href="#lis9-19">Listing 9-19</a> shows these functions in action.</p>
<span id="lis9-19"/>
<pre><code>&lt;?php&#13;
$filePath = __DIR__ . '/data.json';&#13;
&#13;
$data = [&#13;
    'name' =&gt; 'matt',&#13;
    'office' =&gt; 'E-042',&#13;
    'phone' =&gt; '086-111-2323',&#13;
];&#13;
&#13;
$jsonString = json_encode($data);&#13;
&#13;
file_put_contents($filePath, $jsonString);&#13;
&#13;
$jsonStringFromFile = file_get_contents($filePath);&#13;
print $jsonStringFromFile;&#13;
&#13;
$jsonArrayFromFile = json_decode($jsonStringFromFile, true);&#13;
print "\n";&#13;
var_dump($jsonArrayFromFile);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 9-19: A script to convert an array to JSON, and vice versa</span></p>
<p class="TX">We store a path to <i>data.json</i> in the <span class="SANS_TheSansMonoCd_W5Regular_11">$filePath</span> variable. Then we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">$data</span> array that maps the values <span class="SANS_TheSansMonoCd_W5Regular_11">'matt'</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">'E-042'</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">'086-111-2323'</span> to the keys <span class="SANS_TheSansMonoCd_W5Regular_11">'name'</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">'office'</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">'phone'</span>, respectively. Next, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">json_encode()</span> function to convert the array to a JSON-formatted string, storing the result in the <span class="SANS_TheSansMonoCd_W5Regular_11">$jsonString</span> variable. We then use <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> to write the JSON string to the <i>data.json</i> file, just as we would use it to write to a <i>.txt</i> file.</p>
<p class="TX">The rest of the script goes through the same process in reverse. We use <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> to read the JSON data from the file into the <span class="SANS_TheSansMonoCd_W5Regular_11">$jsonStringFromFile</span> variable, which we print out. The variable contains a JSON string, but we use <span class="SANS_TheSansMonoCd_W5Regular_11">json_decode()</span> to convert the string into a PHP array, which we display using <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span>. We need to provide <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> as a second argument to the <span class="SANS_TheSansMonoCd_W5Regular_11">json_decode()</span> function, or the result will be a type of object rather than an array. Here’s the output of running this script at the terminal:</p>
<pre><code>{"name":"matt","office":"E 042","phone":"086 111 2323"}&#13;
array(3) {&#13;
  ["name"]=&gt;&#13;
  string(4) "matt"&#13;
  ["office"]=&gt;&#13;
  string(5) "E-042"&#13;
  ["phone"]=&gt;&#13;
  string(12) "086 111 2323"&#13;
}</code></pre>
<p class="TX"><span aria-label="173" epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/>The first line shows the JSON string that we wrote into and read back out of the <i>data.json</i> file. The string consists of a JSON object, delimited by curly brackets, containing three key/value pairs separated by commas. The keys are set off from their corresponding values by colons. The rest of the output shows the contents of <span class="SANS_TheSansMonoCd_W5Regular_11">$jsonArrayFromFile</span>, the array created by decoding the JSON data. Notice the direct correlation between the key/value pairs in the JSON object and the key/value pairs in the PHP array.</p>
<p class="TX">For YAML Ain’t Markup Language (YAML) text data files, PHP provides several functions. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">yaml_parse()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">yaml_emit()</span> are similar to <span class="SANS_TheSansMonoCd_W5Regular_11">json_decode()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">json_encode()</span> but for converting between YAML strings and PHP arrays. PHP also has direct file-to-string and string-to-file YAML functions: <span class="SANS_TheSansMonoCd_W5Regular_11">yaml_parse_file()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">yaml_emit_file()</span>.</p>
<p class="TX">For CSV files, PHP has the direct file-to-string and string-to-file functions <span class="SANS_TheSansMonoCd_W5Regular_11">fgetcsv()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fputcsv()</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">str_getcsv()</span> function takes a string in CSV format and converts it to an array. However, the function has some flaws. It doesn’t escape newline characters, for example, so it can’t cope with typical CSV files from spreadsheets like Google Sheets or Microsoft Excel. Perhaps because of this nonstandard treatment of CSV data, PHP doesn’t have a reciprocal function to create a CSV-encoded string from an array.</p>
<p class="TX">Working with eXtensible Markup Language (XML) is a little more complex. PHP represents XML data with objects, so you need to be confident with the basics of object-oriented programming to use functions such as <span class="SANS_TheSansMonoCd_W5Regular_11">simplexml_load_file()</span> and classes such as <span class="SANS_TheSansMonoCd_W5Regular_11">SimpleXMLElement</span>. However, PHP provides several powerful ways to traverse and manipulate XML data once you know how to use these features of the language. We’ll discuss object-oriented PHP in <span class="Xref"><a href="part5.xhtml">Part V</a></span>.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="toc-link_138"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">In this chapter, we worked with basic PHP functions like <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> for reading and writing data to and from external files. We also discussed the <span class="SANS_TheSansMonoCd_W5Regular_11">file()</span> function, which reads the lines of a file into separate array elements, and low-level functions like <span class="SANS_TheSansMonoCd_W5Regular_11">fread()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fwrite()</span> that let you traverse a file by using a pointer. We explored how to ensure that a file or directory exists (or doesn’t exist) before interacting with it, and how to use <span class="SANS_TheSansMonoCd_W5Regular_11">glob()</span> to get a reference to all the files that match a certain criterion. Although we mostly worked with <i>.txt</i> files, we also touched on some PHP functions for interacting with JSON, YAML, CSV, and XML data formats.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="toc-link_139"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Find a limerick online or write your own. Here’s one I found:</p>
<pre><code>A magazine writer named Bing&#13;
Could make copy from most anything&#13;
But the copy he wrote&#13;
<span aria-label="174" epub:type="pagebreak" id="pg_174" role="doc-pagebreak"/>of a ten-dollar note&#13;
Was so good he now lives in Sing Sing</code></pre>
<p class="ListBody1">Write a script that declares an array; each element of the array is a line from the limerick. Then write those lines to a text file named <i>limerick.txt</i>.</p>
<p class="ListNumber">2.   Find a sample JSON file online that’s accessible through a URL (for example, at <i><a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a></i>). Write a script that reads the JSON string from the URL, converts it to an array, and then uses <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> to display the array.</p>
<p class="ListNumber">3.   Add a new data file for a game player and their high score in the <i>data</i> folder to be processed by the script in <a href="#lis9-18">Listing 9-18</a>. Run the main script, and you should see another line added to the output file and the new score added to the total.</p>
</section>
</section>
</div></body></html>