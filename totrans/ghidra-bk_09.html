<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_119"/>
<h2 class="h2" id="ch07"><strong><span class="big">7</span><br/>DISASSEMBLY MANIPULATION</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">After navigation, disassembly modification is the next most significant feature of Ghidra. Ghidra offers the ability to easily manipulate disassemblies to add new information or reformat a listing to suit your particular needs, and because of Ghidra’s underlying structure, changes that you make to a disassembly are easily propagated to all associated Ghidra views to maintain a consistent picture of your program. Ghidra automatically handles operations such as context-aware search and replace when it makes sense to do so, and it makes trivial work of reformatting instructions as data, and data as instructions. And perhaps the best feature is that almost anything you do can be undone!</p>
<span epub:type="pagebreak" id="page_120"/>
<div class="box5">
<p class="boxtitle-c"><strong>I WISH I HADN’T DONE THAT</strong></p>
<p class="noindent">Part of being good at software reverse engineering is the ability to explore, experiment, and, when necessary, backtrack and retrace your steps. Ghidra’s powerful Undo capability allows you the flexibility to undo (and redo) actions during the SRE process. Multiple methods are available to access this magical power: the appropriate arrow icons in the CodeBrowser toolbar <span class="ent">➊➋</span>, as shown in <a href="ch07.xhtml#fig7_1">Figure 7-1</a>; Edit ▸ Undo from the CodeBrowser menu; and the hotkeys <span class="smallcaps">CTRL</span>-Z to undo and <span class="smallcaps">CTRL</span>-<span class="smallcaps">SHIFT</span>-Z to redo.</p>
<div class="image"><img src="Images/fig7-1.jpg" alt="image" width="616" height="102"/></div>
<p class="figcap" id="fig7_1"><em>Figure 7-1: Undo and Redo icons in the CodeBrowser toolbar</em></p>
</div>
<h3 class="h3" id="ch07lev118"><strong>Manipulating Names and Labels</strong></h3>
<p class="noindent">At this point, we have encountered two categories of identifiers in Ghidra disassemblies: labels (which are identifiers associated with locations) and names (which are identifiers associated with stack frame variables). For the most part, we will refer to both as <em>names</em>, as Ghidra is somewhat loose in this distinction also. (If you want to be really precise, labels actually have associated names, addresses, histories, and so on. The name of the label is how we generally reference the label.) We use more specific terms when the distinction makes a critical difference.</p>
<p class="indent">To review, stack variable names have one of two prefixes based on whether the variable is a parameter (<code>param_</code>) or a local variable (<code>local_</code>), and locations are assigned names/labels with helpful prefixes during auto analysis (for example, <code>LAB_</code>, <code>DAT_</code>, <code>FUN_</code>, <code>EXT_</code>, <code>OFF_</code>, and <code>UNK_</code>). In most cases, Ghidra will automatically generate names and labels based on its best guess about the use of the associated variable or address, but you will need to analyze the program yourself to understand the purpose of a location or variable.</p>
<p class="indent">As you begin to analyze any program, one of the first and most common ways to manipulate a disassembly listing is to change default names into more meaningful names. Fortunately, Ghidra allows you to easily change any name, and it intelligently propagates name changes throughout the entire program. To open a name-change dialog, select the name by clicking it and then use the L hotkey or the Edit Label option on the right-click context menu. From there, the process for stack variables (names) and named locations (labels) varies, as detailed in the following sections.</p>
<span epub:type="pagebreak" id="page_121"/>
<h4 class="h4" id="ch07lev119"><strong><em>Renaming Parameters and Local Variables</em></strong></h4>
<p class="noindent">Names associated with stack variables are not associated with a specific virtual address. As in most programming languages, such names are restricted to the scope of the function to which a given stack frame belongs. Thus, every function in a program can have its own stack variable named <code>param_1</code>, but no function may have more than one variable named <code>param_1</code>, as shown in <a href="ch07.xhtml#fig7_2">Figure 7-2</a>.</p>
<div class="image"><img src="Images/fig7-2.jpg" alt="image" width="328" height="510"/></div>
<p class="figcap" id="fig7_2"><em>Figure 7-2: Symbol Tree showing reuse of parameter names</em> (<span class="codeitalic">param_1</span>)</p>
<p class="indent">When you rename a variable in the Listing window, the informative dialog shown in <a href="ch07.xhtml#fig7_3">Figure 7-3</a> will pop up. The type of entity you are changing (variable, function, and so on) appears in the title bar of the window, and the current (about to be changed) name appears in the editable text box and the title bar.</p>
<span epub:type="pagebreak" id="page_122"/>
<div class="image"><img src="Images/fig7-3.jpg" alt="image" width="338" height="321"/></div>
<p class="figcap" id="fig7_3"><em>Figure 7-3: Renaming a stack variable</em> (<span class="codeitalic">local_14</span> to <span class="codeitalic">y</span>)</p>
<p class="indent">Once a new name is supplied, Ghidra changes every occurrence of the old name in the current function. The following listing shows the result of renaming <code>local_14</code> to <code>y</code> in <code>demo_stackframe</code>:</p>
<pre>     *******************************************************************<br/>
     *                         FUNCTION                                *<br/>
     *******************************************************************<br/>
     undefined demo_stackframe(undefined param_1, undefined4<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
        undefined     Stack[0x4]:1      param_1<br/>
        undefined4    Stack[0x8]:4      param_2      <br/>
        undefined4    Stack[0xc]:4      param_3      <br/>
        undefined4    Stack[-0x10]:4    local_10     <br/>
        undefined4    Stack[-0x14]:4    y<span class="ent">➊</span>           <br/>
        undefined4    Stack[-0x18]:4    local_18     <br/>
        undefined1    Stack[-0x58]:1    local_58     <br/>
     demo_stackframe    <br/>
08048473 55           PUSH   EBP<br/>
08048474 89 e5        MOV    EBP,ESP<br/>
08048476 83 ec 58     SUB    ESP,0x58<br/>
08048479 8b 45 10     MOV    EAX,dword ptr [EBP + param_3]<br/>
0804847c 89 45 f4     MOV    dword ptr [EBP + local_10],EAX<br/>
0804847f 8b 45 0c     MOV    EAX,dword ptr [EBP + param_2]<br/>
08048482 89 45 f0     MOV    dword ptr [EBP + y],EAX<span class="ent">➋</span><br/>
08048485 c7 45 ec     MOV    dword ptr [EBP + local_18],0xa<br/>
         0a 00 00 00<br/>
0804848c c6 45 ac 41  MOV    byte ptr [EBP + local_58],0x41<br/>
08048490 83 ec 08     SUB    ESP,0x8<br/>
08048493 ff 75 f0     PUSH   dword ptr [EBP + y]<span class="ent">➌</span><br/>
08048496 ff 75 ec     PUSH   dword ptr [EBP + local_18]<br/>
08048499 e8 88 ff     CALL   helper                        <br/>
         ff ff<br/>
0804849e 83 c4 10     ADD    ESP,0x10<br/>
080484a1 90           NOP<br/>
080484a2 c9           LEAVE<br/>
080484a3 c3           RET</pre>
<span epub:type="pagebreak" id="page_123"/>
<p class="indent">These changes <span class="ent">➊</span><span class="ent">➋</span><span class="ent">➌</span> are also reflected in the Symbol Tree, as shown in <a href="ch07.xhtml#fig7_4">Figure 7-4</a>.</p>
<div class="image"><img src="Images/fig7-4.jpg" alt="image" width="309" height="252"/></div>
<p class="figcap" id="fig7_4"><em>Figure 7-4: Symbol Tree view of renamed stack variable,</em> <span class="codeitalic">y</span></p>
<div class="box5">
<p class="boxtitle-c"><strong>THE FORBIDDEN NAMES</strong></p>
<p class="noindent">Some interesting rules restrict what you can name variables within a function. Here are some of the more relevant rules for parameters:</p>
<ul>
<li>You <em>can’t</em> use the prefix <code>param_</code> followed by an integer in a name, even if the resulting name does not conflict with an existing parameter name.</li>
<li>You <em>can</em> use the prefix <code>param_</code> followed by other characters.</li>
<li>You <em>can</em> use the prefix <code>Param_</code> followed by an integer, as names are case-sensitive (but it might not be advisable).</li>
<li>You <em>can</em> restore a parameter name to its original Ghidra-assigned name by entering <code>param_</code> followed by an integer value. If you use the original integer value, Ghidra will revert the name with no complaints. If you use any integer other than the original value, Ghidra will warn “Rename failed – default names may not be used<em>.</em>” At this point, clicking Cancel in the Rename Parameter dialog will restore the original name.</li>
<li>You <em>can</em> have two parameters with the names <code>param_1</code> (named by Ghidra) and <code>Param_1</code> (named by you). Names are case-sensitive, but it might not be advisable to reuse them.</li>
</ul>
<p class="indent">Local variables are also case-sensitive, and you can use the prefix <code>local_</code> with a non-numeric suffix.</p>
<p class="indent">For all types of variables, you <em>can’t</em> use a variable name that’s already used in that scope (for example, in the same function). Your attempt will be rejected with a reason in the dialog.</p>
<p class="indent">Finally, if you are thoroughly confused by your labels, you can see the label history for a variable by pressing the hotkey H, choosing Show All History, and entering the current name (or a past name) of the variable into the text box. (This option is also available through Search ▸ Label History in the main menu.)</p>
</div>
<span epub:type="pagebreak" id="page_124"/>
<div class="box5">
<p class="boxtitle-c"><strong>WHERE SHOULD YOU CHANGE YOUR NAME?</strong></p>
<p class="noindent">Variable names can be changed from the Listing, Symbol Tree, and Decompiler windows; the outcome is the same regardless, but the dialog accessed from the Listing window presents more information. All rules associated with naming variables are enforced when using any of these methods.</p>
<p class="indent">Many of the example parameter names in this book were changed in the Listing window using the dialog shown on the left in <a href="ch07.xhtml#fig7_5">Figure 7-5</a>. To change a name in the Symbol Tree, right-click the name and select <strong>Rename</strong> from the context menu. In the Decompiler window, use the hotkey L, or use the <strong>Rename Variable</strong> context menu option; the corresponding dialog is shown on the right in <a href="ch07.xhtml#fig7_5">Figure 7-5</a>. While the two dialogs provide the same functionality, the right dialog does not include information about the namespace or properties associated with the parameter.</p>
<div class="image"><img src="Images/fig7-5.jpg" alt="image" width="624" height="292"/></div>
<p class="figcap" id="fig7_5"><em>Figure 7-5: Renaming a variable from the Listing window or Symbol Tree (left) or the Decompiler window (right)</em></p>
<p class="indent">In Ghidra, a <em>namespace</em> is simply a named scope. Within a namespace, all symbols are unique. The global namespace contains all symbols within a binary. Function namespaces are nested within the global namespace. Within a function namespace, all variable names and labels are unique. Functions may themselves contain nested namespaces, such as a namespace associated with a switch statement (which allows case labels to be reused in separate namespaces; for example, when a function contains two switch statements that each have a case 10).</p>
</div>
<h4 class="h4" id="ch07lev120"><strong><em>Renaming Labels</em></strong></h4>
<p class="noindent">A label is a default or user-assigned name associated with a location. As with stack variables, the name-change dialog is opened with the hotkey L or context option Edit Label. When you change a location’s name, you can also change its namespace and properties, as shown in <a href="ch07.xhtml#fig7_6">Figure 7-6</a>.</p>
<span epub:type="pagebreak" id="page_125"/>
<div class="image"><img src="Images/fig7-6.jpg" alt="image" width="326" height="309"/></div>
<p class="figcap" id="fig7_6"><em>Figure 7-6: Renaming a function</em></p>
<p class="indent">This enhanced dialog shows the entity type and virtual address of the location in the title bar. Under Properties, you can identify the address as an entry point or pin the address (see “<a href="ch07.xhtml#ch07lev122">Editing Labels</a>” on <a href="ch07.xhtml#page_126">page 126</a>). As mentioned in <a href="ch06.xhtml#ch06">Chapter 6</a>, Ghidra limits names to a maximum of 2000 characters, so feel free to use meaningful names or even embed a narrative about the address (without any spaces). The Listing window will display only a portion of the name if the length is excessive, but the Decompiler window shows the entire thing.</p>
<h4 class="h4" id="ch07lev121"><strong><em>Adding a New Label</em></strong></h4>
<p class="noindent">While Ghidra generates many default labels, you can also add new labels and associate them with any address in the listing. These can be used to annotate your disassembly, although in many cases <em>comments</em> (discussed later in this chapter) are a more appropriate mechanism for this. To add a new label, open the Add Label dialog (hotkey L), shown in <a href="ch07.xhtml#fig7_7">Figure 7-7</a>, for the address associated with the cursor location. The drop-down list for the name includes a list of names you have used recently, and the Namespace drop-down list lets you choose an appropriate label scope.</p>
<div class="image"><img src="Images/fig7-7.jpg" alt="image" width="326" height="312"/></div>
<p class="figcap" id="fig7_7"><em>Figure 7-7: Add Label dialog</em></p>
<span epub:type="pagebreak" id="page_126"/>
<div class="box5">
<p class="boxtitle-c"><strong>FUN_ WITH PREFIXES</strong></p>
<p class="noindent">When Ghidra creates labels during auto analysis, it uses meaningful prefixes followed by an address to let you know what to expect at that location. These prefixes are listed next with very general descriptions. More information about the meaning of each prefix can be found in Ghidra Help.</p>
<p class="uln-indent"><span class="codestrong">LAB_</span><span class="EmpStrongItalic">address</span> Code—an auto-generated label (usually a jump target within a function)</p>
<p class="uln-indent"><span class="codestrong">DAT_</span><span class="EmpStrongItalic">address</span> Data—an auto-generated global variable name</p>
<p class="uln-indent"><span class="codestrong">FUN_</span><span class="EmpStrongItalic">address</span> Function—an auto-generated function name</p>
<p class="uln-indent"><span class="codestrong">SUB_</span><span class="EmpStrongItalic">address</span> Target of a call (or equivalent)—probably not a function</p>
<p class="uln-indent"><span class="codestrong">EXT_</span><span class="EmpStrongItalic">address</span> External entry point—probably someone else’s function</p>
<p class="uln-indent"><span class="codestrong">OFF_</span><span class="EmpStrongItalic">address</span> An offcut (inside existing data or code)—probably a disassembly error</p>
<p class="uln-indent"><span class="codestrong">UNK_</span><span class="EmpStrongItalic">address</span> Unknown—the purpose of the data here can’t be determined</p>
<p class="indent">Function labels have the following specific behaviors associated with them:</p>
<ul>
<li>If you delete a default function label (such as <code>FUN_08048473</code>) in the Listing window, the <code>FUN_</code> prefix will be replaced by the <code>SUB_</code> prefix (in this case, resulting in <code>SUB_08048473</code>).</li>
<li>Adding a new label to an address that has a default <code>FUN_</code> label changes the function name rather than creating a new label.</li>
<li>Labels are case-sensitive, so you can use <code>Fun_</code> or <code>fun_</code> as a valid prefix if your desire is to create a confusing disassembly.</li>
</ul>
</div>
<p class="indent">You can run into conflicts if you attempt to use one of Ghidra’s reserved prefixes when entering a name. If you insist on using a reserved prefix, Ghidra will reject your new label if it believes that a name conflict might arise. This occurs only when Ghidra determines that your suffix looks like an address (in our experience, this means four or more hex digits). For example, Ghidra will allow <code>FUN_zone</code> and <code>FUN_123</code>, but will reject <code>FUN_12345</code>. Also, if you attempt to add a label at the same address as a function that has a default label (for example, <code>FUN_08048473</code>), Ghidra renames the function rather than adding a second label at that location.</p>
<h4 class="h4" id="ch07lev122"><strong><em>Editing Labels</em></strong></h4>
<p class="noindent">To edit a label, use the hotkey L or context menu option Edit Label. Editing a label presents you with the same dialog as adding a label, except that the fields in the dialog will be initialized with the current values for the existing label. Note that editing labels can have an effect on other labels that share the same address, whether or not they share the same namespace. For example, if you identify a label as an entry point, Ghidra will identify all labels associated with that location as entry points.</p>
<span epub:type="pagebreak" id="page_127"/>
<div class="box5">
<p class="boxtitle-c"><strong>IS IT A BUG OR A FEATURE?</strong></p>
<p class="noindent">In the course of experimenting with function names, you may notice that Ghidra is perfectly content to allow you to give two functions the same name. This may elicit flashbacks to overloaded functions, which can be distinguished by the parameters they are passed. Ghidra’s capability extends beyond this: you can give two functions the exact same name even if this results in duplicate function prototypes within the same namespace. This is possible because a label is not a unique identifier (primary key in the database sense) and thus does not uniquely identify a function, even when considered with its associated parameters. Duplicate names can be used to tag functions; for example, to classify them for further analysis or eliminate them from consideration. Recall that all names are preserved in the function history (hotkey H) and can easily be reverted.</p>
</div>
<p class="indent">The Primary checkbox in <a href="ch07.xhtml#fig7_7">Figure 7-7</a> indicates that this is the label that will be displayed when the address is displayed. By default, this checkbox is disabled for the primary label, so you cannot deselect the primary name. This is necessary to ensure that there is always a name to display. If another label were chosen as the primary, its checkbox would be disabled, and checkboxes for other labels at the same address would be enabled.</p>
<p class="indent">Although we have, up to now, associated labels with addresses, in reality labels are most commonly associated with content that happens to have an address. For example, the label <code>main</code> typically denotes the beginning of the block of code that is the main function in a program. Ghidra assigns an address to this location based on file header information. If we were to relocate the entire content of the binary to a new address range, we would expect that the label <code>main</code> would continue to correctly associate with the new address of <code>main</code> and its corresponding, unchanged byte content. When a label is <em>pinned</em>, the label’s association with the content at its address is severed. If you were to then relocate the binary’s content to a new address range, any pinned labels would not move accordingly, but remain fixed to the address that you pinned them to. The most common use of pinned labels is to name reset vectors and memory mapped I/O locations that exist at specific addresses designated by the processor/system designers.</p>
<h4 class="h4" id="ch07lev123"><strong><em>Removing a Label</em></strong></h4>
<p class="noindent">To remove a label at the cursor, you can use the right-click context option (or hotkey <span class="smallcaps">DELETE</span>). Be warned that not all labels are removable. First, it is impossible to delete a default, Ghidra-generated label. Second, if you have renamed a default label and later decide to delete the new label, Ghidra will replace the name you are deleting with the originally assigned, default label (this is a direct result of the previous statement). The finer details associated with removing labels are discussed in Ghidra Help.</p>
<span epub:type="pagebreak" id="page_128"/>
<h4 class="h4" id="ch07lev124"><strong><em>Navigating Labels</em></strong></h4>
<p class="noindent">Labels are associated with navigable locations, so double-clicking a reference to a label will navigate you to that label. While this is discussed more thoroughly in <a href="ch09.xhtml#ch09">Chapter 9</a>, remember that you can add labels to any location you wish to navigate to in the disassembly. While the same functionality is described in “<a href="ch07.xhtml#ch07lev131">Annotations</a>” on <a href="ch07.xhtml#page_132">page 132</a>, sometimes a label (particularly with its 2000-character allowance) is the quickest way to accomplish the same goal.</p>
<h3 class="h3" id="ch07lev125"><strong>Comments</strong></h3>
<p class="noindent">Embedding comments into your disassembly and decompiler listings is a particularly useful way to leave notes for yourself regarding your progress and discoveries as you analyze a program. Ghidra offers five categories of comments, each suited for a different purpose. We begin by looking at comments that we can add directly to the disassembly in the Listing window.</p>
<p class="indent">While you can navigate to the Set Comment dialog (shown in <a href="ch07.xhtml#fig7_8">Figure 7-8</a>) through the right-click context menu, the quickest way is to use the hotkey for comments, which is the semicolon (;) key. (This is a logical choice, as the semicolon is the comment indicator in many flavors of assembly.)</p>
<div class="image"><img src="Images/fig7-8.jpg" alt="image" width="694" height="279"/></div>
<p class="figcap" id="fig7_8"><em>Figure 7-8: Set Comment dialog</em></p>
<p class="indent">The Set Comment dialog opens in association with a particular address: <code>08048479</code> in <a href="ch07.xhtml#fig7_8">Figure 7-8</a>, as displayed in the title bar. Any content entered into any one of the five comment category tabs (EOL, Pre, Post, Plate, and Repeatable Comments) is associated with that address.</p>
<p class="indent">By default, you enter content in the text box, including carriage returns, create a comment that is one or more lines long, and then click <strong>Apply</strong> or <strong>OK</strong>. (Apply allows you to see the comment in context and keeps the Set Comment dialog open for continued editing.) To save time when entering short comments, select the <strong>Enter accepts comment</strong> checkbox in the lower left of the dialog. (You can always deselect the box temporarily if you are writing a particularly informative plate comment.)</p>
<span epub:type="pagebreak" id="page_129"/>
<div class="box5">
<p class="boxtitle-c"><strong>THOSE THREE BUTTONS</strong></p>
<p class="noindent">Of the three buttons at the bottom of the Set Comment dialog (<a href="ch07.xhtml#fig7_8">Figure 7-8</a>), the OK and Apply buttons behave as you might expect. Clicking OK closes the dialog and commits your changes. When you click Apply, the listing is updated so that you can examine your changes and approve them or continue editing your comment.</p>
<p class="indent">Dismiss, however, is not the same as Cancel, which would exit the dialog with no effect on your listing! The unique term is consistent with the unique behavior. Clicking the Dismiss button exits the window immediately if you have not modified any comments, but lets you decide whether you want to save changes if you did modify comments. Closing the window using the X in the top right exhibits the same behavior. This Dismiss functionality will be encountered in other places within Ghidra.</p>
</div>
<p class="indent">To delete a comment, clear a comment’s text in the Set Comment dialog, or use the hotkey <span class="smallcaps">DELETE</span> when the cursor is on a comment in the Listing window. Right-clicking Comments ▸ Show History for Comment can be used to recall the comments associated with a particular address and reinstate them as needed.</p>
<h4 class="h4" id="ch07lev126"><strong><em>End-of-Line Comments</em></strong></h4>
<p class="noindent">Perhaps the most commonly used type of comment is the <em>end-of-line (EOL) comment</em>, placed at the end of existing lines in the Listing window. To add one, open the Set Comment dialog with the semicolon hotkey and select the EOL Comment tab. By default, EOL comments are displayed as blue text and will span multiple lines if you enter multiple lines in the comment text box. Each line will be indented to align at the right side of the disassembly, and existing content will be moved down to make space for the new comments. You can edit your comments at any time by reopening the Set Comment dialog. The quickest method to delete a comment is to click the comment in the Listing window and press <span class="smallcaps">DELETE</span>.</p>
<p class="indent">Ghidra itself adds many EOL comments during auto analysis. For example, when you load a PE file, Ghidra inserts descriptive EOL comments to describe the fields in the <code>IMAGE_DOS_HEADER</code> section, including the comment <code>Magic number</code>. Ghidra is able to do this only when it has this information associated with a particular data type. This information is typically contained within type libraries, which are displayed in the Data Type Manager window and discussed in depth in <a href="ch08.xhtml#ch08">Chapter 8</a> and <a href="ch13.xhtml#ch13">Chapter 13</a>. Among all the comment types, EOL comments are the most configurable through the Edit ▸ Tool Options ▸ Listing Fields options for each comment type.</p>
<span epub:type="pagebreak" id="page_130"/>
<h4 class="h4" id="ch07lev127"><strong><em>Pre and Post Comments</em></strong></h4>
<p class="noindent"><em>Pre</em> and <em>post comments</em> are full-line comments that appear either immediately before or after a given disassembly line. The following listing shows a multi­line pre comment and a truncated single-line post comment, associated with address <code>08048476</code>. Hovering over a truncated comment will display the complete comment. By default, pre comments are displayed in purple, and post comments are displayed in blue, so that you can easily associate them with the correct address in the listing.</p>
<pre>08048473  PUSH   EBP<br/>
08048474  MOV    EBP,ESP<br/>
        ******** Pre Comment - This is a multi-line comment.<br/>
        ******** The following statement allocates 88 bytes of local<br/>
        ******** variable space in the stack frame.<br/>
08048476  SUB    ESP,0x58<br/>
        ******** Post Comment - Now that we have allocated the space...<br/>
08048479  MOV    EAX,dword ptr [EBP + param_3]</pre>
<h4 class="h4" id="ch07lev128"><strong><em>Plate Comments</em></strong></h4>
<p class="noindent"><em>Plate comments</em> allow you to group comments for display anywhere in the Listing window. A plate comment is centered and placed within an asterisk-bounded rectangle. Many of the listings we have examined include a simple plate comment with the word <code>FUNCTION</code> inside the bounding box, as shown in <a href="ch07.xhtml#fig7_9">Figure 7-9</a>. This example includes the associated Decompiler window on the right side so you can see that, in this default presentation, a plate comment has been inserted in the Listing window, but no corresponding comment exists in the Decompiler window.</p>
<div class="image"><img src="Images/fig7-9.jpg" alt="image" width="844" height="318"/></div>
<p class="figcap" id="fig7_9"><em>Figure 7-9: Plate comment example</em></p>
<p class="indent">When you open the comment dialog with the first address in the function selected, you have the option to replace this general plate comment <span epub:type="pagebreak" id="page_131"/>with your own, more informative one, as shown in <a href="ch07.xhtml#fig7_10">Figure 7-10</a>. In addition to replacing the default plate comment, Ghidra adds your comment as a C-style comment at the top of the Decompiler window. If the cursor were at the top of the Decompiler window when the plate comment was created, the result would have been the same.</p>
<div class="image"><img src="Images/fig7-10.jpg" alt="image" width="844" height="310"/></div>
<p class="figcap" id="fig7_10"><em>Figure 7-10: Custom plate comment example</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Only plate and pre comments are displayed in the Decompiler window by default, although you can change this using options in Edit ▸ Tool Options ▸ Decompiler ▸ Display.</em></p>
</div>
<h4 class="h4" id="ch07lev129"><strong><em>Repeatable Comments</em></strong></h4>
<p class="noindent">A <em>repeatable comment</em> is entered once but may appear automatically in many locations throughout the disassembly. The behavior of repeatable comments is tied to the concept of cross-references, which are discussed in depth in <a href="ch09.xhtml#ch09">Chapter 9</a>. Basically, a repeatable comment entered at the target of a cross-reference is echoed at the source of a cross-reference. As a result, a single repeatable comment may be echoed at many locations in the disassembly (because cross-references can be many-to-one). In a disassembly listing, the default color is orange for repeatable comments and gray for echoed comments, making them easily distinguishable from other types of comments. The following listing demonstates the use of a repeatable comment.</p>
<pre>08048432  JGE    LAB_08048446                  Repeatable comment at 08048446<span class="ent">➊</span><br/>
08048434  SUB    ESP,0xc<br/>
08048437  PUSH   s_The_second_parameter_is_larger<br/>
0804843c  CALL   puts                          <br/>
08048441  ADD    ESP,0x10<br/>
08048444  JMP    LAB_08048470<br/>
        LAB_08048446                                              <br/>
08048446  MOV    EAX,dword ptr [EBP + param_2] Repeatable comment at 08048446<span class="ent">➋</span></pre>
<span epub:type="pagebreak" id="page_132"/>
<p class="indent">In the listing, a repeatable comment is set at <code>08048446</code> <span class="ent">➋</span> and repeated at <code>08048432</code> <span class="ent">➊</span> because the instruction at <code>08048432</code> refers to address <code>08048446</code> as a jump target (thus a cross-reference exists from <code>08048432</code> to <code>08048446</code>).</p>
<p class="indent">When an EOL comment and a repeatable comment share the same address, only the EOL comment is visible in the listing. Both comments can be viewed and edited in the Set Comment dialog. If you delete the EOL comment, the repeatable comment will become visible in the listing.</p>
<h4 class="h4" id="ch07lev130"><strong><em>Parameter and Local Variable Comments</em></strong></h4>
<p class="noindent">To associate a comment with a stack variable, select the stack variable and use the semicolon hotkey. <a href="ch07.xhtml#fig7_11">Figure 7-11</a> shows the resulting minimal comment window. The comment will be displayed next to the stack variable in a truncated format similar to an EOL comment. Hovering over the comment will display it in its entirety. The color of the comment matches the default color of the variable type, rather than the blue default for EOL comments.</p>
<div class="image"><img src="Images/fig7-11.jpg" alt="image" width="836" height="272"/></div>
<p class="figcap" id="fig7_11"><em>Figure 7-11: Stack variable comment</em></p>
<h4 class="h4" id="ch07lev131"><strong><em>Annotations</em></strong></h4>
<p class="noindent">Ghidra provides a powerful capability to annotate comments with links to programs, URLs, addresses, and symbols in its Set Comment dialog. Symbol information in comments will automatically update when symbol names are changed. When you use an annotation to launch a specified executable, you can provide optional parameters to gain even more control (yes, that sounds dangerous to us, too).</p>
<p class="indent">For example, the annotation on a plate comment in <a href="ch07.xhtml#fig7_12">Figure 7-12</a> provides a hyperlink to an address in the listing. Additional information about the power of annotations is provided in Ghidra Help.</p>
<span epub:type="pagebreak" id="page_133"/>
<div class="image"><img src="Images/fig7-12.jpg" alt="image" width="844" height="263"/></div>
<p class="figcap" id="fig7_12"><em>Figure 7-12: Address annotation example</em></p>
<h3 class="h3" id="ch07lev132"><strong>Basic Code Transformations</strong></h3>
<p class="noindent">In many cases, you will be perfectly content with the disassembly listings that Ghidra generates. In some cases, however, you won’t. As the types of files that you analyze diverge further and further from ordinary executables generated with common compilers, you may need to take more control of the disassembly analysis and display processes. This will be especially true if you analyze obfuscated code or files that utilize a custom (unknown to Ghidra) file format.</p>
<p class="indent">Ghidra facilitates the following code transformations (among others):</p>
<ul>
<li class="noindent">Changing code display options</li>
<li class="noindent">Formatting instruction operands</li>
<li class="noindent">Manipulating functions</li>
<li class="noindent">Converting data into code</li>
<li class="noindent">Converting code into data</li>
</ul>
<p class="indent">In general, if a binary is very complex, or if Ghidra is not familiar with the code sequences generated by the compiler used to build the binary, then Ghidra will encounter more problems during the analysis phase, and you will need to make manual adjustments to the disassembled code.</p>
<h4 class="h4" id="ch07lev133"><strong><em>Changing Code Display Options</em></strong></h4>
<p class="noindent">Ghidra allows very fine-grained control over the formatting of lines within the Listing window. Layout is controlled with the Browser Field Formatter (introduced in <a href="ch05.xhtml#ch05">Chapter 5</a>). Selecting the Browser Field Formatter icon opens a tabbed display of all the fields associated with your listing, as displayed in <a href="ch05.xhtml#fig5_8">Figure 5-8</a>. You can add, delete, and rearrange fields by using a simple drag-and-drop interface that allows you to immediately observe the changes in your listing. The tight association between an item in the listing field and in the associated Browser Field Formatter is very useful. Anytime <span epub:type="pagebreak" id="page_134"/>you move the cursor to a new location in the Listing window, the Browser Field Formatter moves the appropriate tab and associated field so that you can immediately identify options associated with a particular item. See “<a href="ch12.xhtml#ch12lev212">Special Tool Editing Features</a>” on <a href="ch12.xhtml#page_247">page 247</a> for additional discussion of the Browser Field Formatter.</p>
<p class="indent">To control the appearance of individual elements within the Listing window, you can select Edit ▸ Tool Options, as described in <a href="ch04.xhtml#ch04">Chapter 4</a>. The unique submenus for each field in the Listing window allow you to fine-tune each field to your liking. While the capabilities associated with each field vary, in general you can control display colors, associated default values, configurations, and formats. For example, users who love assembly code and read it in their spare time may choose to adjust the default parameters in the EOL Comments Field area, shown in <a href="ch07.xhtml#fig7_13">Figure 7-13</a>, to activate the Show Semicolon at Start of Each Line option in order to view the assembly comments in a familiar format.</p>
<div class="image"><img src="Images/fig7-13.jpg" alt="image" width="844" height="534"/></div>
<p class="figcap" id="fig7_13"><em>Figure 7-13: Tool Options menu for EOL Comments Field</em></p>
<p class="indent">To color the background for individual lines or larger selections in the Listing window, select the Colors option through the right-click context menu and choose a color. The range of available colors is extensive, and a quick pick option is provided for recently used colors. Through the same menu, you can also clear the background color for a line, a selection, or an entire file.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Clearing options do not appear if no colors are currently set for the listing.</em></p>
</div>
<span epub:type="pagebreak" id="page_135"/>
<h4 class="h4" id="ch07lev134"><strong><em>Formatting Instruction Operands</em></strong></h4>
<p class="noindent">During the auto analysis process, Ghidra makes many decisions regarding how to format operands associated with each instruction, especially various integer constants used by a wide variety of instruction types. Among other things, these constants can represent relative offsets in jump or call instructions, absolute addresses of global variables, values to be used in arithmetic operations, or programmer-defined constants. To make a disassembly more readable, Ghidra attempts to use symbolic names rather than numbers whenever possible.</p>
<p class="indent">In some cases, formatting decisions are made based on the context of the instruction being disassembled (such as a call instruction); in other cases, the decision is based on the data being used (such as access to a global variable or an offset into a stack frame or structure). Often, the exact context in which a constant is used may not be discernable to Ghidra. When this happens, the constant is typically formatted as a hexadecimal value.</p>
<p class="indent">If you are not one of the few people in the world who eat, sleep, and breathe hex, then you will welcome Ghidra’s operand-formatting features. Assume that you have the following in your disassembly listing:</p>
<pre>08048485  MOV    dword ptr [EBP + local_18],0xa<br/>
0804848c  MOV    byte ptr [EBP + local_58],0x41</pre>
<p class="indent">Right-clicking the hex constant <code>0x41</code> opens the context-sensitive menu shown in <a href="ch07.xhtml#fig7_14">Figure 7-14</a>. (See <a href="ch06.xhtml#fig6_7">Figure 6-7</a> for this example in context.) The constant can be reformatted in the various numeric representations displayed on the right side of the figure, or as a character constant (since this value also falls within the ASCII printable range). This can be a very helpful feature as you may not realize the many representations that can be associated with a given constant. In all cases, the menu displays the exact text that will replace the operand text should a particular option be selected.</p>
<div class="image"><img src="Images/fig7-14.jpg" alt="image" width="694" height="197"/></div>
<p class="figcap" id="fig7_14"><em>Figure 7-14: Formatting options for constants</em></p>
<p class="indent">In many cases, programmers use named constants in their source code. Such constants may be the result of <code>#define</code> statements (or their equivalent), or they may belong to a set of enumerated constants. Unfortunately, by the time a compiler is finished with the source code, it is no longer possible to determine whether the source used a symbolic constant or a literal, numeric constant. Fortunately, Ghidra maintains a large catalog of named <span epub:type="pagebreak" id="page_136"/>constants associated with many common libraries, such as the C standard library or the Windows API. This catalog is accessible via the Set Equate option (hotkey E) on the context-sensitive menu associated with any constant value. Selecting this option for the constant <code>0xa</code> opens the Set Equate dialog (<a href="ch07.xhtml#fig7_15">Figure 7-15</a>).</p>
<div class="image"><img src="Images/fig7-15.jpg" alt="image" width="844" height="520"/></div>
<p class="figcap" id="fig7_15"><em>Figure 7-15: Set Equate dialog</em></p>
<p class="indent">The dialog is populated from Ghidra’s internal list of constants after filtering according to the value of the constant we are attempting to format. In this case, we can scroll to see all of the constants that Ghidra knows to be equated with the value <code>0xA</code>. If we determined that the value was being used in conjunction with the creation of an X.25-style network connection, we might select <code>AF_CCITT</code> and end up with the following disassembly line:</p>
<pre>08048485  MOV    dword ptr [EBP + local_18],AF_CCITT</pre>
<p class="indent">The list of standard constants is useful to determine whether a particular constant may be associated with a known name and can save a lot of time reading through API documentation in search of potential matches.</p>
<span epub:type="pagebreak" id="page_137"/>
<h4 class="h4" id="ch07lev135"><strong><em>Manipulating Functions</em></strong></h4>
<p class="noindent">Ghidra provides the capability to manipulate functions in the disassembly (for example, correcting which code Ghidra identifies as belonging to functions, or changing function attributes), which is especially helpful when you disagree with the results of the auto analysis. In some cases, such as when Ghidra fails to locate a call to a function, functions may not be recognized, as there may be no obvious way to reach them. In other cases, Ghidra may fail to properly locate the end of a function, requiring you to correct the disassembly. Ghidra may have trouble locating the end of a function if a compiler has split the function across several address ranges or when, in the process of optimizing code, a compiler merges common end sequences of two or more functions in order to save space.</p>
<h5 class="h5" id="ch07lev136"><strong>Creating New Functions</strong></h5>
<p class="noindent">New functions can be created from existing instructions that do not already belong to a function. You create functions by right-clicking the first instruction to be included in the new function and selecting Create Function (or hotkey F). If you selected a range, that will become the function body. If you did not, Ghidra will follow the control flow to try to determine the bounds of the function body.</p>
<h5 class="h5" id="ch07lev137"><strong>Deleting Functions</strong></h5>
<p class="noindent">You can delete existing functions by placing the cursor within the function signature and using the hotkey <span class="smallcaps">DELETE</span>. You may wish to delete a function if you believe that Ghidra has erred in its auto analysis or you have erred in creating a function. Note that while the function and its associated attributes will no longer exist, no change occurs to the underlying byte content, so the function can be re-created if desired.</p>
<h5 class="h5" id="ch07lev138"><strong>Editing Function Attributes</strong></h5>
<p class="noindent">Ghidra associates several attributes with each function that it recognizes, which can be viewed by selecting the Window ▸ Functions option from the CodeBrowser menu. (While only five attributes are displayed by default, you can add any of 16 additional attributes by right-clicking in a column heading.) To edit the attributes, open the Edit Function dialog from the right-click context menu when the cursor is positioned in the region between a function’s plate comment and the last local variable listed before the beginning of the function’s disassembled code. An example of the Edit Function dialog is shown in <a href="ch07.xhtml#fig7_16">Figure 7-16</a>.</p>
<span epub:type="pagebreak" id="page_138"/>
<div class="image"><img src="Images/fig7-16.jpg" alt="image" width="694" height="598"/></div>
<p class="figcap" id="fig7_16"><em>Figure 7-16: Edit Function dialog</em></p>
<p class="indent">Each attribute that can be modified through this dialog is explained here:</p>
<p class="listhead"><strong>Function Name</strong></p>
<p class="listbody">You can modify the name within the text box at the top of the dialog or within the Function Name field.</p>
<p class="listhead"><strong>Function Attributes</strong></p>
<p class="listbody">Five optional function attributes can be enabled in this area. The first four attributes, Varargs, In Line, No Return, and Use Custom Storage, are checkboxes that are unchecked by default. The fifth optional attribute, Call Fixup, appears in the bottom left of the dialog, defaults to <code>none</code>, and provides a drop-down menu from which you can choose a value. If you modify any of the function’s attributes, Ghidra automatically propagates the function’s updated prototype to all locations at which it may be displayed throughout the disassembly.</p>
<p class="listbody">The Varargs option indicates that a function takes a variable number of arguments (for example, <code>printf</code>). Varargs is also enabled if you edit (in the text field at the top of <a href="ch07.xhtml#fig7_16">Figure 7-16</a>) the function’s parameter list such that the last argument has an ellipsis (. . .). The In Line option has no effect on disassembly analysis other than to include the <code>inline</code> keyword in the function’s prototype. (Keep in mind that if a function were actually inlined by a compiler, you would not see that function <span epub:type="pagebreak" id="page_139"/>as a distinct entity in a disassembly because its body would have been embedded within the body of the functions that call it.) The No Return option is used when it is known that a function will never return (for example, if it uses <code>exit</code> or an opaque predicate to jump to another function). When a function is tagged as No Return, Ghidra will not assume that the bytes following a call to that function are reachable unless it has other evidence to support their reachability, such as a jump instruction targeting those bytes. The Use Custom Storage option allows you to override Ghidra’s analysis of parameter and return value storage locations and sizes.</p>
<p class="listhead"><strong>Calling Convention</strong></p>
<p class="listbody">The Calling Convention drop-down allows you to modify the calling convention used by the function. Modifying the calling convention may change Ghidra’s stack pointer analysis, so it is important to get this correct.</p>
<p class="listhead"><strong>Function Variables</strong></p>
<p class="listbody">The Function Variables area allows you to edit function variables with guidance. As you modify the data in the four columns associated with the variables, Ghidra will provide information to help you change things appropriately. For example, attempts to change the Storage for <code>param_1</code> will result in a message saying <code>Enable 'Use Custom Storage' to allow editing of Parameter and Return Storage</code>. The four icons on the right allow you to add, delete, and navigate through the variables.</p>
<h4 class="h4" id="ch07lev139"><strong><em>Converting Data to Code (and Vice Versa)</em></strong></h4>
<p class="noindent">During the automatic analysis phase, data bytes may be incorrectly classified as code bytes and disassembled into instructions, or code bytes may be incorrectly classified as data bytes and formatted as data values. This happens for many reasons, including because some compilers embed data into the code section of programs and because some code bytes are never directly referenced as code and thus Ghidra opts not to disassemble them. Obfuscated programs in particular tend to deliberately blur the distinction between code and data. (See <a href="ch21.xhtml#ch21">Chapter 21</a>.)</p>
<p class="indent">The first option for reformatting anything is to remove its current formatting (code or data). It is possible to undefine functions, code, or data by right-clicking the item you wish to undefine and selecting Clear Code Bytes (hotkey C). Undefining an item causes the underlying bytes to be reformatted as a list of raw byte values. Large regions can be undefined by using a click-and-drag operation to select a range of addresses prior to performing the undefine operation. As an example, consider this simple function listing:</p>
<pre>004013e0  PUSH   EBP<br/>
004013e1  MOV    EBP,ESP<br/>
004013e3  POP    EBP<br/>
004013e4  RET</pre>
<span epub:type="pagebreak" id="page_140"/>
<p class="indent">Undefining this function would yield the series of uncategorized bytes shown here, which we could reformat in virtually any manner:</p>
<pre>004013e0      ??       55h    U<br/>
004013e1      ??       89h<br/>
004013e2      ??       E5h<br/>
004013e3      ??       5Dh    ]<br/>
004013e4      ??       C3h</pre>
<p class="indent">To disassemble a sequence of undefined bytes, right-click the first byte to be disassembled and select <strong>Disassemble</strong>. This causes Ghidra to start the recursive descent algorithm at that point. Large regions can be converted to code by using click-and-drag to select a range of addresses prior to performing the code-conversion operation.</p>
<p class="indent">Converting code to data is a little more complex. First, you cannot directly convert code to data by using the context menu, unless you first undefine the instructions that you wish to convert to data and then format the bytes appropriately. Basic data formatting is discussed in the following section.</p>
<h3 class="h3" id="ch07lev140"><strong>Basic Data Transformations</strong></h3>
<p class="noindent">To understand a program’s behavior, properly formatted data can be as important as properly formatted code. Ghidra takes information from a variety of sources and uses an algorithmic approach to determine the most appropriate way to format data within a disassembly. For example:</p>
<ul>
<li class="noindent">Data types and/or sizes can be inferred from the manner in which registers are used. An instruction that loads a 32-bit register from memory implies that the associated memory location holds a 4-byte data type (though we may not be able to distinguish between a 4-byte integer and a 4-byte pointer).</li>
<li class="noindent">Function prototypes can be used to assign data types to function parameters. Ghidra maintains a large library of function prototypes for exactly this purpose. Analysis is performed on the parameters passed to functions in an attempt to tie a parameter to a memory location. If such a relationship can be uncovered, a data type can be applied to the associated memory location. Consider a function whose single parameter is a pointer to a <code>CRITICAL_SECTION</code> (a Windows API data type). If Ghidra can determine the address passed in a call to this function, that address can be flagged as a <code>CRITICAL_SECTION</code> object.</li>
<li class="noindent">Analysis of a sequence of bytes can reveal likely data types. This is precisely what happens when a binary is scanned for string content. When long sequences of ASCII characters are encountered, it is not unreasonable to assume that they represent character arrays.</li>
</ul>
<p class="indent">In the next few sections, we discuss some basic transformations that you can perform on data within your disassemblies.</p>
<span epub:type="pagebreak" id="page_141"/>
<h4 class="h4" id="ch07lev141"><strong><em>Specifying Data Types</em></strong></h4>
<p class="noindent">Ghidra offers data size and type specifiers. The most commonly encountered specifiers are <code>byte</code>, <code>word</code>, <code>dword</code>, and <code>qword</code>, representing 1-, 2-, 4-, and 8-byte data, respectively. Data types can be set or changed by right-clicking any disassembly line that contains data (that is not an instruction) and selecting the Set Data Type submenu shown in <a href="ch07.xhtml#fig7_17">Figure 7-17</a>.</p>
<div class="image"><img src="Images/fig7-17.jpg" alt="image" width="333" height="658"/></div>
<p class="figcap" id="fig7_17"><em>Figure 7-17: The Data submenu</em></p>
<p class="indent">This list allows you to immediately change the formatting and data size of the currently selected item by choosing a data type. The Cycle option lets you quickly cycle through a group of associated data types, such as numeric, character, and floating point types, as shown (with associated hotkeys) in <a href="ch07.xhtml#fig7_18">Figure 7-18</a>. For example, repeatedly pressing F would cycle you between float and double, as they are the only items in that cycle group.</p>
<div class="image"><img src="Images/fig7-18.jpg" alt="image" width="285" height="87"/></div>
<p class="figcap" id="fig7_18"><em>Figure 7-18: Cycle groups</em></p>
<span epub:type="pagebreak" id="page_142"/>
<p class="indent">Toggling through data types causes data items to grow, shrink, or remain the same size. If an item’s size remains the same, the only observable change is in the way the data is formatted. If you reduce an item’s size, from <code>ddw</code> (4 bytes) to <code>db</code> (1 byte), for example, any extra bytes (3 in this case) become undefined. If you increase the size of an item, Ghidra will warn you of any conflict and guide you through resolving it. An example involving array dimensioning is shown in <a href="ch07.xhtml#fig7_19">Figure 7-19</a>.</p>
<div class="image"><img src="Images/fig7-19.jpg" alt="image" width="543" height="199"/></div>
<p class="figcap" id="fig7_19"><em>Figure 7-19: Example of an array declaration and warning</em></p>
<h4 class="h4" id="ch07lev142"><strong><em>Working with Strings</em></strong></h4>
<p class="noindent">Choosing Search ▸ For Strings brings up the dialog shown in <a href="ch07.xhtml#fig7_20">Figure 7-20</a>, where you can set and control the search criteria for a specific string search. While most of the fields in this window are self-explanatory, a unique feature of Ghidra is the ability to associate a <em>word model</em> with a search. A word model can be used to determine whether a particular string is considered a word in a given context. Word models are discussed in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>
<div class="image"><img src="Images/fig7-20.jpg" alt="image" width="660" height="475"/></div>
<p class="figcap" id="fig7_20"><em>Figure 7-20: Search For Strings dialog</em></p>
<span epub:type="pagebreak" id="page_143"/>
<p class="indent">Once a search has been conducted, the results are presented in a String Search window (<a href="ch07.xhtml#fig7_21">Figure 7-21</a>). Subsequent searches will be tabbed within the same window, and the window title bar will include timestamps for each search so you can easily order them.</p>
<div class="image"><img src="Images/fig7-21.jpg" alt="image" width="694" height="521"/></div>
<p class="figcap" id="fig7_21"><em>Figure 7-21: String Search window showing search results</em></p>
<p class="indent">The leftmost column of the String Search window contains icons that indicate the string definition status (from undefined to conflicting). The meanings of the icons are shown in <a href="ch07.xhtml#fig7_22">Figure 7-22</a>. To show or hide strings in any of the categories, toggle the corresponding icons in the title bar.</p>
<div class="image"><img src="Images/fig7-22.jpg" alt="image" width="538" height="235"/></div>
<p class="figcap" id="fig7_22"><em>Figure 7-22: String toggle icon definitions</em></p>
<span epub:type="pagebreak" id="page_144"/>
<p class="indent">Using the icons allows you to easily identify the items in the listing that are not already defined as strings and make a string or character array from these entries by selecting them and clicking the Make String or Make Char Array button, as appropriate. These newly defined entities will be displayed in the Defined Strings window, which is discussed in “<a href="ch05.xhtml#ch05lev84">The Defined Strings Window</a>” on <a href="ch05.xhtml#page_81">page 81</a>.</p>
<h4 class="h4" id="ch07lev143"><strong><em>Defining Arrays</em></strong></h4>
<p class="noindent">One of the drawbacks to disassembly listings derived from higher-level languages is that they provide very few clues regarding the size of arrays. In a disassembly listing, an array can require a tremendous amount of space if each item in the array is specified on its own line. The following listing shows a sequence of items in a data section. The fact that only the first item in the listing is referenced by any instructions suggests that it may be the first element in an array. Rather than being referenced directly, additional elements within arrays are often referenced using index computations relative to the beginning of the array.</p>
<pre>        DAT_004195a4                          XREF[1]:  main:00411727(W)<br/>
004195a4    undefined4    ??<br/>
004195a8      ??          ??<br/>
004195a9      ??          ??<br/>
004195aa      ??          ??<br/>
004195ab      ??          ??<br/>
004195ac      ??          ??<br/>
004195ad      ??          ??<br/>
004195ae      ??          ??<br/>
004195af      ??          ??<br/>
004195b0      ??          ??<br/>
004195b1      ??          ??<br/>
004195b2      ??          ??<br/>
004195b3      ??          ??<br/>
004195b4      ??          ??<br/>
004195b5      ??          ??<br/>
004195b6      ??          ??</pre>
<p class="indent">Ghidra can group consecutive data definitions into a single array definition. To create an array, select the first element of the array and use the Data ▸ Create Array option in the context menu (hotkey [). You will be prompted for the number of elements in the array, or you can accept the default that Ghidra suggests. (If you have selected a range of data, rather than a single value, Ghidra will use your selection as the array bounds.) By default, the data type and size associated with the array elements are based on the data type of the first element in the selection. The array is presented in a collapsed format, but can be expanded to view the individual elements. The number of elements displayed per line is controlled in the Edit ▸ Tool Options of the CodeBrowser window. Arrays are discussed more thoroughly in <a href="ch08.xhtml#ch08">Chapter 8</a>.</p>
<span epub:type="pagebreak" id="page_145"/>
<h3 class="h3" id="ch07lev144"><strong>Summary</strong></h3>
<p class="noindent">Together with the previous chapter, this chapter encompasses the most common operations that Ghidra users will ever need to perform. Disassembly manipulation lets you combine your knowledge with the knowledge imparted by Ghidra during its analysis phase to produce valuable information. As in source code, the effective use of names, assignment of data types, and detailed comments will not only assist you in remembering what you have analyzed but also greatly assist others who make use of your work. In the next chapter, we take a look at how to deal with more complex data structures, such as the C <code>struct</code>, and examine some of the low-level details of compiled C++.</p>
</div>



  </body></html>