["```\nstatic int glob = 0;\n\nstatic void\nincr(int loops)\n{\n    int loc, j;\n    for (j = 0; j < loops; j++) {\n     loc = glob;\n     loc++;\n     glob = loc;\n   }\n}\n```", "```\n#include <pthread.h>\n\nint `pthread_once`(pthread_once_t **once_control*, void (**init*)(void));\n```", "```\nvoid\ninit(void)\n{\n    /* Function body */\n}\n```", "```\npthread_once_t once_var = PTHREAD_ONCE_INIT;\n```", "```\n#include <pthread.h>\n\nint `pthread_key_create`(pthread_key_t **key*, void (**destructor*)(void *));\n```", "```\nvoid\ndest(void *value)\n{\n    /* Release storage pointed to by 'value' */\n}\n```", "```\n#include <pthread.h>\n\nint `pthread_setspecific`(pthread_key_t *key*, const void **value*);\n```", "```\nvoid `*pthread_getspecific`(pthread_key_t *key*);\n```", "```\n`threads/strerror.c`\n\n#define _GNU_SOURCE                 /* Get '_sys_nerr' and '_sys_errlist'\n                                       declarations from <stdio.h> */\n\n#include <stdio.h>\n#include <string.h>           /* Get declaration of strerror() */\n\n#define MAX_ERROR_LEN 256            /* Maximum length of string\n                                        returned by strerror() */\n\nstatic char buf[MAX_ERROR_LEN];     /* Statically allocated return buffer */\n\nchar *\nstrerror(int err)\n{\n    if (err < 0 || err >= _sys_nerr || _sys_errlist[err] == NULL) {\n        snprintf(buf, MAX_ERROR_LEN, \"Unknown error %d\", err);\n    } else {\n        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);\n        buf[MAX_ERROR_LEN - 1] = '\\0';          /* Ensure null termination */\n    }\n\n    return buf;\n\n}\n\n      `threads/strerror.c`\n```", "```\n$ `./strerror_test`\nMain thread has called strerror()\nOther thread about to call strerror()\nOther thread: str (0x804a7c0) = Operation not permitted\nMain thread:  str (0x804a7c0) = Operation not permitted\n```", "```\n`threads/strerror_test.c`\n#include <stdio.h>\n#include <string.h>                 /* Get declaration of strerror() */\n#include <pthread.h>\n#include \"tlpi_hdr.h\"\n\nstatic void *\nthreadFunc(void *arg)\n{\n    char *str;\n\n    printf(\"Other thread about to call strerror()\\n\");\n    str = strerror(EPERM);\n    printf(\"Other thread: str (%p) = %s\\n\", str, str);\n\n    return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    pthread_t t;\n    int s;\n    char *str;\n\n    str = strerror(EINVAL);\n    printf(\"Main thread has called strerror()\\n\");\n\n    s = pthread_create(&t, NULL, threadFunc, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n\n    s = pthread_join(t, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n\n    printf(\"Main thread:  str (%p) = %s\\n\", str, str);\n\n    exit(EXIT_SUCCESS);\n}\n\n      `threads/strerror_test.c`\n```", "```\n`threads/strerror_tsd.c`\n    #define _GNU_SOURCE             /* Get '_sys_nerr' and '_sys_errlist'\n                                   declarations from <stdio.h> */\n    #include <stdio.h>\n    #include <string.h>             /* Get declaration of strerror() */\n    #include <pthread.h>\n    #include \"tlpi_hdr.h\"\n\n    static pthread_once_t once = PTHREAD_ONCE_INIT;\n    static pthread_key_t strerrorKey;\n\n    #define MAX_ERROR_LEN 256       /* Maximum length of string in per-thread\n                                 buffer returned by strerror() */\n\n    static void                     /* Free thread-specific data buffer */\n  destructor(void *buf)\n    {\n        free(buf);\n    }\n\n    static void                     /* One-time key creation function */\n  createKey(void)\n    {\n        int s;\n\n        /* Allocate a unique thread-specific data key and save the address\n           of the destructor for thread-specific data buffers */\n\n    s = pthread_key_create(&strerrorKey, destructor);\n        if (s != 0)\n            errExitEN(s, \"pthread_key_create\");\n    }\n        char *\n    strerror(int err)\n    {\n        int s;\n        char *buf;\n\n        /* Make first caller allocate key for thread-specific data */\n\n    s = pthread_once(&once, createKey);\n      if (s != 0)\n            errExitEN(s, \"pthread_once\");\n\n    buf = pthread_getspecific(strerrorKey);\n      if (buf == NULL) {          /* If first call from this thread, allocate\n                                       buffer for thread, and save its location */\n        buf = malloc(MAX_ERROR_LEN);\n          if (buf == NULL)\n              errExit(\"malloc\");\n\n     s = pthread_setspecific(strerrorKey, buf);\n       if (s != 0)\n          errExitEN(s, \"pthread_setspecific\");\n        }\n\n        if (err < 0 || err >= _sys_nerr || _sys_errlist[err] == NULL) {\n            snprintf(buf, MAX_ERROR_LEN, \"Unknown error %d\", err);\n        } else {\n            strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);\n            buf[MAX_ERROR_LEN - 1] = '\\0';          /* Ensure null termination */\n        }\n\n        return buf;\n    }\n\n        `threads/strerror_tsd.c`\n```", "```\n$ `./strerror_test_tsd`\nMain thread has called strerror()\nOther thread about to call strerror()\nOther thread: str (0x804b158) = Operation not permitted\nMain thread:  str (0x804b008) = Invalid argument\n```", "```\nstatic __thread buf[MAX_ERROR_LEN];\n```", "```\n$ `./strerror_test_tls`\nMain thread has called strerror()\nOther thread about to call strerror()\nOther thread: str (0x40376ab0) = Operation not permitted\nMain thread:  str (0x40175080) = Invalid argument\n```", "```\n`threads/strerror_tls.c`\n#define _GNU_SOURCE                 /* Get '_sys_nerr' and '_sys_errlist'\n                                       declarations from <stdio.h> */\n#include <stdio.h>\n#include <string.h>           /* Get declaration of strerror() */\n#include <pthread.h>\n\n#define MAX_ERROR_LEN 256           /* Maximum length of string in per-thread\n                                       buffer returned by strerror() */\n\nstatic __thread char buf[MAX_ERROR_LEN];\n                                    /* Thread-local return buffer */\n\nchar *\nstrerror(int err)\n{\n    if (err < 0 || err >= _sys_nerr || _sys_errlist[err] == NULL) {\n        snprintf(buf, MAX_ERROR_LEN, \"Unknown error %d\", err);\n    } else {\n        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);\n        buf[MAX_ERROR_LEN - 1] = '\\0';          /* Ensure null termination */\n    }\n\n    return buf;\n}\n     `threads/strerror_tls.c`\n```"]