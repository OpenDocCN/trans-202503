- en: Chapter 15. File Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we investigate various attributes of files (file metadata).
    We begin with a description of the *stat()* system call, which returns a structure
    containing many of these attributes, including file timestamps, file ownership,
    and file permissions. We then go on to look at various system calls used to change
    these attributes. (The discussion of file permissions continues in [Chapter 17](ch17.html
    "Chapter 17. Access Control Lists"), where we look at access control lists.) We
    conclude the chapter with a discussion of i-node flags (also known as *ext2* extended
    file attributes), which control various aspects of the treatment of files by the
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving File Information: *stat()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *stat()*, *lstat()*, and *fstat()* system calls retrieve information about
    a file, mostly drawn from the file i-node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'These three system calls differ only in the way that the file is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '*stat()* returns information about a named file;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lstat()* is similar to *stat()*, except that if the named file is a symbolic
    link, information about the link itself is returned, rather than the file to which
    the link points; and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*fstat()* returns information about a file referred to by an open file descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *stat()* and *lstat()* system calls don’t require permissions on the file
    itself. However, execute (search) permission is required on all of the parent
    directories specified in *pathname*. The *fstat()* system call always succeeds,
    if provided with a valid file descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these system calls return a *stat* structure in the buffer pointed to
    by *statbuf*. This structure has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The various data types used to type the fields in the *stat* structure are all
    specified in SUSv3\. See [System Data Types](ch03.html#system_data_types "System
    Data Types") for further information about these types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to SUSv3, when *lstat()* is applied to a symbolic link, it needs to
    return valid information only in the *st_size* field and in the file type component
    (described shortly) of the *st_mode* field. None of other fields (e.g., the time
    fields) need contain valid information. This gives an implementation the freedom
    to not maintain these fields, which may be done for efficiency reasons. In particular,
    the intent of earlier UNIX standards was to allow a symbolic link to be implemented
    either as an i-node or as an entry in a directory. Under the latter implementation,
    it is not possible to implement all of the fields required by the *stat* structure.
    (On all major contemporary UNIX implementations, symbolic links are implemented
    as i-nodes. See [Symbolic (Soft) Links](ch18.html#symbolic_open_parenthesis_soft_close_par
    "Symbolic (Soft) Links") for further details.) On Linux, *lstat()* returns information
    in all of the *stat* fields when applied to a symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: In the following pages, we look at some of the *stat* structure fields in more
    detail, and finish with an example program that displays the entire *stat* structure.
  prefs: []
  type: TYPE_NORMAL
- en: Device IDs and i-node number
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *st_dev* field identifies the device on which the file resides. The *st_ino*
    field contains the i-node number of the file. The combination of *st_dev* and
    *st_ino* uniquely identifies a file across all file systems. The *dev_t* type
    records the major and minor IDs of a device ([Device Special Files (Devices)](ch14.html#device_special_files_open_parenthesis_de
    "Device Special Files (Devices)")).
  prefs: []
  type: TYPE_NORMAL
- en: If this is the i-node for a device, then the *st_rdev* field contains the major
    and minor IDs of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major and minor IDs of a *dev_t* value can be extracted using two macros:
    `major()` and `minor()`. The header file required to obtain the declarations of
    these two macros varies across UNIX implementations. On Linux, they are exposed
    by `<sys/types.h>` if the `_BSD_SOURCE` macro is defined.'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the integer values returned by `major()` and `minor()` varies across
    UNIX implementations. For portability, we always cast the returned values to *long*
    when printing them (see [System Data Types](ch03.html#system_data_types "System
    Data Types")).
  prefs: []
  type: TYPE_NORMAL
- en: File ownership
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *st_uid* and *st_gid* fields identify, respectively, the owner (user ID)
    and group (group ID) to which the file belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Link count
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *st_nlink* field is the number of (hard) links to the file. We describe
    links in detail in [Chapter 18](ch18.html "Chapter 18. Directories and Links").
  prefs: []
  type: TYPE_NORMAL
- en: File type and permissions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *st_mode* field is a bit mask serving the dual purpose of identifying the
    file type and specifying the file permissions. The bits of this field are laid
    out as shown in [Figure 15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "Figure 15-1. Layout of st_mode bit mask").
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout of st_mode bit mask](figs/web/15-1_FILES-st_mode.png.jpg)Figure 15-1. Layout
    of *st_mode* bit mask'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file type can be extracted from this field by ANDing (`&`) with the constant
    `S_IFMT`. (On Linux, 4 bits are used for the file-type component of the *st_mode*
    field. However, because SUSv3 makes no specification about how the file type is
    represented, this detail may vary across implementations.) The resulting value
    can then be compared with a range of constants to determine the file type, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this is a common operation, standard macros are provided to simplify
    the above to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full set of file-type macros (defined in `<sys/stat.h>`) is shown in [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "Table 15-1. Macros for checking file types in the st_mode field of the stat structure").
    All of the file-type macros in [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "Table 15-1. Macros for checking file types in the st_mode field of the stat structure")
    are specified in SUSv3 and appear on Linux. Some other UNIX implementations define
    additional file types (e.g., `S_IFDOOR`, for door files on Solaris). The type
    `S_IFLNK` is returned only by calls to *lstat()*, since calls to *stat()* always
    follow symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: The original POSIX.1 standard did not specify the constants shown in the first
    column of [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st "Table 15-1. Macros
    for checking file types in the st_mode field of the stat structure"), although
    most of them appeared on most UNIX implementations. SUSv3 requires these constants.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to obtain the definitions of `S_IFSOCK` and `S_ISSOCK()` from `<sys/stat.h>`,
    we must either define the `_BSD_SOURCE` feature test macro or define `_XOPEN_SOURCE`
    with a value greater than or equal to 500\. (The rules have varied somewhat across
    *glibc* versions: in some cases, `_XOPEN_SOURCE` must be defined with a value
    of 600 or greater.)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1. Macros for checking file types in the *st_mode* field of the *stat*
    structure
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | Test macro | File type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IFREG` | `S_ISREG()` | Regular file |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IFDIR` | `S_ISDIR()` | Directory |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IFCHR` | `S_ISCHR()` | Character device |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IFBLK` | `S_ISBLK()` | Block device |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IFIFO` | `S_ISFIFO()` | FIFO or pipe |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IFSOCK` | `S_ISSOCK()` | Socket |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IFLNK` | `S_ISLNK()` | Symbolic link |'
  prefs: []
  type: TYPE_TB
- en: The bottom 12 bits of the *st_mode* field define the permissions for the file.
    We describe the file permission bits in Section 15.4\. For now, we simply note
    that the 9 least significant of the permission bits are the read, write, and execute
    permissions for each of the categories owner, group, and other.
  prefs: []
  type: TYPE_NORMAL
- en: File size, blocks allocated, and optimal I/O block size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For regular files, the *st_size* field is the total size of the file in bytes.
    For a symbolic link, this field contains the length (in bytes) of the pathname
    pointed to by the link. For a shared memory object ([Chapter 54](ch54.html "Chapter 54. POSIX
    Shared Memory")), this field contains the size of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The *st_blocks* field indicates the total number of blocks allocated to the
    file, in 512-byte block units. This total includes space allocated for pointer
    blocks (see [Figure 14-2](ch14.html#structure_of_file_blocks_for_a_file_in_a "Figure 14-2. Structure
    of file blocks for a file in an ext2 file system"), in [I-nodes and data block
    pointers in *ext2*](ch14.html#i-nodes_and_data_block_pointers_in-id1 "I-nodes
    and data block pointers in ext2")). The choice of the 512-byte unit of measurement
    is historical—this is the smallest block size on any of the file systems that
    have been implemented under UNIX. More modern file systems use larger logical
    block sizes. For example, under *ext2*, the value in *st_blocks* is always a multiple
    of 2, 4, or 8, depending on whether the *ext2* logical block size is 1024, 2048,
    or 4096 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 doesn’t define the units in which *st_blocks* is measured, allowing the
    possibility that an implementation uses a unit other than 512 bytes. Most UNIX
    implementations do use 512-byte units, but HP-UX 11 uses file system–specific
    units (e.g., 1024 bytes in some cases).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *st_blocks* field records the number of disk blocks actually allocated.
    If the file contains holes ([Changing the File Offset: *lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()")), this will be smaller than might be expected
    from the corresponding number of bytes *(st_size)* in the file. (The disk usage
    command, *du -k file*, displays the actual space allocated for a file, in kilobytes;
    that is, a figure calculated from the *st_blocks* value for the file, rather than
    the *st_size* value.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *st_blksize* field is somewhat misleadingly named. It is not the block
    size of the underlying file system, but rather the optimal block size (in bytes)
    for I/O on files on this file system. I/O in blocks smaller than this size is
    less efficient (refer to [Kernel Buffering of File I/O: The Buffer Cache](ch13.html#kernel_buffering_of_file_i_solidus_o_col
    "Kernel Buffering of File I/O: The Buffer Cache")). A typical value returned in
    *st_blksize* is 4096.'
  prefs: []
  type: TYPE_NORMAL
- en: File timestamps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *st_atime*, *st_mtime*, and *st_ctime* fields contain, respectively, the
    times of last file access, last file modification, and last status change. These
    fields are of type *time_t*, the standard UNIX time format of seconds since the
    Epoch. We say more about these fields in Section 15.2.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Example 15-1](ch15.html#retrieving_and_interpreting_file_stat_in
    "Example 15-1. Retrieving and interpreting file stat information") uses *stat()*
    to retrieve information about the file named on its command line. If the *-l*
    command-line option is specified, then the program instead uses *lstat()* so that
    we can retrieve information about a symbolic link instead of the file to which
    it refers. The program prints all fields of the returned *stat* structure. (For
    an explanation of why we cast the *st_size* and *st_blocks* fields to *long long*,
    see [I/O on Large Files](ch05.html#i_solidus_o_on_large_files "I/O on Large Files").)
    The *filePermStr()* function used by this program is shown in [Example 15-4](ch15.html#convert_file_permissions_mask_to_string
    "Example 15-4. Convert file permissions mask to string"), in [Permissions on Directories](ch15.html#permissions_on_directories
    "Permissions on Directories").
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the use of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 15-1. Retrieving and interpreting file *stat* information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: File Timestamps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *st_atime*, *st_mtime*, and *st_ctime* fields of the *stat* structure contain
    file timestamps. These fields record, respectively, the times of last file access,
    last file modification, and last file status change (i.e., last change to the
    file’s i-node information). Timestamps are recorded in seconds since the Epoch
    (1 January 1970; see [Calendar Time](ch10.html#calendar_time "Calendar Time")).
  prefs: []
  type: TYPE_NORMAL
- en: Most native Linux and UNIX file systems support all of the timestamp fields,
    but some non-UNIX file systems may not.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-2](ch15.html#effect_of_various_functions_on_file_time "Table 15-2. Effect
    of various functions on file timestamps") summarizes which of the timestamp fields
    (and in some cases, the analogous fields in the parent directory) are changed
    by various system calls and library functions described in this book. In the headings
    of this table, *a*, *m*, and *c* represent the *st_atime*, *st_mtime*, and *st_ctime*
    fields, respectively. In most cases, the relevant timestamp is set to the current
    time by the system call. The exceptions are *utime()* and similar calls (discussed
    in [Nanosecond timestamps](ch15.html#nanosecond_timestamps-id1 "Nanosecond timestamps")
    and [Changing File Timestamps with *utime()* and *utimes()*](ch15.html#changing_file_timestamps_with_utime_open
    "Changing File Timestamps with utime() and utimes()")), which can be used to explicitly
    set the last file access and modification times to arbitrary values.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-2. Effect of various functions on file timestamps
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | File or directory | Parent directory | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a | m | c | a | m | c |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *chmod()* |   |   | • |   |   |   | Same for *fchmod()* |'
  prefs: []
  type: TYPE_TB
- en: '| *chown()* |   |   | • |   |   |   | Same for *lchown()* and *fchown()* |'
  prefs: []
  type: TYPE_TB
- en: '| *exec()* | • |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *link()* |   |   | • |   | • | • | Affects parent directory of second argument
    |'
  prefs: []
  type: TYPE_TB
- en: '| *mkdir()* | • | • | • |   | • | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *mkfifo()* | • | • | • |   | • | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *mknod()* | • | • | • |   | • | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *mmap()* | • | • | • |   |   |   | *st_mtime* and *st_ctime* are changed
    only on updates to `MAP_SHARED` mapping |'
  prefs: []
  type: TYPE_TB
- en: '| *msync()* |   | • | • |   |   |   | Changed only if file is modified |'
  prefs: []
  type: TYPE_TB
- en: '| *open()*, *creat()* | • | • | • |   | • | • | When creating new file |'
  prefs: []
  type: TYPE_TB
- en: '| *open()*, *creat()* |   | • | • |   |   |   | When truncating existing file
    |'
  prefs: []
  type: TYPE_TB
- en: '| *pipe()* | • | • | • |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *read()* | • |   |   |   |   |   | Same for *readv()*, *pread()*, and *preadv()*
    |'
  prefs: []
  type: TYPE_TB
- en: '| *readdir()* | • |   |   |   |   |   | readdir() may buffer directory entries;
    timestamps updated only if directory is read |'
  prefs: []
  type: TYPE_TB
- en: '| *removexattr()* |   |   | • |   |   |   | Same for *fremovexattr()* and *lremovexattr()*
    |'
  prefs: []
  type: TYPE_TB
- en: '| *rename()* |   |   | • |   | • | • | Affects timestamps in both parent directories;
    SUSv3 doesn’t specify file *st_ctime* change, but notes that some implementations
    do this |'
  prefs: []
  type: TYPE_TB
- en: '| *rmdir()* |   |   |   |   | • | • | Same for *remove(directory)* |'
  prefs: []
  type: TYPE_TB
- en: '| *sendfile()* | • |   |   |   |   |   | Timestamp changed for input file |'
  prefs: []
  type: TYPE_TB
- en: '| *setxattr()* |   |   | • |   |   |   | Same for *fsetxattr()* and *lsetxattr()*
    |'
  prefs: []
  type: TYPE_TB
- en: '| *symlink()* | • | • | • |   | • | • | Sets timestamps of link (not target
    file) |'
  prefs: []
  type: TYPE_TB
- en: '| *truncate()* |   | • | • |   |   |   | Same for *ftruncate()*; timestamps
    change only if file size changes |'
  prefs: []
  type: TYPE_TB
- en: '| *unlink()* |   |   | • |   | • | • | Same for *remove(file)*; file *st_ctime*
    changes if previous link count was > 1 |'
  prefs: []
  type: TYPE_TB
- en: '| *utime()* | • | • | • |   |   |   | Same for *utimes()*, *futimes()*, *futimens()*,
    *lutimes()*, and *utimensat()* |'
  prefs: []
  type: TYPE_TB
- en: '| *write()* |   | • | • |   |   |   | Same for *writev()*, *pwrite()*, and
    *pwritev()* |'
  prefs: []
  type: TYPE_TB
- en: 'In [Mounting a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()") and [I-node Flags (*ext2* Extended File Attributes)](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I-node Flags (ext2 Extended File Attributes)"), we describe *mount(2)* options
    and per-file flags that prevent updates to the last access time of a file. The
    *open()* `O_NOATIME` flag described in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()") also serves a similar purpose. In
    some applications, this can be useful for performance reasons, since it reduces
    the number of disk operations that are required when a file is accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although most UNIX systems don’t record the creation time of a file, on recent
    BSD systems, this time is recorded in a *stat* field named *st_birthtime*.
  prefs: []
  type: TYPE_NORMAL
- en: Nanosecond timestamps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With version 2.6, Linux supports nanosecond resolution for the three timestamp
    fields of the *stat* structure. Nanosecond resolution improves the accuracy of
    programs that need to make decisions based on the relative order of file timestamps
    (e.g., *make(1)*).
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 doesn’t specify nanosecond timestamps for the *stat* structure, but SUSv4
    adds this specification.
  prefs: []
  type: TYPE_NORMAL
- en: Not all file systems support nanosecond timestamps. *JFS*, *XFS*, *ext4*, and
    *Btrfs* do, but *ext2*, *ext3*, and *Reiserfs* do not.
  prefs: []
  type: TYPE_NORMAL
- en: Under the *glibc* API (since version 2.3), the timestamp fields are each defined
    as a *timespec* structure (we describe this structure when we discuss *utimensat()*
    later in this section), which represents a time in seconds and nanoseconds components.
    Suitable macro definitions make the seconds component of these structures visible
    using the traditional field names (*st_atime*, *st_mtime*, and *st_ctime*). The
    nanosecond components can be accessed using field names such *st_atim.tv_nsec*,
    for the nanosecond component of the last file access time.
  prefs: []
  type: TYPE_NORMAL
- en: Changing File Timestamps with *utime()* and *utimes()*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last file access and modification timestamps stored in a file i-node can
    be explicitly changed using *utime()* or one of a related set of system calls.
    Programs such as *tar(1)* and *unzip(1)* use these system calls to reset file
    timestamps when unpacking an archive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *pathname* argument identifies the file whose times we wish to modify.
    If *pathname* is a symbolic link, it is dereferenced. The *buf* argument can be
    either `NULL` or a pointer to a *utimbuf* structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The fields in this structure measure time in seconds since the Epoch ([Calendar
    Time](ch10.html#calendar_time "Calendar Time")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two different cases determine how *utime()* works:'
  prefs: []
  type: TYPE_NORMAL
- en: If *buf* is specified as `NULL`, then both the last access and the last modification
    times are set to the current time. In this case, either the effective user ID
    of the process must match the file’s user ID (owner), the process must have write
    permission on the file (logical, since a process with write permission on a file
    could employ other system calls that would have the side effect of changing these
    file timestamps), or the process must be privileged (`CAP_FOWNER` or `CAP_DAC_OVERRIDE`).
    (To be accurate, on Linux, it is the process’s file-system user ID, rather than
    its effective user ID, that is checked against the file’s user ID, as described
    in Section 9.5.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *buf* is specified as pointer to a *utimbuf* structure, then the last file
    access and modification times are updated using the corresponding fields of this
    structure. In this case, the effective user ID of the process must match the file’s
    user ID (having write permission on the file is not sufficient) or the caller
    must be privileged (`CAP_FOWNER`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To change just one of the file timestamps, we first use *stat()* to retrieve
    both times, use one of these times to initialize the *utimbuf* structure, and
    then set the other as desired. This is demonstrated in the following code, which
    makes the last modification time of a file the same as the last access time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A successful call to *utime()* always sets the last status change time to the
    current time.
  prefs: []
  type: TYPE_NORMAL
- en: Linux also provides the BSD-derived *utimes()* system call, which performs a
    similar task to *utime()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The most notable difference between *utime()* and *utimes()* is that *utimes()*
    allows time values to be specified with microsecond accuracy (the *timeval* structure
    is described in [Calendar Time](ch10.html#calendar_time "Calendar Time")). This
    provides (partial) access to the nanosecond accuracy with which file timestamps
    are provided in Linux 2.6\. The new file access time is specified in *tv[0]*,
    and the new modification time is specified in *tv[1]*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An example of the use of *utimes()* is provided in the file `files/t_utimes.c`
    in the source code distribution for this book.
  prefs: []
  type: TYPE_NORMAL
- en: The *futimes()* and *lutimes()* library functions perform a similar task to
    *utimes()*. They differ from *utimes()* in the argument used to specify the file
    whose timestamps are to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: With *futimes()*, the file is specified via an open file descriptor, *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: With *lutimes()*, the file is specified via a pathname, with the difference
    from *utimes()* that if the pathname refers to a symbolic link, then the link
    is not dereferenced; instead, the timestamps of the link itself are changed.
  prefs: []
  type: TYPE_NORMAL
- en: The *futimes()* function is supported since *glibc* 2.3\. The *lutimes()* function
    is supported since *glibc* 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: Changing File Timestamps with *utimensat()* and *futimens()*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *utimensat()* system call (supported since kernel 2.6.22) and the *futimens()*
    library function (supported since *glibc* 2.6) provide extended functionality
    for setting a file’s last access and last modification timestamps. Among the advantages
    of these interfaces are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can set timestamps with nanosecond precision. This improves on the microsecond
    precision provided by *utimes()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to set the timestamps independently (i.e., one at a time). As
    shown earlier, to change just one of the timestamps using the older interfaces,
    we must first call *stat()* to retrieve the value of the other timestamp, and
    then specify the retrieved value along with the timestamp whose value we want
    to change. (This could lead to a race condition if another process performed an
    operation that updated the timestamp between these two steps.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can independently set either of the timestamps to the current time. To change
    just one timestamp to the current time with the older interfaces, we need to employ
    a call to *stat()* to retrieve the setting of the timestamp whose value we wish
    to leave unchanged, and a call to *gettimeofday()* to obtain the current time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These interfaces are not specified in SUSv3, but are included in SUSv4.
  prefs: []
  type: TYPE_NORMAL
- en: The *utimensat()* system call updates the timestamps of the file specified by
    *pathname* to the values specified in the array *times*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'If *times* is specified as `NULL`, then both file timestamps are updated to
    the current time. If *times* is not `NULL`, then the new last access timestamp
    is specified in *times[0]* and the new last modification timestamp is specified
    in *times[1]*. Each of the elements of the array *times* is a structure of the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The fields in this structure specify a time in seconds and nanoseconds since
    the Epoch ([Calendar Time](ch10.html#calendar_time "Calendar Time")).
  prefs: []
  type: TYPE_NORMAL
- en: To set one of the timestamps to the current time, we specify the special value
    `UTIME_NOW` in the corresponding *tv_nsec* field. To leave one of the timestamps
    unchanged, we specify the special value `UTIME_OMIT` in the corresponding *tv_nsec*
    field. In both cases, the value in the corresponding *tv_sec* field is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The *dirfd* argument can either specify `AT_FDCWD`, in which case the *pathname*
    argument is interpreted as for *utimes()*, or it can specify a file descriptor
    referring to a directory. The purpose of the latter choice is described in [Operating
    Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor").
  prefs: []
  type: TYPE_NORMAL
- en: The *flags* argument can be either 0, or `AT_SYMLINK_NOFOLLOW`, meaning that
    *pathname* should not be dereferenced if it is a symbolic link (i.e., the timestamps
    of the symbolic link itself should be changed). By contrast, *utimes()* always
    dereferences symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code segment sets the last access time to the current time and
    leaves the last modification time unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The permission rules for changing timestamps with *utimensat()* (and *futimens()*)
    are similar to those for the older APIs, and are detailed in the *utimensat(2)*
    manual page.
  prefs: []
  type: TYPE_NORMAL
- en: The *futimens()* library function updates the timestamps of the file referred
    to by the open file descriptor *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *times* argument of *futimens()* is used in the same way as for *utimensat()*.
  prefs: []
  type: TYPE_NORMAL
- en: File Ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each file has an associated user ID (UID) and group ID (GID). These IDs determine
    which user and group the file belongs to. We now look at the rules that determine
    the ownership of new files and describe the system calls used to change a file’s
    ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership of New Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a new file is created, its user ID is taken from the effective user ID
    of the process. The group ID of the new file may be taken from either the effective
    group ID of the process (equivalent to the System V default behavior) or the group
    ID of the parent directory (the BSD behavior). The latter possibility is useful
    for creating project directories in which all files belong to a particular group
    and are accessible to the members of that group. Which of the two values is used
    as the new file’s group ID is determined by various factors, including the type
    of file system on which the new file is created. We begin by describing the rules
    followed by *ext2* and a few other file systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be accurate, on Linux, all uses of the terms *effective user* or *group ID*
    in this section should really be *file-system user* or *group ID* ([File-System
    User ID and File-System Group ID](ch09.html#file-system_user_id_and_file-system_grou
    "File-System User ID and File-System Group ID")).
  prefs: []
  type: TYPE_NORMAL
- en: When an *ext2* file system is mounted, either the *-o grpid* (or the synonymous
    *-o bsdgroups*) option or the *-o nogrpid* (or the synonymous *-o sysvgroups*)
    option may be specified to the *mount* command. (If neither option is specified,
    the default is *-o nogrpid*.) If *-o grpid* is specified, then a new file always
    inherits its group ID from the parent directory. If *-o nogrpid* is specified,
    then, by default, a new file takes its group ID from the process’s effective group
    ID. However, if the set-group-ID bit is enabled for the directory (via *chmod
    g+s*), then the group ID of the file is inherited from the parent directory. These
    rules are summarized in [Table 15-3](ch15.html#rules_determining_the_group_ownership_of
    "Table 15-3. Rules determining the group ownership of a newly created file").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Creating and Removing Directories: *mkdir()* and *rmdir()*](ch18.html#creating_and_removing_directories_colon
    "Creating and Removing Directories: mkdir() and rmdir()"), we’ll see that when
    the set-group-ID bit is set on a directory, then it is also set on new subdirectories
    created within that directory. In this manner, the set-group-ID behavior described
    in the main text is propagated down through an entire directory tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-3. Rules determining the group ownership of a newly created file
  prefs: []
  type: TYPE_NORMAL
- en: '| File system mount option | Set-group-ID bit enabled on parent directory?
    | Group ownership of new file taken from |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *-o grpid*, *-o bsdgroups* | (ignored) | parent directory group ID |'
  prefs: []
  type: TYPE_TB
- en: '| *-o nogrpid*, *-o sysvgroups* (*default*) | no | process effective group
    ID |'
  prefs: []
  type: TYPE_TB
- en: '| yes | parent directory group ID |'
  prefs: []
  type: TYPE_TB
- en: At the time of writing, the only file systems that support the *grpid* and *nogrpid*
    mount options are *ext2*, *ext3*, *ext4*, and (since Linux 2.6.14) *XFS*. Other
    file systems follow the *nogrpid* rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing File Ownership: *chown()*, *fchown()*, and *lchown()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *chown()*, *lchown()*, and *fchown()* system calls change the owner (user
    ID) and group (group ID) of a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinction between these three system calls is similar to the *stat()*
    family of system calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '*chown()* changes the ownership of the file named in the *pathname* argument;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lchown()* does the same, except that if *pathname* is a symbolic link, ownership
    of the link file is changed, rather than the file to which it refers; and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*fchown()* changes the ownership of a file referred to by the open file descriptor,
    *fd*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *owner* argument specifies the new user ID for the file, and the *group*
    argument specifies the new group ID for the file. To change just one of the IDs,
    we can specify -1 for the other argument to leave that ID unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to Linux 2.2, *chown()* did not dereference symbolic links. The semantics
    of *chown()* were changed with Linux 2.2, and the new *lchown()* system call was
    added to provide the behavior of the old *chown()* system call.
  prefs: []
  type: TYPE_NORMAL
- en: Only a privileged (`CAP_CHOWN`) process may use *chown()* to change the user
    ID of a file. An unprivileged process can use *chown()* to change the group ID
    of a file that it owns (i.e., the process’s effective user ID matches the user
    ID of the file) to any of the groups of which they are a member. A privileged
    process can change the group ID of a file to any value.
  prefs: []
  type: TYPE_NORMAL
- en: If the owner or group of a file is changed, then the set-user-ID and set-group-ID
    permission bits are both turned off. This is a security precaution to ensure that
    a normal user could not enable the set-user-ID (or set-group-ID) bit on an executable
    file and then somehow make it owned by some privileged user (or group), thereby
    gaining that privileged identity when executing the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 leaves it unspecified whether the set-user-ID and set-group-ID bits should
    be turned off when the superuser changes the owner or group of an executable file.
    Linux 2.0 did turn these bits off in this case, while some of the early 2.2 kernels
    (up to 2.2.12) did not. Later 2.2 kernels returned to the 2.0 behavior, where
    changes by the superuser are treated the same as everyone else, and this behavior
    is maintained in subsequent kernel versions. (However, if we use the *chown(1)*
    command under a *root* login to change the ownership of a file, then, after calling
    *chown(2)*, the *chown* command uses the *chmod()* system call to reenable the
    set-user-ID and set-group-ID bits.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When changing the owner or group of a file, the set-group-ID permission bit
    is not turned off if the group-execute permission bit is already off or if we
    are changing the ownership of a directory. In both of these cases, the set-group-ID
    bit is being used for a purpose other than the creation of a set-group-ID program,
    and therefore it is undesirable to turn the bit off. These other uses of the set-group-ID
    bit are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the group-execute permission bit is off, then the set-group-ID permission
    bit is being used to enable mandatory file locking (discussed in [Mandatory Locking](ch55.html#mandatory_locking
    "Mandatory Locking")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a directory, the set-group-ID bit is being used to control the
    ownership of new files created in the directory ([Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of *chown()* is demonstrated in [Example 15-2](ch15.html#changing_the_owner_and_group_of_a_file
    "Example 15-2. Changing the owner and group of a file"), a program that allows
    the user to change the owner and group of an arbitrary number of files, specified
    as command-line arguments. (This program uses the *userIdFromName()* and *groupIdFromName()*
    functions from [Example 8-1](ch08.html#functions_to_convert_user_and_group_ids
    "Example 8-1. Functions to convert user and group IDs to and from user and group
    names"), in [Example program](ch08.html#example_program-id5 "Example program"),
    to convert user and group names into corresponding numeric IDs.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2. Changing the owner and group of a file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: File Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we describe the permission scheme applied to files and directories.
    Although we talk about permissions here mainly as they apply to regular files
    and directories, the rules that we describe apply to all types of files, including
    devices, FIFOs, and UNIX domain sockets. Furthermore, the System V and POSIX interprocess
    communication objects (shared memory, semaphores, and message queues) also have
    permission masks, and the rules that apply for these objects are similar to those
    for files.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions on Regular Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As noted in [Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()"), the bottom 12 bits of the *st_mode* field
    of the *stat* structure define the permissions for a file. The first 3 of these
    bits are special bits known as the set-user-ID, set-group-ID, and sticky bits
    (labeled U, G, and T, respectively, in [Figure 15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "Figure 15-1. Layout of st_mode bit mask")). We say more about these bits in [Set-User-ID,
    Set-Group-ID, and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and
    "Set-User-ID, Set-Group-ID, and Sticky Bits"). The remaining 9 bits form the mask
    defining the permissions that are granted to various categories of users accessing
    the file. The file permissions mask divides the world into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Owner* (also known as *user*): The permissions granted to the owner of the
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *user* is used by commands such as *chmod(1)*, which uses the abbreviation
    *u* to refer to this permission category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Group*: The permissions granted to users who are members of the file’s group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Other*: The permissions granted to everyone else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three permissions may be granted to each user category:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Read*: The contents of the file may be read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Write*: The contents of the file may be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Execute*: The file may be executed (i.e., it is a program or a script). In
    order to execute a script file (e.g., a *bash* script), both read and execute
    permissions are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The permissions and ownership of a file can be viewed using the command *ls
    -l*, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the file permissions are displayed as `rwxr-x---` (the
    initial hyphen preceding this string indicates the type of this file: a regular
    file). To interpret this string, we break these 9 characters into sets of 3 characters,
    which respectively indicate whether read, write, and execute permission are enabled.
    The first set indicates the permissions for owner, which has read, write, and
    execute permissions enabled. The next set indicates the permissions for group,
    which has read and execute enabled, but not write. The final set are the permissions
    for other, which doesn’t have any permissions enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<sys/stat.h>` header file defines constants that can be ANDed (`&`) with
    *st_mode* of the *stat* structure, in order to check whether particular permission
    bits are set. (These constants are also defined via the inclusion of `<fcntl.h>`,
    which prototypes the *open()* system call.) These constants are shown in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits").
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-4. Constants for file permission bits
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | Octal value | Permission bit |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S_ISUID` | `04000` | Set-user-ID |'
  prefs: []
  type: TYPE_TB
- en: '| `S_ISGID` | `02000` | Set-group-ID |'
  prefs: []
  type: TYPE_TB
- en: '| `S_ISVTX` | `01000` | Sticky |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IRUSR` | `0400` | User-read |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IWUSR` | `0200` | User-write |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IXUSR` | `0100` | User-execute |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IRGRP` | `040` | Group-read |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IWGRP` | `020` | Group-write |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IXGRP` | `010` | Group-execute |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IROTH` | `04` | Other-read |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IWOTH` | `02` | Other-write |'
  prefs: []
  type: TYPE_TB
- en: '| `S_IXOTH` | `01` | Other-execute |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the constants shown in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), three constants are defined
    to equate to masks for all three permissions for each of the categories owner,
    group, and other: `S_IRWXU` (0700), `S_IRWXG` (070), and `S_IRWXO` (07).'
  prefs: []
  type: TYPE_NORMAL
- en: The header file in [Example 15-3](ch15.html#header_file_for_file_underscore_perms.c
    "Example 15-3. Header file for file_perms.c") declares a function, *filePermStr()*,
    which, given a file permissions mask, returns a statically allocated string representation
    of that mask in the same style as is used by *ls(1)*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3. Header file for `file_perms.c`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the `FP_SPECIAL` flag is set in the *filePermStr() flags* argument, then
    the returned string includes the settings of the set-user-ID, set-group-ID, and
    sticky bits, again in the style of *ls(1)*.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the *filePermStr()* function is shown in [Example 15-4](ch15.html#convert_file_permissions_mask_to_string
    "Example 15-4. Convert file permissions mask to string"). We employ this function
    in the program in [Example 15-1](ch15.html#retrieving_and_interpreting_file_stat_in
    "Example 15-1. Retrieving and interpreting file stat information").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-4. Convert file permissions mask to string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Permissions on Directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Directories have the same permission scheme as files. However, the three permissions
    are interpreted differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Read*: The contents (i.e., the list of filenames) of the directory may be
    listed (e.g., by *ls*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If experimenting to verify the operation of the directory read permission bit,
    be aware that some Linux distributions alias the *ls* command to include flags
    (e.g., *-F*) that require access to i-node information for files in the directory,
    and this requires execute permission on the directory. To ensure that we are using
    an unadulterated ls, we can specify the full pathname of the command `(/bin/ls)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Write*: Files may be created in and removed from the directory. Note that
    it is not necessary to have any permission on a file itself in order to be able
    to delete it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Execute*: Files within the directory may be accessed. Execute permission on
    a directory is sometimes called *search* permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When accessing a file, execute permission is required on all of the directories
    listed in the pathname. For example, reading the file `/home/mtk/x` would require
    execute permission on `/`, `/home`, and `/home/mtk` (as well as read permission
    on the file `x` itself). If the current working directory is `/home/mtk/sub1`
    and we access the relative pathname `../sub2/x`, then we need execute permission
    on `/home/mtk` and `/home/mtk/sub2` (but not on `/` or `/home`).
  prefs: []
  type: TYPE_NORMAL
- en: Read permission on a directory only lets us view the list of filenames in the
    directory. We must have execute permission on the directory in order to access
    the contents or the i-node information of files in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if we have execute permission on a directory, but not read permission,
    then we can access a file in the directory if we know its name, but we can’t list
    the contents of (i.e., the other filenames in) the directory. This is a simple
    and frequently used technique to control access to the contents of a public directory.
  prefs: []
  type: TYPE_NORMAL
- en: To add or remove files in a directory, we need both execute and write permissions
    on the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Permission-Checking Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The kernel checks file permissions whenever we specify a pathname in a system
    call that accesses a file or directory. When the pathname given to the system
    call includes a directory prefix, then, in addition to checking for the required
    permissions on the file itself, the kernel also checks for execute permission
    on each of the directories in this prefix. Permission checks are made using the
    process’s effective user ID, effective group ID, and supplementary group IDs.
    (To be strictly accurate, for file permission checks on Linux, the file-system
    user and group IDs are used instead of the corresponding effective IDs, as described
    in Section 9.5.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a file has been opened with *open()*, no permission checking is performed
    by subsequent system calls that work with the returned file descriptor (such as
    *read()*, *write()*, *fstat()*, *fcntl()*, and *mmap()*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules applied by the kernel when checking permissions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the process is privileged, all access is granted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the effective user ID of the process is the same as the user ID (owner) of
    the file, then access is granted according to the *owner* permissions on the file.
    For example, read access is granted if the owner-read permission bit is turned
    on in the file permissions mask; otherwise, read access is denied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the effective group ID of the process or any of the process supplementary
    group IDs matches the group ID (group owner) of the file, then access is granted
    according to the *group* permissions on the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, access is granted according to the *other* permissions on the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the kernel code, the above tests are actually constructed so that the test
    to see whether a process is privileged is performed only if the process is not
    granted the permissions it needs via one of the other tests. This is done to avoid
    unnecessarily setting the `ASU` process accounting flag, which indicates that
    the process made use of superuser privileges ([Process Accounting](ch28.html#process_accounting
    "Process Accounting")).
  prefs: []
  type: TYPE_NORMAL
- en: 'The checks against owner, group, and other permissions are done in order, and
    checking stops as soon as the applicable rule is found. This can have an unexpected
    consequence: if, for example, the permissions for group exceed those of owner,
    then the owner will actually have fewer permissions on the file than members of
    the file’s group, as illustrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Similar remarks apply if other grants more permissions than owner or group.
  prefs: []
  type: TYPE_NORMAL
- en: Since file permissions and ownership information are maintained within a file
    i-node, all filenames (links) that refer to the same i-node share this information.
  prefs: []
  type: TYPE_NORMAL
- en: Linux 2.6 provides access control lists (ACLs), which make it possible to define
    file permissions on a per-user and per-group basis. If a file has an ACL, then
    a modified version of the above algorithm is used. We describe ACLs in [Chapter 17](ch17.html
    "Chapter 17. Access Control Lists").
  prefs: []
  type: TYPE_NORMAL
- en: Permission checking for privileged processes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Above, we said that if a process is privileged, all access is granted when checking
    permissions. We need to add one proviso to this statement. For a file that is
    not a directory, Linux grants execute permission to a privileged process only
    if that permission is granted to at least one of the permission categories for
    the file. On some other UNIX implementations, a privileged process can execute
    a file even when no permission category grants execute permission. When accessing
    a directory, a privileged process is always granted execute (search) permission.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can rephrase our description of a privileged process in terms of two Linux
    process capabilities: `CAP_DAC_READ_SEARCH` and `CAP_DAC_OVERRIDE` ([The Linux
    Capabilities](ch39.html#the_linux_capabilities "The Linux Capabilities")). A process
    with the `CAP_DAC_READ_SEARCH` capability always has read permission for any type
    of file, and always has read and execute permissions for a directory (i.e., can
    always access files in a directory and read the list of files in a directory).
    A process with the `CAP_DAC_OVERRIDE` capability always has read and write permissions
    for any type of file, and also has execute permission if the file is a directory
    or if execute permission is granted to at least one of the permission categories
    for the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking File Accessibility: *access()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in [Permission-Checking Algorithm](ch15.html#permission-checking_algorithm
    "Permission-Checking Algorithm"), the *effective* user and group IDs, as well
    as supplementary group IDs, are used to determine the permissions a process has
    when accessing a file. It is also possible for a program (e.g., a set-user-ID
    or set-group-ID program) to check file accessibility based on the *real* user
    and group IDs of the process.
  prefs: []
  type: TYPE_NORMAL
- en: The *access()* system call checks the accessibility of the file specified in
    *pathname* based on a process’s real user and group IDs (and supplementary group
    IDs).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 if all permissions are granted, otherwise -1
  prefs: []
  type: TYPE_NORMAL
- en: If *pathname* is a symbolic link, *access()* dereferences it.
  prefs: []
  type: TYPE_NORMAL
- en: The *mode* argument is a bit mask consisting of one or more of the constants
    shown in [Table 15-5](ch15.html#mode_constants_for_access_open_parenthes "Table 15-5. mode
    constants for access()"), ORed (`|`) together. If all of the permissions specified
    in *mode* are granted on *pathname*, then *access()* returns 0; if at least one
    of the requested permissions is not available (or an error occurred), then *access()*
    returns -1.
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-5. *mode* constants for *access()*
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `F_OK` | Does the file exist? |'
  prefs: []
  type: TYPE_TB
- en: '| `R_OK` | Can the file be read? |'
  prefs: []
  type: TYPE_TB
- en: '| `W_OK` | Can the file be written? |'
  prefs: []
  type: TYPE_TB
- en: '| `X_OK` | Can the file be executed? |'
  prefs: []
  type: TYPE_TB
- en: The time gap between a call to *access()* and a subsequent operation on a file
    means that there is no guarantee that the information returned by *access()* will
    still be true at the time of the later operation (no matter how brief the interval).
    This situation could lead to security holes in some application designs.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, that we have a set-user-ID-*root* program that uses *access()*
    to check that a file is accessible to the real user ID of the program, and, if
    so, performs an operation on the file (e.g., *open()* or *exec()*).
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that if the pathname given to *access()* is a symbolic link,
    and a malicious user manages to change the link so that it refers to a different
    file before the second step, then the set-user-ID-*root* may end up operating
    on a file for which the real user ID does not have permission. (This is an example
    of the type of time-of-check, time-of-use race condition described in Section
    38.6.) For this reason, recommended practice is to avoid the use of *access()*
    altogether (see, for example, [Borisov, 2005]). In the example just given, we
    can achieve this by temporarily changing the effective (or file system) user ID
    of the set-user-ID process, attempting the desired operation (e.g., *open()* or
    *exec()*), and then checking the return value and *errno* to determine whether
    the operation failed because of a permissions problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GNU C library provides an analogous, nonstandard function, *euidaccess()*
    (or synonymously, *eaccess()*), that checks file access permissions using the
    effective user ID of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Set-User-ID, Set-Group-ID, and Sticky Bits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As well as the 9 bits used for owner, group, and other permissions, the file
    permissions mask contains 3 additional bits, known as the *set-user-ID* (bit 04000),
    *set-group-ID* (bit 02000), and *sticky* (bit 01000) bits. We have already discussed
    the use of the set-user-ID and set-group-ID permission bits for creating privileged
    programs in Section 9.3\. The set-group-ID bit also serves two other purposes
    that we describe elsewhere: controlling the group ownership of new files created
    in a directory mounted with the *nogrpid* option ([Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files")), and enabling mandatory locking on a file ([Mandatory
    Locking](ch55.html#mandatory_locking "Mandatory Locking")). In the remainder of
    this section, we limit our discussion to the use of the sticky bit.'
  prefs: []
  type: TYPE_NORMAL
- en: On older UNIX implementations, the sticky bit was provided as a way of making
    commonly used programs run faster. If the sticky bit was set on a program file,
    then the first time the program was executed, a copy of the program text was saved
    in the swap area—thus it *sticks* in swap, and loads faster on subsequent executions.
    Modern UNIX implementations have more sophisticated memory-management systems,
    which have rendered this use of the sticky permission bit obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name of the constant for the sticky permission bit shown in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), `S_ISVTX`, derives from an
    alternative name for the sticky bit: the *saved-text* bit.'
  prefs: []
  type: TYPE_NORMAL
- en: In modern UNIX implementations (including Linux), the sticky permission bit
    serves another, quite different purpose. For directories, the sticky bit acts
    as the *restricted deletion* flag. Setting this bit on a directory means that
    an unprivileged process can unlink (*unlink()*, *rmdir()*) and rename (*rename()*)
    files in the directory only if it has write permission on the directory *and*
    owns either the file or the directory. (A process with the `CAP_FOWNER` capability
    can bypass the latter ownership check.) This makes it possible to create a directory
    that is shared by many users, who can each create and delete their own files in
    the directory but can’t delete files owned by other users. The sticky permission
    bit is commonly set on the `/tmp` directory for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'A file’s sticky permission bit is set via the *chmod* command (*chmod +t file*)
    or via the *chmod()* system call. If the sticky bit for a file is set, *ls -l*
    shows a lowercase or uppercase letter *T* in the other-execute permission field,
    depending on whether the other-execute permission bit is on or off, as in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The Process File Mode Creation Mask: *umask()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now consider in more detail the permissions that are placed on a newly created
    file or directory. For new files, the kernel uses the permissions specified in
    the *mode* argument to *open()* or *creat()*. For new directories, permissions
    are set according to the *mode* argument to *mkdir()*. However, these settings
    are modified by the file mode creation mask, also known simply as the *umask*.
    The umask is a process attribute that specifies which permission bits should always
    be turned *off* when new files or directories are created by the process.
  prefs: []
  type: TYPE_NORMAL
- en: Often, a process just uses the umask it inherits from its parent shell, with
    the (usually desirable) consequence that the user can control the umask of programs
    executed from the shell using the shell built-in command *umask*, which changes
    the umask of the shell process.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization files for most shells set the default umask to the octal
    value 022 (`----w--w-`). This value specifies that write permission should always
    be turned off for group and other. Thus, assuming the *mode* argument in a call
    to *open()* is 0666 (i.e., read and write permitted for all users, which is typical),
    then new files are created with read and write permissions for owner, and only
    read permission for everyone else (displayed by *ls -l* as `rw-r--r--`). Correspondingly,
    assuming that the *mode* argument to *mkdir()* is specified as 0777 (i.e., all
    permissions granted to all users), new directories are created with all permissions
    granted for owner, and just read and execute permissions for group and other (i.e.,
    `rwxr-xr-x`).
  prefs: []
  type: TYPE_NORMAL
- en: The *umask()* system call changes a process’s umask to the value specified in
    *mask*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always successfully returns the previous process umask
  prefs: []
  type: TYPE_NORMAL
- en: The *mask* argument can be specified either as an octal number or by ORing (`|`)
    together the constants listed in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits").
  prefs: []
  type: TYPE_NORMAL
- en: A call to *umask()* is always successful, and returns the previous umask.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 15-5](ch15.html#using_umask_open_parenthesis_close_paren "Example 15-5. Using
    umask()") illustrates the use of *umask()* in conjunction with *open()* and *mkdir()*.
    When we run this program, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Example 15-5](ch15.html#using_umask_open_parenthesis_close_paren "Example 15-5. Using
    umask()"), we employ the *mkdir()* and *rmdir()* system calls to create and remove
    a directory, and the *unlink()* system call to remove a file. We describe these
    system calls in [Chapter 18](ch18.html "Chapter 18. Directories and Links").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-5. Using *umask()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing File Permissions: *chmod()* and *fchmod()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *chmod()* and *fchmod()* system calls change the permissions of a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *chmod()* system call changes the permissions of the file named in *pathname*.
    If this argument is a symbolic link, *chmod()* changes the permissions of the
    file to which it refers, rather than the permissions of the link itself. (A symbolic
    link is always created with read, write, and execute permissions enabled for all
    users, and these permission can’t be changed. These permissions are ignored when
    dereferencing the link.)
  prefs: []
  type: TYPE_NORMAL
- en: The *fchmod()* system call changes the permissions on the file referred to by
    the open file descriptor *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: The *mode* argument specifies the new permissions of the file, either numerically
    (octal) or as a mask formed by ORing (|) the permission bits listed in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"). In order to change the permissions
    on a file, either the process must be privileged (`CAP_FOWNER`) or its effective
    user ID must match the owner (user ID) of the file. (To be strictly accurate,
    on Linux, for an unprivileged process, it is the process’s file-system user ID,
    rather than its effective user ID, that must match the user ID of the file, as
    described in Section 9.5.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the permissions on a file so that only read permission is granted to
    all users, we could use the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to modify selected bits of the file permissions, we first retrieve
    the existing permissions using *stat()*, tweak the bits we want to change, and
    then use *chmod()* to update the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is equivalent to the following shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Ownership of New Files](ch15.html#ownership_of_new_files "Ownership of
    New Files"), we noted that if a directory resides on an *ext2* system mounted
    with the *-o bsdgroups* option, or on one mounted with the *-o sysvgroups* option
    *and* the set-group-ID permission bit is turned on for the directory, then a newly
    created file in the directory takes its ownership from the parent directory, not
    the effective group ID of the creating process. It may be the case that the group
    ID of such a file doesn’t match any of the group IDs of the creating process.
    For this reason, when an unprivileged process (one that doesn’t have the `CAP_FSETID`
    capability) calls *chmod()* (or *fchmod()*) on a file whose group ID is not equal
    to the effective group ID or any of the supplementary group IDs of the process,
    the kernel always clears the set-group-ID permission bit. This is a security measure
    designed to prevent a user from creating a set-group-ID program for a group of
    which they are not a member. The following shell commands show the attempted exploit
    that this measure prevents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I-node Flags (*ext2* Extended File Attributes)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some Linux file systems allow various *i-node flags* to be set on files and
    directories. This feature is a nonstandard Linux extension.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modern BSDs provide a similar feature to i-node flags in the form of file
    flags set using *chflags(1)* and *chflags(2)*.
  prefs: []
  type: TYPE_NORMAL
- en: The first Linux file system to support i-node flags was *ext2*, and these flags
    are sometimes referred to as *ext2 extended file attributes*. Subsequently, support
    for i-node flags has been added on other file systems, including *Btrfs*, *ext3*,
    *ext4*, *Reiserfs* (since Linux 2.4.19), *XFS* (since Linux 2.4.25 and 2.6), and
    *JFS* (since Linux 2.6.17).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The range of i-node flags supported varies somewhat across file systems. In
    order to use i-node flags on a *Reiserfs* file system, we must use the *mount
    -o attrs* option when mounting the file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the shell, i-node flags can be set and viewed using the *chattr* and *lsattr*
    commands, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Within a program, i-node flags can be retrieved and modified using the *ioctl()*
    system call, as detailed shortly.
  prefs: []
  type: TYPE_NORMAL
- en: I-node flags can be set on both regular files and directories. Most i-node flags
    are intended for use with regular files, although some of them also (or only)
    have meaning for directories. [Table 15-6](ch15.html#i-node_flags "Table 15-6. I-node
    flags") summarizes the range of available i-node flags, showing the corresponding
    flag name (defined in `<linux/fs.h>`) that is used from programs in *ioctl()*
    calls, and the option letter that is used with the *chattr* command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before Linux 2.6.19, the `FS_*` constants shown in [Table 15-6](ch15.html#i-node_flags
    "Table 15-6. I-node flags") were not defined in `<linux/fs.h>`. Instead, there
    was a set of file system–specific header files that defined file system-specific
    constant names, all with the same value. Thus, *ext2* had `EXT2_APPEND_FL`, defined
    in `<linux/ext2_fs.h>`; *Reiserfs* had `REISERFS_APPEND_FL`, defined with the
    same value in `<linux/reiser_fs.h>`; and so on. Since each of the header files
    defines the corresponding constants with the same value, on older systems that
    don’t provide the definitions in `<linux/fs.h>`, it is possible to include any
    of the header files and use the file system–specific names.
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-6. I-node flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | *chattr* option | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_APPEND_FL` | `a` | Append only (privilege required) |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_COMPR_FL` | `c` | Enable file compression (not implemented) |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_DIRSYNC_FL` | `D` | Synchronous directory updates (since Linux 2.6) |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_IMMUTABLE_FL` | `i` | Immutable (privilege required) |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_JOURNAL_DATA_FL` | `j` | Enable data journaling (privilege required)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_NOATIME_FL` | `A` | Don’t update file last access time |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_NODUMP_FL` | `d` | No dump |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_NOTAIL_FL` | `t` | No tail packing |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_SECRM_FL` | `s` | Secure deletion (not implemented) |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_SYNC_FL` | `S` | Synchronous file (and directory) updates |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_TOPDIR_FL` | `T` | Treat as top-level directory for Orlov (since Linux
    2.6) |'
  prefs: []
  type: TYPE_TB
- en: '| `FS_UNRM_FL` | `u` | File can be undeleted (not implemented) |'
  prefs: []
  type: TYPE_TB
- en: 'The various `FL_*` flags and their meanings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_APPEND_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: The file can be opened for writing only if the `O_APPEND` flag is specified
    (thus forcing all file updates to append to the end of the file). This flag could
    be used for a log file, for example. Only privileged (`CAP_LINUX_IMMUTABLE`) processes
    can set this flag.
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_COMPR_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: Store the file on disk in a compressed format. This feature is not implemented
    as a standard part of any of the major native Linux file systems. (There are packages
    that implement this feature for *ext2* and *ext3*.) Given the low cost of disk
    storage, the CPU overhead involved in compression and decompression, and the fact
    that compressing a file means that it is no longer a simple matter to randomly
    access the file’s contents (via *lseek()*), file compression is undesirable for
    many applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_DIRSYNC_FL` (since Linux 2.6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make directory updates (e.g., *open(pathname, O_CREAT)*, *link()*, *unlink()*,
    and *mkdir()*) synchronous. This is analogous to the synchronous file update mechanism
    described in Section 13.3\. As with synchronous file updates, there is a performance
    impact associated with synchronous directory updates. This setting can be applied
    only to directories. (The `MS_DIRSYNC` mount flag described in [Mounting a File
    System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open "Mounting
    a File System: mount()") provides similar functionality, but on a per-mount basis.)'
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_IMMUTABLE_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: Make the file immutable. File data can’t be updated (*write()* and *truncate()*)
    and metadata changes are prevented (e.g., *chmod()*, *chown()*, *unlink()*, *link()*,
    *rename()*, *rmdir()*, *utime()*, *setxattr()*, and *removexattr()*). Only privileged
    (`CAP_LINUX_IMMUTABLE`) processes can set this flag for a file. When this flag
    is set, even a privileged process can’t change the file contents or metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_JOURNAL_DATA_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable journaling of data. This flag is supported only on the *ext3* and *ext4*
    file systems. These file systems provide three levels of journaling: *journal*,
    *ordered*, and *writeback*. All modes journal updates to file metadata, but the
    *journal* mode additionally journals updates to file data. On a file system that
    is journaling in *ordered* or *writeback* mode, a privileged `(CAP_SYS_RESOURCE)`
    process can enable journaling of data updates on a per-file basis by setting this
    flag. (The *mount(8)* manual page describes the difference between the *ordered*
    and *writeback* modes.)'
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_NOATIME_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t update the file last access time when the file is accessed. This eliminates
    the need to update the file’s i-node each time the file is accessed, thus improving
    I/O performance (see the description of the `MS_NOATIME` flag in [Mounting a File
    System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open "Mounting
    a File System: mount()")).'
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_NODUMP_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t include this file in backups made using *dump(8)*. The effect of this
    flag is dependent on the *-h* option described in the *dump(8)* manual page.
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_NOTAIL_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: Disable tail packing. This flag is supported only on the *Reiserfs* file system.
    It disables the *Reiserfs* tail-packing feature, which tries to pack small files
    (and the final fragment of larger files) into the same disk block as the file
    metadata. Tail packing can also be disabled for an entire *Reiserfs* file system
    by mounting it with the *mount -o notail* option.
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_SECRM_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the file securely. The intended purpose of this unimplemented feature
    is that, when removed, a file is securely deleted, meaning that it is first overwritten
    to prevent a disk-scanning program from reading or re-creating it. (The issue
    of truly secure deletion is rather complex: it can actually require multiple writes
    on magnetic media to securely erase previously recorded data; see [Gutmann, 1996].)'
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_SYNC_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: Make file updates synchronous. When applied to files, this flag causes writes
    to the file to be synchronous (as though the `O_SYNC` flag was specified on all
    opens of this file). When applied to a directory, this flag has the same effect
    as the synchronous directory updates flag described above.
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_TOPDIR_FL` (since Linux 2.6)'
  prefs: []
  type: TYPE_NORMAL
- en: This marks a directory for special treatment under the *Orlov* block-allocation
    strategy. The Orlov strategy is a BSD-inspired modification of the *ext2* block-allocation
    strategy that tries to improve the chances that related files (e.g., the files
    within a single directory) are placed close to each other on disk, which can improve
    disk seek times. For details, see [Corbet, 2002] and [Kumar, et al. 2008]. `FS_TOPDIR_FL`
    has an effect only for *ext2* and its descendants, *ext3* and *ext4*.
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_UNRM_FL`'
  prefs: []
  type: TYPE_NORMAL
- en: Allow this file to be recovered (undeleted) if it is deleted. This feature is
    not implemented, since it is possible to implement file-recovery mechanisms outside
    the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, when i-node flags are set on a directory, they are automatically
    inherited by new files and subdirectories created in that directory. There are
    exceptions to this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FS_DIRSYNC_FL` (*chattr +D*) flag, which can be applied only to a directory,
    is inherited only by subdirectories created in that directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `FS_IMMUTABLE_FL` (*chattr +i*) flag is applied to a directory, it
    is not inherited by files and subdirectories created within that directory, since
    this flag prevents new entries being added to the directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within a program, i-node flags can be retrieved and modified using the *ioctl()*
    `FS_IOC_GETFLAGS` and `FS_IOC_SETFLAGS` operations. (These constants are defined
    in `<linux/fs.h>`.) The following code shows how to enable the `FS_NOATIME_FL`
    flag on the file referred to by the open file descriptor *fd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In order to change the i-node flags of a file, either the effective user ID
    of the process must match the user ID (owner) of the file, or the process must
    be privileged (`CAP_FOWNER`). (To be strictly accurate, on Linux, for an unprivileged
    process it is the process’s file-system user ID, rather than its effective user
    ID, that must match the user ID of the file, as described in Section 9.5.)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *stat()* system call retrieves information about a file (metadata), most
    of which is drawn from the file i-node. This information includes file ownership,
    file permissions, and file timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: A program can update a file’s last access time and last modification time using
    *utime()*, *utimes()*, and various similar interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each file has an associated user ID (owner) and group ID, as well as a set
    of permission bits. For permissions purposes, file users are divided into three
    categories: *owner* (also known as *user*), *group*, and *other*. Three permissions
    may be granted to each category of user: *read*, *write*, and *execute*. The same
    scheme is used with directories, although the permission bits have slightly different
    meanings. The *chown()* and *chmod()* system calls change the ownership and permissions
    of a file. The *umask()* system call sets a mask of permission bits that are always
    turned off when the calling process creates a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Three additional permission bits are used for files and directories. The set-user-ID
    and set-group-ID permission bits can be applied to program files to create programs
    that cause the executing process to gain privilege by assuming a different effective
    user or group identity (that of the program file). For directories residing on
    file systems mounted using the *nogrpid* (*sysvgroups*) option, the set-group-ID
    permission bit can be used to control whether new files created in the directory
    inherit their group ID from the process’s effective group ID or from the parent
    directory’s group ID. When applied to directories, the sticky permission bit acts
    as the restricted deletion flag.
  prefs: []
  type: TYPE_NORMAL
- en: I-node flags control the various behaviors of files and directories. Although
    originally defined for *ext2*, these flags are now supported on several other
    file systems.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[File Permissions](ch15.html#file_permissions "File Permissions") contained
    several statements about the permissions required for various file-system operations.
    Use shell commands or write programs to verify or answer the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing all owner permissions from a file denies the file owner access, even
    though group and other do have access.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On a directory with read permission but not execute permission, the names of
    files in the directory can be listed, but the files themselves can’t be accessed,
    regardless of the permissions on them.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What permissions are required on the parent directory and the file itself in
    order to create a new file, open a file for reading, open a file for writing,
    and delete a file? What permissions are required on the source and target directory
    to rename a file? If the target file of a rename operation already exists, what
    permissions are required on that file? How does setting the sticky permission
    bit (*chmod +t*) of a directory affect renaming and deletion operations?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you expect any of a file’s three timestamps to be changed by the *stat()*
    system call? If not, explain why.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a system running Linux 2.6, modify the program in [Example 15-1](ch15.html#retrieving_and_interpreting_file_stat_in
    "Example 15-1. Retrieving and interpreting file stat information") (`t_stat.c`)
    so that the file timestamps are displayed with nanosecond accuracy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *access()* system call checks permissions using the process’s real user
    and group IDs. Write a corresponding function that performs the checks according
    to the process’s effective user and group IDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As noted in [The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()"), *umask()* always sets the process
    umask and, at the same time, returns a copy of the old umask. How can we obtain
    a copy of the current process umask while leaving it unchanged?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *chmod a+rX file* command enables read permission for all categories of
    user, and likewise enables execute permission for all categories of user if *file*
    is a directory or execute permission is enabled for any of the user categories
    for *file*, as demonstrated in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a program that uses *stat()* and *chmod()* to perform the equivalent of
    *chmod a+rX*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a simple version of the *chattr(1)* command, which modifies file i-node
    flags. See the *chattr(1)* man page for details of the *chattr* command-line interface.
    (You don’t need to implement the *-R*, *-V*, and *-v* options.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
