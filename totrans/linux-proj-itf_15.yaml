- en: Chapter 15. File Attributes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章 文件属性
- en: In this chapter, we investigate various attributes of files (file metadata).
    We begin with a description of the *stat()* system call, which returns a structure
    containing many of these attributes, including file timestamps, file ownership,
    and file permissions. We then go on to look at various system calls used to change
    these attributes. (The discussion of file permissions continues in [Chapter 17](ch17.html
    "Chapter 17. Access Control Lists"), where we look at access control lists.) We
    conclude the chapter with a discussion of i-node flags (also known as *ext2* extended
    file attributes), which control various aspects of the treatment of files by the
    kernel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究文件的各种属性（文件元数据）。我们首先介绍*stat()*系统调用，它返回一个包含许多这些属性的结构体，包括文件时间戳、文件所有权和文件权限。接下来，我们讨论用于更改这些属性的各种系统调用。（关于文件权限的讨论将在[第17章](ch17.html
    "第17章：访问控制列表")中继续，那里我们将讨论访问控制列表。）本章的最后，我们讨论i节点标志（也称为*ext2*扩展文件属性），它们控制内核对文件的处理方式。
- en: 'Retrieving File Information: *stat()*'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取文件信息：*stat()*
- en: The *stat()*, *lstat()*, and *fstat()* system calls retrieve information about
    a file, mostly drawn from the file i-node.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*stat()*、*lstat()*和*fstat()*系统调用获取关于文件的信息，主要来自文件的i节点。'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All return 0 on success, or -1 on error
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数成功时返回0，出错时返回-1。
- en: 'These three system calls differ only in the way that the file is specified:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种系统调用仅在指定文件的方式上有所不同：
- en: '*stat()* returns information about a named file;'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*stat()*返回一个命名文件的信息；'
- en: '*lstat()* is similar to *stat()*, except that if the named file is a symbolic
    link, information about the link itself is returned, rather than the file to which
    the link points; and'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lstat()*与*stat()*类似，不同之处在于如果命名的文件是符号链接，则返回关于链接本身的信息，而不是链接指向的文件的信息；'
- en: '*fstat()* returns information about a file referred to by an open file descriptor.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fstat()*返回由打开的文件描述符引用的文件的信息。'
- en: The *stat()* and *lstat()* system calls don’t require permissions on the file
    itself. However, execute (search) permission is required on all of the parent
    directories specified in *pathname*. The *fstat()* system call always succeeds,
    if provided with a valid file descriptor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*stat()*和*lstat()*系统调用不需要对文件本身有权限。然而，*pathname*中指定的所有父目录都需要有执行（搜索）权限。*fstat()*系统调用在提供有效的文件描述符时始终成功。'
- en: 'All of these system calls return a *stat* structure in the buffer pointed to
    by *statbuf*. This structure has the following form:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些系统调用都在由*statbuf*指向的缓冲区中返回一个*stat*结构体。这个结构体的形式如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The various data types used to type the fields in the *stat* structure are all
    specified in SUSv3\. See [System Data Types](ch03.html#system_data_types "System
    Data Types") for further information about these types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义*stat*结构字段的数据类型在SUSv3中都有明确规定。有关这些类型的更多信息，请参见[系统数据类型](ch03.html#system_data_types
    "系统数据类型")。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to SUSv3, when *lstat()* is applied to a symbolic link, it needs to
    return valid information only in the *st_size* field and in the file type component
    (described shortly) of the *st_mode* field. None of other fields (e.g., the time
    fields) need contain valid information. This gives an implementation the freedom
    to not maintain these fields, which may be done for efficiency reasons. In particular,
    the intent of earlier UNIX standards was to allow a symbolic link to be implemented
    either as an i-node or as an entry in a directory. Under the latter implementation,
    it is not possible to implement all of the fields required by the *stat* structure.
    (On all major contemporary UNIX implementations, symbolic links are implemented
    as i-nodes. See [Symbolic (Soft) Links](ch18.html#symbolic_open_parenthesis_soft_close_par
    "Symbolic (Soft) Links") for further details.) On Linux, *lstat()* returns information
    in all of the *stat* fields when applied to a symbolic link.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SUSv3标准，当*lstat()*应用于符号链接时，它只需要在*st_size*字段和*st_mode*字段中的文件类型组件（稍后描述）返回有效信息。其他字段（例如时间字段）不需要包含有效信息。这使得实现可以自由选择不维护这些字段，出于效率考虑可能会这样做。特别地，早期UNIX标准的意图是允许符号链接作为i节点或目录条目实现。在后一种实现中，无法实现*stat*结构要求的所有字段。（在所有主要的现代UNIX实现中，符号链接作为i节点实现。有关更多细节，请参见[符号（软）链接](ch18.html#symbolic_open_parenthesis_soft_close_par
    "符号（软）链接")。）在Linux中，*lstat()*在应用于符号链接时返回所有*stat*字段的信息。
- en: In the following pages, we look at some of the *stat* structure fields in more
    detail, and finish with an example program that displays the entire *stat* structure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，我们将更详细地查看一些 *stat* 结构字段，并以一个示例程序结束，显示整个 *stat* 结构。
- en: Device IDs and i-node number
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设备 ID 和 i-node 号
- en: The *st_dev* field identifies the device on which the file resides. The *st_ino*
    field contains the i-node number of the file. The combination of *st_dev* and
    *st_ino* uniquely identifies a file across all file systems. The *dev_t* type
    records the major and minor IDs of a device ([Device Special Files (Devices)](ch14.html#device_special_files_open_parenthesis_de
    "Device Special Files (Devices)")).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_dev* 字段标识文件所在的设备。*st_ino* 字段包含文件的 i-node 号。*st_dev* 和 *st_ino* 的组合唯一标识一个文件，在所有文件系统中都有效。*dev_t*
    类型记录设备的主次设备 ID（[设备特殊文件（设备）](ch14.html#device_special_files_open_parenthesis_de
    "设备特殊文件（设备）")）。'
- en: If this is the i-node for a device, then the *st_rdev* field contains the major
    and minor IDs of the device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个设备的 i-node，那么 *st_rdev* 字段包含该设备的主次设备 ID。
- en: 'The major and minor IDs of a *dev_t* value can be extracted using two macros:
    `major()` and `minor()`. The header file required to obtain the declarations of
    these two macros varies across UNIX implementations. On Linux, they are exposed
    by `<sys/types.h>` if the `_BSD_SOURCE` macro is defined.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两个宏：`major()` 和 `minor()` 来提取 *dev_t* 值的主次设备 ID。获取这两个宏声明的头文件在不同的 UNIX 实现中有所不同。在
    Linux 中，如果定义了 `_BSD_SOURCE` 宏，则它们由 `<sys/types.h>` 提供。
- en: The size of the integer values returned by `major()` and `minor()` varies across
    UNIX implementations. For portability, we always cast the returned values to *long*
    when printing them (see [System Data Types](ch03.html#system_data_types "System
    Data Types")).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`major()` 和 `minor()` 返回的整数值在不同的 UNIX 实现中大小不同。为了移植性，我们始终将返回值强制转换为 *long* 类型进行打印（参见
    [系统数据类型](ch03.html#system_data_types "系统数据类型")）。'
- en: File ownership
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件所有权
- en: The *st_uid* and *st_gid* fields identify, respectively, the owner (user ID)
    and group (group ID) to which the file belongs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_uid* 和 *st_gid* 字段分别标识文件的所有者（用户 ID）和所属组（组 ID）。'
- en: Link count
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接计数
- en: The *st_nlink* field is the number of (hard) links to the file. We describe
    links in detail in [Chapter 18](ch18.html "Chapter 18. Directories and Links").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_nlink* 字段是指向该文件的（硬）链接数。我们在 [第 18 章](ch18.html "第 18 章. 目录和链接") 中详细描述了链接。'
- en: File type and permissions
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件类型和权限
- en: The *st_mode* field is a bit mask serving the dual purpose of identifying the
    file type and specifying the file permissions. The bits of this field are laid
    out as shown in [Figure 15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "Figure 15-1. Layout of st_mode bit mask").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_mode* 字段是一个位掩码，具有双重功能：识别文件类型和指定文件权限。该字段的位布局如 [图 15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "图 15-1. st_mode 位掩码的布局") 所示。'
- en: '![Layout of st_mode bit mask](figs/web/15-1_FILES-st_mode.png.jpg)Figure 15-1. Layout
    of *st_mode* bit mask'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![st_mode 位掩码的布局](figs/web/15-1_FILES-st_mode.png.jpg)图 15-1. *st_mode* 位掩码的布局'
- en: 'The file type can be extracted from this field by ANDing (`&`) with the constant
    `S_IFMT`. (On Linux, 4 bits are used for the file-type component of the *st_mode*
    field. However, because SUSv3 makes no specification about how the file type is
    represented, this detail may vary across implementations.) The resulting value
    can then be compared with a range of constants to determine the file type, like
    so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型可以通过与常量 `S_IFMT` 进行与（`&`）运算从该字段提取出来。（在 Linux 上，*st_mode* 字段的文件类型部分使用 4 位。然而，由于
    SUSv3 没有规定文件类型的表示方式，因此此细节可能在不同实现中有所不同。）然后，可以将得到的值与一系列常量进行比较，以确定文件类型，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Because this is a common operation, standard macros are provided to simplify
    the above to the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个常见操作，提供了标准宏来简化上述内容，简化为以下内容：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full set of file-type macros (defined in `<sys/stat.h>`) is shown in [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "Table 15-1. Macros for checking file types in the st_mode field of the stat structure").
    All of the file-type macros in [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "Table 15-1. Macros for checking file types in the st_mode field of the stat structure")
    are specified in SUSv3 and appear on Linux. Some other UNIX implementations define
    additional file types (e.g., `S_IFDOOR`, for door files on Solaris). The type
    `S_IFLNK` is returned only by calls to *lstat()*, since calls to *stat()* always
    follow symbolic links.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件类型宏集合（定义在`<sys/stat.h>`中）见[表15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "表15-1. 用于检查stat结构体的st_mode字段中文件类型的宏")。所有在[表15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "表15-1. 用于检查stat结构体的st_mode字段中文件类型的宏")中的文件类型宏都在SUSv3中有规定，并且在Linux上出现。一些其他的UNIX实现定义了额外的文件类型（例如，`S_IFDOOR`，用于Solaris上的门文件）。类型`S_IFLNK`仅通过调用*lstat()*返回，因为调用*stat()*总是会遵循符号链接。
- en: The original POSIX.1 standard did not specify the constants shown in the first
    column of [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st "Table 15-1. Macros
    for checking file types in the st_mode field of the stat structure"), although
    most of them appeared on most UNIX implementations. SUSv3 requires these constants.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的POSIX.1标准并没有指定[表15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "表15-1. 用于检查stat结构体的st_mode字段中文件类型的宏")中第一列所示的常量，尽管它们大多数在大多数UNIX实现中都有出现。SUSv3要求这些常量。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to obtain the definitions of `S_IFSOCK` and `S_ISSOCK()` from `<sys/stat.h>`,
    we must either define the `_BSD_SOURCE` feature test macro or define `_XOPEN_SOURCE`
    with a value greater than or equal to 500\. (The rules have varied somewhat across
    *glibc* versions: in some cases, `_XOPEN_SOURCE` must be defined with a value
    of 600 or greater.)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`<sys/stat.h>`中获取`S_IFSOCK`和`S_ISSOCK()`的定义，我们必须定义`_BSD_SOURCE`特性测试宏，或者定义`_XOPEN_SOURCE`并设置其值大于或等于500。（这些规则在不同的*glibc*版本中略有不同：在某些情况下，`_XOPEN_SOURCE`必须定义为600或更大值。）
- en: Table 15-1. Macros for checking file types in the *st_mode* field of the *stat*
    structure
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表15-1. 用于检查*stat*结构体的*st_mode*字段中文件类型的宏
- en: '| Constant | Test macro | File type |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 测试宏 | 文件类型 |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `S_IFREG` | `S_ISREG()` | Regular file |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `S_IFREG` | `S_ISREG()` | 常规文件 |'
- en: '| `S_IFDIR` | `S_ISDIR()` | Directory |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `S_IFDIR` | `S_ISDIR()` | 目录 |'
- en: '| `S_IFCHR` | `S_ISCHR()` | Character device |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `S_IFCHR` | `S_ISCHR()` | 字符设备 |'
- en: '| `S_IFBLK` | `S_ISBLK()` | Block device |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `S_IFBLK` | `S_ISBLK()` | 块设备 |'
- en: '| `S_IFIFO` | `S_ISFIFO()` | FIFO or pipe |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `S_IFIFO` | `S_ISFIFO()` | FIFO或管道 |'
- en: '| `S_IFSOCK` | `S_ISSOCK()` | Socket |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `S_IFSOCK` | `S_ISSOCK()` | 套接字 |'
- en: '| `S_IFLNK` | `S_ISLNK()` | Symbolic link |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `S_IFLNK` | `S_ISLNK()` | 符号链接 |'
- en: The bottom 12 bits of the *st_mode* field define the permissions for the file.
    We describe the file permission bits in Section 15.4\. For now, we simply note
    that the 9 least significant of the permission bits are the read, write, and execute
    permissions for each of the categories owner, group, and other.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_mode*字段的最低12位定义了文件的权限。我们在第15.4节中描述了文件权限位。目前，我们只需注意，权限位中的9个位是每个类别（所有者、组和其他）的读、写和执行权限。'
- en: File size, blocks allocated, and optimal I/O block size
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件大小、分配的块数和最佳I/O块大小
- en: For regular files, the *st_size* field is the total size of the file in bytes.
    For a symbolic link, this field contains the length (in bytes) of the pathname
    pointed to by the link. For a shared memory object ([Chapter 54](ch54.html "Chapter 54. POSIX
    Shared Memory")), this field contains the size of the object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规文件，*st_size*字段是文件的总大小，以字节为单位。对于符号链接，该字段包含链接指向的路径名的长度（以字节为单位）。对于共享内存对象（[第54章](ch54.html
    "第54章. POSIX共享内存")），该字段包含对象的大小。
- en: The *st_blocks* field indicates the total number of blocks allocated to the
    file, in 512-byte block units. This total includes space allocated for pointer
    blocks (see [Figure 14-2](ch14.html#structure_of_file_blocks_for_a_file_in_a "Figure 14-2. Structure
    of file blocks for a file in an ext2 file system"), in [I-nodes and data block
    pointers in *ext2*](ch14.html#i-nodes_and_data_block_pointers_in-id1 "I-nodes
    and data block pointers in ext2")). The choice of the 512-byte unit of measurement
    is historical—this is the smallest block size on any of the file systems that
    have been implemented under UNIX. More modern file systems use larger logical
    block sizes. For example, under *ext2*, the value in *st_blocks* is always a multiple
    of 2, 4, or 8, depending on whether the *ext2* logical block size is 1024, 2048,
    or 4096 bytes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_blocks*字段表示分配给文件的总块数，单位为512字节的块。这个总数包括为指针块分配的空间（参见[图14-2](ch14.html#structure_of_file_blocks_for_a_file_in_a
    "Figure 14-2. Structure of file blocks for a file in an ext2 file system"), 在[I节点和*ext2*中的数据块指针](ch14.html#i-nodes_and_data_block_pointers_in-id1
    "I-nodes and data block pointers in ext2")）。选择512字节作为度量单位是出于历史原因——这是UNIX下所有实现的文件系统中最小的块大小。现代文件系统使用更大的逻辑块大小。例如，在*ext2*下，*st_blocks*中的值始终是2、4或8的倍数，具体取决于*ext2*逻辑块大小是1024、2048还是4096字节。'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 doesn’t define the units in which *st_blocks* is measured, allowing the
    possibility that an implementation uses a unit other than 512 bytes. Most UNIX
    implementations do use 512-byte units, but HP-UX 11 uses file system–specific
    units (e.g., 1024 bytes in some cases).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3没有定义*st_blocks*的度量单位，这使得实现可能使用除512字节以外的其他单位。大多数UNIX实现使用512字节单位，但HP-UX 11使用特定于文件系统的单位（例如，在某些情况下为1024字节）。
- en: 'The *st_blocks* field records the number of disk blocks actually allocated.
    If the file contains holes ([Changing the File Offset: *lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()")), this will be smaller than might be expected
    from the corresponding number of bytes *(st_size)* in the file. (The disk usage
    command, *du -k file*, displays the actual space allocated for a file, in kilobytes;
    that is, a figure calculated from the *st_blocks* value for the file, rather than
    the *st_size* value.)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_blocks*字段记录了实际分配的磁盘块数量。如果文件包含空洞（[更改文件偏移量：*lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()")），那么此值将小于文件中对应字节数*(st_size)*的预期值。（磁盘使用命令，*du
    -k file*，显示文件实际分配的空间，以千字节为单位；也就是说，这是根据文件的*st_blocks*值计算出来的，而不是*st_size*值。）'
- en: 'The *st_blksize* field is somewhat misleadingly named. It is not the block
    size of the underlying file system, but rather the optimal block size (in bytes)
    for I/O on files on this file system. I/O in blocks smaller than this size is
    less efficient (refer to [Kernel Buffering of File I/O: The Buffer Cache](ch13.html#kernel_buffering_of_file_i_solidus_o_col
    "Kernel Buffering of File I/O: The Buffer Cache")). A typical value returned in
    *st_blksize* is 4096.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_blksize*字段的名称有些误导。它不是底层文件系统的块大小，而是该文件系统上文件I/O的最佳块大小（以字节为单位）。I/O操作如果使用比此值更小的块，将效率较低（参考[内核文件I/O缓冲：缓冲区缓存](ch13.html#kernel_buffering_of_file_i_solidus_o_col
    "Kernel Buffering of File I/O: The Buffer Cache")）。*st_blksize*返回的典型值为4096。'
- en: File timestamps
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件时间戳
- en: The *st_atime*, *st_mtime*, and *st_ctime* fields contain, respectively, the
    times of last file access, last file modification, and last status change. These
    fields are of type *time_t*, the standard UNIX time format of seconds since the
    Epoch. We say more about these fields in Section 15.2.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*st_atime*、*st_mtime*和*st_ctime*字段分别包含最后访问文件、最后修改文件和最后状态更改的时间。这些字段的类型是*time_t*，即UNIX标准时间格式，表示自纪元以来的秒数。我们将在15.2节中进一步介绍这些字段。'
- en: Example program
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 15-1](ch15.html#retrieving_and_interpreting_file_stat_in
    "Example 15-1. Retrieving and interpreting file stat information") uses *stat()*
    to retrieve information about the file named on its command line. If the *-l*
    command-line option is specified, then the program instead uses *lstat()* so that
    we can retrieve information about a symbolic link instead of the file to which
    it refers. The program prints all fields of the returned *stat* structure. (For
    an explanation of why we cast the *st_size* and *st_blocks* fields to *long long*,
    see [I/O on Large Files](ch05.html#i_solidus_o_on_large_files "I/O on Large Files").)
    The *filePermStr()* function used by this program is shown in [Example 15-4](ch15.html#convert_file_permissions_mask_to_string
    "Example 15-4. Convert file permissions mask to string"), in [Permissions on Directories](ch15.html#permissions_on_directories
    "Permissions on Directories").
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-1](ch15.html#retrieving_and_interpreting_file_stat_in "示例 15-1. 获取和解释文件
    stat 信息") 中的程序使用 *stat()* 来检索命令行中指定的文件信息。如果指定了 *-l* 命令行选项，则程序改用 *lstat()*，这样我们可以检索符号链接的信息，而不是它所指向的文件信息。程序打印返回的
    *stat* 结构的所有字段。（关于为何将 *st_size* 和 *st_blocks* 字段强制转换为 *long long* 类型的解释，请参见 [大文件的
    I/O](ch05.html#i_solidus_o_on_large_files "大文件的 I/O")）。该程序使用的 *filePermStr()*
    函数展示于 [示例 15-4](ch15.html#convert_file_permissions_mask_to_string "示例 15-4. 将文件权限掩码转换为字符串")，在
    [目录权限](ch15.html#permissions_on_directories "目录权限")中也有展示。'
- en: 'Here is an example of the use of the program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是该程序的使用示例：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 15-1. Retrieving and interpreting file *stat* information
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-1. 获取和解释文件 *stat* 信息
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: File Timestamps
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件时间戳
- en: The *st_atime*, *st_mtime*, and *st_ctime* fields of the *stat* structure contain
    file timestamps. These fields record, respectively, the times of last file access,
    last file modification, and last file status change (i.e., last change to the
    file’s i-node information). Timestamps are recorded in seconds since the Epoch
    (1 January 1970; see [Calendar Time](ch10.html#calendar_time "Calendar Time")).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*stat* 结构中的 *st_atime*、*st_mtime* 和 *st_ctime* 字段包含文件时间戳。这些字段分别记录了文件的最后访问时间、最后修改时间和最后状态更改时间（即文件的
    i-node 信息最后一次修改时间）。时间戳以自纪元（1970年1月1日；参见 [日历时间](ch10.html#calendar_time "日历时间")）以来的秒数记录。'
- en: Most native Linux and UNIX file systems support all of the timestamp fields,
    but some non-UNIX file systems may not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数本地 Linux 和 UNIX 文件系统都支持所有时间戳字段，但一些非 UNIX 文件系统可能不支持。
- en: '[Table 15-2](ch15.html#effect_of_various_functions_on_file_time "Table 15-2. Effect
    of various functions on file timestamps") summarizes which of the timestamp fields
    (and in some cases, the analogous fields in the parent directory) are changed
    by various system calls and library functions described in this book. In the headings
    of this table, *a*, *m*, and *c* represent the *st_atime*, *st_mtime*, and *st_ctime*
    fields, respectively. In most cases, the relevant timestamp is set to the current
    time by the system call. The exceptions are *utime()* and similar calls (discussed
    in [Nanosecond timestamps](ch15.html#nanosecond_timestamps-id1 "Nanosecond timestamps")
    and [Changing File Timestamps with *utime()* and *utimes()*](ch15.html#changing_file_timestamps_with_utime_open
    "Changing File Timestamps with utime() and utimes()")), which can be used to explicitly
    set the last file access and modification times to arbitrary values.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-2](ch15.html#effect_of_various_functions_on_file_time "表 15-2. 各种函数对文件时间戳的影响")
    总结了哪些时间戳字段（以及在某些情况下，父目录中的类似字段）会被本书中描述的各种系统调用和库函数所更改。在此表的标题中，*a*、*m* 和 *c* 分别代表
    *st_atime*、*st_mtime* 和 *st_ctime* 字段。在大多数情况下，相关时间戳会被系统调用设置为当前时间。例外情况是 *utime()*
    和类似的调用（讨论见 [纳秒时间戳](ch15.html#nanosecond_timestamps-id1 "纳秒时间戳") 和 [使用 *utime()*
    和 *utimes()* 更改文件时间戳](ch15.html#changing_file_timestamps_with_utime_open "使用 utime()
    和 utimes() 更改文件时间戳")），这些调用可以用来显式地将文件的最后访问时间和修改时间设置为任意值。'
- en: Table 15-2. Effect of various functions on file timestamps
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-2. 各种函数对文件时间戳的影响
- en: '| Function | File or directory | Parent directory | Notes |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 文件或目录 | 父目录 | 备注 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| a | m | c | a | m | c |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| a | m | c | a | m | c |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *chmod()* |   |   | • |   |   |   | Same for *fchmod()* |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| *chmod()* |   |   | • |   |   |   | 同样适用于 *fchmod()* |'
- en: '| *chown()* |   |   | • |   |   |   | Same for *lchown()* and *fchown()* |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| *chown()* |   |   | • |   |   |   | 同样适用于 *lchown()* 和 *fchown()* |'
- en: '| *exec()* | • |   |   |   |   |   |   |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| *exec()* | • |   |   |   |   |   |   |'
- en: '| *link()* |   |   | • |   | • | • | Affects parent directory of second argument
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| *link()* |   |   | • |   | • | • | 影响第二个参数的父目录 |'
- en: '| *mkdir()* | • | • | • |   | • | • |   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| *mkdir()* | • | • | • |   | • | • |   |'
- en: '| *mkfifo()* | • | • | • |   | • | • |   |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| *mkfifo()* | • | • | • |   | • | • |   |'
- en: '| *mknod()* | • | • | • |   | • | • |   |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| *mknod()* | • | • | • |   | • | • |   |'
- en: '| *mmap()* | • | • | • |   |   |   | *st_mtime* and *st_ctime* are changed
    only on updates to `MAP_SHARED` mapping |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| *mmap()* | • | • | • |   |   |   | 只有在更新 `MAP_SHARED` 映射时，*st_mtime* 和 *st_ctime*
    才会改变 |'
- en: '| *msync()* |   | • | • |   |   |   | Changed only if file is modified |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| *msync()* |   | • | • |   |   |   | 只有在文件被修改时才会发生变化 |'
- en: '| *open()*, *creat()* | • | • | • |   | • | • | When creating new file |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| *open()*, *creat()* | • | • | • |   | • | • | 创建新文件时 |'
- en: '| *open()*, *creat()* |   | • | • |   |   |   | When truncating existing file
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| *open()*, *creat()* |   | • | • |   |   |   | 当截断现有文件时 |'
- en: '| *pipe()* | • | • | • |   |   |   |   |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| *pipe()* | • | • | • |   |   |   |   |'
- en: '| *read()* | • |   |   |   |   |   | Same for *readv()*, *pread()*, and *preadv()*
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| *read()* | • |   |   |   |   |   | 同样适用于 *readv()*, *pread()*, 和 *preadv()*
    |'
- en: '| *readdir()* | • |   |   |   |   |   | readdir() may buffer directory entries;
    timestamps updated only if directory is read |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| *readdir()* | • |   |   |   |   |   | readdir() 可能会缓存目录条目；只有在读取目录时才会更新时间戳
    |'
- en: '| *removexattr()* |   |   | • |   |   |   | Same for *fremovexattr()* and *lremovexattr()*
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| *removexattr()* |   |   | • |   |   |   | 同样适用于 *fremovexattr()* 和 *lremovexattr()*
    |'
- en: '| *rename()* |   |   | • |   | • | • | Affects timestamps in both parent directories;
    SUSv3 doesn’t specify file *st_ctime* change, but notes that some implementations
    do this |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| *rename()* |   |   | • |   | • | • | 影响父目录中的时间戳；SUSv3 没有指定文件 *st_ctime* 变化，但指出某些实现会这么做
    |'
- en: '| *rmdir()* |   |   |   |   | • | • | Same for *remove(directory)* |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| *rmdir()* |   |   |   |   | • | • | 同样适用于 *remove(directory)* |'
- en: '| *sendfile()* | • |   |   |   |   |   | Timestamp changed for input file |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| *sendfile()* | • |   |   |   |   |   | 输入文件的时间戳已更改 |'
- en: '| *setxattr()* |   |   | • |   |   |   | Same for *fsetxattr()* and *lsetxattr()*
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| *setxattr()* |   |   | • |   |   |   | 同样适用于 *fsetxattr()* 和 *lsetxattr()*
    |'
- en: '| *symlink()* | • | • | • |   | • | • | Sets timestamps of link (not target
    file) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| *symlink()* | • | • | • |   | • | • | 设置的是符号链接的时间戳（而不是目标文件） |'
- en: '| *truncate()* |   | • | • |   |   |   | Same for *ftruncate()*; timestamps
    change only if file size changes |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| *truncate()* |   | • | • |   |   |   | 同样适用于 *ftruncate()*；只有在文件大小发生变化时，时间戳才会更改
    |'
- en: '| *unlink()* |   |   | • |   | • | • | Same for *remove(file)*; file *st_ctime*
    changes if previous link count was > 1 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| *unlink()* |   |   | • |   | • | • | 同样适用于 *remove(file)*；如果先前的链接计数大于 1，则文件
    *st_ctime* 会发生变化 |'
- en: '| *utime()* | • | • | • |   |   |   | Same for *utimes()*, *futimes()*, *futimens()*,
    *lutimes()*, and *utimensat()* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| *utime()* | • | • | • |   |   |   | 同样适用于 *utimes()*, *futimes()*, *futimens()*,
    *lutimes()*, 和 *utimensat()* |'
- en: '| *write()* |   | • | • |   |   |   | Same for *writev()*, *pwrite()*, and
    *pwritev()* |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| *write()* |   | • | • |   |   |   | 同样适用于 *writev()*, *pwrite()*, 和 *pwritev()*
    |'
- en: 'In [Mounting a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()") and [I-node Flags (*ext2* Extended File Attributes)](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I-node Flags (ext2 Extended File Attributes)"), we describe *mount(2)* options
    and per-file flags that prevent updates to the last access time of a file. The
    *open()* `O_NOATIME` flag described in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()") also serves a similar purpose. In
    some applications, this can be useful for performance reasons, since it reduces
    the number of disk operations that are required when a file is accessed.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [挂载文件系统: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open "挂载文件系统:
    mount()") 和 [I节点标志 (*ext2* 扩展文件属性)](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I节点标志 (ext2 扩展文件属性)") 中，我们描述了 *mount(2)* 选项和每个文件标志，这些选项和标志防止更新文件的最后访问时间。 [文件描述符号由
    *open()* 返回](ch04.html#file_descriptor_number_returned_by-id1 "文件描述符号由 open()
    返回") 中描述的 *open()* `O_NOATIME` 标志也有类似的作用。在一些应用中，这对性能有帮助，因为它减少了文件访问时所需的磁盘操作次数。'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although most UNIX systems don’t record the creation time of a file, on recent
    BSD systems, this time is recorded in a *stat* field named *st_birthtime*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数 UNIX 系统不会记录文件的创建时间，但在最近的 BSD 系统中，这个时间会记录在一个名为 *st_birthtime* 的 *stat*
    字段中。
- en: Nanosecond timestamps
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 纳秒时间戳
- en: With version 2.6, Linux supports nanosecond resolution for the three timestamp
    fields of the *stat* structure. Nanosecond resolution improves the accuracy of
    programs that need to make decisions based on the relative order of file timestamps
    (e.g., *make(1)*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.6 开始，Linux 支持 *stat* 结构中三个时间戳字段的纳秒分辨率。纳秒分辨率提高了需要基于文件时间戳相对顺序做出决策的程序的准确性（例如，*make(1)*）。
- en: SUSv3 doesn’t specify nanosecond timestamps for the *stat* structure, but SUSv4
    adds this specification.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 并没有为 *stat* 结构指定纳秒时间戳，但 SUSv4 添加了这一规范。
- en: Not all file systems support nanosecond timestamps. *JFS*, *XFS*, *ext4*, and
    *Btrfs* do, but *ext2*, *ext3*, and *Reiserfs* do not.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有文件系统都支持纳秒时间戳。*JFS*、*XFS*、*ext4* 和 *Btrfs* 支持，但 *ext2*、*ext3* 和 *Reiserfs*
    不支持。
- en: Under the *glibc* API (since version 2.3), the timestamp fields are each defined
    as a *timespec* structure (we describe this structure when we discuss *utimensat()*
    later in this section), which represents a time in seconds and nanoseconds components.
    Suitable macro definitions make the seconds component of these structures visible
    using the traditional field names (*st_atime*, *st_mtime*, and *st_ctime*). The
    nanosecond components can be accessed using field names such *st_atim.tv_nsec*,
    for the nanosecond component of the last file access time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *glibc* API（自 2.3 版本起）下，时间戳字段被定义为 *timespec* 结构（当我们讨论 *utimensat()* 时会介绍此结构），该结构表示秒和纳秒组件的时间。合适的宏定义使得这些结构的秒组件可以通过传统的字段名称（*st_atime*、*st_mtime*
    和 *st_ctime*）显示。纳秒组件可以通过如 *st_atim.tv_nsec* 这样的字段名访问，用于表示最后文件访问时间的纳秒部分。
- en: Changing File Timestamps with *utime()* and *utimes()*
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 *utime()* 和 *utimes()* 修改文件时间戳
- en: The last file access and modification timestamps stored in a file i-node can
    be explicitly changed using *utime()* or one of a related set of system calls.
    Programs such as *tar(1)* and *unzip(1)* use these system calls to reset file
    timestamps when unpacking an archive.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在文件 i 节点中的最后文件访问和修改时间戳可以通过 *utime()* 或一组相关的系统调用显式更改。像 *tar(1)* 和 *unzip(1)*
    这样的程序使用这些系统调用在解压档案时重置文件时间戳。
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Returns 0 on success, or -1 on error
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'The *pathname* argument identifies the file whose times we wish to modify.
    If *pathname* is a symbolic link, it is dereferenced. The *buf* argument can be
    either `NULL` or a pointer to a *utimbuf* structure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*pathname* 参数用于指定我们希望修改时间的文件。如果 *pathname* 是一个符号链接，它会被解除引用。*buf* 参数可以是 `NULL`
    或指向 *utimbuf* 结构的指针：'
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fields in this structure measure time in seconds since the Epoch ([Calendar
    Time](ch10.html#calendar_time "Calendar Time")).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构中的字段以自纪元（[日历时间](ch10.html#calendar_time "Calendar Time")）以来的秒数来表示时间。
- en: 'Two different cases determine how *utime()* works:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同的情况决定了 *utime()* 的工作方式：
- en: If *buf* is specified as `NULL`, then both the last access and the last modification
    times are set to the current time. In this case, either the effective user ID
    of the process must match the file’s user ID (owner), the process must have write
    permission on the file (logical, since a process with write permission on a file
    could employ other system calls that would have the side effect of changing these
    file timestamps), or the process must be privileged (`CAP_FOWNER` or `CAP_DAC_OVERRIDE`).
    (To be accurate, on Linux, it is the process’s file-system user ID, rather than
    its effective user ID, that is checked against the file’s user ID, as described
    in Section 9.5.)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *buf* 被指定为 `NULL`，则将最后的访问时间和最后的修改时间都设置为当前时间。在这种情况下，进程的有效用户 ID 必须与文件的用户 ID（所有者）匹配，进程必须具有文件的写权限（这是合乎逻辑的，因为一个拥有文件写权限的进程可以使用其他系统调用来间接修改这些文件时间戳），或者进程必须具备特权（`CAP_FOWNER`
    或 `CAP_DAC_OVERRIDE`）。 （准确来说，在 Linux 上，检查的是进程的文件系统用户 ID，而不是有效用户 ID，如第 9.5 节所述。）
- en: If *buf* is specified as pointer to a *utimbuf* structure, then the last file
    access and modification times are updated using the corresponding fields of this
    structure. In this case, the effective user ID of the process must match the file’s
    user ID (having write permission on the file is not sufficient) or the caller
    must be privileged (`CAP_FOWNER`).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *buf* 被指定为指向 *utimbuf* 结构的指针，则使用该结构的相应字段更新最后的文件访问时间和修改时间。在这种情况下，进程的有效用户 ID
    必须与文件的用户 ID 匹配（仅具有写权限是不够的），或者调用者必须具备特权（`CAP_FOWNER`）。
- en: 'To change just one of the file timestamps, we first use *stat()* to retrieve
    both times, use one of these times to initialize the *utimbuf* structure, and
    then set the other as desired. This is demonstrated in the following code, which
    makes the last modification time of a file the same as the last access time:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 若要仅更改一个文件时间戳，首先使用 *stat()* 获取两个时间，然后用其中一个时间初始化 *utimbuf* 结构，再按需要设置另一个时间。以下代码演示了这一过程，它使文件的最后修改时间与最后访问时间相同：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A successful call to *utime()* always sets the last status change time to the
    current time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用 *utime()* 后，总是将最后的状态变化时间设置为当前时间。
- en: Linux also provides the BSD-derived *utimes()* system call, which performs a
    similar task to *utime()*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Linux还提供了BSD衍生的*utimes()*系统调用，它执行与*utime()*相似的任务。
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: The most notable difference between *utime()* and *utimes()* is that *utimes()*
    allows time values to be specified with microsecond accuracy (the *timeval* structure
    is described in [Calendar Time](ch10.html#calendar_time "Calendar Time")). This
    provides (partial) access to the nanosecond accuracy with which file timestamps
    are provided in Linux 2.6\. The new file access time is specified in *tv[0]*,
    and the new modification time is specified in *tv[1]*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*utime()*和*utimes()*之间最显著的区别在于，*utimes()*允许使用微秒精度指定时间值（*timeval*结构在[日历时间](ch10.html#calendar_time
    "Calendar Time")中描述）。这为Linux 2.6提供的纳秒精度文件时间戳提供了（部分）访问。新的文件访问时间在*tv[0]*中指定，新的修改时间在*tv[1]*中指定。'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An example of the use of *utimes()* is provided in the file `files/t_utimes.c`
    in the source code distribution for this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*utimes()*的示例在本书的源代码分发中的`files/t_utimes.c`文件中提供。
- en: The *futimes()* and *lutimes()* library functions perform a similar task to
    *utimes()*. They differ from *utimes()* in the argument used to specify the file
    whose timestamps are to be changed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*futimes()*和*lutimes()*库函数执行与*utimes()*相似的任务。它们与*utimes()*的不同之处在于用于指定要更改时间戳的文件的参数。'
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: With *futimes()*, the file is specified via an open file descriptor, *fd*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*futimes()*时，通过打开的文件描述符*fd*指定文件。
- en: With *lutimes()*, the file is specified via a pathname, with the difference
    from *utimes()* that if the pathname refers to a symbolic link, then the link
    is not dereferenced; instead, the timestamps of the link itself are changed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*lutimes()*时，通过路径名指定文件，区别在于与*utimes()*不同的是，如果路径名指向符号链接，则不会取消引用该链接；相反，链接本身的时间戳会被更改。
- en: The *futimes()* function is supported since *glibc* 2.3\. The *lutimes()* function
    is supported since *glibc* 2.6.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*futimes()*函数自*glibc* 2.3起支持。*lutimes()*函数自*glibc* 2.6起支持。'
- en: Changing File Timestamps with *utimensat()* and *futimens()*
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用*utimensat()*和*futimens()*更改文件时间戳
- en: 'The *utimensat()* system call (supported since kernel 2.6.22) and the *futimens()*
    library function (supported since *glibc* 2.6) provide extended functionality
    for setting a file’s last access and last modification timestamps. Among the advantages
    of these interfaces are the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*utimensat()*系统调用（自内核2.6.22起支持）和*futimens()*库函数（自*glibc* 2.6起支持）提供了设置文件最后访问时间和最后修改时间戳的扩展功能。以下是这些接口的一些优点：'
- en: We can set timestamps with nanosecond precision. This improves on the microsecond
    precision provided by *utimes()*.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以以纳秒精度设置时间戳。这比*utimes()*提供的微秒精度更精确。
- en: It is possible to set the timestamps independently (i.e., one at a time). As
    shown earlier, to change just one of the timestamps using the older interfaces,
    we must first call *stat()* to retrieve the value of the other timestamp, and
    then specify the retrieved value along with the timestamp whose value we want
    to change. (This could lead to a race condition if another process performed an
    operation that updated the timestamp between these two steps.)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以独立设置时间戳（即一次设置一个）。如前所述，要使用旧的接口只更改一个时间戳，我们必须首先调用*stat()*以检索另一个时间戳的值，然后指定检索到的值以及我们要更改的时间戳的值。（如果另一个进程在这两个步骤之间执行了一个更新时间戳的操作，这可能会导致竞态条件。）
- en: We can independently set either of the timestamps to the current time. To change
    just one timestamp to the current time with the older interfaces, we need to employ
    a call to *stat()* to retrieve the setting of the timestamp whose value we wish
    to leave unchanged, and a call to *gettimeofday()* to obtain the current time.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以独立设置任何一个时间戳为当前时间。要使用旧的接口仅将一个时间戳更改为当前时间，我们需要调用*stat()*以检索我们希望保留不变的时间戳的设置，并调用*gettimeofday()*来获取当前时间。
- en: These interfaces are not specified in SUSv3, but are included in SUSv4.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口未在SUSv3中指定，但在SUSv4中包含。
- en: The *utimensat()* system call updates the timestamps of the file specified by
    *pathname* to the values specified in the array *times*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*utimensat()*系统调用将指定路径*pathname*的文件时间戳更新为*times*数组中指定的值。'
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'If *times* is specified as `NULL`, then both file timestamps are updated to
    the current time. If *times* is not `NULL`, then the new last access timestamp
    is specified in *times[0]* and the new last modification timestamp is specified
    in *times[1]*. Each of the elements of the array *times* is a structure of the
    following form:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *times* 被指定为 `NULL`，则两个文件时间戳都会更新为当前时间。如果 *times* 不是 `NULL`，则新的最后访问时间戳在 *times[0]*
    中指定，新的最后修改时间戳在 *times[1]* 中指定。数组 *times* 的每个元素都是以下形式的结构：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The fields in this structure specify a time in seconds and nanoseconds since
    the Epoch ([Calendar Time](ch10.html#calendar_time "Calendar Time")).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构中的字段指定自纪元以来的秒数和纳秒数（见 [日历时间](ch10.html#calendar_time "Calendar Time")）。
- en: To set one of the timestamps to the current time, we specify the special value
    `UTIME_NOW` in the corresponding *tv_nsec* field. To leave one of the timestamps
    unchanged, we specify the special value `UTIME_OMIT` in the corresponding *tv_nsec*
    field. In both cases, the value in the corresponding *tv_sec* field is ignored.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其中一个时间戳设置为当前时间，我们在相应的 *tv_nsec* 字段中指定特殊值 `UTIME_NOW`。要保持其中一个时间戳不变，我们在相应的 *tv_nsec*
    字段中指定特殊值 `UTIME_OMIT`。在这两种情况下，相应的 *tv_sec* 字段中的值将被忽略。
- en: The *dirfd* argument can either specify `AT_FDCWD`, in which case the *pathname*
    argument is interpreted as for *utimes()*, or it can specify a file descriptor
    referring to a directory. The purpose of the latter choice is described in [Operating
    Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*dirfd* 参数可以指定 `AT_FDCWD`，此时 *pathname* 参数的解释方式与 *utimes()* 相同，或者它可以指定一个指向目录的文件描述符。后一种选择的目的在于
    [相对于目录文件描述符操作](ch18.html#operating_relative_to_a_directory_file_d "Operating Relative
    to a Directory File Descriptor") 中有所描述。'
- en: The *flags* argument can be either 0, or `AT_SYMLINK_NOFOLLOW`, meaning that
    *pathname* should not be dereferenced if it is a symbolic link (i.e., the timestamps
    of the symbolic link itself should be changed). By contrast, *utimes()* always
    dereferences symbolic links.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数可以是 0，或者是 `AT_SYMLINK_NOFOLLOW`，表示如果 *pathname* 是符号链接，则不应取消引用它（即，应更改符号链接本身的时间戳）。与此相对，*utimes()*
    总是取消引用符号链接。'
- en: 'The following code segment sets the last access time to the current time and
    leaves the last modification time unchanged:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段将最后的访问时间设置为当前时间，而不改变最后的修改时间：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The permission rules for changing timestamps with *utimensat()* (and *futimens()*)
    are similar to those for the older APIs, and are detailed in the *utimensat(2)*
    manual page.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *utimensat()*（和 *futimens()*）更改时间戳的权限规则与旧的 API 相似，详细信息请参见 *utimensat(2)*
    手册页面。
- en: The *futimens()* library function updates the timestamps of the file referred
    to by the open file descriptor *fd*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*futimens()* 库函数更新由打开文件描述符 *fd* 引用的文件的时间戳。'
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: The *times* argument of *futimens()* is used in the same way as for *utimensat()*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*futimens()* 的 *times* 参数使用方式与 *utimensat()* 相同。'
- en: File Ownership
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件所有权
- en: Each file has an associated user ID (UID) and group ID (GID). These IDs determine
    which user and group the file belongs to. We now look at the rules that determine
    the ownership of new files and describe the system calls used to change a file’s
    ownership.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都有一个关联的用户 ID（UID）和组 ID（GID）。这些 ID 决定了文件属于哪个用户和组。接下来我们将讨论确定新文件所有权的规则，并描述用于更改文件所有权的系统调用。
- en: Ownership of New Files
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新文件的所有权
- en: When a new file is created, its user ID is taken from the effective user ID
    of the process. The group ID of the new file may be taken from either the effective
    group ID of the process (equivalent to the System V default behavior) or the group
    ID of the parent directory (the BSD behavior). The latter possibility is useful
    for creating project directories in which all files belong to a particular group
    and are accessible to the members of that group. Which of the two values is used
    as the new file’s group ID is determined by various factors, including the type
    of file system on which the new file is created. We begin by describing the rules
    followed by *ext2* and a few other file systems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当新文件创建时，它的用户 ID 来自进程的有效用户 ID。新文件的组 ID 可以来自进程的有效组 ID（相当于 System V 的默认行为），或者来自父目录的组
    ID（BSD 行为）。后一种情况对于创建项目目录很有用，在这些目录中所有文件都属于一个特定组，并且该组的成员可以访问这些文件。哪个值被用作新文件的组 ID
    由多个因素决定，包括新文件所在的文件系统类型。我们从描述 *ext2* 及其他一些文件系统的规则开始。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be accurate, on Linux, all uses of the terms *effective user* or *group ID*
    in this section should really be *file-system user* or *group ID* ([File-System
    User ID and File-System Group ID](ch09.html#file-system_user_id_and_file-system_grou
    "File-System User ID and File-System Group ID")).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 准确地说，在 Linux 上，本节中所有使用的 *有效用户* 或 *组 ID* 术语实际上应该是 *文件系统用户* 或 *组 ID*（[文件系统用户 ID
    和文件系统组 ID](ch09.html#file-system_user_id_and_file-system_grou "文件系统用户 ID 和文件系统组
    ID")）。
- en: When an *ext2* file system is mounted, either the *-o grpid* (or the synonymous
    *-o bsdgroups*) option or the *-o nogrpid* (or the synonymous *-o sysvgroups*)
    option may be specified to the *mount* command. (If neither option is specified,
    the default is *-o nogrpid*.) If *-o grpid* is specified, then a new file always
    inherits its group ID from the parent directory. If *-o nogrpid* is specified,
    then, by default, a new file takes its group ID from the process’s effective group
    ID. However, if the set-group-ID bit is enabled for the directory (via *chmod
    g+s*), then the group ID of the file is inherited from the parent directory. These
    rules are summarized in [Table 15-3](ch15.html#rules_determining_the_group_ownership_of
    "Table 15-3. Rules determining the group ownership of a newly created file").
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当挂载 *ext2* 文件系统时，可以通过 *mount* 命令指定 *-o grpid*（或同义的 *-o bsdgroups*）选项，或者 *-o
    nogrpid*（或同义的 *-o sysvgroups*）选项。（如果没有指定任何选项，默认使用 *-o nogrpid*。）如果指定了 *-o grpid*，则新文件总是从父目录继承其组
    ID。如果指定了 *-o nogrpid*，则默认情况下，新文件从进程的有效组 ID 中获取其组 ID。然而，如果目录启用了设置组 ID 位（通过 *chmod
    g+s*），则文件的组 ID 会从父目录继承。这些规则在 [表 15-3](ch15.html#rules_determining_the_group_ownership_of
    "表 15-3. 确定新创建文件的组所有权的规则") 中进行了总结。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In [Creating and Removing Directories: *mkdir()* and *rmdir()*](ch18.html#creating_and_removing_directories_colon
    "Creating and Removing Directories: mkdir() and rmdir()"), we’ll see that when
    the set-group-ID bit is set on a directory, then it is also set on new subdirectories
    created within that directory. In this manner, the set-group-ID behavior described
    in the main text is propagated down through an entire directory tree.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [创建和删除目录：*mkdir()* 和 *rmdir()*](ch18.html#creating_and_removing_directories_colon
    "创建和删除目录：mkdir() 和 rmdir()") 中，我们将看到，当目录设置了设置组 ID 位时，创建该目录内的新子目录时，组 ID 位也会被设置。这样，主文中描述的设置组
    ID 的行为会在整个目录树中传播。
- en: Table 15-3. Rules determining the group ownership of a newly created file
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-3. 确定新创建文件的组所有权的规则
- en: '| File system mount option | Set-group-ID bit enabled on parent directory?
    | Group ownership of new file taken from |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统挂载选项 | 父目录是否启用设置组 ID 位？ | 新文件的组所有权来源于 |'
- en: '| --- | --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *-o grpid*, *-o bsdgroups* | (ignored) | parent directory group ID |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| *-o grpid*、*-o bsdgroups* | （忽略） | 父目录组 ID |'
- en: '| *-o nogrpid*, *-o sysvgroups* (*default*) | no | process effective group
    ID |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| *-o nogrpid*、*-o sysvgroups*（*默认*） | 否 | 进程有效组 ID |'
- en: '| yes | parent directory group ID |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 是 | 父目录组 ID |'
- en: At the time of writing, the only file systems that support the *grpid* and *nogrpid*
    mount options are *ext2*, *ext3*, *ext4*, and (since Linux 2.6.14) *XFS*. Other
    file systems follow the *nogrpid* rules.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，唯一支持 *grpid* 和 *nogrpid* 挂载选项的文件系统是 *ext2*、*ext3*、*ext4* 和（自 Linux 2.6.14
    起）*XFS*。其他文件系统遵循 *nogrpid* 规则。
- en: 'Changing File Ownership: *chown()*, *fchown()*, and *lchown()*'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改文件所有权：*chown()*、*fchown()* 和 *lchown()*
- en: The *chown()*, *lchown()*, and *fchown()* system calls change the owner (user
    ID) and group (group ID) of a file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*chown()*、*lchown()* 和 *fchown()* 系统调用会更改文件的所有者（用户 ID）和组（组 ID）。'
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All return 0 on success, or -1 on error
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: 'The distinction between these three system calls is similar to the *stat()*
    family of system calls:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个系统调用之间的区别类似于 *stat()* 系列系统调用：
- en: '*chown()* changes the ownership of the file named in the *pathname* argument;'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*chown()* 会更改 *pathname* 参数指定的文件的所有权；'
- en: '*lchown()* does the same, except that if *pathname* is a symbolic link, ownership
    of the link file is changed, rather than the file to which it refers; and'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lchown()* 执行相同的操作，不同的是如果 *pathname* 是符号链接，则会更改链接文件的所有权，而不是链接所指向的文件的所有权；并且'
- en: '*fchown()* changes the ownership of a file referred to by the open file descriptor,
    *fd*.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fchown()* 会更改由打开文件描述符 *fd* 引用的文件的所有权。'
- en: The *owner* argument specifies the new user ID for the file, and the *group*
    argument specifies the new group ID for the file. To change just one of the IDs,
    we can specify -1 for the other argument to leave that ID unchanged.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*owner* 参数指定文件的新用户ID，*group* 参数指定文件的新组ID。要只更改其中一个ID，我们可以为另一个参数指定 -1，以保持该ID不变。'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to Linux 2.2, *chown()* did not dereference symbolic links. The semantics
    of *chown()* were changed with Linux 2.2, and the new *lchown()* system call was
    added to provide the behavior of the old *chown()* system call.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.2 之前，*chown()* 不会解除符号链接的引用。Linux 2.2 更改了 *chown()* 的语义，并新增了 *lchown()*
    系统调用，以提供旧版 *chown()* 系统调用的行为。
- en: Only a privileged (`CAP_CHOWN`) process may use *chown()* to change the user
    ID of a file. An unprivileged process can use *chown()* to change the group ID
    of a file that it owns (i.e., the process’s effective user ID matches the user
    ID of the file) to any of the groups of which they are a member. A privileged
    process can change the group ID of a file to any value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只有特权 (`CAP_CHOWN`) 进程才能使用 *chown()* 更改文件的用户ID。非特权进程可以使用 *chown()* 将其拥有的文件的组ID更改为它们是成员的任何组（即进程的有效用户ID与文件的用户ID匹配）。特权进程可以将文件的组ID更改为任何值。
- en: If the owner or group of a file is changed, then the set-user-ID and set-group-ID
    permission bits are both turned off. This is a security precaution to ensure that
    a normal user could not enable the set-user-ID (or set-group-ID) bit on an executable
    file and then somehow make it owned by some privileged user (or group), thereby
    gaining that privileged identity when executing the file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改了文件的所有者或组，则会关闭设置用户ID和设置组ID权限位。这是一种安全预防措施，以确保普通用户不能在可执行文件上启用设置用户ID（或设置组ID）位，然后通过某种方式使其成为特权用户（或组）的所有，进而在执行该文件时获得该特权身份。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 leaves it unspecified whether the set-user-ID and set-group-ID bits should
    be turned off when the superuser changes the owner or group of an executable file.
    Linux 2.0 did turn these bits off in this case, while some of the early 2.2 kernels
    (up to 2.2.12) did not. Later 2.2 kernels returned to the 2.0 behavior, where
    changes by the superuser are treated the same as everyone else, and this behavior
    is maintained in subsequent kernel versions. (However, if we use the *chown(1)*
    command under a *root* login to change the ownership of a file, then, after calling
    *chown(2)*, the *chown* command uses the *chmod()* system call to reenable the
    set-user-ID and set-group-ID bits.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 没有规定当超级用户更改可执行文件的所有者或组时，是否应关闭设置用户ID和设置组ID权限位。Linux 2.0 在这种情况下确实关闭了这些位，而早期的
    2.2 内核（直到 2.2.12）则没有。之后的 2.2 内核恢复了 2.0 的行为，其中超级用户的更改与普通用户的行为相同，并且这种行为在随后的内核版本中得到了保持。（然而，如果我们在
    *root* 登录下使用 *chown(1)* 命令更改文件的所有权，那么，在调用 *chown(2)* 后，*chown* 命令会使用 *chmod()*
    系统调用重新启用设置用户ID和设置组ID权限位。）
- en: 'When changing the owner or group of a file, the set-group-ID permission bit
    is not turned off if the group-execute permission bit is already off or if we
    are changing the ownership of a directory. In both of these cases, the set-group-ID
    bit is being used for a purpose other than the creation of a set-group-ID program,
    and therefore it is undesirable to turn the bit off. These other uses of the set-group-ID
    bit are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改文件的所有者或组时，如果组执行权限位已经关闭，或者我们正在更改目录的所有权，则不会关闭设置组ID权限位。在这两种情况下，设置组ID位用于其他目的，而非创建设置组ID程序，因此不希望关闭该位。设置组ID位的其他用途如下：
- en: If the group-execute permission bit is off, then the set-group-ID permission
    bit is being used to enable mandatory file locking (discussed in [Mandatory Locking](ch55.html#mandatory_locking
    "Mandatory Locking")).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果关闭了组执行权限位，则设置组ID权限位将用于启用强制文件锁定（在[强制锁定](ch55.html#mandatory_locking "强制锁定")中讨论）。
- en: In the case of a directory, the set-group-ID bit is being used to control the
    ownership of new files created in the directory ([Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files")).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目录的情况下，设置组ID位用于控制在该目录中创建的新文件的所有权（[新文件的所有权](ch15.html#ownership_of_new_files
    "新文件的所有权")）。
- en: The use of *chown()* is demonstrated in [Example 15-2](ch15.html#changing_the_owner_and_group_of_a_file
    "Example 15-2. Changing the owner and group of a file"), a program that allows
    the user to change the owner and group of an arbitrary number of files, specified
    as command-line arguments. (This program uses the *userIdFromName()* and *groupIdFromName()*
    functions from [Example 8-1](ch08.html#functions_to_convert_user_and_group_ids
    "Example 8-1. Functions to convert user and group IDs to and from user and group
    names"), in [Example program](ch08.html#example_program-id5 "Example program"),
    to convert user and group names into corresponding numeric IDs.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*chown()* 的使用示例见于[示例 15-2](ch15.html#changing_the_owner_and_group_of_a_file
    "示例 15-2. 更改文件的所有者和组"), 这是一个允许用户更改任意数量文件的所有者和组的程序，文件通过命令行参数指定。（该程序使用[示例 8-1](ch08.html#functions_to_convert_user_and_group_ids
    "示例 8-1. 转换用户和组ID的函数")中的 *userIdFromName()* 和 *groupIdFromName()* 函数，来自[示例程序](ch08.html#example_program-id5
    "示例程序")，将用户和组名转换为相应的数字ID。）'
- en: Example 15-2. Changing the owner and group of a file
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-2. 更改文件的所有者和组
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: File Permissions
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件权限
- en: In this section, we describe the permission scheme applied to files and directories.
    Although we talk about permissions here mainly as they apply to regular files
    and directories, the rules that we describe apply to all types of files, including
    devices, FIFOs, and UNIX domain sockets. Furthermore, the System V and POSIX interprocess
    communication objects (shared memory, semaphores, and message queues) also have
    permission masks, and the rules that apply for these objects are similar to those
    for files.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了应用于文件和目录的权限方案。虽然我们主要讨论文件和目录的权限，但我们描述的规则适用于所有类型的文件，包括设备、FIFO和UNIX域套接字。此外，System
    V和POSIX进程间通信对象（共享内存、信号量和消息队列）也有权限掩码，适用于这些对象的规则与文件类似。
- en: Permissions on Regular Files
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常规文件的权限
- en: 'As noted in [Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()"), the bottom 12 bits of the *st_mode* field
    of the *stat* structure define the permissions for a file. The first 3 of these
    bits are special bits known as the set-user-ID, set-group-ID, and sticky bits
    (labeled U, G, and T, respectively, in [Figure 15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "Figure 15-1. Layout of st_mode bit mask")). We say more about these bits in [Set-User-ID,
    Set-Group-ID, and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and
    "Set-User-ID, Set-Group-ID, and Sticky Bits"). The remaining 9 bits form the mask
    defining the permissions that are granted to various categories of users accessing
    the file. The file permissions mask divides the world into three categories:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o "检索文件信息：stat()")所述，*stat*
    结构的 *st_mode* 字段的底部12位定义了文件的权限。这些位中的前三位是特殊位，称为设置用户ID、设置组ID和粘滞位（分别在[图 15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "图 15-1. st_mode 位掩码的布局")中标记为 U、G 和 T）。我们将在[设置用户ID、设置组ID和粘滞位](ch15.html#set-user-id_comma_set-group-id_comma_and
    "设置用户ID、设置组ID和粘滞位")中进一步讨论这些位。剩余的9位形成了定义授予不同类别用户访问文件权限的掩码。文件权限掩码将世界分为三类：
- en: '*Owner* (also known as *user*): The permissions granted to the owner of the
    file.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*所有者*（也称为 *用户*）：授予文件所有者的权限。'
- en: Note
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term *user* is used by commands such as *chmod(1)*, which uses the abbreviation
    *u* to refer to this permission category.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*用户* 这一术语由 *chmod(1)* 等命令使用，其中 *u* 是该权限类别的缩写。'
- en: '*Group*: The permissions granted to users who are members of the file’s group.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组*：授予文件所属组成员的权限。'
- en: '*Other*: The permissions granted to everyone else.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他*：授予其他所有人的权限。'
- en: 'Three permissions may be granted to each user category:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户类别可以授予三种权限：
- en: '*Read*: The contents of the file may be read.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取*：文件的内容可以被读取。'
- en: '*Write*: The contents of the file may be changed.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*写入*：文件的内容可能会被更改。'
- en: '*Execute*: The file may be executed (i.e., it is a program or a script). In
    order to execute a script file (e.g., a *bash* script), both read and execute
    permissions are required.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行*：文件可以被执行（即，它是一个程序或脚本）。为了执行脚本文件（例如，*bash* 脚本），需要同时拥有读取和执行权限。'
- en: 'The permissions and ownership of a file can be viewed using the command *ls
    -l*, as in the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用命令 *ls -l* 查看文件的权限和所有权，如以下示例所示：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the above example, the file permissions are displayed as `rwxr-x---` (the
    initial hyphen preceding this string indicates the type of this file: a regular
    file). To interpret this string, we break these 9 characters into sets of 3 characters,
    which respectively indicate whether read, write, and execute permission are enabled.
    The first set indicates the permissions for owner, which has read, write, and
    execute permissions enabled. The next set indicates the permissions for group,
    which has read and execute enabled, but not write. The final set are the permissions
    for other, which doesn’t have any permissions enabled.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，文件权限显示为 `rwxr-x---`（该字符串前的初始连字符表示文件类型：常规文件）。为了理解这个字符串，我们将这 9 个字符分成 3
    组，每组分别表示是否启用了读、写和执行权限。第一组表示所有者的权限，所有者具有读、写和执行权限。接下来的组表示组的权限，组具有读和执行权限，但没有写权限。最后一组表示其他用户的权限，其他用户没有任何权限。
- en: The `<sys/stat.h>` header file defines constants that can be ANDed (`&`) with
    *st_mode* of the *stat* structure, in order to check whether particular permission
    bits are set. (These constants are also defined via the inclusion of `<fcntl.h>`,
    which prototypes the *open()* system call.) These constants are shown in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits").
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`<sys/stat.h>` 头文件定义了常量，可以与 *stat* 结构的 *st_mode* 使用 AND 运算符（`&`）进行比较，以检查是否设置了特定的权限位。（这些常量也通过包含
    `<fcntl.h>` 被定义，`<fcntl.h>` 中原型化了 *open()* 系统调用。）这些常量显示在 [表 15-4](ch15.html#constants_for_file_permission_bits
    "表 15-4. 文件权限位常量") 中。'
- en: Table 15-4. Constants for file permission bits
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-4. 文件权限位常量
- en: '| Constant | Octal value | Permission bit |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 八进制值 | 权限位 |'
- en: '| --- | --- | --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `S_ISUID` | `04000` | Set-user-ID |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `S_ISUID` | `04000` | 设置用户标识位 |'
- en: '| `S_ISGID` | `02000` | Set-group-ID |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `S_ISGID` | `02000` | 设置组标识位 |'
- en: '| `S_ISVTX` | `01000` | Sticky |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `S_ISVTX` | `01000` | Sticky 位 |'
- en: '| `S_IRUSR` | `0400` | User-read |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `S_IRUSR` | `0400` | 用户可读 |'
- en: '| `S_IWUSR` | `0200` | User-write |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `S_IWUSR` | `0200` | 用户可写 |'
- en: '| `S_IXUSR` | `0100` | User-execute |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `S_IXUSR` | `0100` | 用户可执行 |'
- en: '| `S_IRGRP` | `040` | Group-read |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `S_IRGRP` | `040` | 组可读 |'
- en: '| `S_IWGRP` | `020` | Group-write |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `S_IWGRP` | `020` | 组可写 |'
- en: '| `S_IXGRP` | `010` | Group-execute |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `S_IXGRP` | `010` | 组可执行 |'
- en: '| `S_IROTH` | `04` | Other-read |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `S_IROTH` | `04` | 其他用户可读 |'
- en: '| `S_IWOTH` | `02` | Other-write |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `S_IWOTH` | `02` | 其他用户可写 |'
- en: '| `S_IXOTH` | `01` | Other-execute |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `S_IXOTH` | `01` | 其他用户可执行 |'
- en: 'In addition to the constants shown in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), three constants are defined
    to equate to masks for all three permissions for each of the categories owner,
    group, and other: `S_IRWXU` (0700), `S_IRWXG` (070), and `S_IRWXO` (07).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 [表 15-4](ch15.html#constants_for_file_permission_bits "表 15-4. 文件权限位常量")
    中显示的常量外，还定义了三个常量，用于表示所有者、组和其他用户的所有三种权限掩码：`S_IRWXU`（0700）、`S_IRWXG`（070）和 `S_IRWXO`（07）。
- en: The header file in [Example 15-3](ch15.html#header_file_for_file_underscore_perms.c
    "Example 15-3. Header file for file_perms.c") declares a function, *filePermStr()*,
    which, given a file permissions mask, returns a statically allocated string representation
    of that mask in the same style as is used by *ls(1)*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-3](ch15.html#header_file_for_file_underscore_perms.c "示例 15-3. file_perms.c
    的头文件")中的头文件声明了一个函数，*filePermStr()*，该函数接收一个文件权限掩码，返回该掩码的静态分配字符串表示，格式与 *ls(1)* 中使用的格式相同。'
- en: Example 15-3. Header file for `file_perms.c`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-3. `file_perms.c` 的头文件
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the `FP_SPECIAL` flag is set in the *filePermStr() flags* argument, then
    the returned string includes the settings of the set-user-ID, set-group-ID, and
    sticky bits, again in the style of *ls(1)*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 *filePermStr()* 函数的 *flags* 参数中设置了 `FP_SPECIAL` 标志，那么返回的字符串将包含设置的用户标识位、组标识位和
    Sticky 位，再次以 *ls(1)* 的样式显示。
- en: The implementation of the *filePermStr()* function is shown in [Example 15-4](ch15.html#convert_file_permissions_mask_to_string
    "Example 15-4. Convert file permissions mask to string"). We employ this function
    in the program in [Example 15-1](ch15.html#retrieving_and_interpreting_file_stat_in
    "Example 15-1. Retrieving and interpreting file stat information").
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*filePermStr()* 函数的实现显示在 [示例 15-4](ch15.html#convert_file_permissions_mask_to_string
    "示例 15-4. 将文件权限掩码转换为字符串") 中。我们在 [示例 15-1](ch15.html#retrieving_and_interpreting_file_stat_in
    "示例 15-1. 获取和解释文件状态信息") 的程序中使用了这个函数。'
- en: Example 15-4. Convert file permissions mask to string
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-4. 将文件权限掩码转换为字符串
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Permissions on Directories
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录权限
- en: 'Directories have the same permission scheme as files. However, the three permissions
    are interpreted differently:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目录的权限结构与文件相同。然而，三种权限的含义不同：
- en: '*Read*: The contents (i.e., the list of filenames) of the directory may be
    listed (e.g., by *ls*).'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取*: 可以列出目录的内容（即文件名列表）（例如，通过*ls*命令）。'
- en: Note
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If experimenting to verify the operation of the directory read permission bit,
    be aware that some Linux distributions alias the *ls* command to include flags
    (e.g., *-F*) that require access to i-node information for files in the directory,
    and this requires execute permission on the directory. To ensure that we are using
    an unadulterated ls, we can specify the full pathname of the command `(/bin/ls)`.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果实验验证目录读取权限位的操作，请注意，一些Linux发行版会将*ls*命令别名化，包含一些需要访问目录中文件i节点信息的标志（例如，*-F*），而这需要目录的执行权限。为了确保我们使用的是未经修改的`ls`命令，可以指定命令的完整路径名`(/bin/ls)`。
- en: '*Write*: Files may be created in and removed from the directory. Note that
    it is not necessary to have any permission on a file itself in order to be able
    to delete it.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*写入*: 可以在目录中创建和删除文件。请注意，要删除文件本身，并不需要对文件本身拥有任何权限。'
- en: '*Execute*: Files within the directory may be accessed. Execute permission on
    a directory is sometimes called *search* permission.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行*: 可以访问目录中的文件。目录上的执行权限有时也称为*搜索*权限。'
- en: When accessing a file, execute permission is required on all of the directories
    listed in the pathname. For example, reading the file `/home/mtk/x` would require
    execute permission on `/`, `/home`, and `/home/mtk` (as well as read permission
    on the file `x` itself). If the current working directory is `/home/mtk/sub1`
    and we access the relative pathname `../sub2/x`, then we need execute permission
    on `/home/mtk` and `/home/mtk/sub2` (but not on `/` or `/home`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 访问文件时，需要对路径名中列出的所有目录具有执行权限。例如，读取文件`/home/mtk/x`需要对`/`、`/home`和`/home/mtk`具有执行权限（同时对文件`x`本身需要有读取权限）。如果当前工作目录是`/home/mtk/sub1`，我们访问相对路径`../sub2/x`时，需要对`/home/mtk`和`/home/mtk/sub2`具有执行权限（但不需要对`/`或`/home`有执行权限）。
- en: Read permission on a directory only lets us view the list of filenames in the
    directory. We must have execute permission on the directory in order to access
    the contents or the i-node information of files in the directory.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对目录的读取权限只允许我们查看目录中文件名的列表。要访问目录中文件的内容或i节点信息，我们必须对目录具有执行权限。
- en: Conversely, if we have execute permission on a directory, but not read permission,
    then we can access a file in the directory if we know its name, but we can’t list
    the contents of (i.e., the other filenames in) the directory. This is a simple
    and frequently used technique to control access to the contents of a public directory.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，如果我们对目录具有执行权限，但没有读取权限，那么如果知道文件名，我们可以访问该目录中的文件，但无法列出目录中的其他文件名。这是控制公共目录内容访问的一种简单且常用的技术。
- en: To add or remove files in a directory, we need both execute and write permissions
    on the directory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要在目录中添加或删除文件，我们需要对目录同时拥有执行和写入权限。
- en: Permission-Checking Algorithm
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 权限检查算法
- en: The kernel checks file permissions whenever we specify a pathname in a system
    call that accesses a file or directory. When the pathname given to the system
    call includes a directory prefix, then, in addition to checking for the required
    permissions on the file itself, the kernel also checks for execute permission
    on each of the directories in this prefix. Permission checks are made using the
    process’s effective user ID, effective group ID, and supplementary group IDs.
    (To be strictly accurate, for file permission checks on Linux, the file-system
    user and group IDs are used instead of the corresponding effective IDs, as described
    in Section 9.5.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在系统调用中指定路径名以访问文件或目录时，内核会检查文件权限。当系统调用的路径名包括目录前缀时，内核除了检查文件本身的所需权限外，还会检查该前缀中每个目录的执行权限。权限检查是使用进程的有效用户ID、有效组ID和附加组ID进行的。（严格来说，在Linux中进行文件权限检查时，使用的是文件系统的用户和组ID，而不是相应的有效ID，如第9.5节所述。）
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once a file has been opened with *open()*, no permission checking is performed
    by subsequent system calls that work with the returned file descriptor (such as
    *read()*, *write()*, *fstat()*, *fcntl()*, and *mmap()*).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件通过*open()*打开，之后的系统调用（如*read()*, *write()*, *fstat()*, *fcntl()*, 和 *mmap()*)不会对返回的文件描述符进行权限检查。
- en: 'The rules applied by the kernel when checking permissions are as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 内核在检查权限时应用的规则如下：
- en: If the process is privileged, all access is granted.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程具有特权，则授予所有访问权限。
- en: If the effective user ID of the process is the same as the user ID (owner) of
    the file, then access is granted according to the *owner* permissions on the file.
    For example, read access is granted if the owner-read permission bit is turned
    on in the file permissions mask; otherwise, read access is denied.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的有效用户 ID 与文件的用户 ID（所有者）相同，则根据文件上的*所有者*权限授予访问权限。例如，如果文件权限掩码中的所有者读取权限位被启用，则授予读取访问权限；否则，拒绝读取访问权限。
- en: If the effective group ID of the process or any of the process supplementary
    group IDs matches the group ID (group owner) of the file, then access is granted
    according to the *group* permissions on the file.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的有效组 ID 或任何进程附加组 ID 与文件的组 ID（组所有者）匹配，则根据文件上的*组*权限授予访问权限。
- en: Otherwise, access is granted according to the *other* permissions on the file.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，访问权限将根据文件上的*其他*权限授予。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the kernel code, the above tests are actually constructed so that the test
    to see whether a process is privileged is performed only if the process is not
    granted the permissions it needs via one of the other tests. This is done to avoid
    unnecessarily setting the `ASU` process accounting flag, which indicates that
    the process made use of superuser privileges ([Process Accounting](ch28.html#process_accounting
    "Process Accounting")).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核代码中，上述测试实际上是这样构造的：只有在进程未通过其他测试获得所需权限时，才会执行检查该进程是否具有特权的测试。这是为了避免不必要地设置 `ASU`
    进程会计标志，该标志表示进程使用了超级用户特权（[进程会计](ch28.html#process_accounting "进程会计")）。
- en: 'The checks against owner, group, and other permissions are done in order, and
    checking stops as soon as the applicable rule is found. This can have an unexpected
    consequence: if, for example, the permissions for group exceed those of owner,
    then the owner will actually have fewer permissions on the file than members of
    the file’s group, as illustrated by the following example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有者、组和其他权限的检查是按顺序进行的，一旦找到适用的规则，检查便停止。这可能会产生意想不到的后果：例如，如果组的权限超过所有者的权限，那么所有者实际上在文件上的权限会少于文件组的成员，以下例子说明了这一点：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Similar remarks apply if other grants more permissions than owner or group.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他权限比所有者或组更多，类似的说明也适用。
- en: Since file permissions and ownership information are maintained within a file
    i-node, all filenames (links) that refer to the same i-node share this information.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件权限和所有权信息保存在文件的 i 节点中，因此所有指向同一 i 节点的文件名（链接）共享这些信息。
- en: Linux 2.6 provides access control lists (ACLs), which make it possible to define
    file permissions on a per-user and per-group basis. If a file has an ACL, then
    a modified version of the above algorithm is used. We describe ACLs in [Chapter 17](ch17.html
    "Chapter 17. Access Control Lists").
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6 提供了访问控制列表（ACLs），使得可以基于每个用户和每个组定义文件权限。如果文件具有 ACL，则使用修改后的算法来检查权限。我们在[第17章](ch17.html
    "第17章。访问控制列表")中描述了 ACL。
- en: Permission checking for privileged processes
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对特权进程的权限检查
- en: Above, we said that if a process is privileged, all access is granted when checking
    permissions. We need to add one proviso to this statement. For a file that is
    not a directory, Linux grants execute permission to a privileged process only
    if that permission is granted to at least one of the permission categories for
    the file. On some other UNIX implementations, a privileged process can execute
    a file even when no permission category grants execute permission. When accessing
    a directory, a privileged process is always granted execute (search) permission.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述中，我们说过如果进程具有特权，则在检查权限时会授予所有访问权限。我们需要为这个说法添加一个前提条件。对于非目录文件，只有当文件的某个权限类别被授予执行权限时，Linux
    才会授予特权进程执行权限。在某些其他 UNIX 实现中，即使没有任何权限类别授予执行权限，特权进程也能执行文件。当访问目录时，特权进程始终会被授予执行（搜索）权限。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can rephrase our description of a privileged process in terms of two Linux
    process capabilities: `CAP_DAC_READ_SEARCH` and `CAP_DAC_OVERRIDE` ([The Linux
    Capabilities](ch39.html#the_linux_capabilities "The Linux Capabilities")). A process
    with the `CAP_DAC_READ_SEARCH` capability always has read permission for any type
    of file, and always has read and execute permissions for a directory (i.e., can
    always access files in a directory and read the list of files in a directory).
    A process with the `CAP_DAC_OVERRIDE` capability always has read and write permissions
    for any type of file, and also has execute permission if the file is a directory
    or if execute permission is granted to at least one of the permission categories
    for the file.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking File Accessibility: *access()*'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in [Permission-Checking Algorithm](ch15.html#permission-checking_algorithm
    "Permission-Checking Algorithm"), the *effective* user and group IDs, as well
    as supplementary group IDs, are used to determine the permissions a process has
    when accessing a file. It is also possible for a program (e.g., a set-user-ID
    or set-group-ID program) to check file accessibility based on the *real* user
    and group IDs of the process.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The *access()* system call checks the accessibility of the file specified in
    *pathname* based on a process’s real user and group IDs (and supplementary group
    IDs).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 if all permissions are granted, otherwise -1
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: If *pathname* is a symbolic link, *access()* dereferences it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The *mode* argument is a bit mask consisting of one or more of the constants
    shown in [Table 15-5](ch15.html#mode_constants_for_access_open_parenthes "Table 15-5. mode
    constants for access()"), ORed (`|`) together. If all of the permissions specified
    in *mode* are granted on *pathname*, then *access()* returns 0; if at least one
    of the requested permissions is not available (or an error occurred), then *access()*
    returns -1.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-5. *mode* constants for *access()*
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | Description |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| `F_OK` | Does the file exist? |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| `R_OK` | Can the file be read? |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| `W_OK` | Can the file be written? |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| `X_OK` | Can the file be executed? |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: The time gap between a call to *access()* and a subsequent operation on a file
    means that there is no guarantee that the information returned by *access()* will
    still be true at the time of the later operation (no matter how brief the interval).
    This situation could lead to security holes in some application designs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, that we have a set-user-ID-*root* program that uses *access()*
    to check that a file is accessible to the real user ID of the program, and, if
    so, performs an operation on the file (e.g., *open()* or *exec()*).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that if the pathname given to *access()* is a symbolic link,
    and a malicious user manages to change the link so that it refers to a different
    file before the second step, then the set-user-ID-*root* may end up operating
    on a file for which the real user ID does not have permission. (This is an example
    of the type of time-of-check, time-of-use race condition described in Section
    38.6.) For this reason, recommended practice is to avoid the use of *access()*
    altogether (see, for example, [Borisov, 2005]). In the example just given, we
    can achieve this by temporarily changing the effective (or file system) user ID
    of the set-user-ID process, attempting the desired operation (e.g., *open()* or
    *exec()*), and then checking the return value and *errno* to determine whether
    the operation failed because of a permissions problem.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GNU C library provides an analogous, nonstandard function, *euidaccess()*
    (or synonymously, *eaccess()*), that checks file access permissions using the
    effective user ID of the process.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Set-User-ID, Set-Group-ID, and Sticky Bits
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As well as the 9 bits used for owner, group, and other permissions, the file
    permissions mask contains 3 additional bits, known as the *set-user-ID* (bit 04000),
    *set-group-ID* (bit 02000), and *sticky* (bit 01000) bits. We have already discussed
    the use of the set-user-ID and set-group-ID permission bits for creating privileged
    programs in Section 9.3\. The set-group-ID bit also serves two other purposes
    that we describe elsewhere: controlling the group ownership of new files created
    in a directory mounted with the *nogrpid* option ([Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files")), and enabling mandatory locking on a file ([Mandatory
    Locking](ch55.html#mandatory_locking "Mandatory Locking")). In the remainder of
    this section, we limit our discussion to the use of the sticky bit.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: On older UNIX implementations, the sticky bit was provided as a way of making
    commonly used programs run faster. If the sticky bit was set on a program file,
    then the first time the program was executed, a copy of the program text was saved
    in the swap area—thus it *sticks* in swap, and loads faster on subsequent executions.
    Modern UNIX implementations have more sophisticated memory-management systems,
    which have rendered this use of the sticky permission bit obsolete.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name of the constant for the sticky permission bit shown in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), `S_ISVTX`, derives from an
    alternative name for the sticky bit: the *saved-text* bit.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In modern UNIX implementations (including Linux), the sticky permission bit
    serves another, quite different purpose. For directories, the sticky bit acts
    as the *restricted deletion* flag. Setting this bit on a directory means that
    an unprivileged process can unlink (*unlink()*, *rmdir()*) and rename (*rename()*)
    files in the directory only if it has write permission on the directory *and*
    owns either the file or the directory. (A process with the `CAP_FOWNER` capability
    can bypass the latter ownership check.) This makes it possible to create a directory
    that is shared by many users, who can each create and delete their own files in
    the directory but can’t delete files owned by other users. The sticky permission
    bit is commonly set on the `/tmp` directory for this reason.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'A file’s sticky permission bit is set via the *chmod* command (*chmod +t file*)
    or via the *chmod()* system call. If the sticky bit for a file is set, *ls -l*
    shows a lowercase or uppercase letter *T* in the other-execute permission field,
    depending on whether the other-execute permission bit is on or off, as in the
    following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Process File Mode Creation Mask: *umask()*'
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now consider in more detail the permissions that are placed on a newly created
    file or directory. For new files, the kernel uses the permissions specified in
    the *mode* argument to *open()* or *creat()*. For new directories, permissions
    are set according to the *mode* argument to *mkdir()*. However, these settings
    are modified by the file mode creation mask, also known simply as the *umask*.
    The umask is a process attribute that specifies which permission bits should always
    be turned *off* when new files or directories are created by the process.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Often, a process just uses the umask it inherits from its parent shell, with
    the (usually desirable) consequence that the user can control the umask of programs
    executed from the shell using the shell built-in command *umask*, which changes
    the umask of the shell process.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The initialization files for most shells set the default umask to the octal
    value 022 (`----w--w-`). This value specifies that write permission should always
    be turned off for group and other. Thus, assuming the *mode* argument in a call
    to *open()* is 0666 (i.e., read and write permitted for all users, which is typical),
    then new files are created with read and write permissions for owner, and only
    read permission for everyone else (displayed by *ls -l* as `rw-r--r--`). Correspondingly,
    assuming that the *mode* argument to *mkdir()* is specified as 0777 (i.e., all
    permissions granted to all users), new directories are created with all permissions
    granted for owner, and just read and execute permissions for group and other (i.e.,
    `rwxr-xr-x`).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The *umask()* system call changes a process’s umask to the value specified in
    *mask*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always successfully returns the previous process umask
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The *mask* argument can be specified either as an octal number or by ORing (`|`)
    together the constants listed in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits").
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*mask* 参数可以作为八进制数字指定，或者通过按位或（`|`）将[表 15-4](ch15.html#constants_for_file_permission_bits
    "表 15-4. 文件权限位常量")中列出的常量结合在一起。'
- en: A call to *umask()* is always successful, and returns the previous umask.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *umask()* 的调用总是成功，并返回先前的 umask 值。
- en: '[Example 15-5](ch15.html#using_umask_open_parenthesis_close_paren "Example 15-5. Using
    umask()") illustrates the use of *umask()* in conjunction with *open()* and *mkdir()*.
    When we run this program, we see the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-5](ch15.html#using_umask_open_parenthesis_close_paren "示例 15-5. 使用 umask()")展示了如何将
    *umask()* 与 *open()* 和 *mkdir()* 一起使用。当我们运行该程序时，我们会看到以下结果：'
- en: '[PRE24]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Example 15-5](ch15.html#using_umask_open_parenthesis_close_paren "Example 15-5. Using
    umask()"), we employ the *mkdir()* and *rmdir()* system calls to create and remove
    a directory, and the *unlink()* system call to remove a file. We describe these
    system calls in [Chapter 18](ch18.html "Chapter 18. Directories and Links").
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 15-5](ch15.html#using_umask_open_parenthesis_close_paren "示例 15-5. 使用 umask()")中，我们使用
    *mkdir()* 和 *rmdir()* 系统调用来创建和删除目录，并使用 *unlink()* 系统调用来删除文件。我们在[第 18 章](ch18.html
    "第 18 章. 目录与链接")中描述了这些系统调用。
- en: Example 15-5. Using *umask()*
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-5. 使用 *umask()*
- en: '[PRE25]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Changing File Permissions: *chmod()* and *fchmod()*'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改文件权限：*chmod()* 和 *fchmod()*
- en: The *chmod()* and *fchmod()* system calls change the permissions of a file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*chmod()* 和 *fchmod()* 系统调用更改文件的权限。'
- en: '[PRE26]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在成功时返回 0，出错时返回 -1。
- en: The *chmod()* system call changes the permissions of the file named in *pathname*.
    If this argument is a symbolic link, *chmod()* changes the permissions of the
    file to which it refers, rather than the permissions of the link itself. (A symbolic
    link is always created with read, write, and execute permissions enabled for all
    users, and these permission can’t be changed. These permissions are ignored when
    dereferencing the link.)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*chmod()* 系统调用更改在 *pathname* 中指定的文件的权限。如果该参数是符号链接，*chmod()* 更改其指向的文件的权限，而不是链接本身的权限。（符号链接始终以所有用户具有读、写和执行权限的方式创建，这些权限无法更改。在取消引用链接时，这些权限会被忽略。）'
- en: The *fchmod()* system call changes the permissions on the file referred to by
    the open file descriptor *fd*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*fchmod()* 系统调用更改由打开文件描述符 *fd* 引用的文件的权限。'
- en: The *mode* argument specifies the new permissions of the file, either numerically
    (octal) or as a mask formed by ORing (|) the permission bits listed in [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"). In order to change the permissions
    on a file, either the process must be privileged (`CAP_FOWNER`) or its effective
    user ID must match the owner (user ID) of the file. (To be strictly accurate,
    on Linux, for an unprivileged process, it is the process’s file-system user ID,
    rather than its effective user ID, that must match the user ID of the file, as
    described in Section 9.5.)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*mode* 参数指定文件的新权限，可以是数字（八进制）或通过按位或（|）运算得到的权限位掩码，这些位列在[表 15-4](ch15.html#constants_for_file_permission_bits
    "表 15-4. 文件权限位常量")中。为了更改文件的权限，进程必须具备相应的权限（`CAP_FOWNER`），或者其有效用户 ID 必须与文件的所有者（用户
    ID）匹配。（严格来说，在 Linux 上，对于非特权进程，必须是进程的文件系统用户 ID，而不是有效用户 ID，必须与文件的用户 ID 匹配，详情请见第
    9.5 节。）'
- en: 'To set the permissions on a file so that only read permission is granted to
    all users, we could use the following call:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置文件的权限，使得所有用户仅被授予读取权限，我们可以使用以下调用：
- en: '[PRE27]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In order to modify selected bits of the file permissions, we first retrieve
    the existing permissions using *stat()*, tweak the bits we want to change, and
    then use *chmod()* to update the permissions:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改文件权限的特定位，我们首先使用 *stat()* 检索现有的权限，调整我们想要更改的位，然后使用 *chmod()* 更新权限：
- en: '[PRE28]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The above is equivalent to the following shell command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作等同于以下 shell 命令：
- en: '[PRE29]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In [Ownership of New Files](ch15.html#ownership_of_new_files "Ownership of
    New Files"), we noted that if a directory resides on an *ext2* system mounted
    with the *-o bsdgroups* option, or on one mounted with the *-o sysvgroups* option
    *and* the set-group-ID permission bit is turned on for the directory, then a newly
    created file in the directory takes its ownership from the parent directory, not
    the effective group ID of the creating process. It may be the case that the group
    ID of such a file doesn’t match any of the group IDs of the creating process.
    For this reason, when an unprivileged process (one that doesn’t have the `CAP_FSETID`
    capability) calls *chmod()* (or *fchmod()*) on a file whose group ID is not equal
    to the effective group ID or any of the supplementary group IDs of the process,
    the kernel always clears the set-group-ID permission bit. This is a security measure
    designed to prevent a user from creating a set-group-ID program for a group of
    which they are not a member. The following shell commands show the attempted exploit
    that this measure prevents:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I-node Flags (*ext2* Extended File Attributes)
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some Linux file systems allow various *i-node flags* to be set on files and
    directories. This feature is a nonstandard Linux extension.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modern BSDs provide a similar feature to i-node flags in the form of file
    flags set using *chflags(1)* and *chflags(2)*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The first Linux file system to support i-node flags was *ext2*, and these flags
    are sometimes referred to as *ext2 extended file attributes*. Subsequently, support
    for i-node flags has been added on other file systems, including *Btrfs*, *ext3*,
    *ext4*, *Reiserfs* (since Linux 2.4.19), *XFS* (since Linux 2.4.25 and 2.6), and
    *JFS* (since Linux 2.6.17).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The range of i-node flags supported varies somewhat across file systems. In
    order to use i-node flags on a *Reiserfs* file system, we must use the *mount
    -o attrs* option when mounting the file system.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'From the shell, i-node flags can be set and viewed using the *chattr* and *lsattr*
    commands, as shown in the following example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Within a program, i-node flags can be retrieved and modified using the *ioctl()*
    system call, as detailed shortly.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: I-node flags can be set on both regular files and directories. Most i-node flags
    are intended for use with regular files, although some of them also (or only)
    have meaning for directories. [Table 15-6](ch15.html#i-node_flags "Table 15-6. I-node
    flags") summarizes the range of available i-node flags, showing the corresponding
    flag name (defined in `<linux/fs.h>`) that is used from programs in *ioctl()*
    calls, and the option letter that is used with the *chattr* command.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before Linux 2.6.19, the `FS_*` constants shown in [Table 15-6](ch15.html#i-node_flags
    "Table 15-6. I-node flags") were not defined in `<linux/fs.h>`. Instead, there
    was a set of file system–specific header files that defined file system-specific
    constant names, all with the same value. Thus, *ext2* had `EXT2_APPEND_FL`, defined
    in `<linux/ext2_fs.h>`; *Reiserfs* had `REISERFS_APPEND_FL`, defined with the
    same value in `<linux/reiser_fs.h>`; and so on. Since each of the header files
    defines the corresponding constants with the same value, on older systems that
    don’t provide the definitions in `<linux/fs.h>`, it is possible to include any
    of the header files and use the file system–specific names.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-6. I-node flags
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | *chattr* option | Purpose |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| `FS_APPEND_FL` | `a` | Append only (privilege required) |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| `FS_COMPR_FL` | `c` | Enable file compression (not implemented) |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| `FS_DIRSYNC_FL` | `D` | Synchronous directory updates (since Linux 2.6) |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| `FS_IMMUTABLE_FL` | `i` | Immutable (privilege required) |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| `FS_JOURNAL_DATA_FL` | `j` | Enable data journaling (privilege required)
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| `FS_NOATIME_FL` | `A` | Don’t update file last access time |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| `FS_NODUMP_FL` | `d` | No dump |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| `FS_NOTAIL_FL` | `t` | No tail packing |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| `FS_SECRM_FL` | `s` | Secure deletion (not implemented) |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| `FS_SYNC_FL` | `S` | Synchronous file (and directory) updates |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| `FS_TOPDIR_FL` | `T` | Treat as top-level directory for Orlov (since Linux
    2.6) |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| `FS_UNRM_FL` | `u` | File can be undeleted (not implemented) |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: 'The various `FL_*` flags and their meanings are as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_APPEND_FL`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The file can be opened for writing only if the `O_APPEND` flag is specified
    (thus forcing all file updates to append to the end of the file). This flag could
    be used for a log file, for example. Only privileged (`CAP_LINUX_IMMUTABLE`) processes
    can set this flag.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_COMPR_FL`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Store the file on disk in a compressed format. This feature is not implemented
    as a standard part of any of the major native Linux file systems. (There are packages
    that implement this feature for *ext2* and *ext3*.) Given the low cost of disk
    storage, the CPU overhead involved in compression and decompression, and the fact
    that compressing a file means that it is no longer a simple matter to randomly
    access the file’s contents (via *lseek()*), file compression is undesirable for
    many applications.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_DIRSYNC_FL` (since Linux 2.6)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Make directory updates (e.g., *open(pathname, O_CREAT)*, *link()*, *unlink()*,
    and *mkdir()*) synchronous. This is analogous to the synchronous file update mechanism
    described in Section 13.3\. As with synchronous file updates, there is a performance
    impact associated with synchronous directory updates. This setting can be applied
    only to directories. (The `MS_DIRSYNC` mount flag described in [Mounting a File
    System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open "Mounting
    a File System: mount()") provides similar functionality, but on a per-mount basis.)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_IMMUTABLE_FL`'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Make the file immutable. File data can’t be updated (*write()* and *truncate()*)
    and metadata changes are prevented (e.g., *chmod()*, *chown()*, *unlink()*, *link()*,
    *rename()*, *rmdir()*, *utime()*, *setxattr()*, and *removexattr()*). Only privileged
    (`CAP_LINUX_IMMUTABLE`) processes can set this flag for a file. When this flag
    is set, even a privileged process can’t change the file contents or metadata.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_JOURNAL_DATA_FL`'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable journaling of data. This flag is supported only on the *ext3* and *ext4*
    file systems. These file systems provide three levels of journaling: *journal*,
    *ordered*, and *writeback*. All modes journal updates to file metadata, but the
    *journal* mode additionally journals updates to file data. On a file system that
    is journaling in *ordered* or *writeback* mode, a privileged `(CAP_SYS_RESOURCE)`
    process can enable journaling of data updates on a per-file basis by setting this
    flag. (The *mount(8)* manual page describes the difference between the *ordered*
    and *writeback* modes.)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_NOATIME_FL`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t update the file last access time when the file is accessed. This eliminates
    the need to update the file’s i-node each time the file is accessed, thus improving
    I/O performance (see the description of the `MS_NOATIME` flag in [Mounting a File
    System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open "Mounting
    a File System: mount()")).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_NODUMP_FL`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Don’t include this file in backups made using *dump(8)*. The effect of this
    flag is dependent on the *-h* option described in the *dump(8)* manual page.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_NOTAIL_FL`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Disable tail packing. This flag is supported only on the *Reiserfs* file system.
    It disables the *Reiserfs* tail-packing feature, which tries to pack small files
    (and the final fragment of larger files) into the same disk block as the file
    metadata. Tail packing can also be disabled for an entire *Reiserfs* file system
    by mounting it with the *mount -o notail* option.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_SECRM_FL`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the file securely. The intended purpose of this unimplemented feature
    is that, when removed, a file is securely deleted, meaning that it is first overwritten
    to prevent a disk-scanning program from reading or re-creating it. (The issue
    of truly secure deletion is rather complex: it can actually require multiple writes
    on magnetic media to securely erase previously recorded data; see [Gutmann, 1996].)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_SYNC_FL`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Make file updates synchronous. When applied to files, this flag causes writes
    to the file to be synchronous (as though the `O_SYNC` flag was specified on all
    opens of this file). When applied to a directory, this flag has the same effect
    as the synchronous directory updates flag described above.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_TOPDIR_FL` (since Linux 2.6)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: This marks a directory for special treatment under the *Orlov* block-allocation
    strategy. The Orlov strategy is a BSD-inspired modification of the *ext2* block-allocation
    strategy that tries to improve the chances that related files (e.g., the files
    within a single directory) are placed close to each other on disk, which can improve
    disk seek times. For details, see [Corbet, 2002] and [Kumar, et al. 2008]. `FS_TOPDIR_FL`
    has an effect only for *ext2* and its descendants, *ext3* and *ext4*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '`FS_UNRM_FL`'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Allow this file to be recovered (undeleted) if it is deleted. This feature is
    not implemented, since it is possible to implement file-recovery mechanisms outside
    the kernel.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, when i-node flags are set on a directory, they are automatically
    inherited by new files and subdirectories created in that directory. There are
    exceptions to this rule:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The `FS_DIRSYNC_FL` (*chattr +D*) flag, which can be applied only to a directory,
    is inherited only by subdirectories created in that directory.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `FS_IMMUTABLE_FL` (*chattr +i*) flag is applied to a directory, it
    is not inherited by files and subdirectories created within that directory, since
    this flag prevents new entries being added to the directory.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within a program, i-node flags can be retrieved and modified using the *ioctl()*
    `FS_IOC_GETFLAGS` and `FS_IOC_SETFLAGS` operations. (These constants are defined
    in `<linux/fs.h>`.) The following code shows how to enable the `FS_NOATIME_FL`
    flag on the file referred to by the open file descriptor *fd*:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In order to change the i-node flags of a file, either the effective user ID
    of the process must match the user ID (owner) of the file, or the process must
    be privileged (`CAP_FOWNER`). (To be strictly accurate, on Linux, for an unprivileged
    process it is the process’s file-system user ID, rather than its effective user
    ID, that must match the user ID of the file, as described in Section 9.5.)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *stat()* system call retrieves information about a file (metadata), most
    of which is drawn from the file i-node. This information includes file ownership,
    file permissions, and file timestamps.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: A program can update a file’s last access time and last modification time using
    *utime()*, *utimes()*, and various similar interfaces.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Each file has an associated user ID (owner) and group ID, as well as a set
    of permission bits. For permissions purposes, file users are divided into three
    categories: *owner* (also known as *user*), *group*, and *other*. Three permissions
    may be granted to each category of user: *read*, *write*, and *execute*. The same
    scheme is used with directories, although the permission bits have slightly different
    meanings. The *chown()* and *chmod()* system calls change the ownership and permissions
    of a file. The *umask()* system call sets a mask of permission bits that are always
    turned off when the calling process creates a file.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Three additional permission bits are used for files and directories. The set-user-ID
    and set-group-ID permission bits can be applied to program files to create programs
    that cause the executing process to gain privilege by assuming a different effective
    user or group identity (that of the program file). For directories residing on
    file systems mounted using the *nogrpid* (*sysvgroups*) option, the set-group-ID
    permission bit can be used to control whether new files created in the directory
    inherit their group ID from the process’s effective group ID or from the parent
    directory’s group ID. When applied to directories, the sticky permission bit acts
    as the restricted deletion flag.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: I-node flags control the various behaviors of files and directories. Although
    originally defined for *ext2*, these flags are now supported on several other
    file systems.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[File Permissions](ch15.html#file_permissions "File Permissions") contained
    several statements about the permissions required for various file-system operations.
    Use shell commands or write programs to verify or answer the following:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing all owner permissions from a file denies the file owner access, even
    though group and other do have access.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On a directory with read permission but not execute permission, the names of
    files in the directory can be listed, but the files themselves can’t be accessed,
    regardless of the permissions on them.
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What permissions are required on the parent directory and the file itself in
    order to create a new file, open a file for reading, open a file for writing,
    and delete a file? What permissions are required on the source and target directory
    to rename a file? If the target file of a rename operation already exists, what
    permissions are required on that file? How does setting the sticky permission
    bit (*chmod +t*) of a directory affect renaming and deletion operations?
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you expect any of a file’s three timestamps to be changed by the *stat()*
    system call? If not, explain why.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a system running Linux 2.6, modify the program in [Example 15-1](ch15.html#retrieving_and_interpreting_file_stat_in
    "Example 15-1. Retrieving and interpreting file stat information") (`t_stat.c`)
    so that the file timestamps are displayed with nanosecond accuracy.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *access()* system call checks permissions using the process’s real user
    and group IDs. Write a corresponding function that performs the checks according
    to the process’s effective user and group IDs.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As noted in [The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()"), *umask()* always sets the process
    umask and, at the same time, returns a copy of the old umask. How can we obtain
    a copy of the current process umask while leaving it unchanged?'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *chmod a+rX file* command enables read permission for all categories of
    user, and likewise enables execute permission for all categories of user if *file*
    is a directory or execute permission is enabled for any of the user categories
    for *file*, as demonstrated in the following example:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Write a program that uses *stat()* and *chmod()* to perform the equivalent of
    *chmod a+rX*.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a simple version of the *chattr(1)* command, which modifies file i-node
    flags. See the *chattr(1)* man page for details of the *chattr* command-line interface.
    (You don’t need to implement the *-R*, *-V*, and *-v* options.)
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
