- en: '**9**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Map Routes**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we can instantly get directions using sites like Google Maps, we forget
    that not long ago people often got lost driving to unfamiliar destinations. Now
    software plans our route for us and even alters the route mid-trip if an accident
    or road closure blocks our way.
  prefs: []
  type: TYPE_NORMAL
- en: In computing, this task is called *finding the shortest path*. Despite the name,
    the goal isn’t always to find the shortest path, but more generally to minimize
    the *cost*, where the definition of cost varies. If the cost is time, the software
    finds the fastest route. If the cost is distance, the software minimizes the mileage,
    truly finding the shortest path. By changing how cost is defined, the same software
    methods can find routes to match different goals.
  prefs: []
  type: TYPE_NORMAL
- en: '**What a Map Looks Like to Software**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although software can provide directions, it can’t actually read a map. Instead,
    it uses tables of data. To see how we get from a map to a table of data, let’s
    begin with [Figure 9-1](ch09.html#ch9fig1), which shows a portion of a city map
    for a simple routing problem. The goal is to find the quickest route from the
    corner of 3rd Street and West Avenue to the corner of 1st Street and Morris Avenue.
    The numbered arrows alongside the streets show the average driving time in seconds
    between intersections. Note that 1st Street and Morris Avenue are one-way streets.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: A simple routing problem: find the fastest route from 3rd and
    West to 1st and Morris.*'
  prefs: []
  type: TYPE_NORMAL
- en: To produce a data table that can be processed by software, we first reconceptualize
    the map as the *directed graph* shown in [Figure 9-2](ch09.html#ch9fig2). Here,
    the street intersections are represented as points labeled A through I. The arrows
    in [Figure 9-1](ch09.html#ch9fig1) become connections between points on the graph,
    known as *edges*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: The map from [Figure 9-1](ch09.html#ch9fig1) as a directed graph*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the directed graph, we put the data into the tabular form shown in [Table
    9-1](ch09.html#ch9tab1). This table contains all of the information from the map
    in [Figure 9-2](ch09.html#ch9fig2) that software needs to find the fastest route.
    In [Figure 9-2](ch09.html#ch9fig2), for example, travel time from A to B is 23
    seconds; the same information is provided by the first row of the table. Note
    that travel in impossible directions, such as from H to G, is not listed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** The Data from the Directed Graph of [Figure 9-2](ch09.html#ch9fig2)
    in Tabular Form'
  prefs: []
  type: TYPE_NORMAL
- en: '| **From** | **To** | **Time** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | B | 23 |'
  prefs: []
  type: TYPE_TB
- en: '| A | D | 19 |'
  prefs: []
  type: TYPE_TB
- en: '| B | A | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| B | C | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| B | E | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| C | B | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| D | A | 14 |'
  prefs: []
  type: TYPE_TB
- en: '| D | E | 17 |'
  prefs: []
  type: TYPE_TB
- en: '| D | G | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| E | B | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| E | D | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| E | F | 33 |'
  prefs: []
  type: TYPE_TB
- en: '| E | H | 21 |'
  prefs: []
  type: TYPE_TB
- en: '| F | C | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| F | E | 26 |'
  prefs: []
  type: TYPE_TB
- en: '| G | D | 35 |'
  prefs: []
  type: TYPE_TB
- en: '| G | H | 25 |'
  prefs: []
  type: TYPE_TB
- en: '| H | E | 35 |'
  prefs: []
  type: TYPE_TB
- en: '| H | I | 28 |'
  prefs: []
  type: TYPE_TB
- en: '| I | F | 14 |'
  prefs: []
  type: TYPE_TB
- en: '***Best-First Search***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’re ready to find the quickest route on the map, which means finding the
    lowest-cost path from A to I on our graph. Many methods exist for solving this
    problem; the variation I’ll describe is a type of algorithm called a *best-first
    search*. Calling this algorithm a “search” may be a little misleading, because
    this method doesn’t aim for the destination. Instead, at each step it finds the
    best new route from the starting point to *any* point it hasn’t already routed
    to. Eventually, this procedure stumbles upon a route to the destination, which
    will be the cheapest route possible from the start to the goal.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how best-first search works for our example. All routes starting at A
    must first travel to either B or D. The algorithm starts by comparing these two
    choices, as shown in [Figure 9-3](ch09.html#ch9fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: The first step in our best-first search. Starting from A, we can
    travel either to B or D.*'
  prefs: []
  type: TYPE_NORMAL
- en: In these figures, black circles mark the points we’ve found the best paths to,
    while gray circles indicate points we can reach directly from one of the marked
    (black) points. The numbers inside the circles represent the cost of the route
    to that point. In each step, the search examines all edges extending from marked
    to unmarked points to find the edge that produces the lowest-cost route. In this
    first step, the choice is between the A-to-B edge and the A-to-D edge. Because
    the travel time to D is less than the travel time to B, the lowest-cost route
    is from A to D, as shown in [Figure 9-4](ch09.html#ch9fig4).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just found the cheapest possible route from A to D. No matter what the
    rest of the graph looks like, it can’t contain a lower-cost route from A to D,
    because this is the lowest-cost route of *all* routes starting from A. In the
    same way, each step will produce a new route that will be the lowest-cost route
    possible from A to some other point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second step, there are four edges to consider: the A-to-B edge and the
    three edges extending from D. Again, the algorithm will choose the edge that creates
    the fastest new route. In considering the edges extending from D, we have to include
    the 19 seconds from A to D. For example, the time required to travel from A to
    E through D is the sum of the A-to-D edge time (19) and the D-to-E edge time (17),
    which is 36 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that one edge from D leads back to A. In [Figure 9-4](ch09.html#ch9fig4),
    the circle at the end of that edge is white to indicate that it will never be
    chosen. There’s no benefit in taking a round trip back to our starting point.
    More generally, once a point has been included in a route (marked black in the
    figures), later appearances of that point are ignored, because a better route
    to it has already been found.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the lowest-cost new route is made using the A-to-B edge. This
    brings us to the stage shown in [Figure 9-5](ch09.html#ch9fig5). Again, because
    we’ve found the lowest-cost route of all remaining routes, that makes this A-to-B
    route the fastest possible way to get from A to B.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: In the second step of our search, the best new route leads to
    D. Marking D exposes three new routing possibilities, one of which leads back
    to our starting point.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: The third step in our best-first search finds the best route to
    point B.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have six edges to consider next, although the edges leading back to A aren’t
    contenders. The best choice uses the B-to-C edge to make an A-to-C route of 30
    seconds, as shown in [Figure 9-6](ch09.html#ch9fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: The fourth step in our search finds the best route to point C.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the fastest route to C doesn’t help us reach our ultimate goal, though.
    From C, we can only return to B, to which we already know the fastest route.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the fastest new route is the one going through B to E, as shown
    in [Figure 9-7](ch09.html#ch9fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: The fifth step in our best-first search finds the best route to
    E.*'
  prefs: []
  type: TYPE_NORMAL
- en: This process continues until we have reached the state shown in [Figure 9-8](ch09.html#ch9fig8).
    At this stage, the lowest-cost new route uses the edge from H to I, which means
    we’ve finally identified the best route from A to I.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: The ninth and final step in our best-first search reaches point
    I.*'
  prefs: []
  type: TYPE_NORMAL
- en: As shown, the fastest route from A to I is A-B-E-H-I. Looking at our original
    map in [Figure 9-1](ch09.html#ch9fig1) and its graph equivalent in [Figure 9-2](ch09.html#ch9fig2),
    we can see that this corresponds to taking 3rd Street to Kentucky Avenue, taking
    a left on 1st Street, and driving one block to our destination.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reusing Prior Search Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, the best-first search found not only the fastest route from
    A to I, but also the fastest route to every other point on the map. Although this
    is an unusual result, the best-first process typically produces a surplus of information.
    At a minimum, the search results will also provide the best routes between intermediate
    points that lie along the route between the start and destination points. In our
    example, the best route from A to I contains the best routes from B to H, and
    from E to I, and so on. For this reason, the results of best-first searches can
    be stored for later use.
  prefs: []
  type: TYPE_NORMAL
- en: We can even use this data in searches involving points that weren’t part of
    the original map data. To see why, consider [Figure 9-9](ch09.html#ch9fig9). This
    is the same directed graph in [Figure 9-2](ch09.html#ch9fig2) except that it includes
    a new point, J, that has edges to A and B.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: The directed graph from [Figure 9-2](ch09.html#ch9fig2) with an
    additional point, J*'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we need to find the fastest route from J to I. Any route from J begins
    by going to either A or B. We already know the fastest routes from A and B to
    I from the results in [Figure 9-8](ch09.html#ch9fig8). The fastest route from
    A to I takes 83 seconds. The fastest route from B to I takes 60 seconds; we find
    this by subtracting the A-to-B edge time of 23 seconds from the total A-to-I time
    of 83 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the J-to-I route that starts by heading to A takes 102 seconds—19
    seconds to reach A, and 83 seconds to follow the best route from A to I. The route
    that heads directly to B takes 96 seconds: 36 seconds to reach B, and 60 seconds
    from there to reach I. Using the previous search results makes finding the fastest
    J-to-I route much simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding All the Best Routes at Once**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, then, storing past search results benefits future searches. This
    idea can be extended to efficiently find the best routes between any two points
    on a given map, which is known as the *all-pairs shortest paths* problem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Floyd’s Algorithm***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll solve the all-pairs shortest paths problem using *Floyd’s algorithm* (sometimes
    called the *Floyd-Warshall algorithm*), which starts with simple routes of individual
    edges, then builds longer routes by connecting the existing routes using each
    point on the map in turn. This method uses a grid, the initial state of which
    is shown in [Figure 9-10](ch09.html#ch9fig10). At each step in the process, the
    grid contains the costs of the best routes between every pair of points. At the
    start, the only known routes are the edges that directly connect points, the same
    data from [Figure 9-2](ch09.html#ch9fig2) and [Table 9-1](ch09.html#ch9tab1).
    For example, the 23 in row A, column B, represents the cost of travel from A to
    B. The cost is 0 where the “from” and “to” points are the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: The initial grid of numbers for Floyd’s algorithm. At this stage
    the only routes in the grid are the direct connections between points.*'
  prefs: []
  type: TYPE_NORMAL
- en: As the process continues, this grid will be filled in and modified. New routes
    will be added where none initially exist, such as from A to F. Routes with lower
    costs will replace existing routes; if we can find a way to get from G to D in
    less than 35 seconds, for example, we’ll replace the 35 currently in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: We start by considering point A as a route connector. From [Figure 9-10](ch09.html#ch9fig10),
    we can see that B and D have routes to A. Because A has routes back to B and D,
    A can connect B to D and D to B. These new routes are shown as gray squares in
    [Figure 9-11](ch09.html#ch9fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: Discovering new routes using point A as a connector*'
  prefs: []
  type: TYPE_NORMAL
- en: The cost of new routes is the sum of the costs of the two routes we are connecting.
    In [Figure 9-11](ch09.html#ch9fig11), the cost of the B-to-D route (34) is the
    cost of the B-to-A route (15) plus the cost of the A-to-D route (19), as indicated
    by the arrows. The cost of the D-to-B route (37) is computed the same way, as
    the sum of the D-to-A route (14) and the A-to-B route (23).
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we use point B to connect existing routes. This produces a
    whopping eight new routes, as shown in [Figure 9-12](ch09.html#ch9fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-12: Discovering new routes using point B as a connector*'
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous step, the cost of each new route is the sum of the costs
    of the two routes we are connecting. For example, the cost of the new A-to-E route
    (34) is the sum of the A-to-B cost (23) and the B-to-E cost (11).
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, using C to connect existing routes reveals three new routes,
    as shown in [Figure 9-13](ch09.html#ch9fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-13: Discovering new routes using point C as a connector*'
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we have our first instance of a *better* route. Previously
    we found a 33-second route from E to A. In this step, we discover a 23-second
    route from E to A through D, and update the grid with the lower cost. Nine new
    routes are also found, bringing us to the state shown in [Figure 9-14](ch09.html#ch9fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-14: Discovering new routes using point D as a connector*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This process continues, using the points E through I to connect routes in turn,
    resulting in the complete grid shown in [Figure 9-15](ch09.html#ch9fig15). By
    relating the points back to the street names on the original map, routing software
    can use this grid to provide the fastest time between any two locations on the
    map. If you want to know how many seconds it should take to get from the corner
    of 1st and West to the corner of 3rd and Morris, the software will translate this
    into a query about the G-to-C route on the graph. Then the answer can be found
    right there in the grid: 77 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-15: The complete grid produced by Floyd’s algorithm, showing the
    fastest time possible from each point to every other point*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Storing Route Directions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What this grid *doesn’t* tell you, as you may have noticed, is what that fastest
    route is—only how much time it takes. For example, you can see that the fastest
    route from A to I takes 83 seconds, but does that route begin by going east or
    south, and where do you make the first turn? In order to record the route itself,
    we must record the initial direction of the routes when updating route times in
    the grid.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-16](ch09.html#ch9fig16) shows the starting grid. As before, the grid
    will be used to store the costs of the best routes found so far, but now it will
    also store the initial direction of travel for each route. This starting grid
    contains just the edges of the original graph. The 23 and B in the second column
    of the first row means the best route from A to B costs 23 and starts by heading
    toward B.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-16: The initial grid for Floyd’s algorithm, amended to store the
    direction of travel for each route*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 9-17](ch09.html#ch9fig17), we use A to connect existing routes,
    as we did in [Figure 9-11](ch09.html#ch9fig11). But now, adding or updating a
    route in the grid means recording the direction as well. The new route from B
    to D, for example, begins by going to A. The logic is: “We’ve just discovered
    a route from B to D that goes through A. The fastest known route from B to A heads
    directly to A. Therefore, the route from B to D must also start by going to A.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-17: Discovering new routes using point A as a connector*'
  prefs: []
  type: TYPE_NORMAL
- en: Skipping over the steps for B and C, [Figure 9-18](ch09.html#ch9fig18) shows
    the grid just after we’ve added the routes for D. Here we’ve found a new route
    from B to G that takes 52 seconds. Because this new route goes through D, the
    route must begin the same way the route to D begins—by traveling to A.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-18: Discovering new routes using point D as a connector*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-19](ch09.html#ch9fig19) shows the completed grid, with the times
    removed for clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-19: The complete routing grid produced by Floyd’s algorithm, showing
    the direction of travel. The fastest route from A to I is highlighted.*'
  prefs: []
  type: TYPE_NORMAL
- en: The fastest route from A to I is highlighted in the grid. We start at row A,
    column I, and see the fastest route from A to I starts by going to B. So then
    we look at row B and see the fastest route from B to I heads to E. The route from
    E heads to H, and the route from H reaches I. Using this grid is like stopping
    at every street corner and asking, “Which way should I turn?”
  prefs: []
  type: TYPE_NORMAL
- en: '**The Future of Routing**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today’s software can provide accurate directions in an instant, so what can
    tomorrow’s mapping software possibly do better?
  prefs: []
  type: TYPE_NORMAL
- en: Improvements in mapping will come from improvements in data. For example, if
    the software has access to hourly traffic data, it can tailor directions to the
    time of the trip.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time traffic data may also be integrated into mapping software. For example,
    most mapping programs don’t know about traffic issues until the user requests
    a new route. In the future, your mapping software may find out about accidents
    and road closures before you do and route you around the problems. Weather data
    may also be included to provide more accurate estimates of travel time, and to
    accommodate the preferences of drivers who wish to avoid driving in heavy rain
    or other troubling conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Routing is just a small part of a larger area of software called *geographic
    information systems (GIS)*, which uses software to answer questions about maps
    and location-tagged data. Some GIS tasks have nothing to do with routing, such
    as determining if an area contains enough potential customers to support a new
    grocery store. But many interesting GIS projects combine the map routing concepts
    from this chapter with data about what’s inside buildings along a map’s roadways.
    By tracking where schoolchildren live, for example, GIS software can plan the
    most efficient routes for school buses.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, routing software may expand to encompass more of the abilities
    of general GIS tools. When you need a route for a long drive out of town, the
    software may not provide just the turns you need to take, but also highlight places
    where you might want to stop, like the best-priced gas stations and the restaurants
    that serve your favorite food.
  prefs: []
  type: TYPE_NORMAL
