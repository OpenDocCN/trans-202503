["```\npackage tftp\n\nimport (\n    \"bytes\"\n    \"encoding/binary\"\n    \"errors\"\n    \"io\"\n    \"strings\"\n)\n\nconst (\n    DatagramSize = 1516 // the maximum supported datagram size\n    BlockSize = 2DatagramSize â€“ 4 // the DatagramSize minus a 4-byte header\n)\n\n3 type OpCode uint16\n\nconst (\n    OpRRQ OpCode = iota + 1\n    _            // no WRQ support\n    OpData\n    OpAck\n    OpErr\n)\n\n4 type ErrCode uint16\n\nconst (\n    ErrUnknown ErrCode = iota\n    ErrNotFound\n    ErrAccessViolation\n    ErrDiskFull\n    ErrIllegalOp\n    ErrUnknownID\n    ErrFileExists\n    ErrNoUser\n)\n```", "```\n`--snip--`\n\n1 type ReadReq struct {\n    Filename string\n    Mode     string\n}\n\n// Although not used by our server, a client would make use of this method.\nfunc (q ReadReq) MarshalBinary() ([]byte, error) {\n    mode := \"octet\"\n    if q.Mode != \"\" {\n        mode = q.Mode\n    }\n\n    // operation code + filename + 0 byte + mode + 0 byte\n    cap := 2 + 2 + len(q.Filename) + 1 + len(q.Mode) + 1\n\n    b := new(bytes.Buffer)\n    b.Grow(cap)\n\n    err := 2binary.Write(b, binary.BigEndian, OpRRQ) // write operation code\n    if err != nil {\n        return nil, err\n    }\n\n    _, err = b.WriteString(q.Filename) // write filename\n    if err != nil {\n        return nil, err\n    }\n\n    err = 3b.WriteByte(0) // write 0 byte\n    if err != nil {\n return nil, err\n    }\n\n    _, err = b.WriteString(mode) // write mode\n    if err != nil {\n        return nil, err\n    }\n\n    err = 3b.WriteByte(0) // write 0 byte\n    if err != nil {\n        return nil, err\n    }\n\n    return b.Bytes(), nil\n}\n```", "```\n`--snip--`\n\nfunc (q *ReadReq) 1UnmarshalBinary(p []byte) error {\n    r := bytes.NewBuffer(p)\n\n    var code OpCode\n\n    err := 2binary.Read(r, binary.BigEndian, &code) // read operation code\n    if err != nil {\n        return err\n    }\n\n    if code != OpRRQ {\n        return errors.New(\"invalid RRQ\")\n    }\n\n    q.Filename, err = 3r.ReadString(0) // read filename\n    if err != nil {\n        return errors.New(\"invalid RRQ\")\n    }\n\n    q.Filename = 4strings.TrimRight(q.Filename, \"\\x00\") // remove the 0-byte\n    if len(q.Filename) == 0 {\n        return errors.New(\"invalid RRQ\")\n    }\n\n    q.Mode, err = r.ReadString(0) // read mode\n    if err != nil {\n return errors.New(\"invalid RRQ\")\n    }\n\n    q.Mode = strings.TrimRight(q.Mode, \"\\x00\") // remove the 0-byte\n    if len(q.Mode) == 0 {\n        return errors.New(\"invalid RRQ\")\n    }\n\n    actual := strings.ToLower(q.Mode) // enforce octet mode\n    if actual != \"octet\" {\n        return errors.New(\"only binary transfers supported\")\n    }\n\n    return nil\n}\n```", "```\n`--snip--`\n\n1 type Data struct {\n    Block   uint16\n    Payload io.Reader\n}\n\n2 func (d *Data) MarshalBinary() ([]byte, error) {\n    b := new(bytes.Buffer)\n    b.Grow(DatagramSize)\n\n    d.Block++ // block numbers increment from 1\n\n    err := binary.Write(b, binary.BigEndian, OpData) // write operation code\n    if err != nil {\n        return nil, err\n    }\n\n    err = binary.Write(b, binary.BigEndian, d.Block) // write block number\n    if err != nil {\n        return nil, err\n    }\n\n    // write up to BlockSize worth of bytes\n    _, err = 3io.CopyN(b, d.Payload, BlockSize)\n    if err != nil && err != io.EOF {\n        return nil, err\n    }\n\n    return b.Bytes(), nil\n}\n```", "```\n`--snip--`\n\nfunc (d *Data) UnmarshalBinary(p []byte) error {\n    1 if l := len(p); l < 4 || l > DatagramSize {\n        return errors.New(\"invalid DATA\")\n    }\n\n    var opcode\n\n    err := 2binary.Read(bytes.NewReader(p[:2]), binary.BigEndian, &opcode)\n    if err != nil || opcode != OpData {\n        return errors.New(\"invalid DATA\")\n    }\n\n    err = 3binary.Read(bytes.NewReader(p[2:4]), binary.BigEndian, &d.Block)\n    if err != nil {\n        return errors.New(\"invalid DATA\")\n    }\n\n    d.Payload = 4bytes.NewBuffer(p[4:])\n\n    return nil\n}\n```", "```\n`--snip--`\n\n1 type Ack uint16\n\nfunc (a Ack) MarshalBinary() ([]byte, error) {\n    cap := 2 + 2 // operation code + block number\n\n    b := new(bytes.Buffer)\n    b.Grow(cap)\n\n    err := binary.Write(b, binary.BigEndian, OpAck) // write operation code\n    if err != nil {\n        return nil, err\n    }\n\n    err = binary.Write(b, binary.BigEndian, a) // write block number\n    if err != nil {\n        return nil, err\n    }\n\n    return b.Bytes(), nil\n}\n\nfunc (a *Ack) UnmarshalBinary(p []byte) error {\n    var code OpCode\n\n    r := bytes.NewReader(p)\n\n    err := binary.Read(r, binary.BigEndian, &code) // read operation code\n    if err != nil {\n        return err\n    }\n\n    if code != OpAck {\n        return errors.New(\"invalid ACK\")\n    }\n\n return binary.Read(r, binary.BigEndian, a) // read block number\n}\n```", "```\n`--snip--`\n\n1 type Err struct {\n    Error   ErrCode\n    Message string\n}\n\nfunc (e Err) MarshalBinary() ([]byte, error) {\n    // operation code + error code + message + 0 byte\n    cap := 2 + 2 + len(e.Message) + 1\n\n    b := new(bytes.Buffer)\n    b.Grow(cap)\n\n    err := binary.Write(b, binary.BigEndian, OpErr) // write operation code\n    if err != nil {\n        return nil, err\n    }\n\n    err = binary.Write(b, binary.BigEndian, e.Error) // write error code\n    if err != nil {\n        return nil, err\n    }\n\n    _, err = b.WriteString(e.Message) // write message\n    if err != nil {\n return nil, err\n    }\n\n    err = b.WriteByte(0) // write 0 byte\n    if err != nil {\n        return nil, err\n    }\n\n    return b.Bytes(), nil\n}\n```", "```\n`--snip--`\n\nfunc (e *Err) UnmarshalBinary(p []byte) error {\n    r := bytes.NewBuffer(p)\n\n    var code OpCode\n\n    err := 1binary.Read(r, binary.BigEndian, &code) // read operation code\n    if err != nil {\n        return err\n    }\n\n    if code != OpErr {\n        return errors.New(\"invalid ERROR\")\n    }\n\n    err = 2binary.Read(r, binary.BigEndian, &e.Error) // read error message\n    if err != nil {\n        return err\n    }\n\n    e.Message, err = 3r.ReadString(0)\n    e.Message = 4strings.TrimRight(e.Message, \"\\x00\") // remove the 0-byte\n\n    return err\n}\n```", "```\npackage tftp\n\nimport (\n    \"bytes\"\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"net\"\n    \"time\"\n)\n\ntype Server struct {\n    1 Payload []byte // the payload served for all read requests\n    2 Retries uint8 // the number of times to retry a failed transmission\n    3 Timeout time.Duration // the duration to wait for an acknowledgment\n}\n\nfunc (s Server) ListenAndServe(addr string) error {\n    conn, err := net.ListenPacket(\"udp\", addr)\n    if err != nil {\n        return err\n    }\n    defer func() { _ = conn.Close() }()\n\n    log.Printf(\"Listening on %s ...\\n\", conn.LocalAddr())\n\n    return s.Serve(conn)\n}\n\nfunc (s *Server) 4Serve(conn net.PacketConn) error {\n    if conn == nil {\n        return errors.New(\"nil connection\")\n    }\n\n    if s.Payload == nil {\n        return errors.New(\"payload is required\")\n    }\n\n if s.Retries == 0 {\n        s.Retries = 10\n    }\n\n    if s.Timeout == 0 {\n        s.Timeout = 6 * time.Second\n    }\n\n    var rrq ReadReq\n\n    for {\n        buf := make([]byte, DatagramSize)\n\n        _, addr, err := conn.ReadFrom(buf)\n        if err != nil {\n            return err\n        }\n\n        err = 5rrq.UnmarshalBinary(buf)\n        if err != nil {\n            log.Printf(\"[%s] bad request: %v\", addr, err)\n            continue\n        }\n\n        6 go s.handle(addr.String(), rrq)\n    }\n}\n```", "```\n`--snip--`\n\n1 func (s Server) handle(clientAddr string, rrq ReadReq) {\n    log.Printf(\"[%s] requested file: %s\", clientAddr, rrq.Filename)\n\n    conn, err := 2net.Dial(\"udp\", clientAddr)\n    if err != nil {\n        log.Printf(\"[%s] dial: %v\", clientAddr, err)\n        return\n    }\n    defer func() { _ = conn.Close() }()\n\n    var (\n        ackPkt  Ack\n        errPkt  Err\n        dataPkt = 3Data{Payload: bytes.NewReader(s.Payload)}\n        buf     = make([]byte, DatagramSize)\n    )\n\nNEXTPACKET:\n    4 for n := DatagramSize; n == DatagramSize; {\n        data, err := dataPkt.MarshalBinary()\n        if err != nil {\n            log.Printf(\"[%s] preparing data packet: %v\", clientAddr, err)\n            return\n        }\n\n    RETRY:\n        5 for i := s.Retries; i > 0; i-- {\n            6 n, err = conn.Write(data) // send the data packet\n            if err != nil {\n                log.Printf(\"[%s] write: %v\", clientAddr, err)\n                return\n            }\n\n            // wait for the client's ACK packet\n            _ = conn.SetReadDeadline(time.Now().Add(s.Timeout))\n\n            _, err = conn.Read(buf)\n            if err != nil {\n                if nErr, ok := err.(net.Error); ok && nErr.Timeout() {\n                    continue RETRY\n                }\n\n                log.Printf(\"[%s] waiting for ACK: %v\", clientAddr, err)\n                return\n            }\n\n            switch {\n            case ackPkt.UnmarshalBinary(buf) == nil:\n                7 if uint16(ackPkt) == dataPkt.Block {\n                    // received ACK; send next data packet\n                    continue NEXTPACKET\n }\n            case errPkt.UnmarshalBinary(buf) == nil:\n                log.Printf(\"[%s] received error: %v\",\n                    clientAddr, errPkt.Message)\n                return\n            default:\n                log.Printf(\"[%s] bad packet\", clientAddr)\n            }\n        }\n\n        log.Printf(\"[%s] exhausted retries\", clientAddr)\n        return\n    }\n\n    log.Printf(\"[%s] sent %d blocks\", clientAddr, dataPkt.Block)\n}\n```", "```\npackage main\n\nimport (\n    \"flag\"\n    \"io/ioutil\"\n    \"log\"\n\n    \"github.com/awoodbeck/gnp/ch06/tftp\"\n)\n\nvar (\n    address = flag.String(\"a\", \"127.0.0.1:69\", \"listen address\")\n    payload = flag.String(\"p\", \"payload.svg\", \"file to serve to clients\")\n)\n\nfunc main() {\n    flag.Parse()\n\n    p, err := 1ioutil.ReadFile(*payload)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    s := 2tftp.Server{Payload: p}\n    3 log.Fatal(s.ListenAndServe(*address))\n}\n```", "```\nMicrosoft Windows [Version 10.0.18362.449]\n(c) 2019 Microsoft Corporation. All rights reserved.\n\nC:\\Users\\User\\gnp\\ch06\\tftp\\tftp>**go run tftp.go**\n2006/01/02 15:04:05 Listening on 127.0.0.1:69 ...\n```", "```\nMicrosoft Windows [Version 10.0.18362.449]\n(c) 2019 Microsoft Corporation. All rights reserved.\n\nC:\\Users\\User>**tftp -i 127.0.0.1 GET test.svg**\nTransfer successful: 75352 bytes in 1 second(s), 75352 bytes/s\n```", "```\nMicrosoft Windows [Version 10.0.18362.449]\n(c) 2019 Microsoft Corporation. All rights reserved.\n\nC:\\Users\\User\\gnp\\ch06\\tftp\\tftp>**go run tftp.go**\n2006/01/02 15:04:05 Listening on 127.0.0.1:69 ...\n2006/01/02 15:04:05 [127.0.0.1:57944] requested file: test.svg\n2006/01/02 15:04:05 [127.0.0.1:57944] sent 148 blocks\n```", "```\npackage main\n\nimport (\n    \"crypto/sha512\"\n    \"flag\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n)\n\nfunc init() {\n    flag.Usage = func() {\n        fmt.Printf(\"Usage: %s file...\\n\", os.Args[0])\n        flag.PrintDefaults()\n    }\n}\n\nfunc main() {\n    flag.Parse()\n    for _, file := range 1flag.Args() {\n        fmt.Printf(\"%s  %s\\n\", checksum(file), file)\n    }\n}\n\nfunc checksum(file string) string {\n    b, err := 2ioutil.ReadFile(file)\n    if err != nil {\n        return err.Error()\n    }\n\n    return fmt.Sprintf(\"%x\", 3sha512.Sum512_256(b))\n}\n```", "```\nMicrosoft Windows [Version 10.0.18362.449]\n(c) 2019 Microsoft Corporation. All rights reserved.\n\nC:\\Users\\User\\dev\\gnp\\ch06>**go build sha512-256sum\\sha512-256sum.go**\n\nC:\\Users\\User\\dev\\gnp\\ch06>**sha512-256sum \\Users\\User\\test.svg**\n\n\\Users\\User\\test.svg =>\n1 3f5794c522e83b827054183658ce63cb701dc49f4e59335f08b5c79c56873969\n\nC:\\Users\\User\\dev\\gnp\\ch06>**sha512-256sum tftp\\tftp\\payload.svg**\n\ntftp\\tftp\\payload.svg =>\n2 3f5794c522e83b827054183658ce63cb701dc49f4e59335f08b5c79c56873969\n```"]