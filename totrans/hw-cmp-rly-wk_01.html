<html><head></head><body>
<span epub:type="pagebreak" id="page_1"/>&#13;
<h2 class="h2"><strong><span class="big">1</span><br/>COMPUTING CONCEPTS</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">Computers are everywhere now: in our homes, our schools, our offices—you might find a computer in your pocket, on your wrist, or even in your refrigerator. It’s easier than ever to find and use computers, but few people today really understand how computers work. This isn’t surprising, since learning the complexities of computing can be overwhelming. The goal of this book is to lay out the foundational principles of computing in a way that anyone with curiosity, and a bit of a technical bent, can follow. Before we dig into the nuts and bolts of how computers work, let’s take some time to get familiar with some major concepts of computing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_2"/>In this chapter we’ll begin by discussing the definition of a computer. From there, we’ll cover the differences between analog and digital data and then explore number systems and the terminology used to describe digital data.</p>&#13;
<h3 class="h3" id="lev1_5"><strong>Defining a Computer</strong></h3>&#13;
<p class="noindent">Let’s start with a basic question: what is a computer? When people hear the word <em>computer</em>, most think of a laptop or desktop, sometimes referred to as a personal computer or PC. That is one class of device that this book covers, but let’s think a bit more broadly. Consider smartphones. Smartphones are certainly computers; they perform the same types of operations as PCs. In fact, for many people today, a smartphone is their primary computing device. Most computer users today also rely on the internet, which is powered by servers—another type of computer. Every time you visit a website or use an app that connects to the internet, you’re interacting with one or more servers connected to a global network. Video game consoles, fitness trackers, smart watches, smart televisions … all of these are computers!</p>&#13;
<p class="indent">A <em>computer</em> is any electronic device that can be programmed to carry out a set of logical instructions. With that definition in mind, it becomes clear that many modern devices are in fact computers!</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch1ex1"><strong>EXERCISE 1-1: FIND THE COMPUTERS IN YOUR HOME</strong></p>&#13;
<p class="exercise-para">Take a moment and see how many computers you can identify in your home. When I did this exercise with my family, we quickly found about 30 devices!</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_6"><strong>Analog and Digital</strong></h3>&#13;
<p class="noindent">You’ve probably heard a computer described as a digital device. This is in contrast to an analog device, such as a mechanical clock. But what do these two terms really mean? Understanding the differences between analog and digital is foundational to understanding computing, so let’s take a closer look at these two concepts.</p>&#13;
<h4 class="h4" id="lev2_1"><strong><em>The Analog Approach</em></strong></h4>&#13;
<p class="noindent">Look around you. Pick an object. Ask yourself: What color is it? What size is it? How much does it weigh? By answering these questions, you’re describing the attributes, or <em>data</em>, of that object. Now, pick a different object and answer the same questions. If you repeat this process for even more objects, you’ll find that for each question, the potential answers are numerous. You might pick up a red object, a yellow object, or a blue object. Or the object <span epub:type="pagebreak" id="page_3"/>could be a mix of the primary colors. This type of variation does not only apply to color. For a given property, the variations found across the objects in our world are potentially infinite.</p>&#13;
<p class="indent">It’s one thing to describe an object verbally, but let’s say you want to measure one of its attributes more precisely. If you wanted to measure an object’s weight, for example, you could put it on a scale. The scale, responding to the weight placed upon it, would move a needle along a numbered line, stopping when it reaches a position that corresponds to the weight. Read the number from the scale and you have the object’s weight.</p>&#13;
<p class="indent">This kind of measurement is common, but let’s think a little more about how we’re measuring this data. The position of the needle on the scale isn’t actually the weight; it’s a representation of the weight. The numbered line that the needle points to provides a means for us to easily convert between the needle’s position, representing a weight, and the numeric value of that weight. In other words, though the weight is an attribute of the object, here we can understand that attribute through something else: the position of the needle along the line. The needle’s position changes proportionally in response to the weight placed on the scale. Thus, the scale is working as an <em>analogy</em> where we understand the weight of the object through the needle’s position on the line. This is why we call this method of measuring the <em>analog</em> approach.</p>&#13;
<p class="indent">Another example of an analog measuring tool is a mercury thermometer. Mercury’s volume increases with temperature. Thermometer manufacturers utilize this property by placing mercury in a glass tube with markings that correspond to the expected volume of the mercury at various temperatures. Thus, the position of mercury in the tube serves as a representation of temperature. Notice that for both of these examples (a scale and a thermometer), when we make a measurement, we can use markings on the instrument to convert a position to a specific numeric value. But the value we read from the instrument is just an approximation. The true position of the needle or mercury can be anywhere within the range of the instrument, and we round up or down to the nearest marked value. So although it may seem that these tools can produce only a finite set of measurements, that’s a limitation imposed by the conversion to a number, not by the analogy itself.</p>&#13;
<p class="indent">Throughout most of human history, humans have measured things using an analog approach. But people don’t only use analog approaches for measurement. They’ve also devised clever ways to store data in an analog fashion. A phonograph record uses a modulated groove as an analog representation of audio that was recorded. The groove’s shape changes along its path in a way that corresponds to changes in the shape of the audio waveform over time. The groove isn’t the audio itself, but it’s an analogy of the original sound’s waveform. Film-based cameras do something similar by briefly exposing film to light from a camera lens, leading to a chemical change in the film. The chemical properties of the film are not the image itself, but a representation of the captured image, an analogy of the image.</p>&#13;
<h4 class="h4" id="lev2_2"><strong><em><span epub:type="pagebreak" id="page_4"/>Going Digital</em></strong></h4>&#13;
<p class="noindent">What does all this have to do with computing? It turns out that all those analog representations of data are hard for computers to deal with. The types of analog systems used are so different and variable that creating a common computing device that can understand all of them is nearly impossible. For example, creating a machine that can measure the volume of mercury is a very different task than creating a machine that can read the grooves on a vinyl disc. Additionally, computers require highly reliable and accurate representations of certain types of data, such as numeric data sets and software programs. Analog representations of data can be difficult to measure precisely, tend to decay over time, and lose fidelity when copied. Computers need a way to represent all types of data in a format that can be accurately processed, stored, and copied.</p>&#13;
<p class="indent">If we don’t want to represent data as something with potentially infinitely varying analog values, what can we do? We can use a digital approach instead. A <em>digital</em> system represents data as a sequence of symbols, where each symbol is one of a limited set of values. Now, that description may sound a bit formal and a bit confusing, so rather than go deep on the theory of digital systems, I’ll explain what this means in practice. In almost all of today’s computers, data is represented with combinations of two symbols: 0 and 1. That’s it. Although a digital system could use more than two symbols, adding more symbols would increase the complexity and cost of the system. A set of only two symbols allows for simplified hardware and improved reliability. All data in most modern computing devices is represented as a sequence of 0s and 1s. From this point forward in this book, when I talk about digital computers, you can assume that I am talking about systems that only deal with 0s and 1s and not some other set of symbols. Nice and simple!</p>&#13;
<p class="indent">It’s a point worth repeating: everything on your computer is stored as 0s and 1s. The last photo you took on your smartphone? Your device stored the photo as a sequence of 0s and 1s. The song you streamed from the internet? 0s and 1s. The document you wrote on your computer? 0s and 1s. The app you installed? It was a bunch of 0s and 1s. The website you visited? 0s and 1s.</p>&#13;
<p class="indent">It may sound limiting to say that we can only use 0 and 1 to represent the infinite values found in nature. How can a musical recording or a detailed photograph be distilled down to 0s and 1s? Many find it counterintuitive that such a limited “vocabulary” can be used to express complex ideas. The key here is that digital systems use a <em>sequence</em> of 0s and 1s. A digital photograph, for example, usually consists of millions of 0s and 1s.</p>&#13;
<p class="indent">So what exactly are these 0s and 1s? You may see other terms used to describe these 0s and 1s: false and true, off and on, low and high, and so forth. This is because the computer doesn’t literally store the number <em>0</em> or <em>1</em>. It stores a sequence of entries where each entry in the sequence can have only two possible states. Each entry is like a light switch that is either on or off. In practice, these sequences of 1s and 0s are stored in various ways. On a CD or DVD, the 0s and 1s are stored on the disc as bumps (0) or flat spaces (1). On a flash drive, the 1s and 0s are stored as electrical charges. A hard disk drive stores the 0s and 1s using magnetization. As you’ll see in <a href="ch04.xhtml">Chapter 4</a>, digital circuits represent 0s and 1s using voltage levels.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_5"/>Before we move on, one final note on the term <em>analog</em>—it’s often used to simply mean “not digital.” For example, engineers may speak of an “analog signal,” meaning a signal that varies continuously and doesn’t align to digital values. In other words, it’s a non-digital signal but doesn’t necessarily represent an analogy of something else. So, when you see the term <em>analog</em>, consider that it might not always mean what you think.</p>&#13;
<h3 class="h3" id="lev1_7"><strong>Number Systems</strong></h3>&#13;
<p class="noindent">So far, we’ve established that computers are digital machines that deal with 0s and 1s. For many people, this concept seems strange; they’re used to having 0 through 9 at their disposal when representing numbers. If we constrain ourselves to only two symbols, rather than ten, how should we represent large numbers? To answer that question, let’s back up and review an elementary school math topic: number systems.</p>&#13;
<h4 class="h4" id="lev2_3"><strong><em>Decimal Numbers</em></strong></h4>&#13;
<p class="noindent">We typically write numbers using something called <em>decimal place-value notation</em>. Let’s break that down. <em>Place-value notation</em> (or <em>positional notation</em>) means that each position in a written number represents a different order of magnitude; <em>decimal</em>, or <em>base 10</em>, means that the orders of magnitude are factors of 10, and each place can have one of ten different symbols, 0 through 9. Look at the example of place-value notation in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>.</p>&#13;
<div class="image" id="ch1fig1"><img src="../images/fig1-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 1-1: Two hundred seventy-five represented in decimal place-value notation</em></p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>, the number two hundred seventy-five is written in decimal notation as 275. The 5 is in the ones place, meaning its value is 5 × 1 = 5. The 7 is in the tens place, meaning its value is 7 × 10 = 70. The 2 is in the hundreds place, meaning its value is 2 × 100 = 200. The total value is the sum of all the places: 5 + 70 + 200 = 275.</p>&#13;
<p class="indent">Easy, right? You’ve probably understood this since first grade. But let’s examine this a bit closer. Why is the rightmost place the ones place? And why is the next place the tens place, and so on? It’s because we are working in decimal, or base 10, and therefore each place is a power of ten—in other words, 10 multiplied by itself a certain number of times. As seen in <a href="ch01.xhtml#ch1fig2">Figure 1-2</a>, the rightmost place is 10 raised to 0, which is 1, because any number raised to 0 is 1. The next place is 10 raised to 1, which is 10, and the next place is 10 raised to 2 (10 × 10), which is 100.</p>&#13;
<span epub:type="pagebreak" id="page_6"/>&#13;
<div class="image" id="ch1fig2"><img src="../images/fig1-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 1-2: In decimal place-value notation, each place is a power of ten.</em></p>&#13;
<p class="indent">If we needed to represent a number larger than 999 in decimal, we’d add another place to the left, the thousands place, and its weight would be equal to 10 raised to 3 (10 × 10 × 10), which is 1,000. This pattern continues so that we can represent any large whole number by adding more places as needed.</p>&#13;
<p class="indent">We’ve established why the various places have certain weights, but let’s keep digging. Why does each place use the symbols 0 through 9? When working in decimal, we can only have ten symbols, because by definition each place can only represent ten different values. 0 through 9 are the symbols that are currently used, but really any set of ten unique symbols could be used, with each symbol corresponding to a certain numeric value.</p>&#13;
<p class="indent">Most humans prefer decimal, base 10, as a number system. Some say this is because we have ten fingers and ten toes, but whatever the reason, in the modern world most people read, write, and think of numbers in decimal. Of course, that’s just a convention we’ve collectively chosen to represent numbers. As we covered earlier, that convention doesn’t apply to computers, which instead use only two symbols. Let’s see how we can apply the principles of the place-value system while constraining ourselves to only two symbols.</p>&#13;
<h4 class="h4" id="lev2_4"><strong><em>Binary Numbers</em></strong></h4>&#13;
<p class="noindent">The number system consisting of only two symbols is <em>base 2</em>, or <em>binary</em>. Binary is still a place-value system, so the fundamental mechanics are the same as decimal, but there are a couple of changes. First, each place represents a power of 2, rather than a power of 10. Second, each place can only have one of two symbols, rather than ten. Those two symbols are 0 and 1. <a href="ch01.xhtml#ch1fig3">Figure 1-3</a> has an example of how we’d represent a number using binary.</p>&#13;
<div class="image" id="ch1fig3"><img src="../images/fig1-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 1-3: Five decimal represented in binary place-value notation</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_7"/>In <a href="ch01.xhtml#ch1fig3">Figure 1-3</a>, we have a binary number: 101. That may look like one hundred and one to you, but when dealing in binary, this is actually a representation of five! If you wish to verbally say it, “one zero one binary” would be a good way to communicate what is written.</p>&#13;
<p class="indent">Just like in decimal, each place has a weight equal to the base raised to various powers. Since we are in base 2, the rightmost place is 2 raised to 0, which is 1. The next place is 2 raised to 1, which is 2, and the next place is 2 raised to 2 (2 × 2), which is 4. Also, just like in decimal, to get the total value, we multiply the symbol in each place by the place-value weight and sum the results. So, starting from the right, we have (1 × 1) + (0 × 2) + (1 × 4) = 5.</p>&#13;
<p class="indent">Now you can try converting from binary to decimal yourself.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch1ex2"><strong>EXERCISE 1-2: BINARY TO DECIMAL</strong></p>&#13;
<p class="exercise-para">Convert these numbers, represented in binary, to their decimal equivalents.</p>&#13;
<p class="exercise-para">    10 (binary) = ______ (decimal)</p>&#13;
<p class="exercise-para">  111 (binary) = ______ (decimal)</p>&#13;
<p class="exercise-para">1010 (binary) = ______ (decimal)</p>&#13;
</div>&#13;
<p class="indent">You can check your answers in <a href="appa.xhtml">Appendix A</a>. Did you get them right? The last one might have been a bit tricky, since it introduced another place to the left, the eights place. Now, try going the other way around, from decimal to binary.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch1ex3"><strong>EXERCISE 1-3: DECIMAL TO BINARY</strong></p>&#13;
<p class="exercise-para">Convert these numbers, represented in decimal, to their binary equivalents.</p>&#13;
<p class="exercise-para">  3 (decimal) = ______ (binary)</p>&#13;
<p class="exercise-para">  8 (decimal) = ______ (binary)</p>&#13;
<p class="exercise-para">14 (decimal) = ______ (binary)</p>&#13;
</div>&#13;
<p class="indent">I hope you got those correct too! Right away, you can see that dealing with both decimal and binary at the same time can be confusing, since a number like 10 represents ten in decimal or two in binary. From this point forward in the book, if there’s a chance of confusion, binary numbers will be written with a 0b prefix. I’ve chosen the 0b prefix because several programming languages use this approach. The leading 0 (zero) character indicates a numeric value and the b is short for binary. As an example, 0b10 represents two in binary, whereas 10, with no prefix, means ten in decimal.</p>&#13;
<h3 class="h3" id="lev1_8"><strong><span epub:type="pagebreak" id="page_8"/>Bits and Bytes</strong></h3>&#13;
<p class="noindent">A single place or symbol in a decimal number is called a <em>digit</em>. A decimal number like 1,247 is a four-digit number. Similarly, a single place or symbol in a binary number is called a <em>bit</em> (a binary digit). Each bit can either be 0 or 1. A binary number like 0b110 is a 3-bit number.</p>&#13;
<p class="indent">A single bit cannot convey much information; it’s either off or on, 0 or 1. We need a sequence of bits to represent anything more complex. To make these sequences of bits easier to manage, computers group bits together in sets of eight, called <em>bytes</em>. Here are some examples of bits and bytes (leaving off the 0b prefix since they are all binary):</p>&#13;
<p class="block"><strong>1</strong>   That’s a bit.</p>&#13;
<p class="block"><strong>0</strong>   That is also a bit.</p>&#13;
<p class="block"><strong>11001110</strong>   That’s a byte, or 8 bits.</p>&#13;
<p class="block"><strong>00111000</strong>   That’s also a byte!</p>&#13;
<p class="block"><strong>10100101</strong>   Yet another byte.</p>&#13;
<p class="block"><strong>0011100010100101</strong>   That’s two bytes, or 16 bits.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Fun fact: A 4-bit number, half a byte, is sometimes called a</em> nibble <em>(sometimes spelled</em> nybble <em>or</em> nyble).</p>&#13;
</div>&#13;
<p class="indent">So how much data can we store in a byte? Another way to think about this question is how many unique combinations of 0s and 1s can we make with our 8 bits? Before we answer that question, let me illustrate with only 4 bits, as it’ll be easier to visualize.</p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch1tab1">Table 1-1</a>, I’ve listed all the possible combination of 0s and 1s in a 4-bit number. I’ve also included the corresponding decimal representation of that number.</p>&#13;
<p class="tabcap" id="ch1tab1"><strong>Table 1-1:</strong> All Possible Values of a 4-bit Number</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Binary</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Decimal</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">0000</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">0010</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">0100</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">0110</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">1000</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">8</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">9</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">1010</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">10</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><span epub:type="pagebreak" id="page_9"/>1011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">1100</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">13</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">1110</p></td>&#13;
<td class="borb" style="vertical-align: top;"><p class="tab">14</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">15</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As you can see in <a href="ch01.xhtml#ch1tab1">Table 1-1</a>, we can represent 16 unique combinations of 0s and 1s in a 4-bit number, ranging in decimal value from 0 to 15. Seeing the list of combinations of bits helps to illustrate this, but we could have figured this out in a couple of ways without enumerating every possible combination.</p>&#13;
<p class="indent">We could determine the largest possible number that 4 bits can represent by setting all the bits to one, giving us 0b1111. That is 15 in decimal; if we add 1 to account for representing 0, then we come to our total of 16. Another shortcut is to raise 2 to the number of bits, 4 in this case, which gives us 2<sup>4</sup> = 2 × 2 × 2 × 2 = 16 total combinations of 0s and 1s.</p>&#13;
<p class="indent">Looking at 4 bits is a good start, but previously we were talking about bytes, which contain 8 bits. Using the preceding approach, we could list out all combinations of 0s and 1s, but let’s skip that step and go straight to a shortcut. Raise 2 to the power of 8 and you get 256, so that’s the number of unique combinations of bits in a byte.</p>&#13;
<p class="indent">Now we know that a 4-bit number allows for 16 combinations of 0s and 1s, and a byte allows for 256 combinations. What does that have to do with computing? Let’s say that a computer game has 12 levels; the game could easily store the current level number in only 4 bits. On the other hand, if the game has 99 levels, 4 bits won’t be enough … only 16 levels could be represented! A byte, on the other hand, would handle that 99-level requirement just fine. Computer engineers sometimes need to consider how many bits or bytes will be needed for storage of data.</p>&#13;
<h3 class="h3" id="lev1_9"><strong>Prefixes</strong></h3>&#13;
<p class="noindent">Representing complex data types takes a large number of bits. Something as simple as the number 99 won’t require more than a byte; a video in a digital format, on the other hand, can require billions of bits. To more easily communicate the size of data, we use prefixes like giga- and mega-. The <em>International System of Units (SI)</em>, also known as the <em>metric system</em>, defines a set of standard prefixes. These prefixes are used to describe anything that can be quantified, not just bits. We’ll see them again in upcoming chapters dealing with electrical circuits. <a href="ch01.xhtml#ch1tab2">Table 1-2</a> lists some of the common SI prefixes and their meanings.</p>&#13;
<span epub:type="pagebreak" id="page_10"/>&#13;
<p class="tabcap" id="ch1tab2"><strong>Table 1-2:</strong> Common SI Prefixes</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Prefix name</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Prefix symbol</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Value</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Base 10</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>English word</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">tera</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">T</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1,000,000,000,000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">10<sup>12</sup></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">trillion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">giga</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">G</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1,000,000,000</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">10<sup>9</sup></p></td>&#13;
<td style="vertical-align: top;"><p class="tab">billion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">mega</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">M</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1,000,000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">10<sup>6</sup></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">million</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">kilo</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">k</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1,000</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">10<sup>3</sup></p></td>&#13;
<td style="vertical-align: top;"><p class="tab">thousand</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">centi</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">c</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0.01</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">10<sup>-2</sup></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">hundredth</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">milli</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">m</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0.001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">10<sup>-3</sup></p></td>&#13;
<td style="vertical-align: top;"><p class="tab">thousandth</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">micro</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">μ</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0.000001</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">10<sup>-6</sup></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">millionth</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">nano</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">n</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0.000000001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">10<sup>-9</sup></p></td>&#13;
<td style="vertical-align: top;"><p class="tab">billionth</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">pico</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">p</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0.000000000001</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">10<sup>-12</sup></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">trillionth</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">With these prefixes, if we want to say “3 billion bytes,” we can use the shorthand 3GB. Or if we want to represent 4 thousand bits, we can say 4kb. Note the uppercase B for byte and lowercase b for bit.</p>&#13;
<p class="indent">You’ll find that this convention is commonly used to represent quantities of bits and bytes. Unfortunately, it’s also often technically incorrect. Here’s why: when dealing with bytes, most software is actually working in base 2, not base 10. If your computer tells you that a file is 1MB in size, it is actually 1,048,576 bytes! That is approximately one million, but not quite. Seems like an odd number, doesn’t it? That’s because we are looking at it in decimal. In binary, that same number is expressed as 0b100000000000000000000. It’s a power of two, specifically 2<sup>20</sup>. <a href="ch01.xhtml#ch1tab3">Table 1-3</a> shows how to interpret the SI prefixes when dealing with bytes.</p>&#13;
<p class="tabcap" id="ch1tab3"><strong>Table 1-3:</strong> SI Prefix Meaning When Applied to Bytes</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Prefix name</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Prefix symbol</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Value</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Base 2</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">tera</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">T</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1,099,511,627,776</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2<sup>40</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">giga</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">G</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1,073,741,824</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">2<sup>30</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">mega</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">M</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1,048,576</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2<sup>20</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">kilo</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">k</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1,024</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">2<sup>10</sup></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Another point of confusion with bits and bytes relates to network transfer rates. Internet service providers usually advertise in bits per second, base 10. So, if you get 50 mega<em>bits</em> per second from your internet connection, that means you can only transfer about 6 mega<em>bytes</em> per second. That is, 50,000,000 bits per second divided by 8 bits per byte gives us 6,250,000 bytes per second. Divide 6,250,000 by 2<sup>20</sup> and we get about 6 megabytes per second.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise"><strong>SI PREFIXES FOR BINARY DATA</strong></p>&#13;
<p class="exercise-para">To address the confusion caused by multiple meanings of prefixes, a new set of prefixes was introduced in 2002 (in a standard called IEEE 1541) to be used for binary scenarios. When dealing with powers of 2, kibi- is to be used instead of kilo-, mebi- is to be used instead of mega-, and so on. These new prefixes correspond to base 2 values and are intended to be used in scenarios where the old prefixes were previously being used incorrectly. For example, since kilobyte might be interpreted as 1,000 or 1,024 bytes, this standard recommends that kibibyte be used to mean 1,024 bytes, while kilo- retains its original meaning so that a kilobyte is equal to 1,000 bytes.</p>&#13;
<p class="exercise-parai">This seems like a good idea, but at the time of this writing, these symbols haven’t been widely adopted. <a href="ch01.xhtml#ch1tab4">Table 1-4</a> lists the new prefixes and their meanings.</p>&#13;
<p class="tabcap" id="ch1tab4"><strong>Table 1-4:</strong> IEEE 1541-2002 Prefixes for Binary Data</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Prefix name</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Prefix symbol</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Value</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Base 2</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">tebi</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Ti</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1,099,511,627,776</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2<sup>40</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">gibi</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Gi</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1,073,741,824</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">2<sup>30</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">mebi</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Mi</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1,048,576</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2<sup>20</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">kibi</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Ki</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1,024</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">2<sup>10</sup></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="exercise-parai">This distinction is important because in practice, most software that displays the size of files uses the old SI prefix but calculates size using base 2. In other words, if your device says a file’s size is 1KB, it means 1,024 bytes. On the other hand, manufacturers of storage devices tend to advertise the capacity of their devices using base 10. This means that a hard drive that is advertised as 1TB probably holds 1 trillion bytes, but if you connect that device to a computer, the computer will show the size as about 931GB (1 trillion divided by 2<sup>30</sup>). Given the lack of standard adoption of the new prefixes, in this book, I will continue to use the old SI prefixes.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_11"/>&#13;
<h3 class="h3" id="lev1_10"><strong>Hexadecimal</strong></h3>&#13;
<p class="noindent">Before we leave the topic of thinking in binary, I’ll cover one more number system: hexadecimal. Quickly reviewing, our “normal” number system is decimal, or base 10. Computers use binary, or base 2. <em>Hexadecimal</em> is <em>base 16</em>! Given what you’ve already learned in this chapter, you probably know what that means. Hexadecimal, or just <em>hex</em> for short, is a place-value system where each place represents a power of 16, and each place can be one of 16 symbols.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>As in all place-value systems, the rightmost place will still be the ones place. The next place to the left will be the sixteens place, then the 256s (16 × 16) place, then the 4,096s (16 × 16 × 16) place, and so on. Simple enough. But what about the other requirement that each place can be one of 16 symbols? We usually have ten symbols to use to represent numbers, 0 through 9. We need to add six more symbols to represent the other values. We could pick some random symbols like &amp; @ #, but these symbols have no obvious order. Instead, the standard is to use A, B, C, D, E, and F (either uppercase or lowercase is fine!). In this scheme, A represents ten, B represents eleven, and so on, up to F, which represents fifteen. That makes sense; we need symbols that represent zero through one less than the base. So our extra symbols are A through F. It’s standard practice to use the prefix 0x to indicate hexadecimal, when needed for clarity. <a href="ch01.xhtml#ch1tab5">Table 1-5</a> lists each of the 16 hexadecimal symbols, along with their decimal and binary equivalents.</p>&#13;
<p class="tabcap" id="ch1tab5"><strong>Table 1-5:</strong> Hexadecimal Symbols</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Hexadecimal</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Decimal</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Binary (4-bit)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0001</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0010</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0011</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">4</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">4</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0100</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0101</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">6</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">6</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0110</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0111</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">8</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">8</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">9</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">9</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1001</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">A</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">10</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1010</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">B</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">11</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1011</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">C</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">12</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1100</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">D</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">13</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1101</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">E</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">14</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1110</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">F</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">15</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1111</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">What happens when you need to count higher than 15 decimal or 0xF? Just like in decimal, we add another place. After 0xF comes 0x10, which is 16 decimal. Then 0x11, 0x12, 0x13, and so on. Now take a look at <a href="ch01.xhtml#ch1fig4">Figure 1-4</a>, where we see a larger hexadecimal number, 0x1A5.</p>&#13;
<span epub:type="pagebreak" id="page_13"/>&#13;
<div class="image" id="ch1fig4"><img src="../images/fig1-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 1-4: Hexadecimal number 0x1A5 broken out by place value</em></p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch1fig4">Figure 1-4</a> we have the number 0x1A5 in hexadecimal. What’s the value of this number in decimal? The rightmost place is worth 5. The next place has a weight of 16, and there’s an A there, which is 10 in decimal, so the middle place is worth 16 × 10 = 160. The leftmost place has a weight of 256, and there’s a 1 in that place, so that place is worth 256. The total value then is 5 + 160 + 256 = 421 in decimal.</p>&#13;
<p class="indent">Just to reinforce the point, this example shows how the new symbols, like A, have a different value depending on the place in which they appear. 0xA is 10 decimal, but 0xA0 is 160 in decimal, because the A appears in the sixteens place.</p>&#13;
<p class="indent">At this point you may be saying to yourself “great, but what use is this?” I’m glad you asked. Computers don’t use hexadecimal, and neither do most people. And yet, hexadecimal is very useful for people who need to work in binary.</p>&#13;
<p class="indent">Using hexadecimal helps overcome two common difficulties with working in binary. First, most people are terrible at reading long sequences of 0s and 1s. After a while the bits all run together. Dealing with 16 or more bits is tedious and error-prone for humans. The second problem is that although people are good at working in decimal, converting between decimal and binary isn’t easy. It’s tough for most people to look at a decimal number and quickly tell which bits would be 1 or 0 if that number were represented in binary. But with hexadecimal, conversions to binary are much more straightforward. <a href="ch01.xhtml#ch1tab6">Table 1-6</a> provides a couple of examples of 16-bit binary numbers and their corresponding hexadecimal and decimal representations. Note that I’ve added spaces to the binary values for clarity.</p>&#13;
<p class="tabcap" id="ch1tab6"><strong>Table 1-6:</strong> Examples of 16-bit Binary Numbers as Decimal and Hexadecimal</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Example 1</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Example 2</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Binary</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1111 0000 0000 1111</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1000 1000 1000 0001</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Hexadecimal</strong></p></td>&#13;
<td style="vertical-align: top;"><p class="tab">F00F</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">8881</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Decimal</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">61,455</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">34,945</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>Consider Example 1 in <a href="ch01.xhtml#ch1tab6">Table 1-6</a>. In binary, there’s a clear sequence: the first four bits are 1, the next eight bits are 0, and the last four bits are 1. In decimal, this sequence is obscured. It isn’t clear at all from looking at 61,455 which bits might be set to 0 or 1. Hexadecimal, on the other hand, mirrors the sequence in binary. The first hex symbol is F (which is 1111 in binary), the next two hex symbols are 0, and the final hex symbol is F.</p>&#13;
<p class="indent">Continuing to Example 2, the first three sets of four bits are all 1000 and the final set of four bits is 0001. That’s easy to see in binary, but rather hard to see in decimal. Hexadecimal provides a clearer picture, with the hexadecimal symbol of 8 corresponding to 1000 in binary and the hexadecimal symbol of 1 corresponding to, well, 1!</p>&#13;
<p class="indent">I hope you are seeing a pattern emerge: every four bits in binary correspond to one symbol in hexadecimal. If you remember, four bits is half a byte (or a nibble). Therefore, a byte can be easily represented with two hexadecimal symbols. A 16-bit number can be represented with four hex symbols, a 32-bit number with eight hex symbols, and so on. Let’s take the 32-bit number in <a href="ch01.xhtml#ch1fig5">Figure 1-5</a> as an example.</p>&#13;
<div class="image" id="ch1fig5"><img src="../images/fig1-5.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 1-5: Each hexadecimal character maps to 4 bits</em></p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch1fig5">Figure 1-5</a> we can digest this rather long number one half-byte at a time, something that isn’t possible using a decimal representation of the same number (2,320,695,040).</p>&#13;
<p class="indent">Because it’s relatively easy to move between binary and hex, many engineers will often use the two in tandem, converting to decimal numbers only when necessary. I’ll use hexadecimal later in this book where it makes sense.</p>&#13;
<p class="indent">Try converting from binary to hexadecimal without going through the intermediate step of converting to decimal.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch1ex4"><strong>EXERCISE 1-4: BINARY TO HEXADECIMAL</strong></p>&#13;
<p class="exercise-para">Convert these numbers, represented in binary, to their hexadecimal equivalents. Don’t convert to decimal if you can help it! The goal is to move directly from binary to hexadecimal.</p>&#13;
<p class="exercise-para">            10 (binary) = ______ (hexadecimal)</p>&#13;
<p class="exercise-para">11110000 (binary) = ______ (hexadecimal)</p>&#13;
<p class="exercise-para">You can check your answers in <a href="appa.xhtml">Appendix A</a>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_15"/>Once you have the hang of binary to hexadecimal, try going the other way, from hex to binary.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch1ex5"><strong>EXERCISE 1-5: HEXADECIMAL TO BINARY</strong></p>&#13;
<p class="exercise-para">Convert these numbers, represented in hexadecimal, to their binary equivalents. Don’t convert to decimal if you can help it! The goal is to move directly from hexadecimal to binary.</p>&#13;
<p class="exercise-para">     1A (hexadecimal) = _____ (binary)</p>&#13;
<p class="exercise-para">C3A0 (hexadecimal) = ______ (binary)</p>&#13;
<p class="exercise-para">You can check your answers in <a href="appa.xhtml">Appendix A</a>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_11"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we covered some of the foundational concepts of computing. You learned that a computer is any electronic device that can be programmed to carry out a set of logical instructions. You then saw that modern computers are digital devices rather than analog devices, and you learned the difference between the two: analog systems are those that use widely varying values to represent data, whereas digital systems represent data as a sequence of symbols. After that, we explored how modern digital computers rely on only two symbols, 0 and 1, and learned about a number system consisting of only two symbols, base 2, or binary. We covered bits, bytes, and the standard SI prefixes (giga-, mega-, kilo-, and so on) you can use to more easily describe the size of data. Lastly, you learned how hexadecimal is useful for people who need to work in binary.</p>&#13;
<p class="indent">In the next chapter we’ll look more closely at how binary is used in digital systems. We’ll take a look at how binary can be used to represent various types of data, and we’ll see how binary logic works.</p>&#13;
<span epub:type="pagebreak" id="page_16"/>&#13;
</body></html>