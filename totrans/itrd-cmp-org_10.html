<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_185"/><strong><span class="big">10</span><br/>PROGRAMMING IN ASSEMBLY LANGUAGE</strong></h2>&#13;
<div class="image1"><img src="../images/pg213_Image_246.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindentz">In previous chapters, you learned how computers can be programmed using <code>1</code>s and <code>0</code>s to represent operations and data. Those <code>1</code>s and <code>0</code>s are the <em>machine language</em>. Now, we’ll move on to programming at the machine level. Instead of using machine language, we’ll use <em>assembly language</em>, which uses a short mnemonic for each machine language instruction. We’ll use an <em>assembler</em> program to translate the assembly language into the machine language instructions that control the computer.</p>&#13;
<p class="indent">Creating a program in assembly language is similar to creating one in a higher-level compiled language such as C, C++, Java, or FORTRAN. I’ll use C as the programming model to explore the primary programming constructs and data structures that are common to essentially all higher-level programming languages. The compiler we’re using, <code>gcc</code>, allows us to look at the assembly language it generates. From there, I’ll show you how I would implement the programming constructs and data structures directly in assembly language.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_186"/>We’ll start by looking at the steps the compiler takes to create an executable program from C source code. Next, I’ll discuss which of these steps apply to assembly language programming and walk you through creating a program directly in assembly language that will run in the C hosted environment. You’ll also learn about a <code>gdb</code> mode that’s useful for learning assembly language.</p>&#13;
<p class="indent">While reading this chapter, you should also consult the man pages and <code>info</code> documentation resources available in Raspberry Pi OS for the programs discussed here. You’ll probably need to install some of them on your Raspberry Pi, as described in “The Programming Environment” on <a href="ch01.xhtml#ch01lev1sec3">page 4</a>.</p>&#13;
<p class="indent">I’ll be using the GNU assembler program, <code>as</code>, quite a bit through the rest of the book. Some call this assembler <code>gas</code>, short for <em>GNU assembler</em>. I’ll explain what you need to know about using the <code>as</code> program, but I recommend getting a copy of the <em>Using as</em> manual so you can learn the details as we go. It’s available in the Software Development section at <em><a href="https://www.gnu.org/manual/manual.html">https://www.gnu.org/manual/manual.html</a></em>, as part of the GNU Binutils collection.</p>&#13;
<h3 class="h3" id="ch10lev1sec1"><strong>Starting in C</strong></h3>&#13;
<p class="indent">The <code>gcc</code> compiler creates an executable program from one or more source files by performing several distinct steps. Each step results in an intermediate file that serves as the input to the next step. The description of each step here assumes a single C source file, <em>filename.c</em>:</p>&#13;
<p class="noindenttL"><strong>Preprocessing</strong></p>&#13;
<p class="noindentin">Preprocessing is the first step. This step resolves <em>preprocessor directives</em> such as <code>#include</code> (file inclusion), <code>#define</code> (macro definition), and <code>#if</code> (conditional compilation) by invoking the program <code>cpp</code>. Each preprocessor directive begins with the <code>#</code> character, which may be pronounced or not—for example, you may hear the <code>#include</code> directive referred to as <em>include</em>, <em>pound-include</em>, <em>hash-include</em>, or <em>hashtag-include</em>.</p>&#13;
<p class="indentinL">The compilation process can be stopped at the end of the preprocessing phase using the <code>-E</code> option, which writes the resulting C source code to <em>standard output</em>. Standard output is the plaintext output from a command line program in Linux. It is usually connected to the terminal window. You can redirect the output to a file with the <code>&gt;</code> operator, like so:</p>&#13;
<pre class="pre2L">$ <span class="codestrong1">gcc -Wall -O0 -E &lt;<span class="codeitalic1">filename.c</span>&gt; &gt; &lt;<span class="codeitalic1">filename.i</span>&gt;</span></pre>&#13;
<p class="indent">The <em>.i</em> file extension denotes a file that does not require preprocessing.</p>&#13;
<p class="noindentt"><strong>Compilation</strong></p>&#13;
<p class="noindentin">Next, the compiler translates the source code that results from preprocessing into assembly language. The compilation process can be stopped at the end of the compilation phase with the <code>-S</code> option (an uppercase S), which writes the assembly language source code to <em>&lt;filename&gt;.s</em>.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_187"/><strong>Assembly</strong></p>&#13;
<p class="noindentin">After the compiler generates the assembly language that implements the C source code, the assembler program, <code>as</code>, translates the assembly language into machine code (instructions and data). The process can be stopped at the end of the assembly phase using the <code>-c</code> option, which writes the machine code to an <em>object file</em> named <em>&lt;filename&gt;.o</em>. In addition to the machine code, the object file includes metadata about the code used by the linker to resolve cross-references between different modules, determine where to locate the different parts of the program, and so forth. It also includes metadata about the module, for use by the debugger.</p>&#13;
<p class="noindentt"><strong>Linking</strong></p>&#13;
<p class="noindentin">The <code>ld</code> program determines where each function and data item will be located in memory when the program is executed. It replaces the programmer’s labels, where each is referenced with the memory address of the label. If a called function is in an external library, this is noted where the function is called, and the address of the external library function is determined during program execution.</p>&#13;
<p class="indentinL">The compiler directs the <code>ld</code> program to add the computer code to the executable file that sets up the C hosted environment. This includes operations such as opening paths to standard output (the screen) and standard input (the keyboard) for use by the program.</p>&#13;
<p class="indentinL">The result of this linking is written to an executable file. The default name of the executable file is <em>a.out</em>, but you can specify another name with the <code>-o</code> option.</p>&#13;
<p class="indenttL">If you don’t use any of the <code>gcc</code> options to stop the process at the end of one of these steps (<code>-E</code>, <code>-S</code>, <code>-c</code>), the compiler will perform all four steps and automatically delete the intermediate files, leaving only the executable program as the final result. You can direct <code>gcc</code> to keep all the intermediate files with the <code>-save-temps</code> option.</p>&#13;
<p class="indent">The complement of being able to stop <code>gcc</code> along the way is that we can supply files that have effectively gone through the earlier steps, and <code>gcc</code> will incorporate those files into the remaining steps. For example, if we write a file in assembly language (<em>.s</em>), <code>gcc</code> will skip the preprocessing and compilation steps and perform only the assembly and linking steps for that file. If we supply only object files (<em>.o</em>), <code>gcc</code> will go directly to the linking step. An implicit benefit of this is that we can write programs in assembly language that call functions in the C standard library (which are already in object file format), and <code>gcc</code> will automatically link our assembly language with those library functions.</p>&#13;
<p class="indent">Be sure to use the filename extensions specified in the GNU programming environment when naming a file. The default action of the compiler at each step depends upon the filename extension appropriate to that step. To see these naming conventions, enter <span class="codestrong">info gcc</span> into the command line, select <span epub:type="pagebreak" id="page_188"/><strong>Invoking GCC</strong>, and then select <strong>Overall Options</strong>. If you don’t use the specified filename extension, the compiler might not do what you want or might even overwrite a required file.</p>&#13;
<h4 class="h4" id="ch10lev2sec1"><em><strong>From C to Assembly Language</strong></em></h4>&#13;
<p class="noindent">Programs written in C are organized into functions. Each function has a name that is unique within the program. After the C hosted environment is set up, the <code>main</code> function is called, so our programs will start with a <code>main</code> function.</p>&#13;
<p class="indent">Let’s start by looking at the assembly language that <code>gcc</code> generates for the minimum C program in <a href="ch10.xhtml#ch10list1">Listing 10-1</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>do_nothing.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Minimum components of a C program&#13;
&#13;
int main(void)&#13;
{&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch10list1"><em>Listing 10-1: The minimum C program</em></p>&#13;
<p class="indent">This program does nothing except return 0 to the operating system. A program can return various numerical error codes; 0 indicates that the program did not detect any errors.</p>&#13;
<p class="indent">Even though this program accomplishes very little, some instructions need to be executed just to return 0. To see what takes place, we’ll first translate this program from C to assembly language with the following Linux command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gcc -Wall -O0 -S do_nothing.c</span></pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re not familiar with the GNU</em> <span class="codeitalic">make</span> <em>program, it’s worth learning how to use it to build your programs. It may seem like overkill at this point, but it’s much easier to learn with simple programs. The manual is available in several formats at</em> <a href="https://www.gnu.org/software/make/manual/">https://www.gnu.org/software/make/manual/</a>, <em>and I have some comments about using it on my website at</em> <a href="https://rgplantz.github.io">https://rgplantz.github.io</a>.</p>&#13;
</div>&#13;
<p class="indent">Before showing the result of this command, I’ll explain the options I’ve used. The <code>-O0</code> (uppercase O and zero) option tells the compiler not to use any optimization. This is in keeping with the goal of this book, which is to show what’s taking place at the machine level; asking the compiler to optimize the code may obscure some important details.</p>&#13;
<p class="indent">You’ve already learned that the <code>-Wall</code> option asks the compiler to warn you about questionable constructions in your code. That’s not likely to be an issue in this simple program, but it’s a good habit to get into.</p>&#13;
<p class="indent">The <code>-S</code> option directs the compiler to stop after the compilation phase and write the assembly language resulting from the compilation to a file with <span epub:type="pagebreak" id="page_189"/>the same name as the C source code file, but with the <em>.s</em> extension instead of <em>.c</em>. The previous compiler command generates the assembly language shown in <a href="ch10.xhtml#ch10list2">Listing 10-2</a>, which is saved in the file <em>do_nothing.s</em>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>do_nothing.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "do_nothing.c"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
.LFB0:&#13;
        .cfi_startproc&#13;
        mov     w0, 0&#13;
        ret&#13;
        .cfi_endproc&#13;
.LFE0:&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
        .section .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch10list2"><em>Listing 10-2: The minimum C program in assembly language generated by the compiler</em></p>&#13;
<p class="indent">The first thing to notice in <a href="ch10.xhtml#ch10list2">Listing 10-2</a> is that assembly language is organized by lines. Only one assembly language statement is on each line, and none of the statements spans more than one line. This differs from the free-form nature of many high-level languages, where the line structure is irrelevant. In fact, good programmers use the ability to write program statements across multiple lines and indentation to emphasize the structure of their code. Good assembly language programmers use blank lines to help separate parts of an algorithm, and they comment almost every line.</p>&#13;
<p class="indent">The lines are organized roughly into columns. They probably do not make much sense to you at this point because they’re written in assembly language, but if you look carefully, each of the lines is organized into four possible fields:</p>&#13;
<pre class="pre"><span class="codeitalic1">label</span>: <span class="codeitalic1">operation operand(s)</span>   // <span class="codeitalic1">comment</span></pre>&#13;
<p class="indent">Not all the lines will have entries in all the fields. The assembler requires at least one space or tab character to separate the fields. When writing assembly language, your program will be much easier to read if you use the <small>TAB</small> key to move from one field to the next so the columns line up.</p>&#13;
<p class="indent">Let’s look at each field in a bit more detail:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><span class="codestrongitalic">label</span> This field allows us to give a symbolic name to a memory address in the program. Other parts of the program can then refer to the memory address by name. A label consists of an identifier immediately followed by the <code>:</code> character. I’ll cover the rules for creating an identifier soon. Only the lines that need to be referred to are labeled.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_190"/><span class="codestrongitalic">operation</span> This field contains either an <em>instruction operation code (opcode)</em> or an <em>assembler directive</em> (sometimes called a <em>pseudo-op</em>). The assembler translates an opcode and its operands into machine instructions, which are copied into memory when the program is to be executed. Assembler directives are instructions to the assembler program that guide the assembly process.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">operand(s)</span> This field specifies the arguments to be used in the operation. The arguments can be explicit values, names of registers, or programmer-created names. There may be zero to several operands, depending on the operation.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">comment</span> Everything on a line following two <code>/</code> characters (<code>//</code>) is ignored by the assembler, thus providing a way for the programmer to provide human-readable comments. Since assembly language is not as easy to read as higher-level languages, good programmers will place a comment on almost every line. Of course, the compiler has not commented the code in <a href="ch10.xhtml#ch10list2">Listing 10-2</a> because it has no way of knowing the programmer’s intent.</p>&#13;
</div>&#13;
<p class="indent">You probably noticed that most of the operators in <a href="ch10.xhtml#ch10list2">Listing 10-2</a> begin with a <code>.</code> character. These are assembler directives. Each assembler directive begins with the <code>.</code> character, which may be pronounced or not—for example, you might hear <code>.text</code> referred to as <em>text</em> or <em>dot-text</em>. These are instructions to the assembler program itself, not computer instructions. The compiler generates some assembler directives that we won’t need for the assembly language we write in this book; we’ll take a quick look at those next, then look at the required directives.</p>&#13;
<h4 class="h4" id="ch10lev2sec2"><em><strong>Unused Assembler Directives</strong></em></h4>&#13;
<p class="noindent">The assembler directives in <a href="ch10.xhtml#ch10list2">Listing 10-2</a> that begin with <code>.cfi</code> tell the assembler to generate information that can be used for debugging and certain error situations. The labels beginning with <code>.LF</code> mark places in the code used to generate this information. A discussion of this is beyond the scope of this book, but their appearance in the listing can be confusing, so we’ll tell the compiler not to include them in the assembly language file using the <code>-fno-asynchronous-unwind-tables</code> and <code>-fno-unwind-tables</code> options:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gcc -Wall -O0 -S -fno-asynchronous-unwind-tables -fno-unwind-tables do_nothing.c</span></pre>&#13;
<p class="indent">This produces the file <em>do_nothing.s</em>, shown in <a href="ch10.xhtml#ch10list3">Listing 10-3</a>. I’ve used boldface to show the directives that we will use and left the ones we won’t use unbolded. The compiler did not comment the assembly language code in this listing, but I’ve added my own comment using <code>///</code> to help you see the relationship with the C source code. I’ll add my own comments to many of the compiler-generated assembly language listings I show in this book.</p>&#13;
<div class="note6">&#13;
<p class="notep"><span epub:type="pagebreak" id="page_191"/><em>do_nothing.s</em></p>&#13;
</div>&#13;
<pre class="pre">        <span class="codestrong1">.arch armv8-a</span>&#13;
        .file   "do_nothing.c"&#13;
        <span class="codestrong1">.text</span>&#13;
        <span class="codestrong1">.align  2</span>&#13;
        <span class="codestrong1">.global main</span>&#13;
        <span class="codestrong1">.type   main, %function</span>&#13;
main:&#13;
        mov     w0, 0           /// return 0;&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch10list3"><em>Listing 10-3: The minimum C program in assembly language generated by the compiler, without</em> <span class="codeitalic">.cfi</span> <em>directives</em></p>&#13;
<p class="indent">We’ve stripped away the <code>.cfi</code> directives, but we still have several assembler directives that we won’t need when we write our own functions in assembly language. These include:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><span class="codestrong">.file</span> This is used by <code>gcc</code> to specify the name of the C source file that this assembly language came from. This directive isn’t used when writing directly in assembly language.</p>&#13;
<p class="noindentin"><span class="codestrong">.size</span> This computes the size of the machine code, in bytes, that results from assembling this file. The <code>.</code> symbol refers to the current address in the code, so the arithmetic expression <code>.-main</code> subtracts the address of <code>main</code> from the current address. The <code>.size</code> directive associates this value with the <code>main</code> label as part of the metadata in the object file, thus giving the number of bytes in this function. This can be useful information in systems with limited memory, but it’s of no concern in our programs.</p>&#13;
<p class="noindentin"><span class="codestrong">.ident</span> This provides information in the object file about the compiler that was used. This might be useful in large projects that have evolved over several years, but we won’t need it.</p>&#13;
<p class="noindentin"><span class="codestrong">.section</span> This provides guidance to the linker about how the stack should be treated for this function. We won’t include it and will just accept the default settings of the linker.</p>&#13;
</div>&#13;
<p class="indent">Next, we’ll look at the directives that will be required when we write in assembly language.</p>&#13;
<h4 class="h4" id="ch10lev2sec3"><em><strong>Required Assembler Directives</strong></em></h4>&#13;
<p class="noindent">The required assembler directives are shown in boldface in <a href="ch10.xhtml#ch10list3">Listing 10-3</a>.</p>&#13;
<p class="indent">There are several variations of the ARM instruction set architecture, and it continues to evolve. The <code>.arch</code> assembler directive tells the assembler which ARM architecture we’re using. It causes the assembler to warn us if <span epub:type="pagebreak" id="page_192"/>we use an instruction that is not available in our specific architecture. The <code>.arch</code> directive is arguably not required for the simple programs we’re writing in this book, but we’ll use it to be on the safe side.</p>&#13;
<p class="indent">The <code>.text</code> assembler directive tells the assembler to place whatever follows in the text section. What does <em>text section</em> mean? In Linux, the object files produced by the assembler are in the <em>Executable and Linkable Format (ELF)</em>. The ELF standard specifies many types of sections, each specifying the type of information stored in it. We use assembler directives to tell the assembler in which section to place the code. The text section is where the program’s executable instructions go.</p>&#13;
<p class="indent">The Linux operating system also divides memory into <em>segments</em> for specific purposes when a program is loaded from the disk. The linker gathers together all the sections that belong in each segment and outputs an executable ELF file that’s organized by segment to make it easier for the operating system to load the program into memory. The four general types of segments are as follows:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>Text (also called code)</strong> The <em>text segment</em> is where program instructions and constant data are stored. The operating system prevents a program from changing anything stored in the text segment, making it read-only.</p>&#13;
<p class="noindentin"><strong>Data</strong> Global variables and static local variables are stored in the <em>data segment</em>. Global variables can be accessed by any of the functions in a program. A static local variable can be accessed only by the function it’s defined in, but its value remains the same between calls to its function. Programs can both read from and write to variables in the data segment. These variables remain in place for the duration of the program.</p>&#13;
<p class="noindentin"><strong>Stack</strong> Automatic local variables and the information that links functions are stored on the <em>call stack</em>. Automatic local variables are created when a function is called and deleted when the function returns to its calling function. A program can both read from and write to memory on the stack; it’s allocated and deallocated dynamically as the program executes.</p>&#13;
<p class="noindentin"><strong>Heap</strong> The <em>heap</em> is a pool of memory that’s available for a program to use when running. A C program calls the <code>malloc</code> function (C++ programs call <code>new</code>) to get a chunk of memory from the heap. Programs can both read from and write to heap memory; it’s used to store data and is explicitly deallocated by calling <code>free</code> (<code>delete</code> in C++) in the program.</p>&#13;
</div>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This is a simplistic overview of ELF sections and segments. For more details, read the man page for ELF and sources such as “ELF-64 Object File Format,” which you can download at</em> <a href="https://uclibc.org/docs/elf-64-gen.pdf">https://uclibc.org/docs/elf-64-gen.pdf</a>, <em>and John R. Levine’s</em> Linkers &amp; Loaders <em>(Morgan Kaufmann, 1999). The</em> <span class="codeitalic">readelf</span> <em>program is also useful for learning about ELF files.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>.align</code> directive is used to align the code following it on an address boundary. The argument used in <a href="ch10.xhtml#ch10list3">Listing 10-3</a>, <code>2</code>, has different meanings depending on the platform you’re using. On the ARM platform, it specifies <span epub:type="pagebreak" id="page_193"/>the number of low-order bits that should be <code>0</code> in the program counter. If the bits are not <code>0</code>, the assembler increments the address until they are. Thus, the code that follows this <code>.align 2</code> directive will start at a full word address.</p>&#13;
<p class="indent">The <code>.global</code> directive has one argument, the identifier <code>main</code>. The <code>.global</code> directive makes the name globally known, so functions that are defined in other files can refer to this name. The code that sets up the C hosted environment was written to call the function named <code>main</code>, so the name must be global in scope. All C/C++ programs start with a <code>main</code> function. In this book, I’ll also start the assembly language programs with a <code>main</code> function and execute them within the C hosted environment.</p>&#13;
<p class="indent">You can write stand-alone assembly language programs that don’t depend on the C hosted environment, in which case you can create your own name for the first function in the program. You need to stop the compilation process at the end of the assembly step with the <code>-c</code> option. You then link the object (<em>.o</em>) files using the <code>ld</code> command by itself, not as part of <code>gcc</code>. I’ll describe this in more detail in <a href="ch21.xhtml">Chapter 21</a>.</p>&#13;
<p class="indent">The <code>.type</code> directive has two arguments: <code>main</code> and <code>@function</code>. This causes the identifier <code>main</code> to be recorded in the object file as the name of a function.</p>&#13;
<p class="indent">These last three directives are not translated into actual machine instructions. Rather, they’re used to describe the characteristics of the statements that follow. In the next chapter, we’ll start seeing assembler directives that store constant data in memory for the program to use.</p>&#13;
<p class="indent">Now that you’ve seen how the compiler translates C code into assembly language, let’s look at how to write a program directly in assembly language. In the Introduction, I said you should avoid writing programs in assembly language. But the goal of this book is to help you learn how computers work at the machine level. Writing programs directly in assembly language is a better learning technique than just reading what the compiler does.</p>&#13;
<h3 class="h3" id="ch10lev1sec2"><strong>Starting in Assembly Language</strong></h3>&#13;
<p class="noindent"><a href="ch10.xhtml#ch10list4">Listing 10-4</a> was written in assembly language by a programmer (me), rather than by a compiler. Naturally, I’ve added comments to explain what my code accomplishes.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>do_nothing.s</em></p>&#13;
</div>&#13;
<pre class="pre">  // Minimum components of a C program, in assembly language&#13;
&#13;
          .arch   armv8-a&#13;
          .text&#13;
          .align  2&#13;
          .global main&#13;
          .type   main, %function&#13;
<span class="ent">➊</span> main:&#13;
        <span class="ent">➋</span> mov     w0, wzr  // return 0;&#13;
           ret</pre>&#13;
<p class="list" id="ch10list4"><em>Listing 10-4: The minimum C-style program written in assembly language</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_194"/>The first line begins with two slashes, <code>//</code>. Everything after those two characters, up to the end of the line, is a comment and does not generate any action by the assembler. Comments can be started with two slashes at any place on a line. As in a high-level language, they are intended solely for human readers and have no effect on the program.</p>&#13;
<p class="indent">This comment line is followed by a blank line, also causing no action by the assembler, but very helpful for human readability.</p>&#13;
<p class="indent">A word about program comments here. Beginners often comment on what the programming statement does, not its purpose relative to solving the problem. Your comments should describe what <em>you</em> are doing, not what the computer is doing. For example, a comment like</p>&#13;
<pre class="pre">counter = 1;  // Let counter = 1</pre>&#13;
<p class="noindent">in C is not very useful. But a comment like</p>&#13;
<pre class="pre">counter = 1;  // Need to start at 1</pre>&#13;
<p class="noindent">could be very helpful.</p>&#13;
<p class="indent">After the five assembler directives that we’re using in our assembly language programs (described in the previous section), we see the label <code>main</code> on the first memory address in this function <span class="ent">❶</span>. It’s common to place a label on its own line, in which case it applies to the address of the next assembly language statement that takes up memory <span class="ent">❷</span>. This allows you to create longer, more meaningful labels while maintaining the column organization of your code, to improve readability.</p>&#13;
<h4 class="h4" id="ch10lev2sec4"><em><strong>Symbolic Names in Assembly Language</strong></em></h4>&#13;
<p class="noindent">Since this is the top-level function in this program, the label <code>main</code> is required, but we’ll soon be writing programs that require us to create our own names. The rules for creating a symbolic name are similar to those for C/C++. Each name starts with either a letter or the character <code>.</code> or <code>_</code> followed by a string of letters, numerals, and/or <code>$</code> and <code>_</code> characters. The first character must not be a numeral, except for local labels, as described shortly. A name may be any length, and all characters are significant. Although the letter case of keywords (operators, register names, directives) is not significant, it is significant for labels. For example, <code>my_label</code> and <code>My_label</code> are different. Compiler-generated labels begin with the <code>.</code> character, and many system-related names begin with the <code>_</code> character; it’s a good idea to avoid beginning your own labels with these characters so you don’t inadvertently create one that’s already being used by the system.</p>&#13;
<p class="indent">Our assembler also allows us to use an unsigned integer, <span class="codeitalic">N</span>, to create a <em>local label</em>. Your assembly language code can refer to these labels as <span class="codeitalic">N</span><code>b</code> for the most recently used (<span class="codeitalic">N</span> <em>backward</em>) and <span class="codeitalic">N</span><code>f</code> for the next used (<span class="codeitalic">N</span> <em>forward</em>). This means you can have more than one local label with the same number. While it might seem to simplify your code writing, using local labels is usually not a good programming technique because the names don’t show the purpose of the labels.</p>&#13;
<h4 class="h4" id="ch10lev2sec5"><span epub:type="pagebreak" id="page_195"/><em><strong>Basic Format of Assembly Language Instructions</strong></em></h4>&#13;
<p class="noindent">ARM instructions fall into three categories: load and store, data processing, and program flow control. We’ll start by looking at the general format of the assembly language instruction. Rather than list all the A64 instructions, I will introduce a few at a time—the ones that will be needed to illustrate the programming concept at hand. I will also give only the commonly used variants of those instructions.</p>&#13;
<p class="indent">For a detailed description of the instructions and all their variants, download a copy of the <em>Arm Architecture Reference Manual for A-Profile Architecture</em> from <em><a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a></em>. This manual can be a little difficult to read, but going back and forth between my descriptions of the instructions in this book and the descriptions in the manual should help you learn how to read the manual.</p>&#13;
<p class="indent">Assembly language provides a set of mnemonics that correspond directly to the machine language instructions. A <em>mnemonic</em> is a short, English-like group of characters that suggests the action of the instruction. Even if you’ve never seen assembly language before, the <code>mov w0, wzr</code> instruction in <a href="ch10.xhtml#ch10list4">Listing 10-4</a> <span class="ent">❷</span> probably makes much more sense to you than the machine code it represents, <code>0x2a1f03e0</code>. You can probably figure out that it moves the contents of the 32-bit zero register <code>wzr</code> to the <code>w0</code> register. You’ll see what that means in the next few paragraphs.</p>&#13;
<p class="indent">Strictly speaking, the mnemonics are completely arbitrary, as long as you have an assembler program that will translate them into the desired machine instructions. However, most assembler programs follow the mnemonics used in the manuals provided by CPU vendors.</p>&#13;
<p class="indent">ARM uses a <em>load and store architecture</em>, which means data items must be loaded into registers or be part of the instruction itself before they can be used in an arithmetic or logic operation.</p>&#13;
<p class="indent">The general format of a load or store instruction is:</p>&#13;
<pre class="pre"><span class="codeitalic1">operation register</span>, <span class="codeitalic1">memory_address</span></pre>&#13;
<p class="noindent">The <span class="codeitalic">memory_address</span> is either a label on a memory address or the name of a register that contains the address. Load instructions copy the data item from the <span class="codeitalic">memory_address</span> to the <span class="codeitalic">register</span>. Store instructions copy the data item from the <span class="codeitalic">register</span> to the <span class="codeitalic">memory_address</span>. In most cases, you will be dealing with only one data item for each load or store instruction, but the A64 architecture includes load and store instructions that allow you to work with two data items in separate registers with one instruction. You’ll see how this works in <a href="ch11.xhtml">Chapter 11</a>.</p>&#13;
<p class="indent">Data processing instructions—arithmetic and logic operations—have the general format:</p>&#13;
<pre class="pre"><span class="codeitalic1">operation register(s)</span>, <span class="codeitalic1">source(s)</span></pre>&#13;
<p class="noindent">The first operand is where the result of the <span class="codeitalic">operation</span> is placed. Some instructions use two registers for the results. There can be from one to three <span epub:type="pagebreak" id="page_196"/><span class="codeitalic">source(s)</span>, which are registers or an <em>immediate value</em>. An immediate value is an explicit constant.</p>&#13;
<p class="indent">Instructions that control program flow have the general format</p>&#13;
<pre class="pre"><span class="codeitalic1">operation memory_address</span></pre>&#13;
<p class="noindent">or:</p>&#13;
<pre class="pre"><span class="codeitalic1">operation data</span>, <span class="codeitalic1">memory_address</span></pre>&#13;
<p class="noindent">The <span class="codeitalic">memory_address</span> is either a label on a memory address or the name of a register that contains the address. The <span class="codeitalic">data</span> must be in a register or an immediate value.</p>&#13;
<h4 class="h4" id="ch10lev2sec6"><em><strong>Symbols Used for Instruction Descriptions</strong></em></h4>&#13;
<p class="noindent">Here is a list of symbols I’ll use for describing instructions in this book, which are a little different from those used in the Arm manual:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><span class="codestrong">w</span><span class="codestrongitalic">d</span> A 32-bit destination register for the result of an operation.</p>&#13;
<p class="noindentin"><span class="codestrong">x</span><span class="codestrongitalic">d</span> A 64-bit destination register for the result of an operation.</p>&#13;
<p class="noindentin"><span class="codestrong">w</span><span class="codestrongitalic">s</span><strong>,</strong> <span class="codestrong">w</span><span class="codestrongitalic">n</span> A 32-bit source register for an operation. If there’s more than one source register, they are numbered.</p>&#13;
<p class="noindentin"><span class="codestrong">x</span><span class="codestrongitalic">s</span><strong>,</strong> <span class="codestrong">x</span><span class="codestrongitalic">n</span> A 64-bit source register for an operation. If there’s more than one source register, they are numbered.</p>&#13;
<p class="noindentin"><span class="codestrong">x</span><span class="codestrongitalic">b</span><strong>,</strong> <span class="codestrong">x</span><span class="codestrongitalic">n</span> A 64-bit register that holds a base address.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">offset</span> A constant number that is added to a base address.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">imm</span> A constant number whose size depends on the instruction.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">amnt</span> The number of bits to shift a source operand.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">addr</span> An address, typically a label.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">cond</span> A logical combination of the bits in the <code>nzcv</code> register.</p>&#13;
<p class="noindentin"><span class="codestrongitalic">xtnd</span> Specifies a wider version of an operand to use in an operation.</p>&#13;
<p class="noindentin"><span class="codestrong">{}</span> Indicates one or more operands that are optional.</p>&#13;
<p class="noindentin"><span class="codestrong">|</span> Indicates that either the operand on the left or the operand on the right can be used.</p>&#13;
</div>&#13;
<p class="indent">The registers can be any of the 31 general-purpose registers described in <a href="ch09.xhtml">Chapter 9</a>. Most instructions also allow us to use the <code>wzr</code>, <code>xzr</code>, <code>wsp</code>, and <code>sp</code> registers.</p>&#13;
<h4 class="h4" id="ch10lev2sec7"><em><strong>First Instructions</strong></em></h4>&#13;
<p class="noindent">Again, I won’t describe all the instructions, nor will I describe all the variants of the instructions that I do describe. My aim is to equip you with the information you need to understand the programming concepts I introduce in this book and to be comfortable using other sources as needed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>Let’s start with the most commonly used assembly language instruction, <code>mov</code>. Some of the variations of this instruction follow; you can find more in the Arm manual:</p>&#13;
<p class="noindenttL"><span class="codestrong">mov</span><strong>—Move register</strong></p>&#13;
<p class="hang"><code>mov w</code><span class="codeitalic">d</span>, <code>w</code><span class="codeitalic">s</span> <code>|wzr</code> copies the 32-bit value in <code>w</code><span class="codeitalic">s</span> or <code>wzr</code> to <code>w</code><span class="codeitalic">d</span> and zeros bits 63 to 32 of <code>x</code><span class="codeitalic">d</span>.</p>&#13;
<p class="hang"><code>mov x</code><span class="codeitalic">d</span>, <code>x</code><span class="codeitalic">s</span> <code>|xzr</code> copies the 64-bit value in <code>x</code><span class="codeitalic">s</span> or <code>xzr</code> to <code>x</code><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentt"><span class="codestrong">mov</span><strong>—Move to or from</strong> <span class="codestrong">sp</span></p>&#13;
<p class="hang"><code>mov x</code><span class="codeitalic">d</span> <code>|sp, x</code><span class="codeitalic">s</span> <code>|sp</code> copies the 64-bit value in <code>x</code><span class="codeitalic">s</span> or <code>sp</code> to <code>x</code><span class="codeitalic">d</span> or <code>sp</code>.</p>&#13;
<p class="noindentt"><span class="codestrong">mov</span><strong>—Move immediate</strong></p>&#13;
<p class="hang"><code>mov w</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span> copies the 16-bit value <span class="codeitalic">imm</span> to the low-order part of <code>w</code><span class="codeitalic">d</span> and zeros bits 63 to 16 of <code>x</code><span class="codeitalic">d</span>.</p>&#13;
<p class="hang"><code>mov x</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span> copies the 16-bit value <span class="codeitalic">imm</span> to the low-order part of <code>x</code><span class="codeitalic">d</span> and zeros bits 63 to 16 of <code>x</code><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentt"><span class="codestrong">movz</span><strong>—Move immediate and zero</strong></p>&#13;
<p class="hang"><code>movz w</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span><code>{, lsl</code> <span class="codeitalic">amnt</span><code>}</code> copies the 16-bit value <span class="codeitalic">imm</span> to <code>w</code><span class="codeitalic">d</span>, optionally shifted <span class="codeitalic">amnt</span> bits to the left. The other 48 bits of <code>x</code><span class="codeitalic">d</span> are set to <code>0</code>. <span class="codeitalic">amnt</span> can be <code>0</code> (the default) or <code>16</code>.</p>&#13;
<p class="hang"><code>movz x</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span><code>{, lsl</code> <span class="codeitalic">amnt</span><code>}</code> copies the 16-bit value <span class="codeitalic">imm</span> to <code>x</code><span class="codeitalic">d</span>, optionally shifted <span class="codeitalic">amnt</span> bits to the left. The other 48 bits of <code>x</code><span class="codeitalic">d</span> are set to <code>0</code>. <span class="codeitalic">amnt</span> can be <code>0</code> (the default), <code>16</code>, <code>32</code>, or <code>48</code>.</p>&#13;
<p class="noindentt"><span class="codestrong">movk</span><strong>—Move immediate and keep</strong></p>&#13;
<p class="hang"><code>movk w</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span><code>{, lsl</code> <span class="codeitalic">amnt</span><code>}</code> copies the 16-bit value <span class="codeitalic">imm</span> to <code>w</code><span class="codeitalic">d</span>, optionally shifted <span class="codeitalic">amnt</span> bits to the left. The other 48 bits of <code>x</code><span class="codeitalic">d</span> are not changed. <span class="codeitalic">amnt</span> can be <code>0</code> (the default) or <code>16</code>.</p>&#13;
<p class="hang"><code>movk x</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span><code>{, lsl</code> <span class="codeitalic">amnt</span><code>}</code> copies the 16-bit value <span class="codeitalic">imm</span> to <code>x</code><span class="codeitalic">d</span>, optionally shifted <span class="codeitalic">amnt</span> bits to the left. The other 48 bits of <code>x</code><span class="codeitalic">d</span> are not changed. <span class="codeitalic">amnt</span> can be <code>0</code> (the default), <code>16</code>, <code>32</code>, or <code>48</code>.</p>&#13;
<p class="noindent"><span class="codestrong">movn</span><strong>—Move immediate and NOT</strong></p>&#13;
<p class="hang"><code>movn w</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span><code>{, lsl</code> <span class="codeitalic">amnt</span><code>}</code> copies the inverse of the 16-bit value <span class="codeitalic">imm</span> to <code>w</code><span class="codeitalic">d</span>, optionally shifted <span class="codeitalic">amnt</span> bits to the left. The other 48 bits of <code>x</code><span class="codeitalic">d</span> are set to <code>1</code>. <span class="codeitalic">amnt</span> can be <code>0</code> (the default) or <code>16</code>.</p>&#13;
<p class="hang"><code>movn x</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">imm</span><code>{, lsl</code> <span class="codeitalic">amnt</span><code>}</code> copies the inverse of the 16-bit value in <span class="codeitalic">imm</span> to <code>x</code><span class="codeitalic">d</span>, optionally shifted <span class="codeitalic">amnt</span> bits to the left. The other 48 bits of <code>x</code><span class="codeitalic">d</span> are set to <code>1</code>. <span class="codeitalic">amnt</span> can be <code>0</code> (the default), <code>16</code>, <code>32</code>, or <code>48</code>.</p>&#13;
<p class="indenttL">The only other instruction in <a href="ch10.xhtml#ch10list4">Listing 10-4</a> is a <code>ret</code>, which causes a return to the calling function, assuming the return address is in <code>x30</code>:</p>&#13;
<p class="noindenttL"><span class="codestrong">ret</span><strong>—Return from a function</strong></p>&#13;
<p class="hang"><code>ret</code> moves the address in <code>x30</code> to the program counter, <code>pc</code>.</p>&#13;
<p class="indenttL"><span epub:type="pagebreak" id="page_198"/>Now you see why I said in <a href="ch09.xhtml">Chapter 9</a> that <code>x30</code> is commonly used as the link register: when a function is called, the return address is placed in <code>x30</code>. We’ll see how this works when we look at function calls in <a href="ch11.xhtml">Chapter 11</a>.</p>&#13;
<p class="indent">One of the most valuable uses of <code>gdb</code> is as a learning tool. It has a mode that is especially helpful in learning what each assembly language instruction does. I’ll show you how to do this in the next section, using the program in <a href="ch10.xhtml#ch10list4">Listing 10-4</a>. This will also help you to become more familiar with using <code>gdb</code>, which is an important skill to have when debugging your programs.</p>&#13;
<h3 class="h3" id="ch10lev1sec3"><strong>Using gdb to Learn Assembly Language</strong></h3>&#13;
<p class="noindent">This would be a good place for you to run the program in <a href="ch10.xhtml#ch10list4">Listing 10-4</a> so you can follow along with the discussion. You can assemble, link, and execute it with the following commands:</p>&#13;
<pre class="pre">$ <span class="codestrong1">as --gstabs -o do_nothing.o do_nothing.s</span>&#13;
$ <span class="codestrong1">gcc -o do_nothing do_nothing.o</span>&#13;
$ <span class="codestrong1">./do_nothing</span></pre>&#13;
<p class="indent">The <code>--gstabs</code> option (note the two dashes here) tells the assembler to include debugging information with the object file. The <code>gcc</code> program recognizes that the only input file is already an object file, so it goes directly to the linking stage. There is no need to tell <code>gcc</code> to include the debugging information, because the assembler already included it in the object file.</p>&#13;
<p class="indent">As you might guess from the name, you won’t see anything on the screen when you run this program. We’ll use <code>gdb</code> to walk through the execution of the program, which will allow us to see that this program actually does do something.</p>&#13;
<p class="indent">The <code>gdb</code> debugger has a mode that’s useful for seeing the effects of each assembly language instruction as it’s executed. The <em>text user interface (TUI)</em> mode splits the terminal window into a display pane at the top and the usual command pane at the bottom. The display pane can be further split into two display panes.</p>&#13;
<p class="indent">Each display pane can show either the source code (<code>src</code>), the registers (<code>regs</code>), or the disassembled machine code (<code>asm</code>). <em>Disassembly</em> is the process of translating the machine code (<code>1</code>s and <code>0</code>s) into the corresponding assembly language. The disassembly process does not know the programmer-defined names, so you will see only the numerical values that were generated by the assembly and linking processes. The <code>asm</code> display will probably be more useful when we look at the details of instructions in <a href="ch12.xhtml">Chapter 12</a>.</p>&#13;
<p class="indent">The documentation for using the TUI mode is in <code>info</code> for <code>gdb</code>. I’ll give a simple introduction to using the TUI mode here, using our assembly language version of <code>do_nothing</code> from <a href="ch10.xhtml#ch10list4">Listing 10-4</a>. I’ll step through each of the instructions. You’ll get a chance to single-step through each of them in “Your Turn” <a href="ch10.xhtml#ch10exe1">exercise 10.1</a> on <a href="ch10.xhtml#commonL1">page 205</a>.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_199"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>My example here shows</em> <span class="codeitalic">gdb</span> <em>being run from the command line. I’ve been told that this doesn’t work well if you try to run</em> <span class="codeitalic">gdb</span> <em>within Emacs.</em></p>&#13;
</div>&#13;
<p class="indent">As we did in <a href="ch02.xhtml">Chapter 2</a>, we’ll run <code>do_nothing</code> under <code>gdb</code>, but this time we’ll use the TUI mode:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gdb -tui ./do_nothing</span></pre>&#13;
<p class="indent">This should bring up a screen like the one in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>. Note that <a href="ch10.xhtml#ch10fig1">Figures 10-1</a> through <a href="ch10.xhtml#ch10fig7">10-7</a> are zoomed in for readability; your screen view may look different, depending on your terminal window settings.</p>&#13;
<div class="image"><img id="ch10fig1" src="../images/pg227_Image_247.jpg" alt="Image" width="615" height="659"/></div>&#13;
<p class="figcap"><em>Figure 10-1: Starting</em> <span class="codeitalic">gdb</span> <em>in TUI mode gives the</em> <span class="codeitalic">src</span> <em>display.</em></p>&#13;
<p class="indent">Enter <span class="codestrong">c</span> to continue through the preliminary message shown in this screenshot.</p>&#13;
<p class="indent">Next, set a breakpoint at the first instruction of the program and set a display layout. There are several display layouts available in TUI mode. We’ll use the <code>regs</code> layout, shown in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_200"/><img id="ch10fig2" src="../images/pg228_Image_248.jpg" alt="image" width="615" height="657"/></div>&#13;
<p class="figcap"><em>Figure 10-2: Adding the</em> <span class="codeitalic">regs</span> <em>display pane to the TUI window</em></p>&#13;
<p class="indent">The <code>layout regs</code> command divides the display pane into a <code>regs</code> pane and an <code>src</code> pane. I’ve moved the focus to the <code>regs</code> pane before telling <code>gdb</code> to run the program. The program starts with a <code>0x1</code> in the <code>x0</code> register (your value may differ). The instruction in the program that is about to be executed is highlighted.</p>&#13;
<p class="indent">The display isn’t large enough to show all the A64 registers. With the focus on the <code>regs</code> pane, use the up and down arrow keys and the page up and page down keys to scroll through the register display. I pressed the page down key three times to get <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_201"/><img id="ch10fig3" src="../images/pg229_Image_249.jpg" alt="image" width="616" height="659"/></div>&#13;
<p class="figcap"><em>Figure 10-3: Viewing other registers</em></p>&#13;
<p class="indent">The value in <code>x30</code> shows the location the program will return to in the C hosted environment when it completes execution. You’ll see how this works in <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>. The value in <code>pc</code> is the address of the first instruction in our <code>main</code> function.</p>&#13;
<p class="indent">Let’s tell <code>gdb</code> to execute a single instruction, as shown in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_202"/><img id="ch10fig4" src="../images/pg230_Image_250.jpg" alt="image" width="616" height="659"/></div>&#13;
<p class="figcap"><em>Figure 10-4: Changes in the registers are highlighted.</em></p>&#13;
<p class="indent">In <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>, <code>gdb</code> highlights the next instruction to be executed as well as the registers that were changed. We knew <code>pc</code> would change, since we executed one instruction.</p>&#13;
<p class="indent">The instruction that was executed changed <code>x0</code>, but that doesn’t show in our <code>regs</code> display pane in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>. I used the page up key to give the view of <code>x0</code> in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_203"/><img id="ch10fig5" src="../images/pg231_Image_251.jpg" alt="image" width="615" height="659"/></div>&#13;
<p class="figcap"><em>Figure 10-5: Viewing the register changed by the instruction that was just executed</em></p>&#13;
<p class="indent">The <code>x0</code> register is highlighted in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a> to show that it changed.</p>&#13;
<p class="indent">Next, we’ll tell <code>gdb</code> to execute the <code>ret</code> instruction, which should take us back to the C hosted environment, as shown in <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_204"/><img id="ch10fig6" src="../images/pg232_Image_252.jpg" alt="image" width="615" height="659"/></div>&#13;
<p class="figcap"><em>Figure 10-6: Back in the C hosted environment</em></p>&#13;
<p class="indent">The <code>ret</code> instruction has copied the address from the link register, <code>x30</code>, to <code>pc</code>, thus implementing the return from the <code>main</code> function.</p>&#13;
<p class="indent">Finally, we continue execution of the program in <a href="ch10.xhtml#ch10fig7">Figure 10-7</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_205"/><img id="ch10fig7" src="../images/pg233_Image_253.jpg" alt="image" width="615" height="659"/></div>&#13;
<p class="figcap"><em>Figure 10-7: The program has completed.</em></p>&#13;
<p class="indent">All that remains is to quit <code>gdb</code>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><a id="commonL1"/><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch10exe1">10.1     Enter the program in <a href="ch10.xhtml#ch10list4">Listing 10-4</a> and use <code>gdb</code> to single-step through the code.</p>&#13;
<p class="box-list1" id="ch10exe2">10.2     Write the following C function in assembly language:</p>&#13;
<pre class="pre2La">int f(void) {&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="box-listpL"><span epub:type="pagebreak" id="page_206"/>Make sure it assembles with no errors. Use the <code>-S</code> option to compile <em>f.c</em> and compare <code>gcc</code>’s assembly language with yours. Write a <code>main</code> function in C that tests your assembly language function, <code>f</code>, and prints out the function’s return value.</p>&#13;
<p class="box-list1" id="ch10exe3">10.3     Write three assembly language functions that do nothing but return an integer. They should each return a different nonzero integer. Write a <code>main</code> function in C that tests your assembly language functions and prints out the functions’ return values using <code>printf</code>.</p>&#13;
<p class="box-list1" id="ch10exe4">10.4     Write three assembly language functions that do nothing but return a character. Each should return a different character. Write a <code>main</code> function in C that tests your assembly language functions and prints out the functions’ return values using <code>printf</code>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch10lev1sec4"><strong>What You’ve Learned</strong></h3>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>Editor</strong> A program used to write the source code for a program in the chosen programming language.</p>&#13;
<p class="noindentin"><strong>Preprocessing</strong> The first stage of compilation. It brings other files into the source, interprets directives, and so forth, in preparation for actual compilation.</p>&#13;
<p class="noindentin"><strong>Compilation</strong> Translates from the chosen programming language into assembly language.</p>&#13;
<p class="noindentin"><strong>Assembly</strong> Translates assembly language into machine language.</p>&#13;
<p class="noindentin"><strong>Linking</strong> Links separate object code modules and libraries together to produce the final executable program.</p>&#13;
<p class="noindentin"><strong>Assembler directives</strong> Guide the assembler program during the assembly process.</p>&#13;
<p class="noindentin"><span class="codestrong">mov</span> <strong>instruction</strong> Moves values within the CPU.</p>&#13;
<p class="noindentin"><span class="codestrong">ret</span> <strong>instruction</strong> Returns program flow to the calling function.</p>&#13;
<p class="noindentin"><span class="codestrong">gdb</span> <strong>TUI mode</strong> Displays changes in registers in real time as you step through a program. It’s an excellent learning tool.</p>&#13;
</div>&#13;
<p class="indent">You might be wondering what happens to the return address in <code>x30</code> if we call another function from <code>main</code>. To use <code>x30</code> as the link register to call the other function, we need to save the return address somewhere while the other function is being executed. You’ll learn how to do this in the next chapter, where we look at the details of how to pass arguments to functions, how to use the call stack, and how to create local variables in functions.</p>&#13;
</div>
</div>
</body></html>