<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label="223"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch13">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">EVADING ENDPOINT AND NETWORK DEFENSES</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">To successfully infiltrate and operate in its target environment, modern malware must survive that environment’s defenses. Many targets, especially those in an enterprise environment, are behind multiple defensive applications and products that work tirelessly to protect the systems and networks that make up the organization’s infrastructure. Malware can take active measures to evade these defenses (for example, by tampering with host defense applications) or take a passive approach to try to slip by them undetected.</p>&#13;
<p class="TX">In this chapter, I’ll outline different types of defenses that malware could encounter on victim hosts and networks, and then I’ll explain some techniques it might employ to get around those defenses. Defense evasion <span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label="224"/>is a huge topic, so this chapter will focus primarily on the most common tactics.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-199"/><samp class="SANS_Futura_Std_Bold_B_11">An Endpoint Defense Primer</samp></h3>&#13;
<p class="TNI1">The endpoint defense market is flooded with overloaded terms and fancy product names. It can be difficult to keep track of it all and understand at a fundamental level what each tool actually does. In this section, I’ll try to establish a common vocabulary for endpoint defense tools. First, though, we’ll go over a brief history of endpoint defenses to establish a baseline level of knowledge on which we can build.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-200"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">A Brief History of Endpoint Defense Technology</samp></h4>&#13;
<p class="TNI1">Endpoint defense software goes back to the early days of malware, the 1970s and 1980s. At that time, endpoint defenses were appropriately called <i>antivirus (AV)</i> products, as most types of malicious software were widely known as <i>viruses</i>. In those early days, malware was relatively simple and AV software simply searched files for specific malicious patterns. Those AV programs were typically developed by hobbyists.</p>&#13;
<p class="TX">In the late 1980s and early 1990s, malware started to become more sophisticated, and commercial AV software companies (including Norton, Kaspersky, and McAfee) emerged to address the growing threat. The software these companies developed provided more advanced features than the hobbyist AV programs, such as real-time scanning, heuristics-based detection, and automatic signature updates.</p>&#13;
<p class="TX">As malware authors were forced to adapt to technological advances, they created even more complex and covert malware capable of evading traditional AV software. In response, AV vendors started to develop much more robust software (which I’ll refer to as <i>anti-malware software</i> going forward), as well as products called <i>endpoint protection platforms (EPPs)</i>. EPPs are a more complete host protection solution that includes features not found in traditional anti-malware, such as built-in software firewalls and host intrusion prevention. More recently, <i>endpoint detection and response (EDR)</i> solutions have emerged as a more advanced endpoint security solution that provides real-time visibility into endpoint activity and enables security teams to quickly detect and respond to security threats.</p>&#13;
<p class="TX">There’s a significant amount of overlap among host defense technologies. Many modern anti-malware products, for example, incorporate aspects of EPPs and even EDR solutions. EPPs include all of the functionalities of traditional and modern anti-malware and may overlap with some EDR solutions. EDR typically includes all of the functionalities of anti-malware and EPPs, as well as others. Thus, for the sake of simplicity, I’ll categorize endpoint defenses as either anti-malware or EDR in this book. Note, however, that each product vendor has its own “secret sauce,” so these categories are meant to reflect how the defenses work in general, not the specific details of how they operate in practice.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label="225"/>&#13;
<h4 class="H2" id="sec3"><span id="h-201"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anti-malware</samp></h4>&#13;
<p class="TNI1">Perhaps the most common and well-known host defense technology is <i>anti-malware</i>, or what was formerly called <i>antivirus</i>. It specializes in detecting and identifying malware threats on the system, both on the hard disk (before malware executes itself) and in memory (after the malware is running on the system). To accomplish this, anti-malware software uses a range of techniques, including hash-based and signature-based detection as well as heuristic and behavioral analysis.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h5 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hash-Based Detection</samp></h5>&#13;
<p class="TNI1"><i>Hash-based detection</i> is a primitive method used in early anti-malware scanners, and it’s still used today to some extent. Anti-malware vendors maintain a database of file hashes known to be either benign or malicious. When a file is written to disk, the anti-malware software scans the file and compares its hash to the database. If the file is known to be benign, the anti-malware software leaves it alone. If the file is known to be malicious, the anti-malware software automatically removes it from the system and places it into a special quarantine where it can do no harm.</p>&#13;
<p class="TX">The primary problem with this hash-based method is that the files must already be known to the anti-malware software. If the file is new and not in the database, the anti-malware can’t detect it (at least, not using hash analysis alone). According to a December 15, 2020, press release from Kaspersky, about 360,000 new malicious files were created every day that year. This obviously poses a problem for hash-based detection methods, since anti-malware software can’t possibly keep up.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Signature-Based Detection</samp></h5>&#13;
<p class="TNI1"><i>Signature-based detection</i>, an upgrade to the older hash-based detection methods, uses <i>signatures</i>, or known patterns, to identify malicious code in files or process memory. These patterns can be strings, byte sequences, metadata, or anything else that indicates that the file or memory segment could be related to malware. Anti-malware software maintains a large database of signatures, and when it identifies a match on one, it raises an alert and quarantines the respective file or terminates the suspect process. Signature-based detection functions similarly to the Yara rules discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.</p>&#13;
<p class="TX">Over time, malware authors have caught on to these detection techniques. For example, since signature-based detection is looking for malicious patterns, malware authors can simply encrypt or obfuscate their malware on disk or in memory to hide or change these patterns. Worse, they can generate countless variations of their malware so that, once again, the detection mechanisms can’t keep pace. It’s clear that anti-malware software has had to evolve.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label="226"/>&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Heuristic-Based Detection</samp></h5>&#13;
<p class="TNI1">Instead of matching file hashes or looking for specific patterns in a piece of software, <i>heuristic-based detection</i> looks at a file’s behavior. It does this by using a few different sub-techniques. First, it inspects the file for signs of malicious code. This goes beyond simple string and byte-sequence pattern matching, however; it’s looking for indicators such as suspicious blocks of assembly instructions or atypical uses of API calls. This process may also involve a weighting or scoring system. When the anti-malware software discovers a suspicious sequence of code, the file’s score increases. Once this score hits a predefined threshold, the anti-malware engine rates the file as malicious.</p>&#13;
<p class="TX">More modern heuristic-based methods can also employ file emulation techniques to better understand the file. <i>File emulation</i> involves executing the file in an <i>emulation engine</i>, which is a very lightweight virtual machine that can dynamically assess the file before it actually executes on the system. As CPU instructions are executed in the emulator, the anti-malware software monitors the file’s behaviors, and if any are suspicious or raise the file’s score high enough, the anti-malware takes further action.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Cloud-Based Analysis Sandboxes</samp></h5>&#13;
<p class="TNI1">Running each file on a system through an emulation engine would be very taxing, so some modern anti-malware vendors instead use cloud-based analysis sandboxes. If a file is still unclassified even after it’s been subjected to hash-based, signature-based, and heuristic-based detection mechanisms, the file will be sent to the anti-malware vendor’s cloud environment for sandboxing and further analysis. <i>Cloud-based sandboxing</i> is a form of crowdsourced security in that all customers who use such anti-malware software will be notified if a particular file is malicious, even if they’ve never seen it.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#fig13-1">Figure 13-1</a> summarizes the detection mechanisms we’ve covered so far.</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-1" src="../images/fig13-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: Typical detection mechanisms in anti-malware software</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Note that many modern anti-malware solutions use a combination of some or all of these techniques.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Limitations and Challenges</samp></h5>&#13;
<p class="TNI1">Even though anti-malware software has progressed and improved substantially over time, it still has some limitations. As a whole, it’s effective at identifying and eliminating threats from files that are known to be malicious; <span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label="227"/>those that share similarities with files that are known to be malicious; and those that aren’t especially advanced, targeted, or bespoke. More advanced and specific threats can sneak past anti-malware software (as we’ll see later in this chapter).</p>&#13;
<p class="TX">Another limitation of anti-malware software is that it must be mindful of system resources. Anti-malware software has a very difficult job: it must scan potentially thousands of files and memory regions at a time while keeping the lowest system resource footprint possible to avoid disrupting the end-user experience. This means that it can’t run every file through the emulation or sandboxing process; it must reserve those more time- and resource-intensive techniques for suspicious files that require deeper investigation.</p>&#13;
<p class="TX">Even among the files it deems malicious, anti-malware software must be selective. For example, anti-malware software has been known to flag critical system files as malicious, an action that cannot be tolerated. As a result, anti-malware products may lean toward giving a file a pass rather than flagging it as malicious.</p>&#13;
<p class="TX">One final limitation of anti-malware software is that while it’s intended to detect and eradicate threats on the endpoint, it wasn’t designed with post-compromise investigations or context in mind. Modern and advanced attacks often involve a number of steps in the attack chain that use multiple techniques and components, and anti-malware alone can leave blind spots, especially in complex corporate environments. This is where EDR comes into play.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-202"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Endpoint Detection and Response</samp></h4>&#13;
<p class="TNI1"><i>Endpoint detection and response (EDR)</i> solutions provide more advanced threat detection and response features than traditional anti-malware solutions provide. While anti-malware solutions are focused primarily on detecting and defending against known malware threats, EDR solutions are able to detect and act upon a broader range of advanced threats.</p>&#13;
<p class="TX">One of EDR’s primary benefits is its ability to establish context around an attack. It creates this context, often referred to as <i>telemetry</i>, by collecting data from multiple endpoints, enabling investigators to perform deeper analysis and to identify similar patterns of malicious activity across the enterprise. EDR can even help investigation teams identify the “patient zero” of an attack.</p>&#13;
<p class="TX">Let’s take a quick look under the hood to see how EDR works. Typically, EDR consists of multiple components in both user space and kernel space, plus a log aggregator and analysis engine. We’ll start with the user-space components.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">User-Space Components</samp></h5>&#13;
<p class="TNI1">EDR solutions always have at least one executable running as a process in user space. This process, often called an <i>agent</i>, runs in a high-privilege context and monitors other processes on the host for suspicious behaviors, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label="228"/>intervening when necessary. To do this, the EDR agent collects and analyzes system events, then forwards this information to a log aggregator, which we’ll discuss shortly. When a new process is created on the host, the EDR process can inject a hooking module into it using various methods such as the ones discussed in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#fig13-2">Figure 13-2</a> illustrates malware being hooked by EDR.</p>&#13;
<figure class="IMG"><img class="img80" id="fig13-2" src="../images/fig13-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: The EDR process using a module to hook malware</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The malware executable (<i>malware.exe</i>) is calling a WinAPI function residing in <i>kernel32.dll</i>, which subsequently invokes <i>ntdll.dll</i>. Instead of <i>ntdll.dll</i> making a syscall into kernel space (which is what would happen under normal circumstances), the installed EDR software is hooking <i>ntdll.dll</i> via a previously injected DLL (<i>edr_hook.dll</i>). This allows the EDR software to decide whether to permit the API call or to block or even terminate it. If the EDR software deems the API activity benign, it allows the API call to continue to the kernel as normal.</p>&#13;
<p class="TX">Some common functions that may be hooked by modern anti-malware and EDR software include the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Memory operations (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>) that monitor memory commits and protection changes, such as when the EDR software wishes to know whether a region of memory is changed to <i>read-write-executable (RWX)</i>, indicating that there’s potentially code in this region about to be executed</li>&#13;
<li class="BL">Functions that create and terminate processes (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtTerminateProcess</samp>) so that the EDR software can watch over and hook into newly created processes</li>&#13;
<li class="BL">Functions that load libraries (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LdrLoadDll</samp>) so that the EDR software can monitor suspicious processes as they load new libraries and modules</li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/>Functions commonly used for process injection (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThread</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>) so that the EDR software can monitor for code- and hook- injection attempts</li>&#13;
<li class="BL">File writes (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteFile</samp>), which are often used by ransomware and other destructive malware</li>&#13;
<li class="BL">Functions that attempt to create network connections, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnect</samp>, which EDR can monitor for suspicious network communication</li>&#13;
</ul>&#13;
<p class="TX">Hooking API function calls is only one way of monitoring the system. Some EDR products also collect system data using other sources, such as <i>Event Tracing for Windows (ETW)</i>, a mechanism designed for logging and diagnostics that’s been a part of Windows since 2007. ETW is able to collect and log data from many sources, including user-space processes and kernel drivers, which makes it quite useful for EDR ingestion as well. You can read more about it in the Microsoft documentation.</p>&#13;
<p class="TX">To identify suspicious activity, EDR agents might rely upon a threat-scoring system. To illustrate this, consider the attack scenario shown in <a href="chapter13.xhtml#fig13-3">Figure 13-3</a>.</p>&#13;
<figure class="IMG"><img class="img80" id="fig13-3" src="../images/fig13-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: A multistage attack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, the attacker sends a target user a specially crafted phishing email containing a malicious Microsoft Office document attachment. The Office document’s malicious code executes PowerShell to contact a staging server where the attacker’s malware payload (<i>ransomware.exe</i>) is hosted, then downloads and executes the payload in memory. The ransomware payload subsequently begins encrypting files on the victim’s hard disk.</p>&#13;
<p class="TX">The EDR product assigns a score to each event that makes up this attack. Say it assigns a threat value of 35 to the Office document that launched a PowerShell command, a value of 20 to the connection to the suspicious server, and a value of 30 to the download and execution of an unknown executable file. If the maximum threat score is a hypothetical 100, and if any value over 75 is considered malicious, then this series of events totaling <span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label="230"/>85 would trigger the EDR solution to perform actions such as killing the Office and PowerShell processes or terminating the network connections to the remote server. The ransomware execution itself would likely have a high threat score, as ransomware creates multitudes of file write actions. Furthermore, metadata related to these events would be forwarded to a central log storage and processor, allowing the EDR product to analyze this attack in the context of the entire enterprise infrastructure.</p>&#13;
<p class="TX">Keep in mind that this threat-scoring system example is intentionally simplified and merely intended to demonstrate how EDR is better equipped than traditional endpoint defenses to “connect the dots” during an advanced attack. Let’s move on to another important part of EDR solutions: kernel-space components.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kernel-Space Components</samp></h5>&#13;
<p class="TNI1">In kernel space, EDR solutions primarily take the form of kernel drivers or modules, which are pieces of compiled code that execute in kernel address space. EDR kernel drivers rely on <i>callbacks</i>, functions registered by kernel components to receive notifications in response to specific events. To monitor the system for new processes, for example, the EDR kernel driver registers a callback routine by invoking the kernel function <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>. When a process is created or terminated, the EDR kernel driver will be notified so that it can respond to that event accordingly, likely by engaging its user-space component to inject hooks into the newly created process to begin monitoring. <a href="chapter13.xhtml#fig13-4">Figure 13-4</a> illustrates how this works.</p>&#13;
<figure class="IMG"><img class="img80" id="fig13-4" src="../images/fig13-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: EDR hook injection</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this example, the EDR kernel driver is notified via <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp> (not shown) that a new process, <i>malware.exe</i>, is being created <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The EDR driver instructs the EDR agent in user space (<i>edr_agent.exe</i>) <span class="CodeAnnotation" aria-label="annotation2">❷</span> to inject a hook into the new process <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Now <i>malware.exe</i> is being monitored by the EDR.</p>&#13;
<p class="TX">Here are a few other callbacks that EDR software might use, plus the circumstances in which they’re triggered:</p>&#13;
<p class="RunInPara1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label="231"/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetCreateThreadNotifyRoutine </samp>This is triggered when any new thread is created or deleted.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetLoadImageNotifyRoutine(Ex) </samp>This is triggered when a process loads an image (such as a DLL module) into memory, or when a new driver is loaded.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoWMISetNotificationCallback </samp>This is triggered by Windows Management Instrumentation (WMI) events.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CmRegisterCallback(Ex) </samp>This is triggered when any running thread modifies the Windows registry.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FsRtlRegisterFileSystemFilterCallbacks </samp>This is triggered when certain filesystem operations occur.</p>&#13;
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoRegisterBootDriverCallback </samp>This is triggered when a new boot-start driver is initialized. Boot-start drivers start on system boot-up, so this callback can be used by anti-malware and EDR to detect rootkits and bootkits that use a boot-up driver (more on rootkits in <span class="runinpara_Xref"><a href="chapter14.xhtml">Chapter 14</a></span>).</p>&#13;
<p class="TX">EDR can also take advantage of minifilter drivers. <i>Minifilters</i> are used to monitor requests to the filesystem from user-space processes, so EDR can use them to intercept and block malicious filesystem actions that malware is trying to execute (for example, ransomware opening and writing to files at a rapid rate). Another reason EDR uses minifilters is to monitor and protect its own files from tampering or deletion. In the event that a malware sample is able to establish low-level privileges and attempt to remove or modify EDR components, the minifilter drivers will notify the EDR product about this activity.</p>&#13;
<p class="TX">Other kernel components that EDR may use are network filter drivers and <i>early-launch anti-malware (ELAM)</i> drivers. Network filter drivers can be used to monitor, intercept, and modify network communication, which can be useful in detecting anomalous network traffic such as command and control (C2) traffic. ELAM drivers load before the operating system boots and help protect against malware that could tamper with the boot process.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You may have noticed that EDR injects modules into other processes, installs hooks to intercept API calls, and installs drivers into kernel space, which is eerily similar to malware! EDR does indeed look suspiciously similar to a variant of malware called rootkits. We’ll talk about rootkit techniques and components in more detail in <a href="chapter14.xhtml">Chapter 14</a>.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Logging and Analysis</samp></h5>&#13;
<p class="TNI1">I mentioned previously that one of the EDR agent’s responsibilities is to forward events and associated data to a central logging server, where they can be further analyzed and stored for future investigations. <a href="chapter13.xhtml#fig13-5">Figure 13-5</a> illustrates this process.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label="232"/>&#13;
<figure class="IMG"><img class="img80" id="fig13-5" src="../images/fig13-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: An EDR agent gathering data from multiple endpoints for analysis</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you can see here, EDR agents running on disparate endpoints in the enterprise infrastructure forward data to the EDR log aggregator. Using various vendor-specific techniques, the data is processed and analyzed, enabling the EDR product to detect larger-scale attacks, for example. Using this telemetry, some EDR products can even “learn” what’s normal for this specific enterprise environment, helping them further differentiate between typical end-user behaviors and malicious activity. Many modern EDR solutions can also collect logs from many different sources to monitor an organization’s entire IT infrastructure. These EDR solutions are sometimes referred to as <i>extended detection and response</i> (<i>XDR)</i> platforms. XDRs are able to collect and analyze data from sources such as client endpoints, servers, network devices, applications, and cloud computing environments. For the remainder of this book, I’ll use the term <i>EDR</i> to also refer to XDR.</p>&#13;
<p class="TX">Even with all its benefits and capabilities, EDR can be (and sometimes is) bypassed by advanced malware. Now that you have a basic understanding of how EDR and anti-malware software work, let’s look at how malware can tamper with and circumvent these defenses. Advanced malware will often first attempt to understand the environment in which it is operating; this involves the malware scouting the target system and network and attempting to identify the endpoint defenses standing in its path. We’ll start there.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h-203"/><samp class="SANS_Futura_Std_Bold_B_11">Identifying Endpoint Defenses</samp></h3>&#13;
<p class="TNI1">Since many anti-malware and EDR products behave and monitor the system a bit differently, an advanced attacker will conduct at least basic reconnaissance on the target prior to executing a malware payload. There are a number of techniques an attacker might employ to enumerate the target’s defenses. For example, the following PowerShell command will retrieve a list of installed anti-malware software on the host:</p>&#13;
<pre class="pre-106"><code>PS C:\&gt; Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/>Here’s some example output for this command:</p>&#13;
<pre class="pre-107"><code>displayName              : Windows Defender&#13;
instanceGuid             : {D68BAD3A-821F-4fce-9E54-DA133F2CBA26}&#13;
pathToSignedProductExe   : windowsdefender://&#13;
pathToSignedReportingExe : %ProgramFiles%\Windows Defender\MsMpEng.exe&#13;
productState             : 397568&#13;
timestamp                : Mon, 13 Feb 2023 18:29:52 GMT&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">On my system, Microsoft Defender was identified as the active anti-malware product. (This output uses the outdated name <i>Windows Defender</i>; the product has since been renamed Microsoft Defender.)</p>&#13;
<p class="TX">Although this command will retrieve only anti-malware software that has registered itself within the Microsoft Security Center, most anti-malware vendors do this. A more robust solution is to enumerate artifacts on the host, searching for signs of endpoint defense products.</p>&#13;
<p class="TX">In <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, we discussed how malware enumerates and lists processes running on the host for sandbox and VM detection. It can do the same for enumerating defenses. For example, it can call the Windows API functions <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp> to create a “snapshot” of all processes running on the victim host, then iterate through these processes using <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>. It can then search for suspect process names such as <i>MsMpEng.exe</i> (the default Windows 10 and 11 anti-malware process), <i>AvastSvc.exe</i> (the executable process for the anti-malware product from Avast), or any process with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">falcon</samp> in its name (which could be related to the CrowdStrike Falcon EDR product) in order to determine what kinds of defenses are on the host.</p>&#13;
<p class="TX">Some of the most popular anti-malware and EDR vendors and products include the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">CrowdStrike Falcon EDR: <i>CSFalcon*.exe</i></li>&#13;
<li class="BL">ESET Smart Security: <i>Ekrn.exe</i></li>&#13;
<li class="BL">Kaspersky: <i>Avp.exe</i></li>&#13;
<li class="BL">Malwarebytes: <i>Mbam.exe</i></li>&#13;
<li class="BL">McAfee Endpoint Security: <i>masvc.exe</i></li>&#13;
<li class="BL">Sophos: <i>SavService.exe</i></li>&#13;
<li class="BL">Symantec Endpoint Protection: <i>ccSvcHst.exe</i></li>&#13;
<li class="BL">VMware Carbon Black: <i>cb.exe</i></li>&#13;
<li class="BL">Microsoft Defender for Endpoint (formerly Windows Defender): <i>MsMpEng.exe</i></li>&#13;
</ul>&#13;
<p class="TX">These processes often have associated services, which are named similarly and can be enumerated by malware. Also keep in mind that the list is not exhaustive and is subject to change between software versions.</p>&#13;
<p class="TX">Alternatively, scanning the host for anti-malware and EDR-related files, drivers, and registry keys can be effective. <a href="chapter13.xhtml#fig13-6">Figure 13-6</a> shows the Procmon <span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label="234"/>output of a malware sample that queries the registry for keys that match common anti-malware vendors.</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-6" src="../images/fig13-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: Malware querying the registry for names of anti-malware and EDR products</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Similarly, the anti-malware product from Kaspersky, for example, installs itself to a directory such as <i>C:\Program Files (x86)\Kaspersky Lab\Kaspersky Total Security</i> and installs several drivers on the host that are visible in the <i>C:\System32\drivers</i> directory, which could alert malware to its presence (see <a href="chapter13.xhtml#fig13-7">Figure 13-7</a>).</p>&#13;
<figure class="IMG"><img class="img80" id="fig13-7" src="../images/fig13-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-7: Kaspersky’s installed drivers</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">There are a number of research projects, such as at <a href="https://github.com/ethereal-vx/Antivirus-Artifacts"><i>https://<wbr/>github<wbr/>.com<wbr/>/ethereal<wbr/>-vx<wbr/>/Antivirus<wbr/>-Artifacts</i></a>, that catalog the different artifacts that endpoint defense products create on the host. These resources can be useful to both malware researchers and malware authors.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/>Finally, malware already running on the host may attempt to look for signs that it is being hooked by anti-malware or EDR. For instance, the malware might enumerate its loaded modules using <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> (as described in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>) or search its process memory for signs of hooking, as it does to circumvent sandbox hooking (described in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>). These hooks may reveal a specific defense product.</p>&#13;
<p class="TX">Once an endpoint security product has been detected and identified, the malware can take one of several active or passive approaches to circumvent it. First, we’ll discuss some active measures.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h-204"/><samp class="SANS_Futura_Std_Bold_B_11">Actively Circumventing Endpoint Defenses</samp></h3>&#13;
<p class="TNI1"><i>Active circumvention</i> is directly bypassing defenses by disabling them completely, modifying policies to weaken them, or tampering with them to blind them. There are many ways to accomplish this, so let’s look at some examples.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h-205"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Disabling Host Defenses</samp></h4>&#13;
<p class="TNI1">A crude but effective method for malware to evade and bypass endpoint security is simply to disable it. After enumerating the security products running on the endpoint, malware can disable them in several ways. First, it can attempt to kill the application’s processes (examples include anti-malware and EDR-related processes, Windows Security Center processes and services, and any firewall products such as the Windows built-in host firewall) by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> function or invoking tools such as PowerShell or the Windows command line.</p>&#13;
<p class="TX">Some anti-malware solutions store parts of their configurations in the registry; tampering with these can also produce unwanted results. The malware family KillAV (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 659ce17fd9d4c6aad952bc5c0ae93a748178e53f8d60e45ba1d0c15632fd3e3f</samp>), which specializes in doing what its name suggests, attempts to disable the default Windows anti-malware and threat protection services by stopping processes and tampering with the registry. Here are some of the commands that this malware executes:</p>&#13;
<pre class="pre-108"><code>net stop WinDefend&#13;
&#13;
REG ADD "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v&#13;
"DisableRealtimeMonitoring" /t REG_DWORD /d "1" /f&#13;
&#13;
REG ADD "HKLM\Software\Policies\Microsoft\Windows Defender" /v "DisableAntiSpyware" /t&#13;
REG_DWORD /d "1" /f&#13;
&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">REG ADD "HKLM\SYSTEM\CurrentControlSet\Services\WdBoot" /v Start /t REG_DWORD /d 4 /f</samp></code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">net stop WinDefend</samp> command terminates the Microsoft Defender process, while the various <samp class="SANS_TheSansMonoCd_W5Regular_11">REG ADD</samp> commands tamper with the registry to switch off the Microsoft Defender real-time monitoring service, the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>AntiSpyware service, and the AV boot driver (WdBoot), all of which are critical components of the Windows default anti-malware services.</p>&#13;
<p class="TX">Some malware simply attempts to uninstall defense software from the host, using PowerShell commands like the following:</p>&#13;
<pre class="pre-109"><code>PS C:\&gt; $antimalware = Get-WmiObject -Class Win32_Product | Where-Object{$_.Name -eq "ESET&#13;
Endpoint Antivirus"}&#13;
PS C:\&gt; $antimalware.Uninstall()</code></pre>&#13;
<p class="TX">The first PowerShell command leverages WMI to enumerate installed software on the host, looking specifically for ESET anti-malware software; the second command uninstalls it.</p>&#13;
<p class="TX">A possibly less noisy approach is lowering an endpoint defense process’s <i>priority</i>: that is, reducing how important the process is to the operating system. Higher-priority processes (typically, critical processes such as system processes) are allotted more CPU time. By lowering an endpoint defense process’s priority using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPriorityClass</samp>, the malware can diminish its effectiveness. The following pseudocode demonstrates this approach:</p>&#13;
<pre class="pre-110"><code>// Open the target process (anti-malware process, for example).&#13;
hProcess = OpenProcess(..., ..., TargetProcessPID);&#13;
&#13;
// Set process priority to "Low".&#13;
SetPriorityClass(hProcess, BELOW_NORMAL_PRIORITY_CLASS);</code></pre>&#13;
<p class="TX">There is a catch with these techniques, however: depending on the operating environment, the malware may require high-level privileges to terminate anti-malware processes and services, tamper with registry configurations and process priorities, and uninstall software. In this case, the malware must elevate its privileges before trying to disable endpoint defenses. We’ll look at how it does so in the <span class="Xref">“Privilege Elevation for Defense Evasion”</span> section on <span class="Xref"><a href="chapter13.xhtml#pg_248">page 248</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h-206"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Adding Anti-malware Exclusions</samp></h4>&#13;
<p class="TNI1">Another way to impair defenses is by tampering with the anti-malware exclusion list. Anti-malware software regularly scans specific filesystem directories on the endpoint, which are determined by how the user or organization configures the software. Most anti-malware software allows users to add exclusions, in the form of directory paths, to its configuration settings. Any files or directories in this exclusion list won’t be monitored or scanned.</p>&#13;
<p class="TX">To employ this technique, an initial dropper or loader malware creates an exclusion on the victim host, and once that exclusion is enabled, it deploys the payload into the excluded directory. Here’s how malware could use PowerShell to create an exclusion in the Microsoft Defender anti-malware solution:</p>&#13;
<pre class="pre-111"><code>PS C:\&gt; Add-MpPreference -ExclusionPath "C:\Malware\DoNotScanThisDirectory"</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>This command adds an anti-malware exclusion for the path <i>C:\Malware\DoNotScanThisDirectory\</i>.</p>&#13;
<p class="TX">Note that the malware must have high-level privileges on the victim host to create exclusions in later versions of Windows, making the barrier to entry for this kind of attack more difficult than in older versions of the operating system.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h-207"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Disabling Other Security Controls</samp></h4>&#13;
<p class="TNI1">In addition to disabling anti-malware, EDR, and other defenses, malware can disable other security features of the system. While such security features may not directly prevent attacks, disabling them can degrade the overall security of the host, making it more susceptible to further attacks.</p>&#13;
<p class="TX">For example, malware may disable the Windows Update service, which is responsible for periodically updating Windows to patch bugs and vulnerabilities. If a threat actor disabled this service under the radar, it could ultimately degrade the overall security of the host over a longer period of time, leaving the system open to follow-up attacks. To disable a service with PowerShell, the malware could execute the following command:</p>&#13;
<pre class="pre-112"><code>PS C:\&gt; Stop-Service "Service_Name"</code></pre>&#13;
<p class="TX">The malware could also disable PowerShell security. Some Windows environments prohibit the execution of unauthorized PowerShell scripts, so switching off script execution controls could help an attacker execute PowerShell scripts they otherwise couldn’t. To enable PowerShell script execution, an attacker can issue the following command:</p>&#13;
<pre class="pre-113"><code>PS C:\&gt; Set-ExecutionPolicy Unrestricted</code></pre>&#13;
<p class="TX">To prevent unauthorized outbound traffic from an endpoint, it’s common to configure a host-based firewall solution. Host-based firewalls can be used to allow outbound traffic from specific processes, such as web browsers, while preventing outbound traffic from processes that shouldn’t be communicating with any other hosts on the network or the internet. To get around this limitation, an attacker can directly modify firewall configurations on the host. This configuration differs depending on the firewall software being used, but for the standard Windows firewall, a rule can be added or modified with PowerShell. For example, malware could use the following command to change the default firewall policy to permit all outbound traffic from all processes on the host:</p>&#13;
<pre class="pre-114"><code>PS C:\&gt; Set-NetFirewallProfile -Name Domain -DefaultOutboundAction Allow</code></pre>&#13;
<p class="TX">Malware can also disable non-security-related tools that could be used to expose it. Examples include terminating and disabling the Windows Task Manager to prevent cautious users from spotting suspicious running <span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/>processes or disabling the Registry Editor to prevent a knowledgeable system administrator from identifying malicious artifacts in the registry.</p>&#13;
<p class="TX">There are many policies and configurations on a Windows system that an attacker could alter to degrade security; these are just a few examples. The key takeaway is that a threat actor may not attempt to completely disable endpoint defenses like anti-malware and EDR but may instead go for a less direct approach, making slight tweaks to the system to achieve its goals. This is a double-edged sword, however; the more the malware alters a system, the higher the chances it will be detected.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h-208"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Blinding Defenses by Unhooking</samp></h4>&#13;
<p class="TNI1">Since EDR and modern anti-malware heavily rely on hooks to monitor suspicious processes and detect and prevent threats, unhooking techniques can create blind spots for them. The unhooking approaches outlined in the <span class="Xref">“Anti-hooking”</span> section on <span class="Xref"><a href="chapter8.xhtml#pg_137">page 137</a></span> can be effective for some EDR and anti-malware software, but advanced host defenses are expecting them. These defenses may monitor their own hooks at the kernel level using their installed kernel components, and malware in turn could tamper with and unhook endpoint defenses at the kernel level.</p>&#13;
<p class="TX">The cat-and-mouse game that malware authors and host defenses play is evident here. Endpoint protection software monitors and hooks into malware. The malware scans for these hooks and unhooks them or tries to circumvent them in other ways. In response, the endpoint protection products check whether they’ve been unhooked, and the cycle continues. Endpoint defenses have some advantage here, however. If a program tries to remove hooks, the EDR or anti-malware software can assume that the process is malicious with some level of confidence, as there’s virtually no legitimate reason for unhooking.</p>&#13;
<p class="TX">As mentioned earlier in this chapter, endpoint defenses might use other sources of system monitoring, such as ETW, to supplement traditional hook-based monitoring. These data sources could also be blinded in various ways; in fact, there’s already a considerable amount of research on blinding ETW. This can be accomplished in multiple ways, one of which is to hook or patch <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwEventWrite</samp>, a function critical to ETW’s operation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h-209"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Exploiting Vulnerabilities in Host Defense Tooling</samp></h4>&#13;
<p class="TNI1">Anti-malware, EDR, and other defenses are developed by humans, and humans make mistakes, so inevitably there will be bugs in the product code that could lead to vulnerabilities threat actors can exploit. There haven’t been many publicly reported attempts to exploit defense tooling during attacks, but it’s always a possibility, especially for threat actors that have the means and ability to discover these bugs. A quick search in the MITRE CVE vulnerability database (<a href="https://cve.mitre.org"><i>https://<wbr/>cve<wbr/>.mitre<wbr/>.org</i></a>) reveals some public vulnerabilities in anti-malware products, as shown in <a href="chapter13.xhtml#fig13-8">Figure 13-8</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>&#13;
<figure class="IMG"><img class="img100" id="fig13-8" src="../images/fig13-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-8: Vulnerabilities in anti-malware products, as reported by MITRE</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This list includes vulnerabilities discovered in the anti-malware engines of Watchdog, Kaspersky, and F-Secure products. Most of the vulnerabilities listed are <i>denial-of-service (DoS)</i> bugs that could allow specially crafted code to crash the anti-malware engine or otherwise hamper its effectiveness.</p>&#13;
<p class="TX">That sums up our tour of active circumvention techniques. Now we’ll turn to passive circumvention, which can be a stealthier and equally effective approach.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h3 class="H1" id="sec20"><span id="h-210"/><samp class="SANS_Futura_Std_Bold_B_11">Passively Circumventing Endpoint Defenses</samp></h3>&#13;
<p class="TNI1">Passive circumvention techniques involve slipping past host defenses without directly tampering with them. As you’ll see, these methods can be just as fruitful as active techniques without raising as many alarms.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h-211"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Circumventing Monitoring</samp></h4>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> discussed how malware can circumvent API hooking and monitoring in an attempt to evade sandboxes. Malware can use similar techniques to circumvent endpoint defenses. Because endpoint defenses also rely on function hooking to intercept and monitor suspicious activities, circumventing and bypassing these hooks is often an effective way to blind them.</p>&#13;
<p class="TX">Since anti-malware and EDR monitor various Windows API calls to detect malicious activities, one circumvention measure is to implement <i>direct syscalls</i>, or calls into kernel address space from user mode that circumvent the typical syscall procedure. Specifically, when a program invokes an API function in user mode, the operating system makes a syscall into <i>ntosknrl.exe</i> to access the function’s code (see <a href="chapter13.xhtml#fig13-9">Figure 13-9</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/>&#13;
<figure class="IMG"><img class="img70" id="fig13-9" src="../images/fig13-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-9: Normal syscall behavior</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Instead of relying on the normal Windows and NT API calling process, though, malware can directly make the syscall (see <a href="chapter13.xhtml#fig13-10">Figure 13-10</a>).</p>&#13;
<figure class="IMG"><img class="img70" id="fig13-10" src="../images/fig13-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-10: A direct syscall</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Syscalls follow a basic pattern called a <i>syscall stub.</i> The purpose of the stub is to transfer execution flow from user mode to kernel mode, where the code of the function being invoked actually resides. The following code shows a syscall stub for the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function:</p>&#13;
<pre class="pre-115"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label="241"/>mov r10, rcx&#13;
mov eax, 18&#13;
test byte ptr ds:[7FFE0308], 1&#13;
jne ntdll.7FF80B57C3C5&#13;
syscall&#13;
ret</code></pre>&#13;
<p class="TX">The most important part of the stub is the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov eax, 18</samp> line, in which <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp> represents the <i>system service number (SSN)</i>, sometimes referred to as the <i>syscall number</i> or <i>syscall ID</i>. This number maps to the function code (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>) that will be called in kernel mode. The next most important part of the stub is the <samp class="SANS_TheSansMonoCd_W5Regular_11">syscall</samp> instruction (in hex, <samp class="SANS_TheSansMonoCd_W5Regular_11">0F 05</samp>), which uses the SSN in the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register to direct execution flow to the corresponding kernel function. The return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>) instruction transfers execution flow back to the main program code once the syscall returns and has completed.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The syscall stubs we’ve discussed thus far are specific to the x64 architecture. The x86 programs often use a different call:</i> <span class="note_Italic">sysenter</span><i>. Sysenter stubs are very similar:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove">mov edx, esp</p>&#13;
<p class="NoteCode">sysenter</p>&#13;
<p class="NoteCodeSpaceBelow">ret</p>&#13;
<p class="NoteContinued1"><i>The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov edx, esp</samp> instruction moves the SSN (stored in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ESP</samp>) to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EDX</samp> and passes it to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sysenter</samp> instruction (hex <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">0F</samp></i> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">34</samp><i>). Note that some x64 programs also use sysenter calls.</i></p>&#13;
</blockquote>&#13;
<div class="spc"/>&#13;
<p class="TX">If malware wants to make a direct syscall (to avoid EDR or anti-malware hooks), it just needs to know the SSN of the function to call and then directly invoke the syscall. Sounds simple enough, but there are a few hurdles malware authors may face; most notably, function SSNs change depending on the Windows version and patch level of the target host. To get around this problem, malware authors have a few options. One option is to extract the SSNs from the <i>ntdll.dll</i> loaded in memory (see <a href="chapter13.xhtml#fig13-11">Figure 13-11</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-11" src="../images/fig13-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-11: Syscall stubs in the loaded</samp> <samp class="SANS_Futura_Std_Book_11">ntdll.dll</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">module</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/><a href="chapter13.xhtml#fig13-11">Figure 13-11</a> illustrates what <i>ntdll.dll</i> syscall stubs look like loaded in memory. Notice the highlighted SSNs for some of the exported <i>ntdll.dll</i> functions. Malware can inspect its loaded modules in memory, locate the relevant syscall stubs, and identify the SSN it requires. Once it obtains the SSN for the function it wants to call, it can craft its own syscall stubs, bypassing the standard syscall invocation from <i>ntdll.dll</i>. The following code illustrates the use of syscalls (more accurately, sysenters) in a variant of Remcos (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 45cd8dd797af4fd769eef00243134c46c38bd9e65e15d7bd2e9b834d5e8b3095</samp>):</p>&#13;
<pre class="pre-116"><code><var>--snip--</var>&#13;
sub_1D29    proc near&#13;
      push  2BC12D2Eh&#13;
      call  resolve_ssn     ; NtMapViewOfSection&#13;
      call  invoke_sysenter&#13;
      retn  28h&#13;
<var>--snip--</var>&#13;
sub_1D3B    proc near&#13;
      push  3ACFFF22h&#13;
      call  resolve_ssn     ; NtWriteVirtualMemory&#13;
      call  invoke_sysenter&#13;
      retn  8&#13;
<var>--snip--</var>&#13;
sub_1D4D    proc near&#13;
      push  7C9B2C0Bh&#13;
      call  resolve_ssn     ; NtResumeThread&#13;
      call  invoke_sysenter&#13;
      retn  8&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This Remcos sample resolves the SSNs of the functions it wishes to call by enumerating the <i>ntdll.dll</i> file on disk (not shown here). It subsequently calls a function that contains the standard sysenter stub. Specifically, this Remcos sample is attempting to covertly inject code into another process by making direct sysenter calls to invoke the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>, and others.</p>&#13;
<p class="TX">One problem with this approach is that these syscalls aren’t originating from their intended module, <i>ntdll.dll</i>. This can be a dead giveaway for endpoint defenses looking for this type of anomaly. A stealthier option, sometimes called an <i>indirect</i> syscall, is for malware authors to simply reuse the syscalls in <i>ntdll.dll</i> rather than crafting their own syscall stubs. To accomplish this, the malware identifies the syscall stub address in <i>ntdll.dll</i> for the function it wishes to call. Then, rather than including a call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp> function, for example, the malware implements a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> instruction to jump directly to that syscall stub inside <i>ntdll.dll</i>.</p>&#13;
<p class="TX">These are just a few of the tricks malware authors might use to bypass hooks installed by endpoint defenses. However, these techniques are not foolproof. As you’ve seen, many can produce suspicious indicators (enumerating <i>ntdll.dll</i> memory, invoking syscalls directly from the malware’s code, making direct jumps into <i>ntdll.dll</i>, and so on). Not only that, but also many <span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>modern endpoint defenses hook into the kernel to attempt to spot this sort of activity.</p>&#13;
<p class="TX">Evasion using syscall invocation is a fascinating topic, so if you’re interested in learning more, I recommend the following references:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Usman Sikander, “AV/EDR Evasion Using Direct System Calls (User-Mode vs. Kernel-Mode),” <i>Medium</i>, March 11, 2022, <a href="https://medium.com/@merasor07/av-edr-evasion-using-direct-system-calls-user-mode-vs-kernel-mode-fad2fdfed01a"><i>https://<wbr/>medium<wbr/>.com<wbr/>/@merasor07<wbr/>/av<wbr/>-edr<wbr/>-evasion<wbr/>-using<wbr/>-direct<wbr/>-system<wbr/>-calls<wbr/>-user<wbr/>-mode<wbr/>-vs<wbr/>-kernel<wbr/>-mode<wbr/>-fad2fdfed01a</i></a>.</li>&#13;
<li class="BL">Cornelis, “Red Team Tactics: Combining Direct System Calls and sRDI to bypass AV/EDR,” <i>Outflank</i>, June 19, 2019, <a href="https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/"><i>https://<wbr/>www<wbr/>.outflank<wbr/>.nl<wbr/>/blog<wbr/>/2019<wbr/>/06<wbr/>/19<wbr/>/red<wbr/>-team<wbr/>-tactics<wbr/>-combining<wbr/>-direct<wbr/>-system<wbr/>-calls<wbr/>-and<wbr/>-srdi<wbr/>-to<wbr/>-bypass<wbr/>-av<wbr/>-edr<wbr/>/</i></a>.</li>&#13;
<li class="BL">Red Team Notes, “Calling Syscalls Directly from Visual Studio to Bypass AVs/EDRs,” <i>Red Team Notes</i>, n.d., <a href="https://www.ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs"><i>https://<wbr/>www<wbr/>.ired<wbr/>.team<wbr/>/offensive<wbr/>-security<wbr/>/defense<wbr/>-evasion<wbr/>/using<wbr/>-syscalls<wbr/>-directly<wbr/>-from<wbr/>-visual<wbr/>-studio<wbr/>-to<wbr/>-bypass<wbr/>-avs<wbr/>-edrs</i></a>.</li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h-212"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Circumventing Signature-Based Detection</samp></h4>&#13;
<p class="TNI1">As we’ve discussed, anti-malware uses signature-based detection mechanisms, meaning that it looks for common patterns to identify malicious code in files and in memory. Malware often contains strings, function names, or DLL and module names that are hardcoded in its executable or that reside in memory and can be used to expose it. Thus, simply modifying these strings, functions, and module names can often lead to lower rates of detection, at least by more traditional anti-malware solutions. This is one of the most basic ways to abuse signature-based anti-malware detections, but modern malware requires more sophisticated evasion techniques to deal with more sophisticated anti-malware solutions. This is where mutation comes in.</p>&#13;
<p class="TX"><i>Mutation</i> is malware’s ability to change its features and code in order to evade detection or adapt to its environment. With mutation, the malware’s goal is to change its code just enough to fly under the radar while retaining its basic functionalities. To help you better understand mutation, let’s look at the life cycle of a typical malware sample.</p>&#13;
<p class="TX">Some malware authors, notably cybercrime groups, “spam” malware to hundreds or thousands of potential victims, expecting to trick a few unsuspecting people into executing it. Once enough victims have been infected by a strain of malware, investigators will inevitably get their hands on the sample and develop detection rules for it, which will then be implemented in anti-malware engines and other defense technologies. This can quickly reduce the lifespan of any given piece of malware. This doesn’t apply just to mass spam malware, however; it can also be true of more targeted malware. If the malware is able to mutate on the victim host, it may be able to similarly evade detection.</p>&#13;
<p class="TX">There are different forms of mutation, such as <i>code block reordering</i>, in which code is shifted around and reordered to create new “variants” of the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/>malware, and <i>register reassignment</i>, in which CPU registers are changed (for example, all ECX register references are changed to EDX). These mutations of the malware’s code, implemented by a <i>mutation engine</i>, can significantly change the code’s structure and signature. The following is a very simple example of a mutation that shows how assembly code may be functionally identical but appears different:</p>&#13;
<pre class="pre-117"><code>mov eax, 0&#13;
add eax, 1</code></pre>&#13;
<p class="TX">This example code block simply sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and then sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Compare this to the following code:</p>&#13;
<pre class="pre-118"><code>xor eax, eax&#13;
inc eax</code></pre>&#13;
<p class="TX">This code also sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (but using the <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> instruction rather than the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction) and then sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> (using the <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> instruction instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>). If this were actual malicious code, anti-malware software might have a detection signature for one of these code blocks, but perhaps not the other. In the real world, of course, this code would be a lot more complex.</p>&#13;
<p class="TX">Mutation can occur either dynamically during runtime or on the malware file itself. Mutation during runtime occurs once the malware executes on the victim system. The malware may dynamically alter its code in memory to evade defenses that scan for malicious code patterns in memory. Mutation on the malware file itself occurs before the malware is delivered to the victim. The malware author may run their code through a mutation engine that spits out unique variants of the same malware that can all be delivered to different victims. Packers, which I’ll discuss in detail in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>, can be a form of both runtime and static file mutation. When malware is run through a packing engine, it is obfuscated so that it will appear unique to all other variants of the same malware family.</p>&#13;
<p class="TX">The virus-like ransomware malware family Virlock provides a good example of mutation. When Virlock (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 7a92e23a6842cb51c9959892b83aa3be633d56ff50994e251b4fe82be1f2354c</samp>) executes on a victim system, it decrypts three instances of itself in memory and drops them to the disk as files. All three instances differ from all other Virlock malware samples and have a different signature. This ensures the malware will remain undetected, at least by anti-malware engines that rely on hashes and basic file signatures for detection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h-213"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Uncommon Programming Languages</samp></h4>&#13;
<p class="TNI1">In an attempt to circumvent endpoint defenses, malware authors may use obscure or uncommon programming languages to develop their malware. Anti-malware software may be unfamiliar with the code and data structure in these languages, and it takes time for its signature and heuristic detections to catch up. Uncommon or new programming languages can also create a challenge for malware analysts and reverse engineers who <span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>are expecting more typical malware code, such as C or C++. Furthermore, many of these uncommon languages can be used across different operating systems. For instance, a program written for Windows can also run on macOS or Linux as long as the victim system has the required libraries installed. This can make the malware more resilient to different operating systems.</p>&#13;
<p class="TX">Using uncommon languages isn’t a new technique. Early malware was often written in C, but malware authors began using the .NET framework (such as C#), which is still very popular. However, anti-malware and other defenses have caught up, so malware authors are adapting and now increasingly using other languages. Python, a very common scripting language, has seen more use in malware in both scripts and executable format. Malware authors simply code a malicious Python script (<i>.py</i>), which can be executed on any system that has the right Python libraries installed. Tools such as Py2Exe and PyInstaller can even convert a Python script into an executable, which the attacker can deploy on a victim machine similar to a standard PE file. Since it’s fairly trivial to code a malicious Python script and then convert it into an executable, this approach has a lower barrier to entry for malware authors.</p>&#13;
<p class="TX">Nim (<a href="https://nim-lang.org"><i>https://<wbr/>nim<wbr/>-lang<wbr/>.org</i></a>), a self-proclaimed “statically typed compiled systems programming language,” has also seen growing use with malware authors. Notably, Nim was used by the threat group behind the infamous Trickbot banking trojan (see Lawrence Abrams’s article “TrickBot’s BazarBackdoor Malware is Now Coded in Nim to Evade Antivirus” at <a href="https://www.bleepingcomputer.com/news/security/trickbots-bazarbackdoor-malware-is-now-coded-in-nim-to-evade-antivirus/"><i>https://<wbr/>www<wbr/>.bleepingcomputer<wbr/>.com<wbr/>/news<wbr/>/security<wbr/>/trickbots<wbr/>-bazarbackdoor<wbr/>-malware<wbr/>-is<wbr/>-now<wbr/>-coded<wbr/>-in<wbr/>-nim<wbr/>-to<wbr/>-evade<wbr/>-antivirus<wbr/>/</i></a>). Using Nim potentially helped the malware evade AV defenses.</p>&#13;
<p class="TX">Go (sometimes called Golang) is an open source language from Google. It’s simple to program in (compared with other compiled languages such as C), so it’s no surprise that it has also seen increased use in malware. Rust (<a href="https://www.rust-lang.org"><i>https://<wbr/>www<wbr/>.rust<wbr/>-lang<wbr/>.org</i></a>) is another language seeing more use in malware development. Indeed, nearly any programming or scripting language can be used for nefarious purposes, so this section could get very long. Even PowerShell is being used more often by malware authors. Malware analysts and defenders would be wise to stay abreast of the different languages being used in modern malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h-214"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Abusing Certificate Trust and Signing</samp></h4>&#13;
<p class="TNI1">A <i>digital signature</i> is a trusted certificate that functions as a mark of approval for a file, informing the operating system and other applications that the file is legitimate and safe to execute. Many anti-malware solutions put less scrutiny on files that are digitally signed by a known and trusted authority. As a result, malware can abuse certificate trust chains to evade endpoint defenses.</p>&#13;
<p class="TX">The <i>certificate trust store</i> is the repository where Windows stores the signer certificates that it trusts. You can view the trust store on Windows with the certmgr application (which you can find in <i>C:\Windows\System32</i>), as shown in <a href="chapter13.xhtml#fig13-12">Figure 13-12</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/>&#13;
<figure class="IMG"><img class="img100" id="fig13-12" src="../images/fig13-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-12: Viewing the trust store in Windows with certmgr</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Malware authors can digitally sign their code with a trusted certificate in a few ways. First, if a threat actor were to infiltrate the network of a trusted company, it could generate valid certificates and sign its own malware with them, or it could steal certificates and digitally sign its malicious code with those. In fact, this has happened on more than one occasion, such as when code-signing certificates were stolen from Nvidia in 2022 (see Pieter Arntz’s article “Stolen Nvidia Certificates Used to Sign Malware—Here’s What to Do” at <a href="https://www.malwarebytes.com/blog/news/2022/03/stolen-nvidia-certificates-used-to-sign-malware-heres-what-to-do"><i>https://<wbr/>www<wbr/>.malwarebytes<wbr/>.com<wbr/>/blog<wbr/>/news<wbr/>/2022<wbr/>/03<wbr/>/stolen<wbr/>-nvidia<wbr/>-certificates<wbr/>-used<wbr/>-to<wbr/>-sign<wbr/>-malware<wbr/>-heres<wbr/>-what<wbr/>-to<wbr/>-do</i></a>). Code-signing certificates are sometimes even sold on the dark web!</p>&#13;
<p class="TX">Second, in certain circumstances it’s possible to insert malicious code into a previously signed executable file, all without invalidating the certificate. This was presented by researchers at the Black Hat conference in 2016 (see the report “Certificate Bypass: Hiding and Executing Malware from a Digitally Signed Executable,” from the Deep Instinct Research Team, at <a href="https://www.blackhat.com/us-16/briefings/schedule/#certificate-bypass-hiding-and-executing-malware-from-a-digitally-signed-executable-3984"><i>https://<wbr/>www<wbr/>.blackhat<wbr/>.com<wbr/>/us<wbr/>-16<wbr/>/briefings<wbr/>/schedule<wbr/>/#certificate<wbr/>-bypass<wbr/>-hiding<wbr/>-and<wbr/>-executing<wbr/>-malware<wbr/>-from<wbr/>-a<wbr/>-digitally<wbr/>-signed<wbr/>-executable<wbr/>-3984</i></a>).</p>&#13;
<p class="TX">Finally, malware can simply add a certificate to the list of trusted certificates on the operating system. This is easier said than done: the malware must already be executing on the host with a high level of privileges. But if it succeeds, the malware author may be able to run any additional malware they wish to on the host.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h-215"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Abusing Engine Limitations</samp></h4>&#13;
<p class="TNI1">As mentioned earlier, anti-malware software (as well as EDR software that has built-in anti-malware capabilities) has the difficult task of balancing high rates of detection with the end-user experience. This means, first and foremost, that it must have a high success rate when detecting malicious code, while also limiting false positives. Additionally, the anti-malware scanning and monitoring activity must be transparent to the end user. These <span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/>scans shouldn’t impact the user experience at a level where the system becomes unusable or unstable. Cunning malware authors can take advantage of these restrictions using various techniques, two examples being delayed execution and memory bombing.</p>&#13;
<p class="TX">In the same way that some malware uses delayed execution to evade detection inside a sandbox (as discussed in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>), it may be able to “outsleep” an anti-malware scanning engine. One way it can do this is by waiting until a specific number of milliseconds have passed. Once, say, 600,000 milliseconds (10 minutes) have elapsed, the sample executes its malicious code. Because the anti-malware engine might have a time limit on its emulation or sandboxing engine (to prevent the anti-malware engine from indefinitely analyzing a large file and consuming valuable system resources), this technique sometimes allows malware to slip through undetected.</p>&#13;
<p class="TX"><i>Memory bombing</i>, a term coined in the book <i>Antivirus Bypass Techniques</i> by Uriel Kosayev and Nir Yehoshua (Packt, 2021), involves malware allocating excessively large regions of memory inside its process address space. Because anti-malware software must take into account its system resources consumption (CPU, memory, and so on), it might only quickly scan this large region of memory or even ignore it altogether, allowing the malicious code to go unnoticed. Note that this technique can also be effective against sandboxes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h-216"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Masquerading as a Safe File</samp></h4>&#13;
<p class="TNI1"><i>Masquerading</i> is used by malware authors to disguise malware as legitimate files. This technique is used primarily as a method of deceiving a victim rather than as a means of directly circumventing endpoint defenses. Masquerading can take many forms, including the following:</p>&#13;
<p class="ListHead"><b>Spoofing a filename</b></p>&#13;
<p class="ListPlainFirst">The malware author simply names a malicious file after a common system file or legitimate application file (such as <i>explorer.exe</i> or <i>PowerPoint.exe</i>) or slightly modifies a filename (such as <i>expl0rer.exe</i>). Malware authors could also change the file extension of malicious files to something more unassuming, such as renaming an <i>.exe</i> file to a <i>.jpg</i> file.</p>&#13;
<p class="ListHead"><b>Spoofing file metadata</b></p>&#13;
<p class="ListPlainFirst">The malware author spoofs the metadata of a malicious file, such as by using “Microsoft” as the file’s publisher or company name. A similar technique is reusing legitimate program icons. For example, malware might use the Microsoft Word logo to make its malicious file appear genuine.</p>&#13;
<p class="ListHead"><b>Executing social engineering attacks</b></p>&#13;
<p class="ListPlainFirst">The malware author tricks the user into executing the malware, for example, by sending an email to a target user with a malicious file called <i>important_invoice.pdf</i>. A similar technique is the use of double extensions. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>By default, Windows doesn’t display file extensions, so the file <i>financials.xls.exe</i> would display in Windows as simply <i>financials.xls</i>. This may mislead an unsuspecting person into launching a malicious executable file.</p>&#13;
<div class="spc"/>&#13;
<p class="TX">Even though masquerading is a relatively simple and inexpensive technique to implement, it can be quite effective. Notably, researchers from ESET reported that the threat group Sandworm delivered to victims in Ukraine malware disguised as a component of the IDA Pro disassembly tool and ESET’s own security software (see Kelly Jackson Higgins’s article “Sandworm APT Trolls Researchers on its Trail as it Targets Ukraine” at <a href="https://www.darkreading.com/threat-intelligence/sandworm-apt-trolls-researchers-on-its-trail-while-it-targets-ukraine"><i>https://<wbr/>www<wbr/>.darkreading<wbr/>.com<wbr/>/threat<wbr/>-intelligence<wbr/>/sandworm<wbr/>-apt<wbr/>-trolls<wbr/>-researchers<wbr/>-on<wbr/>-its<wbr/>-trail<wbr/>-while<wbr/>-it<wbr/>-targets<wbr/>-ukraine</i></a>). Another notable example of masquerading is malware imitating documents authored by reputable organizations, such as COVID-19–related information from the World Health Organization, as reported by Proofpoint in 2022 (see “Nerbian RAT Using COVID-19 Themes Features Sophisticated Evasion Techniques” from Andrew Northern and colleagues at <a href="https://www.proofpoint.com/us/blog/threat-insight/nerbian-rat-using-covid-19-themes-features-sophisticated-evasion-techniques"><i>https://<wbr/>www<wbr/>.proofpoint<wbr/>.com<wbr/>/us<wbr/>/blog<wbr/>/threat<wbr/>-insight<wbr/>/nerbian<wbr/>-rat<wbr/>-using<wbr/>-covid<wbr/>-19<wbr/>-themes<wbr/>-features<wbr/>-sophisticated<wbr/>-evasion<wbr/>-techniques</i></a>).</p>&#13;
<p class="TX">So far, we’ve explored different techniques malware uses to circumvent host defenses by actively tampering with them or passively slipping by them. Now let’s shift gears a bit and explore privilege elevation and how it can be used by malware to carry out operations that may otherwise be detected and blocked by endpoint defenses.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1" id="sec27"><span id="h-217"/><samp class="SANS_Futura_Std_Bold_B_11">Privilege Elevation for Defense Evasion</samp></h3>&#13;
<p class="TNI1"><i>Privilege elevation</i>, or obtaining a higher level of privileges than one currently holds, can be a potent evasion tactic. After obtaining a high privilege level on the host, an attacker has a lot more freedom to execute further attacks that bypass endpoint defenses. As you’ve seen, high privilege levels are required for actions such as disabling anti-malware or modifying firewall configurations. While there are many ways to elevate privileges, this section will focus on four of the most common techniques in modern malware: UAC bypasses, access token impersonation and manipulation, credential reuse, and direct exploitation.</p>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h-218"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Bypassing User Account Control</samp></h4>&#13;
<p class="TNI1"><i>User Account Control (UAC)</i> is a protection control in Windows designed to prevent unauthorized applications from executing code at high privilege levels. When an application requests administrator access, an administrator on the system must consent to the request (see <a href="chapter13.xhtml#fig13-13">Figure 13-13</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/>&#13;
<figure class="IMG"><img class="img70" id="fig13-13" src="../images/fig13-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-13: A typical UAC pop-up</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When an administrator consents, the application’s process integrity level increases to “high.” The most common integrity levels (high, medium, low, and system) help dictate what a process can and cannot do on a system. High-integrity processes run in an elevated mode and have access to objects assigned to lower integrity levels. Medium-integrity processes run with standard user rights; this is the default setting for most processes. Low-integrity processes have the lowest privilege level and are usually reserved for applications such as web browsers that should run in a container-like environment for security reasons. System integrity processes are those that are integral to the stability of the operating system; these include the Service Control Manager (<i>services.exe</i>) and the Windows subsystem process (<i>csrss.exe</i>). By design, processes with lower integrity levels cannot modify data in processes with higher integrity levels.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#fig13-14">Figure 13-14</a> shows an excerpt from Process Hacker, which conveniently highlights processes based on their elevation and integrity levels.</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-14" src="../images/fig13-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-14: Process integrity viewed in Process Hacker</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Process Hacker itself (<i>ProcessHacker.exe</i>) is highlighted in orange (or dark gray in this book), meaning that it’s elevated and running in a high-integrity mode. <i>Explorer.exe</i> is highlighted in pink (medium gray), demarcating it as a system process. The other, more mundane processes, such as Excel and Notepad, are yellow (light gray), meaning that they’re medium-integrity processes running with standard user privileges.</p>&#13;
<p class="TX">UAC works to protect systems against malicious privilege elevation attempts by explicitly requesting permission from a higher-level account. UAC <span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/>bypass attacks rely on tricking a user, an application, or the operating system itself into executing potentially dangerous actions in an elevated context. Let’s take a look at how UAC bypasses work in practice with a simple example.</p>&#13;
<p class="TX">A number of built-in Windows utilities are designed to be run with elevated permissions. One of these utilities is <i>msconfig.exe</i>, a simple Windows configuration tool that allows system administrators to change Windows boot options and modify services and startup tasks, among other things. Normally, applications requesting elevated permissions produce a UAC prompt; by default, even users with administrator privileges must consent to this prompt. If executed from an administrator account, however, <i>msconfig.exe</i> automatically elevates itself to a high-integrity process without prompting for UAC. Furthermore, it allows for the execution of other tools that will subsequently run in a high-integrity context, also without a UAC prompt. Unfortunately for <i>msconfig.exe</i>, an actor can abuse this behavior, resulting in a simple UAC bypass. From the Tools menu in <i>msconfig.exe</i>, a user can select the Command Prompt tool and click Launch (see <a href="chapter13.xhtml#fig13-15">Figure 13-15</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-15" src="../images/fig13-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-15: Launching a command prompt from</samp> <samp class="SANS_Futura_Std_Book_11">msconfig.exe</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, a new command prompt with the integrity level of its parent process (<i>msconfig.exe</i>) will launch, without prompting for UAC permission. <a href="chapter13.xhtml#fig13-16">Figure 13-16</a> shows this new <i>cmd.exe</i> process in Process Hacker.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/>&#13;
<figure class="IMG"><img class="img100" id="fig13-16" src="../images/fig13-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-16: The</samp> <samp class="SANS_Futura_Std_Book_11">cmd.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process spawned with high integrity</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice that the process’s privileges are elevated (“Elevated: Yes”) and its integrity is high. The user bypassed UAC by executing a process that must be run in a high-integrity context (which doesn’t prompt for UAC permission on the default Windows configuration) and by spawning a command prompt that inherits that process’s high integrity level. This command prompt is now running as administrator and can be used to execute high-privilege commands. A similar real-world example of this comes from the malware family Trickbot, which abuses the auto-elevation property of the <i>WSReset.exe</i> Windows tool; see the article “Trickbot Trojan Leveraging a New Windows 10 UAC Bypass,” by Arnold Osipov at <a href="https://blog.morphisec.com/trickbot-uses-a-new-windows-10-uac-bypass"><i>https://<wbr/>blog<wbr/>.morphisec<wbr/>.com<wbr/>/trickbot<wbr/>-uses<wbr/>-a<wbr/>-new<wbr/>-windows<wbr/>-10<wbr/>-uac<wbr/>-bypass</i></a>.</p>&#13;
<p class="TX">The problem with this particular UAC bypass is that it requires GUI access to the system, so malware would have to jump through quite a few hoops to execute this attack without the victim noticing what’s going on. Malware authors have discovered a few ways to get around this limitation, however.</p>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">DLL Hijacking</samp></h5>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, you learned that malware can abuse hijacking vulnerabilities in legitimate applications to inject a malicious DLL and stealthily run code. This type of attack is also an effective way to bypass UAC. Revisiting the <i>msconfig.exe</i> example used earlier, if it fell prey to DLL hijacking and allowed <span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label="252"/>a malicious DLL to be loaded in place of a legitimate one, the malicious DLL could then execute under the context of the high-privileged <i>msconfig.exe</i> application. Any UAC pop-ups will be under the guise of <i>msconfig.exe</i>, possibly tricking the user into consenting and allowing the malicious code to run at a higher privilege level than would otherwise be possible.</p>&#13;
<p class="TX">In a 2016 report from Fox-IT and NCC Group called “Mofang: A Politically Motivated Information Stealing Adversary” (which you can download at <a href="https://blog.fox-it.com/2016/06/15/mofang-a-politically-motivated-information-stealing-adversary/"><i>https://<wbr/>blog<wbr/>.fox<wbr/>-it<wbr/>.com<wbr/>/2016<wbr/>/06<wbr/>/15<wbr/>/mofang<wbr/>-a<wbr/>-politically<wbr/>-motivated<wbr/>-information<wbr/>-stealing<wbr/>-adversary<wbr/>/</i></a>), researchers highlighted such an attack by the threat group Mofang, which abused the legitimate <i>migwiz.exe</i> Windows application to load a DLL called <i>cryptbase.dll</i>. This DLL was hijacked by the attackers, causing <i>migwiz.exe</i> (which runs in an elevated state by default) to load the malicious version of <i>cryptbase.dll</i>, effectively bypassing certain UAC controls.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h5 class="H3" id="sec30"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">COM Abuse</samp></h5>&#13;
<p class="TNI1">The <i>Component Object Model (COM)</i> is a part of the Windows API that allows for interprocess communication. The basic building block of COM is a <i>COM object</i>, which is composed of data and the functions that control access to it, known as <i>interfaces</i>. A COM object server exposes interfaces to COM clients, and clients access the COM server via these interfaces. COM server objects are often <i>.dll</i> or <i>.exe</i> files. Each COM server object has a unique ID, called a class ID (CLSID), which is a 128-bit string that takes the form of a series of numbers and characters. These strings are often displayed in brackets, as in this example: <samp class="SANS_TheSansMonoCd_W5Regular_11">{4E5FC2F8-8C44-6776-0912-CB15617EBC13}</samp>. This will be important in a moment.</p>&#13;
<p class="TX">A number of COM objects have a property called <samp class="SANS_TheSansMonoCd_W5Regular_11">COMAutoApproval</samp>, which indicates that the particular COM object doesn’t require a user to explicitly permit the privilege elevation functions that are part of the object. On a Windows system, you can view the list of COM objects that have this property in the registry key <i>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UAC\COMAutoApprovalList</i>. <a href="chapter13.xhtml#fig13-17">Figure 13-17</a> shows this list on my system.</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-17" src="../images/fig13-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-17: Viewing COM objects with COMAutoApproval enabled</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">On a typical Windows 10 system, there are over 100 objects in this list! As you might imagine, some of these objects can be abused by malware to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label="253"/>bypass UAC. For example, some COM object interfaces contain functions that can execute arbitrary code. A COM interface may expose a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp>, for instance, that takes an arbitrary command as input. The following pseudocode illustrates this:</p>&#13;
<pre class="pre-119"><code>command = "cmd.exe copy malware.exe C:\System32\malware.exe"&#13;
CoInitialize(NULL);&#13;
comObj = CoCreateInstance (CLSID_VulnerableComObject, ..., ...,&#13;
IID_VulnerableComObject, &amp;pMethod);&#13;
pMethod-&gt;ExecuteCommand(command);</code></pre>&#13;
<p class="TX">This malware initializes COM (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoInitialize</samp>) and creates a COM instance (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoCreateInstance</samp>) of the COM object <samp class="SANS_TheSansMonoCd_W5Regular_11">VulnerableComObject</samp>. Once the COM object is initialized, the malware invokes the vulnerable <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp> method (which is exposed and exported via the COM object), passing <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> as a parameter. Because the COM object is running with high privileges, the subsequent command will also be executed with high privileges. This specific command copies the malware executable into the <i>System32</i> directory, an action that would normally display a UAC prompt.</p>&#13;
<p class="TX">This is a simplified version of this technique, but similar techniques have been used in real-world attacks. A well-researched project called UACME details a variation of this technique and many more at <a href="https://github.com/hfiref0x/UACME"><i>https://<wbr/>github<wbr/>.com<wbr/>/hfiref0x<wbr/>/UACME</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h5 class="H3" id="sec31"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registry Tampering</samp></h5>&#13;
<p class="TNI1">Although modifying the registry often requires high-level privileges on the victim system in the first place, malware can use the registry to sidestep the UAC prompt itself. Consider a scenario in which an attacker has control over the infected host and can execute commands on it but doesn’t have a GUI to the host. The attacker might still be required to click on UAC prompts to execute certain actions, and this can be problematic without a graphical interface to the victim system.</p>&#13;
<p class="TX">In this case, the malware can try to modify the registry key <i>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\EnableLUA</i> from the default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which will effectively disable UAC prompts on the host. Setting the key <i>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ConsentPromptBehaviorAdmin</i> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will also disable UAC prompts for administrator actions.</p>&#13;
<p class="TX">Note that the machine may need to be rebooted in order for these changes to take effect, which could be problematic for the attacker and provoke unwanted attention.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h-219"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Impersonating and Manipulating Access Tokens</samp></h4>&#13;
<p class="TNI1">Each process running on a system has an assigned access token inherited from its parent process, whose access token is in turn inherited from the user account that spawned it. This user account access token represents the rights and privileges of the user account. Process access tokens can be assigned different privileges: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>, for example, grants a user <span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label="254"/>or process the ability to back up files and directories; <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp> grants the process the ability to load a kernel driver; and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeShutdownPrivilege</samp> permits a process to shut down the system.</p>&#13;
<p class="TX">To gain additional privileges, malware can duplicate a token from another process, a technique often known as <i>token theft</i> or <i>token impersonation</i>. The malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">DuplicateToken</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">DuplicateTokenEx</samp> to create a copy of a token assigned to another process, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateLoggedOnUser</samp>, passing the duplicated token as a parameter. This assigns the permissions of the original token to the malware. The malware can also call <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp> to spawn a brand-new process and assign it the permissions of the duplicated token.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT"><i>Alternatively, malware can manipulate its own token and assign it new privileges. One such coveted privilege that malware may attempt to obtain is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeDebugPrivilege</samp>, which permits a process to inspect and manipulate other processes owned by other user accounts, up to and including the System account. If a lower-privileged process is allowed to manipulate System processes, it can potentially inject and execute code in the context of these processes, completely bypassing UAC controls or, at the very least, tricking users into permitting elevated actions via UAC.</i></p>&#13;
</blockquote>&#13;
<p class="TX">To gain the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> privilege, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcessToken</samp> function to open the access token of its process, then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>, passing <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> as a parameter. However, just because a process requests this privilege doesn’t mean the operating system will grant it. Only previously elevated processes can request and be granted this permission, so the malware must already be running in an elevated state. Malware usually will use one of the UAC bypass techniques mentioned earlier in this chapter to elevate its privileges and then grant itself <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> to gain further access to other system processes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h-220"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Extracting and Reusing Credentials</samp></h4>&#13;
<p class="TNI1">Locating and extracting account credentials can be a potent privilege elevation method. If malware can locate an administrator’s credentials, for example, it may be able to reuse them to create a process with elevated permissions, or even to move laterally to other hosts on the network and gain elevated privileges on those systems. There are many ways malware can do this.</p>&#13;
<p class="TX">One method of extracting credentials is to inspect the memory of the <i>Local Security Authority Subsystem Service (LSASS)</i> process, which oversees security policies and authentication. By nature, its process (<i>lsass.exe</i>) contains sensitive data in its memory address space—namely, login credentials and security tokens. On modern versions of Windows, this sensitive data is obfuscated (for example, via hashing), but in special circumstances it may be in cleartext. By inspecting the process memory of <i>lsass.exe</i>, malware may be able to locate and extract privileged credentials and tokens, then attempt to reuse them to elevate its own privileges.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>There are some tools that can automate this process. One well-known example, Mimikatz (<a href="https://github.com/gentilkiwi/mimikatz"><i>https://<wbr/>github<wbr/>.com<wbr/>/gentilkiwi<wbr/>/mimikatz</i></a>), can extract credentials (and other sensitive data) from the victim system’s memory. Even though Mimikatz has existed since 2011, it is still actively updated and often used in real-world attacks. Some attack frameworks, such as Cobalt Strike, even have tools like Mimikatz built in.</p>&#13;
<p class="TX">Another method of credential extraction is <i>keylogging</i>, an effort to capture the victim’s keystrokes to obtain login credentials for various accounts and services. Keylogging is often implemented with different forms of hooking, as described in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h4 class="H2" id="sec34"><span id="h-221"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Exploiting Vulnerabilities for Privilege Elevation</samp></h4>&#13;
<p class="TNI1">Finally, some malware may attempt to exploit vulnerabilities in order to elevate its privileges. <i>Local privilege elevation</i> (<i>LPE</i>) vulnerabilities, which allow a malware to elevate its privileges on a system it already has lower-level access to, are especially popular among threat actors. One notable, relatively recent example of exploitation for privilege escalation is the CVE-2021-36934 vulnerability (see <a href="https://cve.mitre.org"><i>https://<wbr/>cve<wbr/>.mitre<wbr/>.org</i></a>), nicknamed “HiveNightmare,” which affected Windows 10 and some versions of Windows 11. HiveNightmare takes advantage of an access control issue in certain Windows directories. Inside these directories lie registry hives containing sensitive data, such as stored credentials, that’s not normally accessible to underprivileged users. However, by exploiting this vulnerability, an attacker could access backups of this sensitive data inside the Windows <i>Volume Shadow Copy Service (VSS)</i>, a Windows backup mechanism that stores copies of files and other data. In vulnerable versions of Windows, the attacker could craft a special payload that exploits this access control flaw, allowing the attacker to access unlocked copies of the sensitive registry hive data and use the stored credentials to elevate their privileges on the system.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#fig13-18">Figure 13-18</a> illustrates this exploit in action. (The exploit code can be obtained at <a href="https://github.com/GossiTheDog/HiveNightmare"><i>https://<wbr/>github<wbr/>.com<wbr/>/GossiTheDog<wbr/>/HiveNightmare<wbr/></i></a>.)</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-18" src="../images/fig13-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-18: The HiveNightmare exploit in action</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>This exploit code dumps the extracted registry hive files into the current working directory. A quick directory listing reveals that the exploit was successful (see <a href="chapter13.xhtml#fig13-19">Figure 13-19</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-19" src="../images/fig13-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-19: The HiveNightmare exploitation was successful!</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This attack may not look like much from the captured screenshots, but it’s powerful. As a nonprivileged user, I was able to extract sensitive registry hives directly from VSS that otherwise would not be available to me; had I wanted to, I could have queried them for stored credentials that I could then have used to execute code at a high privilege level. This is just one example of a vulnerability (and also a good example of credential extraction), but numerous privilege elevation vulnerabilities have been released over the past five years; some are high profile, and some are actively being abused by malware in the wild. Unfortunately, there are likely more similar vulnerabilities that are still unknown to the public.</p>&#13;
<p class="TX">Now that we’ve looked at some ways in which malware might circumvent endpoint defenses, let’s shift our focus to how it could circumvent network defense controls.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h3 class="H1" id="sec35"><span id="h-222"/><samp class="SANS_Futura_Std_Bold_B_11">Circumventing Network Defenses</samp></h3>&#13;
<p class="TNI1"><i>Network controls</i> are another layer of defense that malware must bypass in order to be successful. Circumventing network defenses relies on many of the tactics you’ve already seen in previous chapters. For example, malware can take advantage of obfuscation techniques such as encryption to conceal its C2 traffic. It can also leverage sandbox evasion techniques to circumvent network defenses that rely on sandboxing of suspicious files traversing the network. In this section, I’ll focus on circumvention techniques that haven’t yet been covered in the book. Before we start, however, I’ll briefly introduce some of the various network defenses available.</p>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h4 class="H2" id="sec36"><span id="h-223"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Introducing Modern Network Defenses</samp></h4>&#13;
<p class="TNI1">As with host defenses, the network defense market is flooded with product names and acronyms. At a fundamental level, there are only a few different types of modern network defenses. The ones I’ll focus on in this chapter are NIDS, NDR, and email protection:</p>&#13;
<p class="ListHead"><b>Network intrusion detection systems (NIDS)</b></p>&#13;
<p class="ListPlainFirst">These products monitor incoming and outgoing network traffic, searching for signs of malicious activity. Much like anti-malware, NIDS can be signature based, anomaly based, or a combination of the two. Signature-based NIDS techniques search for suspicious signature <span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/>patterns in network traffic such as sequences of data, code, or strings. Anomaly-based techniques look more into behavioral patterns of network traffic and may leverage machine learning techniques. NIDS can also be <i>intrusion prevention systems (IPS)</i>, which not only detect attacks but also respond to and prevent them. Both NIDS and IPS are often included in modern implementations of more traditional network defenses like firewalls.</p>&#13;
<p class="ListHead"><b>Network detection and response (NDR)</b></p>&#13;
<p class="ListPlainFirst">This is the network equivalent of EDR. NDR is a more modern solution than NIDS and in some ways seeks to replace it. NDR uses real-time network traffic analysis to identify potential attacks, detect threats (such as malware) traversing the network, and be triggered by suspicious behaviors. The telemetry of NDR and host-based EDR can be combined to create extended detection and response (XDR), which allows analysts and investigators to track attacks across both the network and endpoint layers.</p>&#13;
<p class="ListHead"><b>Email protection technologies</b></p>&#13;
<p class="ListPlainFirst">These solutions, which are becoming more widely used and necessary, sit at the email gateway of an organization and monitor and inspect inbound and outbound email traffic. This is a crucial control, as many inbound emails are laced with malicious attachments or URLs. Email protection suites scan and sandbox inbound and (sometimes) outbound emails, then raise alerts on (or simply delete) malicious ones. Since this technology partly relies on sandboxing, it can potentially be thwarted by the previously discussed anti-sandbox techniques.</p>&#13;
<div class="spc"/>&#13;
<p class="TX">Now we’ll start looking at the ways in which malware might try to circumvent these controls.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h4 class="H2" id="sec37"><span id="h-224"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Obfuscating and Obscuring Network Traffic</samp></h4>&#13;
<p class="TNI1">To bypass NIDS and NDR, modern malware must employ obfuscation or encryption techniques to mask its network traffic. Some malware may attempt to hide from network defenses while downloading additional payloads or modules using encrypted network protocols such as HTTPS, Secure File Transfer Protocol (SFTP), or Secure Shell (SSH). Malware has even been known to make use of the encrypted surveillance protection software Tor to obscure its network activities. The malware family Bashlite (also known as Gafgyt) has been observed using this technique when communicating with its C2 infrastructure. Keep in mind that the very act of using Tor and other lesser-used protocols and services can itself be a telltale sign of malicious activity. While this technique may indeed prevent network defenses and investigators from inspecting the suspicious traffic, it doesn’t mean the malware will go completely undetected.</p>&#13;
<p class="TX">Another example of this tactic is <i>DNS tunneling</i>, which abuses the Domain Name System (DNS) protocol to hide traffic such as file downloads, exfiltration of data from the network, or C2 communication. Since <span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>DNS is a fundamental protocol that the internet runs on, DNS tunneling may go completely unnoticed by network monitoring and defenses. <a href="chapter13.xhtml#fig13-20">Figure 13-20</a> illustrates what DNS tunneling looks like.</p>&#13;
<figure class="IMG"><img class="img80" id="fig13-20" src="../images/fig13-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-20: DNS tunneling</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s start with the infected host, which has a remote access trojan (RAT) hiding on it. This RAT communicates with its C2 server (<i>evil.com</i>) and requires special instructions that it will receive via DNS tunneling. It sends a DNS query to its C2 server (<i>36128.evil.com</i>). The <i>36128</i> subdomain is a randomized numerical string. Next, the DNS request is sent to a recursive DNS server, a local server that services DNS requests. This recursive DNS server may be an internet service provider (for home users and small businesses) or a server inside an organization that the host is part of.</p>&#13;
<p class="TX">Recursive DNS servers subsequently contact an <i>authoritative DNS server</i>, the source of authority for a domain. When a new website is provisioned from a hosting provider, the provider acts as the authoritative DNS server for that domain. Alternatively, anyone can establish their own authoritative DNS server for a domain name they have purchased. In this case, the RAT on the infected host is ultimately contacting the authoritative DNS server for the domain <i>evil.com</i>, and the malware author owns the authoritative DNS server for this domain.</p>&#13;
<p class="TX">Once the C2 server receives the DNS request, it responds with a reply to the sender. In this case, however, the reply includes an encoded command, the simple string <samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>. This command, which could be obfuscated with a simple algorithm such as Base64 or even encrypted, can be hidden away in one of the records inside a DNS response. Record types that are often abused for DNS tunneling are TXT, CNAME, Resource Records (RR), and NULL records. (These are outside the scope of this book and won’t be discussed further.)</p>&#13;
<p class="TX">Once the infected host receives the DNS response, the RAT decodes the embedded string and processes the command <samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>. Presumably, this means the RAT will then execute a malicious command. DNS by default is not encrypted, but again, since it’s so widely used and may be difficult to fully monitor, this type of attack may slip past network defenses.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>Malware has also been known to use custom C2 frameworks that employ novel methods of network communication. These frameworks may leverage publicly accessible services such as GitHub, Pastebin, Telegram, or even X to conceal traffic and commands. Not only is this traffic usually encrypted, but it also can go completely unnoticed since it appears normal. One example of this arose when researchers at ESET discovered that the threat group Turla abused Britney Spears’s Instagram account to conceal its C2 servers (see the article “Carbon Paper: Peering into Turla’s Second Stage Backdoor” at <a href="https://www.welivesecurity.com/2017/03/30/carbon-paper-peering-turlas-second-stage-backdoor/"><i>https://<wbr/>www<wbr/>.welivesecurity<wbr/>.com<wbr/>/2017<wbr/>/03<wbr/>/30<wbr/>/carbon<wbr/>-paper<wbr/>-peering<wbr/>-turlas<wbr/>-second<wbr/>-stage<wbr/>-backdoor<wbr/>/</i></a>). The Turla group pasted to Spears’s Instagram page encoded text representing a URL that contained the address of its C2 server. Malware on systems previously infected by the Turla group then monitored her Instagram profile for these specific patterns to retrieve the address information of the C2 servers. The address was then decoded by the malware and used to retrieve additional commands from the attacker’s infrastructure.</p>&#13;
<p class="TX">Attackers may also host their malware payloads on well-known file-sharing sites like Google Drive and Dropbox. Since these services are widely used for legitimate purposes, malware that’s downloading a payload or additional modules from Google Drive, for example, may look completely normal to a casual observer and to network defenses.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h4 class="H2" id="sec38"><span id="h-225"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Concealing Infrastructure Using Geofencing</samp></h4>&#13;
<p class="TNI1"><i>Geofencing</i> refers to the use of geographical locations as a factor that determines the malware’s behavior. In essence, the malware is designed to execute its payload only when the target host is located within a specific geographical boundary, such as a specific country. Geofencing can also be used to deter and prevent malware-scanning engines and analysts from identifying and investigating a malicious server. In the case of email protection solutions, for example, as malicious attachments are detonated in a sandbox, the sandbox may identify that the malware is attempting to communicate with an unknown domain on the internet. The sandbox may then try to “scan” or probe the server in an effort to identify its true nature and classify it as either legitimate or malicious.</p>&#13;
<p class="TX">Geofencing techniques can be used by a malicious server to prevent this behavior. By querying the location of the system or investigator probing its infrastructure, the server can hide itself from uninvited guests. A malware author in China, for example, may be specifically targeting victims in Germany. Any traffic to the malware’s C2 server not originating from an IP address in Germany can be blocked, preventing automated scanning engines or investigators without a German IP address from inspecting it more closely. Alternatively, the server could even display misleading information to systems not originating from Germany. For instance, any traffic from non-German IPs may be rerouted to a completely different, benign website. A similar technique was identified by researchers at Proofpoint, who revealed that the threat group TA547 leveraged geofencing to serve malware payloads to only certain targets (see the article “The First Step: Initial Access Leads to Ransomware” at <a href="https://www.proofpoint.com/us/blog/threat-insight/first-step-initial-access-leads-ransomware"><i>https://<wbr/>www<wbr/>.proofpoint<wbr/>.com<wbr/>/us<wbr/>/blog<wbr/>/threat<wbr/>-insight<wbr/>/first<wbr/>-step<wbr/>-initial<wbr/>-access<wbr/>-leads<wbr/>-ransomware</i></a>). Payloads were hosted on <span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>servers, and only victims originating from specific countries were allowed to access and download the malware payloads.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h4 class="H2" id="sec39"><span id="h-226"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Generating New Infrastructure Using DGAs</samp></h4>&#13;
<p class="TNI1">One major problem that malware authors face is the fact that once a C2 server is identified by a sandbox, investigator, or defense software, it is effectively “burned,” meaning it will soon be blocklisted by most security products. This renders the malware that communicates with this server ineffective.</p>&#13;
<p class="TX">Malware can get around this problem by dynamically generating new C2 server addresses using <i>domain generation algorithms (DGAs)</i>, which consist of client- and server-side components. The malware (the client, in this case) uses embedded DGA code to create new domain names. The malware’s C2 server uses the same algorithm to produce a new domain name identical to the one created by the malware client. DGA operates on the principle that both the client and server sides of the algorithm generate predictable domain names. This algorithm must generate the same domain name on both the client and server sides, but it must be unpredictable enough that security researchers and analysis tools can’t guess the next domain names that will be generated.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#fig13-21">Figure 13-21</a> illustrates how DGAs are used by malware.</p>&#13;
<figure class="IMG"><img class="img70" id="fig13-21" src="../images/fig13-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-21: How DGAs work</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The malware first generates a new domain name using DGA code embedded in its executable file. After executing the algorithm, the malware produces the domain <i>evil-01.tk</i>, and on the malware’s C2 infrastructure, the same algorithm runs and also produces <i>evil-01.tk</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then the malware author provisions a new server with the address <i>evil-01.tk</i> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The malware then connects to the C2 server using this domain name, which is now online <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">After a predetermined period of time, such as eight hours, the malware generates a new domain, <i>evil-02.cn</i> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. In turn, the server generates <span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>the same domain name, which is then provisioned <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Finally, the malware connects to it <span class="CodeAnnotation" aria-label="annotation6">❻</span>. By this time, the first server (<i>evil-01.tk</i>) is likely offline. This cycle repeats until the algorithm runs out of available domains. This powerful DGA technique allows malware authors to generate hundreds or thousands of new domain names to use as C2 servers, making it a game of “whack-a-mole” for security products and investigators to identify and add these domains to a blocklist.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
&#13;
<h4 class="H2" id="sec40"><span id="h-227"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Executing the Fast-Flux Technique</samp></h4>&#13;
<p class="TNI1"><i>Fast flux</i> is a type of evasion technique used in large part by <i>botnets</i>, networks of infected systems that an attacker controls. As victims are infected by a particular malware variant, the infected hosts (the <i>bots</i>) are added to the botnet. Botnets are used by threat actors for various purposes, such as to send spam, conduct phishing and <i>distributed denial-of-service (DDoS)</i> attacks, and facilitate various types of fraud. The fast-flux technique allows threat actors to use their bots as proxies for concealing and protecting C2 servers and other infrastructure.</p>&#13;
<p class="TX">To execute this technique, threat actors purchase a domain name and then rapidly change the IP address associated with the domain so that each time a victim visits it, they are directed to a different hosting IP address. This rapid changing of IP addresses is configured <i>round-robin</i> style, a legitimate technique for balancing client requests to a web server. By shortening the time-to-live (TTL) values of the IP addresses to several minutes or even less, the threat actor creates a more elusive infrastructure, making it more difficult for network defenses to identify and block malicious traffic, and for law enforcement and other investigators to identify its full infrastructure. <a href="chapter13.xhtml#fig13-22">Figure 13-22</a> breaks down what fast flux looks like in practice.</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-22" src="../images/fig13-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-22: The fast-flux technique implemented in a botnet</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, a victim executes malware on their computer, and the malware wants to make an HTTP connection to the threat actor’s domain, <i>evil.com</i>. Before this can happen, however, <i>evil.com</i> must be resolved to an IP address. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/>The victim makes a DNS request <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and <i>evil.com</i> is resolved (by an authoritative DNS server that the malware author controls) to the IP address 59.111.180.193 <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, the malware makes an HTTP request to the IP address 59.111.180.193 <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which is part of a botnet and assigned to Bot 1. Acting as a proxy, Bot 1 redirects the HTTP request to the threat actor’s malware delivery server <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which subsequently delivers the malware payload to the victim <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Minutes later, a new victim (infected with the same malware) makes a DNS and HTTP request for <i>evil.com</i>, just like the first victim. This time, however, the DNS server returns 97.66.36.178 as the IP (since the threat actor has already changed the IP address associated with this domain). This IP is mapped to Bot 2, which similarly proxies and redirects the HTTP request to the malware staging server and delivers a payload to the second victim. Because the IP address changes very frequently and is spread across the botnet (which could be a spiderweb of many thousands of systems), it is difficult to pin down the attacker’s infrastructure in order to identify the other systems in the botnet and the attacker’s malware distribution and C2 servers.</p>&#13;
<p class="TX">Fast flux is not only used in botnets; it’s also used by <i>bulletproof hosters (BPHs)</i>, which are web hosting providers that cater to less scrupulous web activities such as online gambling and spam or illegal activities such as organized crime. Normally, BPHs are housed in countries where this type of activity is not heavily scrutinized (and so goes unnoticed or is otherwise tolerated) and requests for takedown of malicious infrastructure from law enforcement agencies are not honored. BPHs may offer fast-flux services to cybercrime groups and others.</p>&#13;
<p class="TX">There’s a related technique, called <i>double fast flux</i>, where not only is the IP address of the malicious domain rapidly changed, but so is the IP address of the attacker’s authoritative DNS server(s). This adds an extra layer of defense and complexity for researchers and network defenses.</p>&#13;
<p class="TX">Very few of the techniques we have discussed throughout this chapter are effective on their own. Modern malware-based attacks often use a combination of these techniques to infiltrate their targets, as you’ll see next.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h3 class="H1" id="sec41"><span id="h-228"/><samp class="SANS_Futura_Std_Bold_B_11">Multistage and Complex Attacks</samp></h3>&#13;
<p class="TNI1">As mentioned earlier in this chapter, some modern defenses like EDR use a threat-scoring system or other analytical techniques to identify suspicious behaviors. In the early days of malware, it was common for malware to be delivered as a single malicious file. This file contained all the functionality required to infect the victim and take the further actions that the malware author intended. To successfully bypass modern endpoint and network defenses, however, malware authors must take a more complex, multistage approach. Crafting multistep, complex attack chains makes it more difficult for defenses to identify what’s occurring and take appropriate action. <a href="chapter13.xhtml#fig13-23">Figure 13-23</a> illustrates such an attack.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/>&#13;
<figure class="IMG"><img class="img100" id="fig13-23" src="../images/fig13-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-23: A complex, multistage attack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, the malware author delivers a malicious document file to the victim. Once opened, the file executes embedded JavaScript code, which in turn executes obfuscated PowerShell code. The PowerShell code contacts the attacker’s malware staging server to download a loader (<i>Loader.exe</i>), which is responsible for contacting another remote server to download the malware payload (<i>Payload.exe</i>).</p>&#13;
<p class="TX">Tracing these disparate events is more challenging for defenses. Rather than evaluating the behaviors of a single executable file, an EDR’s event-tracing engine and analyzer will have to assess many different events from multiple sources before making a determination that this is malicious activity. To further complicate this attack, the malware author could spice it up with <i>sleep routines</i>. For example, the PowerShell command could wait two hours before downloading the loader executable, the loader could sleep for four hours before downloading the payload file, and then the payload could sleep for another eight hours before contacting its C2 server. The event-tracing engine would then have to account for many hours of time variance between events.</p>&#13;
<p class="TX">From the attacker’s perspective, however, there’s a downside to these multistage attacks: if even one stage of the attack fails, the entire attack chain fails. For example, if anti-malware is able to detect and quarantine the initial malicious Office document, the rest of the attack chain will fail. The same will happen if network defenses are able to identify and block the connections to the attacker’s malware-staging servers. This is a gamble malware authors must take, however.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h3 class="H1" id="sec42"><span id="h-229"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">This chapter discussed many of the common techniques malware uses to actively and passively circumvent host defense controls such as anti-malware and EDR, as well as network-based controls such as NIDS. We looked in detail at how malware can enumerate a victim host to identify host defenses <span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/>and how it might actively thwart those defenses. We also covered how malware can elevate its privileges, enabling it to slip past defenses more discreetly. In the next chapter, you’ll learn about rootkits, a type of low-level malware that uses techniques that might be considered the ultimate form of defense evasion.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>