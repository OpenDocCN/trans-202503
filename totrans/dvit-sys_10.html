<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_539"/><span class="big">10</span><br/><strong>KEY ASSEMBLY TAKEAWAYS</strong></h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">This part of the book has covered the basics of assembly. While most people today code in a high-level programming language, an understanding of assembly increases a programmer’s ability to better understand what their programs and compilers are doing. A knowledge of assembly is also essential for anyone who designs software for embedded systems and other resource-constrained environments, and for people who work in vulnerability analysis. The chapters contained in the assembly part of this book have spanned 64-bit Intel assembly (x86-64), 32-bit Intel Assembly (IA32), and 64-bit ARM assembly (ARMv8-A).</p>&#13;
<h3 class="h3" id="lev1_84">10.1 Common Features</h3>&#13;
<p class="noindent">Regardless of the specific assembly language that one learns, there are some common features to <em>all</em> assembly languages worth highlighting.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_540"/><strong>The ISA defines the assembly language.</strong>   The specific assembly language available on a machine is defined by the <em>instruction set architecture</em> (ISA) of that machine. To identify the underlying architecture of a particular Linux machine, use the <span class="literal">uname -p</span> command.</p>&#13;
<p class="noindentt"><strong>Registers hold data.</strong>   Every ISA defines a set of basic <em>registers</em> that the CPU uses to operate on data. Some registers are <em>general purpose</em> and can hold any kind of data, whereas other registers are <em>special purpose</em> and are typically reserved by the compiler for specific uses (e.g., stack pointer, base pointer). Although general-purpose registers are readable and writable, some special-purpose registers are read-only (e.g., the instruction pointer).</p>&#13;
<p class="noindentt"><strong>Instructions specify what the CPU can do.</strong>   The ISA also defines a series of <em>instructions</em> that specify operations that the CPU can perform. Each instruction has an <em>operation code</em> (opcode) that specifies what the instruction does, and one or more <em>operands</em> that specifies the data to be used. The ISA documents specific instructions for data movement, arithmetic operations, conditionals, branches, and accessing memory. These core instructions are often combined to represent more complex data structures like arrays, structs, and matrices.</p>&#13;
<p class="noindentt"><strong>The program stack holds local variables associated with a particular function.</strong>   The compiler uses the stack (or stack memory) of a process’s virtual address space to store temporary data. On all modern systems, the program stack grows toward <em>lower</em> memory addresses. The compiler uses the stack pointer and base pointer to specify a <em>stack frame</em> that defines the area of the stack that is associated with a particular function or procedure. A new stack frame is added to the stack with every function call and defines the stack region associated with the callee function. The stack frame associated with a particular function is removed from the stack when that function returns. Typically, the stack and base pointers return to their original values when a function ends. While this bit of bookkeeping suggests that local variables are “cleaned” from the stack, old data usually stick around in the form of junk values, which can sometimes lead to hard-to-debug behaviors. Malicious actors can also use knowledge of an ISA’s stack bookkeeping to create dangerous security exploits like buffer overflows.</p>&#13;
<p class="noindentt"><strong>Security.</strong>   All systems are vulnerable to security vulnerabilities like buffer overflow; however, the relatively recent ARMv8-A has had the opportunity to learn from some of the security flaws that affected older Intel architectures. However, the first line of defense is always the programmer. Even with additional protections, no ISA is invulnerable to potential security flaws. When coding in C, programmers should use <em>length specifiers</em> whenever possible to reduce the chance of security vulnerabilities resulting from boundary overruns (see <a href="ch10.xhtml#ch10tab1">Table 10-1</a>).</p>&#13;
<p class="tabcap" id="ch10tab1"><span epub:type="pagebreak" id="page_541"/><strong>Table 10-1:</strong> C Functions with Length Specifiers</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instead of</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Use</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">gets(buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">fgets(buf, 12, stdin)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">scanf("%s", buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">scanf("%12s", buf)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strcpy(buf2, buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strncpy(buf2, buf, 12)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strcat(buf2, buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strncat(buf2, buf, 12)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sprintf(buf, "%d")</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">snprintf(buf, 12, "%d", num)</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<h3 class="h3" id="lev1_85">10.2 Further Reading</h3>&#13;
<p class="noindent">This book offers just a taste of some of the most popular assembly languages in use. For a more in-depth understanding of assembly, we encourage you to check out the ISA specifications:</p>&#13;
<ul>&#13;
<li class="noindent">Intel 64 and IA32 Manuals, <em><a href="https://software.intel.com/en-us/articles/intel-sdm#architecture">https://software.intel.com/en-us/articles/intel-sdm#architecture</a></em></li>&#13;
<li class="noindent">ARM Cortex-A Programmer’s Guide, <em><a href="https://developer.arm.com/docs/den0024/a/preface">https://developer.arm.com/docs/den0024/a/preface</a></em></li>&#13;
</ul>&#13;
<p class="indent">The following free resources may also be useful for those who are interested in learning 32-bit assembly:</p>&#13;
<ul>&#13;
<li class="noindent">IA32 Programming Web Aside, Randal Bryant and David O’Hallaron, <em><a href="http://csapp.cs.cmu.edu/3e/waside/waside-ia32.pdf">http://csapp.cs.cmu.edu/3e/waside/waside-ia32.pdf</a></em></li>&#13;
<li class="noindent">32-bit ARM Assembly, Azeria Labs, <em><a href="https://azeria-labs.com/writing-arm-assembly-part-1/">https://azeria-labs.com/writing-arm-assembly-part-1/</a></em></li>&#13;
</ul>&#13;
<p class="indent">The following books also feature in-depth discussions of assembly; these aren’t free, but they are great resources for further reading:</p>&#13;
<ul>&#13;
<li class="noindent">Intel systems: Randal Bryant and David O’Hallaron, <em>Computer Systems: A Programmer’s Perspective</em>, Pearson, 2015.</li>&#13;
<li class="noindent">ARMv8: David Patterson and John Hennessy, <em>Computer Organization and Design: ARM Edition</em>, Morgan Kaufmann, 2016.</li>&#13;
</ul>&#13;
<span epub:type="pagebreak" id="page_542"/>&#13;
</body></html>