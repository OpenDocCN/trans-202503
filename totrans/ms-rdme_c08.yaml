- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Delivering Software
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件交付
- en: You should understand how your code winds up in front of users. Understanding
    the delivery process will help you troubleshoot problems and control when changes
    are made. You might not participate in the process directly—it might be automated
    or performed by release engineers—but the steps between `git commit` and live
    traffic should not be a mystery.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解你的代码是如何呈现给用户的。理解交付过程将帮助你排查问题并控制何时进行更改。你可能不会直接参与这一过程——它可能是自动化的，或者由发布工程师来执行——但从`git
    commit`到实时流量之间的步骤不应该是一个谜。
- en: Software is delivered when it’s running stably in production and customers are
    using it. Delivery consists of steps such as release, deployment, and rollout.
    This chapter describes different phases involved in delivering software to customers,
    source control branching strategies (which affect how software is released), and
    current best practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件在生产环境中稳定运行并且客户在使用时，它就被认为是交付的。交付包含了发布、部署和上线等步骤。本章描述了将软件交付给客户的不同阶段、源代码控制分支策略（它们影响软件的发布方式）和当前的最佳实践。
- en: Software Delivery Phases
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件交付阶段
- en: Unfortunately, delivery phases do not have industry-standard definitions. Depending
    on who you talk to, words like *release* and *deploy* can refer to completely
    different parts of the delivery pipeline. Your team might refer to the whole process,
    from packaging to rollout, as *releasing*. They might call packaging an artifact
    a *release*, while making the artifact available for download is *publishing*.
    They might not say a feature is *released* until it’s turned on in production,
    while everything preceding that action is *deployment*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，交付阶段没有行业标准的定义。根据你与谁交谈，像*发布*和*部署*这样的词语可以指交付管道中完全不同的部分。你的团队可能会将整个过程，从打包到上线，称为*发布*。他们可能会将打包一个工件称为*发布*，而将使工件可供下载称为*发布*。他们可能不会说某个功能是*发布*的，直到它在生产环境中启用，而在此之前的一切都被称为*部署*。
- en: For the purposes of this chapter, we refer to four software delivery phases,
    namely *build*, *release*, *deployment*, and *rollout*, shown in [Figure 8-1](#figure8-1).
    Software must first be *built* into packages. Packages should be immutable and
    versioned. Packages must then be *released*. Release notes and changelogs are
    updated, and packages are published to a centralized repository. Published release
    artifacts must be *deployed* to preproduction and production environments. Deployed
    software is not yet accessible to users—it’s just been installed. Once deployed,
    software is *rolled out* by shifting users to the new software. Once the rollout
    is complete, software is delivered.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将提到四个软件交付阶段，分别是*构建*、*发布*、*部署*和*上线*，如[图 8-1](#figure8-1)所示。软件首先必须*构建*成包。包应该是不可变的并且是版本化的。然后，包必须*发布*。发布说明和变更日志会更新，包被发布到一个集中式的仓库中。发布的工件必须*部署*到预生产和生产环境中。已部署的软件尚未对用户可访问——它只是被安装了。部署后，软件通过将用户切换到新软件来*上线*。一旦上线完成，软件就被交付了。
- en: '![f08001](image_fi/501836c08/f08001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![f08001](image_fi/501836c08/f08001.png)'
- en: 'Figure 8-1: Software delivery phases'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：软件交付阶段
- en: The delivery process is part of a larger product development cycle. After rollout,
    feedback is gathered, bugs are detected, and new product requirements are collected.
    Feature development begins anew, and eventually the next build is kicked off.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 交付过程是更大产品开发周期的一部分。上线后，会收集反馈，发现bug，并收集新的产品需求。功能开发重新开始，最终启动下一个版本的构建。
- en: Each delivery phase has a set of best practices. These practices will help you
    deliver software quickly and safely. But before we dive into each delivery step,
    we need to cover *source control branching strategies*. Branching strategies determine
    where code changes are committed and how release code is maintained. The right
    branching strategy will make software delivery easy and predictable, while the
    wrong strategy will turn delivery into a fight against the process itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交付阶段都有一套最佳实践。这些实践将帮助你快速且安全地交付软件。但是在深入每个交付步骤之前，我们需要了解*源代码控制分支策略*。分支策略决定了代码更改被提交到哪里，以及如何维护发布代码。正确的分支策略将使软件交付变得轻松且可预测，而错误的策略则会使交付变成与流程本身的斗争。
- en: Branching Strategies
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略
- en: Release packages are built from code in version control systems. *Trunk*—sometimes
    *main* or *mainline*—contains the main version of a codebase with a history of
    changes. *Branches* are “cut” from trunk to alter the code; multiple branches
    allow developers to work in parallel and merge their changes into trunk when ready.
    Different branching strategies define how long branches should last, how they
    relate to released versions of the software, and how changes propagate to multiple
    branches. The two main families of branching strategies are trunk-based and feature
    branch–based development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 发布包是从版本控制系统中的代码构建的。*主干*——有时称为*main*或*mainline*——包含代码库的主要版本及其变更历史。*分支*是从主干“切出”的，用于修改代码；多个分支允许开发人员并行工作，并在准备好时将更改合并回主干。不同的分支策略定义了分支应该持续多久，它们与已发布版本的软件的关系，以及如何将更改传播到多个分支。两种主要的分支策略家族是基于主干的开发和基于功能分支的开发。
- en: In *trunk-based development*, all developers work off of trunk. Branches are
    used for a single small feature, bug fix, or update.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*基于主干的开发*中，所有开发人员都在主干上工作。分支用于实现单个小功能、修复bug或进行更新。
- en: '[Figure 8-2](#figure8-2) shows a trunk-based development strategy. A feature
    branch is created in feature-1 and merged back to trunk. The bug-1 branch is created
    to fix a bug. A release branch has also been cut, and developers have decided
    to cherry-pick the bug fix into the 1.0 release.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](#figure8-2)展示了一个基于主干的开发策略。创建了一个功能分支feature-1，并将其合并回主干。bug-1分支被创建用来修复一个bug。同时也切出了一个发布分支，开发人员决定将bug修复挑选到1.0版本发布中。'
- en: '![f08002](image_fi/501836c08/f08002.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f08002](image_fi/501836c08/f08002.png)'
- en: 'Figure 8-2: Trunk-based development branches'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：基于主干的开发分支
- en: Trunk-based development works best when branches are merged back to trunk quickly,
    in a matter of days if not hours, and not shared between developers. Frequently
    merging is known as *continuous integration* *(CI**)*. CI reduces risk because
    changes quickly propagate to all developers, making them less likely to diverge
    from each other significantly. Keeping developer codebases in sync prevents potential
    last-minute integration hurdles and surfaces bugs and incompatibilities early.
    As a trade-off, bugs in trunk will slow down all developers. To prevent breakages,
    fast automated tests are run to validate that tests pass before a branch is merged
    into trunk. Teams often have explicit processes for reacting to a broken trunk;
    the general expectation is that trunk should always be okay to release, and releases
    tend to be fairly frequent.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发在分支能够快速合并回主干时最为有效，通常在几天甚至几小时内完成，并且不共享给多个开发人员。频繁的合并被称为*持续集成*（*CI*）。持续集成减少了风险，因为更改会迅速传播到所有开发人员，从而减少彼此显著分歧的可能性。保持开发人员的代码库同步可以避免潜在的最后一刻集成难题，并及早暴露错误和不兼容性。作为一种权衡，主干中的错误会拖慢所有开发人员的进度。为了防止错误，通常会运行快速的自动化测试，以验证在分支合并到主干之前所有测试是否通过。团队通常会有明确的流程来应对主干损坏的情况；一般预期是主干应该始终可以发布，并且发布通常会很频繁。
- en: In *feature branch–based development*, many developers simultaneously work on
    long-lived feature branches, each associated with a feature in the product. Because
    feature branches are long lived, developers need to *rebase*—to pull in changes
    from trunk—so the feature branch doesn’t diverge too far. Branches are kept stable
    by controlling when the rebasing occurs. When a release is being prepared, feature
    branches are pulled into the release branch. Release branches are tested, while
    feature branches may continue to evolve. Packages are built off stable release
    branches.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在*基于功能分支的开发*中，许多开发人员同时在长期存在的功能分支上工作，每个分支与产品中的一个功能相关。由于功能分支的生命周期较长，开发人员需要进行*变基*——从主干拉取更改——以确保功能分支不会偏离主干太远。通过控制何时进行变基，可以保持分支的稳定性。在准备发布时，功能分支会合并到发布分支中。发布分支会进行测试，而功能分支可能会继续演化。包是从稳定的发布分支构建的。
- en: Feature branch–based development is common when trunk is too unstable to release
    to users and developers want to avoid entering a feature freeze where feature
    commits are banned while trunk is stabilized. Feature branch–based development
    is more common in shrink-wrapped software where different customers run different
    versions; service-oriented systems usually use trunk-based development strategies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基于功能分支的开发在主干（trunk）不稳定且无法发布给用户时非常常见，开发人员希望避免进入功能冻结状态，在此期间功能提交被禁止，而主干正在稳定。基于功能分支的开发在封闭式软件中更为常见，因为不同客户使用不同版本的程序；而面向服务的系统通常使用基于主干的开发策略。
- en: The most popular feature branch approach, described by Vincent Driesen in 2010,
    is called *Gitflow*. Gitflow uses a develop branch, hotfix branch, and release
    branch. The develop branch is used as the main branch that feature branches merge
    and rebase with. Release branches are cut from the develop branch when a release
    is prepared. Development continues on feature branches during release stabilization.
    Releases are stabilized and merged into trunk. Trunk is always considered to be
    production-ready, since it only ever contains stabilized releases. If trunk is
    unstable because it contains critical bugs, the bugs are addressed immediately
    with hotfixes instead of waiting for the normal release cadence. Hotfixes are
    applied to the hotfix branch and merged into both trunk and the develop branch.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的功能分支方法，由 Vincent Driesen 在 2010 年描述，称为 *Gitflow*。Gitflow 使用一个 develop 分支、hotfix
    分支和 release 分支。develop 分支作为主要分支，功能分支与其合并和变基。当准备发布时，从 develop 分支切出 release 分支。在发布稳定期间，开发工作继续在功能分支上进行。发布稳定后，将其合并到
    trunk 分支。trunk 分支始终被视为生产就绪，因为它只包含稳定的发布版本。如果 trunk 分支不稳定，因为它包含严重的 bug，将立即通过 hotfix
    解决这些问题，而不是等待正常的发布周期。Hotfix 会应用到 hotfix 分支，并合并到 trunk 和 develop 分支。
- en: 'The Gitflow example in [Figure 8-3](#figure8-3) has two feature branches: feature-1
    and feature-2\. The feature branches are long lived; there are commits and merges
    back and forth with the develop branch. The release branch has two releases on
    it, both of which are pulled into trunk. A hotfix branch is used to fix a bug
    discovered on trunk. This hotfix has also been pulled into the develop branch
    so feature branches can pull it in.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](#figure8-3) 中的 Gitflow 示例包含两个功能分支：feature-1 和 feature-2。功能分支长期存在；它们与
    develop 分支之间来回提交和合并。发布分支上有两个版本，都被拉入 trunk 分支。一个 hotfix 分支用来修复 trunk 中发现的 bug。这个
    hotfix 也已被拉入 develop 分支，以便功能分支能够将其合并。'
- en: '![f08003](image_fi/501836c08/f08003.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f08003](image_fi/501836c08/f08003.png)'
- en: 'Figure 8-3: Gitflow feature branch–based development'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：基于 Gitflow 功能分支的开发
- en: Understand and follow your team’s branching strategy. Branching strategies define
    when changes go out, set testing expectations, define your bugfix options, and
    determine the number of versions your changes must be ported to. Many companies
    develop internal tools to help manage their VCS workflows. These scripts will
    branch, merge, and tag for you automatically.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 了解并遵循团队的分支策略。分支策略定义了变更的发布时间、设定了测试期望、定义了 bug 修复选项，并决定了变更需要移植到多少个版本。许多公司开发了内部工具来帮助管理他们的版本控制系统工作流程。这些脚本会自动为你创建分支、合并和打标签。
- en: Stick with a trunk-based branching strategy unless you truly need long-lived
    feature branches. Managing feature branches gets complicated. In fact, Driesen
    has amended his original Gitflow blog post to discourage Gitflow use for software
    that can be continuously integrated and delivered.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除非确实需要长期存在的功能分支，否则请坚持使用基于 trunk 的分支策略。管理功能分支会变得复杂。实际上，Driesen 已经修改了他原本关于 Gitflow
    的博客文章，建议不再使用 Gitflow 来处理可以持续集成和交付的软件。
- en: Build Phase
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建阶段
- en: 'Software packages must be built before they’re delivered. Building software
    takes many steps: resolving and linking dependencies, running linters, compiling,
    testing, and, finally, packaging the software. Most build steps are also used
    during development and have been covered in Chapters 3 to 6\. In this section,
    we’ll focus on a build’s output: packages.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包必须在交付前构建。构建软件需要许多步骤：解决和链接依赖关系、运行静态检查工具、编译、测试，最后是打包软件。大多数构建步骤在开发过程中也会使用，相关内容已经在第
    3 到第 6 章中讨论过。在本节中，我们将重点关注构建的输出：软件包。
- en: Packages are built for each release, so software doesn’t have to be built on
    each machine it runs on. Prebuilt packages are more consistent than having each
    machine compile and run code using its own environment and idiosyncratic combination
    of tools.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个发布都会构建软件包，因此软件不必在每台运行的机器上重新构建。预构建的软件包比每台机器使用其自己的环境和独特工具组合编译和运行代码更一致。
- en: 'Builds produce multiple packages if the software targets more than one platform
    or environment. Builds often produce packages for different operating systems,
    CPU architectures, or language runtimes. You’ve probably come across Linux package
    names like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件面向多个平台或环境，构建会生成多个软件包。构建通常会为不同的操作系统、CPU 架构或语言运行时生成软件包。你可能已经遇到过像这样的 Linux
    软件包名称：
- en: '*mysql-server-8.0_8.0.21-1_amd64.deb*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mysql-server-8.0_8.0.21-1_amd64.deb*'
- en: '*mysql-server-8.0_8.0.21-1_arm64.deb*'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mysql-server-8.0_8.0.21-1_arm64.deb*'
- en: '*mysql-server-8.0_8.0.21-1_i386.deb*'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mysql-server-8.0_8.0.21-1_i386.deb*'
- en: 'These MySQL packages were all built for the same MySQL version, but each package
    is compiled for a different architecture: AMD, ARM, and Intel 386.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 MySQL 包都是为相同的 MySQL 版本构建的，但每个包都是为不同的架构编译的：AMD、ARM 和 Intel 386。
- en: Package content and structure varies. Packages can contain binary or source
    code, dependencies, configurations, release notes, documentation, media, licenses,
    checksums, and even virtual machine images. Libraries are packaged into language-specific
    formats such as *JARs*, *wheels*, and *crates*, most of which are just zipped
    directories arranged to match a spec. Application packages are usually built as
    zips, tarballs (*.tar* files), or installation packages (*.dmg* or *setup.exe*
    files). Container and machine packages allow developers to build not only their
    software but the environment that it runs in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 包的内容和结构各不相同。包可以包含二进制文件或源代码、依赖项、配置文件、发布说明、文档、媒体文件、许可证、校验和，甚至虚拟机镜像。库被打包成特定语言的格式，如*JAR*、*wheels*
    和 *crates*，它们大多是按照规格排列的压缩目录。应用程序包通常构建为 zip 文件、tar 包（*.tar* 文件）或安装包（*.dmg* 或 *setup.exe*
    文件）。容器和机器包使开发者能够构建不仅仅是他们的软件，还包括运行它的环境。
- en: Packaging determines what software gets released. Bad packaging makes software
    difficult to deploy and debug. To avoid headaches, always version packages and
    split packages by resource type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打包决定了软件的发布方式。错误的打包会使软件难以部署和调试。为了避免麻烦，始终对包进行版本控制，并按资源类型拆分包。
- en: Version Packages
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本包
- en: Packages should be versioned and assigned a unique identifier. Unique identifiers
    help operators and developers tie a running application to specific source code,
    feature sets, and documentation. Without a version, you don’t know how a package
    will behave. If you’re unsure what versioning strategy to use, semantic versioning
    is a safe bet. Most packages follow some form of semantic versioning (see Chapter
    5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 包应该进行版本控制并分配唯一标识符。唯一标识符帮助运维人员和开发人员将正在运行的应用程序与特定的源代码、功能集和文档联系起来。没有版本，你无法知道一个包的行为。如果不确定使用什么版本控制策略，语义版本控制是一个安全的选择。大多数包遵循某种形式的语义版本控制（参见第
    5 章）。
- en: Package Different Resources Separately
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单独打包不同的资源
- en: Software is not just code. Configuration, schemas, images, and language packs
    (translations) are all part of software. Different resources have different release
    cadences, different build times, and different testing and verification needs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 软件不仅仅是代码。配置、架构、图片和语言包（翻译）都是软件的一部分。不同的资源有不同的发布节奏、不同的构建时间，以及不同的测试和验证需求。
- en: Different resources should be packaged separately so they can be modified without
    having to rebuild the entire software package. Separate packaging lets each resource
    type have its own release lifecycle and can be rolled forward and backward independently.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的资源应该单独打包，这样它们可以在不重新构建整个软件包的情况下进行修改。单独打包使得每种资源类型可以拥有独立的发布生命周期，并且可以独立地向前和向后滚动。
- en: 'If you are shipping a complete application to a customer, the final package
    is then a meta-package: a package of packages. If you are shipping a web service
    or a self-upgrading application, you can ship packages separately, allowing configuration
    and translation to upgrade separately from code.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要将一个完整的应用程序交付给客户，那么最终的包就是一个元包：由多个包组成的包。如果你要交付一个 Web 服务或自我升级的应用程序，可以将包单独交付，允许配置和翻译与代码独立升级。
- en: Release Phase
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布阶段
- en: 'Release publication makes software available to users and enables deployment,
    the next phase of delivery. Release processes vary based on the type and size
    of software and user sophistication. An internal web service’s release process
    might be a single step: publishing a software package to a shared package repository.
    User-facing releases require artifact publication, documentation updates, release
    notes, and user communication.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 发布发布使软件能够提供给用户并启用部署，这是交付的下一个阶段。发布流程根据软件的类型、规模和用户的技术水平而有所不同。内部 Web 服务的发布流程可能只有一个步骤：将软件包发布到共享的软件包库。面向用户的发布需要发布构件、更新文档、发布说明以及与用户的沟通。
- en: Release management is the art of publishing stable, well-documented software
    at a predictable cadence. Proper release management makes for satisfied customers.
    Complex software with multiple teams committing to it will often have a release
    manager role. Release managers coordinate the process—tests, feature validation,
    security procedures, documentation, and so on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 发布管理是以可预测的节奏发布稳定、文档完备的软件的艺术。适当的发布管理能够带来满意的客户。对于有多个团队在其中进行开发的复杂软件，通常会有发布经理的角色。发布经理协调整个过程——测试、功能验证、安全程序、文档等。
- en: Understanding release management will help you work with your company’s release
    process effectively. Take ownership of your software’s publication by releasing
    immutable packages frequently. Be clear about release schedules, and publish changelogs
    and release notes along with new releases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理解发布管理将帮助你更有效地与公司发布流程协作。通过频繁发布不可变的包，来承担软件发布的责任。明确发布的时间表，并在发布新版本时附带更新日志和发布说明。
- en: Don’t Throw Releases Over the Fence
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要把发布“扔过篱笆”
- en: Take responsibility for your software’s release. Even if your organization has
    a release engineering or operations team, you should know how and when your software
    ends up in front of users. Release and operations teams can be of great help in
    setting up tools, advising on best practices, and automating drudgery and bookkeeping,
    but they do not know your code as well as you do. Ultimately, it’s your responsibility
    to ensure the software is appropriately deployed and well-functioning.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 负责你的软件发布工作。即使你的组织有发布工程或运维团队，你也应该了解你的软件是如何以及何时呈现在用户面前的。发布和运维团队在设置工具、提供最佳实践建议、自动化繁琐任务和记录方面可以提供很大帮助，但他们不如你了解你的代码。最终，确保软件得到适当部署并正常运行是你的责任。
- en: Make sure your code works in test environments, keep track of release schedules,
    understand available options, and choose the right approach for your application.
    If only half of the application ships or a critical bug finds its way to production,
    you need to be involved in understanding how that happened and how to prevent
    it from happening again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的代码在测试环境中正常运行，跟踪发布进度，了解可用的选项，并为你的应用选择正确的发布方法。如果只有部分应用发布，或者一个关键的错误进入了生产环境，你需要参与调查发生了什么，并找出如何防止类似问题再次发生。
- en: Publish Packages to a Release Repository
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将包发布到发布仓库
- en: Release packages are usually published to a package repository or simply tagged
    and housed in a VCS like Git. Though either practice can work, we encourage you
    to publish release packages to a purpose-built package repository.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 发布包通常会发布到包仓库，或者直接在 Git 这样的版本控制系统中打上标签并存储。尽管这两种做法都可以，但我们建议你将发布包发布到专门的包仓库。
- en: Release repositories serve release artifacts to end users. Docker Hub, GitHub
    Release Pages, PyPI, and Maven Central are all public repositories. Many companies
    also stage releases and publish internal software in private repositories.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 发布仓库为最终用户提供发布工件。Docker Hub、GitHub Release Pages、PyPI 和 Maven Central 都是公共仓库。许多公司还会先发布到内部仓库，再进行发布操作。
- en: Package repositories make release artifacts (another word for a deployable package)
    available for deployment. Repositories also act as archives—previous release artifacts
    are accessible for debugging, rollback, and phased deployments. Package contents
    and metadata are indexed and browsable. Search support makes it easy to find dependencies,
    version information, and publication dates—invaluable information when troubleshooting.
    Release repositories are also built to meet deployment demands, handling thousands
    of users simultaneously downloading a new release.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 包仓库使发布工件（也就是可部署包）可供部署。仓库还充当档案库——以前的发布工件可以用于调试、回滚和分阶段部署。包的内容和元数据都会被索引并可浏览。搜索功能让你能轻松找到依赖项、版本信息和发布时间等信息，这在故障排除时非常有价值。发布仓库还专门为满足部署需求而建设，能够处理数千个用户同时下载新版本。
- en: Version control systems like Git can be used as a release repository, too. Go,
    for example, uses this approach. Rather than a centralized package repository,
    Go dependencies are expressed through Git URIs (usually GitHub repositories).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Git 这样的版本控制系统也可以作为发布仓库。例如，Go 就采用了这种方法。Go 的依赖通过 Git URI（通常是 GitHub 仓库）来表示，而不是使用集中式的包仓库。
- en: Version control systems work as release repositories, but they aren’t built
    for this purpose. VCSs don’t have as many useful search and deployment features.
    They are not built for large deployments and can get overwhelmed. Production deployments
    will be impacted if the same VCS machines are handling developer checkouts, tooling
    requests, and deployment requests. If you find yourself releasing from a VCS,
    make sure it can handle the load. Sharing one system for both release and development
    causes operational issues because deployment and development demands are very
    different. Developers make frequent, small commits and fewer checkouts. Deployments
    check out code, oftentimes from many machines at once. Deployment demands and
    developer tools can impact each other’s performance if they share the same repository
    or physical machines.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统作为发布仓库使用，但它们并非为此目的而设计。版本控制系统没有那么多有用的搜索和部署功能。它们并非为大规模部署而设计，可能会不堪重负。如果你发现自己正在从版本控制系统中发布，确保它能够处理负载。将发布和开发共享同一系统会导致操作问题，因为部署和开发的需求非常不同。开发人员进行频繁的小提交和较少的检出操作，而部署则是一次性检出代码，往往是从多台机器上进行。如果它们共享相同的仓库或物理机器，部署需求和开发工具的使用可能会相互影响性能。
- en: Keep Releases Immutable
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持发布包不可变
- en: Once published, never change or overwrite a release package. Immutable releases
    guarantee that all application instances running a specific version will be identical,
    byte for byte. Identical release packages let developers reason about what code
    is in an application and how it should behave. Versioned packages that change
    are no better than unversioned packages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布，绝不更改或覆盖发布包。不可变的发布保证了所有运行特定版本的应用实例在字节级别上完全一致。相同的发布包让开发人员能够推测应用中包含了哪些代码以及它应该如何表现。版本化的包如果发生变化，其效果与没有版本化的包没有区别。
- en: Release Frequently
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经常发布
- en: 'Release as frequently as possible. Slow release cycles give a false sense of
    security: long periods between releases feel like ample time to test changes.
    In practice, rapid release cycles produce more stable software that is easier
    to repair when bugs are found. Fewer changes go out per cycle, so each release
    carries less risk. When a bug makes it to production, there are fewer changes
    to look at when debugging. Code is fresh in developers’ minds, which makes the
    bug easier and faster to fix.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能频繁地发布。缓慢的发布周期会给人一种虚假的安全感：发布之间的长时间间隔让人觉得有充足的时间来测试变更。实际上，快速发布周期能产生更稳定的软件，且在发现错误时更容易修复。每个周期发布的变更较少，因此每次发布的风险较小。当一个错误进入生产环境时，调试时需要查看的变更也更少。开发人员对代码还记忆犹新，这使得修复错误变得更加容易和快速。
- en: Software with automated package publication and deployment should be possible
    to release on every commit. For larger pieces of software that are harder to deploy,
    balance the frequency of release against the cost of release, deployment, maintenance,
    and users’ rate of adoption.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 配备自动化包发布和部署的软件应该能够在每次提交时发布。对于较大且难以部署的软件，需要平衡发布的频率与发布、部署、维护成本以及用户采纳速度之间的关系。
- en: Be Transparent About Release Schedules
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对发布计划保持透明
- en: '*Release schedules* define how frequently software is released. Some projects
    have a predictable time-based schedule, releasing every quarter or year. Other
    projects release when specific features are completed (milestone-based releases)
    or simply when they feel like it. Internal systems often publish releases on every
    commit. Regardless of release style, be clear about release schedules. Publish
    schedules and notify users when new releases are published.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*发布计划*定义了软件发布的频率。一些项目有可预测的时间表，每季度或每年发布一次。其他项目则在特定功能完成时发布（基于里程碑的发布），或者仅仅是根据开发人员的意愿发布。内部系统通常会在每次提交时发布版本。无论发布方式如何，都要明确发布计划。发布计划应该公开，并在新版本发布时通知用户。'
- en: Publish Changelogs and Release Notes
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布变更日志和发布说明
- en: Changelogs and release notes help your users and your support team understand
    what is included in a release. *Changelogs* list every ticket that was fixed or
    commit that was made in a release. To automate changelog creation, track changes
    in commit messages or issue tracker labels. Release notes are a summary of the
    new features and bug fixes contained in a release. Changelogs are primarily read
    by the support and development team, while release notes are for users.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 变更日志和发布说明帮助你的用户和支持团队了解发布内容。*变更日志*列出在发布中修复的每个票证或提交。为了自动化生成变更日志，可以追踪提交信息或问题追踪标签中的变更。发布说明是对发布中包含的新特性和错误修复的总结。变更日志主要供支持和开发团队阅读，而发布说明是为用户准备的。
- en: Deployment Phase
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署阶段
- en: Deploying software is the act of getting software packages where they need to
    be to run. Deployment mechanisms vary—deployment for mobile applications will
    differ from nuclear reactors—but the same underlying principles apply.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 部署软件是将软件包放置到需要运行的地方的过程。部署机制各不相同——移动应用程序的部署与核反应堆的部署有所不同——但相同的基本原则适用。
- en: Automate Deployments
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化部署
- en: Deploy software using scripts rather than manual steps. Automated deployments
    are more predictable because script behavior is reproducible and version controlled.
    Operators will be able to reason about deployment behavior when things go wrong.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用脚本而非手动步骤进行软件部署。自动化部署更具可预测性，因为脚本行为是可复现并且版本受控的。当出现问题时，操作人员能够推理部署行为。
- en: Scripts are less likely to make mistakes than humans, and they remove the temptation
    to make manual system tweaks, log in to machines, or manually copy packages during
    deployment. Mutating state on an existing machine is hard to get right. Two different
    deployments of the same software can lead to inconsistent behavior that’s tough
    to debug.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本比人类更不容易出错，它们消除了手动调整系统、登录机器或手动复制包的诱惑。在现有机器上更改状态是很难做到正确的。两次不同的软件部署可能会导致不一致的行为，这使得调试变得非常困难。
- en: Highly evolved automation leads to *continuous delivery*. With continuous delivery,
    humans are completely removed from deployment. Packaging, testing, release, deployment,
    and even rollout are all automated. Deployments run as frequently as desired—daily,
    hourly, or continuously. With continuous delivery, teams can deliver features
    to their users quickly and get feedback from them. Successful continuous delivery
    requires a commitment to automated testing (see Chapter 6), automated tooling,
    and a customer base that is able to absorb rapid changes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 高度进化的自动化促成了*持续交付*。通过持续交付，人工完全被从部署过程中移除。打包、测试、发布、部署，甚至发布阶段都实现了自动化。部署可以按需求频繁进行——每天、每小时，甚至是持续进行。通过持续交付，团队能够快速将新特性交付给用户，并从中获得反馈。成功的持续交付需要承诺自动化测试（参见第六章）、自动化工具的支持，以及能够适应快速变化的用户群体。
- en: We recommend automating your deployments with off-the-shelf tools. Custom deployment
    scripts are easy to start with but grow unwieldy fast. Off-the-shelf solutions
    like Puppet, Salt, Ansible, and Terraform integrate with existing tooling and
    are purpose-built for deployment automation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用现成工具来自动化部署。自定义部署脚本易于入门，但很快就会变得难以管理。像Puppet、Salt、Ansible和Terraform这样的现成解决方案可以与现有工具集成，并且是为部署自动化而专门设计的。
- en: You might find it impossible to fully automate your deployments—that’s okay.
    Deployments that depend on physical actions or third parties are sometimes impossible
    to fully automate. Just do your best to shrink the boundary of blocking tasks
    by automating everything around them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现完全自动化部署是不可行的——这没关系。依赖于物理操作或第三方的部署有时是无法完全自动化的。尽力通过自动化周围的任务来缩小阻塞任务的范围。
- en: Make Deployments Atomic
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使部署具备原子性
- en: Installation scripts often involve multiple steps. Do not assume each step succeeds
    on every execution. Machines run out of disk, get restarted at the wrong time,
    or have unexpected file permissions. A partially deployed application can cause
    future deployments to fail if scripts assume installation locations are empty.
    To avoid failed partial deployments, make deployment all or nothing (atomic).
    A partially deployed install should never partially replace the previous successful
    install, and it should be possible to install the same package to the same machine
    multiple times, even if previous installation attempts terminated abruptly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装脚本通常涉及多个步骤。不要假设每个步骤在每次执行时都会成功。机器可能会用完磁盘空间、在错误的时间重启，或者遇到意外的文件权限问题。如果脚本假定安装位置为空，部分部署的应用程序可能会导致未来的部署失败。为了避免部分部署失败，应使部署要么全部完成，要么完全不完成（原子性）。部分部署的安装不应该部分替换先前成功的安装，并且应该允许多次将相同的包安装到同一台机器，即使之前的安装尝试突然中止。
- en: The easiest way to make deployments atomic is by installing software in a different
    location than the old version; don’t overwrite anything. Once packages are installed,
    a single shortcut or symbolic link can be flipped atomically. Installing packages
    in a new location has the added benefit that rollbacks become much easier—just
    point to the old version again. In some cases, different versions of the same
    software can be run simultaneously on the same machine!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使部署原子化的最简单方法是将软件安装在与旧版本不同的位置；不要覆盖任何内容。安装完包之后，只需通过一个快捷方式或符号链接来原子性地切换。将包安装在新位置的另一个好处是，回滚变得更加容易——只需再次指向旧版本。在某些情况下，甚至可以在同一台机器上同时运行同一软件的不同版本！
- en: Deploy Applications Independently
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立部署应用程序
- en: Deployment ordering, when one application’s deployment requires the upgrade
    of another application first, is a common problem in software with many applications
    or services that communicate with each other. Developers ask operations to deploy
    one application before another or to bring several systems offline to perform
    the upgrade. Avoid deployment ordering requests. Ordering requirements slow down
    deployment since applications must wait for each other. Ordering also leads to
    conflicts where two applications depend on each other to be upgraded.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 部署顺序是一个常见问题，当一个应用程序的部署需要先升级另一个应用程序时，特别是在有多个应用程序或服务相互通信的软件中。开发人员要求运维先部署一个应用程序，然后再部署另一个，或者将几个系统下线进行升级。避免部署顺序的请求。部署顺序要求会拖慢部署速度，因为应用程序必须互相等待。顺序还会导致冲突，例如两个应用程序相互依赖，必须先升级另一个才能进行部署。
- en: Build applications that deploy independently. Software that doesn’t depend on
    deployment ordering must be backward and forward compatible. For example, communication
    protocols must continue to interoperate with newer and older versions. Compatibility
    is discussed more in Chapter 11.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可以独立部署的应用程序。无需依赖部署顺序的软件必须向前向后兼容。例如，通信协议必须继续与新旧版本互操作。兼容性将在第11章中详细讨论。
- en: When a dependency is unavoidable, use the rollout techniques discussed next
    to safely deploy out of order. Deploying with your changes turned off and turning
    them on in a specific order later is faster and simpler than enforcing deployment
    ordering.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个依赖无法避免时，使用接下来讨论的推出技术来安全地无序部署。将更改关闭并在特定顺序下再开启，通常比强制执行部署顺序更快更简单。
- en: Rollout Phase
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推出阶段
- en: Once the new code is deployed, you can turn it on (roll it out). Switching everything
    to the new code at once is risky. No amount of testing will eliminate the potential
    for bugs, and rolling out code to all users at once can break things for everyone
    simultaneously. Instead, it’s best to roll changes out gradually and monitor health
    metrics.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新代码部署完成，你可以将其启用（推出）。一次性将所有内容切换到新代码是有风险的。再多的测试也无法消除潜在的bug，而一次性将代码推出给所有用户可能会导致所有人同时出现问题。相反，最好的做法是逐步推出更改并监控健康指标。
- en: 'There are many rollout strategies: feature flags, circuit breakers, dark launches,
    canary deployments, and blue-green deployments. *Feature flags* allow you to control
    what percentage of users receive one code path versus another. *Circuit breakers*
    automatically switch code paths when there’s trouble. *Dark launches*, *canary
    deployments*, and *blue-green deployments* let you run multiple deployed versions
    of your software simultaneously. These patterns mitigate the risk of dangerous
    changes when used appropriately. Don’t go crazy using sophisticated rollout strategies,
    though—they add operational complexity. Operators and developers must support
    multiple code versions simultaneously and keep track of which features are toggled
    on or off. Keep fancy rollout strategies in your toolbox for bigger changes.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多发布策略：功能开关、断路器、暗发布、金丝雀发布和蓝绿发布。*功能开关*让你控制多少用户使用某一代码路径而非另一条。*断路器*会在出现问题时自动切换代码路径。*暗发布*、*金丝雀发布*和*蓝绿发布*允许你同时运行多个部署版本的软件。这些模式在正确使用时可以减少危险更改的风险。不过，别在发布策略上过度使用复杂的技术——它们会增加操作复杂性。操作员和开发人员必须同时支持多个代码版本，并跟踪哪些功能被切换开或关。将复杂的发布策略留在工具箱中，适用于更大的变更。
- en: Monitor Rollouts
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控发布
- en: Monitor health metrics such as error rates, response times, and resource consumption
    as new code is activated. Monitoring can be done manually or automatically. Advanced
    release pipelines automatically roll a change out to more users or roll the change
    back based on observed statistics. Even in a fully automated process, humans should
    keep an eye on the statistics and the rollout progress. More commonly, the decision
    to ramp up or down is still made by humans looking at logs and metrics.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码激活时，监控健康指标，如错误率、响应时间和资源消耗。监控可以手动进行，也可以自动进行。高级发布管道会根据观察到的统计数据，自动将更改发布给更多用户，或回滚更改。即使在完全自动化的过程中，人类也应当留意统计数据和发布进度。更常见的是，是否逐步发布的决定仍然由人类根据日志和指标来做出。
- en: Determine ahead of time what the general health metrics are. *Service level
    indicators* *(SLIs**)*, discussed more in Chapter 9, are metrics that indicate
    the health of your service; watch these for signs of degradation. Think about
    what you expect to see in metrics or logs that would tell you that your change
    is functioning correctly. Verify that what you expected to happen is actually
    happening.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 提前确定哪些是常规的健康指标。*服务水平指标*（*SLIs*），在第九章中有更多讨论，是指示服务健康状况的指标；需要观察这些指标以判断是否有退化的迹象。思考一下你期望在指标或日志中看到什么，以判断你的更改是否按预期工作。验证预期发生的事情是否确实发生了。
- en: Remember, your job is not done when code is committed, and it’s still not done
    when the code is rolled out. Hold the champagne until metrics and logs are showing
    your changes running successfully.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，代码提交后你的工作并未结束，代码发布后也仍然没有完成。在看到指标和日志显示你的更改成功运行之前，不要急着庆祝。
- en: Ramp Up with Feature Flags
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用功能开关逐步发布
- en: Feature flags (sometimes called *feature toggles* or *code splits*) allow developers
    to control when new code is released to users. Code is wrapped in an `if` statement
    that checks a flag (set by static configuration or from a dynamic service) to
    determine which branch of code should be run.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关（有时称为*功能切换*或*代码分支*）允许开发人员控制何时将新代码发布给用户。代码被包装在`if`语句中，检查一个标志（由静态配置或动态服务设置），以确定应运行哪一分支代码。
- en: Feature flags can be on-off Booleans, allow lists, percentage-based ramps, or
    even small functions. A Boolean will toggle the feature for all users. Allow lists
    turn on features for specific users. Percent-based ramps allow developers to slowly
    turn on the feature for larger swaths of users. It is common to start with company-owned
    test accounts and then ramp to a single customer before doing an incremental percent-based
    release. Functions dynamically determine flags based on input parameters, usually
    passed in at request time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关可以是开关布尔值、允许列表、基于百分比的逐步发布，甚至是小功能。布尔值会为所有用户切换功能。允许列表为特定用户启用功能。基于百分比的逐步发布允许开发人员慢慢地为更大范围的用户启用该功能。通常会从公司拥有的测试账户开始，然后逐步推广到单一客户，再进行按百分比的增量发布。函数根据输入参数动态地决定功能开关的状态，通常是在请求时传递。
- en: Feature-flagged code that mutates state needs special attention. Databases are
    often not controlled by feature flags. New code and old code both interact with
    the same tables. Your code must be forward and backward compatible. State doesn’t
    go away when a feature is toggled off. If a feature is disabled for a user and
    then reenabled later, any state changes made while the feature was disabled still
    exist. Some changes, like database alterations, do not lend themselves to gradual
    rollouts and must be coordinated with extra care. Isolate feature-flag data if
    possible, test your code in all flagged states, and write scripts to clean rolled-back
    feature data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意那些会改变状态的特性标志代码。数据库通常不受特性标志控制。新旧代码都与相同的表进行交互。你的代码必须向前和向后兼容。当特性被关闭时，状态并不会消失。如果一个特性对用户禁用后再启用，在该特性禁用期间所做的任何状态更改依然存在。一些更改，比如数据库修改，不适合渐进式发布，必须格外小心地协调。如果可能，隔离特性标志数据，在所有标志状态下测试代码，并编写脚本来清理回滚的特性数据。
- en: Make sure to clean up old feature flags that are fully ramped or no longer in
    use. Code littered with feature flags is difficult to reason about and can even
    cause bugs; for example, turning off a feature that’s been on for a long time
    can create havoc. Cleaning feature flags takes discipline. Create tickets to remove
    old flags in the future. Like refactoring, do cleanup incrementally and opportunistically.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 确保清理掉那些已经完全发布或不再使用的旧特性标志。代码中布满特性标志很难推理，甚至可能导致bug；例如，关闭一个已经启用很长时间的特性可能会引发混乱。清理特性标志需要一定的纪律性。创建工单来移除未来的旧标志。就像重构一样，清理工作应当逐步进行，趁机进行。
- en: Feature flags are sometimes used for *A/B testing*, a technique for measuring
    user behavior with a new feature. A/B testing with feature flags is fine if users
    are grouped in a statistically meaningful way. Don’t try to A/B test with feature
    flags unless the flagging system creates test buckets for you, and run your experiment
    by a data scientist.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 特性标志有时用于*A/B测试*，这是一种通过新特性衡量用户行为的技术。如果用户被以统计学上有意义的方式分组，那么使用特性标志进行A/B测试是可以的。除非标志系统为你创建了测试分组，并且实验由数据科学家运行，否则不要尝试使用特性标志进行A/B测试。
- en: Protect Code with Circuit Breakers
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用熔断器保护代码
- en: 'Most feature flags are controlled by humans. Circuit breakers are a special
    kind of feature flag that are controlled by operational events, like a spike in
    latency or exceptions. Circuit breakers have several unique characteristics: they’re
    binary (on/off), they’re permanent, and they’re automated.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数特性标志由人工控制。熔断器是一种特殊的特性标志，由操作事件控制，如延迟激增或异常。熔断器有几个独特的特点：它们是二进制的（开/关），它们是永久性的，并且是自动化的。
- en: Circuit breakers are used to protect against performance degradation. If a latency
    threshold is exceeded, certain features can be automatically disabled or rate
    limited. Similarly, circuits can break if logs show anomalous behavior—exceptions
    or a jump in log verbosity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 熔断器用于防止性能下降。如果超过延迟阈值，某些特性可以被自动禁用或限速。同样，如果日志显示异常行为——例如异常或日志冗余度激增，电路也可以断开。
- en: Circuit breakers also protect against permanent damage. Applications that take
    irreversible action, such as sending an email or transferring money out of a bank
    account, use circuit breakers when it’s unclear whether to proceed. Databases
    can also protect themselves by flipping to a read-only mode. Many databases and
    filesystems will do this automatically if they detect disk corruption.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 熔断器还可以防止永久性损害。那些执行不可逆操作的应用程序，例如发送电子邮件或从银行账户转账，当不确定是否继续时会使用熔断器。数据库也可以通过切换到只读模式来保护自己。如果数据库检测到磁盘损坏，许多数据库和文件系统会自动这样做。
- en: Ramp Service Versions in Parallel
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行发布服务版本
- en: It is possible to deploy new versions of web services alongside old versions.
    Packages can be co-located on the same machine or deployed on entirely new hardware.
    Parallel deployments let you ramp up slowly to mitigate risk and roll back fast
    if things go wrong. A percentage of incoming service calls are shifted from the
    old version to a new version using a switch similar to feature flags, but the
    switch is at the application entry point—usually a load balancer or proxy. Canary
    deployments and blue-green deployments are the two most common parallel deployment
    strategies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将新的 Web 服务版本与旧版本并行部署。软件包可以放置在同一台机器上，或部署到全新的硬件上。并行部署允许你缓慢地增加负载，以降低风险，并在出现问题时快速回滚。通过类似于功能标志的开关，将一定比例的入站服务调用从旧版本切换到新版本，但该开关位于应用入口点——通常是负载均衡器或代理。金丝雀部署和蓝绿部署是最常见的两种并行部署策略。
- en: Canary deployments are used for services that process a lot of traffic and are
    deployed to a large number of instances. A new application version is first deployed
    to a limited set of machines. A small user subset is routed to the canary version.
    [Figure 8-6](#figure8-6) shows canary version 1.1 receiving 1 percent of inbound
    traffic. Like a canary in a coal mine (used to detect the presence of dangerous
    gases), the canary deployment is an early warning system for new application versions.
    Malfunctioning canaries impact only a small portion of users, who can be quickly
    routed back to an old version when errors are encountered.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Canary 部署适用于处理大量流量并部署到多个实例的服务。新的应用版本首先部署到有限的机器集上。少量用户子集会被引导到金丝雀版本。[图 8-6](#figure8-6)显示了金丝雀版本
    1.1 接收 1% 的入站流量。就像矿井中的金丝雀（用于检测有害气体的存在）一样，金丝雀部署是新应用版本的预警系统。出现故障的金丝雀只会影响一小部分用户，遇到错误时可以迅速将他们引导回旧版本。
- en: '![f08006](image_fi/501836c08/f08006.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![f08006](image_fi/501836c08/f08006.png)'
- en: 'Figure 8-6: In canary deployments, load balancers route a fraction of inbound
    traffic to a new deployment.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：在金丝雀部署中，负载均衡器将一部分入站流量引导到新的部署版本。
- en: '*Blue-green deployments* run two different versions of the application: one
    active and one passive. [Figure 8-7](#figure8-7) shows a passive cluster (called
    *blue*) running version 1.0 and an active cluster (called *green*) running 1.1\.
    The new version is deployed to the passive environment; when it is ready, traffic
    is flipped to the new version, and it becomes active, while the previous version
    becomes passive. Like canaries, if the new version has problems, the traffic can
    be flipped back. Unlike canaries, traffic is flipped atomically, and the blue
    and green environments are kept as identical as possible. In a cloud environment,
    the passive environment is usually destroyed once the release is considered stable.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*蓝绿部署*运行两个不同版本的应用：一个是活动版本，一个是被动版本。[图 8-7](#figure8-7)显示了一个运行版本 1.0 的被动集群（称为
    *蓝*），以及一个运行版本 1.1 的活动集群（称为 *绿*）。新版本部署到被动环境；当其准备就绪时，流量会切换到新版本，成为活动版本，而旧版本成为被动版本。与金丝雀部署类似，如果新版本出现问题，流量可以切换回去。与金丝雀部署不同的是，流量切换是原子性的，并且蓝绿环境尽可能保持一致。在云环境中，一旦发布被认为稳定，通常会销毁被动环境。'
- en: '![f08007](image_fi/501836c08/f08007.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![f08007](image_fi/501836c08/f08007.png)'
- en: 'Figure 8-7: In a blue-green deployment, service 1.0 is kept as a fallback in
    case service 1.1 malfunctions.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：在蓝绿部署中，服务 1.0 被保留作为回退，以防服务 1.1 出现故障。
- en: Blue-green deployments are useful when traffic cannot be easily subset or when
    running different versions in parallel is not feasible. Unlike canaries, each
    environment must be able to handle 100 percent of user traffic. In disaster scenarios
    where all users need to be migrated off a misbehaving system, having the ability
    to get a parallel environment up and running quickly is invaluable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署在流量无法轻易子集化或无法并行运行不同版本时非常有用。与金丝雀部署不同，每个环境必须能够处理 100% 的用户流量。在灾难场景中，当所有用户都需要从故障系统迁移时，能够迅速启动并运行并行环境是极其宝贵的。
- en: Like feature flags, parallel deployments that interact with database and cache
    state need special care. Both versions of the application must play nicely with
    each other. Backward and forward compatibility for all schemas must be enforced.
    This topic is discussed more in Chapter 11.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与功能标志一样，涉及数据库和缓存状态的并行部署需要特别小心。应用的两个版本必须和谐共处。必须强制执行所有模式的向后和向前兼容性。本章第 11 章将进一步讨论这一话题。
- en: Launch in Dark Mode
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动深色模式
- en: Feature flags, canary deployments, and blue-green releases roll out code to
    a subset of users and provide mitigation mechanisms when problems arise. Dark
    launches, sometimes called *traffic shadowing*, expose new code to real-life traffic
    without making it visible to end users at all. Even if dark code is bad, no user
    is impacted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 特性标志、金丝雀发布和蓝绿发布将代码部署到一部分用户，并在出现问题时提供缓解机制。暗启动，有时称为*流量影子*，将新代码暴露给真实流量，但完全不让最终用户看到。即使暗代码有问题，也不会影响用户。
- en: Dark-launched software is still enabled, and the code is invoked, but the results
    are thrown away. Dark launches help developers and operators learn about their
    software in production with minimal user impact. Take advantage of dark launches
    whenever you are releasing particularly complex changes. This pattern is especially
    useful for validating system migrations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 暗启动的软件仍然启用，并且代码被调用，但结果会被丢弃。暗启动帮助开发人员和运维人员在生产环境中学习他们的软件，且对用户的影响最小。每当你发布特别复杂的变更时，利用暗启动是一个好方法。这个模式对于验证系统迁移尤其有用。
- en: In a dark launch, an application proxy sits between the live traffic and the
    application. The proxy duplicates requests to the dark system. Responses to these
    identical requests from both systems are compared, and differences are recorded.
    Only the production system’s responses are sent to the users. This practice allows
    the operators to observe their service under real traffic without affecting the
    customers. The system is said to be in “dark reads” mode when only read traffic
    is sent to it and no data is modified. A system might be using the same datastore
    as the production system when operating in dark reads. It is said to be in a “dark
    writes” mode when writes are also sent to the system and it is using a completely
    independent datastore. [Figure 8-8](#figure8-8) shows both modes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在暗启动中，应用代理位于实时流量和应用程序之间。代理将请求复制到暗系统。来自两个系统的相同请求的响应会被比较，差异会被记录下来。只有生产系统的响应会发送给用户。这一做法使运维人员能够在真实流量下观察他们的服务，而不会影响客户。当系统仅接收读流量且没有数据被修改时，它被称为“暗读”模式。一个系统可能在暗读模式下使用与生产系统相同的数据存储。当写入操作也发送到该系统并且它使用完全独立的数据存储时，它被称为“暗写”模式。[图
    8-8](#figure8-8)展示了这两种模式。
- en: Since operations are happening twice for the same request, once on the production
    system and once in the dark, you should take care to avoid duplication-related
    errors. Traffic to the dark system should be excluded from user analytics, and
    side effects like double billing have to be avoided. Requests can be marked for
    exclusion by modifying headers to highlight shadowed traffic. Some service meshes,
    such as Istio, and API gateways, such as Gloo, have built-in support for these
    operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同一请求在生产系统和暗系统上都执行一次，因此需要小心避免与重复相关的错误。发送到暗系统的流量应排除在用户分析之外，并且需要避免诸如重复计费等副作用。可以通过修改头信息来标记请求，以突出显示被影藏的流量。一些服务网格（如
    Istio）和 API 网关（如 Gloo）内置了对这些操作的支持。
- en: '![f08008](image_fi/501836c08/f08008.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![f08008](image_fi/501836c08/f08008.png)'
- en: 'Figure 8-8: Dark reads and dark writes'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：暗读和暗写
- en: 'You can do all kinds of cool things with dark launches. The open source tool
    Diffy, for example, sends dark traffic to three instances of the backend service:
    two running the production version of the code and one running the new release
    candidate. Diffy compares responses from a new version and an old version to identify
    all differences, and compares the responses from the two old versions to identify
    nondeterministic noise. This allows Diffy to automatically identify expected differences
    and remove false positives.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过暗启动做各种很酷的事情。例如，开源工具 Diffy 会将暗流量发送到后端服务的三个实例：两个运行生产版本代码，一个运行新发布候选版本。Diffy
    比较新版本和旧版本的响应，以识别所有差异，并比较两个旧版本的响应，以识别非确定性的噪声。这使得 Diffy 可以自动识别预期的差异，并排除假阳性结果。
- en: Do’s and Don’ts
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应做与不应做
- en: '| **Do’s** | **Don’ts** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **应做** | **不应做** |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **DO** use trunk-based development and continuous integration if possible.  |
    **DON’T** publish unversioned packages.  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **做** 如果可能，使用基于主干的开发和持续集成。 | **不做** 发布没有版本的包。 |'
- en: '| **DO** use VCS tools to manage branches.  | **DON’T** package configuration,
    schema, images, and language packs together.  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **做** 使用版本控制工具管理分支。 | **不做** 将配置、架构、图像和语言包捆绑在一起。 |'
- en: '| **DO** work with release and operations teams to create the right processes
    for your application.  | **DON’T** blindly rely on release managers and operations
    teams.  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **做**与发布和运维团队合作，为你的应用创建正确的流程。  | **不做**盲目依赖发布经理和运维团队。  |'
- en: '| **DO** publish release changelogs and release notes.  | **DON’T** use VCSs
    to distribute software.  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **做**发布发布日志和版本说明。  | **不做**使用版本控制系统（VCS）分发软件。  |'
- en: '| **DO** notify users when a release is published.  | **DON’T** change release
    packages once they’re published.  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **做**在发布时通知用户。  | **不做**发布后更改发布包。  |'
- en: '| **DO** use off-the-shelf tooling to automate deployment.  | **DON’T** roll
    out without monitoring the results.  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **做**使用现成的工具自动化部署。  | **不做**在没有监控结果的情况下进行发布。  |'
- en: '| **DO** roll changes out gradually with feature flags.  | **DON’T** depend
    on deployment ordering.  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **做**通过功能标志逐步推出更改。  | **不做**依赖于部署顺序。  |'
- en: '| **DO** use circuit breakers to prevent applications from causing major damage.  |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **做**使用电路断路器防止应用程序造成重大损害。  |  |'
- en: '| **DO** use traffic shadowing and dark launches for major changes.  |  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **做**对重大更改使用流量影像和暗启动。  |  |'
- en: Level Up
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级
- en: '*Git for Teams*, by Emma Jane Hogbin Westby (O’Reilly Media, 2015), gives more
    detail on branching strategies. This is a great foundational book and is valuable
    even if you’re not working with Git.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*《团队中的 Git》*，作者 Emma Jane Hogbin Westby（O’Reilly Media，2015），详细介绍了分支策略。这是一本很好的基础书籍，即使你不使用
    Git，也非常有价值。'
- en: Jez Humble and David Farley’s *Continuous Delivery* (Addison-Wesley Professional,
    2010) is a deep dive into the topics covered in this chapter. If you spend a lot
    of time with release engineering, read this book. For a shorter read, Google’s
    *Site Reliability Engineering* (O’Reilly Media, 2016) covers release engineering
    in Chapter 8.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Jez Humble 和 David Farley 的*《持续交付》*（Addison-Wesley Professional，2010）深入探讨了本章涵盖的话题。如果你花很多时间在发布工程上，读这本书。对于简短的阅读，Google的*《站点可靠性工程》*（O’Reilly
    Media，2016）在第8章中涵盖了发布工程。
- en: Michael T. Nygard’s *Release It!* (Pragmatic Bookshelf, 2018) is an expansive
    look at operations topics that our book discusses in Chapters 8 and 9\. Nygard’s
    book also spends significant time on software design patterns for operations,
    a topic we discuss in Chapter 4\. We highly recommend *Release It!* for developers
    working on web services.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Michael T. Nygard的*《Release It!》*（Pragmatic Bookshelf，2018）对我们书中第8章和第9章讨论的运维话题进行了全面深入的探讨。Nygard的书还重点介绍了运维的设计模式，这是我们在第4章讨论的内容。我们强烈推荐开发人员阅读*《Release
    It!》*，尤其是从事Web服务开发的人员。
- en: Amazon’s *Builder’s Library* is also a great free resource for delivery best
    practices. Located at [https://aws.amazon.com/builders-library/](https://aws.amazon.com/builders-library/),
    the library has posts on continuous delivery, automated deployment, and rollbacks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的*《构建者库》*也是一个很好的免费资源，提供交付最佳实践。该库位于[https://aws.amazon.com/builders-library/](https://aws.amazon.com/builders-library/)，里面有关于持续交付、自动化部署和回滚的文章。
