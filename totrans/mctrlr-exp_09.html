<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_99"/><strong>9 nRF51 Gadgets in ROM</strong></h2>&#13;
<p class="noindent">First documented in Brosch (2015), this chapter describes an exploit for extracting protected memory from the nRF51822 despite code protection features. The vulnerability is that while the debugger cannot read protected memory directly or write shellcode to SRAM, it can single-step through the protected code in flash memory.</p>&#13;
<p class="indent">Although this version is described for the nRF51 series, a similar bug is described in Obermaier, Schink, and Moczek (2020) for the CKS32F103 and GD32VF103, which are clones of the popular STM32F103. Kovrizhnykh (2023) notes that the SN32F248B from Sonix has been exploited by the same technique.</p>&#13;
<h3 class="h3" id="ch00lev1sec34"><strong>Learning All the Rules</strong></h3>&#13;
<p class="noindent">The nRF51’s protection mechanism, documented in <a href="ch09.xhtml#ch09">Chapter 9</a> of Nordic (2014), is built as an extension of the memory protection unit (MPU). An MPU is sort of like a memory management unit (MMU), except that it is coarser-grained and provides no support for virtual memory.</p>&#13;
<p class="indent">The most common readout protection for this chip is called Protect All (<span class="literal">PALL</span>), which is configured by writing zero into the I/O port <span class="literal">UICR.RBPCONF.PAL</span>. This is designed to prevent the SWD debugger from accessing code region 0, code region 1, RAM, or any peripherals except for the <span class="literal">NVMC</span> peripheral, the <span class="literal">RESET</span> register in the <span class="literal">POWER</span> peripheral, and the <span class="literal">DISABLEINDEBUG</span> register in the <span class="literal">MPU</span> peripheral. You will often see a bootloader perform this protection at every boot, but the protection persists. It is only necessary to apply the protection once.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_100"/><img id="ch9fig1" src="../images/f0100-01.jpg" alt="Image" width="778" height="711"/></div>&#13;
<p class="figcap">Figure 9.1: NXP nRF51822</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_101"/><img id="ch9fig2" src="../images/f0101-01.jpg" alt="Image" width="578" height="671"/></div>&#13;
<p class="figcap">Figure 9.2: nRF51822 Memory Map</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_102"/><img id="ch9fig3" src="../images/f0102-01.jpg" alt="Image" width="821" height="485"/></div>&#13;
<p class="figcap">Figure 9.3: Brosch’s PoC nRF51822 Exploit</p>&#13;
<p class="indent">There are also lesser protection modes, which restrict code region 1 from accessing code region 0. The purpose of these modes is to protect soft devices, binary blob radio drivers that often require commercial licensing but still allow custom code to sit alongside. These blobs freely run in the lower region, and while the upper region can call into the lower, it cannot read that region as data.</p>&#13;
<p class="indent">The reference manual also mentions that whatever the protection mode, CPU fetches from code memory will not be denied and that the interrupt table from <span class="literal">0x00</span> to <span class="literal">0x80</span> is not protected.</p>&#13;
<h3 class="h3" id="ch00lev1sec35"><span epub:type="pagebreak" id="page_103"/><strong>Bypassing the Rules</strong></h3>&#13;
<p class="noindent">Now that we’ve covered the documented behavior of the protection, it’s necessary to experiment a bit and learn the unwritten rules. Kris Brosch discovered that by attaching a debugger to a locked chip, he had quite a bit of freedom to direct the CPU. He could read and write registers, including the program counter. He could also read from a few memory-mapped registers, such as the read-back protection configuration (<span class="literal">RBPCONF</span>) at <span class="literal">0x10001004</span>.</p>&#13;
<p class="indent">Most importantly, while he did not have the freedom to directly read from protected regions with the debugger, he was able to single-step through existing code, controlling registers both before an instruction (as inputs) and after that same instruction (as outputs).</p>&#13;
<p class="indent">He reset the chip, which loads the program counter and the stack pointer from the interrupt vector table, then read the program counter back as <span class="literal">0x000114cc</span>. So he knew that the value of the reset vector at <span class="literal">0x00000004</span> ought to be <span class="literal">0x000114cd</span>. (Odd pointers indicate Thumb2 mode in ARM, but the PC itself does not hold the odd value. Instead, that status bit is held in a status register.)</p>&#13;
<p class="indent">Knowing one word in memory, he then repeatedly loaded all of the registers with <span class="literal">0x00000004</span> and jumped the PC to new addresses until he saw <span class="literal">r3</span> change to <span class="literal">0x000114cd</span>, indicating an arbitrary read gadget!</p>&#13;
<p class="indent">The gadget was <span class="literal">ldr r3, [r3, #0]</span> and it appeared as the second instruction in the reset handler. Repeatedly jumping into this gadget with different values of <span class="literal">r3</span> will expose all memory.</p>&#13;
<p class="indent">Brosch’s proof-of-concept can be found in <a href="ch09.xhtml#ch9fig3">Figure 9.3</a>. The telnet connection is to OpenOCD, and it assumes that the gadget is found in the reset handler. You’ll need to adjust it if the gadget is found elsewhere in your target.<span epub:type="pagebreak" id="page_104"/></p>&#13;
</div>
</div>
</body></html>