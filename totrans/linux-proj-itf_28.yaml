- en: Chapter 28. Process Creation and Program Execution in More Detail
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 28 章. 更详细的进程创建与程序执行
- en: This chapter extends the material presented in [Chapter 24](ch24.html "Chapter 24. Process
    Creation") to [Chapter 27](ch27.html "Chapter 27. Program Execution") by covering
    a variety of topics related to process creation and program execution. We describe
    process accounting, a kernel feature that writes an accounting record for each
    process on the system as it terminates. We then look at the Linux-specific *clone()*
    system call, which is the low-level API that is used to create threads on Linux.
    We follow this with some comparisons of the performance of *fork()*, *vfork()*,
    and *clone()*. We conclude with a summary of the effects of *fork()* and *exec()*
    on the attributes of a process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章扩展了[第 24 章](ch24.html "第 24 章. 进程创建")至[第 27 章](ch27.html "第 27 章. 程序执行")中的内容，涵盖了与进程创建和程序执行相关的各种主题。我们描述了进程会计，这是一个内核功能，在每个进程终止时为系统上的每个进程写入一条会计记录。接着，我们介绍了
    Linux 特有的*clone()* 系统调用，这是用于在 Linux 上创建线程的低级 API。之后，我们对 *fork()*、*vfork()* 和 *clone()*
    的性能进行了比较。最后，我们总结了 *fork()* 和 *exec()* 对进程属性的影响。
- en: Process Accounting
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程会计
- en: When process accounting is enabled, the kernel writes an accounting record to
    the system-wide process accounting file as each process terminates. This accounting
    record contains various information maintained by the kernel about the process,
    including its termination status and how much CPU time it consumed. The accounting
    file can be analyzed by standard tools (*sa(8)* summarizes information from the
    accounting file, and *lastcomm(1)* lists information about previously executed
    commands) or by tailored applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用进程会计时，每当进程终止时，内核会将一条会计记录写入系统范围的进程会计文件。这条会计记录包含内核维护的有关进程的各种信息，包括其终止状态和消耗的
    CPU 时间。可以通过标准工具（*sa(8)* 总结来自会计文件的信息，*lastcomm(1)* 列出先前执行的命令的信息）或定制的应用程序分析会计文件。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In kernels before 2.6.10, a separate process accounting record was written for
    each thread created using the NPTL threading implementation. Since kernel 2.6.10,
    a single accounting record is written for the entire process when the last thread
    terminates. Under the older LinuxThreads threading implementation, a single process
    accounting record is always written for each thread.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.6.10 版本之前的内核中，为每个使用 NPTL 线程实现创建的线程写入一个独立的进程会计记录。自内核 2.6.10 起，当最后一个线程终止时，会为整个进程写入一条会计记录。在较旧的
    LinuxThreads 线程实现中，总是为每个线程写入一条进程会计记录。
- en: Historically, the primary use of process accounting was to charge users for
    consumption of system resources on multiuser UNIX systems. However, process accounting
    can also be useful for obtaining information about a process that was not otherwise
    monitored and reported on by its parent.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，进程会计的主要用途是对多用户 UNIX 系统上用户使用系统资源的情况进行收费。然而，进程会计也可以用于获取有关进程的信息，这些信息通常未被其父进程监控和报告。
- en: Although available on most UNIX implementations, process accounting is not specified
    in SUSv3\. The format of the accounting records, as well as the location of the
    accounting file, vary somewhat across implementations. We describe the details
    for Linux in this section, noting some variations from other UNIX implementations
    along the way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数 UNIX 实现中都可用，进程会计并未在 SUSv3 中指定。会计记录的格式以及会计文件的位置在不同实现之间有所不同。本节中我们描述了 Linux
    的细节，并注意到与其他 UNIX 实现之间的一些差异。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, process accounting is an optional kernel component that is configured
    via the option `CONFIG_BSD_PROCESS_ACCT`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，进程会计是一个可选的内核组件，通过选项 `CONFIG_BSD_PROCESS_ACCT` 配置。
- en: Enabling and disabling process accounting
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用和禁用进程会计
- en: The *acct()* system call is used by a privileged (`CAP_SYS_PACCT`) process to
    enable and disable process accounting. This system call is rarely used in application
    programs. Normally, process accounting is enabled at each system restart by placing
    appropriate commands in the system boot scripts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*acct()* 系统调用由具有特权的（`CAP_SYS_PACCT`）进程用于启用和禁用进程会计。这个系统调用在应用程序中很少使用。通常，进程会计在每次系统重启时通过将适当的命令放入系统启动脚本来启用。'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: To enable process accounting, we supply the pathname of an *existing* regular
    file in *acctfile*. A typical pathname for the accounting file is `/var/log/pacct`
    or `/usr/account/pacct`. To disable process accounting, we specify *acctfile*
    as `NULL`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用进程会计，我们需要在*acctfile*中提供一个*现有*的常规文件路径名。会计文件的典型路径名是`/var/log/pacct`或`/usr/account/pacct`。要禁用进程会计，我们将*acctfile*指定为`NULL`。
- en: The program in [Example 28-1](ch28.html#turning_process_accounting_on_and_off
    "Example 28-1. Turning process accounting on and off") uses *acct()* to switch
    process accounting on and off. The functionality of this program is similar to
    the shell *accton(8)* command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例28-1](ch28.html#turning_process_accounting_on_and_off "示例28-1. 开启和关闭进程会计")中的程序使用*acct()*来切换进程会计的开启和关闭。该程序的功能类似于shell中的*accton(8)*命令。'
- en: Example 28-1. Turning process accounting on and off
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例28-1. 开启和关闭进程会计
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Process accounting records
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程会计记录
- en: 'Once process accounting is enabled, an *acct* record is written to the accounting
    file as each process terminates. The *acct* structure is defined in `<sys/acct.h>`
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用进程会计，每当一个进程终止时，*acct*记录就会被写入到会计文件中。*acct*结构在`<sys/acct.h>`中定义如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the following points regarding the *acct* structure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于*acct*结构的几点：
- en: The *u_int16_t* and *u_int32_t* data types are 16-bit and 32-bit unsigned integers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u_int16_t*和*u_int32_t*数据类型分别是16位和32位无符号整数。'
- en: The *ac_flag* field is a bit mask recording various events for the process.
    The bits that can appear in this field are shown in [Table 28-1](ch28.html#bit_values_for_the_ac_underscore_flag_fi
    "Table 28-1. Bit values for the ac_flag field of process accounting records").
    As indicated in the table, some of these bits are not present on all UNIX implementations.
    A few other implementations provide additional bits in this field.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_flag*字段是一个位掩码，记录进程的各种事件。此字段中可能出现的位在[表28-1](ch28.html#bit_values_for_the_ac_underscore_flag_fi
    "表28-1. 进程会计记录中ac_flag字段的位值")中展示。如表所示，并非所有UNIX实现都支持这些位。某些其他实现会在此字段中提供额外的位。'
- en: The *ac_comm* field records the name of the last command (program file) executed
    by this process. The kernel records this value on each *execve()*. On some other
    UNIX implementations, this field is limited to 8 characters.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_comm*字段记录了该进程执行的最后一个命令（程序文件）的名称。内核在每次执行*execve()*时记录此值。在一些其他UNIX实现中，该字段限制为8个字符。'
- en: The *comp_t* type is a kind of floating-point number. Values of this type are
    sometimes called *compressed clock ticks*. The floating-point value consists of
    a 3-bit, base-8 exponent, followed by a 13-bit mantissa; the exponent can represent
    a factor in the range 8⁰=1 to 8⁷ (2,097,152). For example, a mantissa of 125 and
    an exponent of 1 represent the value 1000\. [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") defines a function
    (*comptToLL()*) to convert this type to *long long*. We need to use the type *long
    long* because the 32 bits used to represent an *unsigned long* on x86-32 are insufficient
    to hold the largest value that can be represented in *comp_t*, which is (2^(13)
    - 1) * 87.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*comp_t*类型是一种浮动点数。此类型的值有时被称为*压缩时钟滴答*。浮动点数由一个3位的基8指数和一个13位的尾数组成；指数可以表示一个范围从8⁰=1到8⁷（2,097,152）的因子。例如，125的尾数和1的指数表示值1000。[示例28-2](ch28.html#displaying_data_from_a_process_accountin
    "示例28-2. 显示进程会计文件中的数据")定义了一个函数（*comptToLL()*）来将此类型转换为*long long*。我们需要使用*long long*类型，因为在x86-32上，表示*unsigned
    long*的32位不足以容纳在*comp_t*中表示的最大值，即(2^(13) - 1) * 87。'
- en: The three time fields defined with the type *comp_t* represent time in system
    clock ticks. Therefore, we must divide these times by the value returned by *sysconf(_SC_CLK_TCK)*
    in order to convert them to seconds.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*comp_t*类型定义的三个时间字段表示系统时钟滴答时间。因此，我们必须通过*sysconf(_SC_CLK_TCK)*返回的值将这些时间转换为秒。
- en: The *ac_exitcode* field holds the termination status of the process (described
    in [The Wait Status Value](ch26.html#the_wait_status_value "The Wait Status Value")).
    Most other UNIX implementations instead provide a single-byte field named *ac_stat*,
    which records only the signal that killed the process (if it was killed by a signal)
    and a bit indicating whether that signal caused the process to dump core. BSD-derived
    implementations don’t provide either field.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_exitcode* 字段保存进程的终止状态（详见 [等待状态值](ch26.html#the_wait_status_value "等待状态值")）。大多数其他
    UNIX 实现则提供一个单字节字段 *ac_stat*，该字段仅记录终止进程的信号（如果进程是由信号终止的），以及一个位标志，指示该信号是否导致进程生成核心转储。基于
    BSD 的实现则不提供这两个字段。'
- en: Table 28-1. Bit values for the *ac_flag* field of process accounting records
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 28-1. 进程会计记录的 *ac_flag* 字段的位值
- en: '| Bit | Description |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 位 | 描述 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AFORK` | Process was created by *fork()*, but did not *exec()* before terminating
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `AFORK` | 进程通过 *fork()* 创建，但在终止之前未执行 *exec()* |'
- en: '| `ASU` | Process made use of superuser privileges |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `ASU` | 进程使用了超级用户权限 |'
- en: '| `AXSIG` | Process was terminated by a signal (not present on some implementations)
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `AXSIG` | 进程被信号终止（某些实现中不存在） |'
- en: '| `ACORE` | Process produced a core dump (not present on some implementations)
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `ACORE` | 进程生成了核心转储（某些实现中不存在） |'
- en: Because accounting records are written only as processes terminate, they are
    ordered by termination time (a value not recorded in the record), rather than
    by process start time (*ac_btime*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于会计记录仅在进程终止时写入，因此它们按终止时间排序（记录中未记录此值），而不是按进程启动时间（*ac_btime*）排序。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the system crashes, no accounting record is written for any processes that
    are still executing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统崩溃，对于仍在执行的任何进程，都不会写入会计记录。
- en: Since writing records to the accounting file can rapidly consume disk space,
    Linux provides the `/proc/sys/kernel/acct` virtual file for controlling the operation
    of process accounting. This file contains three numbers, defining (in order) the
    parameters *high-water*, *low-water*, and *frequency*. Typical defaults for these
    three parameters are 4, 2, and 30\. If process accounting is enabled and the amount
    of free disk space falls below *low-water* percent, accounting is suspended. If
    the amount of free disk space later rises above *high-water* percent, then accounting
    is resumed. The *frequency* value specifies how often, in seconds, checks should
    be made on the percentage of free disk space.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于写入记录到会计文件可能迅速消耗磁盘空间，Linux 提供了 `/proc/sys/kernel/acct` 虚拟文件来控制进程会计操作。该文件包含三个数字，依次定义
    *高水位*、*低水位* 和 *频率* 参数。这三个参数的典型默认值为 4、2 和 30。如果启用了进程会计，并且空闲磁盘空间低于 *低水位* 百分比，则会暂停会计操作。如果空闲磁盘空间后来上升至
    *高水位* 百分比以上，则会恢复会计操作。*频率* 值指定检查空闲磁盘空间百分比的频率（单位：秒）。
- en: Example program
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: 'The program in [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") displays selected
    fields from the records in a process accounting file. The following shell session
    demonstrates the use of this program. We begin by creating a new, empty process
    accounting file and enabling process accounting:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 28-2](ch28.html#displaying_data_from_a_process_accountin "示例 28-2. 从进程会计文件显示数据")
    中的程序显示了进程会计文件中记录的选定字段。以下 shell 会话演示了这个程序的使用。我们首先创建一个新的空的进程会计文件，并启用进程会计：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, three processes have already terminated since we enabled process
    accounting. These processes executed the *acct_on*, *su*, and *bash* programs.
    The *bash* process was started by *su* to run the privileged shell session.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，已有三个进程在启用进程会计后终止。这些进程执行了 *acct_on*、*su* 和 *bash* 程序。*bash* 进程是由 *su* 启动的，用来运行特权
    shell 会话。
- en: 'Now we run a series of commands to add further records to the accounting file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行一系列命令，向会计文件中添加更多记录：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next two commands run programs that we presented in previous chapters ([Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program"), in [The *exec()* Library
    Functions](ch27.html#the_exec_open_parenthesis_close_parenthe "The exec() Library
    Functions"), and [Example 24-1](ch24.html#using_fork_open_parenthesis_close_parent
    "Example 24-1. Using fork()"), in [File Sharing Between Parent and Child](ch24.html#file_sharing_between_parent_and_child
    "File Sharing Between Parent and Child")). The first command runs a program that
    execs the file `/bin/echo`; this results in an accounting record with the command
    name *echo*. The second command creates a child process that doesn’t perform an
    *exec()*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个命令运行了我们在前面章节中介绍的程序（[示例 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "示例 27-1. 使用 execve() 执行新程序")，在[exec()库函数](ch27.html#the_exec_open_parenthesis_close_parenthe
    "exec() 库函数")中，以及[示例 24-1](ch24.html#using_fork_open_parenthesis_close_parent
    "示例 24-1. 使用 fork()")，在[父子进程间的文件共享](ch24.html#file_sharing_between_parent_and_child
    "父子进程间的文件共享")中）。第一个命令运行一个执行`/bin/echo`文件的程序；这将生成一个命令名为*echo*的会计记录。第二个命令创建一个没有执行*exec()*的子进程。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we use the program in [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") to view the contents
    of the accounting file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用[示例 28-2](ch28.html#displaying_data_from_a_process_accountin "示例 28-2.
    显示来自进程会计文件的数据")中的程序查看会计文件的内容：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the output, we see one line for each process that was created in the shell
    session. The *ulimit* and *echo* commands are shell built-in commands, so they
    don’t result in the creation of new processes. Note that the entry for *sleep*
    appeared in the accounting file after the *cat* entry because the *sleep* command
    terminated after the *cat* command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到每个在 shell 会话中创建的进程的每一行。*ulimit*和*echo*命令是 shell 内建命令，因此不会创建新进程。请注意，*sleep*的条目出现在*cat*条目之后，因为*sleep*命令在*cat*命令之后终止。
- en: Most of the output is self-explanatory. The *flags* column shows single letters
    indicating which of the *ac_flag* bits is set in each record (see [Table 28-1](ch28.html#bit_values_for_the_ac_underscore_flag_fi
    "Table 28-1. Bit values for the ac_flag field of process accounting records")).
    [The Wait Status Value](ch26.html#the_wait_status_value "The Wait Status Value")
    describes how to interpret the termination status values shown in the *term. status*
    column.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数输出内容是不言自明的。*flags*列显示单个字母，表示每条记录中哪个*ac_flag*位被设置（见[表 28-1](ch28.html#bit_values_for_the_ac_underscore_flag_fi
    "表 28-1. 进程会计记录中 ac_flag 字段的位值")）。[等待状态值](ch26.html#the_wait_status_value "等待状态值")描述了如何解释*term.
    status*列中显示的终止状态值。
- en: Example 28-2. Displaying data from a process accounting file
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 28-2. 显示来自进程会计文件的数据
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Process accounting Version 3 file format
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程会计版本 3 文件格式
- en: Starting with kernel 2.6.8, Linux introduced an optional alternative version
    of the process accounting file that addresses some limitations of the traditional
    accounting file. To use this alternative version, known as *Version 3*, the `CONFIG_BSD_PROCESS_ACCT_V3`
    kernel configuration option must be enabled before building the kernel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.8 开始，Linux 引入了一种可选的替代版本进程会计文件，解决了传统会计文件的一些限制。要使用这种替代版本，称为*版本 3*，必须在构建内核之前启用`CONFIG_BSD_PROCESS_ACCT_V3`内核配置选项。
- en: 'When using the Version 3 option, the only difference in the operation of process
    accounting is in the format of records written to the accounting file. The new
    format is defined as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用版本 3 选项时，进程会计操作的唯一区别在于写入会计文件的记录格式。新格式定义如下：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are the main differences between the *acct_v3* structure and
    the traditional Linux *acct* structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*acct_v3*结构和传统Linux*acct*结构之间的主要区别：
- en: The *ac_version* field is added. This field contains the version number of this
    type of accounting record. This field is always 3 for an *acct_v3* record.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了*ac_version*字段。该字段包含此类型会计记录的版本号。对于*acct_v3*记录，此字段始终为 3。
- en: The fields *ac_pid* and *ac_ppid*, containing the process ID and parent process
    ID of the terminated process, are added.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了*ac_pid*和*ac_ppid*字段，分别包含已终止进程的进程 ID 和父进程 ID。
- en: The *ac_uid* and *ac_gid* fields are widened from 16 to 32 bits, to accommodate
    the 32-bit user and group IDs that were introduced in Linux 2.4\. (Large user
    and group IDs can’t be correctly represented in the traditional *acct* file.)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_uid* 和 *ac_gid* 字段的宽度从 16 位扩展到 32 位，以适应 Linux 2.4 引入的 32 位用户和组 ID。（传统的
    *acct* 文件无法正确表示较大的用户和组 ID。）'
- en: The type of the *ac_etime* field is changed from *comp_t* to *float*, to allow
    longer elapsed times to be recorded.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_etime* 字段的类型从 *comp_t* 改为 *float*，以便记录更长的经过时间。'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: We provide a Version 3 analog of the program in [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") in the file `procexec/acct_v3_view.c`
    in the source code distribution for this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的源代码分发中提供了一个 Version 3 类似程序，位于文件 `procexec/acct_v3_view.c` 中，参见 [示例 28-2](ch28.html#displaying_data_from_a_process_accountin
    "示例 28-2. 从进程会计文件显示数据")。
- en: The *clone()* System Call
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*clone()* 系统调用'
- en: 'Like *fork()* and *vfork()*, the Linux-specific *clone()* system call creates
    a new process. It differs from the other two calls in allowing finer control over
    the steps that occur during process creation. The main use of *clone()* is in
    the implementation of threading libraries. Because *clone()* is not portable,
    its direct use in application programs should normally be avoided. We describe
    it here because it is useful background for the discussion of POSIX threads in
    [Chapter 29](ch29.html "Chapter 29. Threads: Introduction") to [Chapter 33](ch33.html
    "Chapter 33. Threads: Further Details"), and also because it further illuminates
    the operation of *fork()* and *vfork()*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 像 *fork()* 和 *vfork()* 一样，Linux 特有的 *clone()* 系统调用创建一个新进程。它与另外两个调用的不同之处在于，它允许更精细地控制进程创建过程中发生的各个步骤。*clone()*
    的主要用途是在线程库的实现中。由于 *clone()* 并不具有可移植性，因此通常应避免在应用程序中直接使用它。我们在这里讨论它，是因为它为第 [29 章](ch29.html
    "第29章。线程：简介") 到第 [33 章](ch33.html "第33章。线程：进一步细节") 关于 POSIX 线程的讨论提供了有用的背景，也因为它有助于进一步理解
    *fork()* 和 *vfork()* 的操作。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Returns process ID of child on success, or -1 on error
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回子进程的进程 ID，出错时返回 -1。
- en: Like *fork()*, a new process created with *clone()* is an almost exact duplicate
    of the parent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像 *fork()* 一样，使用 *clone()* 创建的新进程几乎是父进程的精确副本。
- en: Unlike *fork()*, the cloned child doesn’t continue from the point of the call,
    but instead commences by calling the function specified in the *func* argument;
    we’ll refer to this as the *child function*. When called, the child function is
    passed the value specified in *func_arg*. Using appropriate casting, the child
    function can freely interpret this argument; for example, as an int or as a pointer
    to a structure. (Interpreting it as a pointer is possible because the cloned child
    either obtains a copy of or shares the calling process’s memory.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *fork()* 不同，克隆的子进程不会从调用点继续执行，而是通过调用 *func* 参数中指定的函数开始执行；我们将其称为 *子进程函数*。在调用时，子进程函数会传入
    *func_arg* 中指定的值。通过适当的类型转换，子进程函数可以自由解释这个参数；例如，可以将其解释为 int 类型或结构体的指针。（将其解释为指针是可能的，因为克隆的子进程要么获取调用进程的内存副本，要么与之共享内存。）
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: 'Within the kernel, *fork()*, *vfork()*, and *clone()* are ultimately implemented
    by the same function (*do_fork()* in `kernel/fork.c`). At this level, cloning
    is much closer to forking: *sys_clone()* doesn’t have the *func* and *func_arg*
    arguments, and after the call, *sys_clone()* returns in the child in the same
    manner as *fork()*. The main text describes the *clone()* wrapper function that
    *glibc* provides for *sys_clone()*. (This function is defined in architecture-specific
    *glibc* assembler sources, such as in `sysdeps/unix/sysv/linux/i386/clone.S`.)
    This wrapper function invokes *func* after *sys_clone()* returns in the child.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，*fork()*, *vfork()* 和 *clone()* 最终都由同一个函数实现（`kernel/fork.c` 中的 *do_fork()*）。在这个层面上，克隆更接近于分叉：*sys_clone()*
    没有 *func* 和 *func_arg* 参数，且在调用后，*sys_clone()* 会像 *fork()* 一样在子进程中返回。正文描述了 *glibc*
    为 *sys_clone()* 提供的 *clone()* 包装函数。（该函数在架构特定的 *glibc* 汇编源代码中定义，例如在 `sysdeps/unix/sysv/linux/i386/clone.S`
    中。）该包装函数在 *sys_clone()* 在子进程中返回后调用 *func*。
- en: The cloned child process terminates either when *func* returns (in which case
    its return value is the exit status of the process) or when the process makes
    a call to *exit()* (or _*exit()*). The parent process can wait for the cloned
    child in the usual manner using *wait()* or similar.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆的子进程终止的时机要么是 *func* 返回（此时其返回值为进程的退出状态），要么是进程调用 *exit()*（或 _*exit()*）时。父进程可以像往常一样使用
    *wait()* 或类似函数等待克隆的子进程。
- en: Since a cloned child may (like *vfork()*) share the parent’s memory, it can’t
    use the parent’s stack. Instead, the caller must allocate a suitably sized block
    of memory for use as the child’s stack and pass a pointer to that block in the
    argument *child_stack*. On most hardware architectures, the stack grows downward,
    so the *child_stack* argument should point to the high end of the allocated block.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于克隆的子进程可能（像 *vfork()* 一样）共享父进程的内存，因此不能使用父进程的堆栈。相反，调用者必须为子进程分配一个适当大小的内存块作为堆栈，并将该内存块的指针传递给
    *child_stack* 参数。在大多数硬件架构上，堆栈是向下增长的，因此 *child_stack* 参数应该指向分配内存块的高端。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The architecture-dependence on the direction of stack growth is a defect in
    the design of *clone()*. On the Intel IA-64 architecture, an improved clone API
    is provided, in the form of *clone2()*. This system call defines the range of
    the stack of the child in a way that doesn’t depend on the direction of stack
    growth, by supplying both the start address and size of the stack. See the manual
    page for details.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈增长方向的架构依赖性是 *clone()* 设计中的一个缺陷。在Intel IA-64架构上，提供了改进的 *clone()* API，形式为 *clone2()*。这个系统调用通过提供堆栈的起始地址和大小，定义了子进程堆栈的范围，避免依赖堆栈增长的方向。详情请参见手册页。
- en: The *clone() flags* argument serves two purposes. First, its lower byte specifies
    the child’s *termination signal*, which is the signal to be sent to the parent
    when the child terminates. (If a cloned child is *stopped* by a signal, the parent
    still receives `SIGCHLD`.) This byte may be 0, in which case no signal is generated.
    (Using the Linux-specific /`proc/`*PID*`/stat` file, we can determine the termination
    signal of any process; see the *proc(5)* manual page for further details.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*clone()* 标志位参数有两个用途。首先，其低字节指定子进程的 *终止信号*，即当子进程终止时发送给父进程的信号。（如果克隆的子进程被信号 *停止*，父进程仍会接收到
    `SIGCHLD`。）这个字节可以为0，表示不生成信号。（通过使用Linux特有的 /`proc/`*PID*`/stat` 文件，我们可以确定任何进程的终止信号；详情请参见
    *proc(5)* 手册页。）'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: With *fork()* and *vfork()*, we have no way to select the termination signal;
    it is always `SIGCHLD`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *fork()* 和 *vfork()*，我们无法选择终止信号；它总是 `SIGCHLD`。
- en: The remaining bytes of the *flags* argument hold a bit mask that controls the
    operation of *clone()*. We summarize these bit-mask values in [Table 28-2](ch28.html#the_clone_open_parenthesis_close_par
    "Table 28-2. The clone() flags bit-mask values"), and describe them in more detail
    in [Example program](ch28.html#example_program-id39 "Example program").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数的剩余字节包含一个位掩码，控制 *clone()* 的操作。我们在[表28-2](ch28.html#the_clone_open_parenthesis_close_par
    "表28-2. *clone()* 标志位掩码值")中总结了这些位掩码值，并在[示例程序](ch28.html#example_program-id39 "示例程序")中进行了更详细的描述。'
- en: Table 28-2. The *clone() flags* bit-mask values
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表28-2. *clone()* 标志位掩码值
- en: '| Flag | Effect if present |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 如果存在，效果 |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CLONE_CHILD_CLEARTID` | Clear *ctid* when child calls *exec()* or *_exit()*
    (2.6 onward) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_CHILD_CLEARTID` | 当子进程调用 *exec()* 或 *_exit()* 时清除 *ctid*（2.6及以后版本）
    |'
- en: '| `CLONE_CHILD_SETTID` | Write thread ID of child into *ctid* (2.6 onward)
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_CHILD_SETTID` | 将子进程的线程ID写入 *ctid*（2.6及以后版本） |'
- en: '| `CLONE_FILES` | Parent and child share table of open file descriptors |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_FILES` | 父进程和子进程共享打开文件描述符表 |'
- en: '| `CLONE_FS` | Parent and child share attributes related to file system |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_FS` | 父进程和子进程共享与文件系统相关的属性 |'
- en: '| `CLONE_IO` | Child shares parent’s I/O context (2.6.25 onward) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_IO` | 子进程共享父进程的I/O上下文（2.6.25及以后版本） |'
- en: '| `CLONE_NEWIPC` | Child gets new System V IPC namespace (2.6.19 onward) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWIPC` | 子进程获得新的System V IPC命名空间（2.6.19及以后版本） |'
- en: '| `CLONE_NEWNET` | Child gets new network namespace (2.4.24 onward) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWNET` | 子进程获得新的网络命名空间（2.4.24及以后版本） |'
- en: '| `CLONE_NEWNS` | Child gets copy of parent’s mount namespace (2.4.19 onward)
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWNS` | 子进程获得父进程的挂载命名空间副本（2.4.19及以后版本） |'
- en: '| `CLONE_NEWPID` | Child gets new process-ID namespace (2.6.19 onward) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWPID` | 子进程获得新的进程ID命名空间（2.6.19及以后版本） |'
- en: '| `CLONE_NEWUSER` | Child gets new user-ID namespace (2.6.23 onward) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWUSER` | 子进程获得新的用户ID命名空间（2.6.23及以后版本） |'
- en: '| `CLONE_NEWUTS` | Child gets new UTS (*utsname()*) namespace (2.6.19 onward)
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWUTS` | 子进程获得新的UTS（*utsname()*）命名空间（2.6.19及以后版本） |'
- en: '| `CLONE_PARENT` | Make child’s parent same as caller’s parent (2.4 onward)
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PARENT` | 将子进程的父进程设置为与调用者的父进程相同（2.4及以后版本） |'
- en: '| `CLONE_PARENT_SETTID` | Write thread ID of child into *ptid* (2.6 onward)
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PARENT_SETTID` | 将子进程的线程ID写入 *ptid*（2.6及以后版本） |'
- en: '| `CLONE_PID` | Obsolete flag used only by system boot process (up to 2.4)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PID` | 仅由系统启动过程使用的过时标志（最多到2.4版本） |'
- en: '| `CLONE_PTRACE` | If parent is being traced, then trace child also |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PTRACE` | 如果父进程正在被跟踪，则子进程也被跟踪 |'
- en: '| `CLONE_SETTLS` | *tls* describes thread-local storage for child (2.6 onward)
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_SETTLS` | *tls*描述子进程的线程局部存储（从2.6版本起） |'
- en: '| `CLONE_SIGHAND` | Parent and child share signal dispositions |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_SIGHAND` | 父进程和子进程共享信号处理方式 |'
- en: '| `CLONE_SYSVSEM` | Parent and child share semaphore undo values (2.6 onward)
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_SYSVSEM` | 父进程和子进程共享信号量撤销值（从2.6版本起） |'
- en: '| `CLONE_THREAD` | Place child in same thread group as parent (2.4 onward)
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_THREAD` | 将子进程放入与父进程相同的线程组（从2.4版本起） |'
- en: '| `CLONE_UNTRACED` | Can’t force `CLONE_PTRACE` on child (2.6 onward) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_UNTRACED` | 无法强制对子进程执行`CLONE_PTRACE`（从2.6版本起） |'
- en: '| `CLONE_VFORK` | Parent is suspended until child calls *exec()* or *_exit()*
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_VFORK` | 父进程被挂起，直到子进程调用*exec()*或*_exit()* |'
- en: '| `CLONE_VM` | Parent and child share virtual memory |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_VM` | 父进程和子进程共享虚拟内存 |'
- en: The remaining arguments to *clone()* are *ptid*, *tls*, and *ctid*. These arguments
    relate to the implementation of threads, in particular the use of thread IDs and
    thread-local storage. We cover the use of these arguments when describing the
    *flags* bit-mask values in [Example program](ch28.html#example_program-id39 "Example
    program"). (In Linux 2.4 and earlier, these three arguments are not provided by
    *clone()*. They were specifically added in Linux 2.6 to support the NPTL POSIX
    threads implementation.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*clone()*的其余参数是*ptid*、*tls*和*ctid*。这些参数与线程的实现有关，特别是与线程ID和线程局部存储的使用有关。我们将在[示例程序](ch28.html#example_program-id39
    "示例程序")中描述这些参数和*flags*位掩码值时，详细介绍它们的使用。（在Linux 2.4及更早版本中，*clone()*没有提供这三个参数。它们是在Linux
    2.6中专门添加的，用以支持NPTL POSIX线程实现。）'
- en: Example program
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 28-3](ch28.html#using_clone_open_parenthesis_close_paren "Example 28-3. Using
    clone() to create a child process") shows a simple example of the use of *clone()*
    to create a child process. The main program does the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例28-3](ch28.html#using_clone_open_parenthesis_close_paren "示例28-3. 使用clone()创建子进程")展示了如何使用*clone()*创建子进程的简单示例。主程序执行以下操作：'
- en: Open a file descriptor (for `/dev/null`) that will be closed by the child ![](figs/web/U002.png).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个文件描述符（针对`/dev/null`），该文件描述符将由子进程关闭！[](figs/web/U002.png)。
- en: Set the value for the *clone() flags* argument to `CLONE_FILES` ![](figs/web/U003.png)
    if a command-line argument was supplied, so that the parent and child will share
    a single file descriptor table. If no command-line argument was supplied, *flags*
    is set to 0.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了命令行参数，则将*clone()*标志参数的值设置为`CLONE_FILES`！[](figs/web/U003.png)，使得父进程和子进程共享同一个文件描述符表。如果没有提供命令行参数，则将*flags*设置为0。
- en: Allocate a stack for use by the child ![](figs/web/U004.png).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为子进程分配一个栈空间！[](figs/web/U004.png)。
- en: If `CHILD_SIG` is nonzero and is not equal to `SIGCHLD`, ignore it, in case
    it is a signal that would terminate the process. We don’t ignore `SIGCHLD`, because
    doing so would prevent waiting on the child to collect its status.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`CHILD_SIG`非零且不等于`SIGCHLD`，则忽略它，以防它是一个会终止进程的信号。我们不忽略`SIGCHLD`，因为忽略它会阻止父进程等待子进程收集其状态。
- en: Call *clone()* to create the child ![](figs/web/U006.png). The third (bit-mask)
    argument includes the termination signal. The fourth argument (*func_arg*) specifies
    the file descriptor opened earlier (at ![](figs/web/U002.png)).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*clone()*来创建子进程！[](figs/web/U006.png)。第三个（位掩码）参数包括终止信号。第四个参数（*func_arg*）指定先前打开的文件描述符（在![](figs/web/U002.png)处）。
- en: Wait for the child to terminate ![](figs/web/U007.png).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待子进程终止！[](figs/web/U007.png)。
- en: Check whether the file descriptor (opened at ![](figs/web/U002.png)) is still
    open by trying to *write()* to it ![](figs/web/U008.png). The program reports
    whether the *write()* succeeds or fails.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尝试对文件描述符（在![](figs/web/U002.png)处打开）执行*write()*操作，检查文件描述符是否仍然打开！[](figs/web/U008.png)。程序报告*write()*操作是成功还是失败。
- en: Execution of the cloned child begins in *childFunc()*, which receives (in the
    argument *arg*) the file descriptor opened by the main program (at ![](figs/web/U002.png)).
    The child closes this file descriptor and then terminates by performing a `return`
    ![](figs/web/U001.png).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆的子进程执行从*childFunc()*开始，该函数接收（在参数*arg*中）由主程序打开的文件描述符（在![](figs/web/U002.png)处）。子进程关闭此文件描述符后，通过执行`return`！[](figs/web/U001.png)来终止。
- en: Example 28-3. Using *clone()* to create a child process
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例28-3. 使用*clone()*创建子进程
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run the program in [Example 28-3](ch28.html#using_clone_open_parenthesis_close_paren
    "Example 28-3. Using clone() to create a child process") without a command-line
    argument, we see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[示例28-3](ch28.html#using_clone_open_parenthesis_close_paren "示例28-3. 使用clone()创建子进程")中运行程序且没有命令行参数时，我们看到以下内容：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we run the program with a command-line argument, we can see that the two
    processes share the file descriptor table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用命令行参数运行程序时，我们可以看到两个进程共享文件描述符表：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We show a more complex example of the use of *clone()* in the file `procexec/demo_clone.c`
    in the source code distribution for this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的源代码分发版中的文件`procexec/demo_clone.c`中展示了一个更复杂的使用*clone()*的例子。
- en: The *clone() flags* Argument
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*clone() 标志* 参数'
- en: The *clone() flags* argument is a combination (ORing) of the bit-mask values
    described in the following pages. Rather than presenting these flags in alphabetical
    order, we present them in an order that eases explanation, and begin with those
    flags that are used in the implementation of POSIX threads. From the point of
    view of implementing threads, many uses of the word *process* below can be replaced
    by *thread*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*clone() 标志*参数是以下页面中描述的位掩码值的组合（按位“或”运算）。我们没有按字母顺序呈现这些标志，而是按照便于解释的顺序呈现，并从实现POSIX线程中使用的标志开始。从实现线程的角度来看，下面许多提到的“进程”一词可以替换为“线程”。'
- en: At this point, it is worth remarking that, to some extent, we are playing with
    words when trying to draw a distinction between the terms *thread* and *process*.
    It helps a little to introduce the term *kernel scheduling entity* (KSE), which
    is used in some texts to refer to the objects that are dealt with by the kernel
    scheduler. Really, threads and processes are simply KSEs that provide for greater
    and lesser degrees of sharing of attributes (virtual memory, open file descriptors,
    signal dispositions, process ID, and so on) with other KSEs. The POSIX threads
    specification provides just one out of various possible definitions of which attributes
    should be shared between threads.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此时值得指出的是，在某种程度上，我们在试图区分*线程*和*进程*这两个术语时，实际上是在玩文字游戏。引入术语*内核调度实体*（KSE）有助于一些理解，它在某些文献中用于指代内核调度器处理的对象。实际上，线程和进程只是KSE，它们在与其他KSE共享属性（虚拟内存、打开的文件描述符、信号处置、进程ID等）的程度上有所不同。POSIX线程规范提供了一个定义，规定了线程之间应该共享哪些属性。
- en: 'In the course of the following descriptions, we’ll sometimes mention the two
    main implementations of POSIX threads available on Linux: the older LinuxThreads
    implementation and the more recent NPTL implementation. Further information about
    these two implementations can be found in Section 33.5.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的描述过程中，我们有时会提到Linux上两种主要的POSIX线程实现：较旧的LinuxThreads实现和较新的NPTL实现。有关这两种实现的更多信息，请参阅第33.5节。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting in kernel 2.6.16, Linux provides a new system call, *unshare()*, which
    allows a child created using *clone()* (or *fork()* or *vfork()*) to undo some
    of the attribute sharing (i.e., reverse the effects of some of the *clone() flags*
    bits) that was established when the child was created. For details, see the *unshare(2)*
    manual page.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核2.6.16开始，Linux提供了一种新的系统调用*unshare()*，允许使用*clone()*（或*fork()*或*vfork()*)创建的子进程撤销一些属性共享（即撤销一些*clone()
    标志*位的效果），该属性共享在子进程创建时被建立。有关详细信息，请参阅*unshare(2)*手册页。
- en: 'Sharing file descriptor tables: `CLONE_FILES`'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享文件描述符表：`CLONE_FILES`
- en: If the `CLONE_FILES` flag is specified, the parent and the child share the same
    table of open file descriptors. This means that file descriptor allocation or
    deallocation (*open()*, *close()*, *dup()*, *pipe()*, *socket()*, and so on) in
    either process will be visible in the other process. If the `CLONE_FILES` flag
    is not set, then the file descriptor table is not shared, and the child gets a
    copy of the parent’s table at the time of the *clone()* call. These copied descriptors
    refer to the same open file descriptions as the corresponding descriptors in the
    parent (as with *fork()* and *vfork()*).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了`CLONE_FILES`标志，则父进程和子进程共享相同的打开文件描述符表。这意味着在任一进程中的文件描述符分配或释放（*open()*, *close()*,
    *dup()*, *pipe()*, *socket()*等）将在另一个进程中可见。如果没有设置`CLONE_FILES`标志，则文件描述符表不共享，子进程在调用*clone()*时将获得父进程表的副本。这些复制的描述符引用与父进程中相应描述符相同的打开文件描述符（就像*fork()*和*vfork()*一样）。
- en: The specification of POSIX threads requires that all of the threads in a process
    share the same open file descriptors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX线程的规范要求一个进程中的所有线程共享相同的打开文件描述符。
- en: 'Sharing file system-related information: `CLONE_FS`'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享与文件系统相关的信息：`CLONE_FS`
- en: If the `CLONE_FS` flag is specified, then the parent and the child share file
    system-related information—umask, root directory, and current working directory.
    This means that calls to *umask()*, *chdir()*, or *chroot()* in either process
    will affect the other process. If the `CLONE_FS` flag is not set, then the parent
    and child have separate copies of this information (as with *fork()* and *vfork()*).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_FS` 标志，则父进程和子进程共享与文件系统相关的信息——umask、根目录和当前工作目录。这意味着，在任一进程中调用 *umask()*、*chdir()*
    或 *chroot()* 都会影响另一个进程。如果未设置 `CLONE_FS` 标志，则父进程和子进程拥有该信息的独立副本（就像 *fork()* 和 *vfork()*）。
- en: The attribute sharing provided by `CLONE_FS` is required by POSIX threads.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLONE_FS` 提供的属性共享是 POSIX 线程的要求。'
- en: 'Sharing signal dispositions: `CLONE_SIGHAND`'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享信号处置表：`CLONE_SIGHAND`
- en: If the `CLONE_SIGHAND` flag is set, then the parent and child share the same
    table of signal dispositions. Using *sigaction()* or *signal()* to change a signal’s
    disposition in either process will affect that signal’s disposition in the other
    process. If the `CLONE_SIGHAND` flag is not set, then signal dispositions are
    not shared; instead, the child gets a copy of the parent’s signal disposition
    table (as with *fork()* and *vfork()*). The `CLONE_SIGHAND` flag doesn’t affect
    the process signal mask and the set of pending signals, which are always distinct
    for the two processes. From Linux 2.6 onward, `CLONE_VM` must also be included
    in *flags* if `CLONE_SIGHAND` is specified.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_SIGHAND` 标志，则父进程和子进程共享相同的信号处置表。在任一进程中使用 *sigaction()* 或 *signal()*
    更改信号的处置方式，将会影响另一个进程中的信号处置方式。如果未设置 `CLONE_SIGHAND` 标志，则信号处置表不会共享；相反，子进程将获得父进程的信号处置表副本（就像
    *fork()* 和 *vfork()*）。`CLONE_SIGHAND` 标志不会影响进程的信号屏蔽字和待处理信号集，这些始终是两个进程独立的。从 Linux
    2.6 开始，如果指定了 `CLONE_SIGHAND`，则必须在 *flags* 中包含 `CLONE_VM`。
- en: Sharing of signal dispositions is required by POSIX threads.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 线程要求共享信号处置表。
- en: 'Sharing the parent’s virtual memory: `CLONE_VM`'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享父进程的虚拟内存：`CLONE_VM`
- en: If the `CLONE_VM` flag is set, then the parent and child share the same virtual
    memory pages (as with *vfork()*). Updates to memory or calls to *mmap()* or *munmap()*
    by either process will be visible to the other process. If the `CLONE_VM` flag
    is not set, then the child receives a copy of the parent’s virtual memory (as
    with *fork()*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_VM` 标志，则父进程和子进程共享相同的虚拟内存页面（就像 *vfork()*）。任一进程对内存的更新或对 *mmap()*
    或 *munmap()* 的调用都会影响另一个进程。如果未设置 `CLONE_VM` 标志，则子进程会接收父进程的虚拟内存副本（就像 *fork()*）。
- en: Sharing the same virtual memory is one of the defining attributes of threads,
    and is required by POSIX threads.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 共享相同的虚拟内存是线程的一个定义特性，也是 POSIX 线程的要求。
- en: 'Thread groups: `CLONE_THREAD`'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程组：`CLONE_THREAD`
- en: If the `CLONE_THREAD` flag is set, then the child is placed in the same thread
    group as the parent. If this flag not set, the child is placed in its own new
    thread group.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_THREAD` 标志，则子进程会被放入与父进程相同的线程组。如果未设置此标志，则子进程会被放入一个新的线程组。
- en: '*Threads groups* were introduced in Linux 2.4 to allow threading libraries
    to support the POSIX threads requirement that all of the threads in a process
    share a single process ID (i.e., *getpid()* in each of the threads should return
    the same value). A thread group is a group of KSEs that share the same *thread
    group identifier* (TGID), as shown in [Figure 28-1](ch28.html#a_thread_group_containing_four_threads
    "Figure 28-1. A thread group containing four threads"). For the remainder of the
    discussion of `CLONE_THREAD`, we’ll refer to these KSEs as *threads*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程组*是在 Linux 2.4 中引入的，目的是让线程库支持 POSIX 线程要求，使得进程中的所有线程共享一个进程 ID（即，*getpid()*
    在每个线程中返回相同的值）。线程组是共享相同 *线程组标识符*（TGID）的 KSE（Kernel Scheduling Entity）组，如 [图28-1](ch28.html#a_thread_group_containing_four_threads
    "图28-1. 一个包含四个线程的线程组")所示。在接下来的 `CLONE_THREAD` 讨论中，我们将这些 KSE 称为 *线程*。'
- en: Since Linux 2.4, *getpid()* returns the calling thread’s TGID. In other words,
    a TGID is the same thing as a process ID.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Linux 2.4 起，*getpid()* 返回调用线程的 TGID。换句话说，TGID 就是进程 ID。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *clone()* implementation in Linux 2.2 and earlier did not provide `CLONE_THREAD`.
    Instead, LinuxThreads implemented POSIX threads as processes that shared various
    attributes (e.g., virtual memory) but had distinct process IDs. For compatibility
    reasons, even on modern Linux kernels, the LinuxThreads implementation doesn’t
    use the `CLONE_THREAD` flag, so that threads in that implementation continue to
    have distinct process IDs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.2 及更早版本中，*clone()* 实现并没有提供 `CLONE_THREAD`。相反，LinuxThreads 将 POSIX
    线程实现为共享各种属性（例如虚拟内存）的进程，但具有独立的进程 ID。出于兼容性考虑，即使在现代 Linux 内核中，LinuxThreads 实现也不使用
    `CLONE_THREAD` 标志，因此该实现中的线程依然具有独立的进程 ID。
- en: '![A thread group containing four threads](figs/web/28-1_PROCEXEC-thread-group-scale90.png.jpg)Figure 28-1. A
    thread group containing four threads'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个包含四个线程的线程组](figs/web/28-1_PROCEXEC-thread-group-scale90.png.jpg)图 28-1.
    一个包含四个线程的线程组'
- en: Each thread within a thread group is distinguished by a unique *thread identifier*
    (TID). Linux 2.4 introduced a new system call, *gettid()*, to allow a thread to
    obtain its own thread ID (this is the same value as is returned to the thread
    that calls *clone()*). A thread ID is represented using the same data type that
    is used for a process ID, *pid_t*. Thread IDs are unique system-wide, and the
    kernel guarantees that no thread ID will be the same as any process ID on the
    system, except when a thread is the thread group leader for a process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 线程组中的每个线程都有一个独特的*线程标识符*（TID）。Linux 2.4 引入了一个新的系统调用，*gettid()*，允许线程获取其自己的线程 ID（这是返回给调用
    *clone()* 的线程的相同值）。线程 ID 使用与进程 ID 相同的数据类型 *pid_t* 来表示。线程 ID 在系统范围内是唯一的，内核保证没有任何线程
    ID 会与系统上的进程 ID 相同，除非该线程是某个进程的线程组领导者。
- en: The first thread in a new thread group has a thread ID that is the same as its
    thread group ID. This thread is referred to as the *thread group leader*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 新线程组中的第一个线程具有与其线程组 ID 相同的线程 ID。这个线程被称为*线程组领导者*。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The thread IDs that we are discussing here are not the same as the thread IDs
    (the *pthread_t* data type) used by POSIX threads. The latter identifiers are
    generated and maintained internally (in user space) by a POSIX threads implementation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的线程 ID 与 POSIX 线程使用的线程 ID（*pthread_t* 数据类型）不同。后者的标识符是在用户空间内部生成并维护的（由 POSIX
    线程实现）。
- en: All of the threads in a thread group have the same parent process ID—that of
    the thread group leader. Only after all of the threads in a thread group have
    terminated is a `SIGCHLD` signal (or other termination signal) sent to that parent
    process. These semantics correspond to the requirements of POSIX threads.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程组中的所有线程都具有相同的父进程 ID——即线程组领导者的进程 ID。只有当线程组中的所有线程都终止后，`SIGCHLD` 信号（或其他终止信号）才会发送到该父进程。这些语义符合
    POSIX 线程的要求。
- en: When a `CLONE_THREAD` thread terminates, no signal is sent to the thread that
    created it using *clone()*. Correspondingly, it is not possible to use *wait()*
    (or similar) to wait for a thread created using `CLONE_THREAD`. This accords with
    POSIX requirements. A POSIX thread is not the same thing as a process, and can’t
    be waited for using *wait()*; instead, it must be joined using *pthread_join()*.
    To detect the termination of a thread created using `CLONE_THREAD`, a special
    synchronization primitive, called a *futex*, is used (see the discussion of the
    `CLONE_PARENT_SETTID` flag below).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `CLONE_THREAD` 线程终止时，不会向创建它的线程发送信号（该线程使用 *clone()* 创建）。因此，无法使用 *wait()*（或类似的）来等待通过
    `CLONE_THREAD` 创建的线程。这符合 POSIX 的要求。POSIX 线程与进程不同，不能通过 *wait()* 来等待；相反，必须使用 *pthread_join()*
    来连接该线程。为了检测通过 `CLONE_THREAD` 创建的线程的终止，使用一种特殊的同步原语，叫做 *futex*（请参见下文关于 `CLONE_PARENT_SETTID`
    标志的讨论）。
- en: If any of the threads in a thread group performs an *exec()*, then all threads
    other than the thread group leader are terminated (this behavior corresponds to
    the semantics required for POSIX threads), and the new program is execed in the
    thread group leader. In other words, in the new program, *gettid()* will return
    the thread ID of the thread group leader. During an *exec()*, the termination
    signal that this process should send to its parent is reset to `SIGCHLD`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程组中的任何线程执行了 *exec()*，则除了线程组领导者外，所有线程都会被终止（这一行为符合 POSIX 线程所需的语义），新程序将在线程组领导者中执行。换句话说，在新程序中，*gettid()*
    将返回线程组领导者的线程 ID。在 *exec()* 过程中，应该发送到父进程的终止信号将重置为 `SIGCHLD`。
- en: If one of the threads in a thread group creates a child using *fork()* or *vfork()*,
    then any thread in the group can monitor that child using *wait()* or similar.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程组中的某个线程通过 *fork()* 或 *vfork()* 创建了一个子线程，那么该组中的任何线程都可以使用 *wait()* 或类似方法来监控该子线程。
- en: From Linux 2.6 onward, `CLONE_SIGHAND` must also be included in *flags* if `CLONE_THREAD`
    is specified. This corresponds to further POSIX threads requirements; for details,
    see the description of how POSIX threads and signals interact in Section 33.2\.
    (The kernel handling of signals for `CLONE_THREAD` thread groups mirrors the POSIX
    requirements for how the threads in a process should react to signals.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linux 2.6 开始，如果指定了 `CLONE_THREAD`，则必须在 *flags* 中包含 `CLONE_SIGHAND`。这对应于进一步的
    POSIX 线程要求；详细信息请参阅第 33.2 节中描述的 POSIX 线程与信号的交互。（`CLONE_THREAD` 线程组的内核信号处理符合 POSIX
    对进程中线程如何响应信号的要求。）
- en: 'Threading library support: `CLONE_PARENT_SETTID`, `CLONE_CHILD_SETTID`, and
    `CLONE_CHILD_CLEARTID`'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程库支持：`CLONE_PARENT_SETTID`、`CLONE_CHILD_SETTID` 和 `CLONE_CHILD_CLEARTID`
- en: The `CLONE_PARENT_SETTID`, `CLONE_CHILD_SETTID`, and `CLONE_CHILD_CLEARTID`
    flags were added in Linux 2.6 to support the implementation of POSIX threads.
    These flags affect how *clone()* treats its *ptid* and *ctid* arguments. `CLONE_PARENT_SETTID`
    and `CLONE_CHILD_CLEARTID` are used in the NPTL threading implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLONE_PARENT_SETTID`、`CLONE_CHILD_SETTID` 和 `CLONE_CHILD_CLEARTID` 标志是在 Linux
    2.6 中添加的，以支持 POSIX 线程的实现。这些标志影响 *clone()* 如何处理其 *ptid* 和 *ctid* 参数。`CLONE_PARENT_SETTID`
    和 `CLONE_CHILD_CLEARTID` 在 NPTL 线程实现中被使用。'
- en: If the `CLONE_PARENT_SETTID` flag is set, then the kernel writes the thread
    ID of the child thread into the location pointed to by *ptid*. The thread ID is
    copied into *ptid* before the memory of the parent is duplicated. This means that,
    even if the `CLONE_VM` flag is not specified, both the parent and the child can
    see the child’s thread ID in this location. (As noted above, the `CLONE_VM` flag
    is specified when creating POSIX threads.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_PARENT_SETTID` 标志，则内核会将子线程的线程 ID 写入 *ptid* 所指向的位置。在父线程的内存被复制之前，线程
    ID 会被复制到 *ptid* 中。这意味着，即使没有指定 `CLONE_VM` 标志，父线程和子线程都可以在该位置看到子线程的线程 ID。（如上所述，`CLONE_VM`
    标志是在创建 POSIX 线程时指定的。）
- en: 'The `CLONE_PARENT_SETTID` flag exists in order to provide a reliable means
    for a threading implementation to obtain the ID of the new thread. Note that it
    isn’t sufficient to obtain the thread ID of the new thread via the return value
    of *clone()*, like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLONE_PARENT_SETTID` 标志的存在是为了提供一个可靠的方式，使线程实现能够获得新线程的 ID。请注意，仅通过 *clone()*
    的返回值获取新线程的线程 ID 是不够的，如下所示：'
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem is that this code can lead to various race conditions, because the
    assignment occurs only after *clone()* returns. For example, suppose that the
    new thread terminates, and the handler for its termination signal is invoked before
    the assignment to *tid* completes. In this case, the handler can’t usefully access
    *tid*. (Within a threading library, *tid* might be an item in a global bookkeeping
    structure used to track the status of all threads.) Programs that invoke *clone()*
    directly often can be designed to work around this race condition. However, a
    threading library can’t control the actions of the program that calls it. Using
    `CLONE_PARENT_SETTID` to ensure that the new thread ID is placed in the location
    pointed to by *ptid* before *clone()* returns allows a threading library to avoid
    such race conditions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，这段代码可能导致各种竞态条件，因为赋值操作只发生在 *clone()* 返回之后。例如，假设新线程终止，并且其终止信号的处理程序在对 *tid*
    进行赋值之前被调用。在这种情况下，处理程序无法有意义地访问 *tid*。（在一个线程库中，*tid* 可能是一个全局书籍结构中的条目，用于跟踪所有线程的状态。）直接调用
    *clone()* 的程序通常可以设计成规避这种竞态条件。然而，线程库无法控制调用它的程序的行为。使用 `CLONE_PARENT_SETTID` 来确保在
    *clone()* 返回之前将新线程 ID 放入 *ptid* 所指向的位置，允许线程库避免这种竞态条件。
- en: If the `CLONE_CHILD_SETTID` flag is set, then *clone()* writes the thread ID
    of the child thread into the location pointed to by *ctid*. The setting of *ctid*
    is done only in the child’s memory, but this will affect the parent if `CLONE_VM`
    is also specified. Although NPTL doesn’t need `CLONE_CHILD_SETTID`, this flag
    is provided to allow flexibility for other possible threading library implementations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_CHILD_SETTID` 标志，则 *clone()* 会将子线程的线程 ID 写入 *ctid* 所指向的位置。*ctid*
    的设置仅在子线程的内存中进行，但如果同时指定了 `CLONE_VM`，这将影响父线程。尽管 NPTL 不需要 `CLONE_CHILD_SETTID`，但提供此标志是为了给其他可能的线程库实现提供灵活性。
- en: If the `CLONE_CHILD_CLEARTID` flag is set, then *clone()* zeros the memory location
    pointed to by *ctid* when the child terminates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`CLONE_CHILD_CLEARTID`标志，则*clone()*在子进程终止时会将*ctid*指向的内存位置清零。
- en: The *ctid* argument is the mechanism (described in a moment) by which the NPTL
    threading implementation obtains notification of the termination of a thread.
    Such notification is required by the *pthread_join()* function, which is the POSIX
    threads mechanism by which one thread can wait for the termination of another
    thread.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*ctid*参数是NPTL线程实现获取线程终止通知的机制（稍后描述）。这种通知是*pthread_join()*函数所必需的，*pthread_join()*是POSIX线程机制，允许一个线程等待另一个线程的终止。'
- en: When a thread is created using *pthread_create()*, NPTL makes a *clone()* call
    in which *ptid* and *ctid* point to the same location. (This is why `CLONE_CHILD_SETTID`
    is not required by NPTL.) The `CLONE_PARENT_SETTID` flag causes that location
    to be initialized with the new thread’s ID. When the child terminates and *ctid*
    is cleared, that change is visible to all threads in the process (since the `CLONE_VM`
    flag is also specified).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用*pthread_create()*创建线程时，NPTL会调用*clone()*，其中*ptid*和*ctid*指向相同的位置。（这就是为什么NPTL不需要`CLONE_CHILD_SETTID`的原因。）`CLONE_PARENT_SETTID`标志会使该位置初始化为新线程的ID。当子线程终止并且*ctid*被清除时，该变化对进程中的所有线程可见（因为同时指定了`CLONE_VM`标志）。
- en: The kernel treats the location pointed to by *ctid* as a *futex*, an efficient
    synchronization mechanism. (See the *futex(2)* manual page for further details
    of futexes.) Notification of thread termination can be obtained by performing
    a *futex()* system call that blocks waiting for a change in the value at the location
    pointed to by *ctid*. (Behind the scenes, this is what *pthread_join()* does.)
    At the same time that the kernel clears *ctid*, it also wakes up any kernel scheduling
    entity (i.e., thread) that is blocked performing a futex wait on that address.
    (At the POSIX threads level, this causes the *pthread_join()* call to unblock.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将*ctid*指向的位置视为*futex*，一种高效的同步机制。（有关futex的更多详细信息，请参阅*futex(2)*手册页面。）线程终止的通知可以通过执行一个*futex()*系统调用来获得，该调用会阻塞等待*ctid*指向的位置值发生变化。（在背后，这正是*pthread_join()*所做的。）当内核清除*ctid*时，它还会唤醒任何在该地址上执行futex等待的被阻塞内核调度实体（即线程）。（在POSIX线程级别，这会导致*pthread_join()*调用解除阻塞。）
- en: 'Thread-local storage: `CLONE_SETTLS`'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程局部存储：`CLONE_SETTLS`
- en: If the `CLONE_SETTLS` flag is set, then the *tls* argument points to a *user_desc*
    structure describing the thread-local storage buffer to be used for this thread.
    This flag was added in Linux 2.6 to support the NPTL implementation of thread-local
    storage ([Thread-Local Storage](ch31.html#thread-local_storage "Thread-Local Storage")).
    For details of the *user_desc* structure, see the definition and use of this structure
    in the 2.6 kernel sources and the *set_thread_area(2)* manual page.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`CLONE_SETTLS`标志，则*tls*参数指向一个*user_desc*结构，描述该线程将使用的线程局部存储缓冲区。这个标志在Linux
    2.6中加入，以支持NPTL实现的线程局部存储（[线程局部存储](ch31.html#thread-local_storage "线程局部存储")）。有关*user_desc*结构的详细信息，请参阅2.6内核源代码中该结构的定义和使用，以及*set_thread_area(2)*手册页面。
- en: 'Sharing System V semaphore undo values: `CLONE_SYSVSEM`'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享System V信号量撤销值：`CLONE_SYSVSEM`
- en: If the `CLONE_SYSVSEM` flag is set, then the parent and child share a single
    list of System V semaphore undo values ([Semaphore Undo Values](ch47.html#semaphore_undo_values
    "Semaphore Undo Values")). If this flag is not set, then the parent and child
    have separate undo lists, and the child’s undo list is initially empty.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`CLONE_SYSVSEM`标志，则父进程和子进程共享同一列表的System V信号量撤销值（[信号量撤销值](ch47.html#semaphore_undo_values
    "信号量撤销值")）。如果未设置此标志，则父进程和子进程拥有各自独立的撤销列表，子进程的撤销列表最初为空。
- en: The `CLONE_SYSVSEM` flag is available from kernel 2.6 onward, and provides the
    sharing semantics required by POSIX threads.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLONE_SYSVSEM`标志从内核2.6开始提供，并提供了POSIX线程所需的共享语义。'
- en: 'Per-process mount namespaces: `CLONE_NEWNS`'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个进程的挂载命名空间：`CLONE_NEWNS`
- en: From kernel 2.4.19 onward, Linux supports the notion of per-process *mount namespaces*.
    A mount namespace is the set of mount points maintained by calls to *mount()*
    and *umount()*. The mount namespace affects how pathnames are resolved to actual
    files, as well as the operation of system calls such as *chdir()* and *chroot()*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核2.4.19开始，Linux支持每个进程的*挂载命名空间*。挂载命名空间是通过*mount()*和*umount()*调用维护的挂载点集合。挂载命名空间影响路径名如何解析为实际文件，并且会影响诸如*chdir()*和*chroot()*等系统调用的操作。
- en: By default, the parent and the child share a mount namespace, which means that
    changes to the namespace by one process using *mount()* and *umount()* are visible
    in the other process (as with *fork()* and *vfork()*). A privileged (`CAP_SYS_ADMIN`)
    process may specify the `CLONE_NEWNS` flag so that the child obtains a copy of
    the parent’s mount namespace. Thereafter, changes to the namespace by one process
    are not visible in the other process. (In earlier 2.4.*x* kernels, as well as
    in older kernels, we can consider all processes on the system as sharing a single
    system-wide mount namespace.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，父进程和子进程共享一个挂载命名空间，这意味着一个进程通过*mount()*和*umount()*修改命名空间的更改对另一个进程可见（与*fork()*和*vfork()*类似）。具有特权的（`CAP_SYS_ADMIN`）进程可以指定`CLONE_NEWNS`标志，使得子进程获得父进程挂载命名空间的副本。此后，一个进程对命名空间的更改在另一个进程中不可见。（在早期的2.4.*x*内核以及更旧的内核中，我们可以认为系统上的所有进程共享一个全局的挂载命名空间。）
- en: Per-process mount namespaces can be used to create environments that are similar
    to *chroot()* jails, but which are more secure and flexible; for example, a jailed
    process can be provided with a mount point that is not visible to other processes
    on the system. Mount namespaces are also useful in setting up virtual server environments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程的挂载命名空间可用于创建类似于*chroot()*监狱的环境，但更加安全和灵活；例如，可以为被监禁的进程提供一个在系统上其他进程不可见的挂载点。挂载命名空间在设置虚拟服务器环境时也非常有用。
- en: Specifying both `CLONE_NEWNS` and `CLONE_FS` in the same call to *clone()* is
    nonsensical and is not permitted.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一次*clone()*调用中同时指定`CLONE_NEWNS`和`CLONE_FS`是没有意义的，且不被允许。
- en: 'Making the child’s parent the same as the caller’s: `CLONE_PARENT`'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将子进程的父进程设置为与调用者相同：`CLONE_PARENT`
- en: By default, when we create a new process with *clone()*, the parent of that
    process (as returned by *getppid()*) is the process that calls *clone()* (as with
    *fork()* and *vfork()*). If the `CLONE_PARENT` flag is set, then the parent of
    the child will be the caller’s parent. In other words, `CLONE_PARENT` is the equivalent
    of setting *child.PPID = caller.PPID*. (In the default case, without `CLONE_PARENT`,
    it would be *child.PPID = caller.PID*.) The parent process (*child.PPID*) is the
    process that is signaled when the child terminates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们使用*clone()*创建一个新进程时，该进程的父进程（通过*getppid()*返回的父进程）是调用*clone()*的进程（与*fork()*和*vfork()*类似）。如果设置了`CLONE_PARENT`标志，则子进程的父进程将是调用者的父进程。换句话说，`CLONE_PARENT`相当于设置*child.PPID
    = caller.PPID*。（在默认情况下，如果没有`CLONE_PARENT`，则会是*child.PPID = caller.PID*。）父进程（*child.PPID*）是子进程终止时收到信号的进程。
- en: The `CLONE_PARENT` flag is available in Linux 2.4 and later. Originally, it
    was designed to be useful for POSIX threads implementations, but the 2.6 kernel
    pursued an approach to supporting threads (the use of `CLONE_THREAD`, described
    above) that removed the need for this flag.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLONE_PARENT`标志在Linux 2.4及更高版本中可用。最初，它旨在用于POSIX线程实现，但2.6内核采用了支持线程的方式（使用`CLONE_THREAD`，如上所述），因此不再需要此标志。'
- en: 'Making the child’s PID the same as the parent’s PID: `CLONE_PID` (obsolete)'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将子进程的PID设置为与父进程相同：`CLONE_PID`（已废弃）
- en: If the `CLONE_PID` flag is set, then the child has the same process ID as the
    parent. If this flag is not set, then the parent and child have different process
    IDs (as with *fork()* and *vfork()*). Only the system boot process (process ID
    0) may specify this flag; it is used when initializing a multiprocessor system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`CLONE_PID`标志，则子进程与父进程具有相同的进程ID。如果没有设置该标志，则父进程和子进程拥有不同的进程ID（与*fork()*和*vfork()*类似）。只有系统启动进程（进程ID为0）可以指定此标志；它用于初始化多处理器系统时。
- en: The `CLONE_PID` flag is not intended for use in user applications. In Linux
    2.6, it has been removed, and is superseded by `CLONE_IDLETASK`, which causes
    the process ID of the new process to be set to 0\. `CLONE_IDLETASK` is available
    only for internal use within the kernel (if specified in the *flags* argument
    of *clone()*, it is ignored). It is used to create the invisible per-CPU *idle
    process*, of which multiple instances may exist on multiprocessor systems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLONE_PID`标志不应在用户应用程序中使用。在Linux 2.6中，它已被移除，并由`CLONE_IDLETASK`取代，后者会将新进程的进程ID设置为0。`CLONE_IDLETASK`仅供内核内部使用（如果在*clone()*的*flags*参数中指定，它会被忽略）。它用于创建不可见的每CPU*空闲进程*，在多处理器系统上可能会存在多个实例。'
- en: 'Process tracing: `CLONE_PTRACE` and `CLONE_UNTRACED`'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程跟踪：`CLONE_PTRACE`和`CLONE_UNTRACED`
- en: If the `CLONE_PTRACE` flag is set and the calling process is being traced, then
    the child is also traced. For details on process tracing (used by debuggers and
    the *strace* command), refer to the *ptrace(2)* manual page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_PTRACE` 标志并且调用进程正在被追踪，则子进程也会被追踪。有关进程追踪的详细信息（调试器和 *strace* 命令使用的功能），请参阅
    *ptrace(2)* 手册页。
- en: From kernel 2.6 onward, the `CLONE_UNTRACED` flag can be set, meaning that a
    tracing process can’t force `CLONE_PTRACE` on this child. The `CLONE_UNTRACED`
    flag is used internally by the kernel in the creation of kernel threads.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6 开始，可以设置 `CLONE_UNTRACED` 标志，这意味着追踪进程无法强制对子进程使用 `CLONE_PTRACE`。`CLONE_UNTRACED`
    标志由内核在创建内核线程时内部使用。
- en: 'Suspending the parent until the child exits or execs: `CLONE_VFORK`'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在子进程退出或执行时挂起父进程：`CLONE_VFORK`
- en: If the `CLONE_VFORK` flag is set, then the execution of the parent is suspended
    until the child releases its virtual memory resources via a call to *exec()* or
    _*exit()* (as with *vfork()*).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `CLONE_VFORK` 标志，则父进程的执行会被挂起，直到子进程通过调用 *exec()* 或 _*exit()*（如同 *vfork()*
    的行为）释放其虚拟内存资源。
- en: New *clone()* flags to support containers
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的 *clone()* 标志以支持容器
- en: 'A number of new *clone() flags* values were added in Linux 2.6.19 and later:
    `CLONE_IO`, `CLONE_NEWIPC`, `CLONE_NEWNET`, `CLONE_NEWPID`, `CLONE_NEWUSER`, and
    `CLONE_NEWUTS`. (See the *clone(2)* manual page for the details of these flags.)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.6.19 及更高版本中，添加了多个新的 *clone() flags* 值：`CLONE_IO`，`CLONE_NEWIPC`，`CLONE_NEWNET`，`CLONE_NEWPID`，`CLONE_NEWUSER`
    和 `CLONE_NEWUTS`。（有关这些标志的详细信息，请参阅 *clone(2)* 手册页。）
- en: Most of these flags are provided to support the implementation of *containers*
    ([Bhattiprolu et al., 2008]). A container is a form of lightweight virtualization,
    whereby groups of processes running on the same kernel can be isolated from one
    another in environments that appear to be separate machines. Containers can also
    be nested, one inside the other. The containers approach contrasts with full virtualization,
    where each virtualized environment is running a distinct kernel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志大多是为了支持 *容器* 的实现（[Bhattiprolu 等，2008]）。容器是一种轻量级虚拟化形式，通过该形式在同一内核上运行的进程组可以在看似独立的环境中彼此隔离。容器也可以是嵌套的，一个容器可以包含另一个容器。这种容器方法与完全虚拟化形成对比，后者是每个虚拟化环境都在运行一个独立的内核。
- en: To implement containers, the kernel developers had to provide a layer of indirection
    within the kernel around each of the global system resources—such as process IDs,
    the networking stack, the identifiers returned by *uname()*, System V IPC objects,
    and user and group ID namespaces—so that each container can provide its own instance
    of these resources.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现容器，内核开发者必须在内核中提供一层间接机制，围绕每个全局系统资源——例如进程 ID、网络栈、*uname()* 返回的标识符、System V
    IPC 对象，以及用户和组 ID 命名空间——以便每个容器能够提供这些资源的独立实例。
- en: 'There are various possible uses for containers, including the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 容器有多种可能的用途，包括以下内容：
- en: controlling allocation of resources on the system, such as network bandwidth
    or CPU time (e.g., one container might be granted 75% of the CPU time, while the
    other gets 25%);
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制系统资源的分配，例如网络带宽或 CPU 时间（例如，一个容器可能被分配 75% 的 CPU 时间，而另一个容器分配 25%）；
- en: providing multiple lightweight virtual servers on a single host machine;
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单台主机上提供多个轻量级虚拟服务器；
- en: freezing a container, so that execution of all processes in the container is
    suspended, later to be restarted, possibly after migrating to a different machine;
    and
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冻结一个容器，使容器中所有进程的执行暂停，稍后再重启，可能是在迁移到另一台机器后；
- en: allowing an application’s state to be dumped (checkpointed) and then later restored
    (perhaps after an application crash, or a planned or unplanned system shutdown)
    to continue computation from the time of the checkpoint.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将应用程序的状态转储（检查点）并随后恢复（可能是在应用程序崩溃后，或系统计划或非计划关闭后），以便从检查点的时间继续计算。
- en: Use of *clone() flags*
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 *clone() flags*
- en: 'Roughly, we can say that a *fork()* corresponds to a *clone()* call with *flags*
    specified as just `SIGCHLD`, while a *vfork()* corresponds to a *clone()* call
    specifying *flags* as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上，我们可以说，*fork()* 相当于指定 `SIGCHLD` 标志的 *clone()* 调用，而 *vfork()* 相当于指定以下标志的 *clone()*
    调用：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since version 2.3.3, the *glibc* wrapper *fork()* provided as part of the NPTL
    threading implementation bypasses the kernel’s *fork()* system call and invokes
    *clone()*. This wrapper function invokes any fork handlers that have been established
    by the caller using *pthread_atfork()* (see [Threads and Process Control](ch33.html#threads_and_process_control
    "Threads and Process Control")).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.3.3 开始，NPTL 线程实现提供的 *glibc* 包装器 *fork()* 会绕过内核的 *fork()* 系统调用并调用 *clone()*。该包装器函数会调用任何通过
    *pthread_atfork()* 设置的 fork 处理程序（请参见 [线程与进程控制](ch33.html#threads_and_process_control
    "线程与进程控制")）。
- en: 'The LinuxThreads threading implementation uses *clone()* (with just the first
    four arguments) to create threads by specifying *flags* as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: LinuxThreads 线程实现通过指定以下 *flags* 来使用 *clone()*（仅使用前四个参数）创建线程：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The NPTL threading implementation uses *clone()* (with all seven arguments)
    to create threads by specifying *flags* as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: NPTL 线程实现通过指定以下 *flags* 来使用 *clone()*（包括所有七个参数）创建线程：
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Extensions to *waitpid()* for Cloned Children
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*waitpid()* 对克隆子进程的扩展'
- en: 'To wait for children produced by *clone()*, the following additional (Linux-specific)
    values can be included in the *options* bit-mask argument for *waitpid()*, *wait3()*,
    and *wait4()*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待由 *clone()* 产生的子进程，可以在 *waitpid()*、*wait3()* 和 *wait4()* 的 *options* 位掩码参数中包含以下额外的（特定于
    Linux 的）值：
- en: '`__WCLONE`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`__WCLONE`'
- en: If set, then wait for *clone* children only. If not set, then wait for *nonclone*
    children only. In this context, a *clone* child is one that delivers a signal
    other than `SIGCHLD` to its parent on termination. This bit is ignored if `__WALL`
    is also specified.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置，则仅等待 *clone* 子进程。如果未设置，则仅等待 *nonclone* 子进程。在这种情况下，*clone* 子进程是在终止时向其父进程发送除
    `SIGCHLD` 之外的信号。如果同时指定了 `__WALL`，则忽略此位。
- en: '`__WALL` (since Linux 2.4)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`__WALL`（自 Linux 2.4 起）'
- en: Wait for all children, regardless of type (*clone* or *nonclone*).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 等待所有子进程，无论类型是（*clone* 还是 *nonclone*）。
- en: '`__WNOTHREAD` (since Linux 2.4)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`__WNOTHREAD`（自 Linux 2.4 起）'
- en: By default, the wait calls wait not only for children of the calling process,
    but also for children of any other processes in the same thread group as the caller.
    Specifying the `__WNOTHREAD` flag limits the wait to children of the calling process.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，wait 调用不仅会等待调用进程的子进程，还会等待与调用者位于同一线程组中的任何其他进程的子进程。指定 `__WNOTHREAD` 标志会限制等待仅限于调用进程的子进程。
- en: These flags can’t be used with *waitid()*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志不能与 *waitid()* 一起使用。
- en: Speed of Process Creation
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程创建速度
- en: '[Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr "Table 28-3. Time
    required to create 100,000 processes using fork(), vfork(), and clone()") shows
    some speed comparisons for different methods of process creation. The results
    were obtained using a test program that executed a loop that repeatedly created
    a child process and then waited for it to terminate. The table compares the various
    methods using three different process memory sizes, as indicated by the *Total
    virtual memory* value. The differences in memory size were simulated by having
    the program *malloc()* additional memory on the heap prior to performing the timings.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 28-3](ch28.html#time_required_to_create_100_comma_000_pr "表 28-3。使用 fork()、vfork()
    和 clone() 创建 100,000 个进程所需的时间") 显示了不同进程创建方法的速度比较。结果是通过测试程序获得的，该程序执行一个循环，循环中不断创建子进程并等待其终止。该表比较了使用三种不同进程内存大小的方法，如
    *总虚拟内存* 值所示。内存大小的差异通过在执行计时之前让程序通过 *malloc()* 在堆上分配额外内存来模拟。'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Values for process size (*Total virtual memory*) in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()") are taken from the *VSZ* value displayed by the command *ps -o “pid
    vsz cmd”*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表 28-3 中的进程大小（*总虚拟内存*）值来自命令 *ps -o “pid vsz cmd”* 显示的 *VSZ* 值。
- en: Table 28-3. Time required to create 100,000 processes using *fork()*, *vfork()*,
    and *clone()*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 表 28-3。使用 *fork()*、*vfork()* 和 *clone()* 创建 100,000 个进程所需的时间
- en: '| Method of process creation | Total Virtual Memory |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 进程创建方法 | 总虚拟内存 |'
- en: '| --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1.70 MB | 2.70 MB | 11.70 MB |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 1.70 MB | 2.70 MB | 11.70 MB |'
- en: '| --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Time (secs) | Rate | Time (secs) | Rate | Time (secs) | Rate |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 时间（秒） | 速率 | 时间（秒） | 速率 | 时间（秒） | 速率 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *fork()* | `22.27 (7.99)` | `4544` | `26.38 (8.98)` | `4135` | `126.93(52.55)`
    | `1276` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| *fork()* | `22.27 (7.99)` | `4544` | `26.38 (8.98)` | `4135` | `126.93(52.55)`
    | `1276` |'
- en: '| *vfork()* | `3.52 (2.49)` | `28955` | `3.55 (2.50)` | `28621` | `3.53 (2.51)`
    | `28810` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| *vfork()* | `3.52 (2.49)` | `28955` | `3.55 (2.50)` | `28621` | `3.53 (2.51)`
    | `28810` |'
- en: '| *clone()* | `2.97 (2.14)` | `34333` | `2.98 (2.13)` | `34217` | `2.93 (2.10)`
    | `34688` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| *clone()* | `2.97 (2.14)` | `34333` | `2.98 (2.13)` | `34217` | `2.93 (2.10)`
    | `34688` |'
- en: '| *fork() + exec()* | `135.72(12.39)` | `764` | `146.15(16.69)` | `719` | `260.34(61.86)`
    | `435` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| *fork() + exec()* | `135.72(12.39)` | `764` | `146.15(16.69)` | `719` | `260.34(61.86)`
    | `435` |'
- en: '| *vfork() + exec()* | `107.36 (6.27)` | `969` | `107.81 (6.35)` | `964` |
    `107.97 (6.38)` | `960` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| *vfork() + exec()* | `107.36 (6.27)` | `969` | `107.81 (6.35)` | `964` |
    `107.97 (6.38)` | `960` |'
- en: 'For each process size, two types of statistics are provided in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()"):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种进程大小，[表28-3](ch28.html#time_required_to_create_100_comma_000_pr "表28-3：使用fork()、vfork()和clone()创建100,000个进程所需的时间")提供了两种类型的统计数据：
- en: The first statistic consists of two time measurements. The main (larger) measurement
    is the total elapsed (real) time to perform 100,000 process creation operations.
    The second time, shown in parentheses, is the CPU time consumed by the parent
    process. Since these tests were run on an otherwise unloaded machine, the difference
    between the two time values represents the total time consumed by child processes
    created during the test.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个统计数据由两个时间度量组成。主要（较大）的度量是执行100,000个进程创建操作所消耗的总（实际）时间。第二个时间，显示在括号中，是父进程所消耗的CPU时间。由于这些测试是在未负载的机器上运行的，因此这两个时间值之间的差异表示测试过程中由子进程创建所消耗的总时间。
- en: The second statistic for each test shows the rate at which processes were created
    per (real) second.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试的第二个统计数据表示每（实际）秒钟创建进程的速率。
- en: Statistics shown are the average of 20 runs for each case, and were obtained
    using kernel 2.6.27 running on an x86-32 system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的统计数据是每种情况20次运行的平均值，并使用运行在x86-32系统上的内核2.6.27获得。
- en: The first three data rows show times for simple process creation (without execing
    a new program in the child). In each case, the child processes exit immediately
    after they are created, and the parent waits for each child to terminate before
    creating the next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行数据显示了简单进程创建的时间（不在子进程中执行新程序）。在每种情况下，子进程在创建后立即退出，父进程在创建下一个进程之前等待每个子进程终止。
- en: The first row contains values for the *fork()* system call. From the data, we
    can see that as a process gets larger, *fork()* takes longer. These time differences
    show the additional time required to duplicate increasingly large page tables
    for the child and mark all data, heap, and stack segment page entries as read-only.
    (No *pages* are copied, since the child doesn’t modify its data or stack segments.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含*fork()*系统调用的值。从数据中可以看出，随着进程变大，*fork()*的时间变长。这些时间差异表明，为子进程复制日益庞大的页表并将所有数据、堆和栈段的页面条目标记为只读所需要的额外时间。（没有复制*页*，因为子进程不会修改其数据或栈段。）
- en: The second data row provides the same statistics for *vfork()*. We see that
    as the process size increases, the times remain the same—because no page tables
    or pages are copied during a *vfork()*, the virtual memory size of the calling
    process has no effect. The difference between the *fork()* and *vfork()* statistics
    represents the total time required for copying process page tables in each case.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行提供了*vfork()*的相同统计数据。我们看到，随着进程大小的增加，时间保持不变——因为在*vfork()*中没有复制页表或页面，调用进程的虚拟内存大小没有影响。*fork()*和*vfork()*统计数据之间的差异表示复制进程页表所需的总时间。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Small variations in the *vfork()* and *clone()* values in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()") are due to sampling errors and scheduling variations. Even when
    creating processes up to 300 MB in size, times for these two system calls remained
    constant.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表28-3](ch28.html#time_required_to_create_100_comma_000_pr "表28-3：使用fork()、vfork()和clone()创建100,000个进程所需的时间")中，*vfork()*和*clone()*值的微小变化是由于采样误差和调度变化引起的。即使在创建最大达300
    MB的进程时，这两个系统调用的时间仍然保持不变。
- en: 'The third data row shows statistics for process creation using *clone()* with
    the following flags:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行数据显示了使用*clone()*系统调用并带有以下标志的进程创建统计数据：
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first two of these flags emulate the behavior of *vfork()*. The remaining
    flags specify that the parent and child should share their file-system attributes
    (umask, root directory, and current working directory), table of signal dispositions,
    and table of open file descriptors. The difference between the *clone()* and *vfork()*
    data represents the small amount of additional work performed in *vfork()* to
    copy this information into the child process. The cost of copying file-system
    attributes and the table of signal dispositions is constant. However, the cost
    of copying the table of open file descriptors varies according to the number of
    descriptors. For example, opening 100 file descriptors in the parent process raised
    the *vfork()* real time (in the first column of the table) from 3.52 to 5.04 seconds,
    but left times for *clone()* unaffected.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个标志模拟了*vfork()*的行为。其余的标志指定父进程和子进程应该共享文件系统属性（umask、根目录和当前工作目录）、信号处理表以及打开文件描述符表。*clone()*和*vfork()*数据之间的差异代表了在*vfork()*中为将这些信息复制到子进程所做的额外工作。复制文件系统属性和信号处理表的成本是恒定的。然而，复制打开文件描述符表的成本会根据描述符的数量而变化。例如，在父进程中打开100个文件描述符，使得*vfork()*的实际时间（表格中的第一列）从3.52秒增加到5.04秒，但对*clone()*的时间没有影响。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The timings for *clone()* are for the *glibc clone()* wrapper function, rather
    than direct calls to *sys_clone()*. Other tests (not summarized here) revealed
    negligible timing differences between using *sys_clone()* and calling *clone()*
    with a child function that immediately exited.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*clone()*的时间是针对*glibc clone()*包装函数，而不是直接调用*sys_clone()*的时间。其他测试（这里未总结）揭示了使用*sys_clone()*和调用*clone()*与立即退出的子函数之间的时间差异几乎可以忽略不计。'
- en: 'The differences between *fork()* and *vfork()* are quite marked. However, the
    following points should be kept in mind:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*fork()*和*vfork()*之间的差异相当明显。然而，应该记住以下几点：'
- en: The final data column, where *vfork()* is more than 30 times faster than *fork()*,
    corresponds to a large process. Typical processes would lie somewhere closer to
    the first two columns of the table.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一列数据，其中*vfork()*比*fork()*快30倍以上，代表了一个大型进程。典型的进程通常会接近表格前两列的情况。
- en: Because the times required for process creation are typically much smaller than
    those required for an *exec()*, the differences are much less marked if a *fork()*
    or *vfork()* is followed by an *exec()*. This is illustrated by the final pair
    of data rows in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()"), where each child performs an *exec()*, rather than immediately
    exiting. The program execed was the *true* command (`/bin/true`, chosen because
    it produces no output). In this case, we see that the relative differences between
    *fork()* and *vfork()* are much lower.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为进程创建所需的时间通常远小于*exec()*所需的时间，所以如果*fork()*或*vfork()*之后跟着*exec()*，它们之间的差异就不那么明显了。这在[表28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "表28-3。使用fork()、vfork()和clone()创建100,000个进程所需的时间")的最后一组数据行中有所说明，其中每个子进程都会执行*exec()*，而不是立即退出。执行的程序是*true*命令（`/bin/true`，选择它是因为它不会产生任何输出）。在这种情况下，我们可以看到*fork()*和*vfork()*之间的相对差异要低得多。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In fact, the data shown in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()") doesn’t reveal the full cost of an *exec()*, because the child execs
    the same program in each loop of the test. As a result, the cost of disk I/O to
    read the program into memory is essentially eliminated, because the program will
    be read into the kernel buffer cache on the first *exec()*, and then remain there.
    If each loop of the test execed a different program (e.g., a differently named
    copy of the same program), then we would observe a greater cost for an *exec()*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，[表28-3](ch28.html#time_required_to_create_100_comma_000_pr "表28-3。使用fork()、vfork()和clone()创建100,000个进程所需的时间")中显示的数据并没有揭示出*exec()*的全部成本，因为在每次测试循环中，子进程都会执行相同的程序。因此，读取程序到内存的磁盘I/O成本实际上被消除了，因为程序在第一次*exec()*时会被读入内核缓冲区缓存，并保持在那里。如果每次测试循环执行不同的程序（例如，同一程序的不同命名副本），我们将会观察到*exec()*的成本会更高。
- en: Effect of *exec()* and *fork()* on Process Attributes
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*exec()*和*fork()*对进程属性的影响'
- en: 'A process has numerous attributes, some of which we have already described
    in earlier chapters, and others that we explore in later chapters. Regarding these
    attributes, two questions arise:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程有许多属性，其中一些我们已经在前面的章节中描述，其他则在后续章节中讨论。关于这些属性，有两个问题：
- en: What happens to these attributes when a process performs an *exec()*?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 *exec()* 时这些属性会发生什么变化？
- en: Which attributes are inherited by a child when a *fork()* is performed?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些属性在执行 *fork()* 时会被子进程继承？
- en: '[Table 28-4](ch28.html#effect_of_exec_open_parenthesis_clos "Table 28-4. Effect
    of exec() and fork() on process attributes") summarizes the answers to these questions.
    The *exec()* column indicates which attributes are preserved during an *exec()*.
    The *fork()* column indicates which attributes are inherited (or in some cases,
    shared) by a child after *fork()*. Other than the attributes indicated as being
    Linux-specific, all listed attributes appear in standard UNIX implementations,
    and their handling during *exec()* and *fork()* conforms to the requirements of
    SUSv3.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 28-4](ch28.html#effect_of_exec_open_parenthesis_clos "表 28-4. exec() 和 fork()
    对进程属性的影响") 总结了这些问题的答案。*exec()* 列表示在 *exec()* 中哪些属性被保留。*fork()* 列表示子进程在 *fork()*
    后继承（或在某些情况下共享）哪些属性。除非标记为 Linux 特有的属性，否则所有列出的属性都出现在标准 UNIX 实现中，它们在 *exec()* 和 *fork()*
    中的处理符合 SUSv3 的要求。 |'
- en: Table 28-4. Effect of *exec()* and *fork()* on process attributes
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 表 28-4. *exec()* 和 *fork()* 对进程属性的影响
- en: '| Process attribute | *exec()* | *fork()* | Interfaces affecting attribute;
    additional notes |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 进程属性 | *exec()* | *fork()* | 影响属性的接口；附加注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Process address space |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 进程地址空间 |'
- en: '| --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Text segment | No | Shared | Child process shares text segment with parent.
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 文本段 | 否 | 共享 | 子进程与父进程共享文本段。 |'
- en: '| Stack segment | No | Yes | Function entry/exit; *alloca()*, *longjmp()*,
    *siglongjmp()*. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 栈段 | 否 | 是 | 函数进入/退出；*alloca()*, *longjmp()*, *siglongjmp()*。 |'
- en: '| Data and heap segments | No | Yes | *brk()*, *sbrk()*. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 数据和堆段 | 否 | 是 | *brk()*, *sbrk()*。 |'
- en: '| Environment variables | Seenotes | Yes | *putenv()*, *setenv()*; direct modification
    of *environ*. Overwritten by *execle()* and *execve()* and preserved by remaining
    *exec()* calls. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 环境变量 | 见注释 | 是 | *putenv()*, *setenv()*; 直接修改 *environ*。被 *execle()* 和 *execve()*
    覆盖，其他 *exec()* 调用保留。 |'
- en: '| Memory mappings | No | Yes; see notes | *mmap()*, *munmap()*. A mapping’s
    `MAP_NORESERVE` flag is inherited across *fork()*. Mappings that have been marked
    with madvise(*MADV_DONTFORK*) are not inherited across *fork()*. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 内存映射 | 否 | 是；见注释 | *mmap()*, *munmap()*。一个映射的 `MAP_NORESERVE` 标志会在 *fork()*
    时被继承。已标记为 madvise(*MADV_DONTFORK*) 的映射不会在 *fork()* 时继承。 |'
- en: '| Memory locks | No | No | *mlock()*, *munlock()*. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 内存锁定 | 否 | 否 | *mlock()*, *munlock()*。 |'
- en: '| Process identifiers and credentials |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 进程标识符和凭证 |'
- en: '| --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Process ID | Yes | No |   |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 进程 ID | 是 | 否 |   |'
- en: '| Parent process ID | Yes | No |   |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 父进程 ID | 是 | 否 |   |'
- en: '| Process group ID | Yes | Yes | *setpgid()*. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 进程组 ID | 是 | 是 | *setpgid()*。 |'
- en: '| Session ID | Yes | Yes | *setsid()*. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 会话 ID | 是 | 是 | *setsid()*。 |'
- en: '| Real IDs | Yes | Yes | *setuid()*, *setgid()*, and related calls. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 实际 ID | 是 | 是 | *setuid()*, *setgid()*, 和相关调用。 |'
- en: '| Effective and saved set IDs | Seenotes | Yes | *setuid()*, *setgid()*, and
    related calls. [Chapter 9](ch09.html "Chapter 9. Process Credentials") explains
    how *exec()* affects these IDs. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 有效和保存的设置 ID | 见注释 | 是 | *setuid()*, *setgid()*, 和相关调用。[第 9 章](ch09.html "第
    9 章. 进程凭证") 解释了 *exec()* 如何影响这些 ID。 |'
- en: '| Supplementary group IDs | Yes | Yes | *setgroups()*, *initgroups()*. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 补充组 ID | 是 | 是 | *setgroups()*, *initgroups()*。 |'
- en: '| Files, file I/O, and directories |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 文件、文件 I/O 和目录 |'
- en: '| --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Open file descriptors | Seenotes | Yes | *open()*, *close()*, *dup()*, *pipe()*,
    *socket()*, and so on. File descriptors are preserved across *exec()* unless marked
    close-on-exec. Descriptors in child and parent refer to same open file descriptions;
    see Section 5.4. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 打开文件描述符 | 见注释 | 是 | *open()*, *close()*, *dup()*, *pipe()*, *socket()* 等。文件描述符在
    *exec()* 过程中会被保留，除非被标记为关闭执行时关闭。子进程和父进程的描述符指向相同的打开文件描述；详见第 5.4 节。 |'
- en: '| Close-on-exec flag | Yes (if off) | Yes | *fcntl(F_SETFD)*. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 执行时关闭标志 | 是（如果关闭） | 是 | *fcntl(F_SETFD)*。 |'
- en: '| File offsets | Yes | Shared | *lseek()*, *read()*, *write()*, *readv()*,
    *writev()*. Child shares file offsets with parent. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 文件偏移量 | 是 | 共享 | *lseek()*, *read()*, *write()*, *readv()*, *writev()*。子进程与父进程共享文件偏移量。
    |'
- en: '| Open file status flags | Yes | Shared | *open(), fcntl(F_SETFL)*. Child shares
    open file status flags with parent. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 打开文件状态标志 | 是 | 共享 | *open(), fcntl(F_SETFL)*。子进程与父进程共享打开文件状态标志。 |'
- en: '| Asynchronous I/O operations | Seenotes | No | *aio_read()*, *aio_write()*,
    and related calls. Outstanding operations are canceled during an *exec()*. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 异步 I/O 操作 | 见注释 | 否 | *aio_read()*，*aio_write()* 及相关调用。未完成的操作在 *exec()* 时会被取消。
    |'
- en: '| Directory streams | No | Yes; see notes | *opendir()*, *readdir()*. SUSv3
    states that child gets a copy of parent’s directory streams, but these copies
    may or may not share the directory stream position. On Linux, the directory stream
    position is not shared. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 目录流 | 否 | 是；见注释 | *opendir()*，*readdir()*。SUSv3 表示子进程获得父进程的目录流副本，但这些副本可能共享或不共享目录流位置。在
    Linux 中，目录流位置不会共享。 |'
- en: '| File system |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 |'
- en: '| --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Current working directory | Yes | Yes | *chdir()*. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 当前工作目录 | 是 | 是 | *chdir()*。 |'
- en: '| Root directory | Yes | Yes | *chroot()*. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 根目录 | 是 | 是 | *chroot()*。 |'
- en: '| File mode creation mask | Yes | Yes | *umask()*. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 文件模式创建掩码 | 是 | 是 | *umask()*。 |'
- en: '| Signals |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 信号 |'
- en: '| --- |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Signal dispositions | See notes | Yes | *signal()*, *sigaction()*. During
    an *exec()*, signals with dispositions set to default or ignore are unchanged;
    caught signals revert to their default dispositions. See Section 27.5. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 信号处理 | 见注释 | 是 | *signal()*，*sigaction()*。在 *exec()* 时，信号的默认处理或忽略处理不会改变；捕获的信号会恢复为其默认处理。见第
    27.5 节。 |'
- en: '| Signal mask | Yes | Yes | Signal delivery, *sigprocmask()*, *sigaction()*.
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 信号屏蔽 | 是 | 是 | 信号传递，*sigprocmask()*，*sigaction()*。 |'
- en: '| Pending signal set | Yes | No | Signal delivery; *raise()*, *kill()*, *sigqueue()*.
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 待处理信号集 | 是 | 否 | 信号传递；*raise()*，*kill()*，*sigqueue()*。 |'
- en: '| Alternate signal stack | No | Yes | *sigaltstack()*. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 替代信号栈 | 否 | 是 | *sigaltstack()*。 |'
- en: '| Timers |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 定时器 |'
- en: '| --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Interval timers | Yes | No | *setitimer()*. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 间隔定时器 | 是 | 否 | *setitimer()*。 |'
- en: '| Timers set by *alarm()* | Yes | No | *alarm()*. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 由 *alarm()* 设置的定时器 | 是 | 否 | *alarm()*。 |'
- en: '| POSIX timers | No | No | *timer_create()* and related calls. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 定时器 | 否 | 否 | *timer_create()* 及相关调用。 |'
- en: '| POSIX threads |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 线程 |'
- en: '| --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Threads | No | See notes | During *fork()*, only calling thread is replicated
    in child. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 线程 | 否 | 见注释 | 在 *fork()* 时，只有调用线程会在子进程中复制。 |'
- en: '| Thread cancelability state and type | No | Yes | After an *exec()*, the cancelability
    type and state are reset to `PTHREAD_CANCEL_ENABLE` and `PTHREAD_CANCEL_DEFERRED`,
    respectively |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 线程可取消状态和类型 | 否 | 是 | 在 *exec()* 后，取消类型和状态被重置为 `PTHREAD_CANCEL_ENABLE` 和 `PTHREAD_CANCEL_DEFERRED`，分别。
    |'
- en: '| Mutexes and condition variables | No | Yes | See [Threads and Process Control](ch33.html#threads_and_process_control
    "Threads and Process Control") for details of the treatment of mutexes and other
    thread resources during *fork()*. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 互斥锁和条件变量 | 否 | 是 | 详见 [线程与进程控制](ch33.html#threads_and_process_control "线程与进程控制")，了解在
    *fork()* 时互斥锁和其他线程资源的处理。 |'
- en: '| Priority and scheduling |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 优先级和调度 |'
- en: '| --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Nice value | Yes | Yes | *nice()*, *setpriority()*. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 优先级值 | 是 | 是 | *nice()*，*setpriority()*。 |'
- en: '| Scheduling policy and priority | Yes | Yes | *sched_setscheduler()*, *sched_setparam()*.
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 调度策略和优先级 | 是 | 是 | *sched_setscheduler()*，*sched_setparam()*。 |'
- en: '| Resources and CPU time |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 资源与 CPU 时间 |'
- en: '| --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Resource limits | Yes | Yes | *setrlimit()*. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 资源限制 | 是 | 是 | *setrlimit()*。 |'
- en: '| Process and child CPU times | Yes | No | As returned by *times()*. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 进程和子进程 CPU 时间 | 是 | 否 | 如 *times()* 所返回的。 |'
- en: '| Resource usages | Yes | No | As returned by *getrusage()*. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 资源使用情况 | 是 | 否 | 如 *getrusage()* 所返回的。 |'
- en: '| Interprocess communication |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 进程间通信 |'
- en: '| --- |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| System V shared memory segments | No | Yes | *shmat()*, *shmdt()*. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| System V 共享内存段 | 否 | 是 | *shmat()*，*shmdt()*。 |'
- en: '| POSIX shared memory | No | Yes | *shm_open()* and related calls. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 共享内存 | 否 | 是 | *shm_open()* 及相关调用。 |'
- en: '| POSIX message queues | No | Yes | *mq_open()* and related calls. Descriptors
    in child and parent refer to same open message queue descriptions. A child doesn’t
    inherit its parent’s message notification registrations. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 消息队列 | 否 | 是 | *mq_open()* 及相关调用。子进程和父进程中的描述符引用相同的已打开消息队列描述符。子进程不会继承父进程的消息通知注册。
    |'
- en: '| POSIX named semaphores | No | Shared | *sem_open()* and related calls. Child
    shares references to same semaphores as parent. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 命名信号量 | 否 | 共享 | *sem_open()* 及相关调用。子进程共享与父进程相同的信号量引用。 |'
- en: '| POSIX unnamed semaphores | No | See notes | *sem_init()* and related calls.
    If semaphores are in a shared memory region, then child shares semaphores with
    parent; otherwise, child has its own copy of the semaphores. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 无名信号量 | 否 | 见注释 | *sem_init()* 及相关调用。如果信号量位于共享内存区域，则子进程与父进程共享信号量；否则，子进程有自己的一份信号量副本。
    |'
- en: '| System V semaphore adjustments | Yes | No | *semop()*. See Section 47.8.
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| System V 信号量调整 | 是 | 否 | *semop()*。参见第47.8节。 |'
- en: '| File locks | Yes | See notes | *flock()*. Child inherits a reference to the
    same lock as parent. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 文件锁 | 是 | 参见备注 | *flock()*。子进程继承与父进程相同锁的引用。 |'
- en: '| Record locks | Seenotes | No | *fcntl(F_SETLK)*. Locks are preserved across
    *exec()* unless a file descriptor referring to the file is marked close-on-exec;
    see [Lock Limits and Performance](ch55.html#lock_limits_and_performance "Lock
    Limits and Performance"). |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 记录锁 | 参见备注 | 否 | *fcntl(F_SETLK)*。锁会在 *exec()* 之间保留，除非指向该文件的文件描述符被标记为执行时关闭；参见
    [锁限制与性能](ch55.html#lock_limits_and_performance "锁限制与性能")。 |'
- en: '| Miscellaneous |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 杂项 |'
- en: '| --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Locale settings | No | Yes | *setlocale()*. As part of C run-time initialization,
    the equivalent of *setlocale(LC_ALL, “C”)* is executed after a new program is
    execed. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 区域设置 | 否 | 是 | *setlocale()*。作为C运行时初始化的一部分，在执行新程序时，等同于 *setlocale(LC_ALL,
    “C”)* 的操作会被执行。 |'
- en: '| Floating-point environment | No | Yes | When a new program is execed, the
    state of the floating-point environment is reset to the default; see *fenv(3)*.
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 浮点环境 | 否 | 是 | 当一个新程序被执行时，浮点环境的状态会重置为默认值；参见 *fenv(3)*。 |'
- en: '| Controlling terminal | Yes | Yes |   |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 控制终端 | 是 | 是 |   |'
- en: '| Exit handlers | No | Yes | *atexit()*, *on_exit()*. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 退出处理程序 | 否 | 是 | *atexit()*，*on_exit()*。 |'
- en: '| Linux-specific |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| Linux 特有 |'
- en: '| --- |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| File-system IDs | Seenotes | Yes | *setfsuid()*, *setfsgid()*. These IDs
    are also changed any time the corresponding effective IDs are changed. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统ID | 参见备注 | 是 | *setfsuid()*，*setfsgid()*。当相应的有效ID发生变化时，这些ID也会改变。 |'
- en: '| *timerfd* timers | Yes | See notes | *timerfd_create()*; child inherits file
    descriptors referring to same timers as parent. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| *timerfd* 定时器 | 是 | 参见备注 | *timerfd_create()*；子进程继承与父进程相同定时器的文件描述符。 |'
- en: '| Capabilities | Seenotes | Yes | *capset()*. The handling of capabilities
    during an *exec()* is described in Section 39.5. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 能力 | 参见备注 | 是 | *capset()*。在 *exec()* 期间如何处理能力在第39.5节中有描述。 |'
- en: '| Capability bounding set | Yes | Yes |   |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 能力边界集 | 是 | 是 |   |'
- en: '| Capabilities *securebits* flags | Seenotes | Yes | All *securebits* flags
    are preserved during an *exec()* except `SECBIT_KEEP_CAPS`, which is always cleared.
    |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 能力 *securebits* 标志 | 参见备注 | 是 | 在 *exec()* 期间，所有 *securebits* 标志都会被保留，除非
    `SECBIT_KEEP_CAPS`，该标志总是会被清除。 |'
- en: '| CPU affinity | Yes | Yes | *sched_setaffinity()*. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| CPU 亲和性 | 是 | 是 | *sched_setaffinity()*。 |'
- en: '| `SCHED_RESET_ON_FORK` | Yes | No | See [Modifying and Retrieving Policies
    and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr "Modifying
    and Retrieving Policies and Priorities"). |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_RESET_ON_FORK` | 是 | 否 | 参见 [修改和获取策略与优先级](ch35.html#modifying_and_retrieving_policies_and_pr
    "修改和获取策略与优先级")。 |'
- en: '| Allowed CPUs | Yes | Yes | See *cpuset(7)*. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 允许的CPU | 是 | 是 | 参见 *cpuset(7)*。 |'
- en: '| Allowed memory nodes | Yes | Yes | See *cpuset(7)*. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 允许的内存节点 | 是 | 是 | 参见 *cpuset(7)*。 |'
- en: '| Memory policy | Yes | Yes | See *set_mempolicy(2)*. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 内存策略 | 是 | 是 | 参见 *set_mempolicy(2)*。 |'
- en: '| File leases | Yes | See notes | *fcntl(F_SETLEASE)*. Child inherits a reference
    to the same lease as parent. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 文件租约 | 是 | 参见备注 | *fcntl(F_SETLEASE)*。子进程继承与父进程相同租约的引用。 |'
- en: '| Directory change notifications | Yes | No | The *dnotify* API, available
    via *fcntl(F_NOTIFY)*. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 目录更改通知 | 是 | 否 | *dnotify* API，通过 *fcntl(F_NOTIFY)* 提供。 |'
- en: '| *prctl(PR_SET_DUMPABLE)* | Seenotes | Yes | During an *exec()*, the `PR_SET_DUMPABLE`
    flag is set, unless execing a set-user-ID or set-group-ID program, in which case
    it is cleared. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| *prctl(PR_SET_DUMPABLE)* | 参见备注 | 是 | 在 *exec()* 期间，`PR_SET_DUMPABLE` 标志会被设置，除非执行的是一个设置了用户ID或组ID的程序，此时该标志会被清除。
    |'
- en: '| *prctl(PR_SET_PDEATHSIG)* | Yes | No |   |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| *prctl(PR_SET_PDEATHSIG)* | 是 | 否 |   |'
- en: '| *prctl(PR_SET_NAME)* | No | Yes |   |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| *prctl(PR_SET_NAME)* | 否 | 是 |   |'
- en: '| `oom_adj` | Yes | Yes | See Section 49.9. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `oom_adj` | 是 | 是 | 参见第49.9节。 |'
- en: '| `coredump_filter` | Yes | Yes | See Section 22.1. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `coredump_filter` | 是 | 是 | 参见第22.1节。 |'
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: When process accounting is enabled, the kernel writes an accounting record to
    a file for each process that terminates on the system. This record contains statistics
    on the resources used by the process.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程会计功能启用时，内核会为系统上每个终止的进程写入一个会计记录到文件中。该记录包含有关进程使用的资源的统计信息。
- en: Like *fork()*, the Linux-specific *clone()* system call creates a new process,
    but allows finer control over which attributes are shared between the parent and
    child. This system call is used primarily for implementing threading libraries.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 像 *fork()* 一样，Linux 特有的 *clone()* 系统调用创建一个新进程，但允许更精细地控制父子进程之间共享的属性。该系统调用主要用于实现线程库。
- en: We compared the speed of process creation using *fork()*, *vfork()*, and *clone()*.
    Although *vfork()* is faster than *fork()*, the time difference between these
    system calls is small by comparison with the time required for a child process
    to do a subsequent *exec()*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较了使用*fork()*、*vfork()*和*clone()*创建进程的速度。尽管*vfork()*比*fork()*更快，但这些系统调用之间的时间差距与子进程执行后续*exec()*所需的时间相比是微乎其微的。
- en: When a child process is created via *fork()*, it inherits copies of (or in some
    cases shares) certain process attributes from its parent, while other process
    attributes are not inherited. For example, a child inherits copies of its parent’s
    file descriptor table and signal dispositions, but doesn’t inherit its parent’s
    interval timers, record locks, or set of pending signals. Correspondingly, when
    a process performs an *exec()*, certain process attributes remain unchanged, while
    others are reset to defaults. For example, the process ID remains the same, file
    descriptors remain open (unless marked close-on-exec), interval timers are preserved,
    and pending signals remain pending, but handled signals are reset to their default
    disposition and shared memory segments are detached.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过*fork()*创建子进程时，它会继承（或者在某些情况下共享）某些进程属性来自父进程，而其他进程属性则不被继承。例如，子进程继承父进程的文件描述符表和信号处理状态，但不继承父进程的时间间隔定时器、记录锁或待处理信号集。相应地，当进程执行*exec()*时，某些进程属性保持不变，而其他属性则会重置为默认值。例如，进程ID保持不变，文件描述符保持打开状态（除非标记为关闭执行时关闭），时间间隔定时器被保留，待处理的信号保持待处理状态，但已处理的信号会重置为默认的处理方式，且共享内存段会被分离。
- en: Further information
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: Refer to the sources of further information listed in Section 24.6\. [Chapter 17](ch17.html
    "Chapter 17. Access Control Lists") of [Frisch, 2002] describes the administration
    of process accounting, as well as some of the variations across UNIX implementations.
    [Bovet & Cesati, 2005] describes the implementation of the *clone()* system call.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考第24.6节中列出的进一步信息来源。[Frisch, 2002]的[第17章](ch17.html "第17章. 访问控制列表")描述了进程记账的管理，以及不同UNIX实现中的一些变种。[Bovet
    & Cesati, 2005]描述了*clone()*系统调用的实现。
- en: Exercise
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program to see how fast the *fork()* and *vfork()* system calls are
    on your system. Each child process should immediately exit, and the parent should
    *wait()* on each child before creating the next. Compare the relative differences
    for these two system calls with those of [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()"). The shell built-in command *time* can be used to measure the execution
    time of a program.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，查看在您的系统上*fork()*和*vfork()*系统调用的速度。每个子进程应该立即退出，父进程在创建下一个子进程之前应*wait()*每个子进程。将这两个系统调用的相对差异与[表28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "表28-3. 使用fork()、vfork()和clone()创建100,000个进程所需的时间")中的差异进行比较。可以使用shell内建命令*time*来测量程序的执行时间。
