- en: Chapter 28. Process Creation and Program Execution in More Detail
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 28 章. 更详细的进程创建与程序执行
- en: This chapter extends the material presented in [Chapter 24](ch24.html "Chapter 24. Process
    Creation") to [Chapter 27](ch27.html "Chapter 27. Program Execution") by covering
    a variety of topics related to process creation and program execution. We describe
    process accounting, a kernel feature that writes an accounting record for each
    process on the system as it terminates. We then look at the Linux-specific *clone()*
    system call, which is the low-level API that is used to create threads on Linux.
    We follow this with some comparisons of the performance of *fork()*, *vfork()*,
    and *clone()*. We conclude with a summary of the effects of *fork()* and *exec()*
    on the attributes of a process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章扩展了[第 24 章](ch24.html "第 24 章. 进程创建")至[第 27 章](ch27.html "第 27 章. 程序执行")中的内容，涵盖了与进程创建和程序执行相关的各种主题。我们描述了进程会计，这是一个内核功能，在每个进程终止时为系统上的每个进程写入一条会计记录。接着，我们介绍了
    Linux 特有的*clone()* 系统调用，这是用于在 Linux 上创建线程的低级 API。之后，我们对 *fork()*、*vfork()* 和 *clone()*
    的性能进行了比较。最后，我们总结了 *fork()* 和 *exec()* 对进程属性的影响。
- en: Process Accounting
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程会计
- en: When process accounting is enabled, the kernel writes an accounting record to
    the system-wide process accounting file as each process terminates. This accounting
    record contains various information maintained by the kernel about the process,
    including its termination status and how much CPU time it consumed. The accounting
    file can be analyzed by standard tools (*sa(8)* summarizes information from the
    accounting file, and *lastcomm(1)* lists information about previously executed
    commands) or by tailored applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用进程会计时，每当进程终止时，内核会将一条会计记录写入系统范围的进程会计文件。这条会计记录包含内核维护的有关进程的各种信息，包括其终止状态和消耗的
    CPU 时间。可以通过标准工具（*sa(8)* 总结来自会计文件的信息，*lastcomm(1)* 列出先前执行的命令的信息）或定制的应用程序分析会计文件。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In kernels before 2.6.10, a separate process accounting record was written for
    each thread created using the NPTL threading implementation. Since kernel 2.6.10,
    a single accounting record is written for the entire process when the last thread
    terminates. Under the older LinuxThreads threading implementation, a single process
    accounting record is always written for each thread.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.6.10 版本之前的内核中，为每个使用 NPTL 线程实现创建的线程写入一个独立的进程会计记录。自内核 2.6.10 起，当最后一个线程终止时，会为整个进程写入一条会计记录。在较旧的
    LinuxThreads 线程实现中，总是为每个线程写入一条进程会计记录。
- en: Historically, the primary use of process accounting was to charge users for
    consumption of system resources on multiuser UNIX systems. However, process accounting
    can also be useful for obtaining information about a process that was not otherwise
    monitored and reported on by its parent.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，进程会计的主要用途是对多用户 UNIX 系统上用户使用系统资源的情况进行收费。然而，进程会计也可以用于获取有关进程的信息，这些信息通常未被其父进程监控和报告。
- en: Although available on most UNIX implementations, process accounting is not specified
    in SUSv3\. The format of the accounting records, as well as the location of the
    accounting file, vary somewhat across implementations. We describe the details
    for Linux in this section, noting some variations from other UNIX implementations
    along the way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数 UNIX 实现中都可用，进程会计并未在 SUSv3 中指定。会计记录的格式以及会计文件的位置在不同实现之间有所不同。本节中我们描述了 Linux
    的细节，并注意到与其他 UNIX 实现之间的一些差异。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, process accounting is an optional kernel component that is configured
    via the option `CONFIG_BSD_PROCESS_ACCT`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，进程会计是一个可选的内核组件，通过选项 `CONFIG_BSD_PROCESS_ACCT` 配置。
- en: Enabling and disabling process accounting
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用和禁用进程会计
- en: The *acct()* system call is used by a privileged (`CAP_SYS_PACCT`) process to
    enable and disable process accounting. This system call is rarely used in application
    programs. Normally, process accounting is enabled at each system restart by placing
    appropriate commands in the system boot scripts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*acct()* 系统调用由具有特权的（`CAP_SYS_PACCT`）进程用于启用和禁用进程会计。这个系统调用在应用程序中很少使用。通常，进程会计在每次系统重启时通过将适当的命令放入系统启动脚本来启用。'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: To enable process accounting, we supply the pathname of an *existing* regular
    file in *acctfile*. A typical pathname for the accounting file is `/var/log/pacct`
    or `/usr/account/pacct`. To disable process accounting, we specify *acctfile*
    as `NULL`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用进程会计，我们需要在*acctfile*中提供一个*现有*的常规文件路径名。会计文件的典型路径名是`/var/log/pacct`或`/usr/account/pacct`。要禁用进程会计，我们将*acctfile*指定为`NULL`。
- en: The program in [Example 28-1](ch28.html#turning_process_accounting_on_and_off
    "Example 28-1. Turning process accounting on and off") uses *acct()* to switch
    process accounting on and off. The functionality of this program is similar to
    the shell *accton(8)* command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例28-1](ch28.html#turning_process_accounting_on_and_off "示例28-1. 开启和关闭进程会计")中的程序使用*acct()*来切换进程会计的开启和关闭。该程序的功能类似于shell中的*accton(8)*命令。'
- en: Example 28-1. Turning process accounting on and off
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例28-1. 开启和关闭进程会计
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Process accounting records
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程会计记录
- en: 'Once process accounting is enabled, an *acct* record is written to the accounting
    file as each process terminates. The *acct* structure is defined in `<sys/acct.h>`
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用进程会计，每当一个进程终止时，*acct*记录就会被写入到会计文件中。*acct*结构在`<sys/acct.h>`中定义如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the following points regarding the *acct* structure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于*acct*结构的几点：
- en: The *u_int16_t* and *u_int32_t* data types are 16-bit and 32-bit unsigned integers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u_int16_t*和*u_int32_t*数据类型分别是16位和32位无符号整数。'
- en: The *ac_flag* field is a bit mask recording various events for the process.
    The bits that can appear in this field are shown in [Table 28-1](ch28.html#bit_values_for_the_ac_underscore_flag_fi
    "Table 28-1. Bit values for the ac_flag field of process accounting records").
    As indicated in the table, some of these bits are not present on all UNIX implementations.
    A few other implementations provide additional bits in this field.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_flag*字段是一个位掩码，记录进程的各种事件。此字段中可能出现的位在[表28-1](ch28.html#bit_values_for_the_ac_underscore_flag_fi
    "表28-1. 进程会计记录中ac_flag字段的位值")中展示。如表所示，并非所有UNIX实现都支持这些位。某些其他实现会在此字段中提供额外的位。'
- en: The *ac_comm* field records the name of the last command (program file) executed
    by this process. The kernel records this value on each *execve()*. On some other
    UNIX implementations, this field is limited to 8 characters.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_comm*字段记录了该进程执行的最后一个命令（程序文件）的名称。内核在每次执行*execve()*时记录此值。在一些其他UNIX实现中，该字段限制为8个字符。'
- en: The *comp_t* type is a kind of floating-point number. Values of this type are
    sometimes called *compressed clock ticks*. The floating-point value consists of
    a 3-bit, base-8 exponent, followed by a 13-bit mantissa; the exponent can represent
    a factor in the range 8⁰=1 to 8⁷ (2,097,152). For example, a mantissa of 125 and
    an exponent of 1 represent the value 1000\. [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") defines a function
    (*comptToLL()*) to convert this type to *long long*. We need to use the type *long
    long* because the 32 bits used to represent an *unsigned long* on x86-32 are insufficient
    to hold the largest value that can be represented in *comp_t*, which is (2^(13)
    - 1) * 87.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*comp_t*类型是一种浮动点数。此类型的值有时被称为*压缩时钟滴答*。浮动点数由一个3位的基8指数和一个13位的尾数组成；指数可以表示一个范围从8⁰=1到8⁷（2,097,152）的因子。例如，125的尾数和1的指数表示值1000。[示例28-2](ch28.html#displaying_data_from_a_process_accountin
    "示例28-2. 显示进程会计文件中的数据")定义了一个函数（*comptToLL()*）来将此类型转换为*long long*。我们需要使用*long long*类型，因为在x86-32上，表示*unsigned
    long*的32位不足以容纳在*comp_t*中表示的最大值，即(2^(13) - 1) * 87。'
- en: The three time fields defined with the type *comp_t* represent time in system
    clock ticks. Therefore, we must divide these times by the value returned by *sysconf(_SC_CLK_TCK)*
    in order to convert them to seconds.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*comp_t*类型定义的三个时间字段表示系统时钟滴答时间。因此，我们必须通过*sysconf(_SC_CLK_TCK)*返回的值将这些时间转换为秒。
- en: The *ac_exitcode* field holds the termination status of the process (described
    in [The Wait Status Value](ch26.html#the_wait_status_value "The Wait Status Value")).
    Most other UNIX implementations instead provide a single-byte field named *ac_stat*,
    which records only the signal that killed the process (if it was killed by a signal)
    and a bit indicating whether that signal caused the process to dump core. BSD-derived
    implementations don’t provide either field.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table 28-1. Bit values for the *ac_flag* field of process accounting records
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit | Description |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `AFORK` | Process was created by *fork()*, but did not *exec()* before terminating
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `ASU` | Process made use of superuser privileges |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `AXSIG` | Process was terminated by a signal (not present on some implementations)
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `ACORE` | Process produced a core dump (not present on some implementations)
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: Because accounting records are written only as processes terminate, they are
    ordered by termination time (a value not recorded in the record), rather than
    by process start time (*ac_btime*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the system crashes, no accounting record is written for any processes that
    are still executing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Since writing records to the accounting file can rapidly consume disk space,
    Linux provides the `/proc/sys/kernel/acct` virtual file for controlling the operation
    of process accounting. This file contains three numbers, defining (in order) the
    parameters *high-water*, *low-water*, and *frequency*. Typical defaults for these
    three parameters are 4, 2, and 30\. If process accounting is enabled and the amount
    of free disk space falls below *low-water* percent, accounting is suspended. If
    the amount of free disk space later rises above *high-water* percent, then accounting
    is resumed. The *frequency* value specifies how often, in seconds, checks should
    be made on the percentage of free disk space.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program in [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") displays selected
    fields from the records in a process accounting file. The following shell session
    demonstrates the use of this program. We begin by creating a new, empty process
    accounting file and enabling process accounting:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, three processes have already terminated since we enabled process
    accounting. These processes executed the *acct_on*, *su*, and *bash* programs.
    The *bash* process was started by *su* to run the privileged shell session.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we run a series of commands to add further records to the accounting file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next two commands run programs that we presented in previous chapters ([Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program"), in [The *exec()* Library
    Functions](ch27.html#the_exec_open_parenthesis_close_parenthe "The exec() Library
    Functions"), and [Example 24-1](ch24.html#using_fork_open_parenthesis_close_parent
    "Example 24-1. Using fork()"), in [File Sharing Between Parent and Child](ch24.html#file_sharing_between_parent_and_child
    "File Sharing Between Parent and Child")). The first command runs a program that
    execs the file `/bin/echo`; this results in an accounting record with the command
    name *echo*. The second command creates a child process that doesn’t perform an
    *exec()*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we use the program in [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") to view the contents
    of the accounting file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the output, we see one line for each process that was created in the shell
    session. The *ulimit* and *echo* commands are shell built-in commands, so they
    don’t result in the creation of new processes. Note that the entry for *sleep*
    appeared in the accounting file after the *cat* entry because the *sleep* command
    terminated after the *cat* command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Most of the output is self-explanatory. The *flags* column shows single letters
    indicating which of the *ac_flag* bits is set in each record (see [Table 28-1](ch28.html#bit_values_for_the_ac_underscore_flag_fi
    "Table 28-1. Bit values for the ac_flag field of process accounting records")).
    [The Wait Status Value](ch26.html#the_wait_status_value "The Wait Status Value")
    describes how to interpret the termination status values shown in the *term. status*
    column.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-2. Displaying data from a process accounting file
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Process accounting Version 3 file format
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.8, Linux introduced an optional alternative version
    of the process accounting file that addresses some limitations of the traditional
    accounting file. To use this alternative version, known as *Version 3*, the `CONFIG_BSD_PROCESS_ACCT_V3`
    kernel configuration option must be enabled before building the kernel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the Version 3 option, the only difference in the operation of process
    accounting is in the format of records written to the accounting file. The new
    format is defined as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are the main differences between the *acct_v3* structure and
    the traditional Linux *acct* structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The *ac_version* field is added. This field contains the version number of this
    type of accounting record. This field is always 3 for an *acct_v3* record.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fields *ac_pid* and *ac_ppid*, containing the process ID and parent process
    ID of the terminated process, are added.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ac_uid* and *ac_gid* fields are widened from 16 to 32 bits, to accommodate
    the 32-bit user and group IDs that were introduced in Linux 2.4\. (Large user
    and group IDs can’t be correctly represented in the traditional *acct* file.)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_uid* 和 *ac_gid* 字段的宽度从 16 位扩展到 32 位，以适应 Linux 2.4 引入的 32 位用户和组 ID。（传统的
    *acct* 文件无法正确表示较大的用户和组 ID。）'
- en: The type of the *ac_etime* field is changed from *comp_t* to *float*, to allow
    longer elapsed times to be recorded.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ac_etime* 字段的类型从 *comp_t* 改为 *float*，以便记录更长的经过时间。'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: We provide a Version 3 analog of the program in [Example 28-2](ch28.html#displaying_data_from_a_process_accountin
    "Example 28-2. Displaying data from a process accounting file") in the file `procexec/acct_v3_view.c`
    in the source code distribution for this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的源代码分发中提供了一个 Version 3 类似程序，位于文件 `procexec/acct_v3_view.c` 中，参见 [示例 28-2](ch28.html#displaying_data_from_a_process_accountin
    "示例 28-2. 从进程会计文件显示数据")。
- en: The *clone()* System Call
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*clone()* 系统调用'
- en: 'Like *fork()* and *vfork()*, the Linux-specific *clone()* system call creates
    a new process. It differs from the other two calls in allowing finer control over
    the steps that occur during process creation. The main use of *clone()* is in
    the implementation of threading libraries. Because *clone()* is not portable,
    its direct use in application programs should normally be avoided. We describe
    it here because it is useful background for the discussion of POSIX threads in
    [Chapter 29](ch29.html "Chapter 29. Threads: Introduction") to [Chapter 33](ch33.html
    "Chapter 33. Threads: Further Details"), and also because it further illuminates
    the operation of *fork()* and *vfork()*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 像 *fork()* 和 *vfork()* 一样，Linux 特有的 *clone()* 系统调用创建一个新进程。它与另外两个调用的不同之处在于，它允许更精细地控制进程创建过程中发生的各个步骤。*clone()*
    的主要用途是在线程库的实现中。由于 *clone()* 并不具有可移植性，因此通常应避免在应用程序中直接使用它。我们在这里讨论它，是因为它为第 [29 章](ch29.html
    "第29章。线程：简介") 到第 [33 章](ch33.html "第33章。线程：进一步细节") 关于 POSIX 线程的讨论提供了有用的背景，也因为它有助于进一步理解
    *fork()* 和 *vfork()* 的操作。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Returns process ID of child on success, or -1 on error
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回子进程的进程 ID，出错时返回 -1。
- en: Like *fork()*, a new process created with *clone()* is an almost exact duplicate
    of the parent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像 *fork()* 一样，使用 *clone()* 创建的新进程几乎是父进程的精确副本。
- en: Unlike *fork()*, the cloned child doesn’t continue from the point of the call,
    but instead commences by calling the function specified in the *func* argument;
    we’ll refer to this as the *child function*. When called, the child function is
    passed the value specified in *func_arg*. Using appropriate casting, the child
    function can freely interpret this argument; for example, as an int or as a pointer
    to a structure. (Interpreting it as a pointer is possible because the cloned child
    either obtains a copy of or shares the calling process’s memory.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *fork()* 不同，克隆的子进程不会从调用点继续执行，而是通过调用 *func* 参数中指定的函数开始执行；我们将其称为 *子进程函数*。在调用时，子进程函数会传入
    *func_arg* 中指定的值。通过适当的类型转换，子进程函数可以自由解释这个参数；例如，可以将其解释为 int 类型或结构体的指针。（将其解释为指针是可能的，因为克隆的子进程要么获取调用进程的内存副本，要么与之共享内存。）
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: 'Within the kernel, *fork()*, *vfork()*, and *clone()* are ultimately implemented
    by the same function (*do_fork()* in `kernel/fork.c`). At this level, cloning
    is much closer to forking: *sys_clone()* doesn’t have the *func* and *func_arg*
    arguments, and after the call, *sys_clone()* returns in the child in the same
    manner as *fork()*. The main text describes the *clone()* wrapper function that
    *glibc* provides for *sys_clone()*. (This function is defined in architecture-specific
    *glibc* assembler sources, such as in `sysdeps/unix/sysv/linux/i386/clone.S`.)
    This wrapper function invokes *func* after *sys_clone()* returns in the child.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，*fork()*, *vfork()* 和 *clone()* 最终都由同一个函数实现（`kernel/fork.c` 中的 *do_fork()*）。在这个层面上，克隆更接近于分叉：*sys_clone()*
    没有 *func* 和 *func_arg* 参数，且在调用后，*sys_clone()* 会像 *fork()* 一样在子进程中返回。正文描述了 *glibc*
    为 *sys_clone()* 提供的 *clone()* 包装函数。（该函数在架构特定的 *glibc* 汇编源代码中定义，例如在 `sysdeps/unix/sysv/linux/i386/clone.S`
    中。）该包装函数在 *sys_clone()* 在子进程中返回后调用 *func*。
- en: The cloned child process terminates either when *func* returns (in which case
    its return value is the exit status of the process) or when the process makes
    a call to *exit()* (or _*exit()*). The parent process can wait for the cloned
    child in the usual manner using *wait()* or similar.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆的子进程终止的时机要么是 *func* 返回（此时其返回值为进程的退出状态），要么是进程调用 *exit()*（或 _*exit()*）时。父进程可以像往常一样使用
    *wait()* 或类似函数等待克隆的子进程。
- en: Since a cloned child may (like *vfork()*) share the parent’s memory, it can’t
    use the parent’s stack. Instead, the caller must allocate a suitably sized block
    of memory for use as the child’s stack and pass a pointer to that block in the
    argument *child_stack*. On most hardware architectures, the stack grows downward,
    so the *child_stack* argument should point to the high end of the allocated block.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于克隆的子进程可能（像 *vfork()* 一样）共享父进程的内存，因此不能使用父进程的堆栈。相反，调用者必须为子进程分配一个适当大小的内存块作为堆栈，并将该内存块的指针传递给
    *child_stack* 参数。在大多数硬件架构上，堆栈是向下增长的，因此 *child_stack* 参数应该指向分配内存块的高端。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The architecture-dependence on the direction of stack growth is a defect in
    the design of *clone()*. On the Intel IA-64 architecture, an improved clone API
    is provided, in the form of *clone2()*. This system call defines the range of
    the stack of the child in a way that doesn’t depend on the direction of stack
    growth, by supplying both the start address and size of the stack. See the manual
    page for details.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈增长方向的架构依赖性是 *clone()* 设计中的一个缺陷。在Intel IA-64架构上，提供了改进的 *clone()* API，形式为 *clone2()*。这个系统调用通过提供堆栈的起始地址和大小，定义了子进程堆栈的范围，避免依赖堆栈增长的方向。详情请参见手册页。
- en: The *clone() flags* argument serves two purposes. First, its lower byte specifies
    the child’s *termination signal*, which is the signal to be sent to the parent
    when the child terminates. (If a cloned child is *stopped* by a signal, the parent
    still receives `SIGCHLD`.) This byte may be 0, in which case no signal is generated.
    (Using the Linux-specific /`proc/`*PID*`/stat` file, we can determine the termination
    signal of any process; see the *proc(5)* manual page for further details.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*clone()* 标志位参数有两个用途。首先，其低字节指定子进程的 *终止信号*，即当子进程终止时发送给父进程的信号。（如果克隆的子进程被信号 *停止*，父进程仍会接收到
    `SIGCHLD`。）这个字节可以为0，表示不生成信号。（通过使用Linux特有的 /`proc/`*PID*`/stat` 文件，我们可以确定任何进程的终止信号；详情请参见
    *proc(5)* 手册页。）'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: With *fork()* and *vfork()*, we have no way to select the termination signal;
    it is always `SIGCHLD`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *fork()* 和 *vfork()*，我们无法选择终止信号；它总是 `SIGCHLD`。
- en: The remaining bytes of the *flags* argument hold a bit mask that controls the
    operation of *clone()*. We summarize these bit-mask values in [Table 28-2](ch28.html#the_clone_open_parenthesis_close_par
    "Table 28-2. The clone() flags bit-mask values"), and describe them in more detail
    in [Example program](ch28.html#example_program-id39 "Example program").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数的剩余字节包含一个位掩码，控制 *clone()* 的操作。我们在[表28-2](ch28.html#the_clone_open_parenthesis_close_par
    "表28-2. *clone()* 标志位掩码值")中总结了这些位掩码值，并在[示例程序](ch28.html#example_program-id39 "示例程序")中进行了更详细的描述。'
- en: Table 28-2. The *clone() flags* bit-mask values
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表28-2. *clone()* 标志位掩码值
- en: '| Flag | Effect if present |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 如果存在，效果 |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CLONE_CHILD_CLEARTID` | Clear *ctid* when child calls *exec()* or *_exit()*
    (2.6 onward) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_CHILD_CLEARTID` | 当子进程调用 *exec()* 或 *_exit()* 时清除 *ctid*（2.6及以后版本）
    |'
- en: '| `CLONE_CHILD_SETTID` | Write thread ID of child into *ctid* (2.6 onward)
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_CHILD_SETTID` | 将子进程的线程ID写入 *ctid*（2.6及以后版本） |'
- en: '| `CLONE_FILES` | Parent and child share table of open file descriptors |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_FILES` | 父进程和子进程共享打开文件描述符表 |'
- en: '| `CLONE_FS` | Parent and child share attributes related to file system |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_FS` | 父进程和子进程共享与文件系统相关的属性 |'
- en: '| `CLONE_IO` | Child shares parent’s I/O context (2.6.25 onward) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_IO` | 子进程共享父进程的I/O上下文（2.6.25及以后版本） |'
- en: '| `CLONE_NEWIPC` | Child gets new System V IPC namespace (2.6.19 onward) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWIPC` | 子进程获得新的System V IPC命名空间（2.6.19及以后版本） |'
- en: '| `CLONE_NEWNET` | Child gets new network namespace (2.4.24 onward) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWNET` | 子进程获得新的网络命名空间（2.4.24及以后版本） |'
- en: '| `CLONE_NEWNS` | Child gets copy of parent’s mount namespace (2.4.19 onward)
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWNS` | 子进程获得父进程的挂载命名空间副本（2.4.19及以后版本） |'
- en: '| `CLONE_NEWPID` | Child gets new process-ID namespace (2.6.19 onward) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWPID` | 子进程获得新的进程ID命名空间（2.6.19及以后版本） |'
- en: '| `CLONE_NEWUSER` | Child gets new user-ID namespace (2.6.23 onward) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWUSER` | 子进程获得新的用户ID命名空间（2.6.23及以后版本） |'
- en: '| `CLONE_NEWUTS` | Child gets new UTS (*utsname()*) namespace (2.6.19 onward)
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_NEWUTS` | 子进程获得新的UTS（*utsname()*）命名空间（2.6.19及以后版本） |'
- en: '| `CLONE_PARENT` | Make child’s parent same as caller’s parent (2.4 onward)
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PARENT` | 将子进程的父进程设置为与调用者的父进程相同（2.4及以后版本） |'
- en: '| `CLONE_PARENT_SETTID` | Write thread ID of child into *ptid* (2.6 onward)
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PARENT_SETTID` | 将子进程的线程ID写入 *ptid*（2.6及以后版本） |'
- en: '| `CLONE_PID` | Obsolete flag used only by system boot process (up to 2.4)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PID` | 仅由系统启动过程使用的过时标志（最多到2.4版本） |'
- en: '| `CLONE_PTRACE` | If parent is being traced, then trace child also |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_PTRACE` | 如果父进程正在被跟踪，则子进程也被跟踪 |'
- en: '| `CLONE_SETTLS` | *tls* describes thread-local storage for child (2.6 onward)
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_SETTLS` | *tls*描述子进程的线程局部存储（从2.6版本起） |'
- en: '| `CLONE_SIGHAND` | Parent and child share signal dispositions |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_SIGHAND` | 父进程和子进程共享信号处理方式 |'
- en: '| `CLONE_SYSVSEM` | Parent and child share semaphore undo values (2.6 onward)
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_SYSVSEM` | 父进程和子进程共享信号量撤销值（从2.6版本起） |'
- en: '| `CLONE_THREAD` | Place child in same thread group as parent (2.4 onward)
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_THREAD` | 将子进程放入与父进程相同的线程组（从2.4版本起） |'
- en: '| `CLONE_UNTRACED` | Can’t force `CLONE_PTRACE` on child (2.6 onward) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_UNTRACED` | 无法强制对子进程执行`CLONE_PTRACE`（从2.6版本起） |'
- en: '| `CLONE_VFORK` | Parent is suspended until child calls *exec()* or *_exit()*
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_VFORK` | 父进程被挂起，直到子进程调用*exec()*或*_exit()* |'
- en: '| `CLONE_VM` | Parent and child share virtual memory |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `CLONE_VM` | 父进程和子进程共享虚拟内存 |'
- en: The remaining arguments to *clone()* are *ptid*, *tls*, and *ctid*. These arguments
    relate to the implementation of threads, in particular the use of thread IDs and
    thread-local storage. We cover the use of these arguments when describing the
    *flags* bit-mask values in [Example program](ch28.html#example_program-id39 "Example
    program"). (In Linux 2.4 and earlier, these three arguments are not provided by
    *clone()*. They were specifically added in Linux 2.6 to support the NPTL POSIX
    threads implementation.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*clone()*的其余参数是*ptid*、*tls*和*ctid*。这些参数与线程的实现有关，特别是与线程ID和线程局部存储的使用有关。我们将在[示例程序](ch28.html#example_program-id39
    "示例程序")中描述这些参数和*flags*位掩码值时，详细介绍它们的使用。（在Linux 2.4及更早版本中，*clone()*没有提供这三个参数。它们是在Linux
    2.6中专门添加的，用以支持NPTL POSIX线程实现。）'
- en: Example program
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 28-3](ch28.html#using_clone_open_parenthesis_close_paren "Example 28-3. Using
    clone() to create a child process") shows a simple example of the use of *clone()*
    to create a child process. The main program does the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例28-3](ch28.html#using_clone_open_parenthesis_close_paren "示例28-3. 使用clone()创建子进程")展示了如何使用*clone()*创建子进程的简单示例。主程序执行以下操作：'
- en: Open a file descriptor (for `/dev/null`) that will be closed by the child ![](figs/web/U002.png).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个文件描述符（针对`/dev/null`），该文件描述符将由子进程关闭！[](figs/web/U002.png)。
- en: Set the value for the *clone() flags* argument to `CLONE_FILES` ![](figs/web/U003.png)
    if a command-line argument was supplied, so that the parent and child will share
    a single file descriptor table. If no command-line argument was supplied, *flags*
    is set to 0.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了命令行参数，则将*clone()*标志参数的值设置为`CLONE_FILES`！[](figs/web/U003.png)，使得父进程和子进程共享同一个文件描述符表。如果没有提供命令行参数，则将*flags*设置为0。
- en: Allocate a stack for use by the child ![](figs/web/U004.png).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为子进程分配一个栈空间！[](figs/web/U004.png)。
- en: If `CHILD_SIG` is nonzero and is not equal to `SIGCHLD`, ignore it, in case
    it is a signal that would terminate the process. We don’t ignore `SIGCHLD`, because
    doing so would prevent waiting on the child to collect its status.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`CHILD_SIG`非零且不等于`SIGCHLD`，则忽略它，以防它是一个会终止进程的信号。我们不忽略`SIGCHLD`，因为忽略它会阻止父进程等待子进程收集其状态。
- en: Call *clone()* to create the child ![](figs/web/U006.png). The third (bit-mask)
    argument includes the termination signal. The fourth argument (*func_arg*) specifies
    the file descriptor opened earlier (at ![](figs/web/U002.png)).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*clone()*来创建子进程！[](figs/web/U006.png)。第三个（位掩码）参数包括终止信号。第四个参数（*func_arg*）指定先前打开的文件描述符（在![](figs/web/U002.png)处）。
- en: Wait for the child to terminate ![](figs/web/U007.png).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待子进程终止！[](figs/web/U007.png)。
- en: Check whether the file descriptor (opened at ![](figs/web/U002.png)) is still
    open by trying to *write()* to it ![](figs/web/U008.png). The program reports
    whether the *write()* succeeds or fails.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尝试对文件描述符（在![](figs/web/U002.png)处打开）执行*write()*操作，检查文件描述符是否仍然打开！[](figs/web/U008.png)。程序报告*write()*操作是成功还是失败。
- en: Execution of the cloned child begins in *childFunc()*, which receives (in the
    argument *arg*) the file descriptor opened by the main program (at ![](figs/web/U002.png)).
    The child closes this file descriptor and then terminates by performing a `return`
    ![](figs/web/U001.png).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆的子进程执行从*childFunc()*开始，该函数接收（在参数*arg*中）由主程序打开的文件描述符（在![](figs/web/U002.png)处）。子进程关闭此文件描述符后，通过执行`return`！[](figs/web/U001.png)来终止。
- en: Example 28-3. Using *clone()* to create a child process
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例28-3. 使用*clone()*创建子进程
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run the program in [Example 28-3](ch28.html#using_clone_open_parenthesis_close_paren
    "Example 28-3. Using clone() to create a child process") without a command-line
    argument, we see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[示例28-3](ch28.html#using_clone_open_parenthesis_close_paren "示例28-3. 使用clone()创建子进程")中运行程序且没有命令行参数时，我们看到以下内容：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we run the program with a command-line argument, we can see that the two
    processes share the file descriptor table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用命令行参数运行程序时，我们可以看到两个进程共享文件描述符表：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We show a more complex example of the use of *clone()* in the file `procexec/demo_clone.c`
    in the source code distribution for this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的源代码分发版中的文件`procexec/demo_clone.c`中展示了一个更复杂的使用*clone()*的例子。
- en: The *clone() flags* Argument
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*clone() 标志* 参数'
- en: The *clone() flags* argument is a combination (ORing) of the bit-mask values
    described in the following pages. Rather than presenting these flags in alphabetical
    order, we present them in an order that eases explanation, and begin with those
    flags that are used in the implementation of POSIX threads. From the point of
    view of implementing threads, many uses of the word *process* below can be replaced
    by *thread*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*clone() 标志*参数是以下页面中描述的位掩码值的组合（按位“或”运算）。我们没有按字母顺序呈现这些标志，而是按照便于解释的顺序呈现，并从实现POSIX线程中使用的标志开始。从实现线程的角度来看，下面许多提到的“进程”一词可以替换为“线程”。'
- en: At this point, it is worth remarking that, to some extent, we are playing with
    words when trying to draw a distinction between the terms *thread* and *process*.
    It helps a little to introduce the term *kernel scheduling entity* (KSE), which
    is used in some texts to refer to the objects that are dealt with by the kernel
    scheduler. Really, threads and processes are simply KSEs that provide for greater
    and lesser degrees of sharing of attributes (virtual memory, open file descriptors,
    signal dispositions, process ID, and so on) with other KSEs. The POSIX threads
    specification provides just one out of various possible definitions of which attributes
    should be shared between threads.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此时值得指出的是，在某种程度上，我们在试图区分*线程*和*进程*这两个术语时，实际上是在玩文字游戏。引入术语*内核调度实体*（KSE）有助于一些理解，它在某些文献中用于指代内核调度器处理的对象。实际上，线程和进程只是KSE，它们在与其他KSE共享属性（虚拟内存、打开的文件描述符、信号处置、进程ID等）的程度上有所不同。POSIX线程规范提供了一个定义，规定了线程之间应该共享哪些属性。
- en: 'In the course of the following descriptions, we’ll sometimes mention the two
    main implementations of POSIX threads available on Linux: the older LinuxThreads
    implementation and the more recent NPTL implementation. Further information about
    these two implementations can be found in Section 33.5.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的描述过程中，我们有时会提到Linux上两种主要的POSIX线程实现：较旧的LinuxThreads实现和较新的NPTL实现。有关这两种实现的更多信息，请参阅第33.5节。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting in kernel 2.6.16, Linux provides a new system call, *unshare()*, which
    allows a child created using *clone()* (or *fork()* or *vfork()*) to undo some
    of the attribute sharing (i.e., reverse the effects of some of the *clone() flags*
    bits) that was established when the child was created. For details, see the *unshare(2)*
    manual page.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核2.6.16开始，Linux提供了一种新的系统调用*unshare()*，允许使用*clone()*（或*fork()*或*vfork()*)创建的子进程撤销一些属性共享（即撤销一些*clone()
    标志*位的效果），该属性共享在子进程创建时被建立。有关详细信息，请参阅*unshare(2)*手册页。
- en: 'Sharing file descriptor tables: `CLONE_FILES`'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享文件描述符表：`CLONE_FILES`
- en: If the `CLONE_FILES` flag is specified, the parent and the child share the same
    table of open file descriptors. This means that file descriptor allocation or
    deallocation (*open()*, *close()*, *dup()*, *pipe()*, *socket()*, and so on) in
    either process will be visible in the other process. If the `CLONE_FILES` flag
    is not set, then the file descriptor table is not shared, and the child gets a
    copy of the parent’s table at the time of the *clone()* call. These copied descriptors
    refer to the same open file descriptions as the corresponding descriptors in the
    parent (as with *fork()* and *vfork()*).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了`CLONE_FILES`标志，则父进程和子进程共享相同的打开文件描述符表。这意味着在任一进程中的文件描述符分配或释放（*open()*, *close()*,
    *dup()*, *pipe()*, *socket()*等）将在另一个进程中可见。如果没有设置`CLONE_FILES`标志，则文件描述符表不共享，子进程在调用*clone()*时将获得父进程表的副本。这些复制的描述符引用与父进程中相应描述符相同的打开文件描述符（就像*fork()*和*vfork()*一样）。
- en: The specification of POSIX threads requires that all of the threads in a process
    share the same open file descriptors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX线程的规范要求一个进程中的所有线程共享相同的打开文件描述符。
- en: 'Sharing file system-related information: `CLONE_FS`'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享与文件系统相关的信息：`CLONE_FS`
- en: If the `CLONE_FS` flag is specified, then the parent and the child share file
    system-related information—umask, root directory, and current working directory.
    This means that calls to *umask()*, *chdir()*, or *chroot()* in either process
    will affect the other process. If the `CLONE_FS` flag is not set, then the parent
    and child have separate copies of this information (as with *fork()* and *vfork()*).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The attribute sharing provided by `CLONE_FS` is required by POSIX threads.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Sharing signal dispositions: `CLONE_SIGHAND`'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_SIGHAND` flag is set, then the parent and child share the same
    table of signal dispositions. Using *sigaction()* or *signal()* to change a signal’s
    disposition in either process will affect that signal’s disposition in the other
    process. If the `CLONE_SIGHAND` flag is not set, then signal dispositions are
    not shared; instead, the child gets a copy of the parent’s signal disposition
    table (as with *fork()* and *vfork()*). The `CLONE_SIGHAND` flag doesn’t affect
    the process signal mask and the set of pending signals, which are always distinct
    for the two processes. From Linux 2.6 onward, `CLONE_VM` must also be included
    in *flags* if `CLONE_SIGHAND` is specified.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Sharing of signal dispositions is required by POSIX threads.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Sharing the parent’s virtual memory: `CLONE_VM`'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_VM` flag is set, then the parent and child share the same virtual
    memory pages (as with *vfork()*). Updates to memory or calls to *mmap()* or *munmap()*
    by either process will be visible to the other process. If the `CLONE_VM` flag
    is not set, then the child receives a copy of the parent’s virtual memory (as
    with *fork()*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the same virtual memory is one of the defining attributes of threads,
    and is required by POSIX threads.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread groups: `CLONE_THREAD`'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_THREAD` flag is set, then the child is placed in the same thread
    group as the parent. If this flag not set, the child is placed in its own new
    thread group.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '*Threads groups* were introduced in Linux 2.4 to allow threading libraries
    to support the POSIX threads requirement that all of the threads in a process
    share a single process ID (i.e., *getpid()* in each of the threads should return
    the same value). A thread group is a group of KSEs that share the same *thread
    group identifier* (TGID), as shown in [Figure 28-1](ch28.html#a_thread_group_containing_four_threads
    "Figure 28-1. A thread group containing four threads"). For the remainder of the
    discussion of `CLONE_THREAD`, we’ll refer to these KSEs as *threads*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Since Linux 2.4, *getpid()* returns the calling thread’s TGID. In other words,
    a TGID is the same thing as a process ID.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *clone()* implementation in Linux 2.2 and earlier did not provide `CLONE_THREAD`.
    Instead, LinuxThreads implemented POSIX threads as processes that shared various
    attributes (e.g., virtual memory) but had distinct process IDs. For compatibility
    reasons, even on modern Linux kernels, the LinuxThreads implementation doesn’t
    use the `CLONE_THREAD` flag, so that threads in that implementation continue to
    have distinct process IDs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![A thread group containing four threads](figs/web/28-1_PROCEXEC-thread-group-scale90.png.jpg)Figure 28-1. A
    thread group containing four threads'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Each thread within a thread group is distinguished by a unique *thread identifier*
    (TID). Linux 2.4 introduced a new system call, *gettid()*, to allow a thread to
    obtain its own thread ID (this is the same value as is returned to the thread
    that calls *clone()*). A thread ID is represented using the same data type that
    is used for a process ID, *pid_t*. Thread IDs are unique system-wide, and the
    kernel guarantees that no thread ID will be the same as any process ID on the
    system, except when a thread is the thread group leader for a process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The first thread in a new thread group has a thread ID that is the same as its
    thread group ID. This thread is referred to as the *thread group leader*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The thread IDs that we are discussing here are not the same as the thread IDs
    (the *pthread_t* data type) used by POSIX threads. The latter identifiers are
    generated and maintained internally (in user space) by a POSIX threads implementation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: All of the threads in a thread group have the same parent process ID—that of
    the thread group leader. Only after all of the threads in a thread group have
    terminated is a `SIGCHLD` signal (or other termination signal) sent to that parent
    process. These semantics correspond to the requirements of POSIX threads.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: When a `CLONE_THREAD` thread terminates, no signal is sent to the thread that
    created it using *clone()*. Correspondingly, it is not possible to use *wait()*
    (or similar) to wait for a thread created using `CLONE_THREAD`. This accords with
    POSIX requirements. A POSIX thread is not the same thing as a process, and can’t
    be waited for using *wait()*; instead, it must be joined using *pthread_join()*.
    To detect the termination of a thread created using `CLONE_THREAD`, a special
    synchronization primitive, called a *futex*, is used (see the discussion of the
    `CLONE_PARENT_SETTID` flag below).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: If any of the threads in a thread group performs an *exec()*, then all threads
    other than the thread group leader are terminated (this behavior corresponds to
    the semantics required for POSIX threads), and the new program is execed in the
    thread group leader. In other words, in the new program, *gettid()* will return
    the thread ID of the thread group leader. During an *exec()*, the termination
    signal that this process should send to its parent is reset to `SIGCHLD`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: If one of the threads in a thread group creates a child using *fork()* or *vfork()*,
    then any thread in the group can monitor that child using *wait()* or similar.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: From Linux 2.6 onward, `CLONE_SIGHAND` must also be included in *flags* if `CLONE_THREAD`
    is specified. This corresponds to further POSIX threads requirements; for details,
    see the description of how POSIX threads and signals interact in Section 33.2\.
    (The kernel handling of signals for `CLONE_THREAD` thread groups mirrors the POSIX
    requirements for how the threads in a process should react to signals.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Threading library support: `CLONE_PARENT_SETTID`, `CLONE_CHILD_SETTID`, and
    `CLONE_CHILD_CLEARTID`'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `CLONE_PARENT_SETTID`, `CLONE_CHILD_SETTID`, and `CLONE_CHILD_CLEARTID`
    flags were added in Linux 2.6 to support the implementation of POSIX threads.
    These flags affect how *clone()* treats its *ptid* and *ctid* arguments. `CLONE_PARENT_SETTID`
    and `CLONE_CHILD_CLEARTID` are used in the NPTL threading implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If the `CLONE_PARENT_SETTID` flag is set, then the kernel writes the thread
    ID of the child thread into the location pointed to by *ptid*. The thread ID is
    copied into *ptid* before the memory of the parent is duplicated. This means that,
    even if the `CLONE_VM` flag is not specified, both the parent and the child can
    see the child’s thread ID in this location. (As noted above, the `CLONE_VM` flag
    is specified when creating POSIX threads.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CLONE_PARENT_SETTID` flag exists in order to provide a reliable means
    for a threading implementation to obtain the ID of the new thread. Note that it
    isn’t sufficient to obtain the thread ID of the new thread via the return value
    of *clone()*, like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem is that this code can lead to various race conditions, because the
    assignment occurs only after *clone()* returns. For example, suppose that the
    new thread terminates, and the handler for its termination signal is invoked before
    the assignment to *tid* completes. In this case, the handler can’t usefully access
    *tid*. (Within a threading library, *tid* might be an item in a global bookkeeping
    structure used to track the status of all threads.) Programs that invoke *clone()*
    directly often can be designed to work around this race condition. However, a
    threading library can’t control the actions of the program that calls it. Using
    `CLONE_PARENT_SETTID` to ensure that the new thread ID is placed in the location
    pointed to by *ptid* before *clone()* returns allows a threading library to avoid
    such race conditions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If the `CLONE_CHILD_SETTID` flag is set, then *clone()* writes the thread ID
    of the child thread into the location pointed to by *ctid*. The setting of *ctid*
    is done only in the child’s memory, but this will affect the parent if `CLONE_VM`
    is also specified. Although NPTL doesn’t need `CLONE_CHILD_SETTID`, this flag
    is provided to allow flexibility for other possible threading library implementations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: If the `CLONE_CHILD_CLEARTID` flag is set, then *clone()* zeros the memory location
    pointed to by *ctid* when the child terminates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The *ctid* argument is the mechanism (described in a moment) by which the NPTL
    threading implementation obtains notification of the termination of a thread.
    Such notification is required by the *pthread_join()* function, which is the POSIX
    threads mechanism by which one thread can wait for the termination of another
    thread.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: When a thread is created using *pthread_create()*, NPTL makes a *clone()* call
    in which *ptid* and *ctid* point to the same location. (This is why `CLONE_CHILD_SETTID`
    is not required by NPTL.) The `CLONE_PARENT_SETTID` flag causes that location
    to be initialized with the new thread’s ID. When the child terminates and *ctid*
    is cleared, that change is visible to all threads in the process (since the `CLONE_VM`
    flag is also specified).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The kernel treats the location pointed to by *ctid* as a *futex*, an efficient
    synchronization mechanism. (See the *futex(2)* manual page for further details
    of futexes.) Notification of thread termination can be obtained by performing
    a *futex()* system call that blocks waiting for a change in the value at the location
    pointed to by *ctid*. (Behind the scenes, this is what *pthread_join()* does.)
    At the same time that the kernel clears *ctid*, it also wakes up any kernel scheduling
    entity (i.e., thread) that is blocked performing a futex wait on that address.
    (At the POSIX threads level, this causes the *pthread_join()* call to unblock.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread-local storage: `CLONE_SETTLS`'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_SETTLS` flag is set, then the *tls* argument points to a *user_desc*
    structure describing the thread-local storage buffer to be used for this thread.
    This flag was added in Linux 2.6 to support the NPTL implementation of thread-local
    storage ([Thread-Local Storage](ch31.html#thread-local_storage "Thread-Local Storage")).
    For details of the *user_desc* structure, see the definition and use of this structure
    in the 2.6 kernel sources and the *set_thread_area(2)* manual page.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Sharing System V semaphore undo values: `CLONE_SYSVSEM`'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_SYSVSEM` flag is set, then the parent and child share a single
    list of System V semaphore undo values ([Semaphore Undo Values](ch47.html#semaphore_undo_values
    "Semaphore Undo Values")). If this flag is not set, then the parent and child
    have separate undo lists, and the child’s undo list is initially empty.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The `CLONE_SYSVSEM` flag is available from kernel 2.6 onward, and provides the
    sharing semantics required by POSIX threads.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Per-process mount namespaces: `CLONE_NEWNS`'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From kernel 2.4.19 onward, Linux supports the notion of per-process *mount namespaces*.
    A mount namespace is the set of mount points maintained by calls to *mount()*
    and *umount()*. The mount namespace affects how pathnames are resolved to actual
    files, as well as the operation of system calls such as *chdir()* and *chroot()*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parent and the child share a mount namespace, which means that
    changes to the namespace by one process using *mount()* and *umount()* are visible
    in the other process (as with *fork()* and *vfork()*). A privileged (`CAP_SYS_ADMIN`)
    process may specify the `CLONE_NEWNS` flag so that the child obtains a copy of
    the parent’s mount namespace. Thereafter, changes to the namespace by one process
    are not visible in the other process. (In earlier 2.4.*x* kernels, as well as
    in older kernels, we can consider all processes on the system as sharing a single
    system-wide mount namespace.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Per-process mount namespaces can be used to create environments that are similar
    to *chroot()* jails, but which are more secure and flexible; for example, a jailed
    process can be provided with a mount point that is not visible to other processes
    on the system. Mount namespaces are also useful in setting up virtual server environments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Specifying both `CLONE_NEWNS` and `CLONE_FS` in the same call to *clone()* is
    nonsensical and is not permitted.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the child’s parent the same as the caller’s: `CLONE_PARENT`'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, when we create a new process with *clone()*, the parent of that
    process (as returned by *getppid()*) is the process that calls *clone()* (as with
    *fork()* and *vfork()*). If the `CLONE_PARENT` flag is set, then the parent of
    the child will be the caller’s parent. In other words, `CLONE_PARENT` is the equivalent
    of setting *child.PPID = caller.PPID*. (In the default case, without `CLONE_PARENT`,
    it would be *child.PPID = caller.PID*.) The parent process (*child.PPID*) is the
    process that is signaled when the child terminates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The `CLONE_PARENT` flag is available in Linux 2.4 and later. Originally, it
    was designed to be useful for POSIX threads implementations, but the 2.6 kernel
    pursued an approach to supporting threads (the use of `CLONE_THREAD`, described
    above) that removed the need for this flag.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the child’s PID the same as the parent’s PID: `CLONE_PID` (obsolete)'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_PID` flag is set, then the child has the same process ID as the
    parent. If this flag is not set, then the parent and child have different process
    IDs (as with *fork()* and *vfork()*). Only the system boot process (process ID
    0) may specify this flag; it is used when initializing a multiprocessor system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The `CLONE_PID` flag is not intended for use in user applications. In Linux
    2.6, it has been removed, and is superseded by `CLONE_IDLETASK`, which causes
    the process ID of the new process to be set to 0\. `CLONE_IDLETASK` is available
    only for internal use within the kernel (if specified in the *flags* argument
    of *clone()*, it is ignored). It is used to create the invisible per-CPU *idle
    process*, of which multiple instances may exist on multiprocessor systems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Process tracing: `CLONE_PTRACE` and `CLONE_UNTRACED`'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_PTRACE` flag is set and the calling process is being traced, then
    the child is also traced. For details on process tracing (used by debuggers and
    the *strace* command), refer to the *ptrace(2)* manual page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: From kernel 2.6 onward, the `CLONE_UNTRACED` flag can be set, meaning that a
    tracing process can’t force `CLONE_PTRACE` on this child. The `CLONE_UNTRACED`
    flag is used internally by the kernel in the creation of kernel threads.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Suspending the parent until the child exits or execs: `CLONE_VFORK`'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `CLONE_VFORK` flag is set, then the execution of the parent is suspended
    until the child releases its virtual memory resources via a call to *exec()* or
    _*exit()* (as with *vfork()*).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: New *clone()* flags to support containers
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A number of new *clone() flags* values were added in Linux 2.6.19 and later:
    `CLONE_IO`, `CLONE_NEWIPC`, `CLONE_NEWNET`, `CLONE_NEWPID`, `CLONE_NEWUSER`, and
    `CLONE_NEWUTS`. (See the *clone(2)* manual page for the details of these flags.)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Most of these flags are provided to support the implementation of *containers*
    ([Bhattiprolu et al., 2008]). A container is a form of lightweight virtualization,
    whereby groups of processes running on the same kernel can be isolated from one
    another in environments that appear to be separate machines. Containers can also
    be nested, one inside the other. The containers approach contrasts with full virtualization,
    where each virtualized environment is running a distinct kernel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: To implement containers, the kernel developers had to provide a layer of indirection
    within the kernel around each of the global system resources—such as process IDs,
    the networking stack, the identifiers returned by *uname()*, System V IPC objects,
    and user and group ID namespaces—so that each container can provide its own instance
    of these resources.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various possible uses for containers, including the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: controlling allocation of resources on the system, such as network bandwidth
    or CPU time (e.g., one container might be granted 75% of the CPU time, while the
    other gets 25%);
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: providing multiple lightweight virtual servers on a single host machine;
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: freezing a container, so that execution of all processes in the container is
    suspended, later to be restarted, possibly after migrating to a different machine;
    and
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: allowing an application’s state to be dumped (checkpointed) and then later restored
    (perhaps after an application crash, or a planned or unplanned system shutdown)
    to continue computation from the time of the checkpoint.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of *clone() flags*
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Roughly, we can say that a *fork()* corresponds to a *clone()* call with *flags*
    specified as just `SIGCHLD`, while a *vfork()* corresponds to a *clone()* call
    specifying *flags* as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since version 2.3.3, the *glibc* wrapper *fork()* provided as part of the NPTL
    threading implementation bypasses the kernel’s *fork()* system call and invokes
    *clone()*. This wrapper function invokes any fork handlers that have been established
    by the caller using *pthread_atfork()* (see [Threads and Process Control](ch33.html#threads_and_process_control
    "Threads and Process Control")).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The LinuxThreads threading implementation uses *clone()* (with just the first
    four arguments) to create threads by specifying *flags* as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The NPTL threading implementation uses *clone()* (with all seven arguments)
    to create threads by specifying *flags* as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Extensions to *waitpid()* for Cloned Children
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To wait for children produced by *clone()*, the following additional (Linux-specific)
    values can be included in the *options* bit-mask argument for *waitpid()*, *wait3()*,
    and *wait4()*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`__WCLONE`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: If set, then wait for *clone* children only. If not set, then wait for *nonclone*
    children only. In this context, a *clone* child is one that delivers a signal
    other than `SIGCHLD` to its parent on termination. This bit is ignored if `__WALL`
    is also specified.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`__WALL` (since Linux 2.4)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Wait for all children, regardless of type (*clone* or *nonclone*).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '`__WNOTHREAD` (since Linux 2.4)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: By default, the wait calls wait not only for children of the calling process,
    but also for children of any other processes in the same thread group as the caller.
    Specifying the `__WNOTHREAD` flag limits the wait to children of the calling process.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: These flags can’t be used with *waitid()*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Speed of Process Creation
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr "Table 28-3. Time
    required to create 100,000 processes using fork(), vfork(), and clone()") shows
    some speed comparisons for different methods of process creation. The results
    were obtained using a test program that executed a loop that repeatedly created
    a child process and then waited for it to terminate. The table compares the various
    methods using three different process memory sizes, as indicated by the *Total
    virtual memory* value. The differences in memory size were simulated by having
    the program *malloc()* additional memory on the heap prior to performing the timings.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Values for process size (*Total virtual memory*) in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()") are taken from the *VSZ* value displayed by the command *ps -o “pid
    vsz cmd”*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Table 28-3. Time required to create 100,000 processes using *fork()*, *vfork()*,
    and *clone()*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '| Method of process creation | Total Virtual Memory |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| 1.70 MB | 2.70 MB | 11.70 MB |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| Time (secs) | Rate | Time (secs) | Rate | Time (secs) | Rate |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| *fork()* | `22.27 (7.99)` | `4544` | `26.38 (8.98)` | `4135` | `126.93(52.55)`
    | `1276` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| *vfork()* | `3.52 (2.49)` | `28955` | `3.55 (2.50)` | `28621` | `3.53 (2.51)`
    | `28810` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| *clone()* | `2.97 (2.14)` | `34333` | `2.98 (2.13)` | `34217` | `2.93 (2.10)`
    | `34688` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| *fork() + exec()* | `135.72(12.39)` | `764` | `146.15(16.69)` | `719` | `260.34(61.86)`
    | `435` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| *vfork() + exec()* | `107.36 (6.27)` | `969` | `107.81 (6.35)` | `964` |
    `107.97 (6.38)` | `960` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: 'For each process size, two types of statistics are provided in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()"):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The first statistic consists of two time measurements. The main (larger) measurement
    is the total elapsed (real) time to perform 100,000 process creation operations.
    The second time, shown in parentheses, is the CPU time consumed by the parent
    process. Since these tests were run on an otherwise unloaded machine, the difference
    between the two time values represents the total time consumed by child processes
    created during the test.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second statistic for each test shows the rate at which processes were created
    per (real) second.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics shown are the average of 20 runs for each case, and were obtained
    using kernel 2.6.27 running on an x86-32 system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The first three data rows show times for simple process creation (without execing
    a new program in the child). In each case, the child processes exit immediately
    after they are created, and the parent waits for each child to terminate before
    creating the next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The first row contains values for the *fork()* system call. From the data, we
    can see that as a process gets larger, *fork()* takes longer. These time differences
    show the additional time required to duplicate increasingly large page tables
    for the child and mark all data, heap, and stack segment page entries as read-only.
    (No *pages* are copied, since the child doesn’t modify its data or stack segments.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The second data row provides the same statistics for *vfork()*. We see that
    as the process size increases, the times remain the same—because no page tables
    or pages are copied during a *vfork()*, the virtual memory size of the calling
    process has no effect. The difference between the *fork()* and *vfork()* statistics
    represents the total time required for copying process page tables in each case.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Small variations in the *vfork()* and *clone()* values in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()") are due to sampling errors and scheduling variations. Even when
    creating processes up to 300 MB in size, times for these two system calls remained
    constant.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The third data row shows statistics for process creation using *clone()* with
    the following flags:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first two of these flags emulate the behavior of *vfork()*. The remaining
    flags specify that the parent and child should share their file-system attributes
    (umask, root directory, and current working directory), table of signal dispositions,
    and table of open file descriptors. The difference between the *clone()* and *vfork()*
    data represents the small amount of additional work performed in *vfork()* to
    copy this information into the child process. The cost of copying file-system
    attributes and the table of signal dispositions is constant. However, the cost
    of copying the table of open file descriptors varies according to the number of
    descriptors. For example, opening 100 file descriptors in the parent process raised
    the *vfork()* real time (in the first column of the table) from 3.52 to 5.04 seconds,
    but left times for *clone()* unaffected.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The timings for *clone()* are for the *glibc clone()* wrapper function, rather
    than direct calls to *sys_clone()*. Other tests (not summarized here) revealed
    negligible timing differences between using *sys_clone()* and calling *clone()*
    with a child function that immediately exited.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between *fork()* and *vfork()* are quite marked. However, the
    following points should be kept in mind:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The final data column, where *vfork()* is more than 30 times faster than *fork()*,
    corresponds to a large process. Typical processes would lie somewhere closer to
    the first two columns of the table.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the times required for process creation are typically much smaller than
    those required for an *exec()*, the differences are much less marked if a *fork()*
    or *vfork()* is followed by an *exec()*. This is illustrated by the final pair
    of data rows in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()"), where each child performs an *exec()*, rather than immediately
    exiting. The program execed was the *true* command (`/bin/true`, chosen because
    it produces no output). In this case, we see that the relative differences between
    *fork()* and *vfork()* are much lower.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, the data shown in [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()") doesn’t reveal the full cost of an *exec()*, because the child execs
    the same program in each loop of the test. As a result, the cost of disk I/O to
    read the program into memory is essentially eliminated, because the program will
    be read into the kernel buffer cache on the first *exec()*, and then remain there.
    If each loop of the test execed a different program (e.g., a differently named
    copy of the same program), then we would observe a greater cost for an *exec()*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Effect of *exec()* and *fork()* on Process Attributes
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A process has numerous attributes, some of which we have already described
    in earlier chapters, and others that we explore in later chapters. Regarding these
    attributes, two questions arise:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: What happens to these attributes when a process performs an *exec()*?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which attributes are inherited by a child when a *fork()* is performed?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 28-4](ch28.html#effect_of_exec_open_parenthesis_clos "Table 28-4. Effect
    of exec() and fork() on process attributes") summarizes the answers to these questions.
    The *exec()* column indicates which attributes are preserved during an *exec()*.
    The *fork()* column indicates which attributes are inherited (or in some cases,
    shared) by a child after *fork()*. Other than the attributes indicated as being
    Linux-specific, all listed attributes appear in standard UNIX implementations,
    and their handling during *exec()* and *fork()* conforms to the requirements of
    SUSv3.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Table 28-4. Effect of *exec()* and *fork()* on process attributes
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '| Process attribute | *exec()* | *fork()* | Interfaces affecting attribute;
    additional notes |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| Process address space |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| Text segment | No | Shared | Child process shares text segment with parent.
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| Stack segment | No | Yes | Function entry/exit; *alloca()*, *longjmp()*,
    *siglongjmp()*. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| Data and heap segments | No | Yes | *brk()*, *sbrk()*. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| Environment variables | Seenotes | Yes | *putenv()*, *setenv()*; direct modification
    of *environ*. Overwritten by *execle()* and *execve()* and preserved by remaining
    *exec()* calls. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| Memory mappings | No | Yes; see notes | *mmap()*, *munmap()*. A mapping’s
    `MAP_NORESERVE` flag is inherited across *fork()*. Mappings that have been marked
    with madvise(*MADV_DONTFORK*) are not inherited across *fork()*. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| Memory locks | No | No | *mlock()*, *munlock()*. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| Process identifiers and credentials |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| Process ID | Yes | No |   |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| Parent process ID | Yes | No |   |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| Process group ID | Yes | Yes | *setpgid()*. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| Session ID | Yes | Yes | *setsid()*. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| Real IDs | Yes | Yes | *setuid()*, *setgid()*, and related calls. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| Effective and saved set IDs | Seenotes | Yes | *setuid()*, *setgid()*, and
    related calls. [Chapter 9](ch09.html "Chapter 9. Process Credentials") explains
    how *exec()* affects these IDs. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| Supplementary group IDs | Yes | Yes | *setgroups()*, *initgroups()*. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| Files, file I/O, and directories |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| Open file descriptors | Seenotes | Yes | *open()*, *close()*, *dup()*, *pipe()*,
    *socket()*, and so on. File descriptors are preserved across *exec()* unless marked
    close-on-exec. Descriptors in child and parent refer to same open file descriptions;
    see Section 5.4. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| Close-on-exec flag | Yes (if off) | Yes | *fcntl(F_SETFD)*. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| File offsets | Yes | Shared | *lseek()*, *read()*, *write()*, *readv()*,
    *writev()*. Child shares file offsets with parent. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| Open file status flags | Yes | Shared | *open(), fcntl(F_SETFL)*. Child shares
    open file status flags with parent. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| Asynchronous I/O operations | Seenotes | No | *aio_read()*, *aio_write()*,
    and related calls. Outstanding operations are canceled during an *exec()*. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| Directory streams | No | Yes; see notes | *opendir()*, *readdir()*. SUSv3
    states that child gets a copy of parent’s directory streams, but these copies
    may or may not share the directory stream position. On Linux, the directory stream
    position is not shared. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| File system |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| Current working directory | Yes | Yes | *chdir()*. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| Root directory | Yes | Yes | *chroot()*. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| File mode creation mask | Yes | Yes | *umask()*. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| Signals |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| Signal dispositions | See notes | Yes | *signal()*, *sigaction()*. During
    an *exec()*, signals with dispositions set to default or ignore are unchanged;
    caught signals revert to their default dispositions. See Section 27.5. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| Signal mask | Yes | Yes | Signal delivery, *sigprocmask()*, *sigaction()*.
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| Pending signal set | Yes | No | Signal delivery; *raise()*, *kill()*, *sigqueue()*.
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| Alternate signal stack | No | Yes | *sigaltstack()*. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| Timers |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| Interval timers | Yes | No | *setitimer()*. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| Timers set by *alarm()* | Yes | No | *alarm()*. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| POSIX timers | No | No | *timer_create()* and related calls. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| POSIX threads |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| Threads | No | See notes | During *fork()*, only calling thread is replicated
    in child. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| Thread cancelability state and type | No | Yes | After an *exec()*, the cancelability
    type and state are reset to `PTHREAD_CANCEL_ENABLE` and `PTHREAD_CANCEL_DEFERRED`,
    respectively |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| Mutexes and condition variables | No | Yes | See [Threads and Process Control](ch33.html#threads_and_process_control
    "Threads and Process Control") for details of the treatment of mutexes and other
    thread resources during *fork()*. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| Priority and scheduling |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| Nice value | Yes | Yes | *nice()*, *setpriority()*. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| Scheduling policy and priority | Yes | Yes | *sched_setscheduler()*, *sched_setparam()*.
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| Resources and CPU time |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| Resource limits | Yes | Yes | *setrlimit()*. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| Process and child CPU times | Yes | No | As returned by *times()*. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| Resource usages | Yes | No | As returned by *getrusage()*. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| Interprocess communication |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| System V shared memory segments | No | Yes | *shmat()*, *shmdt()*. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| POSIX shared memory | No | Yes | *shm_open()* and related calls. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| POSIX message queues | No | Yes | *mq_open()* and related calls. Descriptors
    in child and parent refer to same open message queue descriptions. A child doesn’t
    inherit its parent’s message notification registrations. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| POSIX named semaphores | No | Shared | *sem_open()* and related calls. Child
    shares references to same semaphores as parent. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| POSIX unnamed semaphores | No | See notes | *sem_init()* and related calls.
    If semaphores are in a shared memory region, then child shares semaphores with
    parent; otherwise, child has its own copy of the semaphores. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| System V semaphore adjustments | Yes | No | *semop()*. See Section 47.8.
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| File locks | Yes | See notes | *flock()*. Child inherits a reference to the
    same lock as parent. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| Record locks | Seenotes | No | *fcntl(F_SETLK)*. Locks are preserved across
    *exec()* unless a file descriptor referring to the file is marked close-on-exec;
    see [Lock Limits and Performance](ch55.html#lock_limits_and_performance "Lock
    Limits and Performance"). |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| Miscellaneous |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| Locale settings | No | Yes | *setlocale()*. As part of C run-time initialization,
    the equivalent of *setlocale(LC_ALL, “C”)* is executed after a new program is
    execed. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| Floating-point environment | No | Yes | When a new program is execed, the
    state of the floating-point environment is reset to the default; see *fenv(3)*.
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| Controlling terminal | Yes | Yes |   |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| Exit handlers | No | Yes | *atexit()*, *on_exit()*. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| Linux-specific |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| File-system IDs | Seenotes | Yes | *setfsuid()*, *setfsgid()*. These IDs
    are also changed any time the corresponding effective IDs are changed. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| *timerfd* timers | Yes | See notes | *timerfd_create()*; child inherits file
    descriptors referring to same timers as parent. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| Capabilities | Seenotes | Yes | *capset()*. The handling of capabilities
    during an *exec()* is described in Section 39.5. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| Capability bounding set | Yes | Yes |   |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| Capabilities *securebits* flags | Seenotes | Yes | All *securebits* flags
    are preserved during an *exec()* except `SECBIT_KEEP_CAPS`, which is always cleared.
    |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| CPU affinity | Yes | Yes | *sched_setaffinity()*. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_RESET_ON_FORK` | Yes | No | See [Modifying and Retrieving Policies
    and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr "Modifying
    and Retrieving Policies and Priorities"). |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| Allowed CPUs | Yes | Yes | See *cpuset(7)*. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| Allowed memory nodes | Yes | Yes | See *cpuset(7)*. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| Memory policy | Yes | Yes | See *set_mempolicy(2)*. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| File leases | Yes | See notes | *fcntl(F_SETLEASE)*. Child inherits a reference
    to the same lease as parent. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| Directory change notifications | Yes | No | The *dnotify* API, available
    via *fcntl(F_NOTIFY)*. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| *prctl(PR_SET_DUMPABLE)* | Seenotes | Yes | During an *exec()*, the `PR_SET_DUMPABLE`
    flag is set, unless execing a set-user-ID or set-group-ID program, in which case
    it is cleared. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| *prctl(PR_SET_PDEATHSIG)* | Yes | No |   |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| *prctl(PR_SET_NAME)* | No | Yes |   |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| `oom_adj` | Yes | Yes | See Section 49.9. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| `coredump_filter` | Yes | Yes | See Section 22.1. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When process accounting is enabled, the kernel writes an accounting record to
    a file for each process that terminates on the system. This record contains statistics
    on the resources used by the process.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Like *fork()*, the Linux-specific *clone()* system call creates a new process,
    but allows finer control over which attributes are shared between the parent and
    child. This system call is used primarily for implementing threading libraries.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: We compared the speed of process creation using *fork()*, *vfork()*, and *clone()*.
    Although *vfork()* is faster than *fork()*, the time difference between these
    system calls is small by comparison with the time required for a child process
    to do a subsequent *exec()*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: When a child process is created via *fork()*, it inherits copies of (or in some
    cases shares) certain process attributes from its parent, while other process
    attributes are not inherited. For example, a child inherits copies of its parent’s
    file descriptor table and signal dispositions, but doesn’t inherit its parent’s
    interval timers, record locks, or set of pending signals. Correspondingly, when
    a process performs an *exec()*, certain process attributes remain unchanged, while
    others are reset to defaults. For example, the process ID remains the same, file
    descriptors remain open (unless marked close-on-exec), interval timers are preserved,
    and pending signals remain pending, but handled signals are reset to their default
    disposition and shared memory segments are detached.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in Section 24.6\. [Chapter 17](ch17.html
    "Chapter 17. Access Control Lists") of [Frisch, 2002] describes the administration
    of process accounting, as well as some of the variations across UNIX implementations.
    [Bovet & Cesati, 2005] describes the implementation of the *clone()* system call.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program to see how fast the *fork()* and *vfork()* system calls are
    on your system. Each child process should immediately exit, and the parent should
    *wait()* on each child before creating the next. Compare the relative differences
    for these two system calls with those of [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "Table 28-3. Time required to create 100,000 processes using fork(), vfork(),
    and clone()"). The shell built-in command *time* can be used to measure the execution
    time of a program.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
