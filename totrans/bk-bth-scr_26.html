<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch23" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch23">
<span class="cn"><span aria-label=" Page 267. " epub:type="pagebreak" id="pg_267" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">23</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">RECURSION</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">This chapter covers one of my favorite topics: recursion, or code that calls itself. I’ll start with a much more detailed definition, but the only way to truly understand this concept is through examples, so we’ll step through multiple instances of Batch recursion. One will be the calculation of a factorial, a truly classic example, with another being the conversion of a decimal to a hexadecimal. The last example will be something that’s quintessentially Batch: a recursive search through directories and their subdirectories. Then you’ll learn an important limitation to be aware of before you write code that calls itself.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-156"/><span aria-label=" Page 268. " epub:type="pagebreak" id="pg_268" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Defining Recursion</span></h3>
<p class="tni"><i class="calibre6">Recursion</i> is the technique where a bit of code invokes or calls itself. You can do this in the vast majority of coding languages. In a more object-oriented language, a command inside a method calls that particular method. Even in a procedural language like COBOL, a command inside a program calls that particular program. Batch is no different. In recursive Batch, a routine typically contains a <span class="sans_thesansmonocd_w5regular_">call</span> command that calls that particular routine. Less frequently, a bat file contains a <span class="sans_thesansmonocd_w5regular_">call</span> command that calls that particular bat file.</p>
<p class="tx">There’s a simple logical beauty to recursion that can best be summed up with one word: <i class="calibre6">elegance</i>. I was trained as a mathematician before becoming a coder, and in both disciplines elegance is the greatest praise, and <i class="calibre6">functional</i> is a back-handed compliment at best, whether it be in reference to a proof in the former discipline or a program in the latter. There are many words and phrases of compliment for a piece of code—well-constructed, slick, nifty, smart, well-thought-out—but elegant stands alone as the best adjective a coder can hear. But when someone calls your code functional, the conceit is “It’ll work, but it’s supremely ugly, even logically offensive, and I could’ve done far better.” In the Venn diagram of descriptive terms for code and supermodels, the intersection set is a set of one: elegant.</p>
<p class="tx">If your first instinct is that recursion sounds like the makings of an endless loop, your caution is prudent. If the call is done unconditionally, yes, the result will be an endless loop (or a crash when the call stack blows up). Recursion must have some sort of conditional logic, usually an <span class="sans_thesansmonocd_w5regular_">if</span> command, that’ll execute code for either the recursive case or the base case.</p>
<p class="tx">The <i class="calibre6">recursive case</i> performs the recursive call, and the <i class="calibre6">base case</i> does not. A properly designed recursive call will get you one step closer to the base case. Several executions of the recursive case usually lead to a call that executes the base case, starting the process of backing out of the recursive calls. The best way to understand this is through examples (to come), stepping through each recursive call and keeping track of the state of each variable for each call, often with pencil and paper.</p>
<p class="tx">Recursion is quite different from the <span class="sans_thesansmonocd_w5regular_">while</span> and <span class="sans_thesansmonocd_w5regular_">do...while</span> commands introduced in <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span>. The <span class="sans_thesansmonocd_w5regular_">goto</span> command branched backward in the code to re-execute some code that just executed, but nothing was being called; there was no intent of control being returned. Instead, the technique of recursion calls or invokes the code of which it’s a part.</p>
<p class="tx">Recursion is the coding equivalent of the Ouroboros, the mythological serpent or dragon eating its own tail (see <a href="#fig23-1" class="calibre3">Figure 23-1</a>). The beast has convergent roots dating back to ancient China, Egypt, and Greece. It often symbolizes “eternal cyclic renewal,” infinity, eternity, and even alchemy. I’ve long viewed it as an excellent metaphor for code invoking itself, even before knowing it by name.</p>
<span aria-label=" Page 269. " epub:type="pagebreak" id="pg_269" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img1" height="587" id="fig23-1" src="../images/fig23-1.jpg" width="548"/>
<figcaption><p class="cap"><span class="futura_std_book_oblique_i_">Figure 23-1: A representation of the Ouroboros</span></p></figcaption>
</figure>
<p class="tx">Salvador Dali expressed his typically atypical interpretation of the creature in his work <i class="calibre6">The Ouroboros</i>. It’s certainly presumptuous, but when I’m done coding a bit of recursive logic, I feel a very small affinity to an artist such as Dali, imagining the pride he must’ve felt in sharing his works with the world. A great painter rightly wants to showcase his works for others to view as a preeminent chef surely looks forward to diners sampling her plat du jour. Instead of a gallery showing or a restaurant opening, I anticipate the date of the next code review with my peers. I’m embellishing to a degree (and not comfortable admitting to what degree), but I do take pride in a fine bit of recursion, and I hope that you do or will as well.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h" id="sec2"><span id="h1-157"/><span class="sans_futura_std_bold_b_">Factorials</span></h3>
<p class="tni">The classic example of recursion in any math or programming text is the factorial, and I see no reason to counter tradition. The factorial of <i class="calibre6">n</i>, represented by <i class="calibre6">n</i>!, is <i class="calibre6">n</i> × (<i class="calibre6">n</i> – 1) × (<i class="calibre6">n</i> – 2) ... 2 × 1, or more informally, the product of the successive multiplication of the integer and all the integers less than it down to 1.</p>
<blockquote class="calibre8">
<p class="warning"><span class="sans_dogma_ot_bold_b_1">NOTE</span></p>
</blockquote>
<p class="warning-txt"><i class="calibre6">When asking a mathematician how old he was turning, I received the reply, “my last factorial birthday.” He was nearing 24 and didn’t expect to make it to 120 or 5!. I was once guilty of decorating a 30th birthday cake with 6! / 4!. Factorials can be fun as well as useful, but I digress.</i></p>
<p class="tx">The factorial of 4 is the product of 4 and the factorial of 3, which is the product of 3 and the factorial of 2, which is the product of 2 and the factorial of 1, which is simply 1. The pattern begs for recursion. A routine that accepts a number as input and returns its factorial can multiply that number by the factorial of the number one less than it. And, the best way to find that second factorial is for the routine to call itself. When finding the factorial of an integer greater than 1, we invoke the recursive case, and when finding the factorial of 1, we have satisfied the base case and elegantly return the number 1. That’s recursion! Now we must turn this into code.</p>
<p class="tx"><span aria-label=" Page 270. " epub:type="pagebreak" id="pg_270" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">:Factorial</span> routine accepts a numerical input parameter and passes back the number’s factorial as the variable name we pass in the second parameter. Before getting to the routine itself, the following call to it populates <span class="sans_thesansmonocd_w5regular_">factorial</span> with the factorial of <span class="sans_thesansmonocd_w5regular_">4</span>:</p>
<pre class="pre"><code class="calibre11">call :Factorial 4 factorial
&gt; con echo The Factorial of 4 is %factorial%.
</code></pre>
<p class="tx">You might be expecting a more complex routine, but here it is in its simplicity. Take note of the <span class="sans_thesansmonocd_w5regular_">call</span> command recursively invoking the <span class="sans_thesansmonocd_w5regular_">:Factorial</span> routine:</p>
<pre class="pre"><code class="calibre11">:Factorial
 if %~1 equ 1 (
    set %~2=1
 ) else (
    set /A nbrLessOne = %~1 - 1
    call :Factorial !nbrLessOne! lessOneFact
    set /A %~2 = %~1 * !lessOneFact!
 )
 goto :eof
</code></pre>
<p class="tx">If the input parameter, <span class="sans_thesansmonocd_w5regular_">%~1</span>, equals <span class="sans_thesansmonocd_w5regular_">1</span>, the <span class="sans_thesansmonocd_w5regular_">if</span> command asserts that the base case is satisfied and we set the second parameter, <span class="sans_thesansmonocd_w5regular_">%~2</span>, to <span class="sans_thesansmonocd_w5regular_">1</span>, because the factorial of 1 is 1, and we are done.</p>
<p class="tx">If the integer is greater than <span class="sans_thesansmonocd_w5regular_">1</span>, control goes to the code block under the <span class="sans_thesansmonocd_w5regular_">else</span> keyword, where the logic for the recursive case executes. We next find the number one less than our input value: <span class="sans_thesansmonocd_w5regular_">nbrLessOne</span>. To determine the factorial of <span class="sans_thesansmonocd_w5regular_">nbrLessOne</span>, we recursively call the same exact routine that we are currently in and retrieve the result as the <span class="sans_thesansmonocd_w5regular_">lessOneFact</span> variable. Finally, we multiply the routine’s input value by the factorial returned from the recursive call, assign the result to the second parameter, <span class="sans_thesansmonocd_w5regular_">%~2</span>, which we return to the calling code, and we are done.</p>
<p class="tx">This top-down reading of the routine is helpful and a great first step, but it glosses over what happens in the successive recursive calls. To really understand what’s happening, let’s explore the logic again by stepping through a sample execution with the input parameter of <span class="sans_thesansmonocd_w5regular_">4</span>.</p>
<p class="tx">Because <span class="sans_thesansmonocd_w5regular_">4</span> is greater than <span class="sans_thesansmonocd_w5regular_">1</span>, we immediately jump down to the <span class="sans_thesansmonocd_w5regular_">else</span> code block, find the prior number of <span class="sans_thesansmonocd_w5regular_">3</span>, and do the recursive call. Let’s put a breadcrumb down and come back to it later.</p>
<p class="tx">The second time through the routine, the input parameter is <span class="sans_thesansmonocd_w5regular_">3</span>, so we call recursively again to find the factorial of <span class="sans_thesansmonocd_w5regular_">2</span>. Place a second breadcrumb at the <span class="sans_thesansmonocd_w5regular_">call</span> command.</p>
<p class="tx">The third time through the routine, the input is <span class="sans_thesansmonocd_w5regular_">2</span>, so we perform yet another recursive call, this time to find the factorial of the number <span class="sans_thesansmonocd_w5regular_">1</span>. Place a third breadcrumb.</p>
<p class="tx">Finally, the <span class="sans_thesansmonocd_w5regular_">if</span> command is true, the base case is satisfied, and we return the value <span class="sans_thesansmonocd_w5regular_">1</span> as the second parameter, <span class="sans_thesansmonocd_w5regular_">%~2</span>.</p>
<p class="tx">Now we can pick up the breadcrumbs in reverse order as we find our way back to the original call. At the third breadcrumb we get back the <span aria-label=" Page 271. " epub:type="pagebreak" id="pg_271" role="doc-pagebreak"/>factorial of <span class="sans_thesansmonocd_w5regular_">1</span> in the <span class="sans_thesansmonocd_w5regular_">lessOneFact</span> variable, and we multiply it by that call’s input parameter, <span class="sans_thesansmonocd_w5regular_">%~1</span>, which is <span class="sans_thesansmonocd_w5regular_">2</span>. We assign the product of <span class="sans_thesansmonocd_w5regular_">2</span> to the return parameter and pass it back.</p>
<p class="tx">We now find ourselves back at the second breadcrumb where we multiply that call’s input parameter of <span class="sans_thesansmonocd_w5regular_">3</span> by <span class="sans_thesansmonocd_w5regular_">lessOneFact</span>, which holds the just returned value of <span class="sans_thesansmonocd_w5regular_">2</span>. The routine passes back the result of <span class="sans_thesansmonocd_w5regular_">6</span>, or the factorial of <span class="sans_thesansmonocd_w5regular_">3</span>, to the site of the first breadcrumb.</p>
<p class="tx">The logic multiplies the original input parameter of <span class="sans_thesansmonocd_w5regular_">4</span> by <span class="sans_thesansmonocd_w5regular_">lessOneFact</span>, which now holds <span class="sans_thesansmonocd_w5regular_">6</span>. We return the result of <span class="sans_thesansmonocd_w5regular_">24</span> to the original call. That last point is subtle and critical: we aren’t passing the result back to one of the recursive calls in the routine; we’re finally passing the result back to the original call. And we are done.</p>
<p class="tx">The concept may be a bit confusing at first, and there is no shame in rereading the last few lines more than once. Curiously, the variables seem to have multiple states at one time. The <span class="sans_thesansmonocd_w5regular_">nbrLessOne</span> and <span class="sans_thesansmonocd_w5regular_">lessOneFact</span> variables contain three different values each, the input parameter took on four values, and we assigned the output parameter four times. Batch accomplishes this with the <i class="calibre6">call stack</i>. Before performing a recursive call, it stores pertinent data on the call stack, and it can do this for multiple calls.</p>
<p class="tx">The interpreter places all active variables on the call stack before it does the first recursive call. During that call, the variables may take on new values that it again places atop the call stack before the next recursive call. When control returns from each call, the interpreter simply restores the corresponding values from the top of the call stack and continues processing.</p>
<p class="tx">By the way, there are means to calculate factorials without recursion, but they are uninspired and far less enjoyable.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="h" id="sec3"><span id="h1-158"/><span class="sans_futura_std_bold_b_">Decimal to Hexadecimal</span></h3>
<p class="tni">Before converting a decimal number (base 10) to a hexadecimal number (base 16) with recursive Batch code, let’s consider how to do it mathematically. For decimal numbers less than 256, start by dividing the number by 16, leaving a quotient and a remainder. These two numbers will be the two digits of the hexadecimal number, with one catch. Either number is in the range from 0 to 15, but we want a single character. The numbers 0 through 9 are fine, but if the value is a two-digit decimal number, we must map it to a hexadecimal digit. That is, 10 maps to A, 11 maps to B, and so on, up to 15 mapping to F.</p>
<p class="tx">If the decimal number is between 256 and 4,095, it maps to a three-digit hexadecimal number. This requires two rounds of division. The remainder of the first division provides the rightmost hexadecimal digit, and we divide the quotient again by 16. The remainder becomes the second rightmost hexadecimal digit, and the new quotient is the leading hexadecimal digit. As the numbers get larger, the same pattern holds; for instance, a six-digit hexadecimal number requires five divisions.</p>
<p class="tx">This is exactly the type of pattern that also screams out for recursion. The following Batch routine converts a decimal number into a hexadecimal <span aria-label=" Page 272. " epub:type="pagebreak" id="pg_272" role="doc-pagebreak"/>number. Similar to the factorials example there are two parameters: the first is the decimal input, and the second is the variable containing the hexadecimal output. Here’s the code:</p>
<pre class="pre"><code class="calibre11">:GetHex
 set hexChars=0123456789ABCDEF
 set /A quotient = %~1 / 16
 set /A remainder = %~1 %% 16
 if %quotient% equ 0 (
    set %~2=!hexChars:~%remainder%,1!
 ) else (
    call :GetHex %quotient% recur
    set %~2=!recur!!hexChars:~%remainder%,1!
 )
 goto :eof
</code></pre>
<p class="tx">I’m storing the 16 hexadecimal characters in <span class="sans_thesansmonocd_w5regular_">hexChars</span> for later use. The routine divides the decimal number by <span class="sans_thesansmonocd_w5regular_">16</span>, giving us <span class="sans_thesansmonocd_w5regular_">quotient</span>, while modulo division by <span class="sans_thesansmonocd_w5regular_">16</span> gives us <span class="sans_thesansmonocd_w5regular_">remainder</span>. If the <span class="sans_thesansmonocd_w5regular_">quotient</span> is <span class="sans_thesansmonocd_w5regular_">0</span>, the result is a single character. This is the base case. We substring the appropriate character out of <span class="sans_thesansmonocd_w5regular_">hexChars</span>, using <span class="sans_thesansmonocd_w5regular_">remainder</span> as the offset. Notice that <span class="sans_thesansmonocd_w5regular_">0</span> maps to <span class="sans_thesansmonocd_w5regular_">0</span>, <span class="sans_thesansmonocd_w5regular_">1</span> maps to <span class="sans_thesansmonocd_w5regular_">1</span>, and so on, until <span class="sans_thesansmonocd_w5regular_">9</span> maps to <span class="sans_thesansmonocd_w5regular_">9</span>. Then <span class="sans_thesansmonocd_w5regular_">10</span> maps to <span class="sans_thesansmonocd_w5regular_">A</span>, <span class="sans_thesansmonocd_w5regular_">11</span> maps to <span class="sans_thesansmonocd_w5regular_">B</span>, and, ultimately, <span class="sans_thesansmonocd_w5regular_">15</span> maps to <span class="sans_thesansmonocd_w5regular_">F</span>. We return this single digit as the value of the second parameter to complete the base case.</p>
<p class="tx">The recursive case occurs when <span class="sans_thesansmonocd_w5regular_">quotient</span> is greater than <span class="sans_thesansmonocd_w5regular_">0</span>. The <span class="sans_thesansmonocd_w5regular_">quotient</span> variable needs to be converted further, so we perform a recursive call of <span class="sans_thesansmonocd_w5regular_">:GetHex</span> and get back its hexadecimal value in the <span class="sans_thesansmonocd_w5regular_">recur</span> variable, which can be one to many characters. We assign the return parameter a concatenation of this value and the same mapping of the <span class="sans_thesansmonocd_w5regular_">remainder</span> to a hexadecimal digit that we just witnessed.</p>
<p class="tx">(By the way, notice the two concatenated values. We resolve the <span class="sans_thesansmonocd_w5regular_">recur</span> variable with exclamation marks because it’s assigned in the code block as part of the <span class="sans_thesansmonocd_w5regular_">call</span> command. The rightmost byte is resolved from this text: <span class="sans_thesansmonocd_w5regular_">!hexChars:~%remainder%,1!</span>. This time I’m employing delayed expansion with the exclamation marks after first resolving the offset, or <span class="sans_thesansmonocd_w5regular_">remainder</span>, with percent signs.)</p>
<p class="tx">To really understand this logic, let’s step through it to convert 700 to a hexadecimal number. First, let’s do it mathematically: 700 / 16 = 43 with a remainder of 12. The 12 maps to the hexadecimal digit C, which will be the rightmost byte of the final result. Next, 43 / 16 = 2 with a remainder of 11, which maps to the next byte from the right in the final result, B. The quotient of 2 is a one-digit number, so it represents itself. The result is the hexadecimal number, 2BC.</p>
<p class="tx">The following <span class="sans_thesansmonocd_w5regular_">call</span> command returns the value <span class="sans_thesansmonocd_w5regular_">2BC</span> as the <span class="sans_thesansmonocd_w5regular_">hexVal</span> variable:</p>
<pre class="pre"><code class="calibre11">call :GetHex 700 hexVal</code></pre>
<p class="tx">Taking this step by step, since the input parameter is <span class="sans_thesansmonocd_w5regular_">700</span>, the <span class="sans_thesansmonocd_w5regular_">quotient</span> variable is <span class="sans_thesansmonocd_w5regular_">43</span>, and the <span class="sans_thesansmonocd_w5regular_">remainder</span> variable is <span class="sans_thesansmonocd_w5regular_">12</span>. Because <span class="sans_thesansmonocd_w5regular_">quotient</span> isn’t <span class="sans_thesansmonocd_w5regular_">0</span>, the <span aria-label=" Page 273. " epub:type="pagebreak" id="pg_273" role="doc-pagebreak"/>recursive case logic executes. The interpreter puts the <span class="sans_thesansmonocd_w5regular_">remainder</span> of <span class="sans_thesansmonocd_w5regular_">12</span> on the stack for now and passes <span class="sans_thesansmonocd_w5regular_">43</span> as the first parameter of a recursive call.</p>
<p class="tx">In this pass, <span class="sans_thesansmonocd_w5regular_">quotient</span> is <span class="sans_thesansmonocd_w5regular_">2</span>, and <span class="sans_thesansmonocd_w5regular_">remainder</span> is <span class="sans_thesansmonocd_w5regular_">11</span>. Again, the recursive case logic executes, and <span class="sans_thesansmonocd_w5regular_">11</span> finds its way onto the stack as we pass <span class="sans_thesansmonocd_w5regular_">2</span> in another recursive call.</p>
<p class="tx">In what’ll be the final pass, <span class="sans_thesansmonocd_w5regular_">quotient</span> is <span class="sans_thesansmonocd_w5regular_">0</span>, and <span class="sans_thesansmonocd_w5regular_">remainder</span> is <span class="sans_thesansmonocd_w5regular_">2</span>. Since <span class="sans_thesansmonocd_w5regular_">quotient</span> equals <span class="sans_thesansmonocd_w5regular_">0</span>, the base case logic finally executes. The decimal digit <span class="sans_thesansmonocd_w5regular_">2</span> maps to the hexadecimal digit <span class="sans_thesansmonocd_w5regular_">2</span>, and we pass it back as the output parameter.</p>
<p class="tx">Now let’s reverse direction and step back through the calls that we just made. The interpreter restores <span class="sans_thesansmonocd_w5regular_">remainder</span> to its value of <span class="sans_thesansmonocd_w5regular_">11</span> before the <span class="sans_thesansmonocd_w5regular_">set</span> command concatenates two values. The first is the just returned value of <span class="sans_thesansmonocd_w5regular_">2</span>, and the second is <span class="sans_thesansmonocd_w5regular_">B</span>, which we mapped to from the <span class="sans_thesansmonocd_w5regular_">11</span>. Hence, the routine passes back <span class="sans_thesansmonocd_w5regular_">2B</span> as the output parameter.</p>
<p class="tx">Back in the initial pass, the interpreter restores the <span class="sans_thesansmonocd_w5regular_">remainder</span> variable of <span class="sans_thesansmonocd_w5regular_">12</span> from the call stack. We concatenate two values, the just returned <span class="sans_thesansmonocd_w5regular_">2B</span> and <span class="sans_thesansmonocd_w5regular_">C</span>, which is the hexadecimal value corresponding to the <span class="sans_thesansmonocd_w5regular_">12</span>. Finally, the routine passes back <span class="sans_thesansmonocd_w5regular_">2BC</span> as the output parameter to the original <span class="sans_thesansmonocd_w5regular_">call</span> command.</p>
<p class="tx">With each call, the recursive logic is determining another hexadecimal digit, ultimately returning a multibyte hexadecimal value. At first glance, these few lines of code might not look like much, but under close inspection the routine turns out to be quite involved and interesting.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="h" id="sec4"><span id="h1-159"/><span class="sans_futura_std_bold_b_">Recursive Directory Searches</span></h3>
<p class="tni">The last two examples offer great demonstrations of recursion, allowing us to step through the recursive calls, but for my last example I want something that has Batch in its DNA, something not easily done in other languages. We’ll recursively search a directory and all of its subdirectories to produce a report detailing the total number of bytes and files in each folder.</p>
<p class="tx">If that sounds familiar, you learned about the <span class="sans_thesansmonocd_w5regular_">for</span> command with the <span class="sans_thesansmonocd_w5regular_">/D</span> (directory) and <span class="sans_thesansmonocd_w5regular_">/R</span> (recursion) options in <span class="xref"><a href="chapter18.xhtml" class="calibre3">Chapter 18</a></span>. This command easily created a simple list of all the subdirectories, but it handled the recursive call for you and didn’t leave much room for modifications. True recursion provides much more flexibility and power over the output, and that’s what we’ll do here.</p>
<p class="tx">Before coding the recursive routine, we need a plan and some analysis. To produce the detail records, we’ll use a <span class="sans_thesansmonocd_w5regular_">dir</span> command targeting a directory and use it as the input to a <span class="sans_thesansmonocd_w5regular_">for /F</span> command. The routine will write the totals for the directory to the report and recursively call itself, passing each subdirectory. Then it will process each subdirectory, making recursive calls for any subdirectories of subdirectories.</p>
<p class="tx">The only way to write code like that is to see the output of the embedded command, in this case a <span class="sans_thesansmonocd_w5regular_">dir</span> command. Depending on the contents of the directory, the <span class="sans_thesansmonocd_w5regular_">dir C:\Batch\*</span> command might produce the following output:</p>
<pre class="pre"><code class="calibre11"> Volume in drive C is OS
 Volume Serial Number is 2E6D-DBF0

<span aria-label=" Page 274. " epub:type="pagebreak" id="pg_274" role="doc-pagebreak"/> Directory of C:\Batch

10/31/2002  10:05 AM    &lt;DIR&gt;          .
10/31/2002  10:05 AM    &lt;DIR&gt;          ..
05/01/2001  11:18 AM               197 FourBrits.txt
02/14/2001  03:37 PM               178 FourBrits.csv
02/06/2002  12:47 PM    &lt;DIR&gt;          OrphanedFolder
06/20/2000  05:52 PM            89,402 outFile.dat
10/27/2002  08:36 AM    &lt;DIR&gt;          Subfolder
07/02/2002  02:03 PM            2,828 test.bat
               4 File(s)         92,605 bytes
               5 Dir(s)  147,918,372,864 bytes free
</code></pre>
<p class="tx">We’ll need to skip seven lines, the five header records plus the two entries showing directories of one or two periods. Of the remaining records, if the second token equals <span class="sans_thesansmonocd_w5regular_">File(s)</span>, we’ve found the entry with the total number of files (token 1) and total bytes of those files (token 3). If the fourth token equals <span class="sans_thesansmonocd_w5regular_">&lt;DIR&gt;</span>, we’ve found a folder name for a subdirectory (token 5). We don’t know much about the subdirectory yet, but a recursive call will bring up the same type of information about it. We can ignore the other records detailing each file and the final trailer record.</p>
<p class="tx">We could write the data to the console, but let’s use our report writing skills from <span class="xref"><a href="chapter22.xhtml" class="calibre3">Chapter 22</a></span>. The first section of code creates the header data and makes the initial call to the recursive <span class="sans_thesansmonocd_w5regular_">:GetFldrSz</span> routine that gets the folder information starting with the contents of <i class="calibre6">C:\Batch\</i>:</p>
<pre class="pre"><code class="calibre11"> set rpt=C:\Report\FolderSizes.txt
 &gt;  %rpt% echo  ==== In Search of Lost Disk Space ====
 &gt;&gt; %rpt% echo       Total Bytes    Files  Folder
 &gt;&gt; %rpt% echo       -----------    -----  ------
 call :GetFldrSz C:\Batch
 goto :eof

:GetFldrSz
 for /F "usebackq tokens=1-4* skip=7" %%a in (`dir "%~1\*"`) do (
    if /i "%%d" equ "&lt;DIR&gt;" (
       call :GetFldrSz "%~1\%%e"
    ) else if /i "%%b" equ "File(s)" (
       set ttlFiles=        %%a
       set ttlBytes=                  %%c
       &gt;&gt; %rpt% echo !ttlBytes:~-17! !ttlFiles:~-8!  %~1
)  )
 goto :eof
</code></pre>
<p class="tx">Focusing on the <span class="sans_thesansmonocd_w5regular_">:GetFldrSz</span> routine, the <span class="sans_thesansmonocd_w5regular_">for /F</span> command uses a <span class="sans_thesansmonocd_w5regular_">dir</span> command as its input, and that command uses the routine’s sole parameter, a directory, appended with a wildcard as its argument. The <span class="sans_thesansmonocd_w5regular_">for /F</span> command uses five tokens (<span class="sans_thesansmonocd_w5regular_">tokens=1-5</span>) and skips the unwanted header records (<span class="sans_thesansmonocd_w5regular_">skip=7</span>).</p>
<p class="tx">If the fourth token, <span class="sans_thesansmonocd_w5regular_">%%d</span>, equals <span class="sans_thesansmonocd_w5regular_">&lt;DIR&gt;</span>, we’ve found the recursive case; the recursive call passing as its argument the input directory appended with the name of the subfolder from the fifth token: <span class="sans_thesansmonocd_w5regular_">%~1\%%e</span>. Otherwise, the <span aria-label=" Page 275. " epub:type="pagebreak" id="pg_275" role="doc-pagebreak"/>base case looks for the second token, <span class="sans_thesansmonocd_w5regular_">%%b</span>, to match the text <span class="sans_thesansmonocd_w5regular_">File(s)</span>. If so, we store the total number of files and bytes in the folder in variables padded with leading spaces. Using those recently learned formatting techniques, we write a record to the report detailing the three pieces of information.</p>
<p class="tx">If the directory structure isn’t very complex, this code might write the following recursively generated report:</p>
<pre class="pre"><code class="calibre11"> ==== In Search of Lost Disk Space ====
      Total Bytes    Files  Folder
      -----------    -----  ------
           24,533       12  C:\Batch\OrphanedFolder
        2,419,998        4  C:\Batch\Subfolder\SubSub\Child
           67,150        3  C:\Batch\Subfolder\Sub
              242        3  C:\Batch\Subfolder
           92,605        4  C:\Batch
</code></pre>
<p class="tx">The last line contains the information from the <span class="sans_thesansmonocd_w5regular_">dir</span> command we executed to get a feel for the expected output, and it also shows the root directory argument from the initial <span class="sans_thesansmonocd_w5regular_">call</span> command. The other four detail lines are products of the recursive calls.</p>
<p class="tx">The beauty of this design is that the code makes a call for each subfolder, regardless of how many exist, if any at all. This routine is a framework, and there are countless auxiliary processes possible with minor modifications. Perhaps only directories in excess of a certain number of files or bytes should make the report. Shifting attention to files, perhaps you want to flag recently modified files to be part of an entirely different report, or maybe archive them. Perhaps you want to delete old or excessively large files, or maybe files fitting a certain mask or having a certain attribute. The list goes on.</p>
<p class="tx">There are a couple of caveats, however. The previous code doesn’t work on a root directory such as <i class="calibre6">C:\</i> because we are skipping the first two detail records produced by the <span class="sans_thesansmonocd_w5regular_">dir</span> command (the <span class="sans_thesansmonocd_w5regular_">&lt;DIR&gt;</span> records with one or two dots for the directory). Remember from <span class="xref"><a href="chapter13.xhtml" class="calibre3">Chapter 13</a></span> that this command doesn’t display those two records when the argument is just a drive letter. With some modifications, we can account for that issue, but the other caveat is more of a batveat, and it applies more generally to recursion. It’s the possibility of a stack overflow.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="h" id="sec5"><span id="h1-160"/><span class="sans_futura_std_bold_b_">Recursion Stack Overflow</span></h3>
<p class="tni">The primary batveat concerning recursion is important, yet very avoidable. With each successive recursive call, the interpreter places data onto the call stack, allowing you to use a variable that may have scores of values, one for each invocation. But memory is finite, and the interpreter doesn’t allocate much of it for the call stack. When it reaches 90 percent of its allocation, the interpreter aborts with a message such as this:</p>
<pre class="pre"><code class="calibre11">******  B A T C H  R E C U R S I O N  exceeds STACK limits ******
Recursion Count=507, Stack Usage=90 percent
******        B A T C H  PROCESSING IS   A B O R T E D      ******
</code></pre>
<p class="tx"><span aria-label=" Page 276. " epub:type="pagebreak" id="pg_276" role="doc-pagebreak"/>Setting aside all justified critiques of Batch’s seemingly random use of capitalization and space-delimited lettering, this failed after 507 recursive calls, but 506 isn’t the limit. I’ve used recursion quite a bit and have never seen it blow up with 300 or fewer recursive calls, but it varies greatly from machine to machine and from situation to situation. Every language has a limitation on recursion, but most usually allow far more levels. This is manageable, but you must take this limitation into consideration when coding a solution.</p>
<p class="tx">If the code is part of a larger process in an environment where an abort might result in a substantial financial loss with the possibility of you and others being woken up in the middle of the night to address the fallout, then you should limit recursive calls to situations where the call stack will max out well below the threshold of a possible overflow. But please don’t let this scare you off from such a wonderful technique. Well-designed recursion will easily stay inside these guardrails.</p>
<p class="tx">For instance, the conversion of an integer to a hexadecimal number requires 10 or fewer recursive calls for numbers less than nine trillion. Even the recursive code traversing a directory structure isn’t in danger of overflowing the call stack. Some directories might hold hundreds of subdirectories, but a close reading of the code in the previous section shows that sibling folders are never on the call stack at the same time. The interpreter continually adds and removes items from the call stack so that it’s never deeper than the level of the deepest folder from the root, rarely more than a dozen. You can safely code these solutions in any language, including Batch.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="h" id="sec6"><span id="h1-161"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">I hope that you enjoyed this chapter as much as I did. You’ve learned how recursion works from a coder’s perspective and the interpreter’s perspective—that is, I demonstrated how to execute recursion and also discussed how the interpreter is using the call stack behind the scenes.</p>
<p class="tx">I also demonstrated the usefulness of stepping through the code, recursive call by recursive call, with detailed examples. You must be careful of overflowing the recursion stack, but recursion is a wonderfully elegant tool when used wisely. Be on the lookout for problems in need of a recursive solution. For any process that iterates through a finite number of repetitive steps, a loop is usually the first solution that comes to mind, but look for the recursive case and the base case. If you see them, you can write some recursive logic. (For more on this topic, see <span class="xref"><a href="chapter23.xhtml" class="calibre3">Chapter 23</a></span>.)</p>
<p class="tx">Recursion is great for searching directories. In the next chapter, I’ll also discuss searches, but with a far more narrowed focus. Instead of searching every directory on your computer, you’ll learn how to search for a string inside a larger string, a file, or even multiple files.</p>
</section>
</section>
</div></body></html>