- en: '**21'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EXCEPTIONS AND INTERRUPTS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg495_Image_321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thus far, we’ve viewed each application as having exclusive use of the computer.
    But like most operating systems, Raspberry Pi OS allows multiple applications
    to run concurrently. It manages the hardware in an interleaved fashion, providing
    each application, and the operating system itself, with the use of the hardware
    components it needs at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: There are two issues here. First, for the operating system to carry out its
    management tasks, it needs to maintain control over the interaction between applications
    and hardware. It does this by using a system of privilege levels in the CPU that
    allows the operating system to control a gateway between itself and the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we saw in [Chapter 20](ch20.xhtml) that most I/O devices can interrupt
    the ongoing activity of the CPU when they are ready to provide input or to accept
    output. The CPU has a mechanism to direct I/O interruptions through this gateway
    and invoke functions that are under the control of the operating system, thus
    allowing the operating system to maintain its control over the I/O devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll start by discussing how the CPU uses privilege levels
    to enforce its control over the hardware. Then I’ll cover what sorts of events
    can cause a change in the privilege level and how the CPU reacts to such events.
    I’ll end the chapter with a discussion of an instruction that allows applications
    to traverse the gateway between application and system software to directly call
    utility functions in the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: A full treatment of this material would require a detailed understanding of
    the internal structure of the operating system and how to program the specific
    hardware you’re using, which is beyond the scope of this book. The goal here is
    to provide you with a very general overview.
  prefs: []
  type: TYPE_NORMAL
- en: '**Application vs. System Software**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software can generally be classified as application software or system software.
    We use *application software* for most of what we do on a computer, while *system
    software* manages usage of hardware resources, providing controlled access to
    the hardware by application software.
  prefs: []
  type: TYPE_NORMAL
- en: The split between system and application software is maintained by a system
    of *privilege levels*. The operating system executes at a *privileged* level,
    allowing it to manage most of the hardware resources. Application programs execute
    at an *unprivileged* level to prevent them from directly accessing much of the
    hardware. The operating system, being privileged, acts as a supervisor over the
    use of the computer resources by applications.
  prefs: []
  type: TYPE_NORMAL
- en: This separation of privileges allows the operating system to manage the resources
    needed to execute several application programs concurrently. For example, we could
    be running a media application to play music while using an editor application
    to edit a source file. While waiting for us to press another key, the operating
    system lets the media application use the CPU. When we press the key, the operating
    system pauses the media application long enough to read the keystroke and then
    passes control back to the media application while waiting for the very slow (in
    CPU time) human to press the next key.
  prefs: []
  type: TYPE_NORMAL
- en: An *exception* is an event that causes the currently executing code stream to
    be suspended and CPU control to be passed to software running at a privileged
    level. An *interrupt* is a type of exception event that comes from a device connected
    to the CPU. Before discussing what can cause an exception and what takes place
    when one occurs, let’s look at the privilege levels.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although the general concepts are the same, the terminology varies, so you
    need to be mindful when reading the respective manuals. For example, ARM uses*
    exception *as the more general term, with an* interrupt *being a type of exception.
    Intel, on the other hand, uses* interrupt *as the more general term, with an*
    exception *being a type of interrupt.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privilege and Exception Levels**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The operating system uses *exception levels* in the CPU to enforce privilege
    levels for the currently executing software. At any given time, the CPU is running
    at one of four possible exception levels. [Table 21-1](ch21.xhtml#ch21tab1) shows
    the levels, from least privileged to most.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-1:** The AArch64 Exception Levels'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| EL0 | Application programs |'
  prefs: []
  type: TYPE_TB
- en: '| EL1 | Operating system |'
  prefs: []
  type: TYPE_TB
- en: '| EL2 | Hypervisor |'
  prefs: []
  type: TYPE_TB
- en: '| EL3 | Firmware/secure monitor |'
  prefs: []
  type: TYPE_TB
- en: Application programs execute with the CPU set at the lowest exception level,
    EL0\. The operating system executes at exception level EL1.
  prefs: []
  type: TYPE_NORMAL
- en: A *hypervisor* allows us to run multiple operating systems concurrently on the
    same computer by coordinating their interactions with the hardware resources.
    A hypervisor executes at exception level EL2, giving it supervisorial control
    over the operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: '*Firmware* provides low-level control of device hardware. It’s stored in read-only
    memory and is executed at the highest exception level, EL3\. When the Raspberry
    Pi is first booted up, the CPU starts at EL3 so that it has access to all the
    hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: The AArch64 architecture defines a *secure state* and a *non-secure state*.
    All the hardware can be accessed in the secure state, while access is limited
    in the non-secure state. Switching between the two states is controlled by a *secure
    monitor*, which is software that can be executed only when the exception level
    is at EL3.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 20](ch20.xhtml), you learned that the memory management unit (MMU)
    uses a page table to map virtual memory addresses to physical memory addresses.
    The entry in the page table for each virtual memory range includes a 2-bit *access
    permissions (AP)* field for that memory range. [Table 21-2](ch21.xhtml#ch21tab2)
    shows what these permissions are at each CPU exception level.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-2:** The AArch64 Memory Access Permission Levels'
  prefs: []
  type: TYPE_NORMAL
- en: '| **AP** | **EL0 (unprivileged)** | **EL1/2/3 (privileged)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `00` | No access | Read/write |'
  prefs: []
  type: TYPE_TB
- en: '| `01` | Read/write | Read/write |'
  prefs: []
  type: TYPE_TB
- en: '| `10` | No access | Read only |'
  prefs: []
  type: TYPE_TB
- en: '| `11` | Read only | Read only |'
  prefs: []
  type: TYPE_TB
- en: Application programs execute with their instructions and read-only data loaded
    into virtual memory that has its access permission set to `11`. If they have any
    global variables, those are loaded into virtual memory with access permission
    set to `01`.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system’s instructions and read-only data are loaded into virtual
    memory that has its access permission set to `10`, and its global variables exist
    in virtual memory with access permission set to `00`.
  prefs: []
  type: TYPE_NORMAL
- en: You saw an example of dealing with these memory access permissions when programming
    the GPIO device in [Listing 20-2](ch20.xhtml#ch20list2) in [Chapter 20](ch20.xhtml).
    The operating system maps a range of its privileged virtual memory address space
    to the hardware addresses of the GPIO device registers. We used the `mmap` system
    call function to map unprivileged memory in our application program to the operating
    system’s GPIO addressing space so that our application program could access it.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to exception level, the Armv8-A processor has two execution states,
    AArch32 and AArch64, as discussed in the introduction to [Chapter 9](ch09.xhtml).
    The operating system sets the execution state when it first starts up.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions provide a way to change the execution state. When an exception takes
    the CPU to a higher exception level, we can tell the processor to stay at the
    same execution state or transition to AArch64\. When returning from an exception
    to a lower exception level, we can tell the processor to stay at the same execution
    state or transition to AArch32\. This allows us to run 32-bit applications under
    our 64-bit Raspberry Pi OS but prevents us from running 64-bit applications under
    a 32-bit version of Raspberry Pi OS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, you’ll see how exceptions allow the use of privileged
    software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception Events**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several kinds of events that can cause an exception. One of the most
    common causes is when an application program (unprivileged) needs a service provided
    by the operating system (privileged).
  prefs: []
  type: TYPE_NORMAL
- en: An example is when we call the `write` system call function to display text
    on the screen. As illustrated in [Figure 2-1](ch02.xhtml#ch2fig1) in [Chapter
    2](ch02.xhtml), the `write` function communicates directly with the operating
    system, which in turn sends the characters to the screen. It does this with an
    `svc` instruction, which causes an exception to occur. You’ll see how to use `svc`
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: An exception caused by the `svc` instruction is a *synchronous exception*, which
    is when the timing is synchronized with that of the CPU. Other causes of synchronous
    exceptions include an attempt to execute an instruction that is not valid at the
    current exception level, an attempt to access a memory address that is out of
    the range of the current exception level, and a debugger inserting a breakpoint
    in a program.
  prefs: []
  type: TYPE_NORMAL
- en: An *asynchronous exception* is not related to the timing of the CPU. Asynchronous
    exceptions, also called *interrupts*, typically come from an I/O device.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an asynchronous exception is when we use the `read` system call
    function to get characters from the keyboard. As you saw in [Figure 2-1](ch02.xhtml#ch2fig1),
    the `read` function also communicates directly with the operating system. However,
    when the `read` function requests characters from the keyboard, the operating
    system has no idea when the next key will be pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system notifies the keyboard device controller that it’s waiting
    for a character and places the currently running program in a waiting state. If
    there’s another program ready to run, the operating system gives CPU control to
    that program. When a user finally presses a key on the keyboard, the keyboard
    device controller sends an interrupt signal to the CPU, which causes an exception.
    When the CPU finishes executing the current instruction, it processes the interrupting
    exception, which typically places the waiting program in a ready state.
  prefs: []
  type: TYPE_NORMAL
- en: Exception processing is done by a piece of code called an *exception handler*.
    The CPU responds to an exception by executing the handler code. Let’s look at
    how the CPU does this.
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU Response to an Exception**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The processor includes a set of *system registers* that hold the configuration
    settings for the processor. These include registers that hold data needed for
    responding to and handling exceptions. Some of the system registers used for exceptions
    are shown in [Table 21-3](ch21.xhtml#ch21tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-3:** Some of the System Registers for Handling Exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Register** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `currentel` | Current exception level | Bits 3 and 2 hold the exception level
    (`00` for EL0, `01` for EL1, `10` for EL2, `11` for EL3) |'
  prefs: []
  type: TYPE_TB
- en: '| `elr` | Exception link | Address of instruction that caused the exception
    |'
  prefs: []
  type: TYPE_TB
- en: '| `esr` | Exception syndrome | Information about the reasons for the exception
    |'
  prefs: []
  type: TYPE_TB
- en: '| `far` | Fault address | Address of access that caused the fault |'
  prefs: []
  type: TYPE_TB
- en: '| `hcr` | Hypervisor configuration | Virtualization settings related to EL2
    |'
  prefs: []
  type: TYPE_TB
- en: '| `scr` | Secure configuration | Secure state settings related to EL3 |'
  prefs: []
  type: TYPE_TB
- en: '| `sctlr` | System control | Information about the system |'
  prefs: []
  type: TYPE_TB
- en: '| `spsr` | Saved program status | PSTATE when exception was taken to this exception
    level |'
  prefs: []
  type: TYPE_TB
- en: '| `vbar` | Vector base address | Exception base address for exception taken
    to this exception level |'
  prefs: []
  type: TYPE_TB
- en: These registers are accessible only from software running at a privileged level.
    There is only one `currentel` register. The `hcr` register exists at EL2 and the
    `scr` register at EL3\. The other system registers in this table have instances
    at levels EL1, EL2, and EL3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current exception level of the CPU is determined by bits 3 and 2 in `currentel`.
    The other 62 bits are reserved for possible future use. The content can be loaded
    into a general-purpose register with the `mrs x`d, `currentel` instruction executed
    at a privileged level:'
  prefs: []
  type: TYPE_NORMAL
- en: mrs**—Move system register**
  prefs: []
  type: TYPE_NORMAL
- en: '`mrs x`d`,` systemreg copies the content of a system register, systemreg, into
    `x`d. Valid only at exception levels EL1 and higher.'
  prefs: []
  type: TYPE_NORMAL
- en: There is also an `msr` instruction for storing content in some system registers,
    but not the `currentel` register. The content of the 2-bit exception level field
    in the `currentel` register can be changed only by an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception level can be increased only by an exception event, which can
    either increase the level or keep it the same, except for an exception event at
    EL0, which can only increase the level. The only way to decrease the exception
    level is with the `eret` instruction, which will either decrease the level or
    keep it the same:'
  prefs: []
  type: TYPE_NORMAL
- en: eret**—Exception return**
  prefs: []
  type: TYPE_NORMAL
- en: '`eret` restores PSTATE from the `spsr` register for the current exception level
    and loads the address in the `elr` register for the current exception level into
    `pc`.'
  prefs: []
  type: TYPE_NORMAL
- en: PSTATE is an abstraction for the bit settings of the system registers that define
    the current processor state. For example, bits 3 and 2 of the `currentel` register
    are included in PSTATE. The condition flags in the `nzcv` register listed in [Table
    9-2](ch09.xhtml#ch9tab2) in [Chapter 9](ch09.xhtml) are also included in PSTATE.
  prefs: []
  type: TYPE_NORMAL
- en: In response to an exception, the CPU performs an operation that is similar to
    the `bl` instruction, but there are some significant differences. The most obvious
    difference is that we specify the address in our program code that the `bl` instruction
    branches to, but an exception causes a branch to a block of code in an *exception
    vector table*.
  prefs: []
  type: TYPE_NORMAL
- en: An exception vector table has 16 entries, arranged in groups of 4, as shown
    in [Table 21-4](ch21.xhtml#ch21tab4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-4:** The Entries in an Exception Vector Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Type** | **Conditions** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x000` | Synchronous | From current EL while using EL0’s SP |'
  prefs: []
  type: TYPE_TB
- en: '| `0x080` | IRQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x100` | FIQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x180` | SError |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x200` | Synchronous | From current EL while using current level’s SP |'
  prefs: []
  type: TYPE_TB
- en: '| `0x280` | IRQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x300` | FIQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x380` | SError |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x400` | Synchronous | From lower EL, next lower EL using AArch64 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x480` | IRQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x500` | FIQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x580` | SError |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x600` | Synchronous | From lower EL, next lower EL using AArch32 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x680` | IRQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x700` | FIQ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x780` | SError |  |'
  prefs: []
  type: TYPE_TB
- en: Exception levels EL1, EL2, and EL3 each have their own copies of the 2KiB exception
    vector table shown here. Each of the 16 entries contains the code that handles
    the type and conditions of the exception corresponding to that entry. The length
    of each entry, 128 bytes, allows for up to 32 instructions for the exception handler.
    If more than 32 instructions are needed to handle an exception, a function outside
    the table can be called from the table entry program code.
  prefs: []
  type: TYPE_NORMAL
- en: Each exception vector table is created when the operating system first starts
    up. The address of each table is stored in the vector base address register, `vbar`,
    for its respective exception level. An exception causes a branch to the first
    instruction at the beginning of one of these entries, depending on the type of
    exception and the conditions when the exception occurred.
  prefs: []
  type: TYPE_NORMAL
- en: A synchronous exception comes from the CPU, as covered in the previous section.
    Of the three types of asynchronous exceptions, an *IRQ* is an interrupt request
    that usually comes from an I/O device controller. In previous versions of the
    ARM architecture, an *FIQ* was a fast interrupt request that also came from an
    I/O device controller but that had a higher priority than an IRQ. Starting with
    the Armv8-A architecture, an FIQ has the same priority as an IRQ; it simply provides
    another path for interrupts. How the two paths are used is dependent on the implementation
    of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: An *SError* is a system error meant to signal an unexpected event in the memory
    system. The events that cause an SError exception also vary based on the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The entry selected for each type of exception is dependent on whether the exception
    comes from the same exception level or from a lower level. If it’s from the current
    exception level, the selection depends on whether the stack pointer at EL0 or
    at the current exception level is being used.
  prefs: []
  type: TYPE_NORMAL
- en: If the exception comes from a lower exception level, the entry selected depends
    on whether the exception level immediately below the level you’re going to is
    executing in AArch32 or AArch64\. For example, you might have a 32-bit virtual
    machine running alongside a 64-bit operating system. Applications in the 32-bit
    virtual machine run at EL0, and their 32-bit operating system runs at EL1\. An
    exception occurring while in the AArch32 mode that goes to the hypervisor at EL2
    would go to one of the entries in the fourth group in [Table 21-4](ch21.xhtml#ch21tab4).
    All the handlers in this group would be from the 32-bit virtual machine’s operating
    system. The exception handler in the appropriate entry would execute within the
    32-bit operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU’s response to an exception is based on the assumption that we want to
    return to the place where the execution stream was interrupted by the exception
    and to continue with the CPU in the same state it was in before the exception
    occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'When responding to an exception, the CPU does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Saves the contents of PSTATE in the `spsr` register of the exception level it’s
    going to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stores the address of the last completed instruction in the `elr` register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For synchronous and system error exceptions, writes the cause to the `esr` register
    of the exception level it’s going to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For address-related synchronous exceptions, writes the cause to the `far` register
    of the exception level it’s going to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates PSTATE to the new exception level
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loads into `pc` the address of the appropriate entry in the exception vector
    table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s the responsibility of the exception handler to save and restore any general-purpose
    registers it uses. There is a separate stack pointer register at each exception
    level, so separate stacks can be set up at each level. When executing at EL1,
    EL2, or EL3, either the stack pointer at the current level or the stack pointer
    at EL0 can be used.
  prefs: []
  type: TYPE_NORMAL
- en: After the exception handler has restored any saved general-purpose registers,
    it uses the `eret` instruction to restore PSTATE to where it was and to return
    to the place where the exception occurred. PSTATE includes the 2-bit exception
    level in the `currentel` register, so this operation also returns the CPU to the
    exception level it came from.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an exception handler is an advanced topic beyond the scope of this book,
    but in the next section you’ll see how you can use an exception to call on the
    services of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supervisor Calls**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The operating system, being privileged, acts as a supervisor over the resources
    of the computer. When an unprivileged application program needs to use privileged
    resources, it calls upon the operating system using a *supervisor call*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-3](ch13.xhtml#ch13list3) in [Chapter 13](ch13.xhtml), we used
    the `write` system call function to write `Hello, World!` on the screen one character
    at a time. The `write` function is a C wrapper for a supervisor call. The program
    in [Listing 21-1](ch21.xhtml#ch21list1) is called *freestanding* because it doesn’t
    use any C library functions. Instead, we’re using a supervisor call directly when
    we need the services of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 21-1: The* Hello, World! *freestanding program*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gcc` compiler assumes we are using the C hosted environment and requires
    that the first function be named `main`. Since we’re not using the C libraries,
    we don’t need to use the C hosted environment and can give our function any name
    we wish ❷. After assembling this function, we go directly to the loader and tell
    it where to start execution of the function with the `-e` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we need the operating system to output a character, we use the `svc` instruction
    ❸:'
  prefs: []
  type: TYPE_NORMAL
- en: svc**—Supervisor call**
  prefs: []
  type: TYPE_NORMAL
- en: '`svc` imm causes an exception to be taken from exception level EL0 to EL1\.
    It stores `0x15` in bits 31 through 26 and imm, a 16-bit unsigned integer, in
    bits 15 through 0 of the `esr` register.'
  prefs: []
  type: TYPE_NORMAL
- en: Exception level EL1 is handled in the operating system. The `svc` handler uses
    the integer in the `x8` register to determine what action it should take. The
    number for the write operation is `0x40` ❶. The other arguments to the write operation
    in the operating system are the same as those to the C library `write` function.
    The argument to the `svc` instruction, imm, is not used in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Our `my_hello` function was launched directly by the operating system as a new
    process, not called from the C hosted environment. We terminate this process with
    another supervisor call ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we do not need to create a stack frame or save any registers in
    this freestanding program. The exception handler for `svc` will restore the state
    of the general-purpose registers when it returns. Because this program doesn’t
    return to the C hosted environment, we don’t need to save the `sp` and `fp` registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers for the operating system operations, the arguments to the operations,
    and the registers that these are all passed in are listed at *[https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/](https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/)*.
    There are four tables on this site: x86_64 (64-bit), arm (32-bit), arm64 (64-bit),
    and x86 (32-bit). Make sure you use the arm64 table with this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 21-5](ch21.xhtml#ch21tab5) lists some common `svc` codes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-5:** Some Register Contents for the `svc` Call'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | x8 | x0 | x1 | x2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `read` | `0x3f` | File descriptor | Address of character(s) | Number of characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `write` | `0x40` | File descriptor | Address of character(s) | Number of
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| `exit` | `0x5d` | Error code | — | — |'
  prefs: []
  type: TYPE_TB
- en: 'For completeness, here are the instructions that cause an exception to be taken
    to the hypervisor, `hvc`, and to the secure monitor, `smc`:'
  prefs: []
  type: TYPE_NORMAL
- en: hvc**—Hypervisor call**
  prefs: []
  type: TYPE_NORMAL
- en: '`hvc` imm causes an exception to be taken from exception level EL1 to EL2\.
    It stores `0x16` in bits 31 through 26 and imm, a 16-bit unsigned integer, in
    bits 15 through 0 of the `esr` register.'
  prefs: []
  type: TYPE_NORMAL
- en: smc**—Secure monitor call**
  prefs: []
  type: TYPE_NORMAL
- en: '`smc` imm causes an exception to be taken from exception level EL1 or EL2 to
    EL3\. It stores `0x17` in bits 31 through 26 and imm, a 16-bit unsigned integer,
    in bits 15 through 0 of the `esr` register.'
  prefs: []
  type: TYPE_NORMAL
- en: Further details of the exception processing mechanism in the AArch64 architecture
    are complex and beyond the scope of this book. A good next step is reading *Learn
    the Architecture—AArch64 Exception Model*, available at *[https://developer.arm.com/documentation/102412/0103](https://developer.arm.com/documentation/102412/0103)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 21.1     Pick a program you’ve written in assembly language. Add the instruction
    `mrs x0, currentel` in a place where you know it will be executed. Your program
    should still assemble and link fine, but what happens when you run the program?
  prefs: []
  type: TYPE_NORMAL
- en: 21.2     Modify the three functions `write_char`, `write_str`, and `read_str`
    in “Your Turn” [exercise 14.4](ch14.xhtml#ch14exe4) on [page 293](ch14.xhtml#ch14you1)
    so that they use the `svc` instruction instead of calling the C `write` and `read`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3     What is the supervisor call number for the `mmap` operation we used
    in [Listing 20-2](ch20.xhtml#ch20list2) in [Chapter 20](ch20.xhtml)?
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Privilege levels** The operating system maintains its privilege over the
    hardware resources by tagging memory addresses and running applications with the
    CPU set at a lower exception level.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception levels** The CPU runs software at one of four exception levels:
    from least to most privileged, EL0, EL1, EL2, or EL3.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception** An interruption in the currently executing code stream that causes
    CPU control to be passed to software running at a privileged level (EL1–EL3).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt** Other hardware devices can interrupt the regular execution cycle
    of the CPU and trigger an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: svc The instruction that causes an exception in AArch64.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception handler** A function in the operating system that gets called by
    the CPU when an exception or interrupt occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception vector table** An array of exception handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Freestanding program** A program that does not use the C library functions.'
  prefs: []
  type: TYPE_NORMAL
- en: This has been a brief overview of exceptions and interrupts. The details are
    complex and require a thorough knowledge of the specific model of CPU you’re working
    with.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes my introduction to computer organization. I hope it has provided
    you with the tools you need to further pursue any of the topics that interest
    you.
  prefs: []
  type: TYPE_NORMAL
