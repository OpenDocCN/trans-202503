["```\npush 1\n```", "```\npop eax\n```", "```\ncall address\n```", "```\nret\n```", "```\ncmp register, memory location, or literal, register, memory location, or\nliteral\n```", "```\nj* address\n```", "```\njge address\n```", "```\n   setup: # symbol standing in for address of instruction on the next line\n➊ mov eax, 10\n   loopstart: # symbol standing in for address of the instruction on the next\n   line\n➋ sub eax, 1\n➌ cmp 0, eax\n   jne $loopstart\n   loopend: # symbol standing in for address of the instruction on the next\n   line\n   mov eax, 1\n   # more code would go here\n```", "```\npip install pefile\npip install capstone\n```", "```\n#!/usr/bin/python\nimport pefile\nfrom capstone import *\n\n# load the target PE file\npe = pefile.PE(\"ircbot.exe\")\n\n# get the address of the program entry point from the program header\nentrypoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint\n\n# compute memory address where the entry code will be loaded into memory\nentrypoint_address = entrypoint+pe.OPTIONAL_HEADER.ImageBase\n\n# get the binary code from the PE file object\nbinary_code = pe.get_memory_mapped_image()[entrypoint:entrypoint+100]\n\n# initialize disassembler to disassemble 32 bit x86 binary code\ndisassembler = Cs(CS_ARCH_X86, CS_MODE_32)\n\n# disassemble the code\nfor instruction in disassembler.disasm(binary_code, entrypoint_address):\n    print \"%s\\t%s\" %(instruction.mnemonic, instruction.op_str)\n```", "```\n➊ push    ebp\n   mov     ebp, esp\n   push    -1\n   push    0x437588\n   push    0x41982c\n➋ mov     eax, dword ptr fs:[0]\n   push    eax\n   mov     dword ptr fs:[0], esp\n➌ add     esp, -0x5c\n   push    ebx\n   push    esi\n   push    edi\n   mov     dword ptr [ebp - 0x18], esp\n➍ call    dword ptr [0x496308]\n   --snip--\n```"]