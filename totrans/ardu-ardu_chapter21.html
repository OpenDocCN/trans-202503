<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch21" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch21">
<span class="CN"><span aria-label=" Page 369. " epub:type="pagebreak" id="pg_369" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">21</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">RETRIEVE THE CURRENT TIME FROM AN INTERNET TIME SERVER</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">When building projects that rely on keeping track of the current time (such as for logging data, creating planned events, or just making your own clocks), it’s common to use a real-time clock IC. For increased time and date accuracy, however, you can use an ESP32 Arduino-compatible board to retrieve the current time and date from an internet time server. Using the ESP32 also saves you the cost of an RTC IC or module and a separate Arduino or compatible board when building a new project and allows you to set your required time zone in the code, rather than in a separate interface.</p>
<p class="TX"><span aria-label=" Page 370. " epub:type="pagebreak" id="pg_370" role="doc-pagebreak"/>In this chapter, you’ll learn about the Network Time Protocol (NTP), install and test the NTP client library for Arduino, and extract the time and date components for your own projects. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Build a compact clock with an OLED display</li>
<li class="BL">Build a dual-time clock that displays time at home and at another location</li>
<li class="BL">Build a giant, super-bright digital clock</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-154"/><samp class="SANS_Futura_Std_Bold_B_11">The Network Time Protocol</samp></h2>
<p class="TNI">Originally standardized in the mid-1980s, NTP is a method of synchronizing connected computers to the Coordinated Universal Time (formally known as Greenwich Mean Time, or GMT). The NTP allows for an accuracy of 1 millisecond or better. In general use, the margin of error is around 100 milliseconds, but a difference of one-10th of a second is easily accurate enough for timing-related Arduino projects.</p>
<p class="TX">You can retrieve the time from the NTP server either in the usual 24-hour time and standard date format or in the format of <i>epoch time</i>. This is the number of seconds since January 1, 1970, from which you can make your own calculations to determine the current date and time. Some people use epoch time to calculate their own types of time, such as metric time.</p>
<p class="TX">There are many NTP servers available around the world, each with its own address. Generally, the one closest to your location should have the fastest connection to your project, but you might want to use a different server depending on your internet routing. Check <a href="https://www.pool.ntp.org/zone/@"><i>https://<wbr/>www<wbr/>.pool<wbr/>.ntp<wbr/>.org<wbr/>/zone<wbr/>/@</i></a> to find the server address most appropriate for you and then use that to replace my default NTP server in the code for this chapter’s projects.</p>
<p class="TX">You will also need to know your <i>time zone offset</i>: the number of hours before or after GMT, or in more contemporary parlance, the Coordinated Universal Time. This is based on the values listed at <a href="https://en.wikipedia.org/wiki/List_of_UTC_offsets"><i>https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/List<wbr/>_of<wbr/>_UTC<wbr/>_offsets</i></a>. For example, if you live in London, set your offset to 0, as your time zone falls in the value of UTC (or GMT) 0. If you live in Los Angeles, California, the time zone is UTC <span class="symbol">−</span>8. This means you’d use a value of <span class="symbol">−</span>28,800, as LA is 8 hours behind UTC, multiplied by 3,600 to convert to seconds. Finally, the update interval value of 60,000 is the update interval in milliseconds. This is set to a default that equates to one minute, as you don’t need to update the time more than once a second.</p>
<p class="TX">To prepare to build the projects in this chapter, download and install the NTP Client library for Arduino directly from my GitHub page. Visit <a href="https://github.com/taranais/NTPClient"><i>https://<wbr/>github<wbr/>.com<wbr/>/taranais<wbr/>/NTPClient</i></a> and click <b>Code</b> in the center of the screen. A small menu should appear, as shown in <a href="chapter21.xhtml#fig21-1">Figure 21-1</a>. Click <b>Download ZIP</b> to download the library ZIP file to your PC. If the Arduino IDE ever prompts you to update this library, don’t—use the first version you already installed.<span aria-label=" Page 371. " epub:type="pagebreak" id="pg_371" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE NTP CLIENT LIBRARY GITHUB PAGE" class="img1" id="fig21-1" src="../images/fig21-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-1: Downloading the NTP Client library</samp></p></figcaption>
</figure>
<p class="TX">Open the Arduino IDE and install the library by selecting <b>Sketch</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Include Library</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Add .ZIP Library.</b> Once the library installs, restart the Arduino IDE to continue.</p>
<p class="TX">You’re ready to start using internet time in your projects.</p>
<p class="HeadProject"><span id="h1-155"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #61: Retrieving the Time and Date</samp></p>
<p class="TNI">This project serves as a framework for retrieving the time and date from an NTP server and then extracting the elements of date and time (hours, minutes, and so on) so you can use them in your own projects.</p>
<p class="TX">The project uses the Serial Monitor to display the time and date, so for hardware, you’ll need only the ESP32 dev board and matching USB cable as used in previous chapters. If you haven’t already, turn to <span class="Xref"><a href="chapter19.xhtml">Chapter 19</a></span> and follow <span class="Xref">“Configuring the Arduino IDE for the ESP32” through “Testing the ESP32”</span> to install the required board profiles for the Arduino IDE.</p>
<p class="TX">Enter and upload the Project #61 sketch, adding your Wi-Fi network credentials in the SSID and password fields near the top of the sketch (as originally explained for <span class="Xref">Project #55 in <a href="chapter19.xhtml">Chapter 19</a></span>). Once the sketch has uploaded, the ESP32 should attempt to connect to your Wi-Fi network and then retrieve and display the time and date information in the Serial Monitor, as shown in <a href="chapter21.xhtml#fig21-2">Figure 21-2</a>.</p>
<figure class="IMG"><img alt="AN EXAMPLE OUTPUT FROM PROJECT #61" class="img4" id="fig21-2" src="../images/fig21-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-2: Example output from Project #61</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 372. " epub:type="pagebreak" id="pg_372" role="doc-pagebreak"/>Let’s take a closer look at how this works:</p>
<span id="pro-61"/>

<pre><code>// Project #61 - Retrieving Internet time

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;NTPClient.h&gt;
#include &lt;WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;
WiFiUDP ntpUDP;

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> // Enter your Wi-Fi network SSID and password:
const char* ssid = "<var>SSID</var>";
const char* password = "<var>password</var>";

// ntpUDP, time server pool, offset in seconds, update interval (mS):
NTPClient timeClient(ntpUDP, "<var>0.north-america.pool.ntp.org</var>", <var>36000</var>, 60000);

void setup()
{
    Serial.begin(115200);
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Connecting to Wi-Fi ");
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(500);
        Serial.print(".");
    }
    timeClient.begin();
}

void loop()
{
    String dateString;
    String date, month, year;

  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> timeClient.update();
    Serial.println(timeClient.getEpochTime());
    Serial.println(timeClient.getFormattedDate());
    Serial.println(timeClient.getFormattedTime());

    // Retrieve and display day of week
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Serial.print("Today is ");
    switch (timeClient.getDay())
    {
        case 0: Serial.println("Sunday"); break;
        case 1: Serial.println("Monday"); break;
        case 2: Serial.println("Tuesday"); break;
        case 3: Serial.println("Wednesday"); break;
        case 4: Serial.println("Thursday"); break;
        case 5: Serial.println("Friday"); break;
        case 6: Serial.println("Saturday"); break;
        case 7: Serial.println("Sunday"); break;
    }

<span aria-label=" Page 373. " epub:type="pagebreak" id="pg_373" role="doc-pagebreak"/>    // Retrieve hours, minutes, and seconds separately and display:
    if (timeClient.getHours() &lt; 10)
    {
        Serial.print("0");
    }
    Serial.print(timeClient.getHours());
        Serial.print("-");
  if (timeClient.getMinutes() &lt; 10)
  {
          Serial.print("0");
    }
      Serial.print(timeClient.getMinutes());
        Serial.print("-");
    if (timeClient.getSeconds() &lt; 10)
    {
        Serial.print("0");
    }
    Serial.println(timeClient.getSeconds());

  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> // Extract data from formatted date result and display:
    dateString = timeClient.getFormattedDate();
    date = dateString.substring(8, 10);
    Serial.print(date);
    Serial.print("/");
    month = dateString.substring(5, 7);
    Serial.print(month);
    Serial.print("/");
    year = dateString.substring(0, 4);
    Serial.println(year);
    Serial.println();
    delay(1000);
}
</code></pre>

<p class="TX">First, the sketch includes the required libraries for Wi-Fi and the NTP client and creates an instance of the timer server <samp class="SANS_TheSansMonoCd_W5Regular_11">ntp</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, it stores the name and password of the Wi-Fi network for use by the Wi-Fi library <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTPClient timeClient()</samp> function accepts the NTP server address to use, the required time zone offset, and the update interval. As mentioned in the previous section, try the default time server address supplied in the code or find one closer to your location. For the time zone offset, replace the value in the code with the offset appropriate for your location.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, various string variables are declared for storing time and date information, followed by a force update of the time client <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> to get the latest time and date from the server. The next three functions demonstrate how to retrieve the time and date information in different formats and display their values on the Serial Monitor. The first is <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getEpochTime()</samp>, which retrieves the epoch time. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getFormattedDate()</samp> shows the entire time and date in the previously set time zone with the date in <i>yyyy</i>-<i>mm</i>-<i>dd</i> format, followed by the letter <i>T</i> (for “time”) and then the current time in 24-hour time. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getFormattedTime()</samp> shows the current time in <i>hh</i>:<i>mm</i>:<i>ss</i> format.</p>
<p class="TX"><span aria-label=" Page 374. " epub:type="pagebreak" id="pg_374" role="doc-pagebreak"/>Next, the sketch demonstrates how to extract individual pieces of time and date information. The <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getDay()</samp> function returns an integer between 0 and 6 that represents the day of the week, from Sunday through Saturday, respectively. This is used in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> to determine the current day and display the name in the Serial Monitor. The sketch displays the individual values for hours, minutes, and seconds with the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getHours()</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getMinutes()</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getSeconds()</samp>, which all return their respective values as integers. The code also includes a test for values less than 10 for minutes and seconds to add a 0 if necessary for the proper time format. This is so that you don’t end up with a time display of 9:5:00 for five minutes past 9 AM, for example.</p>
<p class="TX">Getting the day, month, and year is a little different. The sketch first retrieves the entire time and date using <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getFormattedDate()</samp><span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and then stores the values for the date, month, and year in string variables using <samp class="SANS_TheSansMonoCd_W5Regular_11">.substring</samp> functions. For example, the year falls within the first four characters of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">dateString</samp>, so the function <samp class="SANS_TheSansMonoCd_W5Regular_11">dateString.substring(0,4)</samp> will return those first four characters. Finally, there’s a delay of 1 second before the process repeats.</p>
<p class="TX">If your project loses its connection to your Wi-Fi network, the time will stay the same and not update until the ESP32 can reconnect to the NTP server, at which point the time and date will automatically update.</p>
<p class="TX">The following projects use this sketch as a framework for retrieving the time and date and displaying the results on different devices.</p>
<p class="HeadProject"><span id="h1-156"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #62: Displaying the Time and Date on an OLED</samp></p>
<p class="TNI">This project demonstrates how to display the time and date from an NTP server on the inexpensive OLED display you first used in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. You could modify this project to control other types of displays, such as LCDs or even Nixie tubes, if so inclined.</p>
<p class="TX">You’ll need the following hardware:</p>
<ul class="ul">
<li class="BL">An ESP32 Arduino-compatible board and USB cable</li>
<li class="BL">A 128 <span class="symbol">×</span> 32 pixel, 0.91-inch OLED display</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">If this is your first time using the OLED display, please turn to <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> and follow the instructions in <span class="Xref">“Graphic OLED Displays” on page 149</span> to the point where you have tested the OLED and then assemble the circuit as shown in <a href="chapter21.xhtml#fig21-3">Figure 21-3</a>.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Although your OLED might be marked as a 5 V device, the specified model also works on 3.3 V without a level converter.</i><span aria-label=" Page 375. " epub:type="pagebreak" id="pg_375" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #62" class="img4" id="fig21-3" src="../images/fig21-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-3: The schematic for Project #62</samp></p></figcaption>
</figure>
<p class="TX">Enter and upload the Project #62 sketch, updating your Wi-Fi network details as appropriate. The OLED should display a message telling you the ESP32 is attempting to connect to Wi-Fi, as shown in <a href="chapter21.xhtml#fig21-4">Figure 21-4</a>.</p>
<figure class="IMG"><img alt="THE OLED DISPLAY DURING THE INITIAL CONNECTION TO WI-FI: “CONNECTING TO WI-FI…”" class="img8" id="fig21-4" src="../images/fig21-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-4: The project connecting to Wi-Fi</samp></p></figcaption>
</figure>
<p class="TX">Once the project has connected to the NTP server, the OLED should display the current time and date, along with the day of the week, as shown in <a href="chapter21.xhtml#fig21-5">Figure 21-5</a>.</p>
<figure class="IMG"><img alt="THE EXAMPLE OUTPUT FROM PROJECT #62: “10:49:09 MON 09/01/2023”" class="img8" id="fig21-5" src="../images/fig21-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-5: Example output from Project #62</samp></p></figcaption>
</figure>
<p class="TX">Let’s take a closer look at how this works:</p>
<span id="pro-62"/>

<pre><code>// Project #62 - OLED NTP clock

#include &lt;NTPClient.h&gt;
#include &lt;WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;
#include &lt;U8g2lib.h&gt;
#include &lt;Wire.h&gt;
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

// Enter your Wi-Fi network SSID and password
const char* ssid = "<var>SSID</var>";
<span aria-label=" Page 376. " epub:type="pagebreak" id="pg_376" role="doc-pagebreak"/>const char* password = "<var>Password</var>";
WiFiUDP ntpUDP;

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> // ntpUDP, time server pool, offset in seconds, update interval (mS)
NTPClient timeClient(ntpUDP, "<var>0.us.pool.ntp.org</var>", <var>36000</var>, 60000);

void setup()
{
    Wire.begin();
    u8g2.begin();
    u8g2.setFont(u8g2_font_9x18_tr);
    Serial.begin(115200);
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Connecting to Wi-Fi ");
    while (WiFi.status() != WL_CONNECTED)
    {
        u8g2.clearBuffer();
        u8g2.drawStr(0, 16, "Connecting");
        u8g2.drawStr(0, 31, "to Wi-Fi"…");
        u8g2.sendBuffer();
    }
    timeClient.begin();
}

void loop()
{
    int hours, minutes, seconds;
    int date, month, year, dayOfWeek;
    String hh, mm, ss, dateString;
    String OLED1, OLED2;

    timeClient.update();

    // Assemble time:
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> hours = timeClient.getHours();
    minutes = timeClient.getMinutes();
    seconds = timeClient.getSeconds();

    if (hours &lt; 10) {hh = hh + "0";}
    if (minutes &lt; 10) {mm = mm + "0";}
    if (seconds &lt; 10) {ss = ss + "0";}
    hh = hh + String(hours);
    mm = mm + String(minutes);
    ss = ss + String(seconds);
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> OLED1 = hh + ":" + mm + ":" + ss;

    // Assemble date:
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> dateString = timeClient.getFormattedDate();
    switch (timeClient.getDay())
    {
        case 0: OLED2 = OLED2 + "Sun "; break;
        case 1: OLED2 = OLED2 + "Mon "; break;
        case 2: OLED2 = OLED2 + "Tue "; break;
<span aria-label=" Page 377. " epub:type="pagebreak" id="pg_377" role="doc-pagebreak"/>        case 3: OLED2 = OLED2 + "Wed "; break;
        case 4: OLED2 = OLED2 + "Thu "; break;
        case 5: OLED2 = OLED2 + "Fri "; break;
        case 6: OLED2 = OLED2 + "Sat "; break;
        case 7: OLED2 = OLED2 + "Sun "; break;
	}

  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> OLED2 = OLED2 + dateString.substring(8, 10); // Date
    OLED2 = OLED2 + "/";
    OLED2 = OLED2 + dateString.substring(5, 7); // Month
    OLED2 = OLED2 + "/";
    OLED2 = OLED2 + dateString.substring(0, 4); // Year

    // Show time and date on OLED:
  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> u8g2.clearBuffer();
    u8g2.drawStr(0, 16, OLED1.c_str());
    u8g2.drawStr(0, 31, OLED2.c_str());
    u8g2.sendBuffer();
    delay(1000);
}
</code></pre>

<p class="TX">The sketch includes and initializes the libraries required for Wi-Fi, the NTP client, the I<sup>2</sup>C bus, and the OLED. Set the fields for your Wi-Fi network details, as usual.</p>
<p class="TX">The sketch then initiates an instance of the NTP client and sets up the pool server, time zone offset, and update intervals <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, it starts the I<sup>2</sup>C bus, OLED display library, and Serial Monitor for debugging and then initializes the Wi-Fi. The next block of code causes the “Connecting …” message to appear on the OLED during the connection process <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The sketch then starts the NTP client library.</p>
<p class="TX">The code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> aims to assemble the time information and display it on the top line of the OLED and then assemble the date information and display it on the bottom line. This starts by retrieving the time <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and then adding a 0 to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED1</samp>, which will contain the time data for hours, minutes, and seconds if the individual piece of data is below 10. The hour, minute, and second values are then added into their respective string variables, which are finally concatenated into one string for display <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">After retrieving the date string <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, the code retrieves the day of week and places it inside the string <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED2</samp>, which it uses to display the entire date via the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function. Next, it retrieves the day, month, and year and adds that data to the main date string, including with separators for a neat display <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
<p class="TX">Finally, the sketch sends the two lines of data, <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED2</samp>, to the OLED for display <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. As demonstrated in the code, you must add the suffix <samp class="SANS_TheSansMonoCd_W5Regular_11">.c_str</samp> to the variable name to tell the OLED library to convert the variable from a string to usable data.</p>
<p class="TX">Keep the hardware for this project assembled. In the next project, you’ll use it to make a dual-zone clock that takes advantage of the offset function in the NTP library.</p>
<p class="HeadProject"><span id="h1-157"/><span aria-label=" Page 378. " epub:type="pagebreak" id="pg_378" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #63: Displaying Two Time Zones on an OLED</samp></p>
<p class="TNI">This project shows you how to display the time in two zones simultaneously on the OLED display used in the previous project. This might be useful if you’re a HAM radio operator or if you often communicate with friends, family, or colleagues in different time zones.</p>
<p class="TX">The required hardware and assembly are the same as Project #62. Once the hardware is ready, enter and upload the Project #63 sketch. Don’t forget to add your Wi-Fi network credentials into this sketch. After the ESP32 connects to the Wi-Fi network, the OLED should display the “home zone” time for the east coast of Australia (where I live) and display the “away zone” time for San Francisco in the United States (the home of No Starch Press), as shown in <a href="chapter21.xhtml#fig21-6">Figure 21-6</a>.</p>
<figure class="IMG"><img alt="THE EXAMPLE OUTPUT FROM PROJECT #63: “HOME 11:25:11 SFO 17:25:11”" class="img1" id="fig21-6" src="../images/fig21-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-6: Example display for Project #63</samp></p></figcaption>
</figure>
<p class="TX">To learn to change the time zones, let’s take a closer look at the sketch:</p>
<span id="pro-63"/>

<pre><code>// Project #63 - OLED dual-zone NTP clock

#include &lt;NTPClient.h&gt;
#include &lt;WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;
#include &lt;U8g2lib.h&gt;

#include &lt;Wire.h&gt;
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

// Enter your Wi-Fi network SSID and password:
const char* ssid = "<var>SSID</var>";
const char* password = "<var>Password</var>";
WiFiUDP ntpUDP;

// ntpUDP, time server pool, offset in seconds, update interval (mS)
// Starts with home offset (e.g. 36000 for UTC + 10)
NTPClient timeClient(ntpUDP, "<var>0.us.pool.ntp.org</var>", <var>36000</var>, 60000);

<span aria-label=" Page 379. " epub:type="pagebreak" id="pg_379" role="doc-pagebreak"/>void setup()
{
    Wire.begin();
    u8g2.begin();
    u8g2.setFont(u8g2_font_9x18_tr);

    Serial.begin(115200);
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Connecting to Wi-Fi ");
    while (WiFi.status() != WL_CONNECTED)
    {
        u8g2.clearBuffer();
        u8g2.drawStr(0, 16, "Connecting");
        u8g2.drawStr(0, 31, "to Wi-Fi…");
        u8g2.sendBuffer();
    }
    timeClient.begin();
}

void loop()
{
    int hours, minutes, seconds;
    String hh, mm, ss, dateString;
    String OLED1, OLED2;
    timeClient.update();

    // Assemble home time (BNE, UTC + 10):
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> timeClient.setTimeOffset(<var>36000</var>);
    hours = timeClient.getHours();
    minutes = timeClient.getMinutes();
    seconds = timeClient.getSeconds();

    if (hours &lt; 10) {hh = hh + "0";}
    if (minutes &lt; 10) {mm = mm + "0";}
    if (seconds &lt; 10) {ss = ss + "0";}
    hh = hh + String(hours);
    mm = mm + String(minutes);
    ss = ss + String(seconds);
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> OLED1 = "Home " + hh + ":" + mm + ":" + ss;
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> hh = " "; mm = " "; ss = " ";

    // Assemble away time (SFO, UTC - 8):
    timeClient.setTimeOffset(−<var>28800</var>);
    hours = timeClient.getHours();
    minutes = timeClient.getMinutes();
    seconds = timeClient.getSeconds();

    if (hours &lt; 10) {hh = hh + "0";}
    if (minutes &lt; 10) {mm = mm + "0";}
    if (seconds &lt; 10) {ss = ss + "0";}
    hh = hh + String(hours);
    mm = mm + String(minutes);
    ss = ss + String(seconds);
<span aria-label=" Page 380. " epub:type="pagebreak" id="pg_380" role="doc-pagebreak"/>  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> OLED2 = "SFO " + hh + ":" + mm + ":" + ss;

    // Show time and date on OLED:
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> u8g2.clearBuffer();
    u8g2.drawStr(0, 16, OLED1.c_str());
    u8g2.drawStr(0, 31, OLED2.c_str());
    u8g2.sendBuffer();
    delay(1000);
}
</code></pre>

<p class="TX">This sketch is similar to the one for Project #62, in that it also assembles two lines of data to display on the OLED. To create a dual-zone clock, the code begins by setting the time zone offset for the first zone <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The example home time zone in the sketch is for Brisbane, which is UTC +10, so the offset value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.setTimeOffset()</samp> function is 36,000 (3,600 multiplied by +10 hours), but you can change this to match whichever time zone you like. Following this, the sketch retrieves the time data and assembles it into the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED1</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, preceding it with the label <samp class="SANS_TheSansMonoCd_W5Regular_11">Home</samp>. The sketch then blanks out the string variables used to temporarily hold retrieved time data for reuse <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">The same process repeats for a second time zone. I’ve used the example of San Francisco, which is UTC –8, meaning that the offset value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.setTimeOffset()</samp> function is –28,800 (3,600 multiplied by –8 hours). The sketch retrieves and assembles the time date into the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED2</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, starting with a label for the away zone <samp class="SANS_TheSansMonoCd_W5Regular_11">SFO</samp>. Finally, it sends the two strings of data to the OLED for display <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, followed by a short delay before the entire process repeats.</p>
<p class="TX">For a challenge, you might try modifying this project to scroll through various time zones at the press of a button.</p>
<p class="HeadProject"><span id="h1-158"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #64: Building a Giant Digital Clock</samp></p>
<p class="TNI">For this chapter’s final project, let’s have some fun and build a giant digital clock using the seven-segment LED modules from <span class="Xref">Project #27 in <a href="chapter8.xhtml">Chapter 8</a></span>. Once assembled, you could use this project to keep time in your workshop as an example of your prowess.</p>
<p class="TX">If you don’t already have the seven-segment LED modules set up, revisit <span class="Xref">Project #27</span> and build the four required display boards. (For a challenge, you might make six boards so you can display seconds in addition to minutes and hours.) Apart from the display boards, wiring, and 9 V DC 1A power supply covered in that project, you will only need the ESP32 board used in this chapter and the usual jumper wires and USB cable.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>The TPIC6B595 shift register ICs used in the LED display boards are both 3.3 V and 5 V tolerant, so you don’t need to connect a level shifter between them and the ESP32 board.</i></p>
<p class="TX"><span aria-label=" Page 381. " epub:type="pagebreak" id="pg_381" role="doc-pagebreak"/>Once you have connected the four display boards, upload the Project #64 sketch. Using the connections diagrammed in <a href="chapter21.xhtml#fig21-7">Figure 21-7</a>, connect the ESP32 to the first display board (the one on the left of the figure).</p>
<figure class="IMG"><img alt="THE CONNECTION DETAILS BETWEEN THE ESP32 AND THE FIRST DISPLAY BOARD" class="img5" id="fig21-7" src="../images/fig21-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-7: The connection layout between the ESP32 and first display board</samp></p></figcaption>
</figure>
<p class="TX">Connect the power to the first display board. The ESP32 should connect to the Wi-Fi network and retrieve the time. Stand back to see all four digits light up with the current time, as shown in <a href="chapter21.xhtml#fig21-8">Figure 21-8</a>.</p>
<figure class="IMG"><img alt="PROJECT #64 IN OPERATION, SHOWING 21.15H" class="img1" id="fig21-8" src="../images/fig21-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-8: Project #64 in action</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works in the sketch:</p>
<span id="pro-64"/>

<pre><code>// Project #64 - Giant LED NTP Clock

#include &lt;NTPClient.h&gt;
#include &lt;WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;

// Enter your Wi-Fi network SSID and password:
const char* ssid = "<var>SSID</var>";
const char* password = "<var>Password</var>";
WiFiUDP ntpUDP;

// ntpUDP, time server pool, offset in seconds, update interval (mS)
// Starts with home offset (e.g. 36000 for UTC + 10)
NTPClient timeClient(ntpUDP, "<var>0.us.pool.ntp.org</var>", <var>36000</var>, 60000);
<span aria-label=" Page 382. " epub:type="pagebreak" id="pg_382" role="doc-pagebreak"/><span aria-label="annotation1" class="CodeAnnotationCode">❶</span> #define LATCH 5  // Latch RCK pin
#define CLOCK 18 // Clock SRCK pin
#define DATA 23  // Data SERIN pin

int digits[] = { B00111111,   // 0
                 B00000110,   // 1
                 B01011011,   // 2
                 B01001111,   // 3
                 B01100110,   // 4
                 B01101101,   // 5
                 B01111101,   // 6
                 B00000111,   // 7
                 B01111111,   // 8
                 B01100111}; // 9

void sendNumbers(int numbers[], int dp)
{
    digitalWrite(LATCH, LOW);
    for (int i = 0; i &lt; 4; i++)
    {
        int dig_idx = numbers[i];
        if (dp == i)
        {
          // Display the digit:
          shiftOut(DATA, CLOCK, MSBFIRST, digits[dig_idx] | B10000000);
        } else
        {
          shiftOut(DATA, CLOCK, MSBFIRST, digits[dig_idx]);
        }
    }
    digitalWrite(LATCH, HIGH);
}

void setup()
{
    pinMode(LATCH, OUTPUT);
    pinMode(CLOCK, OUTPUT);
    pinMode(DATA, OUTPUT);
    Serial.begin(115200);
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Connecting to Wi-Fi…");
    while (WiFi.status() != WL_CONNECTED)
    {
        Serial.print(".");
        delay(500);
    }
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> timeClient.begin();
}

void loop()
{
    int numbers[4];
    int hours, minutes;
<span aria-label=" Page 383. " epub:type="pagebreak" id="pg_383" role="doc-pagebreak"/>  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> timeClient.update();

    hours = timeClient.getHours();
    minutes = timeClient.getMinutes();

  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> numbers[3] = hours / 10;
    numbers[2] = hours % 10;
    numbers[1] = minutes / 10;
    numbers[0] = minutes % 10;

  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> sendNumbers(numbers, 2);
    delay(1000);
}
</code></pre>

<p class="TX">The operations in this sketch should be familiar to you at this point. The code includes the required libraries and Wi-Fi network details. It then creates an instance of the NTP client with the pool server, time zone offset, and update interval details. For easy reference, the sketch defines the pin numbers used for the outputs to the shift registers on the display boards <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX">The array <samp class="SANS_TheSansMonoCd_W5Regular_11">digits[]</samp> holds the 10 bytes of data used to define how a digit is displayed on the LED boards, where each bit represents one of the seven segments used to comprise a digit. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">sendNumbers()</samp> function accepts an array of four integers to display on the four LED boards, as well as another integer that, if used, turns on the decimal point on the matching LED board.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the code initializes the required digital pins, sets up the Serial Monitor for debugging, and starts the Wi-Fi connection and the NTP client <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> updates the NTP client for the latest time information <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and then retrieves and stores the hours and minutes in variables. The time must be broken down into single digits before it’s sent to the LED boards, so the use of modulo and division <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> on the hours and minutes values returns the first and second digits, which are then stored in the array <samp class="SANS_TheSansMonoCd_W5Regular_11">numbers[]</samp>. Finally, the sketch sends those digits to the display using <samp class="SANS_TheSansMonoCd_W5Regular_11">sendNumbers()</samp>, with the decimal point placed at the second digit as separator between hours and minutes <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">For a final challenge, you can try altering the code in any of the projects in this chapter to use 12-hour time rather than 24-hour time. To do so, you must subtract 12 from any hour value that is 13 or more before displaying that hour. You could, of course, also add a test for AM and PM.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-159"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned how to harness accurate time and date information from the internet and show that information using various display types. Armed with these skills, you might try building additional clocks with various displays as practice for other projects that require the time and date.</p>
<p class="TX">The next chapter covers another way to use the ESP32, demonstrating how to capture data from the dev board into the Google Sheets app for analysis.</p>
</section>
</section>
</body>
</html>