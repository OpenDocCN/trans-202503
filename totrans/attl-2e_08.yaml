- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: LIBRARY INTERFACE VERSIONING AND RUNTIME DYNAMIC LINKING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 库接口版本控制与运行时动态链接
- en: '*Occasionally he stumbled over the truth, but hastily picked himself up and
    hurried on as if nothing had happened.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*偶尔他会碰到真相，但总是匆忙站起来，像什么也没发生一样继续前进。*'
- en: —Sir Winston Churchill, quoted in* The Irrepressible Churchill
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —温斯顿·丘吉尔爵士，在《无法抑制的丘吉尔》中引用
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In the last chapter, I explained the concepts of dynamically loadable shared
    libraries. I also showed you how easy it is to add Libtool shared-library functionality
    and flexibility to your projects, whether your projects provide shared libraries,
    static libraries, convenience archives, or some mixture of these. There are still
    two major Libtool topics we need to cover. The first is library versioning, and
    the second involves using the Libtool *ltdl* library to portably build and consume
    dynamically loadable modules within your projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我解释了动态加载共享库的概念。我还展示了如何轻松地将Libtool共享库功能和灵活性添加到你的项目中，无论你的项目是提供共享库、静态库、便利档案，还是这些的某种混合体。我们仍然有两个主要的Libtool话题需要讨论。第一个是库版本控制，第二个涉及使用Libtool的*ltdl*库，在你的项目中便捷地构建和使用动态加载模块。
- en: When I talk about the version of a library, I’m referring specifically to the
    version of the library’s public interface, but I need to clearly define the term
    *interface* in this context. A *shared-library interface* refers to all aspects
    of a shared library’s connections with the outside world. Besides the function
    and data signatures that a library exports, these connections include files and
    file formats, network connections and wire data formats, IPC channels and protocols,
    and so on. When considering whether to assign a new version to a shared library,
    you should carefully examine all aspects of the library’s interactions with the
    world to determine if a change will cause the library to act differently from
    a user’s perspective.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈到一个库的版本时，我特指库公共接口的版本，但我需要在此上下文中清楚地定义*接口*这一术语。*共享库接口*指的是共享库与外界所有的连接方面。除了库导出的函数和数据签名之外，这些连接还包括文件和文件格式、网络连接和数据格式、IPC通道和协议等等。在考虑是否为共享库分配一个新版本时，你应当仔细检查库与外部世界的所有交互，以确定变动是否会导致库在用户角度上的表现发生变化。
- en: Libtool’s attempts to hide the differences among shared-library platforms are
    so well conceived that if you’ve always used Libtool to build shared libraries,
    you may not even realize that the way shared libraries are versioned is significantly
    different between platforms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool试图隐藏共享库平台之间的差异，其设计如此巧妙，以至于如果你一直使用Libtool来构建共享库，你可能甚至没有意识到不同平台之间共享库版本控制的方式存在显著差异。
- en: System-Specific Versioning
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统特定的版本控制
- en: Let’s examine how shared-library versioning works on a few different systems
    to put the Libtool abstraction into context.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在几个不同的系统上共享库版本控制是如何工作的，从而为Libtool抽象提供一些背景。
- en: Shared-library versioning can be done either internally or externally. *Internal
    versioning* means that the library name does not reflect its version in any way.
    Thus, internal versioning implies that some form of executable header information
    provides the linker with the appropriate function calls for the requested *application
    binary interface (ABI)*. This also implies that all function calls for all versions
    of the library are maintained within the same shared-library file. Libtool supports
    internal versioning where mandated by platform requirements, but it prefers to
    use external versioning. With *external versioning*, version information is specified
    in the filename itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库版本控制可以是内部的也可以是外部的。*内部版本控制*意味着库的名称与其版本没有任何关联。因此，内部版本控制意味着某种形式的可执行文件头信息向链接器提供适当的函数调用，以满足所请求的*应用程序二进制接口（ABI）*。这也意味着所有版本的库的函数调用都保存在同一个共享库文件中。Libtool支持根据平台要求使用内部版本控制，但它更倾向于使用外部版本控制。在*外部版本控制*中，版本信息直接在文件名中指定。
- en: In addition to library-level versioning, wherein a particular version number
    or string refers to the entire library interface, many Unix systems support a
    form of export- or symbol-level versioning, wherein a shared library exports multiple
    named or numbered versions of the same function or global data item. While Libtool
    does not hinder the use of such export-level versioning schemes on a per-system
    basis, it does not provide any specific portability support for them, either.
    Therefore, I won’t go into great detail on this subject.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了库级别的版本控制，在这种控制中，特定的版本号或字符串表示整个库接口，许多Unix系统还支持一种导出级别或符号级别的版本控制，其中共享库导出多个具有命名或编号版本的相同函数或全局数据项。虽然Libtool不会妨碍在每个系统上使用这种导出级别的版本控制方案，但它也没有为其提供任何特定的可移植性支持。因此，我不会详细讨论这个话题。
- en: '*Linux and Solaris Library Versioning*'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Linux和Solaris库版本控制*'
- en: 'Modern Linux borrows much of its library versioning system from Oracle’s Solaris
    operating system, version 9.^([1](footnote.xhtml#ch08fn1)) These systems use a
    form of external library versioning in which version information is encoded in
    the shared-library filename, following a specific pattern or template. Let’s look
    at a partial directory listing for the */usr/lib/x86_64-linux-gnu* directory on
    a typical Linux system—specifically, the files associated with a fairly typical
    library, *libcurl*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Linux借鉴了Oracle Solaris操作系统9版的库版本控制系统。^([1](footnote.xhtml#ch08fn1))这些系统使用一种外部库版本控制形式，其中版本信息编码在共享库的文件名中，遵循特定的模式或模板。我们来看一下典型Linux系统中*/usr/lib/x86_64-linux-gnu*目录的部分目录列表——特别是与一个相当典型的库*libcurl*相关的文件：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The content in this console directory listing is specific to my system, which
    is based on a Debian distribution. If your distribution is not based on Debian,
    you will probably see a somewhat different listing—perhaps even significantly
    different. In this case, do not try to follow along on your system. Instead, just
    follow my example here as you read the following description. The concepts, not
    the filenames, are the important part of this discussion*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*此控制台目录列表中的内容特定于我的系统，该系统基于Debian发行版。如果您的发行版不是基于Debian的，您可能会看到稍微不同的目录列表——甚至可能会有显著不同。在这种情况下，请不要试图在您的系统上跟随操作。相反，阅读以下描述时，只需按照我的示例进行。这里讨论的重点是概念，而不是文件名*。'
- en: 'Library names on Linux systems conform to a standard format: *lib*name*.so.*X*.*Y.
    The X*.*Y portion of the format represents the version information, where X is
    the major version number (always a single number) and Y is the minor version number
    (which may contain multiple dot-separated parts). The general rule is that changes
    in X represent non-backward-compatible changes to the library’s ABI, while changes
    in Y represent backward-compatible modifications, including isolated additions
    to the library’s interface and nonintrusive bug fixes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统上的库名称遵循标准格式：*lib*name*.so.*X*.*Y。格式中的X*.*Y部分表示版本信息，其中X是主版本号（始终是一个数字），Y是次版本号（可能包含多个由点分隔的部分）。一般规则是，X的变化表示对库的ABI的非向后兼容的更改，而Y的变化表示向后兼容的修改，包括库接口的孤立添加和不干扰的错误修复。
- en: Often, you’ll see what appears to be a third numbered component. The entry at
    ➍, for example, represents the actual *curl* shared library, *libcurl.so.4.4.0*.
    In this example, the last two numbers (*4.0*) really just represent a two-part
    minor version number. Such additional numeric information in the minor version
    number is sometimes referred to as the library’s *patch level*.^([2](footnote.xhtml#ch08fn2))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会看到一个看起来像是第三个编号组件的部分。例如，4号位置的条目表示实际的*curl*共享库，*libcurl.so.4.4.0*。在这个例子中，最后两个数字（*4.0*）实际上只是代表一个两部分的次版本号。次版本号中的这种附加数字信息有时被称为库的*补丁级别*。^([2](footnote.xhtml#ch08fn2))
- en: The *libcurl.so.4* entry at ➌ is referred to as the library’s *shared object
    name (soname)*^([3](footnote.xhtml#ch08fn3)) and is actually a soft link that
    points to the binary file. The soname is the format that consuming programs and
    libraries reference internally—that is, the linker embeds this name in the consuming
    program or library when it’s built. The soft link is created by the `ldconfig`
    utility, which (among other things) ensures that an appropriate soname can locate
    the latest minor version of an installed library. The `ldconfig` utility is usually
    executed by post-install scripts and triggers of RPM and Debian packages. Therefore,
    while the soname is not created or installed by the `make install` target, it
    is most often created by distro installation packages and, therefore, by Linux
    packagers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处的 *libcurl.so.4* 条目被称为库的 *共享对象名称（soname）*^([3](footnote.xhtml#ch08fn3))，实际上是一个软链接，指向二进制文件。soname
    是消费程序和库在内部引用的格式——也就是说，链接器在构建时将此名称嵌入到消费程序或库中。软链接由 `ldconfig` 工具创建，`ldconfig` 除了其他功能外，还确保适当的
    soname 可以定位到已安装库的最新次版本。`ldconfig` 通常由安装后脚本以及 RPM 和 Debian 包的触发器执行。因此，尽管 soname
    不是通过 `make install` 目标创建或安装的，但它通常是由发行版安装包创建的，因此也由 Linux 打包工具创建。
- en: Notice how this versioning scheme allows multiple sonames for different major
    versions and multiple binaries with different major and minor versions to all
    coexist within a single directory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种版本管理方案如何允许不同主版本的多个 soname 以及多个具有不同主版本和次版本的二进制文件在同一目录中共存。
- en: Development packages for a library (ending in *-dev* or *-devel*) often install
    a so-called *linker name* entry (at ➋) as well. The linker name is a soft link
    ending only in *.so* that usually points to the soname, though in some cases (such
    as this one), it may refer directly to the binary shared library. The linker name
    is the name by which a library is referred to on the linker command line. The
    development library allows you to run programs on your system that are linked
    against the latest version of a library but develop against an older version of
    that library, or vice versa.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 库的开发包（以 *-dev* 或 *-devel* 结尾）通常还会安装一个所谓的 *链接器名称* 条目（在 ➋ 处）。链接器名称是一个仅以 *.so*
    结尾的软链接，通常指向 soname，尽管在某些情况下（如本例）它可能直接指向二进制共享库。链接器名称是链接器命令行中引用库的名称。开发库使得你可以运行那些链接到库的最新版本的程序，但在较旧版本的库上进行开发，反之亦然。
- en: The entry at ➊ refers to the static archive form of the library, which has a
    *.a* extension on Linux and Solaris systems. The remaining entries represent other
    forms of the *curl* library set generated for purposes specific to the *curl*
    package.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的条目指的是库的静态归档形式，在 Linux 和 Solaris 系统上具有 *.a* 扩展名。其余条目表示为特定于 *curl* 包生成的 *curl*
    库集的其他形式。
- en: The *curl* library has become an important part of modern Linux systems over
    the years; it’s used by many other programs installed on the system, some of which
    have not been upgraded to the latest major version. The maintainers assert that
    major version 4 is backward compatible with major version 3\. Therefore, sonames
    referring to version 3 are directed toward version 4 of the libraries on systems
    where version 4 is installed. This is not necessarily a common practice, but it
    happens to work in this case.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*curl* 库已经成为现代 Linux 系统中不可或缺的一部分；它被许多其他安装在系统上的程序使用，其中一些程序尚未升级到最新的主版本。维护者声明，主版本
    4 向后兼容主版本 3。因此，指向版本 3 的 soname 会在安装了版本 4 的系统上指向版本 4 的库文件。这并不一定是常见的做法，但在这种情况下它是有效的。'
- en: From here on out, the waters become muddied by a strange array of external and
    internal shared-library versioning techniques. Each of these less-than-intuitive
    systems is designed to overcome some of the fundamental problems that have been
    discovered in the Solaris system over the years.^([4](footnote.xhtml#ch08fn4))
    Let’s look at a few of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从此开始，外部和内部共享库版本管理技术的奇怪阵列使得问题变得复杂。这些不太直观的系统每一个都是为了克服多年来在 Solaris 系统中发现的一些基本问题而设计的。^([4](footnote.xhtml#ch08fn4))让我们看一下其中的一些。
- en: '*IBM AIX Library Versioning*'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*IBM AIX 库版本管理*'
- en: Traditionally, IBM’s AIX used a form of internal versioning, storing all library
    code within a single archive file that follows the pattern *lib*name.*a*. This
    file may actually contain both static and shared forms of code, as well as 32-bit
    and 64-bit code. Internally, all shared-library code is stored in a single, logical,
    shared-object file within the archive file, while static library objects are stored
    as individual logical object files within the archive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，IBM 的 AIX 使用一种内部版本控制形式，将所有库代码存储在一个单独的归档文件中，该文件遵循 *lib*name.*a* 的模式。这个文件实际上可能同时包含静态和共享形式的代码，以及
    32 位和 64 位代码。内部来说，所有共享库代码都存储在归档文件中的一个单一逻辑共享对象文件中，而静态库对象则存储为归档文件中的单独逻辑对象文件。
- en: I say “traditionally” because more recent versions of AIX (including all 64-bit
    versions) now support the concept of loading shared-library code directly from
    physical *.so* files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“传统上”是因为更近期的 AIX 版本（包括所有 64 位版本）现在支持直接从物理 *.so* 文件加载共享库代码的概念。
- en: Libtool generates shared-library code on AIX using both of these schemes. If
    the AIX `-brtl` native linker flag is specified on the command line, Libtool generates
    shared libraries with *.so* extensions. Otherwise, it generates combined libraries
    following the older, single-file scheme.^([5](footnote.xhtml#ch08fn5))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 在 AIX 上使用这两种方案生成共享库代码。如果命令行上指定了 AIX `-brtl` 本地链接器标志，Libtool 会生成带有 *.so*
    扩展名的共享库。否则，它会生成遵循旧版单文件方案的合并库。^([5](footnote.xhtml#ch08fn5))
- en: When using the *.so* file scheme on AIX, Libtool generates libraries named in
    the Linux/Solaris pattern in order to maintain a degree of alliance with these
    more popular platforms. Regardless of the shared-library extension used, however,
    version information is still not stored in the filename; it is stored internally,
    within the library and consuming executables. As far as I can tell, Libtool ensures
    that the correct internal structures are created to reflect the proper versioning
    information within the shared-library header. It does this by passing appropriate
    flags to the native linker with embedded version information derived from the
    Libtool version string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AIX 上使用 *.so* 文件方案时，Libtool 会生成采用 Linux/Solaris 命名模式的库，以便与这些更流行的平台保持一定程度的兼容性。然而，无论使用哪种共享库扩展名，版本信息仍然不会存储在文件名中；它存储在库和使用的可执行文件内部。就我所知，Libtool
    会确保创建正确的内部结构，以反映共享库头文件中的正确版本信息。它通过将适当的标志传递给本地链接器，嵌入由 Libtool 版本字符串派生的版本信息来实现这一点。
- en: Executables on most Unix systems also support the concept of an embedded runtime
    library search path (called a *`LIBPATH`* on AIX), which usually specifies a set
    of colon-separated filesystem paths to be searched for shared-library dependencies.
    You can use Libtool’s `-R` command line option to specify a library search path
    for both programs and libraries. Libtool will translate this option to the appropriate
    GNU or native linker option on any given system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Unix 系统上的可执行文件也支持嵌入式运行时库搜索路径的概念（在 AIX 上称为 *`LIBPATH`*），通常指定一组用冒号分隔的文件系统路径，用于搜索共享库依赖项。你可以使用
    Libtool 的 `-R` 命令行选项来为程序和库指定一个库搜索路径。Libtool 会将此选项转换为适当的 GNU 或本地链接器选项，适用于任何给定的系统。
- en: I say executables *usually* support this option because on AIX, there are a
    few nuances. If all of the directories specified in the `LIBPATH` are real directories,
    everything works as expected—that is, the `LIBPATH` acts purely as a library search
    path. However, if the first segment of the `LIBPATH` is not a real filesystem
    entry, it acts as a so-called *loader domain*, which is basically a namespace
    for a particular shared library. Thus, multiple shared libraries of the same name
    can be stored within the same AIX archive (*.a*) file, each assigned (by linker
    options) to a different loader domain. The library that matches the loader domain
    specified in the `LIBPATH` is loaded from the archive. This can have nasty side
    effects if you assign a loader domain via the `LIBPATH` that later becomes (by
    chance) a real filesystem entry. On the other hand, you could also specify a search
    directory in the `LIBPATH` that happens to match a loader domain in a shared library.
    If that directory is removed later, you’ll unintentionally begin to use the loader
    domain. As you can imagine, strange behavior ensues. Most of these issues have
    been solved by AIX developers by ensuring that loader domain strings look nothing
    like filesystem paths.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我说可执行文件*通常*支持这个选项，因为在 AIX 上有一些细微差别。如果 `LIBPATH` 中指定的所有目录都是真实目录，一切按预期工作——也就是说，`LIBPATH`
    仅作为库搜索路径。然而，如果 `LIBPATH` 的第一个部分不是一个真实的文件系统条目，它就充当所谓的*加载器域*，本质上是某个特定共享库的命名空间。因此，同名的多个共享库可以存储在同一个
    AIX 档案（*.a*）文件中，每个都被分配（通过链接器选项）到不同的加载器域。与 `LIBPATH` 中指定的加载器域匹配的库将从档案中加载。如果你通过
    `LIBPATH` 分配了一个加载器域，后来恰好成为一个真实的文件系统条目，这可能会产生不良副作用。另一方面，你也可以在 `LIBPATH` 中指定一个搜索目录，恰好与共享库中的某个加载器域匹配。如果该目录后来被删除，你将无意中开始使用该加载器域。正如你所想，奇怪的行为随之而来。AIX
    开发人员通过确保加载器域字符串与文件系统路径完全不同，解决了大部分这些问题。
- en: On AIX systems, all code, whether static or shared, is compiled as position-independent
    code because AIX has only ever been ported to PowerPC and RS/6000 processors.
    The architectures of these processors only allow for PIC code, so AIX compilers
    can’t generate non-PIC code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AIX 系统上，所有代码，无论是静态的还是共享的，都是以位置独立代码（PIC）形式编译的，因为 AIX 只曾移植到 PowerPC 和 RS/6000
    处理器上。这些处理器的架构仅支持 PIC 代码，因此 AIX 编译器无法生成非 PIC 代码。
- en: '*Microsoft DLL Versioning*'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*微软 DLL 版本管理*'
- en: Consider Microsoft Windows *dynamic link libraries (DLLs)*, which are shared
    libraries in every sense of the word and provide a proper application programming
    interface (API). But unfortunately, Microsoft has, in the past, provided no integrated
    DLL interface versioning scheme. As a result, Windows developers have often referred
    to DLL versioning issues (tongue-in-cheek, I’m sure) as *DLL hell*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑微软 Windows 的*动态链接库（DLL）*，它们在所有意义上都是共享库，并提供了适当的应用程序编程接口（API）。但不幸的是，微软过去并未提供集成的
    DLL 接口版本管理方案。因此，Windows 开发人员常常将 DLL 版本管理问题（我相信他们开玩笑的）称为*DLL 地狱*。
- en: As a sort of Band-Aid fix to this problem, DLLs on Windows systems can be installed
    into the same directory as the program that uses them. The Windows operating system
    loader will always attempt to use the local copy before searching for a copy in
    the system path. This alleviates a part of the problem because it allows you to
    install a specific version of the library with the package that requires it. While
    this is a fair solution, it’s not really a good solution, because one of the major
    benefits of shared libraries is that they can be shared—both on disk and in memory.
    If every application has its own copy of a different version of the library, then
    this benefit of shared libraries is lost—both on disk and in memory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决此问题的临时补救方法，Windows 系统上的 DLL 可以安装到与使用它们的程序相同的目录中。Windows 操作系统加载器总是会尝试先使用本地副本，然后才会在系统路径中查找副本。这在一定程度上缓解了问题，因为它允许你与需要该库的包一起安装特定版本的库。尽管这是一个合理的解决方案，但并不是一个理想的解决方案，因为共享库的主要优点之一是它们可以共享——无论是在磁盘上还是在内存中。如果每个应用程序都有自己的一份不同版本的库副本，那么共享库的这一优点就会丧失——无论是在磁盘上还是在内存中。
- en: Since the introduction of this partial solution years ago, Microsoft hasn’t
    paid much attention to DLL-sharing efficiency issues. The reasons for this include
    both a cavalier attitude regarding the cost of disk space and RAM and a technical
    issue regarding the implementation of Windows DLLs. Instead of generating position-independent
    code, Microsoft system architects chose to link DLLs with a specific base address
    and then list all of the absolute address references in a base table in the library
    image header. When a DLL can’t be loaded at the desired base address (because
    of a conflict with another DLL), the loader *rebases* the DLL by picking a new
    base address and changing all of the absolute addresses in the code segment that
    are referred to in the base table. When a DLL is rebased in this manner, it can
    only be shared with processes that happen to rebase the DLL to the same address.
    The odds of accidentally encountering such a scenario—especially among applications
    with many DLL components—are pretty slim.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自从多年前引入这一部分解决方案以来，微软对DLL共享效率问题并未给予太多关注。原因包括对磁盘空间和RAM消耗的轻视态度，以及实现Windows DLL时的技术问题。微软的系统架构师没有生成位置无关代码，而是选择将DLL与特定的基地址链接，然后在库镜像头部的基表中列出所有的绝对地址引用。当DLL无法在期望的基地址加载时（因为与另一个DLL发生冲突），加载器会*重定位*该DLL，通过选择一个新的基地址并更改代码段中基表所引用的所有绝对地址。当DLL以这种方式被重定位时，它只能与那些恰好将DLL重定位到相同地址的进程共享。尤其是对于包含许多DLL组件的应用程序，偶然遇到这种情况的几率是相当小的。
- en: More recently, Microsoft invented the concept of the *side-by-side cache* (sometimes
    referred to as *SxS*), which allows developers to associate a unique identification
    value (a GUID, in fact) with a particular version of a DLL installed in a system
    location. The location directory name is derived from the DLL name and the version
    identifier. Applications built against SxS-versioned libraries have metadata stored
    in their executable headers indicating the specifically versioned DLLs they require.
    If the right version is found (by newer OS loaders) in the SxS cache, then it
    is loaded. Based on policy in the EXE header’s metadata, the loader can revert
    to the older scheme of looking for a local copy and then a global copy of the
    DLL. This is a vast improvement over earlier solutions, and it provides a very
    flexible versioning system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，微软发明了*并行缓存*（有时称为*SxS*）的概念，它允许开发人员将一个唯一的标识值（实际上是一个GUID）与安装在系统位置的特定版本的DLL关联。该位置目录的名称是从DLL名称和版本标识符派生出来的。基于SxS版本库构建的应用程序，其可执行文件头中会存储元数据，指示它们所需的特定版本的DLL。如果在SxS缓存中找到正确的版本（通过更新的操作系统加载器），那么它会被加载。根据EXE头部元数据中的策略，加载器可以回退到旧的方案，即先查找本地副本，然后查找全局副本的DLL。这比早期的解决方案有了极大的改进，并提供了一个非常灵活的版本控制系统。
- en: The side-by-side cache effectively moves the Windows DLL architecture a step
    closer to the Unix way of managing shared libraries. Think of the SxS as a system
    installation location for libraries—much like the */usr/lib* directory on Unix
    systems. Also similar to Unix, multiple versions of the same DLL may be co-installed
    in the side-by-side cache.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并行缓存实际上将Windows的DLL架构向Unix管理共享库的方式更靠近一步。可以把SxS看作是库的系统安装位置——就像Unix系统中的*/usr/lib*目录一样。与Unix类似，相同的DLL的多个版本可以并行安装在并行缓存中。
- en: Regardless of the similarities, since DLLs use the rebasing technique as opposed
    to PIC code, the side-by-side cache is still a fairly benign efficiency improvement
    with respect to applications that manage dozens of shared libraries. SxS is really
    intended for system libraries that many applications are likely to consume. These
    are generally based at different addresses so that the odds of clashing (and thus
    rebasing) are decreased but not entirely eliminated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有相似之处，但由于DLL使用的是重定位技术，而不是PIC代码，针对管理大量共享库的应用程序，并行缓存仍然是一个相当温和的效率提升。SxS实际上是为许多应用程序可能会使用的系统库设计的。这些库通常位于不同的地址上，因此发生冲突（进而需要重定位）的可能性降低，但并没有完全消除。
- en: The entire based approach to shared libraries has the major drawback that the
    program address space may become fairly fragmented as the system loader honors
    randomly chosen base addresses throughout a 32-bit address space. Fortunately,
    64-bit addressing helps tremendously in this area, so you may find the side-by-side
    cache to be much more effective with respect to improving memory-use efficiency
    on 64-bit Windows systems, which are the norm these days anyway.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库的整个基础方法的主要缺点是，程序的地址空间可能会变得相当分散，因为系统加载器会在32位地址空间中随机选择基址并予以处理。幸运的是，64位寻址在这一领域帮助巨大，因此在64位Windows系统上，你可能会发现并排缓存对于提高内存使用效率更为有效，而如今64位系统已是常态。
- en: '*HP-UX/AT&T SVR4 Library Versioning*'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*HP-UX/AT&T SVR4库版本管理*'
- en: Hewlett Packard’s version of Unix (since HP-UX version 10.0) adds a form of
    library-level versioning that’s very similar to the versioning used in AT&T UNIX
    System V Release 4\. For our purposes, you can consider these two types of systems
    to work nearly the same way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 惠普的Unix版本（自HP-UX 10.0版本以来）增加了一种库级版本管理方式，这与AT&T UNIX System V Release 4中使用的版本管理非常相似。对于我们的目的，你可以认为这两种系统的工作方式几乎相同。
- en: The native linker looks for libraries specified by their base name with a *.sl*
    extension. However, consuming programs and libraries contain a reference to that
    library’s *internal name*. The internal name is assigned to the library by a linker
    command line option and should contain the library’s interface version number.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本地链接器会根据基础名称和*.sl*扩展名查找指定的库。然而，使用的程序和库包含对该库*内部名称*的引用。内部名称是通过链接器命令行选项分配给库的，并且应该包含该库的接口版本号。
- en: 'The actual library is named with only the major interface version as an extension,
    and a soft link is created with a *.sl* extension pointing to the library. Thus,
    a shared library on these systems will follow this pattern:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的库仅以主要接口版本号作为扩展名命名，并且创建一个软链接，指向具有*.sl*扩展名的库。因此，在这些系统上，共享库将遵循以下模式：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only version information we have to work with is a major version number,
    which should be used to indicate non-backward-compatible changes from one version
    to the next. Since there’s no minor version number, as on Linux or Solaris, we
    can’t keep multiple revisions of a particular interface version around. The only
    option is to replace version zero of a library with an updated version zero if
    bug fixes or backward-compatible enhancements (that is to say, non-intrusive additions
    to the interface) are made.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所能使用的唯一版本信息是一个主要版本号，用于表示从一个版本到下一个版本之间的不兼容更改。由于没有像Linux或Solaris那样的次要版本号，我们不能保留特定接口版本的多个修订版。唯一的选择是，如果进行了错误修复或向后兼容的增强（即对接口的非侵入性添加），则用更新后的版本零替换版本零。
- en: However, we can still have multiple major versions of the library co-installed,
    and Libtool takes full advantage of what’s available on these systems.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然可以共同安装多个主要版本的库，Libtool充分利用了这些系统上可用的功能。
- en: The Libtool Library Versioning Scheme
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Libtool库版本管理方案
- en: The authors of Libtool tried hard to provide a versioning scheme that could
    be mapped to any of the schemes used by any Libtool platform. The Libtool versioning
    scheme is designed to be flexible enough to be forward compatible with reasonable
    future changes to existing Libtool platforms and even to new Libtool platforms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool的作者们努力提供一个可以映射到任何Libtool平台所使用的任何版本管理方案的方案。Libtool版本管理方案被设计得足够灵活，以便与现有Libtool平台的合理未来更改兼容，甚至可以兼容新的Libtool平台。
- en: Nevertheless, it’s not a panacea. When Libtool has been extended for a new type
    of shared-library platform, situations have occurred (and continue to occur) that
    require some serious and careful evaluation. No one can be an expert on all systems,
    so the Libtool developers rely heavily on outside contributions to create proper
    mappings from the Libtool versioning scheme to the schemes of new or would-be
    Libtool platforms.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是万灵药。当Libtool扩展到一种新的共享库平台时，已经发生了（并且仍然会发生）一些需要认真评估的情况。没有人能成为所有系统的专家，因此Libtool开发者非常依赖外部贡献，以创建从Libtool版本管理方案到新平台或潜在Libtool平台方案的正确映射。
- en: '*Library Versioning Is Interface Versioning*'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*库版本管理即接口版本管理*'
- en: You should consciously avoid thinking of library version numbers (either Libtool’s
    or those of a particular platform) as product *major*, *minor*, and *revision*
    (also called *patch* or *micro*) values. In fact, these values have very specific
    meanings to the operating system loader, and they must be updated properly for
    each new library version in order to keep from confusing the loader. A confused
    loader could load the wrong version of a library based on incorrect version information
    assigned to the library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有意识地避免将库版本号（无论是 Libtool 的版本号，还是特定平台的版本号）看作是产品的*主版本*、*次版本*和*修订版*（也叫做*补丁*或*微版本*）。事实上，这些版本值对操作系统加载器有非常具体的含义，它们必须在每个新版本的库中正确更新，以避免混淆加载器。一个混淆的加载器可能会根据分配给库的错误版本信息加载错误的库版本。
- en: Several years ago, I was working with my company’s corporate versioning committee
    to come up with a software-versioning policy for the company as a whole. The committee
    wanted the engineers to ensure that the version numbers incorporated into our
    shared-library names were in alignment with the corporate software-versioning
    strategy. It took me the better part of a day to convince them that a shared-library
    version was not related to a product version in any way, nor should such a relationship
    be established or enforced by them or by anyone else.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我和公司内部的版本控制委员会一起，为整个公司制定软件版本管理政策。委员会希望工程师们确保我们共享库名称中的版本号与公司软件版本管理策略保持一致。花了我大半天时间才说服他们，共享库版本与产品版本没有任何关系，也不应该由他们或任何其他人建立或强制这种关系。
- en: 'Here’s why: the version number on a shared library is not really a library
    version but an interface version. The *interface* I’m referring to here is the
    application binary interface presented by a library to the user, another programmer
    desiring to call functions presented by the interface. An executable program has
    a single, well-defined, standard entry point (usually called `main` in the C language).
    But a shared library has multiple entry points that are generally not standardized
    in a manner that is widely understood. This makes it much more difficult to determine
    whether or not a particular version of a library is interface compatible with
    another version of the same library.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为什么：共享库上的版本号实际上并不是库版本，而是接口版本。我这里提到的*接口*是指库向用户展示的应用程序二进制接口，另一个程序员希望调用由该接口提供的函数。一个可执行程序有一个单一、明确、标准的入口点（通常在
    C 语言中称为 `main`）。但共享库有多个入口点，这些入口点通常没有被广泛理解的标准化方式。这使得判断特定版本的库是否与同一库的另一个版本接口兼容变得更加困难。
- en: In Libtool’s versioning scheme, shared libraries are said to support a range
    of interface versions, each identified by a unique integer value. If any publicly
    visible aspect of an interface changes between public releases, it can no longer
    be considered the same interface; it therefore becomes a new interface, identified
    by a new integer identifier. Each public release of a library in which the interface
    has changed simply acquires the next consecutive interface version number. Libraries
    that change in a backward-compatible manner between releases are said to support
    both the old and the new interface; thus, a particular release of a library may
    support interface versions 2 through 5, for example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Libtool 的版本控制方案中，共享库被认为支持一系列接口版本，每个版本由一个唯一的整数值标识。如果接口的任何公开可见部分在公开发布之间发生变化，就不能再认为它是同一个接口；它因此成为一个新的接口，由一个新的整数标识符标识。每次公开发布库时，如果接口发生了变化，就会获得下一个连续的接口版本号。那些在发布之间以向后兼容的方式发生变化的库被认为同时支持旧接口和新接口；因此，一个特定的库版本可能支持版本
    2 到 5 之间的接口。
- en: Libtool library version information is specified on the `libtool` command line
    with the `-version-info` option, as shown in [Listing 8-1](ch08.xhtml#ch08ex1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 库版本信息通过 `libtool` 命令行中的 `-version-info` 选项进行指定，如[清单 8-1](ch08.xhtml#ch08ex1)所示。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-1: Setting shared-library version information in a* Makefile.am
    *file*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：在* Makefile.am *文件中设置共享库版本信息*'
- en: The Libtool developers wisely chose the colon separator over the period in an
    effort to keep developers from trying to directly associate Libtool version string
    values with the version numbers appended to the end of shared-library files on
    various platforms. The three values in the version string are respectively called
    the interface *current*, *revision*, and *age* values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 开发者明智地选择了冒号作为分隔符，而不是使用句点，以避免开发者试图将 Libtool 的版本字符串值与各个平台上共享库文件末尾附加的版本号直接关联。版本字符串中的三个值分别称为接口的*当前*、*修订版*和*年龄*值。
- en: The *current* value represents the current interface version number. This is
    the value that changes when a new interface version must be declared because the
    interface has changed in some publicly visible way since the last public release
    of the library. The first interface in a library is given a version number of
    zero by convention. Consider a shared library in which the developer has added
    a new function to the set of functions exposed by this library since the last
    public release. The interface can’t be considered the same in this new version
    because there’s one additional function. Thus, its *current* number must be increased
    from zero to one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*当前*值表示当前接口的版本号。当接口自上次库的公共发布以来以某种公开可见的方式发生变化时，就必须声明新的接口版本，且此值会发生变化。根据约定，库中的第一个接口版本号为零。假设在一个共享库中，开发者自上次公共发布以来添加了一个新函数到该库暴露的函数集中。由于多了一个新函数，这个版本的接口不再和上一个版本相同。因此，*当前*值必须从零增加到一。'
- en: The *age* value represents the number of back versions supported by the shared
    library. In mathematical terms, the library is said to support the interface range,
    *current − age* through *current*. In the example I just gave, a new function
    was added to the library, so the interface presented in this version of the library
    is not the same as it was in the previous version. However, the previous version
    is still fully supported, because the previous interface is a proper subset of
    the current interface. Therefore, the *age* value should also be incremented from
    zero to one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*年龄*值表示共享库支持的回溯版本的数量。从数学角度来看，可以认为库支持的接口范围是 *current − age* 到 *current*。在我刚才给出的例子中，由于向库中添加了一个新函数，所以这个版本的库接口与之前的版本不同。然而，之前的版本仍然完全支持，因为旧接口是当前接口的一个适当子集。因此，*年龄*值应该从零增加到一。'
- en: The *revision* value merely represents a serial revision of the current interface.
    That is, if no publicly visible changes are made to a library’s interface between
    releases—perhaps only an internal function was optimized—then the library name
    should change in some manner, if only to distinguish between the two releases.
    But both the *current* and *age* values would be the same, because the interface
    has not changed from the user’s perspective. Therefore, the *revision* value is
    incremented to reflect the fact that this is a new release of the same interface.
    In the previous example, the *revision* value would be left at zero, because one
    or both of the other values were incremented.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*修订版*值仅表示当前接口的一个序列修订版本。也就是说，如果在两个发布版本之间，库的接口没有任何公开可见的更改——可能只是优化了一个内部函数——那么库的名称应该以某种方式发生变化，至少是为了区分这两个版本。但是，*当前*值和*年龄*值将保持不变，因为从用户的角度来看，接口没有发生变化。因此，*修订版*值会增加，以反映这是相同接口的新版本。在前面的例子中，*修订版*值将保持为零，因为其他两个值之一或两者都已经增加。'
- en: To simplify the release process for shared libraries, the Libtool versioning
    algorithm should be followed step-wise for each new version of a library that
    is about to be publicly released:^([6](footnote.xhtml#ch08fn6))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化共享库的发布过程，应遵循 Libtool 版本算法，逐步处理每个即将公开发布的库的新版本：^([6](footnote.xhtml#ch08fn6))
- en: Start with version information 0:0:0 for each new Libtool library. (This is
    done automatically if you simply omit the `-version-info` option from the list
    of linker flags passed to the `libtool` script.) For existing libraries, start
    with the previous public release’s Libtool version information.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个新的 Libtool 库，版本信息从 0:0:0 开始。（如果你从传递给 `libtool` 脚本的链接器标志列表中省略 `-version-info`
    选项，这一过程会自动完成。）对于现有库，从之前的公共发布的 Libtool 版本信息开始。
- en: If the library source code has changed at all since the last update, then increment
    *revision* (*c*:*r*:*a* becomes *c*:*r*+1:*a*).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果自上次更新以来，库的源代码有任何更改，那么*修订版*（*c*:*r*:*a*变为*c*:*r*+1:*a*）。
- en: If any exported functions or data have been added, removed, or changed since
    the last update, increment *current* and set *revision* to 0.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果自上次更新以来，任何导出的函数或数据有添加、删除或更改，增加 *current* 并将 *revision* 设置为 0。
- en: If any exported functions or data have been added since the last public release,
    increment *age*.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果自上次公开发布以来，任何导出的函数或数据有添加，增加 *age*。
- en: If any exported functions or data have been removed since the last public release,
    set *age* to 0.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果自上次公开发布以来，任何导出的函数或数据被删除，设置 *age* 为 0。
- en: Keep in mind that this is an algorithm; as such, it’s designed to be followed
    step-by-step as opposed to jumping directly to the steps that appear to apply
    to your case. For example, if you removed an API function from your library since
    the last release, you would not simply jump to the last step and set *age* to
    zero. Rather, you would follow all of the steps until you reached the last step,
    and *then* set *age* to zero.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个算法；因此，它设计为逐步执行，而不是直接跳到看似适用于你情况的步骤。例如，如果你自上次发布以来删除了一个 API 函数，你不会简单地跳到最后一步并将
    *age* 设置为零。而是，你需要遵循所有步骤直到最后一步，然后 *再* 设置 *age* 为零。
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Remember to update the version information only immediately before a public
    release of your software. More frequent updates are unnecessary and only guarantee
    that the *current* interface number becomes larger faster*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，仅在软件的公开发布之前立即更新版本信息。更频繁的更新是不必要的，并且只会确保 *current* 接口编号变得更大更快*。'
- en: 'Let’s look at an example. Assume that this is the second release of a library
    and the first release used a `-version-info` string of `0:0:0`. One new function
    was added to the library interface during this development cycle, and one existing
    function was deleted. The effect on the version information string for this new
    release of the library would be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个例子。假设这是库的第二个发布版本，而第一个发布版本使用了 `-version-info` 字符串 `0:0:0`。在这个开发周期中，向库接口添加了一个新功能，并删除了一个现有功能。这个新发布版本的版本信息字符串将如下所示：
- en: 'Begin with the previous version information: `0:0:0`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个版本信息开始：`0:0:0`。
- en: '`0:0:0` becomes `0:1:0` (the library’s source was changed).'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:0:0` 变为 `0:1:0`（库的源代码发生了变化）。'
- en: '`0:1:0` becomes `1:0:0` (the library’s interface was modified).'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:1:0` 变为 `1:0:0`（库的接口已被修改）。'
- en: '`1:0:0` becomes `1:0:1` (one new function was added).'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1:0:0` 变为 `1:0:1`（添加了一个新功能）。'
- en: '`1:0:1` becomes `1:0:0` (one old function was removed).'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1:0:1` 变为 `1:0:0`（删除了一个旧功能）。'
- en: It should be clear by now that there is no *direct* correlation between Libtool’s
    *current*, *revision*, and *age* values and Linux’s major, minor, and optional
    patch-level values. Instead, mapping rules are used to transform the values in
    one scheme to values in the other.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止应该很清楚，Libtool 的 *current*、*revision* 和 *age* 值与 Linux 的主要版本、次要版本和可选补丁级别之间没有
    *直接* 的关联。相反，使用映射规则将一个方案中的值转换为另一个方案中的值。
- en: Returning to the preceding example, wherein a second release of a library added
    one function and removed one function, we ended up with a new Libtool version
    string of `1:0:0`. The version string `1:0:0` indicates that the library is not
    backward compatible with the previous version (*age* is zero), so the Linux shared-library
    file would be named *lib*name.*so.1.0.0*. This looks suspiciously like the Libtool
    version string—but don’t be fooled. This fairly common coincidence is perhaps
    one of the most confusing aspects of the Libtool versioning abstraction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到前面的例子，其中库的第二个发布版本添加了一个功能并删除了一个功能，我们最终得到了一个新的 Libtool 版本字符串 `1:0:0`。版本字符串
    `1:0:0` 表示该库与之前的版本不兼容（*age* 为零），因此 Linux 共享库文件将命名为 *lib*name.*so.1.0.0*。这看起来像是
    Libtool 版本字符串——但不要被迷惑。这种常见的巧合可能是 Libtool 版本化抽象中最让人困惑的方面之一。
- en: 'Let’s modify our example just a little to say that we’ve added a new library
    interface function but haven’t removed anything. Start again with the original
    version information of `0:0:0` and follow the algorithm:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微修改一下例子，假设我们添加了一个新的库接口功能，但没有删除任何东西。重新从原始版本信息 `0:0:0` 开始，并遵循算法：
- en: 'Begin with the previous version information: `0:0:0`.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个版本信息开始：`0:0:0`。
- en: '`0:0:0` becomes `0:1:0` (the library’s source was changed).'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:0:0` 变为 `0:1:0`（库的源代码发生了变化）。'
- en: '`0:1:0` becomes `1:0:0` (the library’s interface was modified).'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:1:0` 变为 `1:0:0`（库的接口已被修改）。'
- en: '`1:0:0` becomes `1:0:1` (one new function was added).'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1:0:0` 变为 `1:0:1`（添加了一个新功能）。'
- en: Not applicable (nothing was removed).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不适用（没有删除任何东西）。
- en: This time, we end up with a Libtool version string of `1:0:1`, but the resulting
    Linux or Solaris shared-library filename is *lib*name.*so.0.1.0*. Consider for
    a moment what it means, in the face of major, minor, and patch-level values, to
    have a nonzero *age* value in the Libtool version string. An *age* value of one
    (as in this case) means that we are effectively still supporting a Linux major
    value of zero, because this new version of the library is 100 percent backward
    compatible with the previous version. The minor value in the shared-library filename
    has been incremented from zero to one to indicate that this is, in fact, an updated
    version of the soname, *lib*name.*so.0*. The patch-level value remains at zero
    because this value indicates a bug fix to a particular minor revision of an soname.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们得到了一个 Libtool 版本字符串 `1:0:1`，但生成的 Linux 或 Solaris 共享库文件名是 *lib*name.*so.0.1.0*。考虑一下，在主要版本、次要版本和补丁级别值的情况下，Libtool
    版本字符串中有一个非零的 *age* 值意味着什么。一个 *age* 值为 1（如本例所示）意味着我们实际上仍然支持 Linux 主版本为零，因为这个新版本的库与之前的版本完全向后兼容。共享库文件名中的次要版本从零增加到一，以表明这实际上是
    soname 的更新版本，*lib*name.*so.0*。补丁级别值保持为零，因为这个值表示对某个 soname 的特定次版本的错误修复。
- en: Once you fully understand Libtool versioning, you’ll find that even this algorithm
    does not cover all possible interface modification scenarios. Consider, for example,
    version information of `0:0:0` for a shared library that you maintain. Now assume
    you add a new function to the interface for the next public release. This second
    release properly defines version information of `1:0:1` because the library supports
    both interface versions 0 and 1\. However, just before the third release of the
    library, you realize you didn’t really need that new function after all, so you
    remove it. This is the only publicly visible change made to the library interface
    in this release. The algorithm would have set the version information string to
    `2:0:0`. But in fact, you’ve merely removed the second interface and are now presenting
    the original interface once again. Technically, this library would be properly
    configured with a version information string of `0:1:0` because it presents a
    second release of version 0 of the shared-library interface. The moral of this
    story is that you need to fully understand the way Libtool versioning works and
    then decide, based on that understanding, what the proper next-version values
    should be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完全理解了 Libtool 版本控制，你会发现即使这个算法也无法涵盖所有可能的接口修改场景。例如，假设你维护的共享库版本信息为 `0:0:0`。现在假设你为下一个公开版本添加了一个新函数。第二个版本正确地定义了版本信息为
    `1:0:1`，因为该库支持接口版本 0 和 1。然而，在库的第三个版本发布之前，你意识到实际上并不需要那个新函数，所以你将其移除。这是本次发布中唯一公开可见的库接口更改。按照算法，版本信息字符串应该设置为
    `2:0:0`。但实际上，你只是移除了第二个接口，现在又重新呈现了原始接口。从技术上讲，这个库应该配置为版本信息字符串 `0:1:0`，因为它展示了共享库接口版本
    0 的第二次发布。这个故事的寓意是，你需要充分理解 Libtool 版本控制的工作方式，然后根据理解决定适当的下一个版本值应该是什么。
- en: I’d also like to point out that the *GNU Libtool Manual* makes little effort
    to describe the myriad ways an interface can be different from one version of
    a library to another. An interface version indicates functional semantics as well
    as API syntax. If you change the way a function works semantically but leave the
    function signature untouched, you’ve still changed the function. If you change
    the network wire format of data sent by a shared library, then it’s not really
    the same shared library from the perspective of the consuming code. All the operating
    system loader really cares about when attempting to determine which library to
    load is, *will this library work just as well as that one?* In these cases, the
    answer would have to be no, because even though the API interface is identical,
    the publicly visible way the two libraries do things is not the same.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想指出，*GNU Libtool 手册*很少描述接口在不同版本的库之间可能存在的各种差异。接口版本不仅表示功能语义，还表示 API 语法。如果你更改了一个函数的语义方式，但保持函数签名不变，那么你仍然改变了这个函数。如果你更改了由共享库发送的数据的网络线格式，那么从消费代码的角度来看，这实际上就不再是相同的共享库了。当操作系统加载器试图确定加载哪个库时，唯一关心的问题是，*这个库能像那个库一样正常工作吗？*
    在这些情况下，答案肯定是否定的，因为即使 API 接口是相同的，两个库在公开可见的方式上做事的方式却不相同。
- en: '*When Library Versioning Just Isn’t Enough*'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*当库版本控制不足以满足需求时*'
- en: These types of changes to a library’s interface are so complex that project
    maintainers will often simply rename the library, thereby skirting library-versioning
    issues entirely. One excellent way to rename your library is to use Libtool’s
    `-release` flag. This flag adds a separate class of library versioning information
    into the base name of the library, effectively making it an entirely new library
    from the perspective of the operating system loader. The `-release` flag is used
    in the manner shown in [Listing 8-2](ch08.xhtml#ch08ex2).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对库接口的这些更改非常复杂，以至于项目维护者通常会直接重命名库，从而完全避免了库版本问题。一种很好的重命名库的方法是使用 Libtool 的 `-release`
    标志。此标志将库版本信息作为一个独立的类别添加到库的基本名称中，从操作系统加载器的角度来看，这实际上使它成为一个全新的库。`-release` 标志的使用方式如
    [列表 8-2](ch08.xhtml#ch08ex2) 中所示。
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 8-2: Setting shared-library release information in a* Makefile.am
    *file*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：在* Makefile.am *文件中设置共享库发布信息*'
- en: In this example, I used `-release` and `-version-info` in the same set of Libtool
    flags, just to show you that they can be used together. You’ll note here that
    the release string is specified as a series of dot-separated values. In this case,
    the final name of your Linux or Solaris shared library will be *lib*name-*2.9.0.so.0.0.0*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我在同一组 Libtool 标志中同时使用了 `-release` 和 `-version-info`，只是为了向你展示它们可以一起使用。你会注意到，发布字符串被指定为一系列用点分隔的值。在这种情况下，你的
    Linux 或 Solaris 共享库的最终名称将是 *lib*name-*2.9.0.so.0.0.0*。
- en: Another reason developers choose to use release strings is to provide some sort
    of correlation between library versions across platforms. As demonstrated earlier,
    a particular Libtool version information string will probably result in different
    library names across platforms because Libtool maps version information into library
    names differently from platform to platform. Release information remains stable
    across platforms, but you should carefully consider how you want to use release
    strings and version information in your shared libraries, because the way you
    choose to use them will affect binary compatibility between releases of your libraries.
    The OS loader will not consider two versions of a library compatible if they have
    different release strings, regardless of the values of those strings.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员选择使用发布字符串的另一个原因是为了在不同平台之间提供某种程度的库版本关联。如前所示，特定的 Libtool 版本信息字符串可能会导致不同平台上库名称的不同，因为
    Libtool 将版本信息以不同的方式映射到库名称中，具体取决于平台。发布信息在各平台间保持稳定，但你应该仔细考虑如何在共享库中使用发布字符串和版本信息，因为你选择的使用方式将影响库版本之间的二进制兼容性。如果两个版本的库有不同的发布字符串，操作系统加载器将不会认为它们兼容，无论这些字符串的值如何。
- en: Using libltdl
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 libltdl
- en: Now let’s move on to a discussion of Libtool’s *ltdl* library. Once again, we
    need to add some functionality to the Jupiter project in order to illustrate these
    concepts. The goal here is to create a plug-in interface that the `jupiter` program
    can use to modify output based on end-user policy choices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论 Libtool 的 *ltdl* 库。同样，我们需要为 Jupiter 项目添加一些功能，以便说明这些概念。这里的目标是创建一个插件接口，`jupiter`
    程序可以使用该接口根据最终用户的策略选择修改输出。
- en: '*Necessary Infrastructure*'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*必要的基础设施*'
- en: Currently, `jupiter` prints *Hello from jupiter!* (Actually, the name printed
    is more likely, at this point, to be a long, ugly path containing some Libtool
    directory garbage and some derivation of the name *jupiter*, but just pretend
    it prints *jupiter* for now.) We’re going to add an additional parameter named
    `salutation` to the *common* static library method, `print_routine`. This parameter
    will also be of type pointer-to-`char` and will contain the leading word or phrase—the
    salutation—in `jupiter`’s greeting.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，`jupiter` 输出 *Hello from jupiter!*（实际上，打印的名称更可能是一个长而难看的路径，包含一些 Libtool 目录垃圾和
    *jupiter* 的某些衍生名称，但现在假装它打印的是 *jupiter*）。我们将为 *common* 静态库方法 `print_routine` 添加一个名为
    `salutation` 的额外参数。这个参数也将是 `char` 类型的指针，包含 `jupiter` 问候语中的前导词或短语——即问候语。
- en: '[Listings 8-3](ch08.xhtml#ch08ex3) and [8-4](ch08.xhtml#ch08ex4) indicate the
    changes we need to make to files in the *common* subdirectory.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-3](ch08.xhtml#ch08ex3) 和 [8-4](ch08.xhtml#ch08ex4) 指出了我们需要对 *common*
    子目录中的文件进行的更改。'
- en: Git tag 8.0
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 8.0
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-3:* common/print.c: *Adding a salutation to the `print_routine`
    function*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3:* common/print.c: *向 `print_routine` 函数添加问候语*'
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-4:* common/jupcommon.h: *Adding a salutation to the `print_routine`
    prototype*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-4:* common/jupcommon.h: *向 `print_routine` 原型添加问候语*'
- en: '[Listings 8-5](ch08.xhtml#ch08ex5) and [8-6](ch08.xhtml#ch08ex6) show the changes
    we need to make to files in the *libjup* and *include* subdirectories.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-5](ch08.xhtml#ch08ex5) 和 [8-6](ch08.xhtml#ch08ex6) 显示了我们需要对 *libjup*
    和 *include* 子目录中的文件进行的更改。'
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-5:* libjup/jup_print.c: *Adding a salutation to the `jupiter_print`
    function*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5:* libjup/jup_print.c: *向 `jupiter_print` 函数添加问候语*'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8-6:* include/libjupiter.h: *Adding a salutation to the `jupiter_print`
    prototype*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6:* include/libjupiter.h: *向 `jupiter_print` 原型添加问候语*'
- en: And finally, [Listing 8-7](ch08.xhtml#ch08ex7) shows what we need to do to *main.c*
    in the *src* directory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[列表 8-7](ch08.xhtml#ch08ex7) 显示了我们需要在 *src* 目录下的 *main.c* 中所做的更改。
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 8-7:* src/main.c: *Passing a salutation to `jupiter_print`*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7:* src/main.c: *向 `jupiter_print` 传递问候语*'
- en: To be clear, all we’ve really done here is parameterize the salutation throughout
    the print routines. That way, we can indicate from `main` which salutation we’d
    like to use. I’ve set the default salutation to *Hello* so that nothing will have
    changed from the user’s perspective. Thus, the overall effect of these changes
    is benign. Note also that these are all source code changes—we’ve made no changes
    to the build system. I wanted to compartmentalize these changes so as to not confuse
    this necessary refactoring with what we’re doing to the build system to add the
    new module-loading functionality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确的是，我们所做的实际上只是将问候语参数化到打印程序中。这样，我们可以从 `main` 中指定我们想使用的问候语。我将默认问候语设置为 *Hello*，以便从用户的角度看，什么都没有改变。因此，这些更改的整体效果是无害的。还需要注意的是，这些都是源代码级的更改——我们没有对构建系统做任何更改。我想将这些更改独立出来，以免将这种必要的重构与我们为添加新的模块加载功能所做的构建系统改动混淆。
- en: After making these changes, should you update the version number of this shared
    library? That depends on whether you’ve already shipped this library (that is,
    posted a tarball) before you made the changes. The point of versioning is to maintain
    some semblance of control over your public interface—but if you’re the only one
    who has ever seen it, there’s no point in changing the version number.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些更改后，是否应该更新这个共享库的版本号？这取决于你在做出更改之前是否已经发布过这个库（即发布了一个 tarball）。版本控制的目的是保持对公共接口的一定控制——但是如果只有你一个人看过它，那么更改版本号就没有意义了。
- en: '*Adding a Plug-In Interface*'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加插件接口*'
- en: I’d like to make it possible to change the salutation displayed by simply changing
    which plug-in module is loaded at runtime. All of the changes we’ll need to make
    to the code and build system to add this functionality will be limited to the
    *configure.ac* file and to files within the *src* directory and its subdirectories.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望能够通过简单地改变运行时加载的插件模块来更改显示的问候语。我们需要对代码和构建系统做的所有更改，将仅限于 *configure.ac* 文件以及
    *src* 目录及其子目录中的文件。
- en: First, we need to define the actual plug-in interface. We’ll do this by creating
    a new private header file in the *src* directory called *module.h*. This file
    is shown in [Listing 8-8](ch08.xhtml#ch08ex8).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义实际的插件接口。我们将通过在 *src* 目录下创建一个新的私有头文件 *module.h* 来完成这项工作。这个文件如 [列表 8-8](ch08.xhtml#ch08ex8)
    所示。
- en: Git tag 8.1
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 8.1
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-8:* src/module.h: *The initial contents of this file*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8:* src/module.h: *该文件的初始内容*'
- en: This header file has a number of interesting aspects. First, let’s look at the
    preprocessor definition, `GET_SALUTATION_SYM`, at ➊. This string represents the
    name of the function you need to import from the plug-in module. I like to define
    these in the header file so all the information that needs to be reconciled exists
    in one place. In this case, the symbol name, the function type definition, and
    the function prototype must all be in alignment, and you can use this single definition
    for all three.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件有许多有趣的方面。首先，让我们来看位于 ➊ 的预处理器定义 `GET_SALUTATION_SYM`。这个字符串表示你需要从插件模块导入的函数名。我喜欢在头文件中定义这些，这样所有需要对齐的信息都能集中在一个地方。在这种情况下，符号名称、函数类型定义和函数原型必须保持一致，你可以用这个单一的定义来处理所有三个部分。
- en: Another interesting item is the type definition^([7](footnote.xhtml#ch08fn7))
    at ➋. If we don’t provide one, the user is going to have to invent one, or else
    use a complex typecast on the return value of the `dlsym` function. Therefore,
    we’ll provide it here for consistency and convenience.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的项是位于 ➋ 的类型定义^([7](footnote.xhtml#ch08fn7))。如果我们不提供一个类型定义，用户就必须自己发明一个，或者在
    `dlsym` 函数的返回值上使用复杂的类型转换。因此，我们将在这里提供它，以确保一致性和便捷性。
- en: Finally, look at the function prototype at ➌. This isn’t so much for the caller
    as it is for the module itself. Modules providing this function should include
    this header file so the compiler can catch potential misspellings of the function
    name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看看 ➌ 处的函数原型。这不仅是为了调用者，而是为了模块本身。提供此函数的模块应包含此头文件，以便编译器能捕捉到潜在的函数名拼写错误。
- en: '*Doing It the Old-Fashioned Way*'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*传统方式操作*'
- en: For this first attempt, let’s use the *dl* interface provided by the Solaris/Linux
    *libdl.so* library. In the next section, we’ll convert this code over to the Libtool
    *ltdl* interface for greater portability.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次尝试，让我们使用 Solaris/Linux *libdl.so* 库提供的 *dl* 接口。在下一节中，我们将把这段代码转换为 Libtool
    *ltdl* 接口，以提高移植性。
- en: To do this right, we need to add checks to *configure.ac* to look for both the
    *libdl* library and the *dlfcn.h* header file. These changes to *configure.ac*
    are highlighted in [Listing 8-9](ch08.xhtml#ch08ex9).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确完成此操作，我们需要在 *configure.ac* 中添加检查，寻找 *libdl* 库和 *dlfcn.h* 头文件。这些对 *configure.ac*
    的更改在 [清单 8-9](ch08.xhtml#ch08ex9) 中突出显示。
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*listing 8-9:* configure.ac: *Adding checks for the* dl *library and public
    header file*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-9:* configure.ac: *添加对* dl *库和公共头文件的检查*'
- en: At ➊, I added the *dlfcn.h* header file to the list of files passed to the `AC_CHECK_HEADERS`
    macro, and then at ➋, I added a check for the `dlopen` function in the *dl* library.
    Note here that the `AC_SEARCH_LIBS` macro searches a list of libraries for a function,
    so this call goes in the “Checks for library functions” section rather than the
    “Checks for libraries” section. To help us see which libraries we’re actually
    linking against, I’ve also added a line to the `cat` command at the end of the
    file. The `Libraries:` line at ➌ displays the contents of the `LIBS` variable,
    which is modified by the `AC_SEARCH_LIBS` macro.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我将 *dlfcn.h* 头文件添加到传递给 `AC_CHECK_HEADERS` 宏的文件列表中，然后在 ➋ 处，我检查了 *dl* 库中的
    `dlopen` 函数。这里需要注意的是，`AC_SEARCH_LIBS` 宏会在库列表中查找一个函数，因此此调用属于“库函数检查”部分，而非“库检查”部分。为了帮助我们查看实际链接的库，我还在文件末尾的
    `cat` 命令中添加了一行。 ➌ 处的 `Libraries:` 行显示了 `LIBS` 变量的内容，该变量由 `AC_SEARCH_LIBS` 宏修改。
- en: '**NOTE**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The *`LT_INIT`* macro also checks for the existence of the* dlfcn.h *header
    file, but I do it here explicitly so it’s obvious to observers that I wish to
    use this header file. This is a good rule of thumb to follow, as long as it doesn’t
    negatively affect performance too much. Since Autoconf caches the results of checks,
    it’s not likely to do so. You can tell this is happening when you see *`(cached)
    ...`* after a check in *`configure`*’s output.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*`LT_INIT`* 宏也会检查 *dlfcn.h* 头文件的存在，但我在这里显式地进行检查，以便观察者能明确看到我希望使用这个头文件。这是一个很好的经验法则，只要它不会对性能造成太大影响。由于
    Autoconf 会缓存检查的结果，因此这种情况不太可能发生。你可以通过查看 *`configure`* 输出中出现的 *`(cached) ...`* 来知道这正在发生。'
- en: 'Adding a module requires several changes, so we’ll make them all here, beginning
    with the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 添加模块需要做几个更改，所以我们将一起进行这些更改，首先执行以下命令：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I’ve created two new subdirectories. The first is *modules*, beneath *src*,
    and the second is *hithere*, beneath *modules*. Each new module added to this
    project will have its own directory beneath *modules*. The *hithere* module will
    provide the salutation *Hi there*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了两个新的子目录。第一个是 *modules*，位于 *src* 目录下，第二个是 *hithere*，位于 *modules* 目录下。每个新增的模块都将在
    *modules* 目录下有自己的子目录。*hithere* 模块将提供问候语 *Hi there*。
- en: '[Listing 8-10](ch08.xhtml#ch08ex10) illustrates how to add a `SUBDIRS` variable
    to the *src/Makefile.am* file to ensure that the build system processes the *modules/hithere*
    directory.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-10](ch08.xhtml#ch08ex10) 说明了如何将 `SUBDIRS` 变量添加到 *src/Makefile.am* 文件中，以确保构建系统能够处理
    *modules/hithere* 目录。'
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 8-10:* src/Makefile.am: *Adding a `SUBDIRS` variable to this* Makefile.am
    *file*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-10:* src/Makefile.am: *向此* Makefile.am *文件添加 `SUBDIRS` 变量*'
- en: The way I’ve used `SUBDIRS` at ➊ presents a new concept. Until now, Jupiter’s
    *Makefile.am* files have only referenced direct descendants of the current directory,
    but this is not strictly necessary, as you can see. In fact, for Jupiter, the
    *modules* directory will only contain additional subdirectories, so it makes little
    sense to provide a *modules/Makefile.am* file just so you can reference its subdirectories.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 ➊ 使用 `SUBDIRS` 的方式引入了一个新概念。到目前为止，Jupiter 的 *Makefile.am* 文件只引用了当前目录的直接子目录，但正如你所见，这并非严格必要。事实上，对于
    Jupiter，*modules* 目录只会包含额外的子目录，因此提供一个 *modules/Makefile.am* 文件只是为了引用其子目录没有太大意义。
- en: While you’re editing the file, you should add the new *module.h* header file
    to the `SOURCES` variable at ➋. If you don’t do this, `jupiter` will still compile
    and build correctly for you as the maintainer, but the `distcheck` target will
    fail because none of the *Makefile.am* files will have mentioned *module.h*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑文件时，您应该将新的*module.h*头文件添加到`SOURCES`变量中，如➋所示。如果不这样做，`jupiter`仍然会为您作为维护者正确编译和构建，但`distcheck`目标将失败，因为没有任何*Makefile.am*文件提到*module.h*。
- en: We also need to change the way the `greptest.sh` shell script is built so it
    can test for any type of salutation. A simple modification of the regular expression
    at ➌ will suffice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要改变`greptest.sh`脚本的构建方式，以便它能够测试任何类型的问候语。只需在➌处简单修改正则表达式即可。
- en: I created a *Makefile.am* file in the new *hithere* subdirectory that contains
    instructions on how to build the *hithere.c* source file, and then I added the
    *hithere.c* source file to this directory. These files are shown in [Listings
    8-11](ch08.xhtml#ch08ex11) and [8-12](ch08.xhtml#ch08ex12), respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我在新的*hithere*子目录中创建了一个*Makefile.am*文件，里面包含了如何构建*hithere.c*源文件的指令，然后我将*hithere.c*源文件添加到该目录中。这些文件分别显示在[列表
    8-11](ch08.xhtml#ch08ex11)和[8-12](ch08.xhtml#ch08ex12)中。
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-11:* src/modules/hithere/Makefile.am: *The initial version of this
    file*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-11:* src/modules/hithere/Makefile.am: *该文件的初始版本*'
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 8-12:* src/modules/hithere/hithere.c: *The initial version of this
    file*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-12:* src/modules/hithere/hithere.c: *该文件的初始版本*'
- en: The *hithere.c* source file includes the semi-private *module.h* header file
    using a double-quoted relative path. Since Automake automatically adds `-I$(srcdir)`
    to the list of *include* paths used, the C preprocessor will properly sort out
    the relative path. The file then defines the `get_salutation` function, whose
    prototype is in the *module.h* header file. This implementation simply returns
    a pointer to a static string, and as long as the library is loaded, the caller
    can access the string. However, callers must be aware of the scope of data references
    returned by plug-in modules; otherwise, the program may unload a module before
    a caller is done using it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*hithere.c*源文件通过双引号相对路径引用半私有的*module.h*头文件。由于Automake会自动将`-I$(srcdir)`添加到使用的*include*路径列表中，C预处理器将正确处理相对路径。然后，文件定义了`get_salutation`函数，其原型位于*module.h*头文件中。该实现简单地返回指向静态字符串的指针，只要库被加载，调用者就可以访问该字符串。然而，调用者必须注意插件模块返回的数据引用的作用域；否则，程序可能会在调用者完成使用之前卸载该模块。'
- en: The last line of *hithere/Makefile.am* (at ➊ in [Listing 8-11](ch08.xhtml#ch08ex11))
    requires some explanation. Here, we’re using a `-module` option on the `hithere_la_LDFLAGS`
    variable. This is a Libtool option that tells Libtool you want to call your library
    *hithere*, not *libhithere*. The *GNU Libtool Manual* makes the statement that
    modules do not need to be prefixed with *lib*. And since your code will be loading
    these modules manually, it should not have to be concerned with determining and
    properly using a platform-specific library name prefix.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*hithere/Makefile.am*的最后一行（在[列表 8-11](ch08.xhtml#ch08ex11)中的➊处）需要一些解释。在这里，我们在`hithere_la_LDFLAGS`变量上使用了`-module`选项。这是Libtool的一个选项，告诉Libtool您希望将库命名为*hithere*，而不是*libhithere*。*GNU
    Libtool手册*中指出，模块不需要以*lib*为前缀。而且，由于您的代码将手动加载这些模块，因此不必担心确定和正确使用特定平台的库名称前缀。'
- en: If you don’t care to use module versioning on your dynamically loadable (`dlopen`-ed)
    modules, try using the Libtool `-avoid-version` option. This option causes Libtool
    to generate a shared library whose name is *lib*name.*so*, rather than *lib*name.*so.0.0.0*.
    It also suppresses generation of the *lib*name.*so.0* and *lib*name.*so* soft
    links that refer to the binary image. Because I’m using both options, my module
    will simply be named *hithere.so*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不关心对动态加载的（`dlopen`加载的）模块使用版本控制，可以尝试使用Libtool的`-avoid-version`选项。此选项使Libtool生成一个共享库，库的名称是*lib*name.*so*，而不是*lib*name.*so.0.0.0*。它还会抑制生成*lib*name.*so.0*和*lib*name.*so*的软链接，这些链接指向二进制镜像。因为我同时使用了这两个选项，所以我的模块将简单地命名为*hithere.so*。
- en: In order to get this module to build, we need to add the new *hithere* module’s
    makefile to the `AC_CONFIG_FILES` macro in *configure.ac*, as shown in [Listing
    8-13](ch08.xhtml#ch08ex13).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个模块能够构建，我们需要将新的*hithere*模块的makefile添加到*configure.ac*中的`AC_CONFIG_FILES`宏中，如[列表
    8-13](ch08.xhtml#ch08ex13)所示。
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 8-13:* configure.ac: *Adding the* hithere *directory makefile to `AC_CONFIG_FILES`*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-13:* configure.ac: *将* hithere *目录的makefile添加到`AC_CONFIG_FILES`中*'
- en: Finally, in order to use the module, we need to modify *src/main.c* so that
    it loads the module, imports the symbol, and calls it. These changes to *src/main.c*
    are highlighted in bold in [Listing 8-14](ch08.xhtml#ch08ex14).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使用该模块，我们需要修改*src/main.c*以便加载模块、导入符号并调用它。这些对*src/main.c*的更改在[清单 8-14](ch08.xhtml#ch08ex14)中以粗体显示。
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-14:* src/main.c: *Using the new plug-in module from the `main` function*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-14:* src/main.c：*从`main`函数使用新的插件模块*'
- en: I’m including the new private *module.h* header file at ➊, and I added a preprocessor
    directive to conditionally include *dlfcn.h* at ➋. Finally, I added two sections
    of code, one before and one after the original call to `jupiter_print` (at ➌ and
    ➎, respectively). Both are conditionally compiled based on the existence of a
    dynamic loader, allowing the code to build and run correctly on systems that do
    not provide the *libdl* library.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➊处包含了新的私有*module.h*头文件，并且在➋处添加了一个预处理指令，以有条件地包含*dlfcn.h*。最后，我在原始调用`jupiter_print`的前后分别添加了两段代码（分别在➌和➎处）。这两段代码都是基于动态加载器的存在条件编译的，这使得代码能够在没有提供*libdl*库的系统上正确构建和运行。
- en: 'The general philosophy I use when deciding whether or not code should be conditionally
    compiled is this: If `configure` fails because a library or header file is missing,
    then I don’t need to conditionally compile the code that uses the item `configure`
    checks for. If I check for a library or header file in `configure` but allow it
    to continue if it’s missing, then I’d better use conditional compilation.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定是否进行条件编译时使用的一般哲学是：如果`configure`因缺少某个库或头文件而失败，那么我不需要有条件地编译使用`configure`检查项的代码。如果我在`configure`中检查某个库或头文件，但允许它缺失而继续，那么我最好使用条件编译。
- en: 'There are just a few more minor points to bring up regarding the use of *dl*
    interface functions. First, at ➍, `dlopen` accepts two parameters: a filename
    or *path* (absolute or relative) and a *flags* word, which is the bitwise composite
    of your choice of several flag values defined in *dlfcn.h*. Check the man page
    for `dlopen` to learn more about these flag bits. If you use a path, then `dlopen`
    honors that path verbatim, but if you use a filename, the library search path
    is searched in an attempt to locate your module. By prefixing the name with *./*,
    we’re telling `dlopen` not to search the library path.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用*dl*接口函数，还有一些小细节需要提及。首先，在➍处，`dlopen`接受两个参数：一个文件名或*路径*（绝对路径或相对路径）和一个*flags*标志，它是你选择的多个在*dlfcn.h*中定义的标志值的按位组合。可以查看`dlopen`的手册页，了解更多关于这些标志位的信息。如果使用路径，`dlopen`会完全遵循该路径，但如果使用文件名，则会在库搜索路径中查找模块。通过在文件名前加上*./*，我们告诉`dlopen`不要搜索库路径。
- en: We want to be able to configure which module `jupiter` uses, so we’re loading
    a generic name, *module.so*. In fact, the built module is located several directories
    below the *src* directory in the build tree, so we need to create a soft link
    in the current directory called *module.so* that points to the module we want
    to load. This is a rather shabby form of configuration for Jupiter, but it works.
    In a real application, you would define the desired module to load using policy
    defined in some sort of configuration file, but in this example, I’m simply ignoring
    these details for the sake of simplicity.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够配置`jupiter`使用哪个模块，因此我们加载了一个通用名称，*module.so*。事实上，构建后的模块位于构建树中*src*目录下的多个子目录中，因此我们需要在当前目录创建一个名为*module.so*的软链接，指向我们希望加载的模块。这是一种相对简陋的Jupiter配置方式，但它有效。在实际应用中，你会通过某种配置文件中定义的策略来指定要加载的模块，但在这个示例中，为了简便起见，我忽略了这些细节。
- en: '**NOTE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’m ignoring some error handling in [Listing 8-14](ch08.xhtml#ch08ex14). In
    production code, you would probably want to log or display something if the module
    doesn’t load or if the symbol is not exported by the module.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在[清单 8-14](ch08.xhtml#ch08ex14)中忽略了一些错误处理。在生产代码中，如果模块未能加载或模块未导出符号，你可能希望记录或显示某些信息。*'
- en: 'The following command sequence shows our loadable module in action:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令序列展示了我们可加载模块的工作情况：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**NOTE**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The symlink *`module.so`* refers to a file in a hidden* .libs *directory.
    Executables and libraries are generated into a* .libs *directory within the associated
    source directory by Autotools build systems*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号链接*`module.so`*指向一个隐藏的* .libs *目录中的文件。可执行文件和库由Autotools构建系统生成，并存放在关联源目录内的*
    .libs *目录中*。'
- en: Converting to Libtool’s ltdl Library
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为Libtool的ltdl库
- en: Libtool provides a wrapper library called *ltdl* that abstracts and hides some
    of the portability issues surrounding the use of shared libraries across many
    different platforms. Most applications ignore the *ltdl* library because of the
    added complexity involved in using it, but there are really only a few issues
    to deal with. I’ll enumerate them here and then cover them in detail later.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool提供了一个名为*ltdl*的包装库，它抽象并隐藏了在多个不同平台上使用共享库时遇到的一些可移植性问题。大多数应用程序因为使用它时的复杂性而忽略了*ltdl*库，但实际上需要处理的问题并不多。我将在这里列出这些问题，并在后续详细讲解。
- en: The *ltdl* functions follow a naming convention based on the *dl* library. The
    rule of thumb is that *dl* functions in the *ltdl* library have the prefix `lt_`.
    For example, `dlopen` is named `lt_dlopen`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ltdl*函数遵循基于*dl*库的命名约定。经验法则是，*ltdl*库中的*dl*函数以`lt_`为前缀。例如，`dlopen`被命名为`lt_dlopen`。'
- en: Unlike the *dl* library, the *ltdl* library must be initialized and terminated
    at appropriate locations within a consuming application.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与*dl*库不同，*ltdl*库必须在应用程序中适当的位置进行初始化和终止。
- en: Applications should be built using the `-dlopen` *`modulename`* option on the
    linker command line (in the `*_LDFLAGS` variable). This tells Libtool to link
    the code for the module into the application when building on platforms without
    shared libraries or when linking statically.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该使用`-dlopen` *`modulename`*选项在链接器命令行中进行构建（在`*_LDFLAGS`变量中）。这告诉Libtool在没有共享库的平台或静态链接时，将模块代码链接到应用程序中。
- en: The `LTDL_SET_PRELOADED_SYMBOLS()` macro should be used at an appropriate location
    within your program source code to ensure that module code can be accessed on
    non-shared-library platforms or when building static-only configurations.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LTDL_SET_PRELOADED_SYMBOLS()`宏应在程序源代码的适当位置使用，以确保在非共享库平台或构建仅静态配置时，模块代码能够被访问。'
- en: Shared-library modules designed to be `dlopen`-ed using *ltdl* should use the
    `-module` option (and, optionally, the `-avoid-version` option) on the linker
    command line (in the `*_LDFLAGS` variable).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计为使用*dlopen*加载的共享库模块应在链接器命令行中使用`-module`选项（可选地，还可以使用`-avoid-version`选项）（在`*_LDFLAGS`变量中）。
- en: The *ltdl* library provides extensive functionality beyond the *dl* library;
    this can be intimidating, but know that all of this other functionality is optional.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ltdl*库提供了超出*dl*库的广泛功能；这可能会让人感觉有些吓人，但请知道，所有这些额外的功能都是可选的。'
- en: Let’s look at what we need to do to the Jupiter project build system in order
    to use the *ltdl* library. First, we need to modify *configure.ac* to look for
    the *ltdl.h* header and search for the `lt_dlopen` function. This means modifying
    references to *dlfcn.h* and the *dl* library in the `AC_CHECK_HEADERS` and `AC_SEARCH_LIBS`
    macros, as highlighted in [Listing 8-15](ch08.xhtml#ch08ex15).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何修改Jupiter项目的构建系统，以便使用*ltdl*库。首先，我们需要修改*configure.ac*文件，去查找*ltdl.h*头文件并搜索`lt_dlopen`函数。这意味着需要修改在`AC_CHECK_HEADERS`和`AC_SEARCH_LIBS`宏中对*dlfcn.h*和*dl*库的引用，如[示例8-15](ch08.xhtml#ch08ex15)所示。
- en: Git tag 8.2
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 8.2
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 8-15:* configure.ac: *Switching from `dl` to `ltdl` in* configure.ac'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例8-15:* configure.ac：*在configure.ac中从`dl`切换到`ltdl`*'
- en: Even though we’re using Libtool, we need to check for *ltdl.h* and *libltdl*,
    because *ltdl* is a separate library that must be installed on the end user’s
    system. It should be treated the same as any other required third-party library.
    By searching for these installed resources on the user’s system and failing configuration
    if they’re not found, or by properly using preprocessor definitions in your source
    code, you can provide the same sort of configuration experience with *ltdl* that
    I’ve presented throughout this book when using other third-party resources.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用了Libtool，我们仍然需要检查*ltdl.h*和*libltdl*，因为*ltdl*是一个独立的库，必须安装在最终用户的系统上。它应该像任何其他所需的第三方库一样对待。通过在用户的系统中搜索这些已安装的资源，并在找不到时失败配置，或者在源代码中正确使用预处理器定义，你可以提供与使用其他第三方资源时相同的配置体验。
- en: I’d like you to recognize that this is the first time we’ve seen the requirement
    for the user to install an Autotools package on his system—and this is the very
    reason most people avoid using *ltdl*. The *GNU Libtool Manual* provides a detailed
    description of how to package the *ltdl* library with your project so it is built
    and installed on the user’s system when your package is built and installed.^([8](footnote.xhtml#ch08fn8))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能意识到，这是我们第一次看到用户需要在其系统上安装 Autotools 软件包的要求——这正是大多数人避免使用 *ltdl* 的原因。《*GNU
    Libtool 手册*》提供了详细的描述，说明如何将 *ltdl* 库与项目一起打包，以便在构建和安装你的软件包时，它会在用户系统上构建并安装。^([8](footnote.xhtml#ch08fn8))
- en: Interestingly, shipping the source code for the *ltdl* library with your package
    is the only way to get your program to *statically* link with the *ltdl* library.
    Linking statically with *ltdl* has the side effect of not requiring the user to
    install the *ltdl* library on their system, since the library becomes part of
    the project’s executable images. There are a few caveats, however. If your project
    also uses a third-party library that dynamically links to *ltdl*, you’ll have
    a symbol conflict between the shared and static versions of the *ltdl* libraries.^([9](footnote.xhtml#ch08fn9))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，将 *ltdl* 库的源代码随你的软件包一起发布是让你的程序与 *ltdl* 库进行*静态*链接的唯一方法。与 *ltdl* 静态链接的副作用是，不需要用户在他们的系统上安装
    *ltdl* 库，因为该库会成为项目可执行文件的一部分。然而，有一些警告需要注意。如果你的项目还使用了一个动态链接到 *ltdl* 的第三方库，你将会遇到共享版和静态版
    *ltdl* 库之间的符号冲突。^([9](footnote.xhtml#ch08fn9))
- en: The next major change we need to make is in the source code—it is limited, in
    this case, to *src/main.c* and highlighted in [Listing 8-16](ch08.xhtml#ch08ex16).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行的下一个重大更改是在源代码中——在这种情况下，仅限于 *src/main.c*，并在 [清单 8-16](ch08.xhtml#ch08ex16)
    中突出显示。
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-16:* src/main.c: *Switching from `dl` to `ltdl` in source code*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-16:* src/main.c: *在源代码中从`dl`切换到`ltdl`*'
- en: These changes are very symmetrical with respect to the original code. Mostly,
    items that previously referred to `DL` or `dl` now refer to `LTDL` or `lt_dl`.
    For example, `#if HAVE_DLFCN_H` becomes `#if HAVE_LTDL_H`, and so forth.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改在原始代码中是非常对称的。通常，之前提到 `DL` 或 `dl` 的地方现在变成了提到 `LTDL` 或 `lt_dl`。例如，`#if HAVE_DLFCN_H`
    变成了 `#if HAVE_LTDL_H`，等等。
- en: One important change is that the *ltdl* library must be initialized at ➌ with
    a call to `lt_dlinit`, whereas the *dl* library did not require initialization.
    In a larger program, the overhead of calling `lt_dlinit` and `lt_dlexit` would
    be amortized over a much larger code base.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的变化是，*ltdl* 库必须在➌处通过调用 `lt_dlinit` 进行初始化，而 *dl* 库则不需要初始化。在一个较大的程序中，调用 `lt_dlinit`
    和 `lt_dlexit` 的开销会在更大的代码基础中得到摊销。
- en: Another important detail is the addition of the `LTDL_SET_PRELOADED_SYMBOLS`
    macro invocation at ➋. This macro configures global variables required by the
    `lt_dlopen` and `lt_dlsym` functions on systems that don’t support shared libraries
    or in cases where the end user has specifically requested static libraries. It’s
    benign on systems that use shared libraries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要细节是在➋处添加了 `LTDL_SET_PRELOADED_SYMBOLS` 宏调用。该宏配置了 `lt_dlopen` 和 `lt_dlsym`
    函数所需的全局变量，适用于不支持共享库的系统，或者在终端用户特别要求静态库的情况下。对于使用共享库的系统，这个调用是无害的。
- en: One last detail is that the return type of `dlopen` is `void *`, or a generic
    pointer, whereas the return type of `lt_dlopen` is `lt_dlhandle` (see ➊ and ➍).
    This abstraction exists so *ltdl* can be ported to systems that use return types
    that are incompatible with a generic pointer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项细节是，`dlopen` 的返回类型是 `void *`，即通用指针，而 `lt_dlopen` 的返回类型是 `lt_dlhandle`（见
    ➊ 和 ➍）。这种抽象的存在是为了让 *ltdl* 可以移植到使用与通用指针不兼容的返回类型的系统上。
- en: When a system doesn’t support shared libraries, Libtool actually links all of
    the modules that might be loaded right into the program. Thus, the `jupiter` program’s
    linker (`libtool`) command line must contain some form of reference to these modules.
    This is done using the `-dlopen` *`modulename`* construct, as shown in [Listing
    8-17](ch08.xhtml#ch08ex17).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统不支持共享库时，Libtool 实际上会将所有可能加载的模块直接链接到程序中。因此，`jupiter` 程序的链接器（`libtool`）命令行必须包含对这些模块的某种形式的引用。这是通过使用
    `-dlopen` *`modulename`* 构造来完成的，如 [清单 8-17](ch08.xhtml#ch08ex17) 所示。
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-17:* src/Makefile.am: *Adding a `-dlopen` option to the `LDADD`
    line*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-17:* src/Makefile.am: *在 `LDADD` 行中添加 `-dlopen` 选项*'
- en: If you forget this addition to *src/Makefile.am*, you’ll get a linker error
    about an undefined symbol—something like `lt__PROGRAM__LTX_preloaded _symbols`.
    If it doesn’t detect any modules being linked into the application, Libtool won’t
    clutter your program’s global symbol space with symbols that will never be referenced;
    the symbols required by the *ltdl* library will be missing if the symbol table
    is empty.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了将这个内容添加到*src/Makefile.am*中，你将得到一个关于未定义符号的链接器错误——类似于`lt__PROGRAM__LTX_preloaded
    _symbols`。如果Libtool没有检测到任何模块被链接到应用程序中，它不会将符号污染程序的全局符号空间，这些符号永远不会被引用；如果符号表为空，*ltdl*库所需的符号将会缺失。
- en: It appears that *ltdl* is not quite as flexible as *dl* regarding the sort of
    path information you can specify in `lt_dlopen` to reference a module. In order
    to fix this problem, I hardwired the proper relative path (*modules/hithere/hithere.la*)
    into *main.c*. Additionally, this example is sensitive to the current working
    directory. If you run `jupiter` from another directory, it will also fail to find
    the module. A real program would undoubtedly use a more robust method of configuration,
    such as a configuration file containing the absolute path to the desired module
    name.^([10](footnote.xhtml#ch08fn10))
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来*ltdl*在指定`lt_dlopen`时可以引用模块的路径信息方面不如*dl*灵活。为了解决这个问题，我将正确的相对路径（*modules/hithere/hithere.la*）硬编码到*main.c*中。此外，这个示例对当前工作目录很敏感。如果你从另一个目录运行`jupiter`，它也会无法找到该模块。一个真正的程序无疑会使用更健壮的配置方法，比如包含目标模块名称绝对路径的配置文件。^([10](footnote.xhtml#ch08fn10))
- en: '*Preloading Multiple Modules*'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*预加载多个模块*'
- en: 'If Libtool links multiple modules into a program on a system without shared-library
    support, and if those modules each provide their own version of `get_salutation`,
    then there will be a conflict of public symbols within the program’s global symbol
    space. This is because all of these modules’ symbols become part of the program’s
    global symbol space and the linker generally won’t allow two symbols of the same
    name to be added to the executable symbol table. Which module’s `get_salutation`
    function should be honored? Unfortunately, there’s no good heuristic to resolve
    this conflict. The *GNU Libtool Manual* provides for this condition by defining
    a convention for maintaining symbol-naming uniqueness:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Libtool在没有共享库支持的系统上将多个模块链接到一个程序中，并且这些模块各自提供自己的`get_salutation`版本，那么在程序的全局符号空间中就会出现公共符号冲突。这是因为所有这些模块的符号都成为程序全局符号空间的一部分，而链接器通常不允许将两个同名的符号添加到可执行符号表中。应该尊重哪个模块的`get_salutation`函数呢？不幸的是，解决这个冲突没有一个好的启发式方法。*GNU
    Libtool手册*通过定义一种约定来解决这种情况，从而保持符号命名的唯一性：
- en: All exported interface symbols should be prefixed with *`modulename`*`_LTX _`
    (for example, `hithere_LTX_get_salutation`).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有导出的接口符号应该以*`modulename`*`_LTX _`（例如，`hithere_LTX_get_salutation`）作为前缀。
- en: All remaining non-static symbols should be reasonably unique. The method Libtool
    suggests is to prefix them with *`_modulename_`* (as in `_jupiter_`*`somefunction`*).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有剩余的非静态符号应当具有合理的唯一性。Libtool建议的方法是以*`_modulename_`*（例如`_jupiter_`*`somefunction`*）作为前缀。
- en: Modules should be named differently even if they’re built in different directories.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使模块在不同的目录中构建，它们的命名也应当不同。
- en: Although it’s not explicitly stated in the manual, the `lt_dlsym` function first
    searches for the specified symbol as *`modulename`*`_LTX_`*`symbolname`*, and
    then, if it can’t find a prefixed version of the symbol, it searches for exactly
    *`symbolname`*. You can see that this convention is necessary, but only for cases
    in which Libtool may statically link such loadable modules directly into the application
    on systems that don’t support shared libraries. The price you have to pay for
    Libtool’s illusion of shared libraries on systems that don’t support them is pretty
    high, but it’s the going rate for getting the same loadable module functionality
    on all platforms.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管手册中没有明确说明，`lt_dlsym`函数首先会以*`modulename`*`_LTX_`*`symbolname`*的形式查找指定的符号，如果找不到带前缀的符号，它接着会查找完全相同的*`symbolname`*。可以看出，这一约定是必要的，但仅仅在Libtool可能会将这些可加载模块静态链接到不支持共享库的系统上的应用程序中时，才需要此约定。在不支持共享库的系统上，Libtool所提供的共享库的幻象代价相当高，但它是为了在所有平台上获得相同的可加载模块功能所必须支付的代价。
- en: To fix the *hithere* module’s source code so that it conforms to this convention,
    we need to make one change to *hithere.c*, shown in [Listing 8-18](ch08.xhtml#ch08ex18).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复*hithere*模块的源代码，使其符合这一约定，我们需要对*hithere.c*进行一次更改，如[列表8-18](ch08.xhtml#ch08ex18)所示。
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-18:* src/modules/hithere/hithere.c: *Ensuring public symbols are
    unique when using `ltdl`*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-18:* src/modules/hithere/hithere.c: *在使用 `ltdl` 时确保公共符号唯一*'
- en: By defining the replacement for `get_salutation` at ➊ before the inclusion of
    the *module.h* header file at ➋, we’re also able to change the prototype in the
    header file so that it matches the modified version of the function name. Because
    of the way the C preprocessor works, this substitution only affects the function
    prototype in *module.h*, not the quoted symbol string or the type definition.
    At this point, you may want to go back and examine the way *module.h* is written
    to prove to yourself that this actually works.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在➊位置定义 `get_salutation` 的替代版本，并在➋位置包含 *module.h* 头文件，我们还能够修改头文件中的原型，使其与修改后的函数名称版本匹配。由于
    C 预处理器的工作方式，这种替换仅影响 *module.h* 中的函数原型，而不会影响引号中的符号字符串或类型定义。此时，你可能想回去查看 *module.h*
    的写法，以证明这一点确实有效。
- en: '*Checking It All Out*'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*检查所有内容*'
- en: 'You can test your program and modules for both static and dynamic shared-library
    systems by using the `--disable-shared` option on the `configure` command line,
    like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `configure` 命令行上使用 `--disable-shared` 选项来测试你的程序和模块，测试静态和动态共享库系统，如下所示：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the output at ➋ and ➌ contains the *hithere* module’s salutation
    in both configurations, yet the file listing at ➊ shows us that, in the `--disable-shared`
    version, the shared library doesn’t even exist. It appears that *ltdl* is doing
    its job.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，➋ 和 ➌ 位置的输出都包含了 *hithere* 模块的问候语，但在➊位置的文件列表显示，在 `--disable-shared` 版本中，根本不存在共享库。看起来
    *ltdl* 正在发挥它的作用。
- en: '**NOTE**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may have noticed the difference in the example’s output for the two executions
    of *`jupiter`*. In the first case, the output shows the name of the program as
    exactly *`./jupiter`*, while in the second case, it shows *`...jupiter`*. This
    was my attempt at removing the cruft in the output caused by Libtool’s redirection
    of the shared-library-consuming version referring to the actual program*—`lt-jupiter`—*in
    the* jupiter /src/.libs *directory. Libtool uses a wrapper around programs linked
    to built shared libraries in order to make it simpler for uninstalled programs
    to find the built shared libraries upon which they depend*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能已经注意到，示例中两次执行 *`jupiter`* 的输出有所不同。在第一次情况下，输出显示程序名称为 *`./jupiter`*，而在第二次情况下，显示的是
    *`...jupiter`*。这是我尝试去除输出中由 Libtool 重定向共享库版本所造成的冗余信息——指向实际程序的 *`lt-jupiter`*——位于
    jupiter /src/.libs 目录中。Libtool 使用一个包装器来链接到构建共享库的程序，以简化未安装程序找到其依赖的共享库。*'
- en: The Jupiter code base has become rather fragile, because I’ve ignored the issue
    of where to find shared libraries at runtime. As I’ve already mentioned, you would
    ultimately have to fix this problem in a real program. But given that I’ve finished
    my task of showing you how to properly use the Libtool *ltdl* library, I’ll leave
    that as an exercise for you.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter 代码库变得相当脆弱，因为我忽视了运行时如何找到共享库的问题。正如我之前提到的，你最终必须在实际程序中解决这个问题。但鉴于我已经完成了向你展示如何正确使用
    Libtool *ltdl* 库的任务，我会把这个问题留给你作为练习。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The decision to use shared libraries brings with it a whole truckload of issues,
    and if you’re interested in maximum portability, you must deal with each of them.
    The *ltdl* library is not a solution to every problem. It solves some problems
    but brings others to the surface. Suffice it to say that using *ltdl* has trade-offs,
    but if you don’t mind the extra maintenance effort, it’s a good way to add maximum
    portability to your loadable-module project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用共享库的决定带来了许多问题，如果你追求最大兼容性，你必须处理每一个问题。*ltdl* 库并不是解决所有问题的万能钥匙。它解决了一些问题，但也带来了其他问题。可以说，使用
    *ltdl* 有其权衡，如果你不介意额外的维护工作，它是为你的可加载模块项目增加最大兼容性的一种好方法。
- en: I hope that by spending some time going through the exercises in this book,
    you’ve been able to get your head around the Autotools enough to know how they
    work and what they’re doing for you. At this point, you should be very comfortable
    *autotool-izing* your own projects—at least at the basic level.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望通过花时间完成本书中的练习，你能够理解 Autotools 的基本概念，知道它们如何工作以及它们为你做了什么。此时，你应该非常熟悉如何将 *autotool*
    应用到你自己的项目中——至少是在基础层面上。
- en: In the coming chapters, I’ll discuss additional tools and utilities that are
    also considered part of the GNU toolbox (and one or two that are not). I’ll also
    show you how to convert a real-world project from a handcoded build system to
    a much more concise, and probably more correct, Autotools build system.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将讨论一些额外的工具和实用程序，这些工具也被认为是GNU工具箱的一部分（还有一两个不是）。我还将向你展示如何将一个真实世界的项目从手动编码的构建系统转换为更加简洁、可能更加正确的Autotools构建系统。
