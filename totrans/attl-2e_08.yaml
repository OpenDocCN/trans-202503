- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LIBRARY INTERFACE VERSIONING AND RUNTIME DYNAMIC LINKING
  prefs: []
  type: TYPE_NORMAL
- en: '*Occasionally he stumbled over the truth, but hastily picked himself up and
    hurried on as if nothing had happened.'
  prefs: []
  type: TYPE_NORMAL
- en: —Sir Winston Churchill, quoted in* The Irrepressible Churchill
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the last chapter, I explained the concepts of dynamically loadable shared
    libraries. I also showed you how easy it is to add Libtool shared-library functionality
    and flexibility to your projects, whether your projects provide shared libraries,
    static libraries, convenience archives, or some mixture of these. There are still
    two major Libtool topics we need to cover. The first is library versioning, and
    the second involves using the Libtool *ltdl* library to portably build and consume
    dynamically loadable modules within your projects.
  prefs: []
  type: TYPE_NORMAL
- en: When I talk about the version of a library, I’m referring specifically to the
    version of the library’s public interface, but I need to clearly define the term
    *interface* in this context. A *shared-library interface* refers to all aspects
    of a shared library’s connections with the outside world. Besides the function
    and data signatures that a library exports, these connections include files and
    file formats, network connections and wire data formats, IPC channels and protocols,
    and so on. When considering whether to assign a new version to a shared library,
    you should carefully examine all aspects of the library’s interactions with the
    world to determine if a change will cause the library to act differently from
    a user’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Libtool’s attempts to hide the differences among shared-library platforms are
    so well conceived that if you’ve always used Libtool to build shared libraries,
    you may not even realize that the way shared libraries are versioned is significantly
    different between platforms.
  prefs: []
  type: TYPE_NORMAL
- en: System-Specific Versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s examine how shared-library versioning works on a few different systems
    to put the Libtool abstraction into context.
  prefs: []
  type: TYPE_NORMAL
- en: Shared-library versioning can be done either internally or externally. *Internal
    versioning* means that the library name does not reflect its version in any way.
    Thus, internal versioning implies that some form of executable header information
    provides the linker with the appropriate function calls for the requested *application
    binary interface (ABI)*. This also implies that all function calls for all versions
    of the library are maintained within the same shared-library file. Libtool supports
    internal versioning where mandated by platform requirements, but it prefers to
    use external versioning. With *external versioning*, version information is specified
    in the filename itself.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to library-level versioning, wherein a particular version number
    or string refers to the entire library interface, many Unix systems support a
    form of export- or symbol-level versioning, wherein a shared library exports multiple
    named or numbered versions of the same function or global data item. While Libtool
    does not hinder the use of such export-level versioning schemes on a per-system
    basis, it does not provide any specific portability support for them, either.
    Therefore, I won’t go into great detail on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux and Solaris Library Versioning*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Modern Linux borrows much of its library versioning system from Oracle’s Solaris
    operating system, version 9.^([1](footnote.xhtml#ch08fn1)) These systems use a
    form of external library versioning in which version information is encoded in
    the shared-library filename, following a specific pattern or template. Let’s look
    at a partial directory listing for the */usr/lib/x86_64-linux-gnu* directory on
    a typical Linux system—specifically, the files associated with a fairly typical
    library, *libcurl*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The content in this console directory listing is specific to my system, which
    is based on a Debian distribution. If your distribution is not based on Debian,
    you will probably see a somewhat different listing—perhaps even significantly
    different. In this case, do not try to follow along on your system. Instead, just
    follow my example here as you read the following description. The concepts, not
    the filenames, are the important part of this discussion*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Library names on Linux systems conform to a standard format: *lib*name*.so.*X*.*Y.
    The X*.*Y portion of the format represents the version information, where X is
    the major version number (always a single number) and Y is the minor version number
    (which may contain multiple dot-separated parts). The general rule is that changes
    in X represent non-backward-compatible changes to the library’s ABI, while changes
    in Y represent backward-compatible modifications, including isolated additions
    to the library’s interface and nonintrusive bug fixes.'
  prefs: []
  type: TYPE_NORMAL
- en: Often, you’ll see what appears to be a third numbered component. The entry at
    ➍, for example, represents the actual *curl* shared library, *libcurl.so.4.4.0*.
    In this example, the last two numbers (*4.0*) really just represent a two-part
    minor version number. Such additional numeric information in the minor version
    number is sometimes referred to as the library’s *patch level*.^([2](footnote.xhtml#ch08fn2))
  prefs: []
  type: TYPE_NORMAL
- en: The *libcurl.so.4* entry at ➌ is referred to as the library’s *shared object
    name (soname)*^([3](footnote.xhtml#ch08fn3)) and is actually a soft link that
    points to the binary file. The soname is the format that consuming programs and
    libraries reference internally—that is, the linker embeds this name in the consuming
    program or library when it’s built. The soft link is created by the `ldconfig`
    utility, which (among other things) ensures that an appropriate soname can locate
    the latest minor version of an installed library. The `ldconfig` utility is usually
    executed by post-install scripts and triggers of RPM and Debian packages. Therefore,
    while the soname is not created or installed by the `make install` target, it
    is most often created by distro installation packages and, therefore, by Linux
    packagers.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how this versioning scheme allows multiple sonames for different major
    versions and multiple binaries with different major and minor versions to all
    coexist within a single directory.
  prefs: []
  type: TYPE_NORMAL
- en: Development packages for a library (ending in *-dev* or *-devel*) often install
    a so-called *linker name* entry (at ➋) as well. The linker name is a soft link
    ending only in *.so* that usually points to the soname, though in some cases (such
    as this one), it may refer directly to the binary shared library. The linker name
    is the name by which a library is referred to on the linker command line. The
    development library allows you to run programs on your system that are linked
    against the latest version of a library but develop against an older version of
    that library, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The entry at ➊ refers to the static archive form of the library, which has a
    *.a* extension on Linux and Solaris systems. The remaining entries represent other
    forms of the *curl* library set generated for purposes specific to the *curl*
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The *curl* library has become an important part of modern Linux systems over
    the years; it’s used by many other programs installed on the system, some of which
    have not been upgraded to the latest major version. The maintainers assert that
    major version 4 is backward compatible with major version 3\. Therefore, sonames
    referring to version 3 are directed toward version 4 of the libraries on systems
    where version 4 is installed. This is not necessarily a common practice, but it
    happens to work in this case.
  prefs: []
  type: TYPE_NORMAL
- en: From here on out, the waters become muddied by a strange array of external and
    internal shared-library versioning techniques. Each of these less-than-intuitive
    systems is designed to overcome some of the fundamental problems that have been
    discovered in the Solaris system over the years.^([4](footnote.xhtml#ch08fn4))
    Let’s look at a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: '*IBM AIX Library Versioning*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Traditionally, IBM’s AIX used a form of internal versioning, storing all library
    code within a single archive file that follows the pattern *lib*name.*a*. This
    file may actually contain both static and shared forms of code, as well as 32-bit
    and 64-bit code. Internally, all shared-library code is stored in a single, logical,
    shared-object file within the archive file, while static library objects are stored
    as individual logical object files within the archive.
  prefs: []
  type: TYPE_NORMAL
- en: I say “traditionally” because more recent versions of AIX (including all 64-bit
    versions) now support the concept of loading shared-library code directly from
    physical *.so* files.
  prefs: []
  type: TYPE_NORMAL
- en: Libtool generates shared-library code on AIX using both of these schemes. If
    the AIX `-brtl` native linker flag is specified on the command line, Libtool generates
    shared libraries with *.so* extensions. Otherwise, it generates combined libraries
    following the older, single-file scheme.^([5](footnote.xhtml#ch08fn5))
  prefs: []
  type: TYPE_NORMAL
- en: When using the *.so* file scheme on AIX, Libtool generates libraries named in
    the Linux/Solaris pattern in order to maintain a degree of alliance with these
    more popular platforms. Regardless of the shared-library extension used, however,
    version information is still not stored in the filename; it is stored internally,
    within the library and consuming executables. As far as I can tell, Libtool ensures
    that the correct internal structures are created to reflect the proper versioning
    information within the shared-library header. It does this by passing appropriate
    flags to the native linker with embedded version information derived from the
    Libtool version string.
  prefs: []
  type: TYPE_NORMAL
- en: Executables on most Unix systems also support the concept of an embedded runtime
    library search path (called a *`LIBPATH`* on AIX), which usually specifies a set
    of colon-separated filesystem paths to be searched for shared-library dependencies.
    You can use Libtool’s `-R` command line option to specify a library search path
    for both programs and libraries. Libtool will translate this option to the appropriate
    GNU or native linker option on any given system.
  prefs: []
  type: TYPE_NORMAL
- en: I say executables *usually* support this option because on AIX, there are a
    few nuances. If all of the directories specified in the `LIBPATH` are real directories,
    everything works as expected—that is, the `LIBPATH` acts purely as a library search
    path. However, if the first segment of the `LIBPATH` is not a real filesystem
    entry, it acts as a so-called *loader domain*, which is basically a namespace
    for a particular shared library. Thus, multiple shared libraries of the same name
    can be stored within the same AIX archive (*.a*) file, each assigned (by linker
    options) to a different loader domain. The library that matches the loader domain
    specified in the `LIBPATH` is loaded from the archive. This can have nasty side
    effects if you assign a loader domain via the `LIBPATH` that later becomes (by
    chance) a real filesystem entry. On the other hand, you could also specify a search
    directory in the `LIBPATH` that happens to match a loader domain in a shared library.
    If that directory is removed later, you’ll unintentionally begin to use the loader
    domain. As you can imagine, strange behavior ensues. Most of these issues have
    been solved by AIX developers by ensuring that loader domain strings look nothing
    like filesystem paths.
  prefs: []
  type: TYPE_NORMAL
- en: On AIX systems, all code, whether static or shared, is compiled as position-independent
    code because AIX has only ever been ported to PowerPC and RS/6000 processors.
    The architectures of these processors only allow for PIC code, so AIX compilers
    can’t generate non-PIC code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Microsoft DLL Versioning*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider Microsoft Windows *dynamic link libraries (DLLs)*, which are shared
    libraries in every sense of the word and provide a proper application programming
    interface (API). But unfortunately, Microsoft has, in the past, provided no integrated
    DLL interface versioning scheme. As a result, Windows developers have often referred
    to DLL versioning issues (tongue-in-cheek, I’m sure) as *DLL hell*.
  prefs: []
  type: TYPE_NORMAL
- en: As a sort of Band-Aid fix to this problem, DLLs on Windows systems can be installed
    into the same directory as the program that uses them. The Windows operating system
    loader will always attempt to use the local copy before searching for a copy in
    the system path. This alleviates a part of the problem because it allows you to
    install a specific version of the library with the package that requires it. While
    this is a fair solution, it’s not really a good solution, because one of the major
    benefits of shared libraries is that they can be shared—both on disk and in memory.
    If every application has its own copy of a different version of the library, then
    this benefit of shared libraries is lost—both on disk and in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Since the introduction of this partial solution years ago, Microsoft hasn’t
    paid much attention to DLL-sharing efficiency issues. The reasons for this include
    both a cavalier attitude regarding the cost of disk space and RAM and a technical
    issue regarding the implementation of Windows DLLs. Instead of generating position-independent
    code, Microsoft system architects chose to link DLLs with a specific base address
    and then list all of the absolute address references in a base table in the library
    image header. When a DLL can’t be loaded at the desired base address (because
    of a conflict with another DLL), the loader *rebases* the DLL by picking a new
    base address and changing all of the absolute addresses in the code segment that
    are referred to in the base table. When a DLL is rebased in this manner, it can
    only be shared with processes that happen to rebase the DLL to the same address.
    The odds of accidentally encountering such a scenario—especially among applications
    with many DLL components—are pretty slim.
  prefs: []
  type: TYPE_NORMAL
- en: More recently, Microsoft invented the concept of the *side-by-side cache* (sometimes
    referred to as *SxS*), which allows developers to associate a unique identification
    value (a GUID, in fact) with a particular version of a DLL installed in a system
    location. The location directory name is derived from the DLL name and the version
    identifier. Applications built against SxS-versioned libraries have metadata stored
    in their executable headers indicating the specifically versioned DLLs they require.
    If the right version is found (by newer OS loaders) in the SxS cache, then it
    is loaded. Based on policy in the EXE header’s metadata, the loader can revert
    to the older scheme of looking for a local copy and then a global copy of the
    DLL. This is a vast improvement over earlier solutions, and it provides a very
    flexible versioning system.
  prefs: []
  type: TYPE_NORMAL
- en: The side-by-side cache effectively moves the Windows DLL architecture a step
    closer to the Unix way of managing shared libraries. Think of the SxS as a system
    installation location for libraries—much like the */usr/lib* directory on Unix
    systems. Also similar to Unix, multiple versions of the same DLL may be co-installed
    in the side-by-side cache.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the similarities, since DLLs use the rebasing technique as opposed
    to PIC code, the side-by-side cache is still a fairly benign efficiency improvement
    with respect to applications that manage dozens of shared libraries. SxS is really
    intended for system libraries that many applications are likely to consume. These
    are generally based at different addresses so that the odds of clashing (and thus
    rebasing) are decreased but not entirely eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: The entire based approach to shared libraries has the major drawback that the
    program address space may become fairly fragmented as the system loader honors
    randomly chosen base addresses throughout a 32-bit address space. Fortunately,
    64-bit addressing helps tremendously in this area, so you may find the side-by-side
    cache to be much more effective with respect to improving memory-use efficiency
    on 64-bit Windows systems, which are the norm these days anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '*HP-UX/AT&T SVR4 Library Versioning*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hewlett Packard’s version of Unix (since HP-UX version 10.0) adds a form of
    library-level versioning that’s very similar to the versioning used in AT&T UNIX
    System V Release 4\. For our purposes, you can consider these two types of systems
    to work nearly the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The native linker looks for libraries specified by their base name with a *.sl*
    extension. However, consuming programs and libraries contain a reference to that
    library’s *internal name*. The internal name is assigned to the library by a linker
    command line option and should contain the library’s interface version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual library is named with only the major interface version as an extension,
    and a soft link is created with a *.sl* extension pointing to the library. Thus,
    a shared library on these systems will follow this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only version information we have to work with is a major version number,
    which should be used to indicate non-backward-compatible changes from one version
    to the next. Since there’s no minor version number, as on Linux or Solaris, we
    can’t keep multiple revisions of a particular interface version around. The only
    option is to replace version zero of a library with an updated version zero if
    bug fixes or backward-compatible enhancements (that is to say, non-intrusive additions
    to the interface) are made.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can still have multiple major versions of the library co-installed,
    and Libtool takes full advantage of what’s available on these systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Libtool Library Versioning Scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The authors of Libtool tried hard to provide a versioning scheme that could
    be mapped to any of the schemes used by any Libtool platform. The Libtool versioning
    scheme is designed to be flexible enough to be forward compatible with reasonable
    future changes to existing Libtool platforms and even to new Libtool platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, it’s not a panacea. When Libtool has been extended for a new type
    of shared-library platform, situations have occurred (and continue to occur) that
    require some serious and careful evaluation. No one can be an expert on all systems,
    so the Libtool developers rely heavily on outside contributions to create proper
    mappings from the Libtool versioning scheme to the schemes of new or would-be
    Libtool platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '*Library Versioning Is Interface Versioning*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should consciously avoid thinking of library version numbers (either Libtool’s
    or those of a particular platform) as product *major*, *minor*, and *revision*
    (also called *patch* or *micro*) values. In fact, these values have very specific
    meanings to the operating system loader, and they must be updated properly for
    each new library version in order to keep from confusing the loader. A confused
    loader could load the wrong version of a library based on incorrect version information
    assigned to the library.
  prefs: []
  type: TYPE_NORMAL
- en: Several years ago, I was working with my company’s corporate versioning committee
    to come up with a software-versioning policy for the company as a whole. The committee
    wanted the engineers to ensure that the version numbers incorporated into our
    shared-library names were in alignment with the corporate software-versioning
    strategy. It took me the better part of a day to convince them that a shared-library
    version was not related to a product version in any way, nor should such a relationship
    be established or enforced by them or by anyone else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s why: the version number on a shared library is not really a library
    version but an interface version. The *interface* I’m referring to here is the
    application binary interface presented by a library to the user, another programmer
    desiring to call functions presented by the interface. An executable program has
    a single, well-defined, standard entry point (usually called `main` in the C language).
    But a shared library has multiple entry points that are generally not standardized
    in a manner that is widely understood. This makes it much more difficult to determine
    whether or not a particular version of a library is interface compatible with
    another version of the same library.'
  prefs: []
  type: TYPE_NORMAL
- en: In Libtool’s versioning scheme, shared libraries are said to support a range
    of interface versions, each identified by a unique integer value. If any publicly
    visible aspect of an interface changes between public releases, it can no longer
    be considered the same interface; it therefore becomes a new interface, identified
    by a new integer identifier. Each public release of a library in which the interface
    has changed simply acquires the next consecutive interface version number. Libraries
    that change in a backward-compatible manner between releases are said to support
    both the old and the new interface; thus, a particular release of a library may
    support interface versions 2 through 5, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Libtool library version information is specified on the `libtool` command line
    with the `-version-info` option, as shown in [Listing 8-1](ch08.xhtml#ch08ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Setting shared-library version information in a* Makefile.am
    *file*'
  prefs: []
  type: TYPE_NORMAL
- en: The Libtool developers wisely chose the colon separator over the period in an
    effort to keep developers from trying to directly associate Libtool version string
    values with the version numbers appended to the end of shared-library files on
    various platforms. The three values in the version string are respectively called
    the interface *current*, *revision*, and *age* values.
  prefs: []
  type: TYPE_NORMAL
- en: The *current* value represents the current interface version number. This is
    the value that changes when a new interface version must be declared because the
    interface has changed in some publicly visible way since the last public release
    of the library. The first interface in a library is given a version number of
    zero by convention. Consider a shared library in which the developer has added
    a new function to the set of functions exposed by this library since the last
    public release. The interface can’t be considered the same in this new version
    because there’s one additional function. Thus, its *current* number must be increased
    from zero to one.
  prefs: []
  type: TYPE_NORMAL
- en: The *age* value represents the number of back versions supported by the shared
    library. In mathematical terms, the library is said to support the interface range,
    *current − age* through *current*. In the example I just gave, a new function
    was added to the library, so the interface presented in this version of the library
    is not the same as it was in the previous version. However, the previous version
    is still fully supported, because the previous interface is a proper subset of
    the current interface. Therefore, the *age* value should also be incremented from
    zero to one.
  prefs: []
  type: TYPE_NORMAL
- en: The *revision* value merely represents a serial revision of the current interface.
    That is, if no publicly visible changes are made to a library’s interface between
    releases—perhaps only an internal function was optimized—then the library name
    should change in some manner, if only to distinguish between the two releases.
    But both the *current* and *age* values would be the same, because the interface
    has not changed from the user’s perspective. Therefore, the *revision* value is
    incremented to reflect the fact that this is a new release of the same interface.
    In the previous example, the *revision* value would be left at zero, because one
    or both of the other values were incremented.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the release process for shared libraries, the Libtool versioning
    algorithm should be followed step-wise for each new version of a library that
    is about to be publicly released:^([6](footnote.xhtml#ch08fn6))
  prefs: []
  type: TYPE_NORMAL
- en: Start with version information 0:0:0 for each new Libtool library. (This is
    done automatically if you simply omit the `-version-info` option from the list
    of linker flags passed to the `libtool` script.) For existing libraries, start
    with the previous public release’s Libtool version information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the library source code has changed at all since the last update, then increment
    *revision* (*c*:*r*:*a* becomes *c*:*r*+1:*a*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any exported functions or data have been added, removed, or changed since
    the last update, increment *current* and set *revision* to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any exported functions or data have been added since the last public release,
    increment *age*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any exported functions or data have been removed since the last public release,
    set *age* to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that this is an algorithm; as such, it’s designed to be followed
    step-by-step as opposed to jumping directly to the steps that appear to apply
    to your case. For example, if you removed an API function from your library since
    the last release, you would not simply jump to the last step and set *age* to
    zero. Rather, you would follow all of the steps until you reached the last step,
    and *then* set *age* to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember to update the version information only immediately before a public
    release of your software. More frequent updates are unnecessary and only guarantee
    that the *current* interface number becomes larger faster*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. Assume that this is the second release of a library
    and the first release used a `-version-info` string of `0:0:0`. One new function
    was added to the library interface during this development cycle, and one existing
    function was deleted. The effect on the version information string for this new
    release of the library would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with the previous version information: `0:0:0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0:0:0` becomes `0:1:0` (the library’s source was changed).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0:1:0` becomes `1:0:0` (the library’s interface was modified).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1:0:0` becomes `1:0:1` (one new function was added).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1:0:1` becomes `1:0:0` (one old function was removed).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be clear by now that there is no *direct* correlation between Libtool’s
    *current*, *revision*, and *age* values and Linux’s major, minor, and optional
    patch-level values. Instead, mapping rules are used to transform the values in
    one scheme to values in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the preceding example, wherein a second release of a library added
    one function and removed one function, we ended up with a new Libtool version
    string of `1:0:0`. The version string `1:0:0` indicates that the library is not
    backward compatible with the previous version (*age* is zero), so the Linux shared-library
    file would be named *lib*name.*so.1.0.0*. This looks suspiciously like the Libtool
    version string—but don’t be fooled. This fairly common coincidence is perhaps
    one of the most confusing aspects of the Libtool versioning abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our example just a little to say that we’ve added a new library
    interface function but haven’t removed anything. Start again with the original
    version information of `0:0:0` and follow the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with the previous version information: `0:0:0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0:0:0` becomes `0:1:0` (the library’s source was changed).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0:1:0` becomes `1:0:0` (the library’s interface was modified).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1:0:0` becomes `1:0:1` (one new function was added).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not applicable (nothing was removed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, we end up with a Libtool version string of `1:0:1`, but the resulting
    Linux or Solaris shared-library filename is *lib*name.*so.0.1.0*. Consider for
    a moment what it means, in the face of major, minor, and patch-level values, to
    have a nonzero *age* value in the Libtool version string. An *age* value of one
    (as in this case) means that we are effectively still supporting a Linux major
    value of zero, because this new version of the library is 100 percent backward
    compatible with the previous version. The minor value in the shared-library filename
    has been incremented from zero to one to indicate that this is, in fact, an updated
    version of the soname, *lib*name.*so.0*. The patch-level value remains at zero
    because this value indicates a bug fix to a particular minor revision of an soname.
  prefs: []
  type: TYPE_NORMAL
- en: Once you fully understand Libtool versioning, you’ll find that even this algorithm
    does not cover all possible interface modification scenarios. Consider, for example,
    version information of `0:0:0` for a shared library that you maintain. Now assume
    you add a new function to the interface for the next public release. This second
    release properly defines version information of `1:0:1` because the library supports
    both interface versions 0 and 1\. However, just before the third release of the
    library, you realize you didn’t really need that new function after all, so you
    remove it. This is the only publicly visible change made to the library interface
    in this release. The algorithm would have set the version information string to
    `2:0:0`. But in fact, you’ve merely removed the second interface and are now presenting
    the original interface once again. Technically, this library would be properly
    configured with a version information string of `0:1:0` because it presents a
    second release of version 0 of the shared-library interface. The moral of this
    story is that you need to fully understand the way Libtool versioning works and
    then decide, based on that understanding, what the proper next-version values
    should be.
  prefs: []
  type: TYPE_NORMAL
- en: I’d also like to point out that the *GNU Libtool Manual* makes little effort
    to describe the myriad ways an interface can be different from one version of
    a library to another. An interface version indicates functional semantics as well
    as API syntax. If you change the way a function works semantically but leave the
    function signature untouched, you’ve still changed the function. If you change
    the network wire format of data sent by a shared library, then it’s not really
    the same shared library from the perspective of the consuming code. All the operating
    system loader really cares about when attempting to determine which library to
    load is, *will this library work just as well as that one?* In these cases, the
    answer would have to be no, because even though the API interface is identical,
    the publicly visible way the two libraries do things is not the same.
  prefs: []
  type: TYPE_NORMAL
- en: '*When Library Versioning Just Isn’t Enough*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These types of changes to a library’s interface are so complex that project
    maintainers will often simply rename the library, thereby skirting library-versioning
    issues entirely. One excellent way to rename your library is to use Libtool’s
    `-release` flag. This flag adds a separate class of library versioning information
    into the base name of the library, effectively making it an entirely new library
    from the perspective of the operating system loader. The `-release` flag is used
    in the manner shown in [Listing 8-2](ch08.xhtml#ch08ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Setting shared-library release information in a* Makefile.am
    *file*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I used `-release` and `-version-info` in the same set of Libtool
    flags, just to show you that they can be used together. You’ll note here that
    the release string is specified as a series of dot-separated values. In this case,
    the final name of your Linux or Solaris shared library will be *lib*name-*2.9.0.so.0.0.0*.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason developers choose to use release strings is to provide some sort
    of correlation between library versions across platforms. As demonstrated earlier,
    a particular Libtool version information string will probably result in different
    library names across platforms because Libtool maps version information into library
    names differently from platform to platform. Release information remains stable
    across platforms, but you should carefully consider how you want to use release
    strings and version information in your shared libraries, because the way you
    choose to use them will affect binary compatibility between releases of your libraries.
    The OS loader will not consider two versions of a library compatible if they have
    different release strings, regardless of the values of those strings.
  prefs: []
  type: TYPE_NORMAL
- en: Using libltdl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s move on to a discussion of Libtool’s *ltdl* library. Once again, we
    need to add some functionality to the Jupiter project in order to illustrate these
    concepts. The goal here is to create a plug-in interface that the `jupiter` program
    can use to modify output based on end-user policy choices.
  prefs: []
  type: TYPE_NORMAL
- en: '*Necessary Infrastructure*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Currently, `jupiter` prints *Hello from jupiter!* (Actually, the name printed
    is more likely, at this point, to be a long, ugly path containing some Libtool
    directory garbage and some derivation of the name *jupiter*, but just pretend
    it prints *jupiter* for now.) We’re going to add an additional parameter named
    `salutation` to the *common* static library method, `print_routine`. This parameter
    will also be of type pointer-to-`char` and will contain the leading word or phrase—the
    salutation—in `jupiter`’s greeting.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 8-3](ch08.xhtml#ch08ex3) and [8-4](ch08.xhtml#ch08ex4) indicate the
    changes we need to make to files in the *common* subdirectory.'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 8.0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3:* common/print.c: *Adding a salutation to the `print_routine`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4:* common/jupcommon.h: *Adding a salutation to the `print_routine`
    prototype*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 8-5](ch08.xhtml#ch08ex5) and [8-6](ch08.xhtml#ch08ex6) show the changes
    we need to make to files in the *libjup* and *include* subdirectories.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5:* libjup/jup_print.c: *Adding a salutation to the `jupiter_print`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6:* include/libjupiter.h: *Adding a salutation to the `jupiter_print`
    prototype*'
  prefs: []
  type: TYPE_NORMAL
- en: And finally, [Listing 8-7](ch08.xhtml#ch08ex7) shows what we need to do to *main.c*
    in the *src* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7:* src/main.c: *Passing a salutation to `jupiter_print`*'
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, all we’ve really done here is parameterize the salutation throughout
    the print routines. That way, we can indicate from `main` which salutation we’d
    like to use. I’ve set the default salutation to *Hello* so that nothing will have
    changed from the user’s perspective. Thus, the overall effect of these changes
    is benign. Note also that these are all source code changes—we’ve made no changes
    to the build system. I wanted to compartmentalize these changes so as to not confuse
    this necessary refactoring with what we’re doing to the build system to add the
    new module-loading functionality.
  prefs: []
  type: TYPE_NORMAL
- en: After making these changes, should you update the version number of this shared
    library? That depends on whether you’ve already shipped this library (that is,
    posted a tarball) before you made the changes. The point of versioning is to maintain
    some semblance of control over your public interface—but if you’re the only one
    who has ever seen it, there’s no point in changing the version number.
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding a Plug-In Interface*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’d like to make it possible to change the salutation displayed by simply changing
    which plug-in module is loaded at runtime. All of the changes we’ll need to make
    to the code and build system to add this functionality will be limited to the
    *configure.ac* file and to files within the *src* directory and its subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to define the actual plug-in interface. We’ll do this by creating
    a new private header file in the *src* directory called *module.h*. This file
    is shown in [Listing 8-8](ch08.xhtml#ch08ex8).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 8.1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8:* src/module.h: *The initial contents of this file*'
  prefs: []
  type: TYPE_NORMAL
- en: This header file has a number of interesting aspects. First, let’s look at the
    preprocessor definition, `GET_SALUTATION_SYM`, at ➊. This string represents the
    name of the function you need to import from the plug-in module. I like to define
    these in the header file so all the information that needs to be reconciled exists
    in one place. In this case, the symbol name, the function type definition, and
    the function prototype must all be in alignment, and you can use this single definition
    for all three.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting item is the type definition^([7](footnote.xhtml#ch08fn7))
    at ➋. If we don’t provide one, the user is going to have to invent one, or else
    use a complex typecast on the return value of the `dlsym` function. Therefore,
    we’ll provide it here for consistency and convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, look at the function prototype at ➌. This isn’t so much for the caller
    as it is for the module itself. Modules providing this function should include
    this header file so the compiler can catch potential misspellings of the function
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '*Doing It the Old-Fashioned Way*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this first attempt, let’s use the *dl* interface provided by the Solaris/Linux
    *libdl.so* library. In the next section, we’ll convert this code over to the Libtool
    *ltdl* interface for greater portability.
  prefs: []
  type: TYPE_NORMAL
- en: To do this right, we need to add checks to *configure.ac* to look for both the
    *libdl* library and the *dlfcn.h* header file. These changes to *configure.ac*
    are highlighted in [Listing 8-9](ch08.xhtml#ch08ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*listing 8-9:* configure.ac: *Adding checks for the* dl *library and public
    header file*'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, I added the *dlfcn.h* header file to the list of files passed to the `AC_CHECK_HEADERS`
    macro, and then at ➋, I added a check for the `dlopen` function in the *dl* library.
    Note here that the `AC_SEARCH_LIBS` macro searches a list of libraries for a function,
    so this call goes in the “Checks for library functions” section rather than the
    “Checks for libraries” section. To help us see which libraries we’re actually
    linking against, I’ve also added a line to the `cat` command at the end of the
    file. The `Libraries:` line at ➌ displays the contents of the `LIBS` variable,
    which is modified by the `AC_SEARCH_LIBS` macro.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The *`LT_INIT`* macro also checks for the existence of the* dlfcn.h *header
    file, but I do it here explicitly so it’s obvious to observers that I wish to
    use this header file. This is a good rule of thumb to follow, as long as it doesn’t
    negatively affect performance too much. Since Autoconf caches the results of checks,
    it’s not likely to do so. You can tell this is happening when you see *`(cached)
    ...`* after a check in *`configure`*’s output.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a module requires several changes, so we’ll make them all here, beginning
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I’ve created two new subdirectories. The first is *modules*, beneath *src*,
    and the second is *hithere*, beneath *modules*. Each new module added to this
    project will have its own directory beneath *modules*. The *hithere* module will
    provide the salutation *Hi there*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-10](ch08.xhtml#ch08ex10) illustrates how to add a `SUBDIRS` variable
    to the *src/Makefile.am* file to ensure that the build system processes the *modules/hithere*
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10:* src/Makefile.am: *Adding a `SUBDIRS` variable to this* Makefile.am
    *file*'
  prefs: []
  type: TYPE_NORMAL
- en: The way I’ve used `SUBDIRS` at ➊ presents a new concept. Until now, Jupiter’s
    *Makefile.am* files have only referenced direct descendants of the current directory,
    but this is not strictly necessary, as you can see. In fact, for Jupiter, the
    *modules* directory will only contain additional subdirectories, so it makes little
    sense to provide a *modules/Makefile.am* file just so you can reference its subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: While you’re editing the file, you should add the new *module.h* header file
    to the `SOURCES` variable at ➋. If you don’t do this, `jupiter` will still compile
    and build correctly for you as the maintainer, but the `distcheck` target will
    fail because none of the *Makefile.am* files will have mentioned *module.h*.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to change the way the `greptest.sh` shell script is built so it
    can test for any type of salutation. A simple modification of the regular expression
    at ➌ will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: I created a *Makefile.am* file in the new *hithere* subdirectory that contains
    instructions on how to build the *hithere.c* source file, and then I added the
    *hithere.c* source file to this directory. These files are shown in [Listings
    8-11](ch08.xhtml#ch08ex11) and [8-12](ch08.xhtml#ch08ex12), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11:* src/modules/hithere/Makefile.am: *The initial version of this
    file*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-12:* src/modules/hithere/hithere.c: *The initial version of this
    file*'
  prefs: []
  type: TYPE_NORMAL
- en: The *hithere.c* source file includes the semi-private *module.h* header file
    using a double-quoted relative path. Since Automake automatically adds `-I$(srcdir)`
    to the list of *include* paths used, the C preprocessor will properly sort out
    the relative path. The file then defines the `get_salutation` function, whose
    prototype is in the *module.h* header file. This implementation simply returns
    a pointer to a static string, and as long as the library is loaded, the caller
    can access the string. However, callers must be aware of the scope of data references
    returned by plug-in modules; otherwise, the program may unload a module before
    a caller is done using it.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of *hithere/Makefile.am* (at ➊ in [Listing 8-11](ch08.xhtml#ch08ex11))
    requires some explanation. Here, we’re using a `-module` option on the `hithere_la_LDFLAGS`
    variable. This is a Libtool option that tells Libtool you want to call your library
    *hithere*, not *libhithere*. The *GNU Libtool Manual* makes the statement that
    modules do not need to be prefixed with *lib*. And since your code will be loading
    these modules manually, it should not have to be concerned with determining and
    properly using a platform-specific library name prefix.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t care to use module versioning on your dynamically loadable (`dlopen`-ed)
    modules, try using the Libtool `-avoid-version` option. This option causes Libtool
    to generate a shared library whose name is *lib*name.*so*, rather than *lib*name.*so.0.0.0*.
    It also suppresses generation of the *lib*name.*so.0* and *lib*name.*so* soft
    links that refer to the binary image. Because I’m using both options, my module
    will simply be named *hithere.so*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get this module to build, we need to add the new *hithere* module’s
    makefile to the `AC_CONFIG_FILES` macro in *configure.ac*, as shown in [Listing
    8-13](ch08.xhtml#ch08ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-13:* configure.ac: *Adding the* hithere *directory makefile to `AC_CONFIG_FILES`*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in order to use the module, we need to modify *src/main.c* so that
    it loads the module, imports the symbol, and calls it. These changes to *src/main.c*
    are highlighted in bold in [Listing 8-14](ch08.xhtml#ch08ex14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-14:* src/main.c: *Using the new plug-in module from the `main` function*'
  prefs: []
  type: TYPE_NORMAL
- en: I’m including the new private *module.h* header file at ➊, and I added a preprocessor
    directive to conditionally include *dlfcn.h* at ➋. Finally, I added two sections
    of code, one before and one after the original call to `jupiter_print` (at ➌ and
    ➎, respectively). Both are conditionally compiled based on the existence of a
    dynamic loader, allowing the code to build and run correctly on systems that do
    not provide the *libdl* library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general philosophy I use when deciding whether or not code should be conditionally
    compiled is this: If `configure` fails because a library or header file is missing,
    then I don’t need to conditionally compile the code that uses the item `configure`
    checks for. If I check for a library or header file in `configure` but allow it
    to continue if it’s missing, then I’d better use conditional compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just a few more minor points to bring up regarding the use of *dl*
    interface functions. First, at ➍, `dlopen` accepts two parameters: a filename
    or *path* (absolute or relative) and a *flags* word, which is the bitwise composite
    of your choice of several flag values defined in *dlfcn.h*. Check the man page
    for `dlopen` to learn more about these flag bits. If you use a path, then `dlopen`
    honors that path verbatim, but if you use a filename, the library search path
    is searched in an attempt to locate your module. By prefixing the name with *./*,
    we’re telling `dlopen` not to search the library path.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to configure which module `jupiter` uses, so we’re loading
    a generic name, *module.so*. In fact, the built module is located several directories
    below the *src* directory in the build tree, so we need to create a soft link
    in the current directory called *module.so* that points to the module we want
    to load. This is a rather shabby form of configuration for Jupiter, but it works.
    In a real application, you would define the desired module to load using policy
    defined in some sort of configuration file, but in this example, I’m simply ignoring
    these details for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’m ignoring some error handling in [Listing 8-14](ch08.xhtml#ch08ex14). In
    production code, you would probably want to log or display something if the module
    doesn’t load or if the symbol is not exported by the module.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command sequence shows our loadable module in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The symlink *`module.so`* refers to a file in a hidden* .libs *directory.
    Executables and libraries are generated into a* .libs *directory within the associated
    source directory by Autotools build systems*.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting to Libtool’s ltdl Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Libtool provides a wrapper library called *ltdl* that abstracts and hides some
    of the portability issues surrounding the use of shared libraries across many
    different platforms. Most applications ignore the *ltdl* library because of the
    added complexity involved in using it, but there are really only a few issues
    to deal with. I’ll enumerate them here and then cover them in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The *ltdl* functions follow a naming convention based on the *dl* library. The
    rule of thumb is that *dl* functions in the *ltdl* library have the prefix `lt_`.
    For example, `dlopen` is named `lt_dlopen`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the *dl* library, the *ltdl* library must be initialized and terminated
    at appropriate locations within a consuming application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications should be built using the `-dlopen` *`modulename`* option on the
    linker command line (in the `*_LDFLAGS` variable). This tells Libtool to link
    the code for the module into the application when building on platforms without
    shared libraries or when linking statically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LTDL_SET_PRELOADED_SYMBOLS()` macro should be used at an appropriate location
    within your program source code to ensure that module code can be accessed on
    non-shared-library platforms or when building static-only configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared-library modules designed to be `dlopen`-ed using *ltdl* should use the
    `-module` option (and, optionally, the `-avoid-version` option) on the linker
    command line (in the `*_LDFLAGS` variable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ltdl* library provides extensive functionality beyond the *dl* library;
    this can be intimidating, but know that all of this other functionality is optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at what we need to do to the Jupiter project build system in order
    to use the *ltdl* library. First, we need to modify *configure.ac* to look for
    the *ltdl.h* header and search for the `lt_dlopen` function. This means modifying
    references to *dlfcn.h* and the *dl* library in the `AC_CHECK_HEADERS` and `AC_SEARCH_LIBS`
    macros, as highlighted in [Listing 8-15](ch08.xhtml#ch08ex15).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 8.2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-15:* configure.ac: *Switching from `dl` to `ltdl` in* configure.ac'
  prefs: []
  type: TYPE_NORMAL
- en: Even though we’re using Libtool, we need to check for *ltdl.h* and *libltdl*,
    because *ltdl* is a separate library that must be installed on the end user’s
    system. It should be treated the same as any other required third-party library.
    By searching for these installed resources on the user’s system and failing configuration
    if they’re not found, or by properly using preprocessor definitions in your source
    code, you can provide the same sort of configuration experience with *ltdl* that
    I’ve presented throughout this book when using other third-party resources.
  prefs: []
  type: TYPE_NORMAL
- en: I’d like you to recognize that this is the first time we’ve seen the requirement
    for the user to install an Autotools package on his system—and this is the very
    reason most people avoid using *ltdl*. The *GNU Libtool Manual* provides a detailed
    description of how to package the *ltdl* library with your project so it is built
    and installed on the user’s system when your package is built and installed.^([8](footnote.xhtml#ch08fn8))
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, shipping the source code for the *ltdl* library with your package
    is the only way to get your program to *statically* link with the *ltdl* library.
    Linking statically with *ltdl* has the side effect of not requiring the user to
    install the *ltdl* library on their system, since the library becomes part of
    the project’s executable images. There are a few caveats, however. If your project
    also uses a third-party library that dynamically links to *ltdl*, you’ll have
    a symbol conflict between the shared and static versions of the *ltdl* libraries.^([9](footnote.xhtml#ch08fn9))
  prefs: []
  type: TYPE_NORMAL
- en: The next major change we need to make is in the source code—it is limited, in
    this case, to *src/main.c* and highlighted in [Listing 8-16](ch08.xhtml#ch08ex16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-16:* src/main.c: *Switching from `dl` to `ltdl` in source code*'
  prefs: []
  type: TYPE_NORMAL
- en: These changes are very symmetrical with respect to the original code. Mostly,
    items that previously referred to `DL` or `dl` now refer to `LTDL` or `lt_dl`.
    For example, `#if HAVE_DLFCN_H` becomes `#if HAVE_LTDL_H`, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: One important change is that the *ltdl* library must be initialized at ➌ with
    a call to `lt_dlinit`, whereas the *dl* library did not require initialization.
    In a larger program, the overhead of calling `lt_dlinit` and `lt_dlexit` would
    be amortized over a much larger code base.
  prefs: []
  type: TYPE_NORMAL
- en: Another important detail is the addition of the `LTDL_SET_PRELOADED_SYMBOLS`
    macro invocation at ➋. This macro configures global variables required by the
    `lt_dlopen` and `lt_dlsym` functions on systems that don’t support shared libraries
    or in cases where the end user has specifically requested static libraries. It’s
    benign on systems that use shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: One last detail is that the return type of `dlopen` is `void *`, or a generic
    pointer, whereas the return type of `lt_dlopen` is `lt_dlhandle` (see ➊ and ➍).
    This abstraction exists so *ltdl* can be ported to systems that use return types
    that are incompatible with a generic pointer.
  prefs: []
  type: TYPE_NORMAL
- en: When a system doesn’t support shared libraries, Libtool actually links all of
    the modules that might be loaded right into the program. Thus, the `jupiter` program’s
    linker (`libtool`) command line must contain some form of reference to these modules.
    This is done using the `-dlopen` *`modulename`* construct, as shown in [Listing
    8-17](ch08.xhtml#ch08ex17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-17:* src/Makefile.am: *Adding a `-dlopen` option to the `LDADD`
    line*'
  prefs: []
  type: TYPE_NORMAL
- en: If you forget this addition to *src/Makefile.am*, you’ll get a linker error
    about an undefined symbol—something like `lt__PROGRAM__LTX_preloaded _symbols`.
    If it doesn’t detect any modules being linked into the application, Libtool won’t
    clutter your program’s global symbol space with symbols that will never be referenced;
    the symbols required by the *ltdl* library will be missing if the symbol table
    is empty.
  prefs: []
  type: TYPE_NORMAL
- en: It appears that *ltdl* is not quite as flexible as *dl* regarding the sort of
    path information you can specify in `lt_dlopen` to reference a module. In order
    to fix this problem, I hardwired the proper relative path (*modules/hithere/hithere.la*)
    into *main.c*. Additionally, this example is sensitive to the current working
    directory. If you run `jupiter` from another directory, it will also fail to find
    the module. A real program would undoubtedly use a more robust method of configuration,
    such as a configuration file containing the absolute path to the desired module
    name.^([10](footnote.xhtml#ch08fn10))
  prefs: []
  type: TYPE_NORMAL
- en: '*Preloading Multiple Modules*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If Libtool links multiple modules into a program on a system without shared-library
    support, and if those modules each provide their own version of `get_salutation`,
    then there will be a conflict of public symbols within the program’s global symbol
    space. This is because all of these modules’ symbols become part of the program’s
    global symbol space and the linker generally won’t allow two symbols of the same
    name to be added to the executable symbol table. Which module’s `get_salutation`
    function should be honored? Unfortunately, there’s no good heuristic to resolve
    this conflict. The *GNU Libtool Manual* provides for this condition by defining
    a convention for maintaining symbol-naming uniqueness:'
  prefs: []
  type: TYPE_NORMAL
- en: All exported interface symbols should be prefixed with *`modulename`*`_LTX _`
    (for example, `hithere_LTX_get_salutation`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All remaining non-static symbols should be reasonably unique. The method Libtool
    suggests is to prefix them with *`_modulename_`* (as in `_jupiter_`*`somefunction`*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules should be named differently even if they’re built in different directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it’s not explicitly stated in the manual, the `lt_dlsym` function first
    searches for the specified symbol as *`modulename`*`_LTX_`*`symbolname`*, and
    then, if it can’t find a prefixed version of the symbol, it searches for exactly
    *`symbolname`*. You can see that this convention is necessary, but only for cases
    in which Libtool may statically link such loadable modules directly into the application
    on systems that don’t support shared libraries. The price you have to pay for
    Libtool’s illusion of shared libraries on systems that don’t support them is pretty
    high, but it’s the going rate for getting the same loadable module functionality
    on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: To fix the *hithere* module’s source code so that it conforms to this convention,
    we need to make one change to *hithere.c*, shown in [Listing 8-18](ch08.xhtml#ch08ex18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-18:* src/modules/hithere/hithere.c: *Ensuring public symbols are
    unique when using `ltdl`*'
  prefs: []
  type: TYPE_NORMAL
- en: By defining the replacement for `get_salutation` at ➊ before the inclusion of
    the *module.h* header file at ➋, we’re also able to change the prototype in the
    header file so that it matches the modified version of the function name. Because
    of the way the C preprocessor works, this substitution only affects the function
    prototype in *module.h*, not the quoted symbol string or the type definition.
    At this point, you may want to go back and examine the way *module.h* is written
    to prove to yourself that this actually works.
  prefs: []
  type: TYPE_NORMAL
- en: '*Checking It All Out*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can test your program and modules for both static and dynamic shared-library
    systems by using the `--disable-shared` option on the `configure` command line,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output at ➋ and ➌ contains the *hithere* module’s salutation
    in both configurations, yet the file listing at ➊ shows us that, in the `--disable-shared`
    version, the shared library doesn’t even exist. It appears that *ltdl* is doing
    its job.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may have noticed the difference in the example’s output for the two executions
    of *`jupiter`*. In the first case, the output shows the name of the program as
    exactly *`./jupiter`*, while in the second case, it shows *`...jupiter`*. This
    was my attempt at removing the cruft in the output caused by Libtool’s redirection
    of the shared-library-consuming version referring to the actual program*—`lt-jupiter`—*in
    the* jupiter /src/.libs *directory. Libtool uses a wrapper around programs linked
    to built shared libraries in order to make it simpler for uninstalled programs
    to find the built shared libraries upon which they depend*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Jupiter code base has become rather fragile, because I’ve ignored the issue
    of where to find shared libraries at runtime. As I’ve already mentioned, you would
    ultimately have to fix this problem in a real program. But given that I’ve finished
    my task of showing you how to properly use the Libtool *ltdl* library, I’ll leave
    that as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The decision to use shared libraries brings with it a whole truckload of issues,
    and if you’re interested in maximum portability, you must deal with each of them.
    The *ltdl* library is not a solution to every problem. It solves some problems
    but brings others to the surface. Suffice it to say that using *ltdl* has trade-offs,
    but if you don’t mind the extra maintenance effort, it’s a good way to add maximum
    portability to your loadable-module project.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that by spending some time going through the exercises in this book,
    you’ve been able to get your head around the Autotools enough to know how they
    work and what they’re doing for you. At this point, you should be very comfortable
    *autotool-izing* your own projects—at least at the basic level.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, I’ll discuss additional tools and utilities that are
    also considered part of the GNU toolbox (and one or two that are not). I’ll also
    show you how to convert a real-world project from a handcoded build system to
    a much more concise, and probably more correct, Autotools build system.
  prefs: []
  type: TYPE_NORMAL
