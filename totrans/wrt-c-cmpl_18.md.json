["```\nchar c;\nsigned char c;\n```", "```\nsigned char array[4] = \"abc\";\n```", "```\nsigned char array[4] = {'a', 'b', 'c', 0};\n```", "```\nchar array1[3] = \"abc\";\nchar array2[3] = {'a', 'b', 'c'};\n```", "```\nchar *str_ptr = \"abc\";\n```", "```\nchar (*array_ptr)[4] = &\"abc\";\n```", "```\nchar *ptr = \"abc\";\nptr[0] = 'x';\n```", "```\nchar arr[3] = \"abc\";\narr[0] = 'x';\n```", "```\nstatic char null_terminated[4] = \"abc\";\nstatic char not_null_terminated[3] = \"abc\";\nstatic char extra_padding[5] = \"abc\";\n```", "```\n .data\nnull_terminated:\n    .asciz \"abc\"\nnot_null_terminated:\n    .ascii \"abc\"\nextra_padding:\n    .asciz \"abc\"\n    .zero 1\n```", "```\nint main(void) {\n    char letters[6] = \"abcde\";\n    return 0;\n}\n```", "```\nmovb    $97,  -8(%rbp)\nmovb    $98,  -7(%rbp)\nmovb    $99,  -6(%rbp)\nmovb    $100, -5(%rbp)\nmovb    $101, -4(%rbp)\nmovb    $0,   -3(%rbp)\n```", "```\nmovl    $1684234849, -8(%rbp)\nmovb    $101, -4(%rbp)\nmovb    $0,   -3(%rbp)\n```", "```\nreturn \"A profound statement.\";\n```", "```\n .section .rodata\n.Lstring.0:\n    .asciz \"A profound statement.\"\n```", "```\nleaq    .Lstring.0(%rip), %rax\n```", "```\nstatic char *ptr = \"A profound statement.\";\n```", "```\n .data\n    .align 8\nptr:\n    .quad .Lstring.0\n```", "```\nstatic int x = 10;\nstatic int *ptr = &x;\n```", "```\n .data\n    .align 4\nx:\n    .long 10\n    .align 8\nptr:\n    .quad x\n```", "```\n'([^'\\\\\\n]|\\\\['\"?\\\\abfnrtv])'\n```", "```\n\"([^\"\\\\\\n]|\\\\['\"\\\\?abfnrtv])*\"\n```", "```\nconst = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)\n      | ConstDouble(double) | **ConstChar(int) | ConstUChar(int)**\n```", "```\nprogram = Program(declaration*)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, initializer? init,\n                        type var_type, storage_class?)\nfunction_declaration = (identifier name, identifier* params, block? body,\n                        type fun_type, storage_class?)\ninitializer = SingleInit(exp) | CompoundInit(initializer*)\ntype = **Char | SChar | UChar |** Int | Long | UInt | ULong | Double\n     | FunType(type* params, type ret)\n     | Pointer(type referenced)\n     | Array(type element, int size)\nstorage_class = Static | Extern\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(const)\n **| String(string)**\n    | Var(identifier)\n    | Cast(type target_type, exp)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\n    | Dereference(exp)\n    | AddrOf(exp)\n    | Subscript(exp, exp)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\nconst = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)\n      | ConstDouble(double) | **ConstChar(int) | ConstUChar(int)**\n```", "```\nreturn \"foo\" \"bar\";\n```", "```\n<program> ::= {<declaration>}\n<declaration> ::= <variable-declaration> | <function-declaration>\n<variable-declaration> ::= {<specifier>}+ <declarator> [\"=\" <initializer>] \";\"\n<function-declaration> ::= {<specifier>}+ <declarator> (<block> | \";\")\n<declarator> ::= \"*\" <declarator> | <direct-declarator>\n<direct-declarator> ::= <simple-declarator> [<declarator-suffix>]\n<declarator-suffix> ::= <param-list> | {\"[\" <const> \"]\"}+\n<param-list> ::= \"(\" \"void\" \")\" | \"(\" <param> {\",\" <param>} \")\"\n<param> ::= {<type-specifier>}+ <declarator>\n<simple-declarator> ::= <identifier> | \"(\" <declarator> \")\"\n<type-specifier> ::= \"int\" | \"long\" | \"unsigned\" | \"signed\" | \"double\" **|** ❶ **\"char\"**\n<specifier> ::= <type-specifier> | \"static\" | \"extern\"\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<initializer> ::= <exp> | \"{\" <initializer> {\",\" <initializer>} [\",\"] \"}\"\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= <unary-exp> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<unary-exp> ::= <unop> <unary-exp>\n              | \"(\" {<type-specifier>}+ [<abstract-declarator>] \")\" <unary-exp>\n              | <postfix-exp>\n<postfix-exp> ::= <primary-exp> {\"[\" <exp> \"]\"}\n<primary-exp> ::= <const> | <identifier> | \"(\" <exp> \")\" **|** ❷ **{<string>}+**\n                | <identifier> \"(\" [<argument-list>] \")\"\n<argument-list> ::= <exp> {\",\" <exp>}\n<abstract-declarator> ::= \"*\" [<abstract-declarator>]\n                        | <direct-abstract-declarator>\n<direct-abstract-declarator> ::= \"(\" <abstract-declarator> \")\" {\"[\" <const> \"]\"}\n                               | {\"[\" <const> \"]\"}+\n<unop> ::= \"-\" | \"~\" | \"!\" | \"*\" | \"&\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<const> ::= <int> | <long> | <uint> | <ulong> | <double> **|** ❸ **<char>**\n<identifier> ::= ? An identifier token ?\n**<string> ::= ? A string token ?** ❹\n<int> ::= ? An int token ?\n**<char> ::= ? A char token ?** ❺\n<long> ::= ? An int or long token ?\n<uint> ::= ? An unsigned int token ?\n<ulong> ::= ? An unsigned int or unsigned long token ?\n<double> ::= ? A floating-point constant token ?\n```", "```\nget_common_type(type1, type2):\n    if type1 is a character type:\n        type1 = Int\n    if type2 is a character type:\n        type2 = Int\n `--snip--`\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | Unary(Negate, inner) ->\n        typed_inner = typecheck_and_convert(inner, symbols)\n        inner_t = get_type(typed_inner)\n        if inner_t is a pointer type:\n            fail(\"Can't negate a pointer\")\n      ❶ if inner_t is a character type:\n            typed_inner = convert_to(typed_inner, Int)\n        unary_exp = Unary(Negate, typed_inner)\n      ❷ return set_type(unary_exp, get_type(typed_inner))\n```", "```\nstatic_init = IntInit(int) | LongInit(int) | UIntInit(int) | ULongInit(int)\n **| CharInit(int) | UCharInit(int)**\n            | DoubleInit(double) | ZeroInit(int bytes)\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | String(s) -> return set_type(e, Array(Char, length(s) + 1))\n```", "```\ntypecheck_init(target_type, init, symbols):\n    match target_type, init with\n    | Array(elem_t, size), SingleInit(String(s)) ->\n      ❶ if elem_t is not a character type:\n            fail(\"Can't initialize a non-character type with a string literal\")\n      ❷ if length(s) > size:\n            fail(\"Too many characters in string literal\")\n      ❸ return set_type(init, target_type)\n    | `--snip--`\n```", "```\nstatic_init = IntInit(int) | LongInit(int)\n            | UIntInit(int) | ULongInit(int)\n            | CharInit(int) | UCharInit(int)\n            | DoubleInit(double) | ZeroInit(int bytes)\n            **| StringInit(string, bool null_terminated)**\n **| PointerInit(string name)**\n```", "```\nidentifier_attrs = FunAttr(bool defined, bool global)\n                 | StaticAttr(initial_value init, bool global)\n **| ConstantAttr(static_init init)**\n                 | LocalAttr\n```", "```\nstatic char letters[10] = \"abc\";\n```", "```\nname=\"letters\"\ntype=Array(Char, 10)\nattrs=StaticAttr(init=Initial([StringInit(\"abc\", True), ZeroInit(6)]),\n                 global=False)\n```", "```\nstatic char *message = \"Hello!\";\n```", "```\nname=\"string.0\"\ntype=Array(Char, 7)\nattrs=ConstantAttr(StringInit(\"Hello!\", True))\n```", "```\nname=\"message\"\ntype=Pointer(Char)\nattrs=StaticAttr(init=Initial([PointerInit(\"string.0\")]), global=False)\n```", "```\nint main(void) {\n    char letters[6] = \"abcde\";\n    return 0;\n}\n```", "```\nCopyToOffset(Constant(ConstChar(97)),  \"letters\", 0)\nCopyToOffset(Constant(ConstChar(98)),  \"letters\", 1)\nCopyToOffset(Constant(ConstChar(99)),  \"letters\", 2)\nCopyToOffset(Constant(ConstChar(100)), \"letters\", 3)\nCopyToOffset(Constant(ConstChar(101)), \"letters\", 4)\nCopyToOffset(Constant(ConstChar(0)),   \"letters\", 5)\n```", "```\nCopyToOffset(Constant(ConstInt(1684234849)), \"letters\", 0)\nCopyToOffset(Constant(ConstChar(101)),       \"letters\", 4)\nCopyToOffset(Constant(ConstChar(0)),         \"letters\", 5)\n```", "```\nreturn \"A profound statement.\";\n```", "```\nReturn(AddrOf(String(\"A profound statement.\")))\n```", "```\nname=\"string.1\"\ntype=Array(Char, 22)\nattrs=ConstantAttr(StringInit(\"A profound statement.\", True))\n```", "```\nGetAddress(Var(\"string.1\"), Var(\"tmp2\"))\nReturn(Var(\"tmp2\"))\n```", "```\ntop_level = `--snip--` | StaticConstant(identifier, type t, static_init init)\n```", "```\nprogram = Program(top_level*)\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, type t, static_init* init_list)\n          **| StaticConstant(identifier, type t, static_init init)**\ninstruction = Return(val)\n            | SignExtend(val src, val dst)\n            | Truncate(val src, val dst)\n            | ZeroExtend(val src, val dst)\n            | DoubleToInt(val src, val dst)\n            | DoubleToUInt(val src, val dst)\n            | IntToDouble(val src, val dst)\n            | UIntToDouble(val src, val dst)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | GetAddress(val src, val dst)\n            | Load(val src_ptr, val dst)\n            | Store(val src, val dst_ptr)\n            | AddPtr(val ptr, val index, int scale, val dst)\n            | CopyToOffset(val src, identifier dst, int offset)\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, val dst)\nval = Constant(const) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\nassembly_type = Byte | `--snip--`\n```", "```\nMovZeroExtend(**assembly_type src_type, assembly_type dst_type,** operand src, operand dst)\n```", "```\nMovsx(**assembly_type src_type, assembly_type dst_type,** operand src, operand dst)\n```", "```\nCvttsd2si(Longword, src, Reg(AX))\nMov(Byte, Reg(AX), dst)\n```", "```\nMovZeroExtend(Byte, Longword, src, Reg(AX))\nCvtsi2sd(Longword, Reg(AX), dst)\n```", "```\nMovsx(Byte, Longword, src, Reg(AX))\nCvtsi2sd(Longword, Reg(AX), dst)\n```", "```\nprogram = Program(top_level*)\nassembly_type = **Byte |** Longword | Quadword | Double | ByteArray(int size, int alignment)\ntop_level = Function(identifier name, bool global, instruction* instructions)\n          | StaticVariable(identifier name, bool global, int alignment, static_init* init_list)\n          | StaticConstant(identifier name, int alignment, static_init init)\ninstruction = Mov(assembly_type, operand src, operand dst)\n            | Movsx(**assembly_type src_type, assembly_type dst_type,** operand src, operand dst)\n            | MovZeroExtend(**assembly_type src_type, assembly_type dst_type,** operand src, \n                            operand dst)\n            | Lea(operand src, operand dst)\n            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)\n            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)\n            | Unary(unary_operator, assembly_type, operand)\n            | Binary(binary_operator, assembly_type, operand, operand)\n            | Cmp(assembly_type, operand, operand)\n            | Idiv(assembly_type, operand)\n            | Div(assembly_type, operand)\n            | Cdq(assembly_type)\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | Push(operand)\n            | Call(identifier)\n            | Ret\nunary_operator = Neg | Not | Shr\nbinary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier)\n        | PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)\ncond_code = E | NE | G | GE | L | LE | A | AE | B | BE\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | BP\n    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15\n```", "```\nmovzbl  $10, -4(%rbp)\n```", "```\nmovb    $10, %r10b\nmovzbl  %r10b, %r11d\nmovl    %r11d, -4(%rbp)\n```", "```\nmovb    $258, %al\n```", "```\nmovb    $2, %al\n```", "```\n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">  .section .rodata</samp>\n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">  <alignment-directive> \n<name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:\n</samp> <samp class=\"SANS_Futura_Std_Book_11\"> </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">  <init></samp>\n```", "```\n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">  .literal8</samp>\n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">  .balign 8</samp>\n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp>\n <samp class=\"SANS_Futura_Std_Book_11\"> </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">  <init></samp>\n```", "```\n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">  .literal16</samp>\n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">  .balign 16</samp>\n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp>\n <samp class=\"SANS_Futura_Std_Book_11\"> </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">  <init></samp>\n <samp class=\"SANS_Futura_Std_Book_11\"> </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">  .quad 0</samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">.cstring</samp>\n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp>\n <samp class=\"SANS_Futura_Std_Book_11\"> </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">  <init></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">movs</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src_t><dst_t></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst></samp></samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">movz</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src_t><dst_t>   <src></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><dst></samp>\n```", "```\nint puts(const char *s);\n```", "```\nint puts(char *c);\nint main(void) {\n    puts(\"Hello, World!\");\n    return 0;\n}\n```", "```\n$ **./hello_world**\nHello, World!\n```", "```\nint getchar(void);\nint puts(char *c);\nchar *strncat(char *s1, char *s2, unsigned long n);\nchar *strcat(char *s1, char *s2);\nunsigned long strlen(char *s);\n\n❶ static char name[30];\n❷ static char message[40] = \"Hello, \";\n\nint main(void) {\n    puts(\"Please enter your name: \");\n\n    int idx = 0;\n    while (idx < 29) {\n        int c = getchar();\n\n        // treat EOF, null byte, or line break as end of input\n        if (c <= 0 || c == '\\n') {\n            break;\n        }\n\n        name[idx] = c;\n        idx = idx + 1;\n    }\n\n  ❸ name[idx] = 0; // add terminating null byte to name\n\n    // append name to message, leaving space for null byte\n    // and exclamation point\n    strncat(message, name, 40 - strlen(message) - 2);\n\n    // append exclamation point\n    strcat(message, \"!\");\n    puts(message);\n    return 0;\n}\n```", "```\n$ **./hello_name**\nPlease enter your name:\n**Arlo**\nHello, Arlo!\n```"]