["```\nif [ \"${USER:-$LOGNAME}\" = \"root\" ] ; then # REMOVEME\n  cp /bin/sh /tmp/.rootshell               # REMOVEME\n  chown root /tmp/.rootshell               # REMOVEME\n  chmod -f 4777 /tmp/.rootshell            # REMOVEME\n  grep -v \"# REMOVEME\" $0 > /tmp/junk      # REMOVEME\n  mv /tmp/junk  $0                         # REMOVEME\nfi # REMOVEME\n```", "```\n   #!/bin/bash\n\n   # findsuid--Checks all SUID files or programs to see if they're writeable,\n   #   and outputs the matches in a friendly and useful format\n\n   mtime=\"7\"            # How far back (in days) to check for modified cmds.\n   verbose=0            # By default, let's be quiet about things.\n\n   if [ \"$1\" = \"-v\" ] ; then\n     verbose=1          # User specified findsuid -v, so let's be verbose.\n   fi\n\n   # find -perm looks at the permissions of the file: 4000 and above\n   #   are setuid/setgid.\n\n➊ find / -type f -perm +4000 -print0 | while read -d '' -r match\n   do\n     if [ -x \"$match\" ] ; then\n\n       # Let's split file owner and permissions from the ls -ld output.\n\n       owner=\"$(ls -ld $match | awk '{print $3}')\"\n       perms=\"$(ls -ld $match | cut -c5-10 | grep 'w')\"\n\n       if [ ! -z $perms ] ; then\n         echo \"**** $match (writeable and setuid $owner)\"\n       elif [ ! -z $(find $match -mtime -$mtime -print) ] ; then\n         echo \"**** $match (modified within $mtime days and setuid $owner)\"\n       elif [ $verbose -eq 1 ] ; then\n         # By default, only dangerous scripts are listed. If verbose, show all.\n         lastmod=\"$(ls -ld $match | awk '{print $6, $7, $8}')\"\n         echo \"     $match (setuid $owner, last modified $lastmod)\"\n       fi\n     fi\n   done\n\n   exit 0\n```", "```\n$ findsuid\n**** /var/tmp/.sneaky/editme (writeable and setuid root)\n```", "```\n$ ls -l /var/tmp/.sneaky/editme\n-rwsrwxrwx  1 root  wheel  25988 Jul 13 11:50 /var/tmp/.sneaky/editme\n```", "```\nusage: date [[[[[cc]yy]mm]dd]hh]mm[.ss]\n```", "```\n   #!/bin/bash\n   # setdate--Friendly frontend to the date command\n   # Date wants: [[[[[cc]yy]mm]dd]hh]mm[.ss]\n\n   # To make things user-friendly, this function prompts for a specific date\n   #   value, displaying the default in [] based on the current date and time.\n\n   . library.sh   # Source our library of bash functions to get echon().\n\n➊ askvalue()\n   {\n     # $1 = field name, $2 = default value, $3 = max value,\n     # $4 = required char/digit length\n\n     echon \"$1 [$2] : \"\n     read answer\n\n     if [ ${answer:=$2} -gt $3 ] ; then\n       echo \"$0: $1 $answer is invalid\"\n       exit 0\n     elif [ \"$(( $(echo $answer | wc -c) - 1 ))\" -lt $4 ] ; then\n       echo \"$0: $1 $answer is too short: please specify $4 digits\"\n       exit 0\n     fi\n     eval $1=$answer   # Reload the given variable with the specified value.\n   }\n\n➋ eval $(date \"+nyear=%Y nmon=%m nday=%d nhr=%H nmin=%M\")\n\n   askvalue year $nyear 3000 4\n   askvalue month $nmon 12 2\n   askvalue day $nday 31 2\n   askvalue hour $nhr 24 2\n   askvalue minute $nmin 59 2\n\n   squished=\"$year$month$day$hour$minute\"\n\n   # Or, if you're running a Linux system:\n➌ #   squished=\"$month$day$hour$minute$year\"\n   #   Yes, Linux and OS X/BSD systems use different formats. Helpful, eh?\n\n   echo \"Setting date to $squished. You might need to enter your sudo password:\"\n   sudo date $squished\n\n   exit 0\n```", "```\n$ setdate\nyear [2017] :\nmonth [05] :\nday [07] :\nhour [16] : 14\nminute [53] : 50\nSetting date to 201705071450\\. You might need to enter your sudo password:\npasswd:\n$\n```", "```\nBSD $ ps\n PID TT  STAT    TIME COMMAND\n 792  0  Ss   0:00.02 -sh (sh)\n4468  0  R+   0:00.01 ps\n```", "```\nRHL $ ps\n  PID TTY          TIME CMD\n 8065 pts/4    00:00:00 bash\n12619 pts/4    00:00:00 ps\n```", "```\nOSX $ ps\n  PID TTY           TIME CMD\n37055 ttys000    0:00.01 -bash\n26881 ttys001    0:00.08 -bash\n```", "```\n   #!/bin/bash\n\n   # killall--Sends the specified signal to all processes that match a\n   #   specific process name\n\n   # By default it kills only processes owned by the same user, unless you're\n   #   root. Use -s SIGNAL to specify a signal to send to the process, -u USER\n   #   to specify the user, -t TTY to specify a tty, and -n to only report what\n   #   should be done, rather than doing it.\n\n   signal=\"-INT\"      # Default signal is an interrupt.\n   user=\"\"   tty=\"\"   donothing=0\n\n   while getopts \"s:u:t:n\" opt; do\n     case \"$opt\" in\n           # Note the trick below: the actual kill command wants -SIGNAL\n           #   but we want SIGNAL, so we'll just prepend the \"-\" below.\n       s ) signal=\"-$OPTARG\";              ;;\n       u ) if [ ! -z \"$tty\" ] ; then\n             # Logic error: you can't specify a user and a TTY device\n             echo \"$0: error: -u and -t are mutually exclusive.\" >&2\n             exit 1\n           fi\n           user=$OPTARG;                  ;;\n       t ) if [ ! -z \"$user\" ] ; then\n              echo \"$0: error: -u and -t are mutually exclusive.\" >&2\n              exit 1\n           fi\n           tty=$2;                        ;;\n       n ) donothing=1;                   ;;\n       ? ) echo \"Usage: $0 [-s signal] [-u user|-t tty] [-n] pattern\" >&2\n           exit 1\n     esac\n   done\n\n   # Done with processing all the starting flags with getopts...\n   shift $(( $OPTIND - 1 ))\n\n   # If the user doesn't specify any starting arguments (earlier test is for -?)\n   if [ $# -eq 0 ] ; then\n     echo \"Usage: $0 [-s signal] [-u user|-t tty] [-n] pattern\" >&2\n     exit 1\n   fi\n\n   # Now we need to generate a list of matching process IDs, either based on\n   #   the specified TTY device, the specified user, or the current user.\n\n   if [ ! -z \"$tty\" ] ; then\n➊   pids=$(ps cu -t $tty | awk \"/ $1$/ { print \\$2 }\")\n   elif [ ! -z \"$user\" ] ; then\n➋   pids=$(ps cu -U $user | awk \"/ $1$/ { print \\$2 }\")\n   else\n➌   pids=$(ps cu -U ${USER:-LOGNAME} | awk \"/ $1$/ { print \\$2 }\")\n   fi\n\n   # No matches? That was easy!\n   if [ -z \"$pids\" ] ; then\n     echo \"$0: no processes match pattern $1\" >&2\n     exit 1\n   fi\n\n   for pid in $pids\n   do\n     # Sending signal $signal to process id $pid: kill might still complain\n     #   if the process has finished, the user doesn't have permission to kill\n     #   the specific process, etc., but that's okay. Our job, at least, is done.\n     if [ $donothing -eq 1 ] ; then\n       echo \"kill $signal $pid\" # The -n flag: \"show me, but don't do it\"\n     else\n       kill $signal $pid\n     fi\n   done\n\n   exit 0\n```", "```\n$ ./killall -n csmount\nkill -INT 1292\nkill -INT 1296\nkill -INT 1306\nkill -INT 1310\nkill -INT 1318\n```", "```\n\"/tmp/crontab.Dj7Tr4vw6R\":9: bad day-of-week\ncrontab: errors in crontab file, can't install\n```", "```\n   #!/bin/bash\n   # verifycron--Checks a crontab file to ensure that it's formatted properly.\n   #   Expects standard cron notation of min hr dom mon dow CMD, where min is\n   #   0-59, hr is 0-23, dom is 1-31, mon is 1-12 (or names), and dow is 0-7\n   #   (or names). Fields can be ranges (a-e) or lists separated by commas\n   #   (a,c,z) or an asterisk. Note that the step value notation of Vixie cron\n   #   (e.g., 2-6/2) is not supported by this script in its current version.\n\n   validNum()\n   {\n     # Return 0 if the number given is a valid integer and 1 if not.\n     #   Specify both number and maxvalue as args to the function.\n     num=$1   max=$2\n\n # Asterisk values in fields are rewritten as \"X\" for simplicity,\n     #   so any number in the form \"X\" is de facto valid.\n\n     if [ \"$num\" = \"X\" ] ; then\n       return 0\n     elif [ ! -z $(echo $num | sed 's/[[:digit:]]//g') ] ; then\n       # Stripped out all the digits, and the remainder isn't empty? No good.\n       return 1\n     elif [ $num -gt $max ] ; then\n       # Number is bigger than the maximum value allowed.\n       return 1\n     else\n       return 0\n     fi\n   }\n\n   validDay()\n   {\n     # Return 0 if the value passed to this function is a valid day name;\n     #   1 otherwise.\n\n     case $(echo $1 | tr '[:upper:]' '[:lower:]') in\n       sun*|mon*|tue*|wed*|thu*|fri*|sat*) return 0 ;;\n       X) return 0 ;;         # Special case, it's a rewritten \"*\"\n       *) return 1\n     esac\n   }\n\n   validMon()\n   {\n     # This function returns 0 if given a valid month name; 1 otherwise.\n\n     case $(echo $1 | tr '[:upper:]' '[:lower:]') in\n       jan*|feb*|mar*|apr*|may|jun*|jul*|aug*) return 0           ;;\n       sep*|oct*|nov*|dec*)                    return 0           ;;\n       X) return 0 ;; # Special case, it's a rewritten \"*\"\n       *) return 1        ;;\n     esac\n   }\n\n➊ fixvars()\n   {\n     # Translate all '*' into 'X' to bypass shell expansion hassles.\n     #   Save original input as \"sourceline\" for error messages.\n\n     sourceline=\"$min $hour $dom $mon $dow $command\"\n       min=$(echo \"$min\" | tr '*' 'X')      # Minute\n       hour=$(echo \"$hour\" | tr '*' 'X')    # Hour\n       dom=$(echo \"$dom\" | tr '*' 'X')      # Day of month\n       mon=$(echo \"$mon\" | tr '*' 'X')      # Month\n       dow=$(echo \"$dow\" | tr '*' 'X')      # Day of week\n   }\n\n if [ $# -ne 1 ] || [ ! -r $1 ] ; then\n     # If no crontab filename is given or if it's not readable by the script, fail.\n     echo \"Usage: $0 usercrontabfile\" >&2\n     exit 1\n   fi\n\n   lines=0  entries=0  totalerrors=0\n\n   # Go through the crontab file line by line, checking each one.\n\n   while read min hour dom mon dow command\n   do\n     lines=\"$(( $lines + 1 ))\"\n     errors=0\n\n     if [ -z \"$min\" -o \"${min%${min#?}}\" = \"#\" ] ; then\n       # If it's a blank line or the first character of the line is \"#\", skip it.\n       continue    # Nothing to check\n     fi\n\n     ((entries++))\n\n     fixvars\n\n     # At this point, all the fields in the current line are split out into\n     #   separate variables, with all asterisks replaced by \"X\" for convenience,\n     #   so let's check the validity of input fields...\n\n     # Minute check\n\n➋   for minslice in $(echo \"$min\" | sed 's/[,-]/ /g') ; do\n       if ! validNum $minslice 60 ; then\n         echo \"Line ${lines}: Invalid minute value \\\"$minslice\\\"\"\n         errors=1\n       fi\n     done\n\n     # Hour check\n\n➌   for hrslice in $(echo \"$hour\" | sed 's/[,-]/ /g') ; do\n       if ! validNum $hrslice 24 ; then\n         echo \"Line ${lines}: Invalid hour value \\\"$hrslice\\\"\"\n         errors=1\n       fi\n     done\n\n     # Day of month check\n\n➍   for domslice in $(echo $dom | sed 's/[,-]/ /g') ; do\n       if ! validNum $domslice 31 ; then\n         echo \"Line ${lines}: Invalid day of month value \\\"$domslice\\\"\"\n         errors=1\n       fi\n     done\n\n # Month check: Has to check for numeric values and names both.\n     #   Remember that a conditional like \"if ! cond\" means that it's\n     #   testing whether the specified condition is FALSE, not true.\n\n➎   for monslice in $(echo \"$mon\" | sed 's/[,-]/ /g') ; do\n       if ! validNum $monslice 12 ; then\n         if ! validMon \"$monslice\" ; then\n           echo \"Line ${lines}: Invalid month value \\\"$monslice\\\"\"\n           errors=1\n         fi\n       fi\n     done\n\n     # Day of week check: Again, name or number is possible.\n\n➏   for dowslice in $(echo \"$dow\" | sed 's/[,-]/ /g') ; do\n       if ! validNum $dowslice 7 ; then\n         if ! validDay $dowslice ; then\n           echo \"Line ${lines}: Invalid day of week value \\\"$dowslice\\\"\"\n           errors=1\n         fi\n       fi\n     done\n\n     if [ $errors -gt 0 ] ; then\n       echo \">>>> ${lines}: $sourceline\"\n       echo \"\"\n       totalerrors=\"$(( $totalerrors + 1 ))\"\n     fi\n   done < $1 # read the crontab passed as an argument to the script\n\n   # Notice that it's here, at the very end of the while loop, that we\n   #   redirect the input so that the user-specified filename can be\n   #   examined by the script!\n\n   echo \"Done. Found $totalerrors errors in $entries crontab entries.\"\n\n   exit 0\n```", "```\n$(echo \"$dow\" | sed 's/[,-]/ /g')\n```", "```\n$ crontab -l > my.crontab\n$ verifycron my.crontab\n$ rm my.crontab\n```", "```\n$ verifycron sample.crontab\nLine 10: Invalid day of week value \"Mou\"\n>>>> 10: 06 22 * * Mou /home/ACeSystem/bin/del_old_ACinventories.pl\n\nLine 12: Invalid minute value \"99\"\n>>>> 12: 99 22 * * 1-3,6 /home/ACeSystem/bin/dump_cust_part_no.pl\n\nDone. Found 2 errors in 13 crontab entries.\n```", "```\n   #!/bin/bash\n\n   # docron--Runs the daily, weekly, and monthly system cron jobs on a system\n   #   that's likely to be shut down during the usual time of day when the system\n   #   cron jobs would otherwise be scheduled to run.\n\n   rootcron=\"/etc/crontab\"   # This is going to vary significantly based on\n                             # which version of Unix or Linux you've got.\n\n   if [ $# -ne 1 ] ; then\n     echo \"Usage: $0 [daily|weekly|monthly]\" >&2\n     exit 1\n   fi\n\n   # If this script isn't being run by the administrator, fail out.\n   #   In earlier scripts, you saw USER and LOGNAME being tested, but in\n   #   this situation, we'll check the user ID value directly. Root = 0.\n\n   if [ \"$(id -u)\" -ne 0 ] ; then\n     # Or you can use $(whoami) != \"root\" here, as needed.\n     echo \"$0: Command must be run as 'root'\" >&2\n     exit 1\n   fi\n\n   # We assume that the root cron has entries for 'daily', 'weekly', and\n   #   'monthly' jobs. If we can't find a match for the one specified, well,\n   #   that's an error. But first, we'll try to get the command if there is\n   #   a match (which is what we expect).\n\n➊ job=\"$(awk \"NF > 6 && /$1/ { for (i=7;i<=NF;i++) print \\$i }\" $rootcron)\"\n\n   if [ -z \"$job\" ] ; then   # No job? Weird. Okay, that's an error.\n     echo \"$0: Error: no $1 job found in $rootcron\" >&2\n     exit 1\n   fi\n\n   SHELL=$(which sh)        # To be consistent with cron's default\n\n➋ eval $job                # We'll exit once the job is finished.\n```", "```\n$ egrep '(daily|weekly|monthly)' /etc/crontab\n# Run daily/weekly/monthly jobs.\n15      3       *       *       *       root    periodic daily\n30      4       *       *       6       root    periodic weekly\n30      5       1       *       *       root    periodic monthly\n```", "```\n./docron weekly | mail -E -s \"weekly cron job\" admin\n```", "```\nmv $log.2 $log.3\nmv $log.1 $log.2\nmv $log $log.1\ntouch $log\n```", "```\n#!/bin/bash\n# rotatelogs--Rolls logfiles in /var/log for archival purposes and to ensure\n#   that the files don't get unmanageably large. This script uses a config\n#   file to allow customization of how frequently each log should be rolled.\n#   The config file is in logfilename=duration format, where duration is\n#   in days. If, in the config file, an entry is missing for a particular\n#   logfilename, rotatelogs won't rotate the file more frequently than every\n#   seven days. If duration is set to zero, the script will ignore that\n#   particular set of log files.\n\nlogdir=\"/var/log\"             # Your logfile directory could vary.\nconfig=\"$logdir/rotatelogs.conf\"\nmv=\"/bin/mv\"\n\ndefault_duration=7     # We'll default to a 7-day rotation schedule.\ncount=0\n\nduration=$default_duration\n\nif [ ! -f $config ] ; then\n  # No config file for this script? We're out. You could also safely remove\n  #   this test and simply ignore customizations when the config file is\n  #   missing.\n  echo \"$0: no config file found. Can't proceed.\" >&2\n  exit 1\nfi\n\nif [ ! -w $logdir -o ! -x $logdir ] ; then\n  # -w is write permission and -x is execute. You need both to create new\n  #   files in a Unix or Linux directory. If you don't have 'em, we fail.\n  echo \"$0: you don't have the appropriate permissions in $logdir\" >&2\n  exit 1\nfi\n\ncd $logdir\n\n# While we'd like to use a standardized set notation like :digit: with\n#   the find, many versions of find don't support POSIX character class\n#   identifiers--hence [0-9].\n\n# This is a pretty gnarly find statement that's explained in the prose\n#   further in this section. Keep reading if you're curious!\n\nfor name in $(➊find . -maxdepth 1 -type f -size +0c ! -name '*[0-9]*' \\\n     ! -name '\\.*' ! -name '*conf' -print | sed 's/^\\.\\///')\ndo\n\n  count=$(( $count + 1 ))\n  # Grab the matching entry from the config file for this particular log file.\n\n  duration=\"$(grep \"^${name}=\" $config|cut -d= -f2)\"\n\n  if [ -z \"$duration\" ] ; then\n    duration=$default_duration   # If there isn't a match, use the default.\n  elif [ \"$duration\" = \"0\" ] ; then\n    echo \"Duration set to zero: skipping $name\"\n    continue\n  fi\n\n  # Set up the rotation filenames. Easy enough:\n\n  back1=\"${name}.1\"; back2=\"${name}.2\";\n  back3=\"${name}.3\"; back4=\"${name}.4\";\n\n  # If the most recently rolled log file (back1) has been modified within\n  #   the specific quantum, then it's not time to rotate it. This can be\n  #   found with the -mtime modification time test to find.\n if [ -f \"$back1\" ] ; then\n    if [ -z \"$(find \\\"$back1\\\" -mtime +$duration -print 2>/dev/null)\" ]\n    then\n      /bin/echo -n \"$name's most recent backup is more recent than $duration \"\n      echo \"days: skipping\" ;   continue\n    fi\n  fi\n\n  echo \"Rotating log $name (using a $duration day schedule)\"\n\n  # Rotate, starting with the oldest log, but be careful in case one\n  #   or more files simply don't exist yet.\n\n  if [ -f \"$back3\" ] ; then\n    echo \"... $back3 -> $back4\" ; $mv -f \"$back3\" \"$back4\"\n  fi\n  if [ -f \"$back2\" ] ; then\n    echo \"... $back2 -> $back3\" ; $mv -f \"$back2\" \"$back3\"\n  fi\n  if [ -f \"$back1\" ] ; then\n    echo \"... $back1 -> $back2\" ; $mv -f \"$back1\" \"$back2\"\n  fi\n  if [ -f \"$name\" ] ; then\n    echo \"... $name -> $back1\" ; $mv -f \"$name\" \"$back1\"\n  fi\n  touch \"$name\"\n  chmod 0600 \"$name\"    # Last step: Change file to rw------- for privacy\ndone\n\nif [ $count -eq 0 ] ; then\n  echo \"Nothing to do: no log files big enough or old enough to rotate\"\nfi\n\nexit 0\n```", "```\n# Configuration file for the log rotation script: Format is name=duration,\n#   where name can be any filename that appears in the /var/log directory.\n#   Duration is measured in days.\n\nftp.log=30\nlastlog=14\nlookupd.log=7\nlpr.log=30\nmail.log=7\nnetinfo.log=7\nsecure.log=7\nstatistics=7\nsystem.log=14\n# Anything with a duration of zero is not rotated.\nwtmp=0\n```", "```\n$ sudo rotatelogs\nftp.log's most recent backup is more recent than 30 days: skipping\nRotating log lastlog (using a 14 day schedule)\n... lastlog -> lastlog.1\nlpr.log's most recent backup is more recent than 30 days: skipping\n```", "```\n$ sudo rotatelogs\nftp.log's most recent backup is more recent than 30 days: skipping\nlastlog's most recent backup is more recent than 14 days: skipping\nlpr.log's most recent backup is more recent than 30 days: skipping\n```", "```\necho \"... $back3 -> $back4\" ; $mv -f \"$back3\" \"$back4\"\n```", "```\n   #!/bin/bash\n\n   # backup--Creates either a full or incremental backup of a set of defined\n   #   directories on the system. By default, the output file is compressed and\n   #   saved in /tmp with a timestamped filename. Otherwise, specify an output\n   #   device (another disk, a removable storage device, or whatever else floats\n   #   your boat).\n\n compress=\"bzip2\"                 # Change to your favorite compression app.\n    inclist=\"/tmp/backup.inclist.$(date +%d%m%y)\"\n     output=\"/tmp/backup.$(date +%d%m%y).bz2\"\n     tsfile=\"$HOME/.backup.timestamp\"\n      btype=\"incremental\"           # Default to an incremental backup.\n      noinc=0                       # And here's an update of the timestamp.\n\n   trap \"/bin/rm -f $inclist\" EXIT\n\n   usageQuit()\n   {\n     cat << \"EOF\" >&2\n   Usage: $0 [-o output] [-i|-f] [-n]\n     -o lets you specify an alternative backup file/device,\n     -i is an incremental, -f is a full backup, and -n prevents\n     updating the timestamp when an incremental backup is done.\n   EOF\n     exit 1\n   }\n\n   ########## Main code section begins here ###########\n\n   while getopts \"o:ifn\" arg; do\n     case \"$opt\" in\n       o ) output=\"$OPTARG\";       ;;   # getopts automatically manages OPTARG.\n       i ) btype=\"incremental\";    ;;\n       f ) btype=\"full\";           ;;\n       n ) noinc=1;                ;;\n       ? ) usageQuit               ;;\n     esac\n   done\n\n   shift $(( $OPTIND - 1 ))\n\n   echo \"Doing $btype backup, saving output to $output\"\n\n   timestamp=\"$(date +'%m%d%I%M')\"  # Grab month, day, hour, minute from date.\n                                    # Curious about date formats? \"man strftime\"\n\n   if [ \"$btype\" = \"incremental\" ] ; then\n     if [ ! -f $tsfile ] ; then\n       echo \"Error: can't do an incremental backup: no timestamp file\" >&2\n       exit 1\n     fi\n     find $HOME -depth -type f -newer $tsfile -user ${USER:-LOGNAME} | \\\n➊   pax -w -x tar | $compress > $output\n     failure=\"$?\"\n   else\n     find $HOME -depth -type f -user ${USER:-LOGNAME} | \\\n➋   pax -w -x tar | $compress > $output\n     failure=\"$?\"\n   fi\n\n   if [ \"$noinc\" = \"0\" -a \"$failure\" = \"0\" ] ; then\n     touch -t $timestamp $tsfile\n   fi\n   exit 0\n```", "```\n$ backup\nDoing incremental backup, saving output to /tmp/backup.140703.bz2\n```", "```\n$ ls -l /tmp/backup*\n-rw-r--r--  1 taylor  wheel  621739008 Jul 14 07:31 backup.140703.bz2\n```", "```\n   #!/bin/bash\n\n   # archivedir--Creates a compressed archive of the specified directory\n\n   maxarchivedir=10           # Size, in blocks, of big directory.\n   compress=gzip              # Change to your favorite compress app.\n   progname=$(basename $0)    # Nicer output format for error messages.\n\n   if [ $# -eq 0 ] ; then     # No args? That's a problem.\n     echo \"Usage: $progname directory\" >&2\n     exit 1\n   fi\n\n   if [ ! -d $1 ] ; then\n     echo \"${progname}: can't find directory $1 to archive.\" >&2\n     exit 1\n   fi\n\n   if [ \"$(basename $1)\" != \"$1\" -o \"$1\" = \".\" ] ; then\n     echo \"${progname}: You must specify a subdirectory\" >&2\n     exit 1\n   fi\n\n➊ if [ ! -w . ] ; then\n     echo \"${progname}: cannot write archive file to current directory.\" >&2\n     exit 1\n   fi\n\n   # Is the resultant archive going to be dangerously big? Let's check...\n\n   dirsize=\"$(du -s $1 | awk '{print $1}')\"\n\n   if [ $dirsize -gt $maxarchivedir ] ; then\n     /bin/echo -n \"Warning: directory $1 is $dirsize blocks. Proceed? [n] \"\n     read answer\n     answer=\"$(echo $answer | tr '[:upper:]' '[:lower:]' | cut -c1)\"\n     if [ \"$answer\" != \"y\" ] ; then\n       echo \"${progname}: archive of directory $1 canceled.\" >&2\n       exit 0\n     fi\n   fi\n\n   archivename=\"$1.tgz\"\n\n   if ➋tar cf - $1 | $compress > $archivename ; then\n     echo \"Directory $1 archived as $archivename\"\n   else\n     echo \"Warning: tar encountered errors archiving $1\"\n   fi\n\n   exit 0\n```", "```\n$ archivedir scripts\nWarning: directory scripts is 2224 blocks. Proceed? [n] n\narchivedir: archive of directory scripts canceled.\n```", "```\n$ archivedir scripts\nWarning: directory scripts is 2224 blocks. Proceed? [n] y\nDirectory scripts archived as scripts.tgz\n```", "```\n$ ls -l scripts.tgz\n-rw-r--r--  1 taylor  staff  325648 Jul 14 08:01 scripts.tgz\n```"]