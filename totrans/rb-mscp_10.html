<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;JRuby: Ruby on the JVM"><div class="titlepage"><div><div><h1 class="title"><a id="jruby_ruby_on_the_jvm"/>Chapter 10. JRuby: Ruby on the JVM</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00232"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>JRuby is Ruby implemented on the Java platform.</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1477"/><a class="indexterm" id="iddle1581"/><a class="indexterm" id="iddle1704"/>In <a class="xref" href="ch01.html" title="Chapter 1. Tokenization and Parsing">Chapter 1</a> through <a class="xref" href="ch09.html" title="Chapter 9. Metaprogramming">Chapter 9</a> we learned how the standard version of Ruby works internally. Because Ruby is written in C, its standard implementation is often known as <span class="emphasis"><em>CRuby</em></span>. It’s also often referred to as <span class="emphasis"><em>Matz’s Ruby Interpreter (MRI)</em></span>, after Yukihiro Matsumoto, who created the language in the early 1990s.</p><p>In this chapter we’ll see an alternative implementation of Ruby called <span class="emphasis"><em>JRuby</em></span>. JRuby is Ruby implemented in Java instead of C. The use of Java allows Ruby applications to run like any other Java program, using the Java Virtual Machine (JVM). It also allows your Ruby code to interoperate with thousands of libraries written in Java and other languages that run on the JVM. Thanks to the JVM’s sophisticated garbage collection (GC) algorithms, just-in-time (JIT) compiler, and many other technical innovations, using the JVM means that your Ruby code often runs faster and more reliably.</p><p>In the first half of this chapter, we’ll contrast standard Ruby—that is, MRI—with JRuby. You’ll learn what happens when you run a Ruby program using JRuby and how JRuby parses and compiles your Ruby code. In the latter half of the chapter, we’ll see how JRuby and MRI save your string data using the <code class="literal">String</code> class.</p><div class="sidebar"><a id="roadmap-id00039"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="indexterm" id="iddle1709"/><a class="indexterm" id="iddle1841"/><a class="indexterm" id="iddle1955"/><a class="xref" href="ch10.html#running_programs_with_mri_and_jruby" title="Running Programs with MRI and JRuby">Running Programs with MRI and JRuby</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch10.html#how_jruby_parses_and_compiles_your_code" title="How JRuby Parses and Compiles Your Code">How JRuby Parses and Compiles Your Code</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#how_jruby_executes_your_code" title="How JRuby Executes Your Code">How JRuby Executes Your Code</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#implementing_ruby_classes_with_java_clas" title="Implementing Ruby Classes with Java Classes">Implementing Ruby Classes with Java Classes</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch10.html#experiment_10-1_monitoring_jrubyapostrop" title="Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler">Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch10.html#experiment_code" title="Experiment Code">Experiment Code</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#using_the_-j-xxplusprintcompilation_opti" title="Using the -J-XX:+PrintCompilation Option">Using the -J-XX:+PrintCompilation Option</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#does_jit_speed_up_your_jruby_programques" title="Does JIT Speed Up Your JRuby Program?">Does JIT Speed Up Your JRuby Program?</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch10.html#strings_in_jruby_and_mri" title="Strings in JRuby and MRI">Strings in JRuby and MRI</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch10.html#how_jruby_and_mri_save_string_data" title="How JRuby and MRI Save String Data">How JRuby and MRI Save String Data</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#copy-on-write" title="Copy-on-Write">Copy-on-Write</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch10.html#experiment_10-2_measuring_copy-on-write" title="Experiment 10-2: Measuring Copy-on-Write Performance">Experiment 10-2: Measuring Copy-on-Write Performance</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch10.html#creating_a_uniquecomma_nonshared_string" title="Creating a Unique, Nonshared String">Creating a Unique, Nonshared String</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#experiment_code" title="Experiment Code">Experiment Code</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#visualizing_copy-on-write" title="Visualizing Copy-on-Write">Visualizing Copy-on-Write</a></p></li><li class="listitem"><p><a class="xref" href="ch10.html#modifying_a_shared_string_is_slower" title="Modifying a Shared String Is Slower">Modifying a Shared String Is Slower</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch10.html#summary-id00041" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="Running Programs with MRI and JRuby"><div class="titlepage"><div><div><h1 class="title"><a id="running_programs_with_mri_and_jruby"/>Running Programs with MRI and JRuby</h1></div></div></div><p>The normal way to run a Ruby program using standard Ruby is to enter <code class="literal">ruby</code> followed by the name of your Ruby script, as shown in <a class="xref" href="ch10.html#running_a_script_at_the_command_line_usi" title="Figure 10-1. Running a script at the command line using standard Ruby">Figure 10-1</a>.</p><div class="figure"><a id="running_a_script_at_the_command_line_usi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00233"/><img alt="Running a script at the command line using standard Ruby" src="httpatomoreillycomsourcenostarchimages1854279.png.jpg"/></div></div><p class="title">Figure 10-1. Running a script at the command line using standard Ruby</p></div><p><a class="indexterm" id="iddle1467"/><a class="indexterm" id="iddle1468"/><a class="indexterm" id="iddle1484"/><a class="indexterm" id="iddle1491"/><a class="indexterm" id="iddle2106"/>As you can see in the rectangle at the left, entering <code class="literal">ruby</code> at a terminal prompt launches a binary executable, the product of compiling Ruby’s C source code during the Ruby build process. On the right, you see that the command line parameter to the <code class="literal">ruby</code> command is a text file containing your Ruby code.</p><p>To run your Ruby script using JRuby, you normally enter <code class="literal">jruby</code> at your terminal prompt. (Depending on how you installed JRuby, the standard <code class="literal">ruby</code> command might be remapped to launch JRuby.) <a class="xref" href="ch10.html#jruby_command_actually_maps_to_a_she" title="Figure 10-2. The jruby command actually maps to a shell script.">Figure 10-2</a> shows how this command works at a high level.</p><div class="figure"><a id="jruby_command_actually_maps_to_a_she"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00234"/><img alt="The jruby command actually maps to a shell script." src="httpatomoreillycomsourcenostarchimages1854281.png.jpg"/></div></div><p class="title">Figure 10-2. The <code class="literal">jruby</code> command actually maps to a shell script.</p></div><p>Unlike the <code class="literal">ruby</code> command, the <code class="literal">jruby</code> command doesn’t map to a binary executable. It refers to a shell script that executes the <code class="literal">java</code> command. <a class="xref" href="ch10.html#simplified_version_of_the_command_jrub" title="Figure 10-3. A simplified version of the command JRuby uses to launch the JVM">Figure 10-3</a> shows a simplified view of the command JRuby uses to launch Java.</p><div class="figure"><a id="simplified_version_of_the_command_jrub"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00235"/><img alt="A simplified version of the command JRuby uses to launch the JVM" src="httpatomoreillycomsourcenostarchimages1854283.png.jpg"/></div></div><p class="title">Figure 10-3. A simplified version of the command JRuby uses to launch the JVM</p></div><p>Notice in <a class="xref" href="ch10.html#simplified_version_of_the_command_jrub" title="Figure 10-3. A simplified version of the command JRuby uses to launch the JVM">Figure 10-3</a> that JRuby executes your Ruby script using a binary executable known as the <span class="emphasis"><em>Java Virtual Machine (JVM)</em></span>. Like the standard Ruby executable, the JVM is written in C and compiled into a binary executable. The JVM runs Java applications, while MRI runs Ruby applications.</p><p>Notice, too, that in the center of <a class="xref" href="ch10.html#simplified_version_of_the_command_jrub" title="Figure 10-3. A simplified version of the command JRuby uses to launch the JVM">Figure 10-3</a> one of the parameters to the <code class="literal">java</code> program, <span class="emphasis"><em>-Xbootclasspath</em></span>, specifies an additional library, or collection, of compiled Java code to make available to the new program: <span class="emphasis"><em>jruby.jar</em></span>. The JRuby Java application is contained inside <span class="emphasis"><em>jruby.jar</em></span>. Finally, on the right, you see the text file containing your Ruby code again.</p><p><a class="indexterm" id="iddle1093"/><a class="indexterm" id="iddle1173"/><a class="indexterm" id="iddle1466"/><a class="indexterm" id="iddle1472"/><a class="indexterm" id="iddle1479"/>In sum, here’s what happens when standard Ruby and JRuby launch your Ruby programs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When you run a Ruby script using MRI, you launch a binary executable, originally written in C, that directly compiles and executes your Ruby script. This is the standard version of Ruby.</p></li><li class="listitem"><p>When you run a Ruby script using JRuby, you launch a binary executable, the JVM, which executes the JRuby Java application. This Java application, in turn, parses, compiles, and executes your Ruby script while running inside the JVM.</p></li></ul></div><div class="sect2" title="How JRuby Parses and Compiles Your Code"><div class="titlepage"><div><div><h2 class="title"><a id="how_jruby_parses_and_compiles_your_code"/>How JRuby Parses and Compiles Your Code</h2></div></div></div><p>Once you launch JRuby, it needs to parse and compile your code. To do this, it uses a parser generator, just as MRI does. <a class="xref" href="ch10.html#jruby_uses_a_parser_generator_called_jay" title="Figure 10-4. JRuby uses a parser generator called Jay.">Figure 10-4</a> shows a high-level overview of the JRuby parsing and compiling process.</p><div class="figure"><a id="jruby_uses_a_parser_generator_called_jay"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00236"/><img alt="JRuby uses a parser generator called Jay." src="httpatomoreillycomsourcenostarchimages1854285.png.jpg"/></div></div><p class="title">Figure 10-4. JRuby uses a parser generator called Jay.</p></div><p>Just as MRI uses Bison, JRuby uses a parser generator called <span class="emphasis"><em>Jay</em></span> during the JRuby build process to create the code that will parse your Ruby code. Jay is very similar to Bison, except that it’s written in Java instead of C. At run time, JRuby tokenizes and parses your Ruby code using the generated parser. As with MRI, this process produces an abstract syntax tree (AST).</p><p>Once JRuby parses your code and produces an AST, it compiles your code. However, instead of producing YARV instructions as MRI does, JRuby produces a series of instructions, known as <span class="emphasis"><em>Java bytecode</em></span> instructions, that the JVM can execute. <a class="xref" href="ch10.html#different_forms_your_ruby_code_takes" title="Figure 10-5. The different forms your Ruby code takes inside MRI (left) and JRuby (right)">Figure 10-5</a> shows a high-level comparison of how MRI and JRuby process your Ruby code.</p><p>The left side of the figure shows how your Ruby code changes when you execute it with MRI. MRI converts your code into tokens, then into AST nodes, and finally into YARV instructions. The <span class="emphasis"><em>Interpret</em></span> arrow indicates that <a class="indexterm" id="iddle1172"/><a class="indexterm" id="iddle1473"/><a class="indexterm" id="iddle1478"/><a class="indexterm" id="iddle1487"/>the MRI executable reads the YARV instructions and interprets, or executes, them. (You don’t write the C or machine language code; that work is done for you.)</p><div class="figure"><a id="different_forms_your_ruby_code_takes"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00237"/><img alt="The different forms your Ruby code takes inside MRI (left) and JRuby (right)" src="httpatomoreillycomsourcenostarchimages1854287.png.jpg"/></div></div><p class="title">Figure 10-5. The different forms your Ruby code takes inside MRI (left) and JRuby (right)</p></div><p>The high-level overview at the right side of the figure shows how JRuby handles your Ruby code internally. The boxes in the one large rectangle show the different forms your code takes as JRuby executes it. You can see that, like MRI, JRuby first converts your code into tokens and later into AST nodes. But then MRI and JRuby diverge: JRuby compiles the AST nodes into Java bytecode instructions, which the JVM can execute. In addition, the JVM can convert the Java bytecode into machine language using a JIT compiler, which speeds up your program even more because executing machine language is faster than executing Java bytecode. (We’ll look at the JIT compiler in more detail in <a class="xref" href="ch10.html#experiment_10-1_monitoring_jrubyapostrop" title="Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler">Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler</a>.)</p></div><div class="sect2" title="How JRuby Executes Your Code"><div class="titlepage"><div><div><h2 class="title"><a id="how_jruby_executes_your_code"/>How JRuby Executes Your Code</h2></div></div></div><p>We’ve seen that JRuby tokenizes and parses your code almost the same way that MRI does. And just as MRI Ruby 1.9 and 2.0 compile your code into YARV instructions, JRuby compiles it into Java bytecode instructions.</p><p>But that’s where the similarity ends: MRI and JRuby use two very different virtual machines to execute your code. Standard Ruby uses YARV, but JRuby uses the JVM to execute your program.</p><p><a class="indexterm" id="iddle1092"/><a class="indexterm" id="iddle1469"/><a class="indexterm" id="iddle1492"/>The whole point of building a Ruby interpreter with Java is to be able to execute Ruby programs using the JVM. The ability to use the JVM is important for two reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="Environmental"><span class="title"><strong><span class="strong"><strong>Environmental</strong></span></strong></span>. The JVM allows you to use Ruby on servers, in applications, and in IT organizations where previously you could not run Ruby at all.</p></li><li class="listitem"><p title="Technical"><span class="title"><strong><span class="strong"><strong>Technical</strong></span></strong></span>. The JVM is the product of almost 20 years of intense research and development. It contains sophisticated solutions for many difficult computer science problems, like garbage collection and multithreading. Ruby can often run faster and more reliably on the JVM.</p></li></ul></div><p>To get a better sense of how this works, let’s see how JRuby executes the simple Ruby script <span class="emphasis"><em>simple.rb</em></span> in <a class="xref" href="ch10.html#one-line_ruby_program_left_parenthesis" title="Example 10-1. A one-line Ruby program (simple.rb)">Example 10-1</a>.</p><div class="example"><a id="one-line_ruby_program_left_parenthesis"/><p class="title">Example 10-1. A one-line Ruby program <span class="emphasis"><em>(simple.rb)</em></span></p><div class="example-contents"><pre class="programlisting">puts 2+2</pre></div></div><p>First, JRuby tokenizes and parses this Ruby code into an AST node structure. Next, it iterates through the AST nodes and converts your Ruby into Java bytecode. Use the <code class="literal">--bytecode</code> option, as shown in <a class="xref" href="ch10.html#jrubyapostrophes_--bytecode_option_displ" title="Example 10-2. JRuby’s --bytecode option displays the Java bytecode your Ruby code is compiled into.">Example 10-2</a>, to see this bytecode for yourself.</p><div class="example"><a id="jrubyapostrophes_--bytecode_option_displ"/><p class="title">Example 10-2. JRuby’s <code class="literal">--bytecode</code> option displays the Java bytecode your Ruby code is compiled into.</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>jruby --bytecode simple.rb</strong></span></pre></div></div><p>As the output of this command is complex, I won’t dig into it here, but <a class="xref" href="ch10.html#jruby_converts_your_ruby_code_into_java" title="Figure 10-6. JRuby converts your Ruby code into Java classes.">Figure 10-6</a> summarizes how JRuby compiles and executes this script.</p><p>At the left of this figure, you see the code <code class="literal">puts 2+2</code>. The large downward pointing arrow indicates that JRuby converts this code into a series of Java bytecode instructions that implement a Java class called <code class="literal">simple</code> (after the script’s filename). The <code class="literal">class simple extends AbstractScript</code> notation is Java code; here, it declares a new Java class called <code class="literal">simple</code>, which uses <code class="literal">AbstractScript</code> as a superclass.</p><p>The <code class="literal">simple</code> class is a Java version of our Ruby code that adds 2 + 2 and prints the sum. The <code class="literal">simple</code> Java class does the same thing using Java. Inside <code class="literal">simple</code>, JRuby creates a Java method called <code class="literal">__file__</code> that executes the <code class="literal">2+2</code> code as indicated with the inner <code class="literal">__file__</code> rectangle at the bottom of the figure. The method rectangle <code class="literal">&lt;init&gt;</code> is the constructor for the <code class="literal">simple</code> class.</p><div class="figure"><a id="jruby_converts_your_ruby_code_into_java"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00238"/><img alt="JRuby converts your Ruby code into Java classes." src="httpatomoreillycomsourcenostarchimages1854289.png.jpg"/></div></div><p class="title">Figure 10-6. JRuby converts your Ruby code into Java classes.</p></div><p><a class="indexterm" id="iddle1143"/><a class="indexterm" id="iddle1408"/><a class="indexterm" id="iddle1944"/><a class="indexterm" id="iddle1946"/>At the right of <a class="xref" href="ch10.html#jruby_converts_your_ruby_code_into_java" title="Figure 10-6. JRuby converts your Ruby code into Java classes.">Figure 10-6</a>, you see a small part of JRuby’s library of Ruby classes. These are Ruby’s built-in classes, such as <code class="literal">Fixnum</code>, <code class="literal">String</code>, and <code class="literal">Array</code>. MRI implements these classes using C. When your code calls a method from one of these classes, the method dispatch process uses the CFUNC method type. However, JRuby implements all of the built-in Ruby classes using Java code. On the right side of <a class="xref" href="ch10.html#jruby_converts_your_ruby_code_into_java" title="Figure 10-6. JRuby converts your Ruby code into Java classes.">Figure 10-6</a>, you see two built-in Ruby methods that our code calls.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>First, your code adds 2 + 2, using the <code class="literal">+</code> method of the Ruby <code class="literal">Fixnum</code> class. JRuby implements the Ruby <code class="literal">Fixnum</code> class using a Java class called <code class="literal">RubyFixnum</code>. In this example, your code calls the <code class="literal">op_plus</code> Java method in this <code class="literal">RubyFixnum</code> class.</p></li><li class="listitem"><p>To print the sum, the code calls the <code class="literal">puts</code> method of the built-in Ruby <code class="literal">IO</code> class (actually via the <code class="literal">Kernel</code> module). JRuby implements this in a similar way, using a Java class called <code class="literal">RubyIO</code>.</p></li></ul></div></div><div class="sect2" title="Implementing Ruby Classes with Java Classes"><div class="titlepage"><div><div><h2 class="title"><a id="implementing_ruby_classes_with_java_clas"/>Implementing Ruby Classes with Java Classes</h2></div></div></div><p>As you know, standard Ruby is implemented internally using C, which doesn’t support the notion of object-oriented programming. C code can’t use objects, classes, methods, or inheritance the way that Ruby code does.</p><p>However, JRuby is implemented in Java, an object-oriented programming language. While not as flexible and powerful as Ruby itself, Java <a class="indexterm" id="iddle1942"/><a class="indexterm" id="iddle1948"/>does support writing classes, creating objects as instances of those classes, and relating one class to another through inheritance, which means that JRuby’s implementation of Ruby is also object oriented.</p><p>JRuby implements Ruby objects with Java objects. To get a better idea of what this means, see <a class="xref" href="ch10.html#mri_implements_objects_and_classes_using" title="Figure 10-7. MRI implements objects and classes using C structures.">Figure 10-7</a>, which compares Ruby code with MRI C structures.</p><div class="figure"><a id="mri_implements_objects_and_classes_using"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00239"/><img alt="MRI implements objects and classes using C structures." src="httpatomoreillycomsourcenostarchimages1854291.png.jpg"/></div></div><p class="title">Figure 10-7. MRI implements objects and classes using C structures.</p></div><p>Internally Ruby creates an <code class="literal">RClass</code> C structure for each class and an <code class="literal">RObject</code> structure for each object. Ruby tracks the class for each object using the <code class="literal">klass</code> pointer in the <code class="literal">RObject</code> structure. <a class="xref" href="ch10.html#mri_implements_objects_and_classes_using" title="Figure 10-7. MRI implements objects and classes using C structures.">Figure 10-7</a> shows one <code class="literal">RClass</code> for the <code class="literal">Mathematician</code> class and one <code class="literal">RObject</code> for <code class="literal">pythagoras</code>, an instance of <code class="literal">Mathematician</code>.</p><p><a class="xref" href="ch10.html#internallycomma_jruby_represents_objects" title="Figure 10-8. Internally, JRuby represents objects using the RubyObject Java class and classes using the RubyClass Java class.">Figure 10-8</a> shows that the situation is very similar in JRuby, at least at first glance.</p><div class="figure"><a id="internallycomma_jruby_represents_objects"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00240"/><img alt="Internally, JRuby represents objects using the RubyObject Java class and classes using the RubyClass Java class." src="httpatomoreillycomsourcenostarchimages1854293.png.jpg"/></div></div><p class="title">Figure 10-8. Internally, JRuby represents objects using the <code class="literal">RubyObject</code> Java class and classes using the <code class="literal">RubyClass</code> Java class.</p></div><p>On the left side of the figure, we see the same Ruby code. On the right are two Java objects, one an instance of the <code class="literal">RubyObject</code> Java class and the other an instance of the <code class="literal">RubyClass</code> Java class. JRuby’s implementation <a class="indexterm" id="iddle1013"/><a class="indexterm" id="iddle1067"/><a class="indexterm" id="iddle1124"/><a class="indexterm" id="iddle1604"/><a class="indexterm" id="iddle1941"/><a class="indexterm" id="iddle1947"/>of Ruby objects and classes closely resembles MRI’s, but JRuby uses Java objects instead of using C structures. JRuby uses the names <code class="literal">RubyObject</code> and <code class="literal">RubyClass</code> because these Java objects represent your Ruby object and class.</p><p>But when we look a bit closer, things aren’t so straightforward. Because <code class="literal">RubyObject</code> is a Java class, JRuby can use inheritance to simplify its internal implementation. In fact, the superclass of <code class="literal">RubyObject</code> is <code class="literal">RubyBasicObject</code>. This reflects how the Ruby classes are related, as we can see by calling the <code class="literal">ancestors</code> method on <code class="literal">Object</code>.</p><a id="pro_id00061"/><pre class="programlisting">p Object.ancestors
 =&gt; [Object, Kernel, BasicObject]</pre><p>Calling <code class="literal">ancestors</code> returns an array containing all the classes and modules in the superclass chain for the receiver. Here, we see that <code class="literal">Object</code>’s superclass is the <code class="literal">Kernel</code> module and its superclass is <code class="literal">BasicObject</code>. JRuby uses the same pattern for its internal Java class hierarchy, as shown in <a class="xref" href="ch10.html#rubybasicobject_is_the_superclass_of_the" title="Figure 10-9. RubyBasicObject is the superclass of the RubyObject Java class.">Figure 10-9</a>.</p><div class="figure"><a id="rubybasicobject_is_the_superclass_of_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00241"/><img alt="RubyBasicObject is the superclass of the RubyObject Java class." src="httpatomoreillycomsourcenostarchimages1854295.png.jpg"/></div></div><p class="title">Figure 10-9. <code class="literal">RubyBasicObject</code> is the superclass of the <code class="literal">RubyObject</code> Java class.</p></div><p>The <code class="literal">Kernel</code> module aside, we can see that JRuby’s internal Java class hierarchy reflects the Ruby class hierarchy that it implements. This similarity is made possible by Java’s object-oriented design.</p><p>Now for a second example. Let’s use <code class="literal">ancestors</code> again to show the superclasses for the <code class="literal">Class</code> Ruby class.</p><a id="pro_id00062"/><pre class="programlisting">p Class.ancestors
 =&gt; [Class, Module, Object, Kernel, BasicObject]</pre><p>Here, we see that the superclass of <code class="literal">Class</code> is <code class="literal">Module</code>, its superclass is <code class="literal">Object</code>, and so on. And as we would expect, JRuby’s Java code uses the same design internally (see <a class="xref" href="ch10.html#jrubyapostrophes_internal_java_class_hie" title="Figure 10-10. JRuby’s internal Java class hierarchy for RubyClass">Figure 10-10</a>).</p><div class="figure"><a id="jrubyapostrophes_internal_java_class_hie"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00242"/><img alt="JRuby’s internal Java class hierarchy for RubyClass" src="httpatomoreillycomsourcenostarchimages1854297.png.jpg"/></div></div><p class="title">Figure 10-10. JRuby’s internal Java class hierarchy for <code class="literal">RubyClass</code></p></div></div></div><div class="sect1" title="Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_10-1_monitoring_jrubyapostrop"/>Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler</h1></div></div></div><p><a class="indexterm" id="iddle1033"/><a class="indexterm" id="iddle1277"/><a class="indexterm" id="iddle1474"/><a class="indexterm" id="iddle1488"/><a class="indexterm" id="iddle1605"/>I mentioned earlier that JRuby can speed up your Ruby code by using a JIT compiler. JRuby always translates your Ruby program into Java bytecode instructions, which the JVM can compile into machine language that your computer’s microprocessor can execute directly. In this experiment we’ll see when this happens and measure how much it speeds up your code.</p><div class="sect2" title="Experiment Code"><div class="titlepage"><div><div><h2 class="title"><a id="experiment_code"/>Experiment Code</h2></div></div></div><p><a class="xref" href="ch10.html#sample_program_for_testing_jrubyapostr" title="Example 10-3. A sample program for testing JRuby’s JIT behavior (jit.rb)">Example 10-3</a> shows a Ruby program that prints out 10 random numbers between 1 and 100.</p><div class="example"><a id="sample_program_for_testing_jrubyapostr"/><p class="title">Example 10-3. A sample program for testing JRuby’s JIT behavior <span class="emphasis"><em>(jit.rb)</em></span></p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> array = (1..100).to_a
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> 10.times do
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   sample = array.sample
      puts sample
    end</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00386"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we create an array with 100 elements: 1 through 100. Then, at <span class="inlinemediaobject"><a id="inline_id00387"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we iterate over the following block 10 times. Inside this block, we use the <code class="literal">sample</code> method at <span class="inlinemediaobject"><a id="inline_id00388"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> to pick a random value from the array and print it. When we run this code, we get the output shown in <a class="xref" href="ch10.html#output_from_listing_10-3" title="Example 10-4. The output from Example 10-3">Example 10-4</a>.</p><div class="example"><a id="output_from_listing_10-3"/><p class="title">Example 10-4. The output from <a class="xref" href="ch10.html#sample_program_for_testing_jrubyapostr" title="Example 10-3. A sample program for testing JRuby’s JIT behavior (jit.rb)">Example 10-3</a></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>jruby jit.rb</strong></span>
87
88
69
5
38
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Now let’s remove the <code class="literal">puts</code> statement and increase the number of iterations. (Removing the output will make the experiment more manageable.) <a class="xref" href="ch10.html#we_remove_puts_and_increase_the_number_o" title="Example 10-5. We remove puts and increase the number of iterations to 1,000.">Example 10-5</a> shows the updated program.</p><div class="example"><a id="we_remove_puts_and_increase_the_number_o"/><p class="title">Example 10-5. We remove <code class="literal">puts</code> and increase the number of iterations to 1,000.</p><div class="example-contents"><pre class="programlisting">    array = (1..100).to_a
    1000.times do
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   sample = array.sample
    end</pre></div></div></div><div class="sect2" title="Using the -J-XX:+PrintCompilation Option"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_-j-xxplusprintcompilation_opti"/>Using the -J-XX:+PrintCompilation Option</h2></div></div></div><p><a class="indexterm" id="iddle1401"/><a class="indexterm" id="iddle1495"/>Of course, if we run the program now, we won’t see any output because we’ve removed <code class="literal">puts</code>. Let’s run the program again—this time using a debug flag (shown in <a class="xref" href="ch10.html#output_generated_by_the_-j-xxpluspri" title="Example 10-6. The output generated by the -J-XX:+PrintCompilation option">Example 10-6</a>) to display information about what the JVM’s JIT compiler is doing.</p><div class="example"><a id="output_generated_by_the_-j-xxpluspri"/><p class="title">Example 10-6. The output generated by the <code class="literal">-J-XX:+PrintCompilation</code> option</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>jruby -J-XX:+PrintCompilation jit.rb</strong></span>
    101   1       java.lang.String::hashCode (64 bytes)
    144   2       java.util.Properties$LineReader::readLine (452 bytes)
    173   3       sun.nio.cs.UTF_8$Decoder::decodeArrayLoop (553 bytes)
    200   4       java.lang.String::charAt (33 bytes)
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Here, we use the <code class="literal">-J</code> option for JRuby and pass the <code class="literal">XX:+PrintCompilation</code> option to the underlying JVM application. <code class="literal">PrintCompilation</code> causes the JVM to display the information you see in <a class="xref" href="ch10.html#output_generated_by_the_-j-xxpluspri" title="Example 10-6. The output generated by the -J-XX:+PrintCompilation option">Example 10-6</a>. The line <code class="literal">java.lang.String::hashCode</code> means that the JVM compiled the <code class="literal">hashCode</code> method of the <code class="literal">String</code> Java class into machine language. The other values show technical information about the JIT process (<code class="literal">101</code> is a time stamp, <code class="literal">1</code> is a compilation ID, and <code class="literal">64 bytes</code> is the size of the bytecode snippet that was compiled).</p><p>The goal of this experiment is to validate the hypothesis that <a class="xref" href="ch10.html#we_remove_puts_and_increase_the_number_o" title="Example 10-5. We remove puts and increase the number of iterations to 1,000.">Example 10-5</a> should run faster once the JVM’s JIT compiler converts it into machine language. Notice that <a class="xref" href="ch10.html#we_remove_puts_and_increase_the_number_o" title="Example 10-5. We remove puts and increase the number of iterations to 1,000.">Example 10-5</a> has just one line of Ruby code inside the loop at <span class="inlinemediaobject"><a id="inline_id00390"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> that calls <code class="literal">array.sample</code>. Therefore, we should expect our Ruby program to finish noticeably faster once the JIT compiles JRuby’s implementation of <code class="literal">Array#sample</code> into machine language because <code class="literal">Array#sample</code> is called so many times.</p><p>Because the output in <a class="xref" href="ch10.html#output_generated_by_the_-j-xxpluspri" title="Example 10-6. The output generated by the -J-XX:+PrintCompilation option">Example 10-6</a> is quite long and complex, we’ll use <code class="literal">grep</code> to search the output for occurrences of <code class="literal">org.jruby.RubyArray</code>.</p><a id="pro_id00064"/><pre class="programlisting">$ <span class="strong"><strong>jruby -J-XX:+PrintCompilation jit.rb | grep org.jruby.RubyArray</strong></span></pre><p>The result is no output. None of the lines in the <code class="literal">PrintCompilation</code> output match the name <code class="literal">org.jruby.RubyArray</code>, which means the JIT compiler is not converting the <code class="literal">Array#sample</code> method into machine language. It doesn’t do this conversion because the JVM only runs the JIT compiler to compile Java bytecode instructions that your program executes numerous times—areas of bytecode instructions known as <span class="emphasis"><em>hot spots</em></span>. The JVM spends extra time compiling hot spots because they are called so many times. To prove this, we can increase the number of iterations to 100,000 and repeat our test, as shown in <a class="xref" href="ch10.html#increasing_the_number_of_iterations_shou" title="Example 10-7. Increasing the number of iterations should trigger the JIT compiler to convert Array#sample to machine language.">Example 10-7</a>.</p><div class="example"><a id="increasing_the_number_of_iterations_shou"/><p class="title">Example 10-7. Increasing the number of iterations should trigger the JIT compiler to convert <code class="literal">Array#sample</code> to machine language.</p><div class="example-contents"><pre class="programlisting">array = (1..100).to_a
100000.times do
  sample = array.sample
end</pre></div></div><p><a class="indexterm" id="iddle1029"/><a class="indexterm" id="iddle1475"/><a class="indexterm" id="iddle1489"/><a class="indexterm" id="iddle2005"/>When we repeat the same <code class="literal">jruby</code> command again with <code class="literal">grep</code>, we see the output shown in <a class="xref" href="ch10.html#output_after_running_listing_10-7_wi" title="Example 10-8. The output after running Example 10-7 with -J-XX:+PrintCompilation piped to grep">Example 10-8</a>.</p><div class="example"><a id="output_after_running_listing_10-7_wi"/><p class="title">Example 10-8. The output after running <a class="xref" href="ch10.html#increasing_the_number_of_iterations_shou" title="Example 10-7. Increasing the number of iterations should trigger the JIT compiler to convert Array#sample to machine language.">Example 10-7</a> with <code class="literal">-J-XX:+PrintCompilation</code> piped to <code class="literal">grep</code></p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> $ <span class="strong"><strong>jruby -J-XX:+PrintCompilation jit.rb | grep org.jruby.RubyArray</strong></span>
       1809 165       org.jruby.RubyArray::safeArrayRef (11 bytes)
       1810 166  !    org.jruby.RubyArray::safeArrayRef (12 bytes)
       1811 167       org.jruby.RubyArray::eltOk (16 bytes)
       1927 203       org.jruby.RubyArray$INVOKER$i$0$2$sample::call (36 bytes)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>    1928 204  !    org.jruby.RubyArray::sample (834 bytes)
       1930 205       org.jruby.RubyArray::randomReal (10 bytes)</pre></div></div><p>Because we used <code class="literal">grep org.jruby.RubyArray</code> at <span class="inlinemediaobject"><a id="inline_id00393"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, we see only Java class names that match the text <code class="literal">org.jruby.RubyArray</code>. At <span class="inlinemediaobject"><a id="inline_id00394"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we can see that the JIT compiler compiled the <code class="literal">Array#sample</code> method because we see the text <code class="literal">org.jruby.RubyArray::sample</code>.</p></div><div class="sect2" title="Does JIT Speed Up Your JRuby Program?"><div class="titlepage"><div><div><h2 class="title"><a id="does_jit_speed_up_your_jruby_programques"/>Does JIT Speed Up Your JRuby Program?</h2></div></div></div><p>Now to see if the JIT sped things up. Based on a command-line parameter—<code class="literal">ARGV[0]</code>—which I save in <code class="literal">iterations</code> at <span class="inlinemediaobject"><a id="inline_id00395"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, <a class="xref" href="ch10.html#sample_code_for_benchmarking_jit_perform" title="Example 10-9. Sample code for benchmarking JIT performance">Example 10-9</a> measures the amount of time it takes to call <code class="literal">Array#sample</code> a given number of times.</p><div class="example"><a id="sample_code_for_benchmarking_jit_perform"/><p class="title">Example 10-9. Sample code for benchmarking JIT performance</p><div class="example-contents"><pre class="programlisting">    require 'benchmark'

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> iterations = ARGV[0].to_i

    Benchmark.bm do |bench|
      array = (1..100).to_a
      bench.report("#{iterations} iterations") do
        iterations.times do
          sample = array.sample
        end
      end
    end</pre></div></div><p>By running this listing as shown below, we can measure how long it takes to execute the loop 100 times, for example.</p><a id="pro_id00065"/><pre class="programlisting">$ <span class="strong"><strong>jruby jit.rb 100</strong></span></pre><p><a class="indexterm" id="iddle1149"/><a class="indexterm" id="iddle1483"/><a class="indexterm" id="iddle1710"/><a class="indexterm" id="iddle2021"/><a class="indexterm" id="iddle2024"/><a class="indexterm" id="iddle2079"/><a class="xref" href="ch10.html#jruby_vsdot_mri_performancedot_time_is_s" title="Figure 10-11. JRuby vs. MRI performance. Time is shown in seconds vs. number of iterations (using JRuby 1.7.5 and Java 1.6; MRI Ruby 2.0).">Figure 10-11</a> shows the results for 100 to 100 million iterations using both JRuby and MRI.</p><div class="figure"><a id="jruby_vsdot_mri_performancedot_time_is_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00243"/><img alt="JRuby vs. MRI performance. Time is shown in seconds vs. number of iterations (using JRuby 1.7.5 and Java 1.6; MRI Ruby 2.0)." src="httpatomoreillycomsourcenostarchimages1854299.png.jpg"/></div></div><p class="title">Figure 10-11. JRuby vs. MRI performance. Time is shown in seconds vs. number of iterations (using JRuby 1.7.5 and Java 1.6; MRI Ruby 2.0).</p></div><p>The graph for MRI is more or less a straight line moving up to the right. This means it always takes Ruby 2.0 about the same amount of time to execute the <code class="literal">Array#sample</code> method. The results for JRuby, however, are not so simple. At left you can see that for fewer than 100,000 iterations, JRuby takes longer to execute <a class="xref" href="ch10.html#sample_code_for_benchmarking_jit_perform" title="Example 10-9. Sample code for benchmarking JIT performance">Example 10-9</a>. (The chart uses a logarithmic scale, so the absolute time differences on the left side are small.) However, once we reach about 1 million iterations, JRuby speeds up dramatically and starts to take less time to execute <code class="literal">Array#sample</code>.</p><p>Ultimately for many, many iterations, JRuby is faster than MRI. But what’s important here is not simply that JRuby might be faster but that its performance characteristics vary. The longer your code runs, the longer the JVM has to optimize it, and the faster things will be.</p></div></div><div class="sect1" title="Strings in JRuby and MRI"><div class="titlepage"><div><div><h1 class="title"><a id="strings_in_jruby_and_mri"/>Strings in JRuby and MRI</h1></div></div></div><p>We’ve learned how JRuby executes bytecode instructions, passing control between your code and a library of Ruby objects implemented with Java. Now we’ll take a closer look at this library, specifically at how JRuby implements the <code class="literal">String</code> class. How do JRuby and MRI implement strings? Where <a class="indexterm" id="iddle1096"/><a class="indexterm" id="iddle1482"/><a class="indexterm" id="iddle1927"/><a class="indexterm" id="iddle1950"/><a class="indexterm" id="iddle1962"/>do they save the string data you use in your Ruby code, and how do their implementations compare? Let’s begin to answer these questions by looking at how MRI implements strings.</p><div class="sect2" title="How JRuby and MRI Save String Data"><div class="titlepage"><div><div><h2 class="title"><a id="how_jruby_and_mri_save_string_data"/>How JRuby and MRI Save String Data</h2></div></div></div><p>This code saves a famous quote from Pythagoras in a local variable. But where does this string go?</p><a id="pro_id00066"/><pre class="programlisting">str = "Geometry is knowledge of the eternally existent."</pre><p>Recall from <a class="xref" href="ch05.html" title="Chapter 5. Objects and Classes">Chapter 5</a> that MRI uses different C structures to implement built-in classes, such as <code class="literal">RRegExp</code>, <code class="literal">RArray</code>, and <code class="literal">RHash</code>, as well as <code class="literal">RString</code>, which saves your strings. <a class="xref" href="ch10.html#part_of_the_rstring_c_structure" title="Figure 10-12. Part of the RString C structure">Figure 10-12</a> shows how MRI represents the <code class="literal">Geometry...</code> string internally.</p><div class="figure"><a id="part_of_the_rstring_c_structure"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00244"/><img alt="Part of the RString C structure" src="httpatomoreillycomsourcenostarchimages1854301.png.jpg"/></div></div><p class="title">Figure 10-12. Part of the <code class="literal">RString</code> C structure</p></div><p>Notice that MRI saves the actual string data in a separate buffer, or section of memory, shown on the right. The <code class="literal">RString</code> structure itself contains a pointer to this buffer, <code class="literal">ptr</code>. Also notice that <code class="literal">RString</code> contains two other integer values: <code class="literal">len</code>, or the length of the string (48 in this example), and <code class="literal">capa</code>, or the capacity of the data buffer (also 48). The size of the data buffer can be longer than the string, in which case <code class="literal">capa</code> would be larger than <code class="literal">len</code>. (This would be the case if you executed code that reduced the length of the string.)</p><p>Now let’s consider JRuby. <a class="xref" href="ch10.html#jruby_uses_two_java_objects_and_a_data_b" title="Figure 10-13. JRuby uses two Java objects and a data buffer for each string.">Figure 10-13</a> shows how JRuby represents this string internally. JRuby uses the Java class <code class="literal">RubyString</code> to represent strings in your Ruby code, following the naming pattern we saw above with <code class="literal">RubyObject</code> and <code class="literal">RubyClass</code>. <code class="literal">RubyString</code> uses another class to track the actual string data: <code class="literal">ByteList</code>. This lower-level code tracks a separate data buffer (called <code class="literal">bytes</code>) similar to the way that the <code class="literal">RString</code> structure does so in MRI. <code class="literal">ByteList</code> also stores the length of the string in the <code class="literal">realSize</code> instance variable.</p><div class="figure"><a id="jruby_uses_two_java_objects_and_a_data_b"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00245"/><img alt="JRuby uses two Java objects and a data buffer for each string." src="httpatomoreillycomsourcenostarchimages1854303.png.jpg"/></div></div><p class="title">Figure 10-13. JRuby uses two Java objects and a data buffer for each string.</p></div></div><div class="sect2" title="Copy-on-Write"><div class="titlepage"><div><div><h2 class="title"><a id="copy-on-write"/>Copy-on-Write</h2></div></div></div><p><a class="indexterm" id="iddle1209"/><a class="indexterm" id="iddle1238"/><a class="indexterm" id="iddle1630"/>Internally, both JRuby and MRI use an optimization called <span class="emphasis"><em>copy-on-write</em></span> for strings and other data. This trick allows two identical string values to share the same data buffer, which saves both memory and time because Ruby avoids making separate copies of the same string data unnecessarily.</p><p>For example, suppose we use the <code class="literal">dup</code> method to copy a string.</p><a id="pro_id00067"/><pre class="programlisting">str = "Geometry is knowledge of the eternally existent."
str2 = str.dup</pre><p>Does JRuby have to copy the <code class="literal">Geometry is...</code> text from one string object to another? No. <a class="xref" href="ch10.html#two_jruby_string_objects_can_share_the_s" title="Figure 10-14. Two JRuby string objects can share the same data buffer.">Figure 10-14</a> shows how JRuby shares the string data across two different string objects.</p><div class="figure"><a id="two_jruby_string_objects_can_share_the_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00246"/><img alt="Two JRuby string objects can share the same data buffer." src="httpatomoreillycomsourcenostarchimages1854305.png.jpg"/></div></div><p class="title">Figure 10-14. Two JRuby string objects can share the same data buffer.</p></div><p>When we call <code class="literal">dup</code>, JRuby creates new <code class="literal">RubyString</code> and <code class="literal">ByteList</code> Java objects, but it doesn’t copy the actual string data. Instead, it sets the second <code class="literal">ByteList</code> object to point to the same data buffer used by the original string. Now we have two sets of Java objects but only one underlying string value, as shown on the right of the figure. Because strings can contain thousands of bytes or more, this optimization can often save a tremendous amount of memory.</p><p>MRI uses the same trick, although in a slightly more complex way. <a class="xref" href="ch10.html#mri_shares_strings_by_creating_a_third_r" title="Figure 10-15. MRI shares strings by creating a third RString structure.">Figure 10-15</a> shows how standard Ruby shares strings.</p><div class="figure"><a id="mri_shares_strings_by_creating_a_third_r"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00247"/><img alt="MRI shares strings by creating a third RString structure." src="httpatomoreillycomsourcenostarchimages1854307.png.jpg"/></div></div><p class="title">Figure 10-15. MRI shares strings by creating a third <code class="literal">RString</code> structure.</p></div><p>Like JRuby, MRI shares the underlying string data. However, when you copy a string in standard MRI Ruby, it creates a third <code class="literal">RString</code> structure and then sets both the original <code class="literal">RString</code> and new <code class="literal">RString</code> to refer to it using the <code class="literal">shared</code> pointer.</p><p>In either case, we have a problem. What if we change one of the string variables? For example, suppose we convert one of the strings to uppercase as follows:</p><a id="pro_id00068"/><pre class="programlisting">    str = "Geometry is knowledge of the eternally existent."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> str2 = str.dup
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> str2.upcase!</pre><p>At <span class="inlinemediaobject"><a id="inline_id00399"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> in both JRuby and MRI, we have two shared strings, but at <span class="inlinemediaobject"><a id="inline_id00400"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> I change the second string using the <code class="literal">upcase!</code> method. Now the two strings differ, which means that Ruby clearly can’t continue to share the underlying string buffer or <code class="literal">upcase!</code> would change both strings. We can see the strings are now different by displaying the string values.</p><a id="pro_id00069"/><pre class="programlisting">p str
 =&gt; "Geometry is knowledge of the eternally existent."
p str2
 =&gt; "GEOMETRY IS KNOWLEDGE OF THE ETERNALLY EXISTENT."</pre><p><a class="indexterm" id="iddle1216"/><a class="indexterm" id="iddle1270"/><a class="indexterm" id="iddle2023"/>At some point, Ruby must have separated these two strings, creating a new data buffer. This is what the phrase <span class="emphasis"><em>copy-on-write</em></span> means: Both MRI and JRuby create a new copy of the string data buffer when you write to one of the strings.</p></div></div><div class="sect1" title="Experiment 10-2: Measuring Copy-on-Write Performance"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_10-2_measuring_copy-on-write"/>Experiment 10-2: Measuring Copy-on-Write Performance</h1></div></div></div><p>In this experiment we’ll collect evidence that this extra copy operation really occurs when we write to a shared string. First, we’ll create a simple, nonshared string and write to it. Then we’ll create two shared strings and write to one of them. If copy-on-write really occurs, then writing to a shared string should take a bit longer because Ruby has to create a new copy of the string before writing.</p><div class="sect2" title="Creating a Unique, Nonshared String"><div class="titlepage"><div><div><h2 class="title"><a id="creating_a_uniquecomma_nonshared_string"/>Creating a Unique, Nonshared String</h2></div></div></div><p>Let’s begin by creating our example string again, <code class="literal">str</code>. Initially Ruby can’t possibly share <code class="literal">str</code> with anything else because there is only one string. We’ll use <code class="literal">str</code> for our baseline performance measurement.</p><a id="pro_id00070"/><pre class="programlisting">str = "Geometry is knowledge of the eternally existent."</pre><p>But as it turns out, Ruby shares <code class="literal">str</code> immediately! To see why, we’ll examine the YARV instructions that MRI uses to execute this code, as shown in <a class="xref" href="ch10.html#mri_ruby_uses_a_dup_yarv_instruction_int" title="Example 10-10. MRI Ruby uses a dup YARV instruction internally when you use a literal string constant.">Example 10-10</a>.</p><div class="example"><a id="mri_ruby_uses_a_dup_yarv_instruction_int"/><p class="title">Example 10-10. MRI Ruby uses a <code class="literal">dup</code> YARV instruction internally when you use a literal string constant.</p><div class="example-contents"><pre class="programlisting">    code = &lt;&lt;END
    str = "Geometry is knowledge of the eternally existent."
    END

    puts RubyVM::InstructionSequence.compile(code).disasm
    == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
    local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> [ 2] str
    0000 trace            1                                               (   1)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> 0002 putstring        "Geometry is knowledge of the eternally existent."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> 0004 dup
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/> 0005 setlocal_OP__WC__0 2
    0007 leave</pre></div></div><p>Reading the YARV instructions above carefully, we see at <span class="inlinemediaobject"><a id="inline_id00405"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> that Ruby puts the string onto the stack using <code class="literal">putstring</code>. This YARV instruction internally copies the string argument to the stack, creating a shared copy already. At <span class="inlinemediaobject"><a id="inline_id00406"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> Ruby uses <code class="literal">dup</code> to create yet another shared copy of the string to use as an argument for <code class="literal">setlocal</code>. Finally, at <span class="inlinemediaobject"><a id="inline_id00407"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> <code class="literal">setlocal_OP__WC__0 2</code> saves this string into the <code class="literal">str</code> variable, shown as <code class="literal">[2]</code> in the local table <span class="inlinemediaobject"><a id="inline_id00408"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>.</p><p><a class="xref" href="ch10.html#executing_putstring_and_dup_creates_shar" title="Figure 10-16. Executing putstring and dup creates shared strings in MRI.">Figure 10-16</a> summarizes this process.</p><div class="figure"><a id="executing_putstring_and_dup_creates_shar"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00248"/><img alt="Executing putstring and dup creates shared strings in MRI." src="httpatomoreillycomsourcenostarchimages1854309.png.jpg"/></div></div><p class="title">Figure 10-16. Executing <code class="literal">putstring</code> and <code class="literal">dup</code> creates shared strings in MRI.</p></div><p>On the left are the YARV instructions <code class="literal">putstring</code>, <code class="literal">dup</code>, and <code class="literal">setlocal</code>. On the right are the <code class="literal">RString</code> structures that these instructions create, as well as the underlying shared string data. As I just mentioned, <code class="literal">putstring</code> in fact copies the string constant from a third <code class="literal">RString</code> left off the diagram, meaning the string is actually shared a third time.</p><p>Because Ruby initially shares strings created from constant values, we need to create our string differently by concatenating two strings together as follows:</p><a id="pro_id00071"/><pre class="programlisting">str = "This string is not shared" + " and so can be modified faster."</pre><p>The result of this concatenation will be a new, unique string. Ruby will not share its string data with any other string objects.</p></div><div class="sect2" title="Experiment Code"><div class="titlepage"><div><div><h2 class="title"><a id="experiment_code-id00040"/>Experiment Code</h2></div></div></div><p>Let’s take some measurements. <a class="xref" href="ch10.html#measuring_a_delay_for_copy-on-write" title="Example 10-11. Measuring a delay for copy-on-write">Example 10-11</a> shows the code for this experiment.</p><div class="example"><a id="measuring_a_delay_for_copy-on-write"/><p class="title">Example 10-11. Measuring a delay for copy-on-write</p><div class="example-contents"><pre class="programlisting">    require 'benchmark'

    ITERATIONS = 1000000

    Benchmark.bm do |bench|
      bench.report("test") do
        ITERATIONS.times do
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>       str = "This string is not shared" + " and so can be modified faster."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>       str2 = "But this string is shared" + " so Ruby will need to copy it
                  before writing to it."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>       str3 = str2.dup
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>       str3[3] = 'x'
        end
      end
    end</pre></div></div><p><a class="indexterm" id="iddle2091"/>Before we run this test, let’s walk through this code. At <span class="inlinemediaobject"><a id="inline_id00413"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we create a unique, unshared string by concatenating two strings. This is <code class="literal">str</code>. Then at <span class="inlinemediaobject"><a id="inline_id00414"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we create a second unshared string, <code class="literal">str2</code>. But at <span class="inlinemediaobject"><a id="inline_id00415"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> we use <code class="literal">dup</code> to create a copy of this string, <code class="literal">str3</code>, and now <code class="literal">str2</code> and <code class="literal">str3</code> share the same value.</p></div><div class="sect2" title="Visualizing Copy-on-Write"><div class="titlepage"><div><div><h2 class="title"><a id="visualizing_copy-on-write"/>Visualizing Copy-on-Write</h2></div></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00416"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> in <a class="xref" href="ch10.html#measuring_a_delay_for_copy-on-write" title="Example 10-11. Measuring a delay for copy-on-write">Example 10-11</a> we change the fourth character in <code class="literal">str3</code> using the code <code class="literal">str3[3] = 'x'</code>. But here Ruby can’t change the character in <code class="literal">str3</code> without changing <code class="literal">str2</code> as well, as shown in <a class="xref" href="ch10.html#ruby_canapostrophet_change_str3_without" title="Figure 10-17. Ruby can’t change str3 without also changing str2.">Figure 10-17</a>.</p><div class="figure"><a id="ruby_canapostrophet_change_str3_without"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00249"/><img alt="Ruby can’t change str3 without also changing str2." src="httpatomoreillycomsourcenostarchimages1854311.png.jpg"/></div></div><p class="title">Figure 10-17. Ruby can’t change <code class="literal">str3</code> without also changing <code class="literal">str2</code>.</p></div><p><a class="indexterm" id="iddle1689"/>Ruby has to make a separate copy of <code class="literal">str3</code> first, as shown in <a class="xref" href="ch10.html#ruby_copies_the_string_into_a_new_buffer" title="Figure 10-18. Ruby copies the string into a new buffer for str3 before writing to it.">Figure 10-18</a>.</p><div class="figure"><a id="ruby_copies_the_string_into_a_new_buffer"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00250"/><img alt="Ruby copies the string into a new buffer for str3 before writing to it." src="httpatomoreillycomsourcenostarchimages1854313.png.jpg"/></div></div><p class="title">Figure 10-18. Ruby copies the string into a new buffer for <code class="literal">str3</code> before writing to it.</p></div><p>Now Ruby can write into the new buffer for <code class="literal">str3</code> without affecting <code class="literal">str2</code>.</p></div><div class="sect2" title="Modifying a Shared String Is Slower"><div class="titlepage"><div><div><h2 class="title"><a id="modifying_a_shared_string_is_slower"/>Modifying a Shared String Is Slower</h2></div></div></div><p>When we execute <a class="xref" href="ch10.html#measuring_a_delay_for_copy-on-write" title="Example 10-11. Measuring a delay for copy-on-write">Example 10-11</a>, the <code class="literal">benchmark</code> library measures how long it takes to run the inner block 1 million times. This block creates <code class="literal">str</code>, <code class="literal">str2</code>, and <code class="literal">str3</code> and then modifies <code class="literal">str3</code>. On my laptop, <code class="literal">benchmark</code> yields a measurement of about 1.87 seconds.</p><p>Next, let’s change <code class="literal">str3[3] = 'x'</code> at <span class="inlinemediaobject"><a id="inline_id00417"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> to modify <code class="literal">str</code> instead.</p><a id="pro_id00072"/><pre class="programlisting">#str3[3] = 'x'str[3] = 'x'</pre><p>Now we’re modifying the unshared, unique string instead of the shared string. Running the test again yields a result of about 1.69 seconds, or about 9.5 percent less than the time <code class="literal">benchmark</code> reported for the shared string. As expected, it takes slightly less time to modify a unique string than it does to modify a shared one.</p><p>The graph in <a class="xref" href="ch10.html#both_mri_and_jruby_show_a_delay_for_copy" title="Figure 10-19. Both MRI and JRuby show a delay for copy-on-write (seconds).">Figure 10-19</a> shows my cumulative results averaged over 10 different observations for both MRI and JRuby. On the left side of the graph are my average measurements for MRI. The bar on the far left represents the time required to modify the shared string, <code class="literal">str3</code>, and the right MRI bar shows how long it took to modify the unique string, <code class="literal">str</code>. The two bars on the right side exhibit the same pattern for JRuby, but the difference in the height of the bars is much less. Apparently, the JVM can make a new copy of the string faster than MRI.</p><p>But there’s more: Notice that overall JRuby ran the experiment code in 60 percent less time. That is, it was 2.5 times faster than MRI! Just as in <a class="xref" href="ch10.html#experiment_10-1_monitoring_jrubyapostrop" title="Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler">Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler</a>, we must be seeing the JVM optimizations, such as JIT compilation, speed up JRuby when compared to MRI.</p><div class="figure"><a id="both_mri_and_jruby_show_a_delay_for_copy"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00251"/><img alt="Both MRI and JRuby show a delay for copy-on-write (seconds)." src="httpatomoreillycomsourcenostarchimages1854315.png.jpg"/></div></div><p class="title">Figure 10-19. Both MRI and JRuby show a delay for copy-on-write (seconds).</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00041"/>Summary</h1></div></div></div><p>In this chapter we took a look at JRuby, a version of Ruby written in Java. We saw how the <code class="literal">jruby</code> command launches the JVM, passing <span class="emphasis"><em>jruby.jar</em></span> as a parameter. We explored how JRuby parses and compiles our code, and learned in <a class="xref" href="ch10.html#experiment_10-1_monitoring_jrubyapostrop" title="Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler">Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler</a> how the JVM can compile hot spots, or frequently executed snippets of Java bytecode, into machine language. Our results from <a class="xref" href="ch10.html#experiment_10-1_monitoring_jrubyapostrop" title="Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler">Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler</a> showed that compiling hot spots dramatically improves performance, allowing JRuby to run even faster than MRI in some cases.</p><p>In the second half of this chapter, we learned how MRI and JRuby represent our string data internally. We discovered that both versions of Ruby use copy-on-write optimization, sharing string data between different string objects when possible. Finally, in <a class="xref" href="ch10.html#experiment_10-2_measuring_copy-on-write" title="Experiment 10-2: Measuring Copy-on-Write Performance">Experiment 10-2: Measuring Copy-on-Write Performance</a> we proved that copy-on-write actually occurred in both JRuby and MRI.</p><p>JRuby is a very powerful and clever implementation of Ruby: By running your Ruby code using the Java platform, you can benefit from the many years of research, development, tuning, and testing that have been invested in the JVM. The JVM is one of the most popular, mature, and powerful software platforms in use today. It’s being used not only by Java and JRuby but also by many other software languages, such as Clojure, Scala, and Jython, to name a few. By using this shared platform, JRuby can take advantage of the speed, robustness, and diversity of the Java platform—and it can do this for free!</p><p>JRuby is a groundbreaking piece of technology with which every Ruby developer should be familiar.</p></div></div></body></html>