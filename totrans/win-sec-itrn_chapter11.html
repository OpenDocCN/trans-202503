<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>11. Active Directory</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch11" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch11">
<span class="CN"><span aria-label=" Page 341. " epub:type="pagebreak" id="pg_341" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ACTIVE DIRECTORY</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">The previous chapter described the authentication configuration of a local domain. In this chapter, we’ll detail how Active Directory stores user and group configurations on an enterprise network domain. We’ll begin by inspecting the domain configuration, using various PowerShell commands that can enumerate the configured trust relationships, users, and groups. We’ll then dig into the structure of Active Directory and how you can access its raw information over the network.</p>
<p class="TX">Once you understand how Active Directory is structured, we’ll explore how Windows determines who can inspect and modify it. As you’ll see, like most Windows platforms, Active Directory uses security descriptors to grant or deny access to the configuration.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-81"></span><span aria-label=" Page 342. " epub:type="pagebreak" id="pg_342" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">A Brief History of Active Directory</samp></h3>
<p class="TNI1">Prior to Windows 2000, the user configuration for an enterprise network was stored in a SAM database on the network’s domain controller. The domain controller authenticated users with the Netlogon protocol, which relied on the MD4 password hash format. To modify the SAM database, you could use the SAM remote service, as described in the previous chapter. This service allowed an administrator to add or remove users and groups on the domain controller.</p>
<p class="TX">As enterprise networks became more complex, the SAM database format proved to be limited. Windows 2000, which overhauled enterprise networking, moved the user configuration to Active Directory and changed the primary authentication protocol from Netlogon to Kerberos.</p>
<p class="TX">Active Directory provides several advantages over the SAM database, as it is extensible and can store arbitrary data. For example, an administrator can store additional information with a user’s configuration to represent their security clearance, and an application can check this information when granting or denying access to a resource. Active Directory also has fine-grained security, allowing administrators to delegate parts of the configuration to different users more easily than the SAM can.</p>
<p class="TX">Active Directory is stored locally on a domain controller, and computers in the network can access it using the <i>Lightweight Directory Access Protocol (LDAP)</i>, which exposes a TCP/IP network connection on port 389. LDAP derives from the more complex <i>Directory Access Protocol (DAP)</i>, which formed part of the X.500 directory service specification. If you’re familiar with the X.509 certificate format for exchanging public key information on secure websites, some of the following concepts might seem familiar.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-82"></span><samp class="SANS_Futura_Std_Bold_B_11">Exploring an Active Directory Domain with PowerShell</samp></h3>
<p class="TNI1">Let’s begin our exploration of Active Directory with a high-level look at a domain configuration. <a href="chapter11.xhtml#fig11-1">Figure 11-1</a> shows an example forest (of course, your configuration might differ).</p>
<span aria-label=" Page 343. " epub:type="pagebreak" id="pg_343" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="1341" id="fig11-1" src="../images/Figure11-1.jpg" width="1654"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: An example Windows forest</samp></p></figcaption>
</figure>
<p class="TX">To explore this forest, we’ll run various PowerShell commands that can enumerate its domains, users, groups, and devices. If you’d like to follow along, you can find setup instructions for a similar domain configuration in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a>.</span></p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-105"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Remote Server Administration Tools</samp></h4>
<p class="TNI1">We can interact with the Active Directory server through PowerShell’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp> module, which ships with the optional Remote Server Administration Tools (RSAT) Windows capability. By default, only domain controllers come with RSAT installed, as the commands are designed for managing the directory (which not every client system needs to do).</p>
<p class="TX">Therefore, you might need to install RSAT before running the example scripts in this chapter. If you’re running a version of Windows older than Windows 10, version 1809, you must download RSAT from the Microsoft website. If you’re using a newer version of Windows, you can install RSAT by running the commands in <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a> from an administrator PowerShell console.</p>
<span id="Lis11-1"></span><pre><code><span aria-label=" Page 344. " epub:type="pagebreak" id="pg_344" role="doc-pagebreak"></span>PS&gt; <b>$cap_name = Get-WindowsCapability -Online |</b>
<b>Where-Object Name -Match 'Rsat.ActiveDirectory.DS-LDS.Tools'</b>
PS&gt; <b>Add-WindowsCapability -Name $cap_name.Name -Online</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-1: Installing the Remote Server Administration Tools</span></p>
<p class="TX">Note that the examples in this section won’t work unless you run the commands on a machine joined to a Windows enterprise network, such as the one described in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a>.</span></p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-106"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Basic Forest and Domain Information</samp></h4>
<p class="TNI1">Let’s start by gathering some basic information about the forest and domain we’re connected to. You can follow along by executing the commands in <a href="chapter11.xhtml#Lis11-2">Listing 11-2</a> on a computer in the root <i>mineral.local</i> domain of the example forest.</p>
<span id="Lis11-2"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$forest = Get-ADForest</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$forest.Domains</b>
mineral.local
sales.mineral.local
engineering.mineral.local

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$forest.GlobalCatalogs</b>
PRIMARYDC.mineral.local
SALESDC.sales.mineral.local
ENGDC.engineers.mineral.local

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-ADDomain | Format-List PDCEmulator, DomainSID, DNSRoot, NetBIOSName</b>
PDCEmulator : PRIMARYDC.mineral.local
DomainSID   : S-1-5-21-1195776225-522706947-2538775957
DNSRoot     : mineral.local
NetBIOSName : MINERAL

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Get-ADDomainController | Select-Object Name, Domain</b>
Name      Domain
----      ------
PRIMARYDC mineral.local

<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> PS&gt; <b>Get-ADTrust -Filter * | Select-Object Target, Direction, TrustType</b>
Target                     Direction       TrustType
------                     ---------       ---------
engineering.mineral.local  BiDirectional   Uplevel
sales.mineral.local        BiDirectional   Uplevel
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-2: Listing some basic information about the forest and domain</span></p>
<p class="TX">We first request information about the current forest using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADForest</samp> command <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The returned object has many properties, but here we focus on two of them. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Domains</samp> property returns a list of the Domain Name System (DNS) names for the domains in the forest <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In this example, it matches the forest in <a href="chapter11.xhtml#fig11-1">Figure 11-1</a>. We also inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalCatalogs</samp> property, which lists all systems that maintain a copy of the shared global catalog <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We can use these to inspect the forest-level configuration.</p>
<p class="TX"><span aria-label=" Page 345. " epub:type="pagebreak" id="pg_345" role="doc-pagebreak"></span>We then run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADDomain</samp> command, which returns information about the domain to which the current system is connected <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Here, we select four properties. The first one, <samp class="SANS_TheSansMonoCd_W5Regular_11">PDCEmulator</samp>, is the DNS name of the <i>primary domain controller (PDC) emulator</i>. The PDC, which used to be the main domain controller in the local domain, once acted as the definitive user database. (A backup domain controller served as a secondary database, in case the PDC went down.) With the introduction of Active Directory, it became possible to more evenly distribute the authentication workload without the PDC. However, Windows still gives the PDC emulator preferential treatment; for example, when you change your password, the operating system will always first try to change it on the PDC. The PDC also runs the legacy Netlogon service, for backward compatibility with older versions of Windows.</p>
<p class="TX">The next property is the <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainSID</samp>. This SID serves as the basis for all other user and group SIDs in the domain. It’s equivalent to the machine SID we saw in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, but it applies to the entire network. The final two properties are the <samp class="SANS_TheSansMonoCd_W5Regular_11">DNSRoot</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NetBIOSName</samp>. These are the domain’s root DNS name and simple domain name, which Windows keeps around for legacy support reasons.</p>
<p class="TX">A good example of this legacy support involves the names of users in a domain. Officially, you should refer to users with a fully qualified name, the <i>user principal name (UPN)</i>, which takes the form <i>alice@mineral.local</i>. However, in the user interface you use to log in to your computer, you typically won’t enter the UPN as your username; instead, you’d enter something like <i>MINERAL\alice</i>, which we refer to as a <i>down-level logon name</i>.</p>
<p class="TX">Next, we list the domain controllers on the domain the system is connected to using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADDomainController</samp> command <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. We’re inspecting a simple domain, so <a href="chapter11.xhtml#Lis11-2">Listing 11-2</a> contains only a single entry, <samp class="SANS_TheSansMonoCd_W5Regular_11">PRIMARYDC</samp>. As we saw earlier, though, the forest contains multiple domains. We can enumerate the configured trust relationships using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADTrust</samp> command <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. The output reveals all of the trusts to be bidirectional. The third column identifies the type of each domain: <samp class="SANS_TheSansMonoCd_W5Regular_11">Uplevel</samp> indicates that the domain is also based on Active Directory, while a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Downlevel</samp> would represent a pre–Windows 2000 domain.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="h2-107"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Users</samp></h4>
<p class="TNI1">Let’s now list the user account information stored on the Active Directory server. We can do this with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> command, as shown in <a href="chapter11.xhtml#Lis11-3">Listing 11-3</a>.</p>
<span id="Lis11-3"></span><pre><code>PS&gt; <b>Get-ADUser -Filter * | Select-Object SamAccountName, Enabled, SID</b>
SamAccountName Enabled SID
-------------- ------- ---
Administrator     True S-1-5-21-1195776225-522706947-2538775957-500
Guest            False S-1-5-21-1195776225-522706947-2538775957-501
krbtgt           False S-1-5-21-1195776225-522706947-2538775957-502
bob               True S-1-5-21-1195776225-522706947-2538775957-1108
alice            <b> </b>True S-1-5-21-1195776225-522706947-2538775957-1110
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-3: Displaying the Active Directory server’s users</span></p>
<p class="TX"><span aria-label=" Page 346. " epub:type="pagebreak" id="pg_346" role="doc-pagebreak"></span>Using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> is like using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>, except that you need to specify a filter. In <a href="chapter11.xhtml#Lis11-3">Listing 11-3</a> we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> to get all users, but on a real network you’ll find filtering important to reduce the output, as the Active Directory server could contain hundreds or thousands of users.</p>
<p class="TX">The output shows each user’s plain username (in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamAccountName</samp> column), whether the user is enabled, and their SID. As with the local users, each SID has a common prefix that should match the domain SID from <a href="chapter11.xhtml#Lis11-2">Listing 11-2</a>.</p>
<p class="TX">The user’s password is stored in a special write-only attribute in the Active Directory server. We can’t read this password from outside the domain controller except via backups of the directory or when the directory is replicated between domain controllers.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-108"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Groups</samp></h4>
<p class="TNI1">To list the security groups in the Active Directory server, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroup</samp> command (<a href="chapter11.xhtml#Lis11-4">Listing 11-4</a>).</p>
<span id="Lis11-4"></span><pre><code>PS&gt; <b>Get-ADGroup -Filter * | Select-Object SamAccountName, SID, GroupScope</b>
SamAccountName    SID                                           GroupScope
--------------    ---                                           ----------
Administrators    S-1-5-32-544                                  DomainLocal
Users             S-1-5-32-545                                  DomainLocal
Guests            S-1-5-32-546                                  DomainLocal
<var>--snip--</var>
Enterprise Admins S-1-5-21-1195776225-522706947-2538775957-519  Universal
Cert Publishers   S-1-5-21-1195776225-522706947-2538775957-517  DomainLocal
Domain Admins     S-1-5-21-1195776225-522706947-2538775957-512  Global
Domain Users      S-1-5-21-1195776225-522706947-2538775957-513  Global
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-4: Displaying the Active Directory server’s groups</span></p>
<p class="TX">Notice that the output includes both <i>BUILTIN</i> groups, such as <i>Administrators</i>, and domain groups, such as <i>Enterprise Admins</i>. You can easily distinguish these group types based on the domain SID used as the prefix of a group’s SID. In this example, the domain SID prefix is <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-21-1195776225-522706947-2538775957</samp>.</p>
<p class="TX">The system uses the <i>BUILTIN</i> groups only when a user authenticates to the domain controller. For example, adding a user to the <i>BUILTIN\Administrators</i> group would grant that user administrator access to the database on the domain controller, but not on any other machine in the network. On the other hand, the domain groups get added to the user’s token when they authenticate, and they can be used for access checks on the local computer.</p>
<p class="TX">Domain groups can have three possible scopes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group scope is visible to the entire forest. While any domain in the forest can use the group, it contains users or groups in the defining domain only. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group is equivalent to the group object in the SAM configuration we covered in the previous chapter. By contrast, a <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp> group is visible only <span aria-label=" Page 347. " epub:type="pagebreak" id="pg_347" role="doc-pagebreak"></span>in the defining domain, but it can contain any user or group from any trusted domain. It’s equivalent to the alias object in the SAM database.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> group scope combines the global visibility and broad membership of the two other scopes: groups in this scope are visible to the entire forest and can contain any user or group.</p>
<p class="TX">To highlight the distinction between the <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group scopes, let’s consider the difference between two groups, <i>Enterprise Admins</i> and <i>Domain Admins</i>. <i>Enterprise Admins</i> includes all the users who can manage a forest. While there should be only one instance of this group, defined in the root domain, you might want to be able to add any user across the forest as a member. Therefore, as you can see in <a href="chapter11.xhtml#Lis11-4">Listing 11-4</a>, it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> group. All domains can use it, and it can contain anyone.</p>
<p class="TX">In contrast, <i>Domain Admins</i> contains users who are administrators of a single domain. Other domains might use the group as a resource if it is configured to grant them access, but it restricts its membership to the defining domain. Therefore, it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group. If you’re managing only a single domain, the differences between these scopes aren’t particularly relevant.</p>
<p class="TX">The SAM remote service would return <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp> groups when you enumerate alias objects and both <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> groups when you enumerate group objects. You might find it odd that the service returns <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> groups as group objects; after all, the APIs used to manipulate group object members allow you to specify a member using the domain’s relative ID only, preventing you from using the SAM remote service to modify a <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> group if it has any members outside of the domain. In any case, you shouldn’t really use the SAM remote service to manage an Active Directory domain.</p>
<p class="TX">You can list the members of an Active Directory server group using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroupMember</samp> command, as shown in <a href="chapter11.xhtml#Lis11-5">Listing 11-5</a>.</p>
<span id="Lis11-5"></span><pre><code>PS&gt; <b>Get-ADGroupMember -Identity Administrators | Select Name, objectClass</b>
Name              objectClass
----              -----------
Domain Admins     group
Enterprise Admins group
Administrator     user

PS&gt; <b>Get-LocalGroupMember -Name Administrators</b>
ObjectClass Name                   PrincipalSource
----------- ----                   ---------------
Group       MINERAL\Domain Admins  ActiveDirectory
User        MINERAL\alice          ActiveDirectory
User        GRAPHITE\admin         Local
User        GRAPHITE\Administrator Local
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-5: Displaying</span> <samp class="SANS_Futura_Std_Book_11">Administrators</samp> <span class="Futura_Std_Book_Oblique_I_11">group members once they’ve joined the domain</span></p>
<p class="TX">Here, we enumerate the members of the <i>BUILTIN\Administrators</i> group on the domain controller. Because this is a <i>BUILTIN</i> group, users receive membership to the group only once they’ve authenticated to the domain controller.</p>
<p class="TX"><span aria-label=" Page 348. " epub:type="pagebreak" id="pg_348" role="doc-pagebreak"></span>However, when you join a computer to a domain, you can modify the local groups on that computer to include domain groups. For example, when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroupMember</samp> to list the members of the local <i>BUILTIN\Administrators</i> group, we see that the <i>Domain Admins</i> group from the domain has been added as a member. This change allows all administrators in the domain to be local administrators on any computer in the domain.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-109"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Computers</samp></h4>
<p class="TNI1">When you join a computer to a domain, an account is created in the domain. These special user accounts grant the computer access to certain domain services before any user has authenticated to the system. The computer account is especially important for configuring the group policy, as well as for authenticating users to the system, as we’ll see in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>
<p class="TX">You can list the computer accounts on the Active Directory server using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> command, shown in <a href="chapter11.xhtml#Lis11-6">Listing 11-6</a>.</p>
<span id="Lis11-6"></span><pre><code>PS&gt; <b>Get-ADComputer -Filter * | Select-Object SamAccountName, Enabled, SID</b>
SamAccountName Enabled SID
-------------- ------- ---
PRIMARYDC$        True S-1-5-21-1195776225-522706947-2538775957-1000
GRAPHITE$         True S-1-5-21-1195776225-522706947-2538775957-1104
CINNABAR$         True S-1-5-21-1195776225-522706947-2538775957-1105
TOPAZ$            True S-1-5-21-1195776225-522706947-2538775957-1106
PYRITE$           True S-1-5-21-1195776225-522706947-2538775957-1109
HEMATITE$         True S-1-5-21-1195776225-522706947-2538775957-1113
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-6: Displaying the computer account SIDs</span></p>
<p class="TX">As this output shows, the computer account names usually have a trailing dollar sign character (<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>), which makes it easy to differentiate computer accounts from user accounts. We can also see once again that the SIDs use the domain SID as a prefix. (The computers themselves continue to store their own separate machine SIDs in the local SAM database.)</p>
<p class="TX">A computer account needs a password to authenticate to the domain, and the domain-joined computer and domain controller automatically manage this password. By default, the computer generates a new complex password every 30 days and changes it on the domain controller. As the computer must change the password without user interaction, it stores the password in an LSA secret object called <samp class="SANS_TheSansMonoCd_W5Regular_11">$MACHINE.ACC</samp>.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-7">Listing 11-7</a> shows how to query a computer’s LSA secret using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -LsaPrivateData</samp> command. You’ll need to run this command as an administrator. It’s similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSecret</samp> command we saw in the previous chapter, except we don’t need to manually open the policy and secret objects.</p>
<span id="Lis11-7"></span><pre><code>PS&gt; <b>Get-LsaPrivateData '$MACHINE.ACC' | Out-HexDump -ShowAll</b>
          00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
00000000: 00 00 00 01 5F 5D 25 70 36 13 17 41 92 57 5F 50  - ...._]%p6..A.W_P
00000010: 89 EA AA 35 03 00 00 00 00 00 00 00 94 B1 CD 81  - ...5............
00000020: 98 86 67 2A 31 17 1B E1 2F 5D 78 48 7B ED 0C 95  - ..g*1.../]xH{...
<var>--snip--</var>
</code></pre>
<span aria-label=" Page 349. " epub:type="pagebreak" id="pg_349" role="doc-pagebreak"></span>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-7: Querying the $MACHINE.ACC LSA secret</span></p>
<p class="TX">The LSA obfuscates the contents of the secret object, so just reading the value isn’t enough to extract the password used for the computer account.</p>
<p class="TX">We’ve performed a high-level exploration of an Active Directory server configuration. Let’s now look at how the directory is configured at a low level, so we can understand how it is secured.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="h1-83"></span><samp class="SANS_Futura_Std_Bold_B_11">Objects and Distinguished Names</samp></h3>
<p class="TNI1">Although we can use the commands in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp> module to access the user configuration, these commands hide the real structure of the Active Directory server, which consists of a hierarchical tree of entries, as shown in <a href="chapter11.xhtml#fig11-2">Figure 11-2</a>.</p>
<figure class="IMG"><img alt="" class="img1" height="764" id="fig11-2" src="../images/Figure11-2.jpg" width="1528"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: The structure of an Active Directory server</samp></p></figcaption>
</figure>
<p class="TX">There are a few different types of entries, but the only ones we care about are <i>objects</i>, which store the user configuration. To refer to an object in the tree, we use its <i>distinguished name</i>, which must be unique across the directory. The distinguished name is a sequence of one or more <i>relative distinguished names</i> separated by commas. In the Active Directory server, you’re most likely to encounter the following relative distinguished name types:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">C   </samp>The country name</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CN  </samp>The common name</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DC  </samp>The domain component</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O   </samp>The organization name</p>
<p class="RunInPara"><span aria-label=" Page 350. " epub:type="pagebreak" id="pg_350" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W7Bold_B_11">OU  </samp>The organizational unit name</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ST  </samp>The state or province name</p>
<p class="TX">For example, at the root of the directory is the domain object <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which has the domain name <samp class="SANS_TheSansMonoCd_W5Regular_11">DC=mineral,DC=local</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DC</samp> relative distinguished name represents a domain component that is part of a DNS name. Taken together, this distinguished name represents the <i>mineral.local</i> DNS name of the domain.</p>
<p class="TX">Underneath the root object is a tree of objects that describe the configuration of the domain. I’ve shown only three of them in <a href="chapter11.xhtml#fig11-2">Figure 11-2</a>. <samp class="SANS_TheSansMonoCd_W5Regular_11">CN</samp> refers to a common name, a simple label for the object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Users</samp> object <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> contains the user and group objects for the domain. The other two objects, <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Builtin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Computers</samp>, contain group accounts for the <i>BUILTIN</i> domain on the domain controller and the list of computer accounts, respectively.</p>
<p class="TX">To refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp> object, you would use its full distinguished name, <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Users,DC=mineral,DC=local</samp>. Each user object could contain further objects, but it’s more common for them to contain only a list of attribute values that represent the user’s configuration <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. For example, a user object might contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">userPrincipalName</samp> attribute, representing the UPN of the user in the Active Directory server.</p>
<p class="TX">Each object can also contain an <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp> attribute with a GUID that uniquely identifies the object. Although unique, the distinguished name cannot consistently identify an object, as it would change if the object were moved or renamed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp> attribute stays the same even if the distinguished name changes.</p>
<p class="TX">Two separate root objects store administrative information for the domain root. These are the configuration object <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and the schema object <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The information stored in the configuration object matters to Active Directory security, and the schema object defines the directory’s structure. We’ll discuss both objects in more depth in later sections.</p>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-110"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enumerating Directory Objects</samp></h4>
<p class="TNI1">Default installations of the Active Directory server use well-known distinguished names, configurations, and schema objects. However, an administrator can change these names or add new directories to the database. For that reason, the Active Directory server exposes a special directory entry called the <i>Root Directory System Agent-Specific Entry (RootDSE)</i> that contains high-level configuration for the directory.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-8">Listing 11-8</a> shows how to access the RootDSE entry for the current domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADRootDSE</samp> command.</p>
<span id="Lis11-8"></span><pre><code>PS&gt; <b>Get-ADRootDSE | Format-List '*NamingContext'</b>
configurationNamingContext : CN=Configuration,DC=mineral,DC=local
defaultNamingContext       : DC=mineral,DC=local
rootDomainNamingContext    : DC=mineral,DC=local
schemaNamingContext        : CN=Schema,CN=Configuration,DC=mineral,DC=local
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-8: Inspecting the RootDSE entry for the current domain</span></p>
<p class="TX"><span aria-label=" Page 351. " epub:type="pagebreak" id="pg_351" role="doc-pagebreak"></span>As properties, we select the distinguished names for the <i>naming contexts</i>, which represent the top-level objects in the directory. Using these naming contexts, we can query objects on the Active Directory server with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command (<a href="chapter11.xhtml#Lis11-9">Listing 11-9</a>).</p>
<span id="Lis11-9"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$root_dn = (Get-ADRootDSE).defaultNamingContext</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-ADObject -SearchBase $root_dn -SearchScope OneLevel -Filter * |</b>
<b>Select-Object DistinguishedName, ObjectClass</b>
DistinguishedName                                ObjectClass
-----------------                                -----------
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> CN=Builtin,DC=mineral,DC=local                   builtinDomain
CN=Computers,DC=mineral,DC=local                 container
OU=Domain Controllers,DC=mineral,DC=local        organizationalUnit
CN=ForeignSecurityPrincipals,DC=mineral,DC=local container
<var>--snip--</var>

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-ADObject -Identity "CN=Builtin,$root_dn" | Format-List</b>
DistinguishedName : CN=Builtin,DC=mineral,DC=local
Name              : Builtin
ObjectClass       : builtinDomain
ObjectGUID        : 878e2263-2496-4a56-9c6e-7b4db24a6bed

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Get-ADObject -Identity "CN=Builtin,$root_dn" -Properties * | Format-List</b>
CanonicalName        : mineral.local/Builtin
CN                   : Builtin
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-9: Querying for the Active Directory server’s objects</span></p>
<p class="TX">First we get the root domain naming context from the RootDSE <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This naming context represents the distinguished name for the directory’s root domain object, which we can use to query for objects.</p>
<p class="TX">We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command to query the child objects of the root <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The command takes various options to limit the scope of the child objects to return. The first is the <samp class="SANS_TheSansMonoCd_W5Regular_11">SearchBase</samp> parameter, which returns only the children of a certain object (in this case, only the default naming context). We’ve supplied the default value here, which is unnecessary, but the parameter is useful in other cases.</p>
<p class="TX">The second option is the <samp class="SANS_TheSansMonoCd_W5Regular_11">SearchScope</samp> parameter, which determines how recursive the search should be. We specify <samp class="SANS_TheSansMonoCd_W5Regular_11">OneLevel</samp> to search only the immediate children of the search base. Other values include <samp class="SANS_TheSansMonoCd_W5Regular_11">Base</samp>, which returns only the search base object, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtree</samp>, which recursively searches all child objects. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp> parameter limits the values returned. In this case, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> to return everything.</p>
<p class="TX">The output includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistinguishedName</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp> attributes <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp> attribute represents the name of the schema type, which we’ll come back to in <span class="Xref">“The Schema” on page 353</span>. We can select a specific distinguished name by specifying it as the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp> parameter <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The object returned contains a list of the directory object’s attributes as PowerShell properties. For example, we can see the <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp> attribute, which represents the object’s unique identifier.</p>
<p class="TX"><span aria-label=" Page 352. " epub:type="pagebreak" id="pg_352" role="doc-pagebreak"></span>In this case, the command returns only four values. For performance reasons, it queries for a small set of attributes, as some of the attribute values can be quite large. To query for more attributes, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Properties</samp> parameter, passing it either a list of attribute names or <samp class="SANS_TheSansMonoCd_W7Bold_B_11">*</samp> to return all attributes <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-111"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Objects in Other Domains</samp></h4>
<p class="TNI1">What if you’re on a computer in one domain of the forest and want to access the Active Directory server for another domain? You might attempt to use the distinguished name of the object you’re interested in, as in <a href="chapter11.xhtml#Lis11-10">Listing 11-10</a>.</p>
<span id="Lis11-10"></span><pre><code>PS&gt; <b>Get-ADObject -Identity 'CN=Users,DC=sales,DC=mineral,DC=local'</b>
Get-ADObject : Cannot find an object with identity: 'CN=Users,DC=sales,
DC=mineral,DC=local' under: 'DC=mineral,DC=local'.
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-10: Trying to access another domain’s Active Directory</span></p>
<p class="TX">As you can see, trying to access an object in another domain’s Active Directory server fails; the command tries to search for a child object with the specified distinguished name and can’t find it.</p>
<p class="TX">To view the Active Directory server from another domain, you have a couple of options, shown in <a href="chapter11.xhtml#Lis11-11">Listing 11-11</a>.</p>
<span id="Lis11-11"></span><pre><code>PS&gt; <b>$dn = 'CN=Users,DC=sales,DC=mineral,DC=local</b><b>'</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$obj_sales = Get-ADObject -Identity $dn -Server SALES -Properties *</b>
PS&gt; <b>$obj_sales.DistinguishedName</b>
CN=Users,DC=sales,DC=mineral,DC=local

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$obj_gc = Get-ADObject -Identity $dn -Server :3268 -Properties *</b>
PS&gt; <b>$obj_gc.DistinguishedName</b>
CN=Users,DC=sales,DC=mineral,DC=local

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>($obj_sales | Get-Member -MemberType Property | Measure-Object).Count</b>
28
PS&gt; <b>($obj_gc | Get-Member -MemberType Property | Measure-Object).Count</b>
25
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-11: Accessing the Active Directory server’s objects in another domain</span></p>
<p class="TX">The first option is to explicitly specify the target domain using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> parameter <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This parameter accepts the domain’s simple name or DNS name, as well as the hostname of a domain controller within the domain. In this case, we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">SALES</samp>, and because this domain is part of our forest, the query returns a suitable domain controller.</p>
<p class="TX">The second option is to query the global catalog. As <a href="chapter11.xhtml#Lis11-2">Listing 11-2</a> showed, servers in the domain manage this catalog using data copied from other Active Directory servers. Select the global catalog by specifying the well-known port <samp class="SANS_TheSansMonoCd_W5Regular_11">3268</samp> as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> parameter <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In this example, we specify no domain or server name, which selects the global catalog in the current <span aria-label=" Page 353. " epub:type="pagebreak" id="pg_353" role="doc-pagebreak"></span>domain by default. If you wanted to, however, you could query the global catalog in another domain by prefixing the port with its name.</p>
<p class="TX">One thing to keep in mind is that the global catalog contains merely a subset of the full data in the Active Directory server. If we count the number of properties returned, we see that the object contains 28 properties <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, whereas the global catalog version of it returns only 25. For certain object classes, the difference in property counts might be even more pronounced.</p>
<p class="TX">You might wonder: Why wouldn’t you just query the domain directly for Active Directory information? Basically, it’s a question of locality. The domain on which you’re running the command might live on the other side of the world from the target domain, joined by a high-latency satellite link. Querying the target directly might be slow, expensive, or both. By contrast, the local global catalog might live on a domain controller in the next office, which offers convenience, even if it won’t provide the same level of detail.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="h1-84"></span><samp class="SANS_Futura_Std_Bold_B_11">The Schema</samp></h3>
<p class="TNI1">The Active Directory server’s schema describes the classes of object that exist, the attributes those classes might contain, and the relationships between classes. Each object in the directory is assigned to one or more classes; for example, a group is of the class <samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp>. You can find an object’s class in its <samp class="SANS_TheSansMonoCd_W5Regular_11">objectClass</samp> attribute.</p>
<p class="TX">Each object class has a corresponding schema type. The schema can organize these types in a hierarchy, as shown in <a href="chapter11.xhtml#fig11-3">Figure 11-3</a>.</p>
<figure class="IMG"><img alt="" class="img1" height="643" id="fig11-3" src="../images/Figure11-3.jpg" width="1352"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A schema hierarchy for the group, user, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">computer classes</samp></p></figcaption>
</figure>
<p class="TX">All schema class types derive from a base type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp> class <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, and each class object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">subClassOf</samp> attribute specifies the classes from which it derives. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp> type <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> specifies <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp> as its only <samp class="SANS_TheSansMonoCd_W5Regular_11">subClassOf</samp> value.</p>
<p class="TX">Each class type can also include a list of the attributes that an instance of the class can contain <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This list is split into <samp class="SANS_TheSansMonoCd_W5Regular_11">mustContain</samp>, for required attributes, and <samp class="SANS_TheSansMonoCd_W5Regular_11">mayContain</samp>, for optional ones. In <a href="chapter11.xhtml#fig11-3">Figure 11-3</a>, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">mustContain</samp> attribute has the required <samp class="SANS_TheSansMonoCd_W5Regular_11">groupType</samp> attribute, used to indicate <span aria-label=" Page 354. " epub:type="pagebreak" id="pg_354" role="doc-pagebreak"></span>whether the group is <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp>. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> attribute, which contains the list of members of the group, is optional, as a group could have no members.</p>
<p class="TX">A second set of attribute lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">systemMustContain</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">systemMayContain</samp>, hold required and optional attributes that only the Active Directory server can modify; a normal user can’t change these.</p>
<p class="TX">Not all class schema types are as simple as <samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp>. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> class <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> is a subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">organizationalPerson</samp>, which itself is a subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">person</samp>, which in turn is a subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>. Each of these schema class types can contribute required and optional attributes to the final subclass object.</p>
<p class="TX">A class can also contain lists of auxiliary classes, defined with the <samp class="SANS_TheSansMonoCd_W5Regular_11">auxiliaryClass</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">systemAuxiliaryClass</samp> attributes <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. We can use these classes to add additional attributes to a schema class without making them part of the inheritance hierarchy.</p>
<p class="TX">Each class has an <samp class="SANS_TheSansMonoCd_W5Regular_11">objectClassCategory</samp> attribute to define how the class can be used. It can be one of the following values:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Structural  </samp>The class can be used as an object.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Abstract  </samp>The class can be used for inheritance only.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Auxiliary  </samp>The class can be used as an auxiliary only.</p>
<p class="TX">An additional type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Class88</samp>, represents classes that were defined in the oldest LDAP specifications. Only certain system classes use this type, and new schema classes shouldn’t use it.</p>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="h2-112"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting the Schema</samp></h4>
<p class="TNI1">We can inspect the schema using the same tools we would use to inspect user or group objects. An administrator can also modify the schema to add new types and attributes. For example, the Exchange mail server might modify the Active Directory server on which it’s installed to add additional email address attributes for user objects.</p>
<p class="TX">As the schema is part of the directory, we can inspect it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command, as shown in <a href="chapter11.xhtml#Lis11-12">Listing 11-12</a>.</p>
<span id="Lis11-12"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$schema_dn = (Get-ADRootDSE).schemaNamingContext</b>
PS&gt; <b>Get-ADObject -SearchBase $schema_dn -SearchScope OneLevel -Filter *</b> <b>|</b>
<b>Sort-Object Name | Select-Object Name, ObjectClass</b>
Name                    ObjectClass
----                    -----------
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> account                 classSchema
Account-Expires         attributeSchema
Account-Name-History    attributeSchema
<var>--snip--</var>

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-ADObject -SearchBase $schema_dn -Filter {</b>
<b>    ObjectClass -eq "classSchema"</b>
<b>} -Properties * | Sort-Object Name |</b>
<b>Format-List Name, {[guid]$_.schemaIDGUID}, mayContain,</b>
<b>mustContain, systemMayContain, systemMustContain, auxiliaryClass,</b>
<b>systemAuxiliaryClass,</b> <b>SubClassOf</b>
<span aria-label=" Page 355. " epub:type="pagebreak" id="pg_355" role="doc-pagebreak"></span>Name                  : account
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> [guid]$_.schemaIDGUID : 2628a46a-a6ad-4ae0-b854-2b12d9fe6f9e
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> mayContain            : {uid, host, ou, o...}
mustContain           : {}
systemMayContain      : {}
systemMustContain     : {}
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> auxiliaryClass        : {}
systemAuxiliaryClass  : {}
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> SubClassOf            : top
<var>--snip--</var>

<span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> PS&gt; <b>Get-ADObject -SearchBase $schema_dn -Filter {</b>
    <b>lDAPDisplayName -eq "uid"</b>
<b>} -Properties * | Format-List adminDescription, {[guid]$_.schemaIDGUID},</b>
<b>attributeSyntax, oMSyntax, oMObjectClass</b>
adminDescription      : A user ID.
[guid]$_.schemaIDGUID : 0bb0fca0-1e89-429f-901a-1413894d9f59
attributeSyntax       : 2.5.5.12
oMSyntax              : 64
oMObjectClass         :
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-12: Enumerating schema objects</span></p>
<p class="TX">We start by querying for all objects under the schema’s naming context and displaying them to the shell <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The output shows the name of each schema object and its object class <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can see two classes, <samp class="SANS_TheSansMonoCd_W5Regular_11">classSchema</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">attributeSchema</samp>, which represent the schema types for object classes and attributes, respectively.</p>
<p class="TX">Next, we query for the schema objects and attributes again, but this time we use a filter to select only the objects whose <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp> attribute is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">classSchema</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp> property takes a PowerShell-style expression that can filter the returned objects based on the object’s attributes. The server evaluates this filter to improve performance, as it won’t return objects that don’t match the filter.</p>
<p class="TX">Note that the filter string isn’t a full PowerShell script, even though it uses a similar syntax, so you can’t perform complex scripting operations in the filter. The commands in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp> module also support the <samp class="SANS_TheSansMonoCd_W5Regular_11">LDAPFilter</samp> parameter, which uses the LDAP specification’s somewhat less intuitive filtering syntax. (Technically, even if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp> parameter, PowerShell will convert it to an LDAP filter before sending the query to the LDAP server, as Active Directory doesn’t yet execute PowerShell code directly.)</p>
<p class="TX">The returned class objects appear in the console, where I’ve highlighted some of their important attributes. The first is the <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp> attribute <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, which represents the unique identifier for the schema type. Microsoft documents most of these schema identifiers, although an administrator can also add their own. The directory stores the <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp> attribute as an array of bytes, so we convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">guid</samp> object to view the value more easily.</p>
<p class="TX">Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp> won’t match the <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp> attribute assigned to the object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp> should be unique in the directory, but it won’t <span aria-label=" Page 356. " epub:type="pagebreak" id="pg_356" role="doc-pagebreak"></span>necessarily be unique globally. The <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp> should have the same value across all instances of the Active Directory server.</p>
<p class="TX">The next four attributes <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> represent the lists of attributes the class can contain. In this case, only <samp class="SANS_TheSansMonoCd_W5Regular_11">mayContain</samp>, the list of optional class attributes, has any values. Each entry is identified by a name that is unique across the Active Directory server.</p>
<p class="TX">These lists are not exhaustive, however; in addition to these, the class could also incorporate attributes from its configured auxiliary classes (although in this example, none are listed <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>). It will also incorporate any attributes inherited from the parent, which you can find in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubClassOf</samp> attribute <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. To get the full list of attributes a class could contain, you need to enumerate the entire inheritance chain and all auxiliary classes.</p>
<p class="TX">Because it’s unique, we can return an attribute’s schema type by specifying a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">lDAPDisplayName</samp> attribute value. In this case, we use the first value in the attribute list, <samp class="SANS_TheSansMonoCd_W5Regular_11">uid</samp> <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>, and display a few of the schema type’s attributes, including a description of the attribute and the <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H2" id="sec13"><span id="h2-113"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the Security Attributes</samp></h4>
<p class="TNI1">As you just witnessed, manually inspecting the schema is a convoluted process. Still, we need to understand the schema to analyze the security of the directory. For that reason, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module comes with some commands that return the schema’s security-specific attributes. <a href="chapter11.xhtml#Lis11-13">Listing 11-13</a> shows the simplest of these commands, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaClass</samp>.</p>
<span id="Lis11-13"></span><pre><code>PS&gt; <b>Get-DsSchemaClass | Sort-Object Name</b>
Name              SchemaId                             Attributes
----              --------                             ----------
account           2628a46a-a6ad-4ae0-b854-2b12d9fe6f9e 7
aCSPolicy         7f561288-5301-11d1-a9c5-0000f80367c1 17
aCSResourceLimits 2e899b04-2834-11d3-91d4-0000f87a57d4 5
aCSSubnet         7f561289-5301-11d1-a9c5-0000f80367c1 26
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-13: Enumerating all schema classes</span></p>
<p class="TX">When we specify no parameters, the command looks up all class type objects from the schema and returns them. The output shows each type’s LDAP name and schema identifier, as well as the total number of attributes the type can contain, including all required and system attributes.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Depending on the complexity of the schema and speed of the network, querying for all schema types can take a while. Once the command has downloaded the types, however, it will cache them, so you should receive a rapid response the next time you request them in the same PowerShell session.</i></p>
</blockquote>
<p class="TX"><a href="chapter11.xhtml#Lis11-14">Listing 11-14</a> shows how to inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">account</samp> type using the module’s commands.</p>
<span id="Lis11-14"></span><pre><code><span aria-label=" Page 357. " epub:type="pagebreak" id="pg_357" role="doc-pagebreak"></span>PS&gt; <b>$cls = Get-DsSchemaClass -Name "account"</b>
PS&gt; <b>$cls | Format-List</b>
Name        : account
CommonName  : account
Description : The account object class is used to define entries...
SchemaId    : 2628a46a-a6ad-4ae0-b854-2b12d9fe6f9e
SubClassOf  : top
Category    : Structural
Attributes  : {uid, host, ou, o...}

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$cls.Attributes</b>
Name        Required System
----        -------- ------
uid            False  False
host           False  False
ou             False  False
o              False  False
l              False  False
seeAlso        False  False
description    False  False

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$cls.Attributes | Get-DsSchemaAttribute</b>
Name        SchemaId                             AttributeType
----        --------                             -------------
uid         0bb0fca0-1e89-429f-901a-1413894d9f59 String(Unicode)
host        6043df71-fa48-46cf-ab7c-cbd54644b22d String(Unicode)
ou          bf9679f0-0de6-11d0-a285-00aa003049e2 String(Unicode)
o           bf9679ef-0de6-11d0-a285-00aa003049e2 String(Unicode)
l           bf9679a2-0de6-11d0-a285-00aa003049e2 String(Unicode)
seeAlso     bf967a31-0de6-11d0-a285-00aa003049e2 Object(DS-DN)
description bf967950-0de6-11d0-a285-00aa003049e2 String(Unicode)

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-DsSchemaClass -Parent $cls -Recurse</b>
Name SchemaId                             Attributes
---- --------                             ----------
top  bf967ab7-0de6-11d0-a285-00aa003049e2 125
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-14: Inspecting a single class schema type</span></p>
<p class="TX">You can specify the name of the class using either the LDAP name with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> parameter or the schema identifier with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SchemaId</samp> parameter.</p>
<p class="TX">The returned object contains an <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp> property, which holds the list of all attributes for the class <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Rather than including separate attribute lists, the command assigns each attribute the <samp class="SANS_TheSansMonoCd_W5Regular_11">Required</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> properties to indicate the list from which they were sourced.</p>
<p class="TX">To get more information about the attributes, you can pipe them into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaAttribute</samp> command, which looks up the schema attribute type <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This command returns the LDAP name (<samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>) and schema identifier (<samp class="SANS_TheSansMonoCd_W5Regular_11">SchemaId</samp>) properties, as well as a decoded attribute type (<samp class="SANS_TheSansMonoCd_W5Regular_11">AttributeType</samp>). We can see, for example, that the <samp class="SANS_TheSansMonoCd_W5Regular_11">uid</samp> type is a Unicode string, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">seeAlso</samp> type is a string that contains a distinguished name.</p>
<p class="TX"><span aria-label=" Page 358. " epub:type="pagebreak" id="pg_358" role="doc-pagebreak"></span>Finally, you can directly look up the parent class by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parent</samp> parameter and specifying the existing class object <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. You can also specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp> parameter to recursively enumerate all parents. In this case, the only parent class is <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>, but querying a more complex class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>, would return several more schema classes.</p>
</section>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H1" id="sec14"><span id="h1-85"></span><samp class="SANS_Futura_Std_Bold_B_11">Security Descriptors</samp></h3>
<p class="TNI1">Almost any time we must secure a resource in Windows, we’ll turn to security descriptors and access checking, and with Active Directory it’s no different. LDAP supports authentication, and the Active Directory server uses it to create a token that represents the user. It then uses this token to determine what objects and attributes a given user can manipulate. Let’s begin by discussing how to query and store security descriptors on the Active Directory server.</p>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="h2-114"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Querying Security Descriptors of Directory Objects</samp></h4>
<p class="TNI1">Each directory object is assigned a security descriptor when it’s created. The object stores this security descriptor as a byte array in a mandatory attribute named <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp>. As this attribute is defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp> class, all object classes require it. <a href="chapter11.xhtml#Lis11-15">Listing 11-15</a> checks the attribute schema class and shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">Required</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>
<span id="Lis11-15"></span><pre><code>PS&gt; <b>(Get-DsSchemaClass top).Attributes |</b>
<b>Where-Object Name -Match nTSecurityDescriptor</b>
Name                 Required System
----                 -------- ------
nTSecurityDescriptor     True   True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-15: Checking the nTSecurityDescriptor attribute in the top class</span></p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>The lowercase</i> <span class="note_Italic">n</span> <i>in the name <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nTSecurityDescriptor</samp> might look odd, but it’s correct. While LDAP name lookups are case insensitive, the names themselves are defined using lower camel case.</i></p>
</blockquote>
<p class="TX">To read the security descriptor, the user must be granted either <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access rights on the object, depending on the parts of the security descriptor they’ve requested. <a href="chapter11.xhtml#Lis11-16">Listing 11-16</a> shows two techniques for retrieving the security descriptor of an Active Directory server object.</p>
<span id="Lis11-16"></span><pre><code>PS&gt; <b>$root_dn = (Get-ADRootDSE).defaultNamingContext</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$obj = Get-ADObject -Identity $root_dn -Properties "nTSecurityDescriptor"</b>
PS&gt; <b>$obj.nTSecurityDescriptor.Access</b>
ActiveDirectoryRights : ReadProperty
InheritanceType       : None
ObjectType            : 00000000-0000-0000-0000-000000000000
InheritedObjectType   : 00000000-0000-0000-0000-000000000000
<span aria-label=" Page 359. " epub:type="pagebreak" id="pg_359" role="doc-pagebreak"></span>ObjectFlags           : None
AccessControlType     : Allow
IdentityReference     : Everyone
IsInherited           : False
InheritanceFlags      : None
PropagationFlags      : None
<var>--snip--</var>

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Format-Win32SecurityDescriptor -Name $root_dn -Type Ds</b>
Path: DC=mineral,DC=local
Type: DirectoryService
Control: DaclPresent, DaclAutoInherited

&lt;Owner&gt;
 - Name  : BUILTIN\Administrators
 - Sid   : S-1-5-32-544

&lt;Group&gt;
 - Name  : BUILTIN\Administrators
 - Sid   : S-1-5-32-544

&lt;DACL&gt; (Auto Inherited)
 - Type  : AllowedObject
 - Name  : BUILTIN\Pre-Windows 2000 Compatible Access
 - SID   : S-1-5-32-554
 - Mask  : 0x00000010
 - Access: ReadProp
 - Flags : ContainerInherit, InheritOnly
 - ObjectType: 4c164200-20c0-11d0-a768-00aa006e0529
 - InheritedObjectType: 4828cc14-1437-45bc-9b07-ad6f015e5f28
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-16: Accessing the security descriptor for the root object</span></p>
<p class="TX">The first technique queries the object’s security descriptor using <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command automatically converts the security descriptor to an instance of the .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectorySecurity</samp> class, so we can show its DACL using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> property.</p>
<p class="TX">The second technique uses the Win32 security descriptor commands from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ds</samp> type and the pathname as the distinguished name of the object. In this example, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32SecurityDescriptor</samp> command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> to get the security descriptor and immediately format it.</p>
<p class="TX">When might you choose to use one technique over the other? The Win32 security descriptor commands are a better option if you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module installed, as they don’t modify the information retrieved from the security descriptor. For example, you might notice that the first ACE in the DACL returned from each command isn’t the same. One belongs to the <i>Everyone</i> user, whereas the other belongs to <i>BUILTIN\Pre-Windows 2000 Compatible Access</i>.</p>
<p class="TX">The difference comes from the fact that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectorySecurity</samp> class, which the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command uses to return the security descriptor <span aria-label=" Page 360. " epub:type="pagebreak" id="pg_360" role="doc-pagebreak"></span>from its attribute, automatically canonicalizes the DACL before allowing the user access to it. The canonicalization process might hide security misconfigurations. The Win32 command doesn’t do any canonicalization.</p>
<p class="TX">Note that if you access the domain controller via the SAM remote service, you’ll really be accessing the Active Directory server’s user configuration, not a local SAM database. But if you inspect the security descriptors for the various supported objects, the SAM remote service won’t return the Active Directory ones. Instead, the LSA will pick a security descriptor from a predefined set, choosing the one that most closely matches the one in the directory object. This is just for show, though; ultimately, any access checks will occur against the security descriptor stored in the Active Directory server.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-115"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Security Descriptors to New Directory Objects</samp></h4>
<p class="TNI1">When we create a new Active Directory object, we can assign it a security descriptor by providing a byte array for the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp> attribute. <a href="chapter11.xhtml#Lis11-17">Listing 11-17</a> shows how to set this security descriptor when running PowerShell as a domain administrator. Don’t run these commands in a production environment, where modifying Active Directory could have adverse effects.</p>
<span id="Lis11-17"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Type DirectoryService</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid BuiltinAdministrators</b>
<b>-Access All</b>
PS&gt; <b>$root_dn = (Get-ADRootDSE).defaultNamingContext</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$obj = New-ADObject -Type "container" -Name "SDDEMO" -Path $root_dn</b>
<b>-OtherAttributes @{nTSecurityDescriptor=$sd.ToByteArray()} -PassThru</b>
PS&gt; <b>Format-Win32SecurityDescriptor -Name $obj.DistinguishedName -Type Ds</b>
Path: cn=SDDEMO,DC=mineral,DC=local
Type: DirectoryService
Control: DaclPresent, DaclAutoInherited

&lt;Owner&gt;
 - Name  : MINERAL\Domain Admins
 - Sid   : S-1-5-21-146569114-2614008856-3334332795-512

&lt;Group&gt;
 - Name  : MINERAL\Domain Admins
 - Sid   : S-1-5-21-146569114-2614008856-3334332795-512

&lt;DACL&gt; (Auto Inherited)
 <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> - Type  : Allowed
 - Name  : BUILTIN\Administrators
 - SID   : S-1-5-32-544
 - Mask  : 0x000F01FF
 - Access: Full Access
 - Flags : None

 <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> - Type  : AllowedObject
 - Name  : BUILTIN\Pre-Windows 2000 Compatible Access
 - SID   : S-1-5-32-554
<span aria-label=" Page 361. " epub:type="pagebreak" id="pg_361" role="doc-pagebreak"></span> - Mask  : 0x00000010
 - Access: ReadProp
 - Flags : ContainerInherit, InheritOnly, Inherited
 - ObjectType: 4c164200-20c0-11d0-a768-00aa006e0529
 - InheritedObjectType: 4828cc14-1437-45bc-9b07-ad6f015e5f28
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-17: Creating a new Active Directory object with a security descriptor</span></p>
<p class="TX">We first create a security descriptor containing a single ACE that grants the <i>Administrators</i> group full access <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then create a new container object called <samp class="SANS_TheSansMonoCd_W5Regular_11">SDDEMO</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ADObject</samp> command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, specifying the security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">OtherAttributes</samp> parameter.</p>
<p class="TX">Next, we format the new object’s security descriptor. As you can see, the ACE we specified is at the top of the DACL <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, but other ACEs have appeared after the one we specified <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, as auto-inheritance rules apply to the DACL and SACL of the parent object. (As discussed in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> security descriptor control flags to prevent inheritable ACEs from being applied to the object, but we haven’t done that here.)</p>
<p class="TX">What if we don’t specify the security descriptor value when creating the object? In that case, the object will use a default security descriptor, taken from the schema class object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">defaultSecurityDescriptor</samp> attribute. <a href="chapter11.xhtml#Lis11-18">Listing 11-18</a> shows how to manually create a new object security descriptor based on this default security descriptor attribute. This is simulating the operations the Active Directory server performs.</p>
<span id="Lis11-18"></span><pre><code>PS&gt; <b>$root_dn = (Get-ADRootDSE).defaultNamingContext</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$cls = Get-DsSchemaClass -Name "container"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$parent = Get-Win32SecurityDescriptor $root_dn -Type Ds</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Parent $parent -EffectiveToken</b>
<b>-ObjectType $cls.SchemaId -Creator $cls.DefaultSecurityDescriptor</b>
<b>-Type DirectoryService -AutoInherit DaclAutoInherit, SaclAutoInherit</b>
<b>-Container</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -Summary</b>
&lt;Owner&gt; : MINERAL\alice
&lt;Group&gt; : MINERAL\Domain Users
&lt;DACL&gt; (Auto Inherited)
MINERAL\Domain Admins: (Allowed)(None)(Full Access)
NT AUTHORITY\SYSTEM: (Allowed)(None)(Full Access)
<var>--snip--</var>

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$std_sd = Edit-NtSecurityDescriptor $sd -Standardize -PassThru</b>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Compare-NtSecurityDescriptor $std_sd $sd -Report</b>
WARNING: DACL ACE 1 mismatch.
WARNING: Left : Type Allowed - Flags None - Mask 00020094 - Sid S-1-5-11
WARNING: Right: Type Allowed - Flags None - Mask 000F01FF - Sid S-1-5-18
WARNING: DACL ACE 2 mismatch.
WARNING: Left : Type Allowed - Flags None - Mask 000F01FF - Sid S-1-5-18
WARNING: Right: Type Allowed - Flags None - Mask 00020094 - Sid S-1-5-11
False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-18: Creating a new object security descriptor</span></p>
<p class="TX"><span aria-label=" Page 362. " epub:type="pagebreak" id="pg_362" role="doc-pagebreak"></span>First, we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp> schema class <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. By inspecting this class’s schema identifier, we can determine which object ACEs were inherited (those with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> value set) and identify the default security descriptors for the class. We then get the security descriptor from the parent, which is the root domain object <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>, specifying the parent security descriptor, the default security descriptor, and the object type <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We also specify the auto-inherit flags, to automatically inherit any DACL or SACL ACEs, and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp> parameter to identify that the security descriptor will secure a container, which ensures that it will use the correct inheritance rules. Finally, we can format the newly created security descriptor, which has auto-inherited the DACL.</p>
<p class="TX">The new security descriptor has the owner and group SIDs you might expect: namely, the user SID and the primary group SID of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object on which it is based. However, this won’t always be the case. If the creator of the object is a local administrator on the Active Directory server, the server will change the owner and group SIDs to one of the following SIDs:</p>
<p class="RunInPara1"><b><i>Domain Admins    </i></b>Set for any object in the default naming context under the domain root</p>
<p class="RunInPara"><b><i>Enterprise Admins    </i></b>Set for any object in the configuration naming context</p>
<p class="RunInPara2"><b><i>Schema Admins    </i></b>Set for any object in the schema naming context</p>
<p class="TX">Changing the owner and group SIDs to one of these values ensures that the resources across a forest have appropriate owners. For example, if <i>Enterprise Admins</i> weren’t the default owner for configuration objects, an administrator from a different domain in the forest might create an object that an administrator in another domain wouldn’t be able to access, even if they were in the correct group.</p>
<p class="TX">To create the final security descriptor, we must perform one last step: standardization. <i>Security descriptor standardization</i> is a feature introduced in Windows Server 2003, and it’s turned on by default. It ensures that non-inherited ACEs always appear in a binary comparison order. This contrasts with the ACL canonicalization process described in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, which orders the ACEs based on the ACE type rather than on their binary value. Consequently, two canonical ACLs with the same ACE entries could have different ordering.</p>
<p class="TX">We can standardize a security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp> command and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Standardize</samp> parameter <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Note, however, that the standardized ACL form doesn’t always match the canonical one. Indeed, if we compare the original canonicalized security descriptor (shown in <a href="chapter11.xhtml#Lis11-16">Listing 11-16</a>) with the standardized one, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtSecurityDescriptor</samp> command shows two reordered ACEs <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. In theory this discrepancy could change the result of an access check, but in practice it’s unlikely to do so, as <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACEs always appear before <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs, regardless of the other ACE ordering rules in place.</p>
<p class="TX"><span aria-label=" Page 363. " epub:type="pagebreak" id="pg_363" role="doc-pagebreak"></span>An administrator can disable the standardization feature by setting a flag in the directory’s special <samp class="SANS_TheSansMonoCd_W5Regular_11">dsHeuristics</samp> attribute. You can query this flag using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsHeuristics</samp> PowerShell command, as shown in <a href="chapter11.xhtml#Lis11-19">Listing 11-19</a>.</p>
<span id="Lis11-19"></span><pre><code>PS&gt; <b>(Get-DsHeuristics).DontStandardizeSDs</b>
False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-19: Checking whether security descriptor standardization is enabled</span></p>
<p class="TX">If the command returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, security descriptor standardization is disabled.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="h2-116"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Security Descriptors to Existing Objects</samp></h4>
<p class="TNI1">You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp> PowerShell command to change an existing object’s security descriptor based on the distinguished name of the object. <a href="chapter11.xhtml#Lis11-20">Listing 11-20</a> demonstrates this for the object <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=SomeObject,DC=mineral,DC=local</samp>. Before running the script, change this name to that of an object that exists in your Active Directory configuration.</p>
<span id="Lis11-20"></span><pre><code>PS&gt; <b>$dn = "CN=SomeObject,DC=mineral,DC=local"</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor "D:(A;;GA;;;WD)"</b>
PS&gt; <b>Set-Win32SecurityDescriptor $dn -Type Ds -SecurityDescriptor $sd</b>
<b>-SecurityInformation Dacl</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-20: Setting an object’s security descriptor using the Set-Win32SecurityDescriptor command</span></p>
<p class="TX">The command sends a modification request to the directory server to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSecurityDescriptor</samp> attribute. As discussed in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, the user modifying the security descriptor must be granted the appropriate access rights on the object (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access) for the part of the security descriptor being written.</p>
<p class="TX">Security information flags specify which parts of the security descriptor you can modify. To get this information, request the constructed <samp class="SANS_TheSansMonoCd_W5Regular_11">sDRightsEffective</samp> attribute for the object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSDRightsEffective</samp> PowerShell command exposes this attribute, as shown in <a href="chapter11.xhtml#Lis11-21">Listing 11-21</a>.</p>
<span id="Lis11-21"></span><pre><code>PS&gt; <b>Get-DsSDRightsEffective -DistinguishedName $dn</b>
Owner, Group, Dacl
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-21: Querying for the effective security information</span></p>
<p class="TX">The output indicates that the current caller would be granted write access to the owner, group, and DACL. This result takes into account privileges such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>, which allows a caller to modify the owner even if the security descriptor doesn’t grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access. The directory also allows a caller to bypass certain checks using privileges; for example, it can check for <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp> to determine whether the caller can set arbitrary owner SIDs.</p>
<blockquote>
<span aria-label=" Page 364. " epub:type="pagebreak" id="pg_364" role="doc-pagebreak"></span>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>To add or remove a DACL-protected flag with the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Set-Win32SecurityDescriptor</samp> command, you’ll need to use the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ProtectedDacl</samp> or UnprotectedDacl security information flag. These flags aren’t passed to the server; instead, they are set in the security descriptor’s control flags, which are then sent to the server.</i></p>
</blockquote>
<p class="TX">In <a href="chapter11.xhtml#Lis11-22">Listing 11-22</a>, we build a new security descriptor for an object, deriving it from three values: the security descriptor supplied by the user, the current security descriptor, and the parent security descriptor.</p>
<span id="Lis11-22"></span><pre><code>PS&gt; <b>$root_dn = (Get-ADRootDSE).defaultNamingContext</b>
PS&gt; <b>$user_dn =</b> <b>"CN=Users,$root_dn"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$curr_sd = Get-Win32SecurityDescriptor "CN=Users,$root_dn" -Type Ds</b>
PS&gt; <b>Format-NtSecurityDescriptor $curr_sd -Summary</b>
&lt;Owner&gt; : DOMAIN\Domain Admins
&lt;Group&gt; : DOMAIN\Domain Admins
&lt;DACL&gt; (Auto Inherited)
NT AUTHORITY\SYSTEM: (Allowed)(None)(Full Access)
<var>--snip--</var>

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$new_sd = New-NtSecurityDescriptor "D:(A;;GA;;;WD)"</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Edit-NtSecurityDescriptor -SecurityDescriptor $curr_sd</b>
<b>-NewSecurityDescriptor $new_sd -SecurityInformation Dacl</b>
<b>-Flags DaclAutoInherit, SaclAutoInherit</b>

PS&gt; <b>$cls = Get-DsObjectSchemaClass $user_dn</b>
PS&gt; <b>$parent = Get-Win32SecurityDescriptor $root_dn -Type Ds</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Parent $parent</b>
<b>-ObjectType $cls.SchemaId -Creator $curr_sd -Container</b>
<b>-Type DirectoryService -AutoInherit DaclAutoInherit, SaclAutoInherit,</b>
<b>AvoidOwnerCheck, AvoidOwnerRestriction, AvoidPrivilegeCheck</b>
<b>-EffectiveToken</b>

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Edit-NtSecurityDescriptor $sd -Standardize</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -Summary</b>
&lt;Owner&gt; : DOMAIN\Domain Admins
&lt;Group&gt; : DOMAIN\Domain Admins
&lt;DACL&gt; (Auto Inherited)
Everyone: (Allowed)(None)(Full Access)
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-22: Creating a new security descriptor for an object</span></p>
<p class="TX">First, we get the current security descriptor for the object. In this case I’ve picked the <samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp> container, as it provides an easy example <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, but you can choose any object in the directory. Next, we create a new security descriptor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp> PowerShell command to modify the object’s existing security descriptor, replacing it with the one we just created <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In this command, we must specify the security information flags as well as the auto-inherit flags.</p>
<p class="TX">We then use the modified security descriptor as the creator security descriptor, using the parent security descriptor and the target object’s class information for inheritance <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We specify some additional auto-inherit <span aria-label=" Page 365. " epub:type="pagebreak" id="pg_365" role="doc-pagebreak"></span>flags to disable the owner check; this ensures that we set the owner value correctly based on the original security descriptor. Disabling the checks isn’t a security issue because the caller must have set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> security information flag to change the owner, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp> would have checked for the owner SID, preventing a user from circumventing the check.</p>
<p class="TX">We can now standardize the security descriptor and format it <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. As you can see, it now contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">Everyone</samp> ACE, matching the new security descriptor we specified. At this point, the server will also enumerate any child objects of the security descriptor we’re modifying and apply any inheritance changes to the new security descriptor we’ve introduced.</p>
<p class="TX">Note that the server automatically propagates inheritable ACEs to child objects whenever a parent object’s security descriptor changes. This behavior contrasts with that of files and registry keys, where it’s the responsibility of the Win32 APIs to manually propagate inheritance to children. The automatic propagation introduces an interesting consequence: the server doesn’t check that the user setting the security descriptor has appropriate access rights to the child object. Therefore, a user with <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access to an object higher in a hierarchy can set a new inheritable ACE and grant themselves access to a child object to which they didn’t previously have access.</p>
<p class="TX">The only way to mitigate this behavior is by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> control flag in the object’s security descriptor to block inheritance (as well as the fact that administrators should never grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access to non-administrator users).</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H2" id="sec18"><span id="h2-117"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting a Security Descriptor’s Inherited Security</samp></h4>
<p class="TNI1">Because the security descriptors are assigned based on the object hierarchy, it’s possible to locate the source of their inherited ACEs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp> PowerShell command. In <a href="chapter11.xhtml#Lis11-23">Listing 11-23</a>, we find the inherited ACEs for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp> container.</p>
<span id="Lis11-23"></span><pre><code>PS&gt; <b>$root_dn = (Get-ADRootDSE).defaultNamingContext</b>
PS&gt; <b>$user_dn = "CN=Users,$root_dn"</b>
PS&gt; <b>$cls = Get-DsObjectSchemaClass -DistinguishedName $user_dn</b>
PS&gt; <b>Search-Win32SecurityDescriptor -Name $user_dn -Type Ds</b>
<b>-ObjectType $cls.SchemaId</b>
Name                Depth User                             Access
----                ----- ----                             ------
                    0     NT AUTHORITY\SYSTEM              GenericAll
                    0     MINERAL\Domain Admins            CreateChild|...
                    0     BUILTIN\Account Operators        CreateChild|...
                    0     BUILTIN\Account Operators        CreateChild|...
                    0     BUILTIN\Print Operators          CreateChild|...
                    0     NT AUTHORITY\Authenticated Users GenericRead
                    0     BUILTIN\Account Operators        CreateChild|...
DC=mineral,DC=local 1     BUILTIN\Pre-Windows 2000...      ReadProp
DC=mineral,DC=local 1     BUILTIN\Pre-Windows 2000...      ReadProp
DC=mineral,DC=local 1     BUILTIN\Pre-Windows 2000...      ReadProp
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-23: Searching for the source of inherited ACEs</span></p>
<p class="TX"><span aria-label=" Page 366. " epub:type="pagebreak" id="pg_366" role="doc-pagebreak"></span>You can use this command with Active Directory objects in almost the same way as you would use it with files. The important difference is that you must set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> property to <samp class="SANS_TheSansMonoCd_W5Regular_11">Ds</samp> to look up Active Directory objects on the server.</p>
<p class="TX">You must also specify the schema class GUID for inheritance ACEs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> parameter; otherwise, the command might not be able to find the source ACEs at all, as they’re likely to be inherited based on the object’s type. In my testing, the search sometimes succeeded when I didn’t specify the object type, but in most cases, the operation failed with an unrelated error.</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H1" id="sec19"><span id="h1-86"></span><samp class="SANS_Futura_Std_Bold_B_11">Access Checks</samp></h3>
<p class="TNI1">Now that we can query an object’s security descriptor, we can perform an access check to determine whether it would grant a user some specific access. Active Directory designates nine type-specific access rights that directory objects can grant, in addition to the standard rights such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> (used to read and write, respectively, the security descriptor on the object). They are:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateChild  </samp>Enables creating a new child object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeleteChild  </samp>Enables deleting a child object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">List  </samp>Enables listing child objects</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Self  </samp>Enables writing an attribute value (which the server will verify)</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadProp  </samp>Enables reading an attribute value</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteProp</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables writing an attribute value</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeleteTree  </samp>Enables deleting a tree of objects</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListObject  </samp>Enables listing a specific object</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ControlAccess  </samp>Grants access to a directory operation</p>
<p class="TX">Some of these access rights require more explanation than others. In the following sections, we’ll walk through the various operations they represent and how they’re used to determine what a user can do on the directory server. Note that the behaviors of these access rights also apply to ACEs specified in an object’s SACL, meaning you should be able to take the descriptions presented here and apply them to the generation of audit events.</p>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H2" id="sec20"><span id="h2-118"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Objects</samp></h4>
<p class="TNI1">If a user is granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access right, they can create a child object for the object. The object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp> ACEs determine what kinds of child objects a user can create. <a href="chapter11.xhtml#Lis11-24">Listing 11-24</a> shows how to grant the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access right for a specific object type.</p>
<span id="Lis11-24"></span><pre><code><span aria-label=" Page 367. " epub:type="pagebreak" id="pg_367" role="doc-pagebreak"></span>PS&gt; <b>$sd = New-NtSecurityDescriptor -Type DirectoryService -Owner "SY"</b>
<b>-Group "SY"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type Allowed</b>
<b>-Access List</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$user = Get-DsSchemaClass -Name "user"</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type AllowedObject</b>
<b>-Access CreateChild -ObjectType $user.SchemaId</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -Summary</b> <b>-SecurityInformation Dacl</b>
<b>-ResolveObjectType</b>
&lt;DACL&gt;
Everyone: (Allowed)(None)(List)
Everyone: (AllowedObject)(None)(CreateChild)(OBJ:User)

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $user</b>
CreateChild, List

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$cont = Get-DsSchemaClass -Name "container"</b>
PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $cont</b>
List
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-24: Testing CreateChild object type access</span></p>
<p class="TX">We first create a new security descriptor and add an ACE that grants everyone <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This ACE doesn’t specify an object type, so it will apply to every user who matches the SID. Next, we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> schema class <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and use it to create a second ACE that grants <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access, specifying the schema identifier as the object type.</p>
<p class="TX">We display the security descriptor to verify that we’ve created the correct ACEs, passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResolveObjectType</samp> parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp> to return the directory object type’s name. If you don’t use this parameter, the command will print the GUID instead, which is less useful; however, note that returning these names can be quite time-consuming and might cause the command to hang.</p>
<p class="TX">We now request the maximum granted access for the security descriptor <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, specifying the schema class as the object type to check, and are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access. The directory server will do the same when performing the access check for the child creation operation; it will look up the schema class identifier for the object class being created and pass it to the access check API. If <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access is granted, the operation will proceed.</p>
<p class="TX">Finally, we repeat the access check but instead specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp> class <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. This time, we’re granted only <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access—because we didn’t pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> class’s identifier in the list of object types to check, the access check ignored the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> ACE.</p>
<p class="TX">If an object’s security descriptor contains an ACE that grants the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access right with no object type specified, the user can create any child object. However, limitations still exist. First, the user can only create new objects of structural classes; the server should reject the creation of an object from an abstract or auxiliary class. Second, each schema class has a list of possible parent classes, or <i>superiors</i>, stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">possSuperiors</samp> and <span aria-label=" Page 368. " epub:type="pagebreak" id="pg_368" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">systemPossSuperiors</samp> attributes. The server will permit the creation of a child only if the parent object’s class is in this list of classes.</p>
<p class="TX">Determining all permitted child classes can be quite complex due to the rules of class inheritance. Fortunately, the directory server also constructs the <samp class="SANS_TheSansMonoCd_W5Regular_11">possibleInferiors</samp> attribute, which lists the classes the directory will allow as children for a given schema class. You can query for these classes using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaClass</samp> PowerShell command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inferior</samp> parameter, as shown in <a href="chapter11.xhtml#Lis11-25">Listing 11-25</a>.</p>
<span id="Lis11-25"></span><pre><code>PS&gt; <b>Get-DsSchemaClass "user" -Inferior</b>
Name                          SchemaId                             Attributes
----                          --------                             ----------
ms-net-ieee-80211-GroupPolicy 1cb81863-b822-4379-9ea2-5ff7bdc6386d 3
nTFRSSubscriptions            2a132587-9373-11d1-aebc-0000f80367c1 3
classStore                    bf967a84-0de6-11d0-a285-00aa003049e2 4
ms-net-ieee-8023-GroupPolicy  99a03a6a-ab19-4446-9350-0cb878ed2d9b 3
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-25: Listing inferior classes of the user schema class</span></p>
<p class="TX"><a href="chapter11.xhtml#Lis11-25">Listing 11-25</a> shows the four child classes allowed for a user object. Trying to create an object of a class that isn’t in the list of children will result in an error and abort the creation operation. An administrator can change this list by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> class to another class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">possSuperiors</samp> attribute.</p>
<aside aria-label="box-2" class="box">
<p class="BoxTitle" id="box-2"><samp class="SANS_Dogma_OT_Bold_B_11">ABUSING CHILD CLASSES</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If a user is granted the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> <samp class="SANS_Futura_Std_Book_11">access right, there is a risk that they could configure the directory outside of the expected limits. You should assume that granting the ability to create a child means the user can set any attribute in the new object, some of which might inform security decisions made by the server or third-party applications. The user can also create new objects with inferior classes permitted.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">When might the ability to create inferior classes lead to problems? As an example, I found a class added to the Active Directory server when the Exchange mail server was installed that normal users could create in existing objects in the directory. This class, in turn, had the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp> <samp class="SANS_Futura_Std_Book_11">class as an inferior, which could contain security-critical classes such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp><samp class="SANS_Futura_Std_Book_11">. Look up CVE-2021-34470 to read the details of this issue.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">You can pipe the output of one</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaClass</samp> <samp class="SANS_Futura_Std_Book_11">command to another to build the full list of child classes originating from a parent:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-DsSchemaClass user -Inferior | Get-DsSchemaClass -Inferior</samp></code></pre>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This will show what object types you could create if you had</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> <samp class="SANS_Futura_Std_Book_11">access. Repeat the pipeline until you stop receiving new classes in the output.</samp></p>
</aside>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H2" id="sec21"><span id="h2-119"></span><span aria-label=" Page 369. " epub:type="pagebreak" id="pg_369" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Deleting Objects</samp></h4>
<p class="TNI1">Three access rights control deletion: <samp class="SANS_TheSansMonoCd_W5Regular_11">Delete</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteTree</samp>. Each concerns a different delete operation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Delete</samp> access right applies only to the current object; if the object has child objects, the server will refuse to delete the object. (A client application could bypass this restriction by recursively enumerating all children and deleting them if the user had the necessary access.)</p>
<p class="TX">If the user is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp> access, they can delete any immediate child object, although if that child object has its own children, the same restriction as for <samp class="SANS_TheSansMonoCd_W5Regular_11">Delete</samp> applies. The ACE granting <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp> access can use the object type to restrict which of an object’s classes a user can delete.</p>
<p class="TX">Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteTree</samp> access right allows a user to delete an entire tree of objects, including the root object. This deletion is performed entirely on the server, using a specific tree-deletion command. The user does not need any deletion rights on the child objects if they have this right.</p>
<p class="TX">You can remove objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-ADObject</samp> PowerShell command. To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteTree</samp> access right, you must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recursive</samp> parameter.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-120"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listing Objects</samp></h4>
<p class="TNI1">The list of access rights includes two rights for listing objects, <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp>. There are some differences between these. By default, if a user is not granted <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access, they cannot inspect any of an object’s children. However, this restriction isn’t transitive; for example, if a child object grants the <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access right, the user can inspect the children of that object, even though they can’t list the object itself from the parent. (This means the user will need to know the name of the child object to inspect.)</p>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access applies not to the parent but to individual objects. If a user has the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access right on an object but doesn’t have the <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access right on the parent, the user can still list and interact with the object. By default, the Active Directory server doesn’t check the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access right, likely for performance reasons.</p>
<p class="TX">If the user were not granted <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access on an object, but tried to enumerate its children, the server would need to do an access check for every child object to find out which were visible through allowing <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access. For directory objects with large numbers of children, this would be a very expensive operation.</p>
<p class="TX">You can enable this access right using a flag in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dsHeuristics</samp> attribute in the directory. Query the flag using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsHeuristics</samp> PowerShell command:</p>
<pre><code>PS&gt; <b>(Get-DsHeuristics).DoListObject</b>
</code></pre>
<p class="TX">If the output is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access right is enabled.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H2" id="sec23"><span id="h2-121"></span><span aria-label=" Page 370. " epub:type="pagebreak" id="pg_370" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading and Writing Attributes</samp></h4>
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access rights control the reading and writing, respectively, of attributes in an object. It’s possible to allow the reading and writing of all of an object’s attributes through an ACE with no object type. More commonly, however, an object will allow the reading of all attributes, but restrict which attributes can be written by specifying an ACE’s object type as the attribute’s schema identifier.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-26">Listing 11-26</a> shows an example of how to implement an access check for reading and writing attributes.</p>
<span id="Lis11-26"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Type DirectoryService -Owner "DA"</b>
<b>-Group "DA"</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type Allowed</b>
<b>-Access ReadProp</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$attr = Get-DsSchemaAttribute -Name "accountExpires"</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type AllowedObject</b>
<b>-Access WriteProp -ObjectType $attr.SchemaId</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $attr</b>
ReadProp, WriteProp

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$pwd = Get-DsSchemaAttribute -Name "pwdLastSet"</b>
PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $pwd</b>
ReadProp
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-26: Testing the ReadProp and WriteProp access rights</span></p>
<p class="TX">We start by creating a new security descriptor with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACE that grants <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access, without specifying an object type <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then add an ACE that grants <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access to only the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> attribute <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, we perform an access check specifying that attribute’s schema identifier as the object type <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, and we’re granted both <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access. However, if we run the access check with a different attribute type <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, we’re granted only the general <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access.</p>
<p class="TX">Note that the security descriptor could contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE to block the reading or writing of a specific attribute, even if a separate ACE enabled reading or writing of all attributes. For instance, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE blocked the reading of the <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp> attribute we queried for here, even <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access wouldn’t be granted. The directory server must ensure that it specifies the exact object type for the attributes to check.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Even if the access check indicates that an attribute can be read or written, the directory server doesn’t have to honor that decision. The directory contains several attributes that a normal user can’t read or write. For example, they can’t read or write user passwords, which are stored in the unicodePwd attribute that only the system is permitted to access. No amount of configuring the security descriptor should change this behavior (although a separate mechanism allows a user to write the password;</i> <span aria-label=" Page 371. " epub:type="pagebreak" id="pg_371" role="doc-pagebreak"></span><i>we’ll come back to this in “Control Access Rights” on page 376). Note also that a normal user can’t modify any attribute that is marked as system-only, indicated by the systemOnly attribute in the schema.</i></p>
</blockquote>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="H2" id="sec24"><span id="h2-122"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Multiple Attributes</samp></h4>
<p class="TNI1">To avoid making you send multiple requests to the directory server, LDAP supports the reading and writing of multiple attributes in a single request. However, it would be expensive to then require an access check for each of these attributes’ schema identifiers before determining what you can read or write.</p>
<p class="TX">As I described in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, the access check process allows you to build a tree of object types to verify multiple attributes in a single check. This tree lists each object type and what access it will be granted, enabling the directory server to quickly determine if it should grant a request. <a href="chapter11.xhtml#Lis11-27">Listing 11-27</a> shows how to use an object type tree in an access check. It adds to the commands in <a href="chapter11.xhtml#Lis11-26">Listing 11-26</a>.</p>
<span id="Lis11-27"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$user = Get-DsSchemaClass -Name "user"</b>
PS&gt; <b>$obj_tree = New-ObjectTypeTree $user</b>
PS&gt; <b>Add-ObjectTypeTree -Tree $obj_tree $attr</b>
PS&gt; <b>Add-ObjectTypeTree -Tree $obj_tree $pwd</b>

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $obj_tree -ResultList -PassResult |</b>
<b>Format-Table Status, SpecificGrantedAccess, Name</b>
        Status SpecificGrantedAccess Name
        ------ --------------------- ----
STATUS_SUCCESS              ReadProp user
STATUS_SUCCESS   ReadProp, WriteProp accountExpires
STATUS_SUCCESS              ReadProp pwdLastSet

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $obj_tree -ResultList -PassResult</b>
<b>-Access WriteProp | Format-Table Status, SpecificGrantedAccess, Name</b>
              Status SpecificGrantedAccess Name
              ------ --------------------- ----
STATUS_ACCESS_DENIED                  None user
      STATUS_SUCCESS             WriteProp accountExpires
STATUS_ACCESS_DENIED                  None pwdLastSet
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-27: Using an object type tree to check multiple attributes</span></p>
<p class="TX">We first get the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> schema class <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and use it to build the tree, setting the class’s schema identifier as the tree’s root. We then add the two attributes we want to check, <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp>, as leaf nodes to the root, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-ObjectTypeTree</samp> command. <a href="chapter11.xhtml#fig11-4">Figure 11-4</a> shows the structure of the final tree.</p>
<span aria-label=" Page 372. " epub:type="pagebreak" id="pg_372" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img7" height="381" id="fig11-4" src="../images/Figure11-4.jpg" width="848"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The object type tree for the user object and its accountExpires</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and pwdLastSet attributes</samp></p></figcaption>
</figure>
<p class="TX">Next, we pass the tree to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, making sure to specify that we want the list of all results, not the single granted-access value. The results show that only the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> attribute has been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object and <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp> attribute have been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access only.</p>
<p class="TX">Typically, the Active Directory server will specify an explicit access right to check for, rather than simply requesting the maximum granted access. We can test this by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> parameter with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> and checking the resulting behavior <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The results show that the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object and its <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp> attribute have been denied access, but that the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> attribute is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access.</p>
<p class="TX">The fact that the object’s class is specified in the tree leads to an interesting behavior, demonstrated in <a href="chapter11.xhtml#Lis11-28">Listing 11-28</a>.</p>
<span id="Lis11-28"></span><pre><code>PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type AllowedObject</b>
<b>-Access WriteProp -ObjectType $user.SchemaId</b>
PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $obj_tree -ResultList -PassResult |</b>
<b>Format-Table Status, SpecificGrantedAccess, Name</b>
        Status SpecificGrantedAccess Name
        ------ --------------------- ----
STATUS_SUCCESS   ReadProp, WriteProp user
STATUS_SUCCESS   ReadProp, WriteProp accountExpires
STATUS_SUCCESS   ReadProp, WriteProp pwdLastSet
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-28: Granting WriteProp access to the schema class</span></p>
<p class="TX">As you can see, it’s possible to add an ACE that grants access rights for all attributes of a specified object class. Here, we add an ACE granting <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> class’s schema identifier. When we repeat our access check, this time we find that <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access is granted for all attributes in the tree.</p>
<p class="TX">This behavior, granting access to all attributes, is likely an emergent property of the implementation, not an intentional design decision; the Windows user interface for modifying a directory object’s security descriptor can’t understand the ACE and shows it as granting no specific access rights. An attacker could use this behavior to hide malicious modifications to the security descriptor from an administrator.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h4 class="H2" id="sec25"><span id="h2-123"></span><span aria-label=" Page 373. " epub:type="pagebreak" id="pg_373" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Property Sets</samp></h4>
<p class="TNI1">As shown in <a href="chapter11.xhtml#Lis11-29">Listing 11-29</a>, an object class can have many attributes—in the case of the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> class, a total of 428 if we include the attributes of all its auxiliary classes.</p>
<span id="Lis11-29"></span><pre><code>PS&gt; <b>(Get-DsSchemaClass user -Recurse -IncludeAuxiliary |</b>
<b>Sort-Object SchemaId -Unique |</b>
<b>Select-Object -ExpandProperty Attributes).Count</b>
428
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-29: Counting attributes for the user schema class</span></p>
<p class="TX">If you wanted to grant specific access rights to all of these attributes, the DACL would quickly become unmanageable; the ACL might even run out of its allowed 64KB of space.</p>
<p class="TX">To partially solve this problem, the Active Directory configuration can define arbitrary <i>property sets</i>, which group multiple attributes together under a single GUID. It can then use this identifier as the object type in an ACE to grant or deny access to a group of attributes in one go. Property sets are just one type of <i>extended right</i>, which allow an administrator to add additional access rights to the directory. We’ll cover the other two, control access rights and validated write access rights, in the following sections. <a href="chapter11.xhtml#Lis11-30">Listing 11-30</a> shows how to get all the extended rights in the current directory.</p>
<span id="Lis11-30"></span><pre><code>PS&gt; <b>$config_dn = (Get-ADRootDSE).configurationNamingContext</b>
PS&gt; <b>$extended_dn = "CN=Extended-Rights,$config_dn"</b>
PS&gt; <b>Get-ADObject -SearchBase $extended_dn -SearchScope OneLevel -Filter *</b>
<b>-Properties * | Group-Object {</b>
   <b>Get-NtAccessMask $_.validAccesses -AsSpecificAccess DirectoryService</b>
<b>}</b>
Count Name                      Group
----- ----                      -----
   60 ControlAccess             {CN=Add-GUID,CN=Extended-Rights,...}
   15 ReadProp, WriteProp       {CN=DNS-Host-Name-Attributes,...}
    6 Self                      {CN=DS-Validated-Write-Computer,...}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-30: Getting extended rights and grouping them by the validAccesses attribute</span></p>
<p class="TX">An object can specify a particular type of extended right in its <samp class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp> attribute, which stores an integer representing directory object access rights. We convert the attribute to an access rights enumeration using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp> PowerShell command. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp> attribute (and thus the value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column) is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>, the extended right is a property set.</p>
<p class="TX">To simplify the analysis of extended rights and property sets, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsExtendedRight</samp> PowerShell command, as shown in <a href="chapter11.xhtml#Lis11-31">Listing 11-31</a>.</p>
<span id="Lis11-31"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$attr = Get-DsSchemaAttribute -Name "accountExpires"</b>
PS&gt; <b>$prop_set = Get-DsExtendedRight -Attribute $attr</b>
PS&gt; <b>$prop_set</b>
<span aria-label=" Page 374. " epub:type="pagebreak" id="pg_374" role="doc-pagebreak"></span>Name                             RightsId
----                      --------
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> User-Account-Restrictions 4c164200-20c0-11d0-a768-00aa006e0529

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$prop_set.AppliesTo  | Select-Object Name</b>
Name
----
msDS-GroupManagedServiceAccount
inetOrgPerson
msDS-ManagedServiceAccount
computer
user

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$user = Get-DsSchemaClass user</b>
PS&gt; <b>Get-DsExtendedRight -SchemaClass $user</b>
Name                           RightsId
----                           --------
Allowed-To-Authenticate        68b1d179-0d15-4d4f-ab71-46152e79a7bc
Email-Information              e45795b2-9455-11d1-aebd-0000f80367c1
General-Information            59ba2f42-79a2-11d0-9020-00c04fc2d3cf
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-31: Getting the property set for an attribute and its possible schema classes</span></p>
<p class="TX">We first get the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> attribute we used earlier and pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsExtendedRight</samp> command <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If the attribute is part of a property set, the command will return the extended right. Here, the output lists the attribute as part of the <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Account-Restrictions</samp> property set <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">RightsId</samp> column provides the GUID you’d use in an ACE to allow or deny access to the object type. You can find this GUID in the schema attribute’s <samp class="SANS_TheSansMonoCd_W5Regular_11">attributeSecurityGUID</samp> attribute. Each property set also has a list of schema classes that are allowed to contain it <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This allows the directory server to know what object type tree it needs to build when doing an access check.</p>
<p class="TX">Finally, we perform the reverse operation; finding all property sets that apply to a specific schema class, <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-32">Listing 11-32</a> demonstrates using a property set in an access check.</p>
<span id="Lis11-32"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Type DirectoryService</b>
<b>-Owner "SY" -Group "SY"</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type AllowedObject</b>
<b>-Access ReadProp -ObjectType $prop_set.RightsId</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type AllowedObject</b>
<b>-Access WriteProp -ObjectType $attr.SchemaId</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$obj_tree = New-ObjectTypeTree -SchemaObject $user</b>
PS&gt; <b>Add-ObjectTypeTree -Tree $obj_tree -SchemaObject $prop_set</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $prop_set -ResultList -PassResult |</b>
<b>Format-Table SpecificGrantedAccess, Name</b>
SpecificGrantedAccess Name
--------------------- ----
             ReadProp user
             ReadProp User-Account-Restrictions
  ReadProp, WriteProp accountExpires
<span aria-label=" Page 375. " epub:type="pagebreak" id="pg_375" role="doc-pagebreak"></span>             ReadProp msDS-AllowedToActOnBehalfOfOtherIdentity
             ReadProp msDS-User-Account-Control-Computed
             ReadProp msDS-UserPasswordExpiryTimeComputed
             ReadProp pwdLastSet
             ReadProp userAccountControl
             ReadProp userParameters
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-32: Performing an access check with a property set</span></p>
<p class="TX">We build a new security descriptor to do the check <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, and we grant <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access based on the property set identifier. We also grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> attribute within that set, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">attr</samp> variable we defined in <a href="chapter11.xhtml#Lis11-31">Listing 11-31</a> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, we need to build the object type tree <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. As before, the root of the tree is the object class. We then add the property set as a child of the tree, producing the object type tree shown in <a href="chapter11.xhtml#fig11-5">Figure 11-5</a>.</p>
<figure class="IMG"><img alt="" class="img7" height="614" id="fig11-5" src="../images/Figure11-5.jpg" width="1042"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: The property set object type tree</samp></p></figcaption>
</figure>
<p class="TX">This object type tree contains both the property set at level 1 and entries for each attribute in the set at level 2. This tree structure allows us to grant access based on either the property set identifier or individual attributes.</p>
<p class="TX">Note that the directory server implements individual attribute checks a little differently; it always uses property sets if it can, but if an attribute isn’t in a property set it uses a dummy GUID, named <samp class="SANS_TheSansMonoCd_W5Regular_11">PROPSET_GUID_DEFAULT</samp>, as a placeholder. You might see this GUID in audit log entries, although the configuration’s extended rights don’t specify it.</p>
<p class="TX">We pass the object type tree and security descriptor to the access check <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, and since we granted the property set <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access, all attributes in the set receive at least this level of access. Because we explicitly granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> attribute, it receives this access right as well.</p>
<p class="TX">As you can see, if the security descriptor granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access to every attribute in the set, the access would propagate to the property set node at level 1. Therefore, if the server merely checked the property <span aria-label=" Page 376. " epub:type="pagebreak" id="pg_376" role="doc-pagebreak"></span>set’s granted access, it wouldn’t matter if the security descriptor granted the access directly, using the property set’s identifier, or instead granted access to every individual attribute in the set.</p>
<p class="TX">One last thing to highlight is what happens when we add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE for attributes in a property set. <a href="chapter11.xhtml#Lis11-33">Listing 11-33</a> shows an example.</p>
<span id="Lis11-33"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$pwd = Get-DsSchemaAttribute -Name "pwdLastSet"</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type DeniedObject</b>
<b>-Access ReadProp -ObjectType $pwd.SchemaId</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Edit-NtSecurityDescriptor $sd -CanonicalizeDacl</b>
PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $obj_tree -ResultList -PassResult |</b>
<b>Format-Table SpecificGrantedAccess, Name</b>
SpecificGrantedAccess Name
--------------------- ----
               <span aria-label="annotation3" class="CodeAnnotationCode2">❸</span> None user
                 None User-Account-Restrictions
  ReadProp, WriteProp accountExpires
             ReadProp msDS-AllowedToActOnBehalfOfOtherIdentity
             ReadProp msDS-User-Account-Control-Computed
             ReadProp msDS-UserPasswordExpiryTimeComputed
                 None pwdLastSet
             ReadProp userAccountControl
             ReadProp userParameters
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-33: Denying access to an attribute in a property set</span></p>
<p class="TX">In this listing, we include a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE for the <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp> attribute to restrict the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access right <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. You must remember to canonicalize the DACL <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> after adding the ACE; otherwise, it won’t appear at the start of the list, and the access check process will ignore it.</p>
<p class="TX">When we run the access check, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE has removed <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access from the <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp> attribute, then propagated that change to the property set and <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> class, removing their access as well <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. All other attributes in the set retain their <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access. This behavior makes sense: if one of the property set’s attributes is denied access, then the property set as a whole isn’t granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access.</p>
<p class="TX">If the property set identifier was used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeniedObject</samp> ACE, all attributes in the set would be denied the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access right. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> would still be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access as it has a separate ACE granting it that access.</p>
<p class="TX">An Active Directory server administrator can add their own property sets to the configuration to extend this functionality to commonly used attributes; this reduces the complexity of object security descriptors.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h4 class="H2" id="sec26"><span id="h2-124"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting Control Access Rights</samp></h4>
<p class="TNI1">The second type of extended right, <i>control access rights</i>, don’t necessarily correspond to any object attribute; instead, they tell the Active Directory server whether the user can perform a particular operation. Let’s start by listing a subset of the control access rights, as shown in <a href="chapter11.xhtml#Lis11-34">Listing 11-34</a>.</p>
<span id="Lis11-34"></span><pre><code><span aria-label=" Page 377. " epub:type="pagebreak" id="pg_377" role="doc-pagebreak"></span>PS&gt; <b>Get-DsExtendedRight | Where-Object {</b>
<b>    $_.IsControl -and $_.Name -match "password"</b>
<b>} | Select-Object Name, RightsId</b>
Name                               RightsId
----                               --------
User-Force-Change-Password         00299570-246d-11d0-a768-00aa006e0529
Unexpire-Password                  ccc2dc7d-a6ad-4a7a-8846-c04e3cc53501
Update-Password-Not-Required-Bit   280f369c-67c7-438e-ae98-1d46f3c6f541
User-Change-Password               ab721a53-1e2f-11d0-9819-00aa0040529b
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-34: Listing control access rights with password in the name</span></p>
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsControl</samp> property, we filter the output so it includes only control access rights with <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp> in their name. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IsControl</samp> property is <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if the <samp class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp> attribute on the extended right is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp>. The results include two commonly used control access rights, <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Force-Change-Password</samp>, which allow a user to modify their user object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">unicodePwd</samp> write-only attribute. We can’t grant this ability using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access.</p>
<p class="TX">The difference between these two rights is that <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp> requires the user to send their old password as part of the modify operation, while <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Force-Change-Password</samp> works without requiring the old password. These correspond to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp> SAM user access rights we discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> and serve the same purpose.</p>
<p class="TX">To give an example of how the directory server might check for a control access right, let’s assume a user wants to change another user’s password. <a href="chapter11.xhtml#Lis11-35">Listing 11-35</a> shows how the server might implement the access check for permitting the change operation.</p>
<span id="Lis11-35"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Type DirectoryService -Owner "SY" </b>
<b>-Group "SY"</b>
PS&gt; <b>$right = Get-DsExtendedRight -Name 'User-Change-Password'</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Type AllowedObject</b>
<b>-Access ControlAccess -ObjectType $right.RightsId</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$user = Get-DsSchemaClass user</b>
PS&gt; <b>$obj_tree = New-ObjectTypeTree -SchemaObject $user</b>
PS&gt; <b>Add-ObjectTypeTree -Tree $obj_tree -SchemaObject $right</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$force = Get-DsExtendedRight -Name 'User-Force-Change-Password'</b>
PS&gt; <b>Add-ObjectTypeTree -Tree $obj_tree -SchemaObject $force</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-NtGrantedAccess $sd -ObjectType $obj_tree -ResultList -PassResult |</b>
<b>Format-Table Status, SpecificGrantedAccess, Name</b>
              Status SpecificGrantedAccess Name
              ------ --------------------- ----
STATUS_ACCESS_DENIED                  None user
      STATUS_SUCCESS         ControlAccess User-Change-Password
STATUS_ACCESS_DENIED                  None User-Force-Change-Password
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-35: Checking for the User-Change-Password control access right</span></p>
<p class="TX">First, we create a new security descriptor, get the control access right, and add an ACE to the security descriptor granting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> access right for <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, we query for the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> schema class <span aria-label=" Page 378. " epub:type="pagebreak" id="pg_378" role="doc-pagebreak"></span>and use it to build the object type tree <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We need the object class to be the root, but we make the control access right its immediate child. We also query for the <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Force-Change-Password</samp> control access right and add it to the tree <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If the user is granted this right, the server will allow them to force the password change even if they cannot provide the currently set password.</p>
<p class="TX">We then run the access check <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and see that the user has been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp> control access right. Now the directory server can proceed with the operation.</p>
<p class="TX">As with other types of access, it’s possible for a security descriptor to grant <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> either with a non-object ACE or on the object class. From the access check perspective, <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> is granted to the control access right; the directory server doesn’t necessarily know the difference. It’s also possible for an administrator to extend the list of control access rights, although that normally requires a third-party application to check for the right, as the directory server won’t know about it.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h4 class="H2" id="sec27"><span id="h2-125"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Write-Validated Access Rights</samp></h4>
<p class="TNI1">The final type of extended right is write-validated access rights. They’re defined when the <samp class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp> attribute is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>. <a href="chapter11.xhtml#Lis11-36">Listing 11-36</a> shows how to list the write-validated access rights by filtering on the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsValidatedWrite</samp> property.</p>
<span id="Lis11-36"></span><pre><code>PS&gt; <b>Get-DsExtendedRight | Where-Object IsValidatedWrite</b>
Name                                     RightsId
----                                     --------
Validated-MS-DS-Behavior-Version         d31a8757-2447-4545-8081-3bb610cacbf2
Self-Membership                          bf9679c0-0de6-11d0-a285-00aa003049e2
Validated-MS-DS-Additional-DNS-Host-Name 80863791-dbe9-4eb8-837e-7f0ab55d9ac7
Validated-SPN                            f3a64788-5306-11d1-a9c5-0000f80367c1
DS-Validated-Write-Computer              9b026da6-0d3c-465c-8bee-5199d7165cba
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-36: Listing write-validated access rights</span></p>
<p class="TX">A write-validated access right grants a user the ability to write to certain attributes of an object, with the server verifying the new value for the attribute before it’s written. As an example, if a user wants to add a new member to a group object, they will need <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access on the <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> attribute, which contains a list of distinguished names of all users and groups that are members of that group. Being granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access will allow the user to modify the member list, adding or removing user or group objects. A user without that access right might still be able to add or remove their own user account name, however, if they’re granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp> access right for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Self-Membership</samp> write-validated access right on a group object. While this operation would still modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> attribute, the server would ensure that the added or removed value corresponds to the calling user’s distinguished name and reject any other modification.</p>
<p class="TX">The name of the access right, <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>, is likely derived from its use as a mechanism for self-group membership. Over time, its use has been expanded to cover a few additional attributes. Microsoft’s Active Directory <span aria-label=" Page 379. " epub:type="pagebreak" id="pg_379" role="doc-pagebreak"></span>Technical Specification (<i>MS-ADTS</i>, available online) refers to it as <samp class="SANS_TheSansMonoCd_W5Regular_11">RIGHT_DS_WRITE_PROPERTY_EXTENDED</samp>, which is a slightly better description.</p>
<p class="TX">We won’t perform an example access check for write-validated access because it’s the same as the check shown in <a href="chapter11.xhtml#Lis11-35">Listing 11-35</a> for control access rights; simply change the extended right you query and check that <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp> access is granted. As with <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp>, it’s possible for a non-object ACE to grant <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp> access without having a specific ACE for the write-validated access right.</p>
<p class="TX">Note that an administrator can’t modify the list of write-validated access rights; this is because the directory server won’t know to enforce the restriction. A third-party application can’t implement this behavior, either, as its purpose is to limit the changes that can be made to the directory.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="H2" id="sec28"><span id="h2-126"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the SELF SID</samp></h4>
<p class="TNI1">When I discussed the object type access check in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, I also mentioned a principal SID that you can specify to replace the <i>SELF</i> SID in an ACE. Active Directory uses the <i>SELF</i> SID to grant access to resources based on whether the user making the request is the “self” in question. It extracts the SID to use as this principal SID from the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp> attribute, used to store the SID for the user or computer account, as well as the group SID.</p>
<p class="TX">For example, if you want to modify a user object in the directory, the server will look up the object’s security descriptor and query for the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp> attribute. If the attribute is present in the object, the access check will use the value as the principal SID, along with the security descriptor. If the attribute isn’t present, no principal SID will be set, and any ACE with the <i>SELF</i> SID won’t be evaluated. <a href="chapter11.xhtml#Lis11-37">Listing 11-37</a> shows how to extract the <samp class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp> attribute.</p>
<span id="Lis11-37"></span><pre><code>PS&gt; <b>$computer = Get-ADComputer -Identity $env:COMPUTERNAME</b>
PS&gt; <b>$computer.SID.ToString()</b>
S-1-5-21-1195776225-522706947-2538775957-1104

PS&gt; <b>Get-DsObjectSid -DistinguishedName $computer.DistinguishedName</b>
Name              Sid
----              ---
MINERAL\GRAPHITE$ S-1-5-21-1195776225-522706947-2538775957-1104
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-37: Getting a computer account’s objectSID</span></p>
<p class="TX">There are multiple ways of accessing the attribute. The simplest is to use either the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroup</samp> command, which will automatically extract the SID. In <a href="chapter11.xhtml#Lis11-37">Listing 11-37</a>, we get the SID for the current computer. Alternatively, if you’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>, you can request the <samp class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp> attribute to access the property directly.</p>
<p class="TX">You can also use a command that comes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module: <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsObjectSid</samp>, which requires the full distinguished name of the object to query. The main advantage of this command is that it returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Sid</samp> class you can use in the access check without converting the value into the correct <span aria-label=" Page 380. " epub:type="pagebreak" id="pg_380" role="doc-pagebreak"></span>format. You can pass the returned SID to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp> parameter. We’ll use it in the worked example at the end of the chapter.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="H2" id="sec29"><span id="h2-127"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing Additional Security Checks</samp></h4>
<p class="TNI1">In most cases the access check process grants access to the directory based on the security descriptors assigned to objects, but there are several exceptions to this. For example, the directory supports privileges such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>, for changing the components of a security descriptor. Let’s discuss a few additional nonstandard checks.</p>
<section aria-labelledby="sec30" epub:type="division">
<h5 class="H3" id="sec30"><span id="h3-32"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Workstations to a Domain</samp></h5>
<p class="TNI1">In a default domain configuration, the <i>Authenticated Users</i> group is granted a special privilege on the domain controller called <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>. This privilege allows any domain user to join a computer to a domain, which, at a low level, means creating a computer object.</p>
<p class="TX">When a user tries to create a computer object, the directory server checks whether the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access for the target object. If not, it checks whether they have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp> privilege. If they do, it allows the creation operation.</p>
<p class="TX">However, in the latter case the server limits the attributes the user can set at creation time. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp> privilege doesn’t allow a user to set an arbitrary <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSecurityDescriptor</samp> attribute; the object must use the default security descriptor. The values for attributes the user is allowed to set, like the username, must also match a fixed pattern, and the security descriptor must use the <i>Domain Admins</i> SID as its owner and group SIDs, limiting the user’s access to the object after its creation.</p>
<p class="TX">An individual user can create only a fixed number of computer accounts. By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ms-DS-MachineAccountQuota</samp> attribute in the root of the directory sets this limit to 10. To enforce this restriction during the creation of a new computer object, the server searches all existing computer objects and checks their <samp class="SANS_TheSansMonoCd_W5Regular_11">mS-DS-CreatorSID</samp> attribute, which stores the SID of the user who created the object. The server then calculates the number of computers the caller has already added, and if it’s over the quota, it rejects the request. However, if the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access, the quota doesn’t apply. <a href="chapter11.xhtml#Lis11-38">Listing 11-38</a> shows how to query these values.</p>
<span id="Lis11-38"></span><pre><code>PS&gt; <b>$root_dn = (Get-ADRootDSE).defaultNamingContext</b>
PS&gt; <b>$obj = Get-ADObject $root_dn -Properties 'ms-DS-MachineAccountQuota'</b>
PS&gt; <b>$obj['ms-DS-MachineAccountQuota']</b>
10

PS&gt; <b>Get-ADComputer -Filter * -Properties 'mS-DS-CreatorSID' | ForEach-Object {</b>
<b>    $creator = $_['mS-DS-CreatorSID']</b>
<b>    if ($creator.Count -gt 0) {</b>
<b>        $sid = Get-NtSid -Sddl $creator[0]</b>
<b>        Write-Host $_.Name, " - ", $sid.Name</b>
<b>    }</b>
<b>}</b>
<span aria-label=" Page 381. " epub:type="pagebreak" id="pg_381" role="doc-pagebreak"></span>GRAPHITE - MINERAL\alice
TOPAZ - MINERAL\alice
PYRITE - MINERAL\bob
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-38: Querying the SIDs used to enforce computer account creation quotas</span></p>
<p class="TX">You can create a new computer account using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ADComputer</samp> command, specifying the required attributes. For example, <a href="chapter11.xhtml#Lis11-39">Listing 11-39</a> creates the computer account <i>DEMOCOMP</i> with a known password.</p>
<span id="Lis11-39"></span><pre><code>PS&gt; <b>$pwd = ConvertTo-SecureString -String "Passw0rd1!!!" -AsPlainText -Force</b>
PS&gt; <b>$name = "DEMOCOMP"</b>
PS&gt; <b>$dnsname = "$name.$((Get-ADDomain).DNSRoot)"</b>
PS&gt; <b>New-ADComputer -Name $name -SAMAccountName "$name`$" -DNSHostName $dnsname</b>
<b>-ServicePrincipalNames "HOST/$name" -AccountPassword $pwd -Enabled $true</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-39: Creating a new computer account in the domain</span></p>
<p class="TX">You can also create an account using the SAM remote service, as shown in <a href="chapter11.xhtml#Lis11-40">Listing 11-40</a>.</p>
<span id="Lis11-40"></span><pre><code>PS&gt; <b>$sam = Connect-SamServer -ServerName PRIMARYDC</b>
PS&gt; <b>$domain = Get-SamDomain -Server $sam -User</b>
PS&gt; <b>$user = New-SamUser -Domain $domain -Name 'DEMOCOMP$' -AccountType </b>
<b>Workstation</b>
PS&gt; <b>$pwd = ConvertTo-SecureString -String "Passw0rd1!!!" -AsPlainText -Force</b>
PS&gt; <b>$user.SetPassword($pwd, $false)</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-40: Creating a new computer in the domain via the SAM remote service</span></p>
<p class="TX">Servers typically create an account in this way when you join a computer to a domain.</p>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h5 class="H3" id="sec31"><span id="h3-33"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">User Delegation Rights</samp></h5>
<p class="TNI1">In a default domain configuration, the <i>Administrators</i> group is granted a special privilege on the domain controller: the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp> privilege, which allows users to modify the Kerberos delegation settings. Specifically, it lets them do the following:</p>
<ul class="ul">
<li class="ListBullet">Set the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedForDelegation</samp> user account control flag.</li>
<li class="ListBullet">Set the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthenticateForDelegation</samp> user account control flag.</li>
<li class="ListBullet">Modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp> attribute of a user or computer object.</li>
</ul>
<p class="TX">We’ll discuss Kerberos delegation and the use of these settings in more detail in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h5 class="H3" id="sec32"><span id="h3-34"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Protected Objects</samp></h5>
<p class="TNI1">The root domain of the directory shares its domain configuration and schema with the entire forest, meaning changes to a user in other domains will eventually be replicated in the root domain. But allowing a child <span aria-label=" Page 382. " epub:type="pagebreak" id="pg_382" role="doc-pagebreak"></span>domain to modify the domain configuration or schema is not a good idea, so the server implements a way of protecting objects from being directly modified, deleted, or moved.</p>
<p class="TX">Rather than storing this protection as an object attribute or an ACE, the server sets the resource manager control flag in the security descriptor to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. The technical specification refers to this bit flag as <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_PRIVATE_OBJECT</samp>. If the object’s security descriptor has this flag set and the object is in the schema’s or configuration’s naming context, then users cannot modify the object unless their owner SID belongs to the same domain as the domain controller on which the modification is being performed.</p>
<p class="TX">For example, most objects in the configuration are owned by the <i>Enterprise Admins</i> group, a <i>Universal</i> group defined in the root domain. So, if an object is protected, only a domain controller in the root domain can modify it directly. <a href="chapter11.xhtml#Lis11-41">Listing 11-41</a> contains a short script that searches for protected objects in the configuration naming context by checking the resource manager control flags. No other Windows feature uses these resource manager control flags, as far as I can tell.</p>
<span id="Lis11-41"></span><pre><code>PS&gt; <b>$conf_nc = (Get-ADRootDSE).configurationNamingContext</b>
PS&gt; <b>Get-ADObject -SearchBase $conf_nc -SearchScope Subtree -Filter * |</b>
<b>ForEach-Object {</b>
<b>    $sd = Get-Win32SecurityDescriptor -Name $_.DistinguishedName -Type Ds</b>
<b>    if ($sd.RmControl -eq 1) {</b>
<b>        $_.DistinguishedName</b>
<b>    }</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-41: Finding protected configuration objects</span></p>
<p class="TX">In a default installation of an Active Directory server, <a href="chapter11.xhtml#Lis11-41">Listing 11-41</a> should output no results, as the directory shouldn’t have any protected objects.</p>
<p class="TX">This concludes our discussion of access checking, although we’ll come back to it in an expansive worked example at the end of the chapter. Next, we’ll cover two final Active Directory topics: how user and device claims are stored in the directory, and how group policies are configured.</p>
</section>
</section>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h3 class="H1" id="sec33"><span id="h1-87"></span><samp class="SANS_Futura_Std_Bold_B_11">Claims and Central Access Policies</samp></h3>
<p class="TNI1">In the preceding chapters we discussed user and device claims, how tokens store them as security attributes, and how access checks use them. Claims are especially important for enabling central access policies, as we discussed in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
<p class="TX">The domain’s Active Directory server stores both claims and central access policies, and it can apply these whenever a user authenticates or a computer synchronizes its policy. <a href="chapter11.xhtml#Lis11-42">Listing 11-42</a> shows how to query the Active Directory server for a claim using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADClaimType</samp> PowerShell command, which searches for objects of the schema class <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-ClaimType</samp><i>.</i></p>
<span id="Lis11-42"></span><pre><code><span aria-label=" Page 383. " epub:type="pagebreak" id="pg_383" role="doc-pagebreak"></span>PS&gt; <b>Get-ADClaimType -Filter {DisplayName -eq "Country"} |</b>
<b>Format-List ID, ValueType, SourceAttribute, AppliesToClasses</b>
ID              <b> </b>: ad://ext/country
ValueType        : String
SourceAttribute  : CN=Text-Country,CN=Schema,CN=Configuration,...
AppliesToClasses : {CN=User,CN=Schema,CN=Configuration,...}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-42: Displaying properties of the Country claim</span></p>
<p class="TX">In this example, we find that an administrator configured the <samp class="SANS_TheSansMonoCd_W5Regular_11">Country</samp> claim when setting up the domain; it isn’t available by default. This claim represents the name of the user’s country.</p>
<p class="TX">We show only a few of the relevant properties of the object. The first is the claim’s ID, used for the security attribute in the token; in this case, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ad://ext/country</samp>. We also show the value’s type, used to determine what security attribute values to add to the token; in this case, it’s a string.</p>
<p class="TX">The next property is the distinguished name of the schema attribute from which the value is derived. (It’s possible for a claim to be derived from other data, such as values on a user’s smart card, but sourcing the claim from a schema attribute is the simplest case.) When the user is authenticated, the token will construct the claim based on the attribute value from their user object; if the attribute isn’t set, the claim won’t be added to the token. An administrator can modify the directory schema to add new attributes from which to derive their own claims, such as a user’s security clearance.</p>
<p class="TX">Finally, we display the list of schema classes to which this claim applies. In this case, only the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> schema class appears in the listing. If this list contained the distinguished name of the <samp class="SANS_TheSansMonoCd_W5Regular_11">computer</samp> class, it would be a device claim, not a user claim, although claims can apply to both users and computers.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-43">Listing 11-43</a> shows how to display the properties of a central access policy in the directory.</p>
<span id="Lis11-43"></span><pre><code>PS&gt; <b>$policy = Get-ADCentralAccessPolicy -Identity "Secure Room Policy"</b>
PS&gt; <b>$policy | Format-List PolicyID, Members</b>
PolicyID : S-1-17-3260955821-1180564752-550833841-1617862776
Members  : {CN=Secure Rule,CN=Central Access Rules,CN=Claims...}

PS&gt; <b>$policy.Members | ForEach-Object {Get-ADCentralAccessRule -Identity $_} |</b>
<b>Format-List Name, ResourceCondition, CurrentAcl</b>
Name              : Secure Rule
ResourceCondition : (@RESOURCE.EnableSecure == 1)
CurrentAcl        : D:(XA;;FA;;;WD;((@USER.ad://ext/clearance...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-43: Displaying properties of a central access policy</span></p>
<p class="TX">Administrators deploy central access policies to a domain’s computers and servers based on the group policy configuration. This allows them to selectively deploy a policy to a specific subset of systems in the domain. The policy’s configuration is stored in the directory, however.</p>
<p class="TX"><span aria-label=" Page 384. " epub:type="pagebreak" id="pg_384" role="doc-pagebreak"></span>The policy consists of two components: the policy object itself, represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">msAuthz-CentralAccessPolicy</samp> schema class, and one or more central access rules, represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">msAuthz-CentralAccessRule</samp> schema class.</p>
<p class="TX">In <a href="chapter11.xhtml#Lis11-43">Listing 11-43</a>, we first query for a specific central access policy named <samp class="SANS_TheSansMonoCd_W5Regular_11">Secure Room Policy</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADCentralAccessPolicy</samp> PowerShell command. From the policy we can extract the policy SID, which we use to apply the policy to a resource, as well as a list of the distinguished names of each member rule.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Get-ADCentralAccessPolicy</samp> command differs from the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Get-CentralAccessPolicy</samp> command I demonstrated in <a href="chapter7.xhtml">Chapter 7</a>. The former reads all policies from the Active Directory server, whereas the latter shows only the policies configured to be enabled on the local system.</i></p>
</blockquote>
<p class="TX">We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADCentralAccessRule</samp> command to get each of the policy rules. In this example, there is only one rule. We display its name, the resource condition used to determine when the rule is enabled, and the DACL, which determines the level of access a user will be granted on the resource for which the rule is applied. Refer to <span class="Xref"><a href="chapter5.xhtml">Chapters 5</a></span> and <span class="Xref"><a href="chapter7.xhtml">7</a></span> for more information about the implementation of central access policies.</p>
</section>
<section aria-labelledby="sec34" epub:type="division">
<h3 class="H1" id="sec34"><span id="h1-88"></span><samp class="SANS_Futura_Std_Bold_B_11">Group Policies</samp></h3>
<p class="TNI1">On a stand-alone system, the local policy combines information from the LSA policy’s configuration with various registry settings that define what applications can do. In a domain network, an administrator can configure a policy for the entire network using <i>group policies</i>. Domain-joined computers download these policies on a regular basis (generally, every 90 minutes by default). Computers then merge these group policies with any existing local policy settings to define the computer’s overall policy.</p>
<p class="TX"><a href="chapter11.xhtml#fig11-6">Figure 11-6</a> shows how a domain network configures group policies.</p>
<figure class="IMG"><img alt="" class="img1" height="712" id="fig11-6" src="../images/Figure11-6.jpg" width="1363"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: The configuration of group policies</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 385. " epub:type="pagebreak" id="pg_385" role="doc-pagebreak"></span>The root domain and any organizational unit object can contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute. An <i>organizational unit</i> is a directory container that represents some structure in an organization. For example, an administrator could create different organizational units for different offices, then apply different policies for computers within those organizational units.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute contains a list of the domain names belonging to the group policy objects applied to the organizational unit. The group policy objects themselves don’t contain the actual policy settings. Instead, the object contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">gPCFileSysPath</samp> attribute that represents a filepath to a policy configuration file, which contains the settings. This filepath typically points to a special network file share, <i>SYSVOL</i>, which contains the configuration files.</p>
<p class="TX">What policies to apply depends on where the computer’s account object is stored in the directory. For example, in <a href="chapter11.xhtml#fig11-6">Figure 11-6</a>, the administrator has created the <i>Servers</i> organizational unit, then added the <i>CINNABAR</i> server account to that container. The organizational unit has the <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute, which links to the Servers Group Policy object.</p>
<p class="TX">However, the organizational unit also lives in the root domain, which has its own <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute and assigned policy. When the <i>CINNABAR</i> server updates its group policy, it will discover all of these linked group policies in the parent directory hierarchy and use that information to download and apply the policies. The most specific policy takes precedence; for example, for <i>CINNABAR</i>, the Servers Group Policy would override conflicting settings in the Default Group Policy. The server will merge any settings that don’t conflict when creating the final policy.</p>
<p class="TX">In <a href="chapter11.xhtml#Lis11-44">Listing 11-44</a>, we query for group policy objects on the Active Directory server.</p>
<span id="Lis11-44"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Get-ADOrganizationalUnit -Filter * -Properties gpLink |</b>
<b>Format-List Name, LinkedGroupPolicyObjects</b>
Name                     : Domain Controllers
LinkedGroupPolicyObjects : {CN={6AC1786C-016F-11D2-945F-00C04fB984F9},...}

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$policy = Get-ADObject -Filter {</b>
<b>    ObjectClass -eq "groupPolicyContainer" </b>
<b>} -Properties *</b>
PS&gt; <b>$policy | Format-List displayName, gPCFileSysPath</b>
displayName<b>    </b>: Default Domain Policy
gPCFileSysPath : \\mineral.local\sysvol\mineral.local\Policies\{31B2F340-...}

displayName<b>    </b>: Default Domain Controllers Policy
gPCFileSysPath : \\mineral.local\sysvol\mineral.local\Policies\{6AC1786C-...}

displayName<b>    </b>: Default Servers Domain Policy
gPCFileSysPath : \\mineral.local\sysvol\mineral.local\Policies\{6B108F70-...}

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>ls $policy[0].gPCFileSysPath</b>
Directory: \\mineral.local\sysvol\mineral.local\Policies\{31B2F340-016D-...}

Mode<b>                 </b>LastWriteTime         Length Name
----                 -------------         ------ ----
d-----         3/12/2023  12:56 PM                 Adm
<span aria-label=" Page 386. " epub:type="pagebreak" id="pg_386" role="doc-pagebreak"></span>d-----         3/12/2023  <b> </b>1:02 PM                 MACHINE
d-----          4/6/2023   8:18 PM                 USER
-a----          4/6/2023   8:24 PM             22  GPT.INI

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$dc_policy = $policy |</b>
<b>Where-Object DisplayName -eq "Default Domain Controllers Policy"</b>
PS&gt; <b>$dc_path = $dc_policy.gPCFileSysPath</b>
PS&gt; <b>Get-Content "$dc_path\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf" |</b>
<b>Select-String "SeEnableDelegationPrivilege", "SeMachineAccountPrivilege"</b>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> SeMachineAccountPrivilege = *S-1-5-11
SeEnableDelegationPrivilege = *S-1-5-32-544
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-44: Finding group policy objects</span></p>
<p class="TX">First, we query for organizational unit objects in the directory using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADOrganizationalUnit</samp> command and request the <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We display the name and the list of group policy objects for each organizational unit.</p>
<p class="TX">We could now take the group policy object’s distinguished names from the <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute and manually look up each one. Instead, let’s simply search for all objects of class <samp class="SANS_TheSansMonoCd_W5Regular_11">groupPolicyContainer</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> PowerShell command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This shows us the name of each policy object, as well as the path to the real policy store on the <i>SYSVOL</i> file server.</p>
<p class="TX">We can also list the contents of the policy directory on the file server <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Depending on how complex the policy is, the file share might contain many different files. A group policy can apply to a particular machine, as well as on a per-user basis, which is why there are separate <i>MACHINE</i> and <i>USER</i> directories.</p>
<p class="TX">We won’t discuss the configuration of group policies any further, but I recommend inspecting the files contained in the file share during your security research. Group policies can contain a wealth of information related to the configuration of computers and users in the domain. Sometimes this policy configuration includes shared passwords for user accounts or private key material. Because any user on the network can access the <i>SYSVOL</i> share, an attacker could extract this information to gain additional privileges on the network.</p>
<p class="TX">As a minor example of information leakage, you could determine which SIDs would be granted the two special privileges, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp>, on a domain controller. The group policy assigned to the domain controller typically stores this privilege assignment information in the <i>GptTmpl.inf</i> file, which any user in the domain can access. (The LSA domain policy remote service discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> can also provide this information, but it requires administrator privileges.)</p>
<p class="TX">In <a href="chapter11.xhtml#Lis11-44">Listing 11-44</a>, we retrieve the Default Domain Controllers Policy <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, the only policy applied in our simple environment. We then extract the privileges from the file using a simple string selection. In this example, we find the default configuration: <i>Authenticated Users</i> is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>, and <i>BUILTIN\Administrators</i> is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp> <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
</section>
<section aria-labelledby="sec35" epub:type="division">
<h3 class="H1" id="sec35"><span id="h1-89"></span><span aria-label=" Page 387. " epub:type="pagebreak" id="pg_387" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Example</samp></h3>
<p class="TNI1">In this chapter’s single worked example, we’ll walk through a script that checks a user’s access to every object we can find in the local Active Directory server. This process is quite involved, so I’ve broken it into multiple sections.</p>
<section aria-labelledby="sec36" epub:type="division">
<h4 class="H2" id="sec36"><span id="h2-128"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Authorization Context</samp></h4>
<p class="TNI1">Throughout this chapter, we’ve been using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command to run the access check for a security descriptor. This command is fine for testing purposes, but it causes a subtle problem when used to check real-world security descriptors in the Active Directory server.</p>
<p class="TX">The command uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheck</samp> system call, which uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object to represent the user’s identity. However, the token’s group membership is based on the local system’s LSA user configuration, and the domain controller is unlikely to use the same groups. For example, many security descriptors in the directory grant full access to the <i>BUILTIN\Administrators</i> group, but these local administrators won’t necessarily also be administrators on the domain controller.</p>
<p class="TX">We need a way of running an access check using the groups from the domain controller. One option is to run the access check on the domain controller itself. However, that only works if we have full control over the network, which is best avoided. A second option would be to manually create a token with the necessary groups, but this would still require elevated local privileges. Finally, we could use our own implementation of the access check, such as the one we built in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, but this risks introducing incorrect behavior.</p>
<p class="TX">We do have another option: Windows provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp> (authorization) API, which has a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZAccessCheck</samp> that we can use to perform an access check based on a constructed authorization context rather than a token. This API runs entirely in user mode, and the authorization context for a user can contain any groups the caller likes. If you don’t want to enable auditing, the APIs also work without any elevated privileges.</p>
<p class="TX">A big advantage of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp> API over a custom access check implementation is that it shares code with the kernel’s own access check implementation, and therefore, it should be correct. As a bonus, it’s also the same API used by the Active Directory server to perform access checks, so its results should match the server’s when given the correct authorization context.</p>
<p class="TX">We can build an authorization context for a domain user based only on information that we can extract from the domain without administrator privileges. <a href="chapter11.xhtml#Lis11-45">Listing 11-45</a> shows how to build the authorization context.</p>
<span id="Lis11-45"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>function Add-Member($Set, $MemberOf) {</b>
<b>    foreach($name in $MemberOf) {</b>
<b>        if ($Set.Add($name)) {</b>
<b>            $group = Get-ADGroup $name -Properties MemberOf</b>
<b>            Add-Member $Set $group.MemberOf</b>
<span aria-label=" Page 388. " epub:type="pagebreak" id="pg_388" role="doc-pagebreak"></span><b>        }</b>
<b>    }</b>
<b>}</b>

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>function Get-UserGroupMembership($User) {</b>
<b>    $groups = [System.Collections.Generic.HashSet[string]]::new(</b>
<b>        [System.StringComparer]::OrdinalIgnoreCase</b>
<b>    )</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> Add-Member $groups $User.PrimaryGroup</b>
<b>    Add-Member $groups $User.MemberOf</b>

<b>  </b><span aria-label="annotation4" class="CodeAnnotationCode2">❹</span><b> $auth_users = Get-ADObject -Filter {</b>
<b>        ObjectClass -eq "foreignSecurityPrincipal" -and Name -eq "S-1-5-11"</b>
<b>    } -Properties memberOf</b>
<b>    Add-Member $groups $auth_users.MemberOf</b>
<b>  </b><span aria-label="annotation5" class="CodeAnnotationCode2">❺</span><b> $groups | ForEach-Object {Get-DsObjectSid $_}</b>
<b>}</b>

PS&gt; <b>function Get-AuthContext($username) {</b>
  <span aria-label="annotation6" class="CodeAnnotationCode2">❻</span><b> $user = Get-ADUser -Identity $username -Properties memberOf, primaryGroup</b>
<b>-ErrorAction Continue</b>
<b>    if ($null -eq $user) {</b>
<b>        $user = Get-ADComputer -Identity $username -Properties memberOf,</b>
<b>primaryGroup</b>
<b>    }</b>
<b>    $sids = Get-UserGroupMembership $user</b>

<b>  </b><span aria-label="annotation7" class="CodeAnnotationCode2">❼</span><b> $rm = New-AuthZResourceManager</b>
<b>  </b><span aria-label="annotation8" class="CodeAnnotationCode2">❽</span><b> $ctx = New-AuthZContext -ResourceManager $rm -Sid $user.SID.Value</b>
<b>-Flags SkipTokenGroups</b>
<b>  </b><span aria-label="annotation9" class="CodeAnnotationCode2">❾</span><b> Add-AuthZSid $ctx -KnownSid World</b>
<b>    Add-AuthZSid $ctx -KnownSid AuthenticatedUsers</b>
<b>    Add-AuthZSid $ctx -Sid $sids</b>
<b>    $rm.Dispose()</b>
<b>    $ctx</b>
<b>}</b>

<span aria-label="annotation10" class="CodeAnnotationHang1">❿</span> PS&gt; <b>$ctx = Get-AuthContext "alice"</b>
PS&gt; <b>$ctx.Groups</b>
Name                                       Attributes
----                                       ----------
Everyone                                   Enabled
NT AUTHORITY\Authenticated Users           Enabled
MINERAL\Domain Users                       Enabled
BUILTIN\Users                              Enabled
BUILTIN\Pre-Windows 2000 Compatible Access Enabled
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-45: Building an authorization context for the access check</span></p>
<p class="TX">In the directory, user and group objects have a <samp class="SANS_TheSansMonoCd_W5Regular_11">memberOf</samp> attribute that lists the distinguished names of the group objects that the user or group is a member of. We can use this list to recursively inspect the directory to find all groups. This is what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-Member</samp> function is doing <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX"><span aria-label=" Page 389. " epub:type="pagebreak" id="pg_389" role="doc-pagebreak"></span>We then define a function to get a list of member SIDs from a user object <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We need to add the root groups, which include the user’s primary group <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and groups referenced by the <samp class="SANS_TheSansMonoCd_W5Regular_11">memberOf</samp> attribute. We also need to add groups from SIDs that are outside the domain. These are stored as foreign security principals. In the example, we find the entry for <i>Authenticated Users</i>, a group that all users are a member of, and add its group memberships <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We now have a list of distinguished names for group objects, which we convert to a list of SIDs that we can add to the authorization context <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">Next, we build the authorization context itself. We start by querying for the user object <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>; if that fails, we check for a computer object and get the list of SIDs the account is a member of. Then we create an <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp> resource manager <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, which (as its name suggests) is used to manage resources. For example, we can use it to cache access checks between contexts.</p>
<p class="TX">We create the authorization context using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-AuthZContext</samp> command <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. We need to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">SkipTokenGroups</samp> flag when creating the context so that only the user’s SID gets added to it. Otherwise, the context will contain the list of local groups, which defeats the purpose of gathering the groups on the domain controller.</p>
<p class="TX">We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-AuthZSid</samp> command to add the group SIDs to the context <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>, making sure to include the default <i>World</i> and <i>Authenticated Users</i> groups. Finally, we test the behavior of the functions for the user <i>alice</i> <span aria-label="annotation10" class="CodeAnnotationCode">❿</span>, printing out the list of domain groups the user is a member of on the domain controller.</p>
<aside aria-label="box-3" class="box">
<p class="BoxTitle" id="box-3"><samp class="SANS_Dogma_OT_Bold_B_11">THE REMOTE ACCESS CHECK PROTOCOL</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp> <samp class="SANS_Futura_Std_Book_11">API supports another mechanism for running an access check with the correct group list, but without running code directly on the domain controller. Computers on a domain, including the domain controller, expose a remote access check network protocol that you can connect to when creating the resource manager.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Normal users on the domain won’t be able to call the protocol, which requires the calling user to be a member of either the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Administrators</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Access Control Assistance Operators</samp> <samp class="SANS_Futura_Std_Book_11">group on the domain controller, making it somewhat less useful. However, you might be a member of one of these groups without even realizing it, so it’s worth trying to connect to the service and perform an access check. The following commands create an authorization context with a connection to the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">PRIMARYDC</samp> <samp class="SANS_Futura_Std_Book_11">domain controller:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">$rm</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">New-AuthZResourceManager -Server PRIMARYDC.mineral.local</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">$ctx</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">New-AuthZContext -ResourceManager $rm -Sid (Get-NtSid)</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">$ctx.User</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">Name          Attributes</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">----          ----------</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">MINERAL\alice None</samp>

<span aria-label=" Page 390. " epub:type="pagebreak" id="pg_390" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">$ctx.Groups</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">Name                                 Attributes</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">----                                 ------------</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">MINERAL\Domain Users                 Mandatory, EnabledByDefault, Enabled</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">Everyone                             Mandatory, EnabledByDefault, Enabled</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">BUILTIN\Access Control Assistance... Mandatory, EnabledByDefault, Enabled</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--snip--</samp>
</code></pre>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">These commands could replace the entirety of <a href="chapter11.xhtml#Lis11-45">Listing 11-45</a>. To use the remote access check protocol, we specify the DNS name of the domain controller using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> <samp class="SANS_Futura_Std_Book_11">parameter of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">New-AuthZResourceManager</samp> <samp class="SANS_Futura_Std_Book_11">command. We then create the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp> <samp class="SANS_Futura_Std_Book_11">context with the SID of the user. We don’t need to specify any flags, as the service will base the group list on the server running the remote access check protocol (in this case, the domain controller). We can verify the assigned user and groups to confirm that their values are based on the domain controller’s local group assignment.</samp></p>
</aside>
</section>
<section aria-labelledby="sec37" epub:type="division">
<h4 class="H2" id="sec37"><span id="h2-129"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Gathering Object Information</samp></h4>
<p class="TNI1">With the authorization context in hand, we can begin the access check. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AuthZGrantedAccess</samp> command, which works almost the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> but relies on the context we’ve created. We’ll start by gathering information about the object we want to check. We need the following details:</p>
<ul class="ul">
<li class="ListBullet">The security descriptor of the object</li>
<li class="ListBullet">The object SID, if present, for the principal SID</li>
<li class="ListBullet">All schema classes, including auxiliary and child classes</li>
<li class="ListBullet">Allowed schema attributes and associated property sets</li>
<li class="ListBullet">Applicable control and write-validated access rights</li>
</ul>
<p class="TX"><a href="chapter11.xhtml#Lis11-46">Listing 11-46</a> implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ObjectInformation</samp> function, which gathers this information about an object based on its distinguished name.</p>
<span id="Lis11-46"></span><pre><code>PS&gt; <b>function Get-ObjectInformation($Name) {</b>
<b>    $schema_class = Get-DsObjectSchemaClass $Name</b>
<b>    $sid = Get-DsObjectSid $Name</b>
<b>    $all_classes = Get-DsSchemaClass $schema_class.Name -Recurse -IncludeAuxiliary</b>
<b>    $attrs = $all_classes.Attributes | Get-DsSchemaAttribute |</b>
<b>Sort Name -Unique</b>
<b>    $infs = Get-DsSchemaClass $schema_class.Name -Inferior</b>
<b>    $rights = $all_classes | ForEach-Object {Get-DsExtendedRight -SchemaClass $_} | </b>
<b>Sort Name -Unique</b>
<b>    [PSCustomObject]@{</b>
<b>        Name=$Name</b>
<b>        SecurityDescriptor=Get-Win32SecurityDescriptor -Name $Name -Type Ds</b>
<span aria-label=" Page 391. " epub:type="pagebreak" id="pg_391" role="doc-pagebreak"></span><b>        SchemaClass=Get-DsObjectSchemaClass $Name</b>
<b>        Principal=$sid</b>
<b>        Attributes=$attrs</b>
<b>        Inferiors=$infs</b>
<b>        PropertySets=$rights | Where-Object IsPropertySet</b>
<b>        ControlRight=$rights | Where-Object IsControl</b>
<b>        ValidatedWrite=$rights | Where-Object IsValidatedWrite</b>
<b>    }</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-46: Implementing the Get-ObjectInformation function</span></p>
<p class="TX">We can test the function by passing it the distinguished name of the object for which we want the information, as shown in <a href="chapter11.xhtml#Lis11-47">Listing 11-47</a>.</p>
<span id="Lis11-47"></span><pre><code>PS&gt; <b>$dn_root = (Get-ADRootDSE).defaultNamingContext</b>
PS&gt;<b> Get-ObjectInformation $dn_root</b>
Name               : DC=mineral,DC=local
SchemaClass        : domainDNS
Principal          : S-1-5-21-146569114-2614008856-3334332795
Attributes         : {adminDescription, adminDisplayName...}
Inferiors          : {device, samServer, ipNetwork, organizationalUnit...}
PropertySets       : {Domain-Other-Parameters, Domain-Password}
ControlRight       : {Add-GUID, Change-PDC, Create-Inbound-Forest-Trust...}
ValidatedWrite     :
SecurityDescriptor : O:BAG:BAD:AI(OA;CIIO;RP;4c164200-20c0-11d0-...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-47: Gathering object information</span></p>
<p class="TX">In this example, we request the information for the root domain object. You could cache most of the returned information about the schema class, as only the security descriptor and object SID typically change between objects. However, for simplicity, we’ll gather the information for every request.</p>
</section>
<section aria-labelledby="sec38" epub:type="division">
<h4 class="H2" id="sec38"><span id="h2-130"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Access Check</samp></h4>
<p class="TNI1">We now have everything we need to perform a maximum access check for an object. However, it’s not as simple as passing the security descriptor and the authorization context to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp> access check API and calling it a day. We must separately handle each type of resource (such as classes, attributes, control access rights, and write-validated access rights) to make sure we capture the maximum allowed access.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-48">Listing 11-48</a> contains the functions to run the access check process. For simplicity, we’ll focus on capturing access rights that could result in a modification of the object. However, you could easily modify the functions to capture read access, as well.</p>
<span id="Lis11-48"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>function Test-Access($Ctx, $Obj, $ObjTree, $Access) {</b>
    <b>Get-AuthZGrantedAccess -Context $ctx -ObjectType $ObjTree</b>
<b>-SecurityDescriptor $Obj.SecurityDescriptor -Principal $Obj.Principal</b>
<b>-Access $Access | Where-Object IsSuccess</b>
<b>}</b>

<span aria-label=" Page 392. " epub:type="pagebreak" id="pg_392" role="doc-pagebreak"></span>PS&gt; <b>function Get-PropertyObjTree($Obj) {</b>
<b>    $obj_tree = New-ObjectTypeTree $obj.SchemaClass</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> foreach($prop_set in $Obj.PropertySets) {</b>
<b>        Add-ObjectTypeTree $obj_tree $prop_set</b>
<b>    }</b>

<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> $fake_set = Add-ObjectTypeTree $obj_tree -PassThru</b>
<b>-ObjectType "771727b1-31b8-4cdf-ae62-4fe39fadf89e"</b>
<b>   foreach($attr in $Obj.Attributes) {</b>
<b>        if (-not $attr.IsPropertySet) {</b>
<b>            Add-ObjectTypeTree $fake_set $attr</b>
<b>        }</b>
<b>    }</b>
<b>    $obj_tree</b>
<b>}</b>

PS&gt; <b>function Get-AccessCheckResult($Ctx, $Name) {</b>
<b>    try {</b>
<b>      </b><span aria-label="annotation4" class="CodeAnnotationCode2">❹</span><b> $obj = Get-ObjectInformation $Name</b>
<b>        $access = Test-Access $ctx $obj $obj.SchemaClass "MaximumAllowed" |</b>
<b>        Select-Object -ExpandProperty SpecificGrantedAccess</b>

<b>      </b><span aria-label="annotation5" class="CodeAnnotationCode2">❺</span><b> $obj_tree = Get-PropertyObjTree $obj</b>
<b>        $write_attr = Test-Access $ctx $obj $obj_tree "WriteProp"</b>
<b>        $write_sets = $write_attr | Where-Object Level -eq 1 |</b>
<b>Select-Object -ExpandProperty Name</b>
<b>        $write_attr = $write_attr | Where-Object Level -eq 2 |</b>
<b>Select-Object -ExpandProperty Name</b>

<b>      </b><span aria-label="annotation6" class="CodeAnnotationCode2">❻</span><b> $obj_tree = New-ObjectTypeTree</b>
<b>-ObjectType "771727b1-31b8-4cdf-ae62-4fe39fadf89e"</b>
<b>        $obj.Inferiors | Add-ObjectTypeTree -Tree $obj_tree</b>

<b>        $create_child = Test-Access $ctx $obj $obj_tree "CreateChild" |</b>
<b>Where-Object Level -eq 1 | Select-Object -ExpandProperty Name</b>
<b>        $delete_child = Test-Access $ctx $obj $obj_tree "DeleteChild" |</b>
<b>Where-Object Level -eq 1 | Select-Object -ExpandProperty Name</b>

<b>      </b><span aria-label="annotation7" class="CodeAnnotationCode2">❼</span><b> $control = if ($obj.ControlRight.Count -gt 0) {</b>
<b>            $obj_tree = New-ObjectTypeTree -SchemaObject $obj.SchemaClass</b>
<b>            $obj.ControlRight | Add-ObjectTypeTree $obj_tree</b>
<b>            Test-Access $ctx $obj $obj_tree "ControlAccess" |</b>
<b>Where-Object Level -eq 1 | Select-Object -ExpandProperty Name</b>
<b>        }</b>

<b>      </b><span aria-label="annotation8" class="CodeAnnotationCode2">❽</span><b> $write_valid = if ($obj.ValidatedWrite.Count -gt 0) {</b>
<b>            $obj_tree = New-ObjectTypeTree -SchemaObject $obj.SchemaClass</b>
<b>            $obj.ValidatedWrite | Add-ObjectTypeTree $obj_tree</b>
<b>            Test-Access $ctx $obj $obj_tree "Self" |</b>
<b>Where-Object Level -eq 1 | Select-Object -ExpandProperty Name</b>
<b>        }</b>

<b>      </b><span aria-label="annotation9" class="CodeAnnotationCode2">❾</span><b> [PSCustomObject]@{</b>
<b>            Name=$Obj.Name</b>
<span aria-label=" Page 393. " epub:type="pagebreak" id="pg_393" role="doc-pagebreak"></span><b>            Access=$access</b>
<b>            WriteAttributes=$write_attr</b>
<b>            WritePropertySets=$write_sets</b>
<b>            CreateChild=$create_child</b>
<b>            DeleteChild=$delete_child</b>
<b>            Control=$control</b>
<b>            WriteValidated=$write_valid</b>
<b>        }</b>
<b>    } catch {</b>
<b>        Write-Error "Error testing $Name - $_"</b>
<b>    }</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-48: Running the object access check</span></p>
<p class="TX">We start by defining a few helper functions. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-Access</samp>, runs the access check based on the authorization context, the security descriptor, the object type tree, and a desired access mask <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The access check returns a list of results for each checked object type. We’re interested only in the ones that succeeded, granting some access.</p>
<p class="TX">The next helper, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PropertyObjTree</samp>, builds the object type tree used for checking property sets and attributes. The root of the tree is the object’s schema class identifier. From there, we first populate all available property sets <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We then add all remaining attributes that aren’t already in a property set by placing them into a separate dummy set <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">We can now move on to the multiple access check functions. First we get the information for an object based on its distinguished name <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We then get the maximum granted access for the object, with only the object schema class identifier as the object type. This gives us an idea of the basic rights the user will be granted, such as the ability to delete the object or modify its security descriptor.</p>
<p class="TX">Next, we build the tree for the property sets and attributes <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and run the access check using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-Access</samp> function. We’re interested only in results that grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access (most objects let any user read their attributes, so this information is less interesting). We split the access check results into writable property sets and writable individual attributes.</p>
<p class="TX">We now focus on the child classes by building the object type tree from the schema class identifier <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. Even though the directory server would check a single class at a time, we’ll perform all the checks in one go. We run two access checks, one for <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access and one for <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp> access.</p>
<p class="TX">One thing to note is that we use the dummy identifier as the root object type. If we instead used the schema class identifier for the object, the access granted to that class would propagate to all the children, potentially giving us the wrong result. Using an identifier that isn’t a real schema class should enable us to avoid this outcome.</p>
<p class="TX">We run a similar access check for control access rights <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> and write-validated access rights <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>, requesting <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>, respectively. Finally, we package all the results into a custom object to return to the caller <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>.</p>
<p class="TX"><span aria-label=" Page 394. " epub:type="pagebreak" id="pg_394" role="doc-pagebreak"></span><a href="chapter11.xhtml#Lis11-49">Listing 11-49</a> demonstrates calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessCheckResult</samp> function for an Active Directory object.</p>
<span id="Lis11-49"></span><pre><code>PS&gt; <b>$dn = "CN=GRAPHITE,CN=Computers,DC=mineral,DC=local"</b>
PS&gt; <b>$ctx = Get-AuthContext 'alice' </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
PS&gt; <b>Get-AccessCheckResult $ctx $dn </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
Name              : CN=GRAPHITE,CN=Computers,DC=mineral,DC=local
Access            : List, ReadProp, ListObject, ControlAccess, ReadControl
WriteAttributes   : {displayName, sAMAccountName, description, accountExpires...}
WritePropertySets : {User-Account-Restrictions, User-Logon}
CreateChild       :
DeleteChild       :
Control           : {Allowed-To-Authenticate, Receive-As, Send-As,...}
WriteValidated    : Validated-SPN

PS&gt; <b>$ctx = Get-AuthContext $dn</b>
PS&gt; <b>Get-AccessCheckResult $ctx $dn </b><span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
Name              : CN=GRAPHITE,CN=Computers,DC=mineral,DC=local
Access            : CreateChild, DeleteChild, List, ReadProp, ListObject,...
WriteAttributes   : {streetAddress, homePostalAddress, assistant, info...}
WritePropertySets : {Personal-Information, Private-Information}
CreateChild       : {msFVE-RecoveryInformation, ms-net-ieee-80211-...}
DeleteChild       : {msFVE-RecoveryInformation, ms-net-ieee-80211-...}
Control           : User-Change-Password
WriteValidated    : {DS-Validated-Write-Computer, Validated-SPN}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-49: Testing the Get-AccessCheckResult function</span></p>
<p class="TX">In this example I’ve used the <i>GRAPHITE</i> computer object, but you can change this distinguished name to that of any object you want to check in the directory. We first need to get the authentication context for the user (here, <i>alice</i>) <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This user created the <i>GRAPHITE</i> object and therefore has some special access other users don’t have.</p>
<p class="TX">Next, we run the access check and display the results to the console <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. You can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> property that <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> has been granted generally. This means that <i>alice</i> can use any control access right unless it is explicitly denied through an ACE (a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE also applies whenever a user or computer is marked as “User cannot change password,” blocking the <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp> control access right).</p>
<p class="TX">We can see that the user has some writable attributes and property sets but can’t create or delete any child objects. We additionally see the list of granted control and write-validated access rights. The control access rights are granted based on the top-level granted access, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Validated-SPN</samp> access right must have been granted explicitly.</p>
<p class="TX">Next, we repeat the check using the computer account <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If you compare the output with that for <i>alice</i>, you’ll notice several differences. First, the attributes and property sets that the user can write to have changed. More importantly, the computer account can create and delete any child object. The computer account also has fewer control access rights, but more write-validated access rights.</p>
<p class="TX"><span aria-label=" Page 395. " epub:type="pagebreak" id="pg_395" role="doc-pagebreak"></span>You can enumerate all objects in the local Active Directory server using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command, then pass each distinguished name to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -AccessCheckResult</samp> function to enumerate writable access across the entire directory.</p>
<p class="TX">This concludes our worked example. Hopefully, it has given you a better understanding of the nuts and bolts of the Active Directory server access check process. If you’d like to explore an existing implementation of the access check, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleDsObject</samp> command, which checks for read access in addition to write access and caches domain information to improve performance. You can use it to run a full recursive scan of the Active Directory server for the current user with the command shown in <a href="chapter11.xhtml#Lis11-50">Listing 11-50</a>.</p>
<span id="Lis11-50"></span><pre><code>PS&gt; <b>Get-AccessibleDsObject -NamingContext Default -Recurse</b>
Name      ObjectClass   UserName      Modifiable Controllable
----      -----------   --------      ---------- ------------
domain    domainDNS     MINERAL\alice False      True
Builtin   builtinDomain MINERAL\alice False      False
Computers container     MINERAL\alice False      False
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 11-50: Performing an access check</span></p>
<p class="TX">The tabular output indicates whether the user can modify each type of object, such as by changing its attributes or creating a child object, and whether any control access rights have been granted to the user for that object.</p>
</section>
</section>
<section aria-labelledby="sec39" epub:type="division">
<h3 class="H1" id="sec39"><span id="h1-90"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">We began this long chapter with a high-level overview of the information stored in Active Directory, such as the users and groups that are part of the domain, and we inspected the directory’s configuration from PowerShell using the Remote Server Administration Tools.</p>
<p class="TX">We then dug into the Active Directory server at a lower level, starting with its schema, which defines the structure of the directory. The Active Directory server consists of hierarchical objects that can contain named values called attributes. Each object and attribute has a schema representation that defines what it can contain.</p>
<p class="TX">Next, we discussed how the Active Directory server secures objects through a mandatory security descriptor attribute. We looked at examples of querying the security descriptors of existing objects, as well as how to create security descriptors for new objects. We also saw how to assign security descriptors to existing objects.</p>
<p class="TX">Once we understood how an object’s security descriptor is configured, we explored how the directory server determines what access a user has to an object and its attributes. This access check process uses unique identifiers taken from the schema representation to build object type trees. These <span aria-label=" Page 396. " epub:type="pagebreak" id="pg_396" role="doc-pagebreak"></span>make the access check granular, able to grant a user access to only a specific attribute without requiring thousands of hardcoded checks.</p>
<p class="TX">The Active Directory configuration also contains two special types of access rights: control access rights and write-validated access writes. These allow users to perform special operations on an object, such as changing a user’s password; they also prevent a user from modifying certain attribute values without confirmation from the server.</p>
<p class="TX">The access check process contains a few exceptions too. For example, a user can be granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp> privilege, which allows them to create computer objects even if no directory object grants them the necessary permission. This allows users to join their computer to a domain without needing an administrator account. However, the directory server limits what the user can do with the new computer account, to mitigate the risk of compromise.</p>
<p class="TX">Lastly, we went through a very quick overview of how a domain configures group policies through links to external network filesystems. We noted that this design could leak information about the configuration of users on a domain controller to users without administrative access.</p>
<p class="TX">We’ll return to the topic of Active Directory when we discuss Kerberos authentication in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>. Keep in mind that real-world deployments of Windows domains can be extremely complex, with many more security nuances than covered here. If you’d like to know more about how Active Directory functions and the many security edge cases it presents, consult Microsoft’s technical specification for Active Directory (<i>MS-ADTS</i>).</p>
<p class="TX">In the next chapter, we’re going to delve into how interactive authentication is implemented on Windows. This authentication allows you to log in to a desktop and use the computer’s user interface.</p>
</section>
</section>
</div></body>
</html>