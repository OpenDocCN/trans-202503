- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARDUINO-TO-RS232
    COMMUNICATION</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: The RS232 data bus is a popular wired method for electronic devices to communicate
    with one another. It was originally devised in the late 1960s and is still used
    today in industrial programmable logic controllers (PLCs) and applications that
    require reliable wired point-to-point data transfer. It’s also often used to interface
    computers with older devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter shows you how to interface an Arduino with the RS232 bus for data
    transmission and remote-control applications. You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an RS232 interface to your Arduino using a board or shield
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a PC-to-Arduino remote control that operates via RS232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up communication over RS232 between two Arduino boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the projects in this chapter as the framework for your own future
    Arduino-to-RS232 communication needs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The RS232 Bus</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RS232 bus was originally designed to allow connections between data terminals
    and modems that would then be connected to remote mainframes and minicomputers.
    The standard evolved over time, with each version being noted by a letter suffix,
    such as RS232-C. For the purposes of this chapter, I’ll refer to all versions
    of the standard as RS232.
  prefs: []
  type: TYPE_NORMAL
- en: Though the RS232 bus is an older technology, there are still many reasons to
    use it, including interfacing with older hardware and creating long, reliable
    wired data connections between devices such as your Arduino and a PC. RS232 data
    lines can stretch up to 15 meters in length before reliability becomes an issue,
    though you can extend the possible length over 15 meters by reducing the data
    speed. The examples in this chapter use 9,600 bps, but in your own projects, you
    can use lower speeds supported by the Arduino if you want.
  prefs: []
  type: TYPE_NORMAL
- en: RS232 is a serial data bus that operates in a similar manner to the Arduino’s
    serial port (usually found on pins D0 and D1). The basic RS232 connection has
    a TX (transmit) and RX (receive) wire, along with a common ground. The full RS232
    standard has additional lines used for telephony, controlling data start/stop,
    and sending status between two devices, but you won’t use these lines in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Although the RS232 bus sends sequential bits of data representing ones and zeros,
    the signal type is different from the TTL serial used with Arduino. For example,
    [Figure 17-1](chapter17.xhtml#fig17-1) shows data sent from an Arduino’s serial
    port. You can see that the ones (known as *marks* in RS232 parlance) are at 5
    V, while the zeros (*spaces*) are at 0 V.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF TTL LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE](../images/fig17-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-1: Time to live (TTL)
    logic data from the Arduino serial port</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the same piece of data being sent along RS232, as shown in [Figure
    17-2](chapter17.xhtml#fig17-2). RS232 requires marks to be a negative voltage
    and spaces to be a positive voltage.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF RS232 LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE](../images/fig17-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-2: RS232 logic data
    from an RS232 port</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using opposite voltages for marks and spaces clearly defines the 2 bits, avoiding
    potential confusion and thus increasing data accuracy. For each byte of data sent,
    RS232 includes a start bit and a stop bit on the ends of each 8 bits of data.
    (Later in this chapter, I’ll show you how to change the number of bits sent for
    each transmission.)
  prefs: []
  type: TYPE_NORMAL
- en: The voltages for a mark can range from 3 V to 15 V DC and for a space between
    −3 V and −15 V DC. Though long cables mean greater variation in signal voltage—the
    longer the cable, the larger the voltage drop, because of the wire’s resistance—the
    wide voltage range between marks and spaces means the length of the RS232 cable
    affects signal integrity less. If the surrounding electrical environment is noisy,
    there is less chance of confusion between a mark and a space.
  prefs: []
  type: TYPE_NORMAL
- en: The increased voltage required for the RS232 signals is generated by a TTL-to-RS232
    serial converter IC, the MAX3232, found on RS232 shields and modules for Arduino.
    This IC uses a charge-pump circuit to convert the 5 V DC to +/−10 V DC or more,
    but with a reduced current. Therefore, you don’t need a separate dual-rail power
    supply to use RS232 and the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Connecting to RS232</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several easy ways to interface your Arduino with an RS232 connection
    on a device or PC. Whichever interface device you use will have a nine-pin connector
    for RS232 and a way to electrically connect the onboard MAX3232 IC to the Arduino’s
    TX/RX serial pins.
  prefs: []
  type: TYPE_NORMAL
- en: The most convenient interfacing method is to use an RS232 shield for Arduino
    (PMD Way part 954042), as shown in [Figure 17-3](chapter17.xhtml#fig17-3). The
    shield has a convenient switch that selects between RS232 use and Arduino-to-PC
    communication; you turn the switch off when uploading sketches and on when using
    RS232.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN RS232 SHIELD FOR ARDUINO](../images/fig17-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-3: An RS232 shield
    for Arduino</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A more compact alternative to the RS232 shield for Arduino, especially useful
    when making smaller Arduino-based circuits, is the RS232-to-TTL module shown in
    [Figure 17-4](chapter17.xhtml#fig17-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN RS232 MODULE FOR ARDUINO](../images/fig17-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-4: An RS232-to-TTL
    module</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This module connects to the Arduino using the inline header pins: connect V[CC]
    and GND to Arduino 5V and GND, module TXD to Arduino RX (D0), and module RXD to
    Arduino TX (D1). The projects in this chapter use the RS232 shield for Arduino,
    but you could use the module instead for the same projects.'
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, you’ll also need an RS232 cable to bridge the Arduino and
    RS232 hardware with a device or computer. Based on the standard connector on RS232
    shields and modules and the standard PC RS232 socket (shown at the top of [Figure
    17-5](chapter17.xhtml#fig17-5)), you’ll need a double-ended nine-pin female cable.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN RS232 SERIAL PORT ON THE REAR OF A DESKTOP COMPUTER](../images/fig17-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-5: The back of a
    desktop PC showing an RS232 socket</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a Mac or laptop computer or if your PC doesn’t have an RS232
    port, you’ll need a USB-to-RS232 cable such as PMD Way part 514539A, as shown
    in [Figure 17-6](chapter17.xhtml#fig17-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN RS232-TO-USB CONVERTER CABLE](../images/fig17-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-6: A USB-to-RS232
    cable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The RS232 connectors on your PC or Arduino shield are the nine-pin variety with
    two rows of pins, in either a male or female configuration. When working with
    old devices with 25-pin connectors, you should be able to buy a converter plug
    or cable like the one shown in [Figure 17-7](chapter17.xhtml#fig17-7) from the
    supplier of your other RS232 gear.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A DB9-TO-DB25 CONVERTER CABLE](../images/fig17-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-7: A DB9-to-DB25
    serial cable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve collected the required hardware, you’re ready to set up and test
    a PC-to-Arduino connection via RS232.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing Arduino-to-PC Connections via
    USB</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test your Arduino-to-PC connection, upload [Listing 17-1](#LiT-17-1) to your
    Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-1: Testing the Arduino-to-PC
    connection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, remove the USB cable from the Arduino and then connect the RS232 shield
    or module as described in the previous section. Reconnect the Arduino to USB or
    external power and then open your terminal software. As in previous chapters,
    the projects in this chapter use the free terminal emulator CoolTerm by Roger
    Meier, which you can download at [*http://<wbr>freeware<wbr>.the<wbr>-meiers<wbr>.org*](http://freeware.the-meiers.org).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have opened the terminal software, click **Options**. You should be
    presented with a menu of serial port options, as shown in [Figure 17-8](chapter17.xhtml#fig17-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE COOLTERM OPTIONS MENU](../images/fig17-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-8: The CoolTerm options
    menu</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Choose your serial port (for example, COM1) from the Port drop-down menu and
    ensure the rest of the serial port settings match those shown in the figure. Click
    **OK** to close the menu and then click **Connect** to begin data transfer from
    the Arduino to the PC via RS232\. The PC should repeatedly receive the word “Hello”
    and display it on the terminal window, as shown in [Figure 17-9](chapter17.xhtml#fig17-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE RESULTS OF LISTING 17-1 IN THE COOLTERM WINDOW](../images/fig17-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-9: The results of
    [Listing 17-1](#LiT-17-1) in the CoolTerm window</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can use this simple setup to capture data from your Arduino over a longer
    distance than is possible using USB cables. In CoolTerm, press CTRL-R to start
    recording any output received to a text file, and press CTRL-SHIFT-R to stop recording.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your hardware connected; you’ll use it in the following project to make
    a PC-to-Arduino remote control over RS232.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #49: Creating a PC-to-Arduino
    Remote Control</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates the basic framework to remotely control your Arduino
    over RS232 to control devices connected to digital outputs, request information
    from sensors, or even add computer control to your Arduino projects with PC-based
    software that writes to the serial port.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An RS232 shield or module for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nine-pin cable for PC-to-RS232 connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To assemble the project, connect the Arduino to the RS232 hardware and PC as
    described in the previous section. Uploaded the sketch for Project #49, open the
    CoolTerm software, and click **Connect** to begin data communication between the
    Arduino and the PC via RS232.'
  prefs: []
  type: TYPE_NORMAL
- en: Press **0** or **1** on the PC keyboard to request the values of the Arduino’s
    analog inputs 0 and 1, respectively, and turn the onboard LED on and off by pressing
    **2** and **3**. If any other key is pressed, the terminal should display the
    error message <samp class="SANS_TheSansMonoCd_W5Regular_11">Unrecognized command</samp>,
    as shown in [Figure 17-10](chapter17.xhtml#fig17-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE RESULTS OF PROJECT #49 IN THE COOLTERM WINDOW](../images/fig17-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-10: Example output
    from Project #49</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Starting at ❶, the sketch creates four custom functions to be called upon receiving
    a matching command. The sketch then initializes the Arduino serial port ❷ and
    sets the onboard LED pin to output and turns it off.
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, the Arduino waits for a character of text to come in from
    the RS232 connection via serial ❸ and then acts on this character using a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function ❹. If the
    character falls outside of the range of choices, the sketch sends an error message
    back to the PC ❺. The actions in this sketch are simply demonstrations, and you
    can replace the contents with your own requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project demonstrates that you can control or monitor any Arduino operation
    with a PC over an RS232 connection. You could also write your own custom PC software
    for remote control. Any code that can write to a COM: or serial port on the machine
    can control the Arduino, and any code that can receive text from the serial port
    can act upon it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next project, I’ll show you how to set up communication between two
    Arduinos via RS232\. Since RS232 is an extension of the Arduino’s serial communication,
    two Arduinos can communicate with each other using RS232\. However, the RS232
    cable required for this purpose is slightly different than a normal cable: the
    TX and RX data lines need to be crossed over. That is, the TX pin on one end of
    the cable needs to be connected to the RX pin at the other end, and vice versa.
    Otherwise, you’d be trying to connect the TX pins of the two Arduinos, which won’t
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to use a *crossover*, or *null modem*, cable,
    which has the internal wiring required for direct RS232-to-RS232-device communication,
    such as PMD Way part 6045480L15 shown in [Figure 17-11](chapter17.xhtml#fig17-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE RS232 CROSSOVER/NULL-MODEM CABLE](../images/fig17-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-11: An RS232 crossover
    cable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re experimenting over just a short distance, you can instead just use
    jumper wires to connect between the two RS232 shields or modules for Arduino:
    just connect the TX and RX on one side to the RX and TX on the other, and connect
    GND across the two.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #50: Enabling Arduino-to-Arduino
    Communication</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates how one Arduino talks to another over RS232\. One
    Arduino board with a BMP180 temperature sensor will send the current temperature
    to another Arduino board via RS232, and the I²C LCD connected to the receiving
    Arduino will display the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Two Arduino Uno or compatible boards and USB cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two RS232 shields or modules for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nine-pin RS232 crossover cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BMP180 temperature and air pressure sensor board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCF8574 LCD module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One Arduino will act as the transmitter board, the other as the receiver board.
    To assemble the hardware, attach an RS232 shield or module to each Arduino, then
    connect both via the crossover cable or jumper wires. Add the BMP180 sensor to
    the transmitter board, as shown in the schematic in [Figure 17-12](chapter17.xhtml#fig17-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC DIAGRAM FOR A BMP180 SENSOR TO AN ARDUINO](../images/fig17-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-12: The connection
    diagram for a BMP180 sensor to a transmitter Arduino</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, add the LCD module to the receiver board, as shown in [Figure 17-13](chapter17.xhtml#fig17-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC DIAGRAM FOR AN I2C LCD TO AN ARDUINO](../images/fig17-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-13: The connection
    diagram for an LCD to a receiver Arduino</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t used the BMP180 sensor before, install the library as described
    in [Chapter 10](chapter10.xhtml), and install the I²C LCD as described in [Chapter
    13](chapter13.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Arduinos are connected, if you’re using the RS232 shields, be sure
    they’re switched on. To power the project, you can use either USB cables or external
    power if there’s a distance between the PC and Arduinos.
  prefs: []
  type: TYPE_NORMAL
- en: Next, enter and upload the transmitter sketch to the transmitter Arduino and
    then the receiver sketch to the receiver Arduino. A moment or two after this,
    the LCD should display the current temperature on the LCD, an example of which
    is shown in [Figure 17-14](chapter17.xhtml#fig17-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE TEMPERATURE DISPLAYED ON AN LCD: “TEMP (C)=26”](../images/fig17-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-14: Example output
    from Project #50</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works, starting with the transmitter sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The transmitter sketch includes and initializes the BMP180 library and then
    creates a variable to store the temperature ❶. It starts the serial and the BMP180
    ❷. The loop takes a temperature reading from the BMP180 ❸ and then sends the text
    to the receiving Arduino, starting with the description <samp class="SANS_TheSansMonoCd_W5Regular_11">Temp
    (C)</samp> = and followed by the value for the temperature. This is followed by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>, which tells the receiving
    Arduino to add a new line. There’s a small delay before the process repeats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s examine the receiver sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The receiver sketch is tasked with displaying the line of serial data received
    over RS232 on the LCD. It includes and initializes the LCD library and I²C bus
    and then creates three required variables: <samp class="SANS_TheSansMonoCd_W5Regular_11">length</samp>,
    the number of characters that fit on one line of the LCD; <samp class="SANS_TheSansMonoCd_W5Regular_11">endOfLine</samp>,
    which holds a newline character; and a character array <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>,
    which holds incoming data from the RS232 bus.'
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch
    sets up serial communications, activates the I²C bus, and initializes the LCD
    for use by turning on the backlight and setting the cursor to the top left of
    the display. In the main loop, if incoming characters are detected, the LCD cursor
    is reset to the top left with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.home();</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.setCursor(0, 0);</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.readBytesUntil()</samp>
    function captures up to 16 inbound characters from serial, until the newline character
    is received. The sketch stores these characters in the array buffer. Finally,
    it displays the characters of the buffer array on the LCD. The process repeats
    whenever new data is received from the transmitter Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: For more permanent projects that involve two Arduino boards at a distance from
    one another, the simple demonstration in this project provides an ideal framework
    for reliable data transmission. For a challenge, you might create a project in
    which two Arduinos “talk” to each other by sending random data or sensor values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other RS232 Data Configurations</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now in this chapter, you’ve used a default 9,600 bps for data speed
    and 8 bits in each piece of data sent, with no parity and 1 stop bit. (This is
    often written as “8, None, 1” after the speed in device specification sheets or
    user manuals.) However, in future projects, you may want to work with devices
    that use a different data speed or method of sending and receiving data. For example,
    an old terminal might use 7 bits instead of 8, and 2 stop bits instead of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you can modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.begin()</samp>
    function’s parameters used in the projects in this chapter. Set the first parameter
    to the data speed you require and the second parameter as the new data configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the second parameter, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp>
    stands for the requisite number of data bits, which can fall between 5 and 8;
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> stands for parity,
    which can be <samp class="SANS_TheSansMonoCd_W5Regular_11">N</samp> for none,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> for even, or <samp class="SANS_TheSansMonoCd_W5Regular_11">O</samp>
    for odd; and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Z</samp> stands
    for the number of stop bits, which can be 1 or 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to start the serial (and thus RS232) at 4,800 bps with 7-bit data,
    no parity, and 1 stop bit, use the following function in your sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This may come in handy if you decide to interface any vintage equipment with
    your Arduino. For some retro computing fun, keep an eye out on eBay or computer
    marketplaces for old computer terminals or printers. For example, check out the
    Arduino-controlled RS232 to parallel printer interface at [*https://<wbr>hackaday<wbr>.io<wbr>/project<wbr>/18140<wbr>-serial<wbr>-to<wbr>-parallel<wbr>-printer<wbr>-interface*](https://hackaday.io/project/18140-serial-to-parallel-printer-interface).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You learned how to communicate between a PC and Arduino via RS232 and between
    Arduinos via RS232\. You now have the tools to harness the RS232 bus for remote
    control, data communication between Arduinos, and data capture to a PC for analysis
    and to communicate with RS232-based devices with an Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to use an Arduino to communicate with
    other devices using another data bus, the RS485 data bus.
  prefs: []
  type: TYPE_NORMAL
