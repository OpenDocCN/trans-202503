<html><head></head><body>
<h2 class="h2" id="ch3"><span epub:type="pagebreak" id="page_39"/><span class="big">3</span><br/>CRYPTOGRAPHIC SECURITY</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Cryptographic definitions of security are not the same as those that apply to general computer security. The main difference between software security and cryptographic security is that the latter can be <em>quantified</em>. Unlike in the software world, where applications are usually seen as either secure or insecure, in the cryptographic world it’s often possible to calculate the amount of effort required to break a cryptographic algorithm. Also, whereas software security focuses on preventing attackers from abusing a program’s code, the goal of cryptographic security is to make well-defined problems impossible to solve.</p>
<p class="indent">Cryptographic problems involve mathematical notions, but not complex math—or at least not in this book. This chapter walks you through some of these security notions and how they’re applied to solve real-world problems. In the following sections, I discuss how to quantify crypto security in ways that are both theoretically sound and practically relevant. I discuss the notions of informational versus computational security, bit security <span epub:type="pagebreak" id="page_40"/>versus full attack cost, provable versus heuristic security, and symmetric versus asymmetric key generation. I conclude the chapter with actual examples of failures in seemingly strong cryptography.</p>
<h3 class="h3" id="lev1sec21">Defining the Impossible</h3>
<p class="noindent">In <a href="ch01.xhtml#ch1">Chapter 1</a>, I described a cipher’s security relative to an attacker’s capabilities and goals, and deemed a cipher secure if it was impossible to reach these goals given an attacker’s known capabilities. But what does <em>impossible</em> mean in this context?</p>
<p class="indent">Two notions define the concept of impossible in cryptography: informational security and computational security. Roughly speaking, <em>informational security</em> is about theoretical impossibility whereas <em>computational security</em> is about practical impossibility. Informational security doesn’t quantify security because it views a cipher as either secure or insecure, with no middle ground; it’s therefore useless in practice, although it plays an important role in theoretical cryptography. Computational security is the more relevant and practical measure of the strength of a cipher.</p>
<h4 class="h4" id="lev2sec34"><em>Security in Theory: Informational Security</em></h4>
<p class="noindent">Informational security is based not on how hard it is to break a cipher, but whether it’s conceivable to break it at all. A cipher is informationally secure only if, even given unlimited computation time and memory, it cannot be broken. Even if a successful attack on a cipher would take trillions of years, such a cipher is informationally <em>in</em>secure.</p>
<p class="indent">For example, the one-time pad introduced in <a href="ch01.xhtml#ch1">Chapter 1</a> is informationally secure. Recall that the one-time pad encrypts a plaintext, <em>P</em>, to a ciphertext, <em>C</em> = <em>P</em> ⊕ <em>K</em>, where <em>K</em> is a random bit string that is unique to each plaintext. The cipher is informationally secure because given a ciphertext and unlimited time to try all possible keys, <em>K</em>, and compute the corresponding plaintext, <em>P</em>, you would still be unable to identify the right <em>K</em> because there are as many possible <em>P</em>s as there are <em>K</em>s.</p>
<h4 class="h4" id="lev2sec35"><em>Security in Practice: Computational Security</em></h4>
<p class="noindent">Unlike informational security, computational security views a cipher as secure if it cannot be broken within a <em>reasonable</em> amount of time, and with reasonable resources such as memory, hardware, budget, energy, and so on. Computational security is a way to quantify the security of a cipher or any crypto algorithm.</p>
<p class="indent">For example, consider a cipher, <strong>E</strong>, for which you know a plaintext–ciphertext pair (<em>P</em>, <em>C</em>) but not the 128-bit key, <em>K</em>, that served to compute <em>C</em> = <strong>E</strong>(<em>K</em>, <em>P</em>). This cipher is not informationally secure because you could break it after trying the 2<sup>128</sup> possible 128-bit <em>K</em>s until you find the one that satisfies <strong>E</strong>(<em>K</em>, <em>P</em>) = <em>C</em>. But in practice, even testing 100 billion keys per second, it would take more than 100,000,000,000,000,000,000 years. In other <span epub:type="pagebreak" id="page_41"/>words, reasonably speaking, this cipher is computationally secure because it’s practically impossible to break.</p>
<p class="indent">Computational security is sometimes expressed in terms of two values:</p>
<ul>
<li class="noindent"><em>t</em>, which is a limit on the number of operations that an attacker will carry out</li>
<li class="noindent">ε (called “epsilon”), which is a limit on the probability of success of an attack</li>
</ul>
<p class="indentt">We then say that a cryptographic scheme is (<em>t,</em> ε)<em>-secure</em> if an attacker performing at most <em>t</em> operations—whatever those operations are—has a probability of success that is no higher than ε, where ε is at least 0 and at most 1. Computational security gives a limit on how hard it is to break a cryptographic algorithm.</p>
<p class="indent">Here it’s important to know that <em>t</em> and ε are just limits: if a cipher is (<em>t,</em> ε)<em>-secure</em>, then no attacker performing fewer than <em>t</em> operations will succeed (with probability ε). But that doesn’t imply that an attacker doing exactly <em>t</em> operations will succeed, and it doesn’t tell you how many operations are needed, which may be much larger than <em>t</em>. We say that <em>t</em> is a <em>lower bound</em> on the computation effort needed, because you’d need at least <em>t</em> operations to compromise security.</p>
<p class="indent">We sometimes know precisely how much effort it takes to break a cipher; in such cases we say that a (<em>t</em>, ε<em>)-security</em> gives us a <em>tight bound</em> when an attack exists that breaks the cipher with probability ε and exactly <em>t</em> operations.</p>
<p class="indent">For example, consider a symmetric cipher with a 128-bit key. Ideally, this cipher should be (<em>t, t/2</em><sup>128</sup>)<em>-secure</em> for any value of <em>t</em> between 1 and 2<sup>128</sup>. The best attack should be <em>brute force</em> (trying all keys until you find the correct one). Any better attack would have to exploit some imperfection in the cipher, so we strive to create ciphers where brute force is the best possible attack.</p>
<p class="indent">Given the statement (<em>t</em>, <em>t</em>/<em>2</em><sup>128</sup>)<em>-secure</em>, let’s examine the probability of success of three possible attacks:</p>
<ul>
<li class="noindent">In the first case, <em>t</em> = 1, an attacker tries one key and succeeds with a probability of ε = 1/2<sup>128</sup>.</li>
<li class="noindent">In the second case, <em>t</em> = 2<sup>128</sup>, an attacker tries all 2<sup>128</sup> keys and one succeeds. Thus, the probability ε = 1 (if the attacker tries all keys, obviously the right one must be one of them).</li>
<li class="noindent">In the third case, an attacker tries only <em>t</em> = 2<sup>64</sup> keys, and succeeds with a probability of ε = 2<sup>64</sup>/2<sup>128</sup> = 2<sup>−64</sup>. When an attacker only tries a fraction of all keys, the success probability is proportional to the number of keys tried.</li>
</ul>
<p class="indentt">We can conclude that a cipher with a key of <em>n</em> bits is at best (<em>t, t/2</em><sup><em>n</em></sup>)<em>-secure</em>, for any <em>t</em> between 1 and 2<sup><em>n</em></sup>, because no matter how strong the cipher, a brute-force attack against it will always succeed. The key thus needs be long enough to blunt brute-force attacks in practice.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_42"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In this example, we are counting the number of evaluations of the cipher, not the absolute time or number of processor clock cycles. Computational security is technology agnostic, which is good: a cipher that is</em> (t, ε)-secure <em>today will be</em> (t, ε)-secure <em>tomorrow, but what’s considered secure in practice today might not be considered secure tomorrow.</em></p>
</div>
<h3 class="h3" id="lev1sec22">Quantifying Security</h3>
<p class="noindent">When an attack is found, the first thing you want to know is how efficient it is in theory, and how practical it is, if at all. Likewise, given a cipher that’s allegedly secure, you want to know what amount of work it can withstand. To address those questions, I’ll explain how cryptographic security can be measured in bits (the theoretical view) and what factors affect the actual cost of an attack.</p>
<h4 class="h4" id="lev2sec36"><em>Measuring Security in Bits</em></h4>
<p class="noindent">When speaking of computational security, we say that a cipher is <em>t-secure</em> when a successful attack needs at least <em>t</em> operations. We thus avoid the unintuitive (<em>t</em>, ε) notation by assuming a success probability of ε close to 1, or what we care about in practice. We then express security in bits, where “<em>n</em>-bit security” means that about 2<sup><em>n</em></sup> operations are needed to compromise some particular security notion.</p>
<p class="indent">If you know approximately how many operations it takes to break a cipher, you can determine its security level in bits by taking the binary logarithm of the number of operations: if it takes 1000000 operations, the security level is log<sub>2</sub>(1000000), or about 20 bits (that is, 1000000 is approximately equal to 2<sup>20</sup>). Recall that an <em>n</em>-bit key will give at most <em>n</em>-bit security because a brute-force attack with all 2<sup><em>n</em></sup> possible keys will always succeed. But the key size doesn’t always match the security level—it just gives an <em>upper bound</em>, or the highest possible security level.</p>
<p class="indent">A security level may be smaller than the key size for one of two reasons:</p>
<ul>
<li class="noindent">An attack broke the cipher in fewer operations than expected—for example, using a method that recovers the key by trying not all 2<sup><em>n</em></sup> keys, but only a subset of those.</li>
<li class="noindent">The cipher’s security level intentionally differs from its key size, as with most public key algorithms. For example, the RSA algorithm with a 2048-bit secret key provides less than 100-bit security.</li>
</ul>
<p class="indentt">Bit security proves useful when comparing ciphers’ security levels but doesn’t provide enough information on the actual cost of an attack. It is sometimes too simple an abstraction because it just assumes that an <em>n</em>-bit-secure cipher takes 2<sup><em>n</em></sup> operations to break, whatever these operations are. Two ciphers with the same bit security level can therefore have vastly different real-world security levels when you factor in the actual cost of an attack to a real attacker.</p>
<p class="indent"><span epub:type="pagebreak" id="page_43"/>Say we have two ciphers, each with a 128-bit key and 128-bit security. Each must be evaluated 2<sup>128</sup> times in order to be broken, except that the second cipher is 100 times slower than the first. Evaluating the second cipher 2<sup>128</sup> times thus takes the same time as 100 × 2<sup>128</sup> ≈ 2<sup>134.64</sup> evaluations of the first. If we count in terms of the first, fast cipher, then breaking the slower one takes 2<sup>134.64</sup> operations. If we count in terms of the second, slow cipher, it only takes 2<sup>128</sup> operations. Should we then say that the second cipher is stronger than the first? In principle, yes, but we rarely see such a hundred-fold performance difference between commonly used ciphers.</p>
<p class="indent">The inconsistent definition of an operation raises more difficulties when comparing the efficiency of attacks. Some attacks claim to reduce a cipher’s security because they perform 2<sup>120</sup> evaluations of some operation rather than 2<sup>128</sup> evaluations of the cipher, but the speed of each type of attack is left out of the analysis. The 2<sup>120</sup>-operation attack won’t always be faster than a 2<sup>128</sup> brute-force attack.</p>
<p class="indent">Nevertheless, bit security remains a useful notion as long as the operation is reasonably defined—meaning about as fast as an evaluation of the cipher. After all, in real life, all it takes to determine whether a security level is sufficient is an order of magnitude.</p>
<h4 class="h4" id="lev2sec37"><em>Full Attack Cost</em></h4>
<p class="noindent">Bit security expresses the cost of the fastest attack against a cipher by estimating the order of magnitude of the number of operations it needs to succeed. But other factors affect the cost of an attack, and these must be taken into account when estimating the actual security level. I’ll explain the four main ones: parallelism, memory, precomputation, and the number of targets.</p>
<h5 class="h5">Parallelism</h5>
<p class="noindent">The first factor to consider is computational parallelism. For example, consider two attacks of 2<sup>56</sup> operations each. The difference between the two is that the second attack can be parallelized but not the first: the first attack performs 2<sup>56</sup> <em>sequentially dependent</em> operations, such as <em>x</em><sub><em>i</em> + 1</sub> = <em>f</em><sub><em>i</em></sub>(<em>x</em><sub><em>i</em></sub>) for some <em>x</em><sub>0</sub> and some functions <em>f</em><sub><em>i</em></sub> (with <em>i</em> from 1 to 2<sup>56</sup>), whereas the second performs 2<sup>56</sup> <em>independent</em> operations, such as <em>x</em><sub><em>i</em></sub> = <em>f</em><sub><em>i</em></sub>(<em>x</em>) for some <em>x</em> and <em>i</em> from 1 to 2<sup>56</sup>, which can be executed in parallel. Parallel processing can be orders of magnitude faster than sequential processing. For example, if you had 2<sup>16</sup> = 65536 processors available, you could divide the workload of the parallel attacks into 2<sup>16</sup> independent tasks, each performing 2<sup>56</sup> / 2<sup>16</sup> = 2<sup>40</sup> operations. The first attack, however, cannot benefit from having multiple cores available because each operation relies on the previous operation’s result. Therefore, the parallel attack will complete 65536 times faster than the sequential one, even though they perform the same number of operations.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Algorithms that become</em> N <em>times faster to attack when</em> N <em>cores are available are called</em> embarrassingly parallel, <em>and we say that their execution times</em> scale linearly <em>with respect to the number of computing cores.</em></p>
</div>
<h5 class="h5"><span epub:type="pagebreak" id="page_44"/>Memory</h5>
<p class="noindent">The second factor when determining the cost of an attack is memory. Cryptanalytic attacks should be evaluated with respect to their use of time and space: how many operations do they perform over time, how much memory or space do they consume, how do they use the space they consume, and what’s the speed of the available memory? Unfortunately, bit security is concerned only with the time it takes to perform an attack.</p>
<p class="indent">Concerning the way space is used, it’s important to consider how many memory lookups are required as part of an attack, the speed of memory accesses (which may differ between reads and writes), the size of the data accessed, the access pattern (contiguous or random memory addresses), and how data is structured in memory. For example, on one of today’s general-purpose CPUs, reading from a register takes one cycle, whereas reading from the CPU’s cache memory takes around 20 cycles (for the L3 cache), and reading from DRAM usually takes at least 100 cycles. A factor of 100 can make the difference between one day and three months.</p>
<h5 class="h5">Precomputation</h5>
<p class="noindent">Precomputation operations are those that need to be performed only once and can be reused over subsequent executions of the attack. Precomputation is sometimes called the <em>offline stage</em> of an attack.</p>
<p class="indent">For example, consider the time-memory trade-off attack. When performing this kind of attack, the attacker performs one huge computation that produces large lookup tables that are then stored and reused to perform the actual attack. For example, one attack on 2G mobile encryption took two months to build two terabytes’ worth of tables, which were then used to break the encryption in 2G and recover a secret session key in only a few seconds.</p>
<h5 class="h5">Number of Targets</h5>
<p class="noindent">Finally, we come to the number of targets of the attack. The greater the number of targets, the greater the attack surface, and the more attackers can learn about the keys they’re after.</p>
<p class="indent">For example, consider a brute-force key search: if you target a single <em>n</em>-bit key, it will take 2<sup><em>n</em></sup> attempts to find the correct key with certainty. But if you target multiple <em>n</em>-bit keys—say, a number <em>M</em>—and if for a single <em>P</em> you have <em>M</em> distinct ciphertexts, where <em>C</em> = <strong>E</strong>(<em>K</em>, <em>P</em>) for each of the <em>M</em> keys (<em>K</em>) that you’re after, it will again take 2<sup><em>n</em></sup> attempts to find each key. But if you’re only interested in <em>at least one</em> of the <em>M</em> keys and not in every one, it would take on average 2<sup><em>n</em></sup> / <em>M</em> attempts to succeed. For example, to break one 128-bit key of 2<sup>16</sup> = 65536 target keys, it will take on average 2<sup>128 − 16</sup> = 2<sup>112</sup> evaluations of the cipher. That is, the cost (and speed) of the attack decreases as the number of targets increases.</p>
<h4 class="h4" id="lev2sec38"><em>Choosing and Evaluating Security Levels</em></h4>
<p class="noindent">Choosing a security level often involves selecting between 128-bit and 256-bit security because most standard crypto algorithms and implementations are <span epub:type="pagebreak" id="page_45"/>available in one of these two security levels. Below 128 bits you’ll find schemes with 64- or 80-bit security, but these are generally not secure enough for real-world use.</p>
<p class="indent">At a high level, 128-bit security means that you’d need to carry out approximately 2<sup>128</sup> operations to break that crypto system. To give you a sense of what this number means, consider the fact that the universe is approximately 2<sup>88</sup> nanoseconds old (there’s a billion nanoseconds in a second). Since testing a key with today’s technology takes no less than a nanosecond, you’d need several times the age of the universe for an attack to succeed (2<sup>40</sup> times to be precise) if it takes exactly one nanosecond to test a key.</p>
<p class="indent">But can’t parallelism and multiple targets dramatically reduce the time it takes to complete a successful attack? Not exactly. Say you’re interested in breaking any of a million targets, and that you have a million parallel cores available. That brings the search time down from 2<sup>128</sup> to (2<sup>128</sup> / 2<sup>20</sup>) / 2<sup>20</sup> = 2<sup>88</sup>, which is equivalent to only one universe lifetime.</p>
<p class="indent">Another thing to consider when evaluating security levels is the evolution of technology. Moore’s law posits that computing efficiency doubles roughly every two years. We can think of this as a loss of one bit of security every two years: if today a $1000 budget allows you to break, say, a 40-bit key in one hour, then Moore’s law says that two years later, you could break a 41-bit key in one hour for the same $1000 budget (I’m simplifying). We can extrapolate from this to say that, according to Moore’s law, we’ll have 40 fewer bits of security in 80 years compared to today. In other words, in 80 years doing 2<sup>128</sup> operations may cost as much as doing 2<sup>88</sup> operations today. Accounting for parallelism and multiple targets, as discussed earlier, we’re down to 2<sup>48</sup> nanoseconds of computation, or about three days. But this extrapolation is highly inaccurate, because Moore’s law won’t and can’t scale that much. Still, you get the idea: what looks infeasible today may be realistic in a century.</p>
<p class="indent">There will be times when a security level lower than 128 bits is justified. For example, when you need security for only a short time period and when the costs of implementing a higher security level will negatively impact the cost or usability of a system. A real-world example is that of pay TV systems, wherein encryption keys are either 48 or 64 bits. This sounds ridiculously low, but that’s a sufficient security level because the key is refreshed every 5 or 10 seconds.</p>
<p class="indent">Nevertheless, to ensure long-term security, you should choose 256-bit security or a bit less. Even in a worst-case scenario—the existence of quantum computers, see <a href="ch14.xhtml#ch14">Chapter 14</a>—a 256-bit secure scheme is unlikely to be broken in the foreseeable future. More than 256 bits of security is practically unnecessary, except as a marketing device.</p>
<p class="indent">As NIST cryptographer John Kelsey once put it, “The difference between 80 bits and 128 bits of key search is like the difference between a mission to Mars and a mission to Alpha Centauri. As far as I can see, there is no meaningful difference between 192-bit and 256-bit keys in terms of practical brute-force attacks; impossible is impossible.”</p>
<h3 class="h3" id="lev1sec23"><span epub:type="pagebreak" id="page_46"/>Achieving Security</h3>
<p class="noindent">Once you’ve chosen a security level, it’s important to guarantee that your cryptographic schemes will stick to it. In other words, you want <em>confidence</em>, not just hope and uncertainty, that things will work as planned, all the time.</p>
<p class="indent">When building confidence in the security of a crypto algorithm, you can rely on mathematical proofs, an approach called <em>provable security</em>, or on evidence of failed attempts to break the algorithm, which I’ll call <em>heuristic security</em> (though it’s sometimes called <em>probable</em> security). These two approaches are complementary and neither is better than the other, as you’ll see.</p>
<h4 class="h4" id="lev2sec39"><em>Provable Security</em></h4>
<p class="noindent">Provable security is about proving that breaking your crypto scheme is at least as hard as solving another problem known to be hard. Such a <em>security proof</em> guarantees that the crypto remains safe as long as the hard problem remains hard. This type of proof is called a <em>reduction</em>, and it comes from the field of complexity theory. We say that breaking some cipher is reducible to problem X if any method to solve problem X also yields a method to break the cipher.</p>
<p class="indent">Security proofs come in two flavors, depending on the type of presumably hard problem used: proofs relative to a mathematical problem and proofs relative to a cryptographic problem.</p>
<h5 class="h5">Proofs Relative to a Mathematical Problem</h5>
<p class="noindent">Many security proofs (such as those for public-key crypto) show that breaking a crypto scheme is at least as hard as solving some hard mathematical problem. We’re talking of problems for which a solution is known to exist, and is easy to verify once it’s known, but is computationally hard to find.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>There’s no real proof that seemingly hard math problems are actually hard. In fact, proving this for a specific class of problems is one of the greatest challenges in the field of complexity theory, and as I write this there is a $1,000,000 bounty for anyone who can solve it, awarded by the Clay Mathematics Institute. This is discussed in more detail in <a href="ch09.xhtml#ch9">Chapter 9</a>.</em></p>
</div>
<p class="indent">For example, consider the challenge of solving the <em>factoring problem</em>, which is the best-known math problem in crypto: given a number that you know is the product of two prime numbers (<em>n</em> = <em>pq</em>), find the said primes. For example, if <em>n</em> = 15, the answer is 3 and 5. That’s easy for a small number, but it becomes exponentially harder as the size of the number grows. For example, if a number, <em>n</em>, is 3000 bits long (about 900 decimal digits) or more, factoring is believed to be practically infeasible.</p>
<p class="indent">RSA is the most famous crypto scheme to rely on the factoring problem: RSA encrypts a plaintext, <em>P</em>, seen as a large number, by computing <em>C</em> = <em>P</em><sup><em>e</em></sup> mod <em>n</em>, where the number <em>e</em> and <em>n</em> = <em>pq</em> are the public key. Decryption recovers a plaintext from a ciphertext by computing <em>P</em> = <em>C</em><sup><em>d</em></sup> mod <em>n</em>, where <em>d</em> is the private key associated to <em>e</em> and <em>n</em>. If we can factor <em>n</em>, then we can break <span epub:type="pagebreak" id="page_47"/>RSA (by recovering the private key from the public key), and if we can obtain the private key, then we can factor <em>n</em>; in other words, recovering an RSA private key and factoring <em>n</em> are equivalently hard problems. That’s the kind of reduction we’re looking for in provable security. However, there is no guarantee that recovering an RSA plaintext is as hard as factoring <em>n</em>, since the knowledge of a plaintext doesn’t reveal the private key.</p>
<h5 class="h5">Proofs Relative to Another Crypto Problem</h5>
<p class="noindent">Instead of comparing a crypto scheme to a math problem, you can compare it to another crypto scheme and prove that you can only break the second if you can break the first. Security proofs for symmetric ciphers usually follow this approach.</p>
<p class="indent">For example, if all you have is a single permutation algorithm, then you can build symmetric ciphers, random bit generators, and other crypto objects such as hash functions by combining calls to the permutations with various types of inputs (as you’ll see in <a href="ch06.xhtml#ch6">Chapter 6</a>). Proofs then show that the newly created schemes are secure if the permutation is secure. In other words, we know for sure that the newly created algorithm is <em>not weaker</em> than the original one. Such proofs usually work by crafting an attack on the smaller component given an attack on the larger one—that is, by showing a reduction.</p>
<p class="indent">When you’re proving that a crypto algorithm is no weaker than another, the main benefit is that of a reduced attack surface: instead of analyzing both the core algorithm and the combination, you can simply look at the new cipher’s core algorithm. Specifically, if you write a cipher that uses a newly developed permutation and a new combination, you may prove that the combination doesn’t weaken security compared to the core algorithm. Therefore, to break the combination, you need to break the new permutation.</p>
<h5 class="h5">Caveats</h5>
<p class="noindent">Cryptography researchers rely heavily on security proofs, whether with respect to math problem schemes or to other crypto schemes. But the existence of a security proof does not guarantee that a cryptographic scheme is perfect, nor is it an excuse for neglecting the more practical aspects of implementation. After all, as cryptographer Lars Knudsen once said, “If it’s provably secure, it’s probably not,” meaning that a security proof shouldn’t be taken as an absolute guarantee of security. Worse, there are multiple reasons why a “provably secure” scheme may lead to a security failure.</p>
<p class="indent">One issue is with the phrase “proof of security” itself. In mathematics, a proof is the demonstration of an <em>absolute truth</em>, but in crypto, a proof is only the demonstration of a <em>relative truth</em>. For example, a proof that your cipher is as hard to break as it is to compute discrete logarithms—finding the number <em>x</em> given <em>g</em> and <em>g</em><sup><em>x</em></sup> mod <em>n</em>—guarantees that if your cipher fails, a whole lot of other ciphers will fail as well, and nobody will blame you if the worst happens.</p>
<p class="indent">Another caveat is that security proofs are usually proven with respect to a single notion of security. For example, you might prove that recovering the private key of a cipher is as hard as the factoring problem. But if you <span epub:type="pagebreak" id="page_48"/>can recover plaintexts from ciphertext without the key, you’ll bypass the proof, and recovering the key hardly matters.</p>
<p class="indent">Then again, proofs are not always correct, and it may be easier to break an algorithm than originally thought.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Unfortunately, few researchers carefully check security proofs, which commonly span dozens of pages, thus complicating quality control. That said, demonstrating that a proof is incorrect doesn’t necessarily imply that the proof’s goal is completely wrong; if the result is correct, the proof may be salvaged by correcting its errors.</em></p>
</div>
<p class="indent">Another important consideration is that hard math problems sometimes turn out to be easier to solve than expected. For example, certain weak parameters make breaking RSA easy. Or the math problem may be hard in certain cases, but not on average, as often happens when the reference problem is new and not well understood. That’s what happened when the 1978 knapsack encryption scheme by Merkle and Hellman was later totally broken using lattice reduction techniques.</p>
<p class="indent">Finally, although the proof of an algorithm’s security may be fine, the implementation of the algorithm can be weak. For example, attackers may exploit side-channel information such as power consumption or execution time to learn about an algorithm’s internal operations in order to break it, thus bypassing the proof. Or implementers may misuse the crypto scheme: if the algorithm is too complicated with too many knobs to configure, chances are higher that the user or developer will get a configuration wrong, which may render the algorithm completely insecure.</p>
<h4 class="h4" id="lev2sec40"><em>Heuristic Security</em></h4>
<p class="noindent">Provable security is a great tool to gain confidence in a crypto scheme, but it doesn’t apply to all kinds of algorithms. In fact, most symmetric ciphers don’t have a security proof. For example, every day we rely on the Advanced Encryption Standard (AES) to securely communicate using our mobile phones, laptops, and desktop computers, but AES is not provably secure; there’s no proof that it’s as hard to break as some well-known problem. AES can’t be related to a math problem or to another algorithm because it is the hard problem itself.</p>
<p class="indent">In cases where provable security doesn’t apply, the only reason to trust a cipher is because many skilled people tried to break it and failed. This is sometimes called <em>heuristic security</em>.</p>
<p class="indent">When can we be sure that a cipher is secure then? We can never be sure, but we can be pretty confident that an algorithm won’t be broken when hundreds of experienced cryptanalysts have each spent hundreds of hours trying to break it and published their findings—usually by attempting attacks on <em>simplified versions</em> of a cipher (often versions with fewer operations, or fewer <em>rounds</em>, which are short series of operations that ciphers iterate in order to mix bits together).</p>
<p class="indent">When analyzing a new cipher, cryptanalysts first try to break one round, then two, three, or as many as they can. The <em>security margin</em> is then <span epub:type="pagebreak" id="page_49"/>the difference between the total number of rounds and the number of rounds that were successfully attacked. When after years of study a cipher’s security margin is still high, we become confident that it’s (probably) secure.</p>
<h3 class="h3" id="lev1sec24">Generating Keys</h3>
<p class="noindent">If you plan to encrypt something, you’ll have to generate keys, whether they are temporary “session keys” (like the ones generated when browsing an HTTPS site) or long-term public keys. Recall from <a href="ch02.xhtml#ch2">Chapter 2</a> that secret keys are the crux of cryptographic security and should be randomly generated so that they are unpredictable and secret.</p>
<p class="indent">For example, when you browse an HTTPS website, your browser receives the site’s public key and uses it to establish a symmetric key that’s only valid for the current session, and that site’s public key and its associated private key may be valid for years. Therefore, it’d better be hard to find for an attacker. But generating a secret key isn’t always as simple as dumping enough pseudo­random bits. Cryptographic keys may be generated in one of three ways:</p>
<ul>
<li class="noindent"><em>Randomly</em>, using a pseudorandom number generator (PRNG) and, when needed, a key-generation algorithm</li>
<li class="noindent">From a <em>password</em>, using a key derivation function (KDF), which transforms the user-supplied password into a key</li>
<li class="noindent">Through a <em>key agreement protocol</em>, which is a series of message exchanges between two or more parties that ends with the establishment of a shared key</li>
</ul>
<p class="noindent">For now, I’ll explain the simplest method: randomized generation.</p>
<h4 class="h4" id="lev2sec41"><em>Generating Symmetric Keys</em></h4>
<p class="noindent">Symmetric keys are secret keys shared by two parties, and they are the simplest to generate. They are usually the same length as the security level they provide: a 128-bit key provides 128-bit security, and any of the 2<sup>128</sup> possible keys is a valid one that can do the job as well as any other key.</p>
<p class="indent">To generate a symmetric key of <em>n</em> bits using a cryptographic PRNG, you simply ask it for <em>n</em> pseudorandom bits and use those bits as the key. That’s it. You can, for example, use the OpenSSL toolkit to generate a random symmetric key by dumping pseudorandom bytes, as in the following command (obviously, your result will differ from mine):</p>
<pre>$ <span class="codestrong">openssl rand 16 -hex</span><br/>65a4400ea649d282b855bd2e246812c6</pre>
<h4 class="h4" id="lev2sec42"><em>Generating Asymmetric Keys</em></h4>
<p class="noindent">Unlike symmetric keys, asymmetric keys are usually longer than the security level they provide. But that’s not the main problem. Asymmetric keys are trickier to generate than symmetric ones because you can’t just dump <em>n</em> bits <span epub:type="pagebreak" id="page_50"/>from your PRNG and get away with the result. Asymmetric keys aren’t just raw bit sequences; instead, they represent a specific type of object, such as a large number with specific properties (in RSA, a product of two primes). A random bit string value (and thus a random number) is unlikely to have the specific properties needed, and therefore won’t be a valid key.</p>
<p class="indent">To generate an asymmetric key, you send pseudorandom bits as a seed to a <em>key-generation algorithm</em>. This key-generation algorithm takes as input a seed value that’s at least as long as the intended security level and then constructs from it a private key and its respective public key, ensuring that both satisfy all the necessary criteria. For example, a naive key-generation algorithm for RSA would generate a number, <em>n</em> = <em>pq</em>, by using an algorithm to generate two random primes of about the same length. That algorithm would pick random numbers until one happens to be prime—so you’d also need an algorithm to test whether a number is prime.</p>
<p class="indent">To save yourself the burden of manually implementing the key-generation algorithm, you can use OpenSSL to generate a 4096-bit RSA private key, like this:</p>
<pre>$ <span class="codestrong">openssl genrsa 4096</span><br/>Generating RSA private key, 4096 bit long modulus<br/>..............................................................................<br/>...............................++<br/>...............................................++<br/>e is 65537 (0x10001)<br/>-----BEGIN RSA PRIVATE KEY-----<br/>MIIJKQIBAAKCAgEA3Qgm6OjMy61YVstaGawk22A9LyMXhiQUU4N8F5QZXEef2Pjq<br/>vTtAIA1hzpK2AJsv16INpNkYcTjNmechAJ0xHraftO6cp2pZFP85dvknsMfUoe8u<br/>btKXZiYvJwpS0fQQ4tzlDtH45Gj8sMHcwFxTO3HSIx0XV0owfJTLMzZbSE3TDlN+<br/>JdW8d9Xd5UVB+o9gUCI8tSfnOjF2dHlLNiOhlfT4w0Rf+G35USIyUJZtOQ0Dh8M+<br/>--<span class="codeitalic">snip</span>--<br/>zO/dbYtqRkMT8Ubb/0Q1IW0q8e0WnFetzkwPzAIjwZGXT0kWJu3RYj1OXbTYDr2c<br/>xBRVC/ujoDL6O3NaqPxkWY5HJVmkyKIE5pC04RFNyaQ8+o4APyobabPMylQq5Vo5<br/>N5L2c4mhy1/OH8fvKBRDuvCk2oZinjdoKUo8ZA5DOa4pdvIQfR+b4/4Jjsx4<br/>-----END RSA PRIVATE KEY-----</pre>
<p class="indent">Notice that the key comes in a specific format—namely, base64-encoded data between the <code>BEGIN RSA PRIVATE KEY</code> and <code>END RSA PRIVATE KEY</code> markers. That’s a standard encoding format supported by most systems, which then convert this representation to raw bytes of data. The dot sequences at the beginning are a kind of progress bar, and <code>e is 65537 (0x10001)</code> indicates the parameter to use when encrypting (remember that RSA encrypts by computing <em>C</em> = <em>P</em><sup><em>e</em></sup> mod <em>n</em>).</p>
<h4 class="h4" id="lev2sec43"><em>Protecting Keys</em></h4>
<p class="noindentb">Once you have a secret key, you need to keep it secret, yet available when you need it. There are three ways to address this problem.</p>
<p class="hang"><strong>Key wrapping (encrypting the key using a second key)</strong><br/>The problem with this approach is that the second key must be available when you need to decrypt the protected key. In practice, this <span epub:type="pagebreak" id="page_51"/>second key is often generated from a password supplied by the user when he needs to use the protected key. That’s how private keys for the Secure Shell (SSH) protocol are usually protected.</p>
<p class="hang"><strong>On-the-fly generation from a password</strong><br/>Here, no encrypted file needs to be stored because the key comes straight out from the password. Modern systems like miniLock use this method. Although this method is more direct than key wrapping, it’s less widespread, in part because it’s more vulnerable to weak passwords. Say, for example, that an attacker captured some encrypted message: if key wrapping was used, the attacker first needs to get the protected key file, which is usually stored locally on the user’s file system and therefore not easy to access. But if on-the-fly generation was used, the attacker can directly search for the correct password by attempting to decrypt the encrypted message with candidate passwords. And if the password is weak, the key is compromised.</p>
<p class="hang"><strong>Storing the key on a hardware token (smart card or USB dongle)</strong><br/>In this approach, the key is stored in secure memory and remains safe even if the computer is compromised. This is the safest approach to key storage, but also the costliest and least convenient because it requires you to carry the hardware token with you and run the risk of losing it. Smart cards and USB dongles usually require you to enter a password to unlock the key from the secure memory.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Whatever method you use, make sure not to mistake the private key for the public one when exchanging keys, and don’t accidentally publish the private key through email or source code. (I’ve actually found private keys on GitHub.)</em></p>
</div>
<p class="indent">To test key wrapping, run the OpenSSL command shown here with the argument <code>-aes128</code> to tell OpenSSL to encrypt the key with the cipher AES-128 (AES with a 128-bit key):</p>
<pre>$ <span class="codestrong">openssl genrsa -aes128 4096</span><br/>Generating RSA private key, 4096 bit long modulus<br/>..........++<br/>.............................................................................................................................++<br/>e is 65537 (0x10001)<br/>Enter pass phrase:</pre>
<p class="indent">The passphrase requested will be used to encrypt the newly created key.</p>
<h3 class="h3" id="lev1sec25">How Things Can Go Wrong</h3>
<p class="noindent">Cryptographic security can go wrong in many ways. The biggest risk is when we have a false sense of security thanks to security proofs or to well-studied protocols, as illustrated by the following two examples.</p>
<h4 class="h4" id="lev2sec44"><span epub:type="pagebreak" id="page_52"/><em>Incorrect Security Proof</em></h4>
<p class="noindent">Even proofs of security by renowned researchers may be wrong. One of the most striking examples of a proof gone terribly wrong is that of <em>Optimal Asymmetric Encryption Padding (OAEP)</em>, a method of secure encryption that used RSA and was implemented in many applications. Yet, an incorrect proof of OAEP’s security against chosen-ciphertext attackers was accepted as valid for seven years, until a researcher found the flaw in 2001. Not only was the proof wrong, the result was wrong as well. A new proof later showed that OAEP is only almost secure against chosen-ciphertext attackers. We now have to trust the new proof and hope that it’s flawless. (For further details, see the 2001 paper “OAEP Reconsidered” by Victor Shoup.)</p>
<h4 class="h4" id="lev2sec45"><em>Short Keys for Legacy Support</em></h4>
<p class="noindent">In 2015, researchers found that some HTTPS sites and SSH servers supported public-key cryptography with shorter keys than expected: namely, 512 bits instead of at least 2048 bits. Remember, with public-key schemes, the security level isn’t equal to the key size, and in the case of HTTPS, keys of 512 bits offer a security level of approximately 60 bits. These keys could be broken after only about two weeks of computation using a cluster of 72 processors. Many websites were affected, including the FBI’s. Although the software was ultimately fixed (thanks to patches for OpenSSL and for other software), the problem was quite an unpleasant surprise.</p>
<h3 class="h3" id="lev1sec26">Further Reading</h3>
<p class="noindent">To learn more about provable security for symmetric ciphers, read the sponge functions documentation (<em><a href="http://sponge.noekeon.org/">http://sponge.noekeon.org/</a></em>). Sponge functions introduced the permutation-based approach in symmetric crypto, which describes how to construct a bunch of different cryptographic functions using only one permutation.</p>
<p class="indent">Some must-reads on the real cost of attacks include Bernstein’s 2005 paper “Understanding Brute Force” and Wiener’s 2004 paper “The Full Cost of Cryptanalytic Attacks,” both available online for free.</p>
<p class="indent">To determine the security level for a given key size, visit <em><a href="http://www.keylength.com/">http://www.keylength.com/</a></em>. This site also offers an explanation on how private keys are protected in common cryptographic utilities, such as SSH, OpenSSL, GnuPG, and so on.</p>
<p class="indent">Finally, as an exercise, pick an application (such as a secure messaging application) and identify its crypto schemes, key length, and respective security levels. You’ll often find surprising inconsistencies, such as a first scheme providing a 256-bit security level but a second scheme providing only 100-bit security. The security of the whole system is often only as strong as that of its weakest component.</p>
</body></html>