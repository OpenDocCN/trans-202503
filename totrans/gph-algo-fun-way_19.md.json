["```\ndef bipartite_labeling(g: Graph) -> Union[list, None]: \n    label: list = [None] * g.num_nodes\n    pending: queue.Queue = queue.Queue()\n\n  ❶ for start in range(g.num_nodes):\n      ❷ if label[start] is not None:\n            continue\n\n      ❸ pending.put(start)\n        label[start] = True\n        while not pending.empty():\n            current: int = pending.get()\n          ❹ next_label = not label[current]\n\n            for edge in g.nodes[current].get_edge_list():\n                neighbor: int = edge.to_node\n              ❺ if label[neighbor] is None:\n                    pending.put(neighbor)\n                    label[neighbor] = next_label\n              ❻ elif label[neighbor] != next_label:\n                    return None\n    return label \n```", "```\nclass Matching:\n    def __init__(self, num_nodes: int): \n        self.num_nodes: int = num_nodes self.assignments: list = [-1] * num_nodes\n        self.score: float = 0.0\n\n    def add_edge(self, ind1: int, ind2: int, score: float): \n        self.assignments[ind1] = ind2\n        self.assignments[ind2] = ind1\n        self.score += score\n\n    def remove_edge(self, ind1: int, ind2: int, score: float): \n        self.assignments[ind1] = -1\n        self.assignments[ind2] = -1\n        self.score -= score \n```", "```\ndef bipartite_matching_exh(g: Graph) -> Union[list, None]: \n  ❶ labels: Union[list, None] = bipartite_labeling(g)\n    if labels is None:\n        return None\n\n    current: Matching = Matching(g.num_nodes)\n  ❷ best_matching: Matching = matching_recursive(g, labels, current, 0)\n    return best_matching.assignments\n\ndef matching_recursive(g: Graph, labels: list, current: Matching,\n                       index: int) -> Matching: \n  ❸ if index >= g.num_nodes:\n        return copy.deepcopy(current)\n  ❹ if not labels[index]:\n        return matching_recursive(g, labels, current, index + 1)\n\n  ❺ best: Matching = matching_recursive(g, labels, current, index + 1)\n    for edge in g.nodes[index].get_edge_list():\n      ❻ if current.assignments[edge.to_node] == -1:\n            current.add_edge(index, edge.to_node, edge.weight)\n            new_m: Matching = matching_recursive(g, labels, current, index + 1)\n            if new_m.score > best.score:\n                best = new_m\n            current.remove_edge(index, edge.to_node, edge.weight)\n    return best \n```", "```\ndef bipartite_matching_max_flow(g: Graph) -> Union[list, None]: \n    num_nodes: int = g.num_nodes\n\n    labeling: Union[list, None] = bipartite_labeling(g)\n    if labeling is None:\n        return None\n\n  ❶ extended: Graph = Graph(g.num_nodes + 2, undirected=False)\n    for node in g.nodes:\n        for edge in node.edges.values():\n            if labeling[edge.from_node]:\n                extended.insert_edge(edge.from_node, edge.to_node, 1.0)\n\n  ❷ source_ind: int = num_nodes\n    sink_ind: int = num_nodes + 1\n    for i in range(num_nodes):\n        if labeling[i]:\n            extended.insert_edge(source_ind, i, 1.0)\n        else:\n            extended.insert_edge(i, sink_ind, 1.0)\n\n  ❸ residual: ResidualGraph = edmonds_karp(extended, source_ind, sink_ind)\n\n  ❹ result: list = [-1] * g.num_nodes\n    for from_node in range(residual.num_nodes):\n        if from_node != source_ind:\n            edge_list: dict = residual.edges[from_node]\n            for to_node in edge_list.keys():\n                if to_node != sink_ind and edge_list[to_node].used > 0.0:\n                    result[from_node] = to_node\n                    result[to_node] = from_node\n    return result \n```"]