<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_178"/><span epub:type="pagebreak" id="page_179"/><span class="big">7</span><br/>BUILDING LIBRARIES WITH LIBTOOL</h2>&#13;
<p class="quote"><em>The years teach much which the days never know.<br/>— Ralph Waldo Emerson, “Experience”</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">After too many bad experiences building shared libraries for multiple platforms without the help of GNU Libtool, I have come to two conclusions. First, the person who invented the concept of shared libraries should be given a raise . . . and a bonus. Second, the person who decided that shared library management interfaces and naming conventions should be left to the implementation should be flogged.</p>&#13;
<p class="indent">The very existence of Libtool stands as a witness to the truth of this sentiment. Libtool exists for only one reason—to provide a standardized, abstract interface for developers who want to create and access shared libraries in a portable manner. It abstracts both the shared-library build process and the programming interfaces used to dynamically load and access shared libraries at runtime.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_180"/>The Libtool package concept was designed, and initial implementation was done, by Gordon Matzigkeit in March of 1996. Before this time, there was no standard, cross-platform mechanism for building shared libraries. Autoconf and Automake worked great for building portable projects across many platforms—as long as you didn’t try to build a shared library. Once you started down this path, however, your code and build system would become littered with conditional constructs for shared-library management. This was a monumental effort because, as we shall see, building shared libraries is significantly different among some platforms.</p>&#13;
<p class="indent">Thomas Tanner began contributing in November of 1998 with his cross-platform abstraction for shared-library dynamic loading—<em>ltdl</em>. Other contributors since that time include Alexandre Oliva, Ossama Othman, Robert Boehne, Scott James Remnant, Peter O’Gorman, and Ralf Wildenhues. Currently, the Libtool package is maintained by Gary V. Vaughn (who has also been contributing to Libtool since 1998) and Bob Friesenhahn (whose excellent suggestions have been incorporated since 1998).</p>&#13;
<p class="indent">Before I get into a discussion of the proper use of Libtool, I’ll spend a few paragraphs on the features and functionality that shared libraries provide so you understand the scope of the material I’m covering here.</p>&#13;
<h3 class="h3" id="ch07sec1">The Benefits of Shared Libraries</h3>&#13;
<p class="noindent">Shared libraries provide a way to deploy reusable chunks of functionality in a convenient package. You can load shared libraries into a process address space either automatically at program load time, by using the operating system loader, or manually via code in the application itself. The point at which an application binds functionality from a shared library is very flexible, and the developer determines it based on the program’s design and the end user’s needs.</p>&#13;
<p class="indent">The interfaces between the program executable and the modules defined as shared libraries must be reasonably well designed because shared-library interfaces must be well specified. This rigorous specification promotes good design practices. When you use shared libraries, the system essentially forces you to be a better programmer.</p>&#13;
<p class="indent">Shared libraries may be (as the name implies) shared among processes. This sharing is very literal. The code segments for a shared library can be loaded once into physical memory pages. Those same memory pages can then be mapped into the process address spaces of multiple programs at once. The data pages must, of course, be unique for each process, but global data segments are often small compared to the code segments of a shared library. This is true efficiency.</p>&#13;
<p class="indent">It is easy to update shared libraries during program upgrades. Even if the base program doesn’t change between two revisions of a software package, you can replace an old version of a shared library with a new one, as long as the new version’s interfaces have not been changed. If interfaces <em>have</em> changed, two versions of the same shared library may reside together <span epub:type="pagebreak" id="page_181"/>within the same directory, because the versioning schemes used by shared libraries (and supported by Libtool) on various platforms allow multiple versions of a library to be named differently in the filesystem but treated as the same library by the operating system loader. Older programs will continue to use older versions of the library, while newer programs are free to use the newer versions.</p>&#13;
<p class="indent">If a software package specifies a well-defined plug-in interface, then shared libraries can be used to implement user-configurable loadable functionality. This means that additional functionality can become available to a program after it has been released, and third-party developers can even add functionality to your program, if you publish a document describing your plug-in interface specification (or if they’re smart enough to figure it out on their own).</p>&#13;
<p class="indent">There are a few widely known examples of these types of systems. Eclipse, for instance, is almost a pure plug-in framework. The base executable supports little more than a well-defined plug-in interface. Most of the functionality in an Eclipse application comes from library functions. Eclipse is written in Java and uses Java class libraries and <em>.jar</em> files, but the principle is the same, regardless of the language or platform.</p>&#13;
<h3 class="h3" id="ch07sec2">How Shared Libraries Work</h3>&#13;
<p class="noindent">The specifics of how POSIX-compliant operating systems implement shared libraries vary from platform to platform, but the general idea is the same. Shared libraries provide chunks of executable code that the operating system can load into a program’s address space and execute. The following discussion applies to shared-library references that the linker resolves when a program is built and the operating system loader resolves when the program is loaded.</p>&#13;
<p class="indent">While the object (<em>.o</em>) files produced by compilers do contain executable code, they cannot be executed by themselves from the command line. This is because they’re incomplete, containing symbolic references or <em>links</em> to external entities (functions and global data items) that must be patched up. This patching is done by using a tool designed to manage such links to combine the complete set of object files containing such references.</p>&#13;
<h4 class="h4" id="ch07sec2-1"><em>Dynamic Linking at Load Time</em></h4>&#13;
<p class="noindent">As a program executable image is being built, the linker (formally called a <em>link editor</em>) maintains a table of symbols—function entry points and global data addresses. Each symbol referenced within the accumulating body of object code is added to this table as the linker finds it. As symbol definitions are located, the linker resolves symbol references in the table to their addresses in the code. At the end of the linking process, all object files (or simply <em>objects</em>) containing referenced symbol definitions are linked together and become part of the program executable image.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_182"/>Objects found in static libraries (also called archives) that contain no referenced symbol definitions are discarded, but objects linked explicitly are added to the binary image even if they contain no referenced symbol definitions. If there are outstanding references in the symbol table after all the objects have been analyzed, the linker exits with an error message. On success, the final executable image may be loaded and executed by a user. The image is now entirely self-contained, depending on no external binary code.</p>&#13;
<p class="indent">Assuming that all undefined references are resolved during the linking process, if the list of objects to be linked contains one or more shared libraries, the linker will build the executable image from all <em>nonshared</em> objects specified on the linker command line. This includes all individual object files (<em>.o</em>) and all objects contained in static library archives (<em>.a</em>). However, the linker will add two tables to the binary image header. The first is the outstanding <em>external reference table</em>—a table of references to symbol definitions found only in shared libraries during the linking process. The second is the <em>shared-library table</em>, containing the list of shared-library names and versions in which the outstanding undefined references were found.</p>&#13;
<p class="indent">When the operating system loader attempts to load the program, it must resolve the remaining outstanding references in the external reference table to symbols imported from the shared libraries named in the shared-library table. If the loader can’t resolve all of the references, then a load error occurs, and the process is terminated with an operating system error message. Note that these external symbols are not tied to a specific shared library. As long as they’re found in any one of the searched libraries in the shared-library table, they’re accepted.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This process differs slightly from the way a Windows operating system loader resolves symbols in dynamic link libraries (DLLs). On Windows, the linker ties a particular symbol to a specifically named DLL at program build time.<sup><a id="ch07fn_1" href="footnote.xhtml#ch07fn1">1</a></sup></em></p>&#13;
</div>&#13;
<p class="indent">Using free-floating external references has both pros and cons. On some operating systems, unbound symbols can be satisfied by a library specified by the user. That is, a user can entirely replace a library (or a portion of a library) at runtime by simply preloading one that contains the same symbols. On BSD and Linux-based systems, for example, a user can use the <code>LD_PRELOAD</code> environment variable to inject a shared library into a process address space. Since the loader loads these libraries before any other libraries, the loader will locate symbols in the preloaded libraries when it tries to resolve external references. The program author’s intended libraries will not even be checked because the symbols provided by these libraries have already been resolved by the preloaded libraries.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_183"/>In the following example, the Linux <code>df</code> utility is executed with an environment containing the <code>LD_PRELOAD</code> variable. This variable has been set to a path referring to a library that presumably contains a heap manager that’s compatible with the C <em>malloc</em> interface. This technique can be used to debug memory problems in your programs. By preloading your own heap manager, you can capture memory allocations in a log file—in order to debug memory block overruns, for instance. This sort of technique is used by such widely known debugging aids as the <em>Valgrind</em> package.<sup><a id="ch07fn_2" href="footnote.xhtml#ch07fn2">2</a></sup></p>&#13;
<p class="indent">Here, the <code>LD_PRELOAD</code> environment variable is set on the same command line used to execute the <code>df</code> program. This shell code causes only the <code>df</code> child process environment to contain the <code>LD_PRELOAD</code> variable, set to the specified value:</p>&#13;
<pre>$ <span class="codestrong1">LD_PRELOAD=$HOME/lib/libmymalloc.so /bin/df</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">Unfortunately, free-floating symbols can also lead to problems. For instance, two libraries can provide the same symbol name, and the dynamic loader can inadvertently bind an executable to a symbol from the wrong library. At best, this will cause a program crash when the wrong arguments are passed to the mismatched function. At worst, it can present security risks because the mismatched function might be used to capture passwords and security credentials passed by the unsuspecting program.</p>&#13;
<p class="indent">C-language symbols do not include parameter information, so it’s rather likely that symbols will clash in this manner. C++ symbols are a bit safer, in that the entire function signature (minus the return type) is encoded into the symbol name. However, even C++ is not immune to hackers who purposely replace security functions with their own versions of those functions (assuming, of course, that they have access to your runtime shared-library search path).</p>&#13;
<h5 class="h5">Automatic Dynamic Linking at Runtime</h5>&#13;
<p class="noindent">The operating system loader can also use a very late form of binding, often referred to as <em>lazy binding</em>. In this situation, the external reference table entries in the program header are initialized so that they refer to code within the dynamic loader itself.</p>&#13;
<p class="indent">When a program first calls a <em>lazy entry</em>, the call is routed to the loader, which will then (potentially) load the proper shared library, determine the actual address of the function, reset the entry point in the jump table, and, finally, redirect the processor to the shared-library function (which is now available). The next time this happens, the jump table entry will have already been correctly initialized, and the program will jump directly to the called function. This is very efficient both because the overhead for the jump after <span epub:type="pagebreak" id="page_184"/>fix-up is no more than a normal indirect function call and because the cost of the initial load and link is amortized over many calls to the function during the lifetime of the process.<sup><a id="ch07fn_3" href="footnote.xhtml#ch07fn3">3</a></sup></p>&#13;
<p class="indent">This lazy binding mechanism makes program startup very fast because shared libraries whose symbols are not bound until they’re needed aren’t even loaded until the application program first references them. But, consider this—the program may <em>never</em> reference them. And that means they may never be loaded, saving both time and space. A good example of this sort of situation might be a word processor with a thesaurus feature implemented in a shared library. How often do you use your thesaurus? If the program is using automatic dynamic linking, chances are that the shared library containing the thesaurus code will never be loaded in most word-processing sessions.</p>&#13;
<p class="indent">As good as this system appears to be, there can be problems. While using automatic runtime dynamic linking can give you faster load times, better performance, and more efficient use of space, it can also cause your application to terminate abruptly and without warning. In the event that the loader can’t find the requested symbol—perhaps the required library is missing—it has no recourse except to abort the process.</p>&#13;
<p class="indent">Why not ensure that all symbols exist when the program is loaded? Because if the loader resolved all symbols at load time, it might as well populate the jump table entries at that point, too. After all, it had to load all the libraries to ensure that the symbols actually exist, so this would entirely defeat the purpose of using lazy binding. Furthermore, even if the loader did check all external references when the program was first started, there’s nothing to stop someone from deleting one or more of these libraries before the program uses them, while the program is still running.<sup><a id="ch07fn_4" href="footnote.xhtml#ch07fn4">4</a></sup> Thus, even the pre-check is defeated.</p>&#13;
<p class="indent">The moral of this story is that there’s no free lunch. If you don’t want to pay the insurance premium for longer up-front load times and more space consumed (even if you may never really need it), then you may have to take the hit of a missing symbol at runtime, causing a program crash.</p>&#13;
<h5 class="h5">Manual Dynamic Linking at Runtime</h5>&#13;
<p class="noindent">One possible solution to the aforementioned problem is to take personal responsibility for some of the system loader’s work. Then, when things don’t go right, you have a little more control over the outcome. In the case of the thesaurus module, was it really necessary to terminate the program if the <span epub:type="pagebreak" id="page_185"/>thesaurus library could not be loaded or didn’t provide the correct symbols? Of course not—but the operating system loader can’t know that. Only the software programmer can make such judgment calls.</p>&#13;
<p class="indent">When a program manages dynamic linking manually at runtime, the linker is left out of the equation entirely, and the program doesn’t call any exported shared-library functions directly. Rather, shared-library functions are referenced through function pointers that the program itself populates at runtime.</p>&#13;
<p class="indent">Here’s how it works: A program calls an operating system function (<code>dlopen</code>) to manually load a shared library into its own process address space. This function returns a <em>handle</em>, or an opaque value representing the loaded library. The program then calls another loader function (<code>dlsym</code>) to import a symbol from the library to which the handle refers. If all goes well, the operating system returns the address of the requested function or data item from the desired library. The program may then call the function, or access the global data item, through this pointer.</p>&#13;
<p class="indent">If something goes wrong in this process—the symbol isn’t found within the library or the library isn’t found—then it becomes the responsibility of the program to define the results, perhaps by displaying an error message indicating that the program was not configured correctly. In the preceding example of the word processor, a simple dialog indicating that the thesaurus is unavailable would be entirely sufficient.</p>&#13;
<p class="indent">This is a little nicer than the way automatic dynamic runtime linking works; while the loader has no option but to abort, the application has a higher-level perspective and can handle the problem much more gracefully. The drawback, of course, is that you as the programmer have to manage the process of loading libraries and importing symbols within your application code. However, this process is not very difficult, as I’ll demonstrate in the next chapter.</p>&#13;
<h3 class="h3" id="ch07sec3">Using Libtool</h3>&#13;
<p class="noindent">An entire book could be written about the details of shared libraries and how they’re implemented on various systems. The short primer you just read should suffice for our immediate needs, so I’ll now move on to how you can use Libtool to make a package maintainer’s life a little easier.</p>&#13;
<p class="indent">The Libtool project was designed to extend Automake, but you can use it independently within hand-coded makefiles, as well. As of this writing, the latest version of Libtool, and the one I’m using in the examples here, is version 2.4.6.</p>&#13;
<h4 class="h4" id="ch07sec3-1"><em>Abstracting the Build Process</em></h4>&#13;
<p class="noindent">First, let’s look at how Libtool helps during the build process. Libtool provides a script (<em>ltmain.sh</em>) that <code>config.status</code> consumes in a Libtool-enabled project. The <code>config.status</code> script converts <code>configure</code> test results and the <code>ltmain.sh</code> script into a custom version of the <code>libtool</code> script, specifically <span epub:type="pagebreak" id="page_186"/>tailored to your project.<sup><a id="ch07fn_5" href="footnote.xhtml#ch07fn5">5</a></sup> Your project’s makefiles then use this <code>libtool</code> script to build the shared libraries listed in any Automake product list variables defined with the Libtool-specific <code>LTLIBRARIES</code> primary. The <code>libtool</code> script is really just a fancy wrapper around the compiler, linker, and other tools. You should ship the <code>ltmain.sh</code> script in a distribution archive, as part of your build system. Automake-generated rules ensure that this happens properly.</p>&#13;
<p class="indent">The <code>libtool</code> script insulates the author of the build system from the nuances of building shared libraries on different platforms. This script accepts a well-defined set of options, converting them to appropriate platform- and linker-specific options on the target platform and toolset. Thus, the maintainer doesn’t need to worry about the specifics of building shared libraries on each platform—they only need to understand the available <code>libtool</code> script options. These options are well specified in the <em>GNU Libtool Manual</em>,<sup><a id="ch07fn_6" href="footnote.xhtml#ch07fn6">6</a></sup> and I’ll cover many of them in this chapter and the next.</p>&#13;
<p class="indent">On systems that don’t support shared libraries at all, the <code>libtool</code> script uses appropriate commands and options to build and link only static archive libraries. Furthermore, the maintainer doesn’t have to worry about the differences between building shared libraries and building static libraries when using Libtool. You can emulate building your package on a static-only system by using the <code>--disable-shared</code> option on the <code>configure</code> command line for your Libtool-enabled project. This option causes Libtool to assume that shared libraries cannot be built on the target system.</p>&#13;
<h4 class="h4" id="ch07sec3-2"><em>Abstraction at Runtime</em></h4>&#13;
<p class="noindent">You can also use Libtool to abstract the programming interfaces the operating system supplies for loading libraries and importing symbols. If you’ve ever dynamically loaded a library on a Linux system, you’re familiar with the standard POSIX shared-library API, including the <code>dlopen</code>, <code>dlsym</code>, and <code>dlclose</code> functions. A system-level shared library, usually called simply <em>dl</em>, provides these functions. This translates to a binary image file named <em>libdl.so</em> (or something similar on systems that use different library-naming conventions).</p>&#13;
<p class="indent">Unfortunately, not all Unix systems that support shared libraries provide the <em>libdl.so</em> library or functions using these names. To address these differences, Libtool provides a shared library called <em>ltdl</em>, which exports a clean, portable, library-management interface that is very similar to the POSIX <em>dl</em> interface. The use of this library is optional, of course, but it is highly recommended because it provides more than just a common API across shared-library platforms—it also provides an abstraction for manual dynamic linking between shared-library and non-shared-library platforms.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_187"/><em>What?! How can that work?!</em> On systems that don’t support shared libraries, Libtool actually creates internal symbol tables within the executable that contain all the symbols you would otherwise find within shared libraries (on systems that support shared libraries). By using such symbol tables on these platforms, the <code>lt_dlopen</code> and <code>lt_dlsym</code> functions can make your code appear to be loading libraries and importing symbols, when in fact, the library load function does nothing more than return a handle to the appropriate internal symbol table, and the import function merely returns the address of code that has been statically linked into the program itself. On these systems, a project’s shared-library code is linked directly into the programs that would normally load them at runtime.</p>&#13;
<h3 class="h3" id="ch07sec4">Installing Libtool</h3>&#13;
<p class="noindent">If you want to make use of the latest version of Libtool while developing your packages, you may find that you either have to download, build, and install it manually or look for an updated <em>libtool</em> package from your distribution provider.</p>&#13;
<p class="indent">Downloading, building, and installing Libtool is really trivial, as you’ll see here. However, you should check the GNU Libtool website<sup><a id="ch07fn_7" href="footnote.xhtml#ch07fn7">7</a></sup> before executing these steps in order to ensure you’re getting the most recent package. I’ve reproduced the basic steps here from <a href="ch01.xhtml">Chapter 1</a>:</p>&#13;
<pre>$ <span class="codestrong1">wget https://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.gz</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">tar xzf libtool-2.4.6.tar.gz</span>&#13;
$ <span class="codestrong1">cd libtool-2.4.6</span>&#13;
$ <span class="codestrong1">./configure &amp;&amp; make</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">sudo make install</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Be aware that the default installation location (as with most of the GNU packages) is <em>/usr/local</em>. If you wish to install Libtool into the <em>/usr</em> hierarchy, you’ll need to use the <code>--prefix=/usr</code> option on the <code>configure</code> command line. The recommended practice is to install distribution-provided packages into the <em>/usr</em> hierarchy and user-built packages into the <em>/usr/local</em> tree, but if you’re trying to get a hand-built version of Libtool to interoperate with distribution-provided versions of Autoconf and Automake, you may have to install Libtool into the <em>/usr</em> hierarchy. The simplest way to avoid problems with package interdependencies is to install hand-built versions of all three packages into <em>/usr/local</em> or, better still, into a directory within your home directory, which you can then add to your <code>PATH</code>.</p>&#13;
<h3 class="h3" id="ch07sec5"><span epub:type="pagebreak" id="page_188"/>Adding Shared Libraries to Jupiter</h3>&#13;
<p class="noindent">Now that I’ve presented the requisite background information, let’s take a look at how we might add a Libtool shared library to the Jupiter project. First, let’s consider what functionality we could add to Jupiter using a shared library. Perhaps we want to provide our users with some library functionality that their own applications could use. Or we might have several applications in a package that need to share the same functionality. A shared library is a great tool for both of these scenarios because you get to reuse code and save memory—the cost of the memory used by shared code is amortized across multiple applications, both internal and external to the project.</p>&#13;
<p class="indent">Let’s add a shared library to Jupiter that provides Jupiter’s printing functionality. We can do this by having the new shared library call into the <em>libjupcommon.a</em> static library. Remember that calling a routine in a static library has the same effect as linking the object code for the called routine right into the calling program. The called routine ultimately becomes an integral part of the calling binary image (program or shared library).<sup><a id="ch07fn_8" href="footnote.xhtml#ch07fn8">8</a></sup></p>&#13;
<p class="indent">Additionally, we’ll provide a public header file from the Jupiter project that will allow external applications to call this same functionality. This allows other applications to display stuff in the same quaint manner that the <code>jupiter</code> program does. (This would be significantly cooler if we were doing something useful in Jupiter, but you get the idea.)</p>&#13;
<h4 class="h4" id="ch07sec5-1"><em>Using the LTLIBRARIES Primary</em></h4>&#13;
<p class="noindent">Automake has built-in support for Libtool; it’s the Automake package, rather than the Libtool package, that provides the <code>LTLIBRARIES</code> primary. Libtool doesn’t really qualify as a pure Automake extension but rather is more of an add-on package for Automake, where Automake provides the necessary infrastructure for this specific add-on package. You can’t access Automake’s <code>LTLIBRARIES</code> primary functionality without Libtool because the use of this primary generates <code>make</code> rules that call the <code>libtool</code> script.</p>&#13;
<p class="indent">Libtool ships separately, rather than as part of Automake, because you can use Libtool quite effectively independently of Automake. If you want to try Libtool by itself, I’ll refer you to the <em>GNU Libtool Manual</em>; the opening chapters describe the use of the <code>libtool</code> script as a stand-alone product. It’s as simple as modifying your makefile commands so that the compiler, linker, and librarian are called through the <code>libtool</code> script, and then modifying some of your command line parameters as required by Libtool.</p>&#13;
<h4 class="h4" id="ch07sec5-2"><span epub:type="pagebreak" id="page_189"/><em>Public Include Directories</em></h4>&#13;
<p class="noindent">A project subdirectory named <em>include</em> should only contain public header files—those that expose a public interface in your project. We’re now going to add just such a header file to the Jupiter project, so we’ll create a directory called <em>include</em> in the project root directory.</p>&#13;
<p class="indent">If we had multiple shared libraries, we’d have a choice to make: do we create separate <em>include</em> directories, one in each library source directory, or do we add a single, top-level <em>include</em> directory? I usually use the following rule of thumb to make my decision: If the libraries are designed to work together as a group, and if consuming applications generally use the libraries together, then I use a single, top-level <em>include</em> directory. If, on the other hand, the libraries can be effectively used independently, and if they offer fairly autonomous sets of functionality, then I provide individual <em>include</em> directories in the libraries’ own directories.</p>&#13;
<p class="indent">In the end, it doesn’t really matter much because the header files for these libraries will be installed in directory structures that are entirely different from the ones where they exist within your project. In fact, you should make sure you don’t inadvertently use the same filename for public headers in two different libraries in your project—if you do, you’ll have problems installing these files. They generally end up all together in the <code>$(prefix)</code><em>/include</em> directory, although you can override this default by using either the <code>includedir</code> variable or the <code>pkginclude</code> prefix in your <em>Makefile.am</em> files.</p>&#13;
<p class="indent">The <code>includedir</code> variable allows you to specify where you want your header files to be installed by defining the exact value of Automake’s <code>$(includedir)</code> variable, the usual value of which is <code>$(prefix)</code><em>/include</em>. The use of the <code>pkginclude</code> prefix indicates to Automake that you want your header files to be in a private, package-specific directory, beneath the directory indicated by <code>$(includedir)</code>, called <code>$(includedir)</code><em>/</em><code>$(PACKAGE)</code>.</p>&#13;
<p class="indent">We’ll also add another root-level directory (<em>libjup</em>) for Jupiter’s new shared library, <em>libjupiter</em>. These changes require you to add references to the new directories to the top-level <em>Makefile.am</em> file’s <code>SUBDIRS</code> variable and then add corresponding <em>Makefile</em> references to the <code>AC_CONFIG_FILES</code> macro in <em>configure.ac</em>. Since we’re going to make major changes to our project, we’d better clean up the work area before we start. Then we’ll create the directories and add a new <em>Makefile.am</em> file to the new <em>include</em> directory:</p>&#13;
<p class="margin">Git tag 7.0</p>&#13;
<pre>   $ <span class="codestrong1">make maintainer-clean</span>&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   $ <span class="codestrong1">mkdir libjup</span> <span class="codestrong1">include</span>&#13;
<span class="ent">➊</span> $ <span class="codestrong1">echo "include_HEADERS = libjupiter.h" &gt; include/Makefile.am</span>&#13;
   $</pre>&#13;
<p class="indent">The <em>include</em> directory’s <em>Makefile.am</em> file is trivial—it contains only a single line, in which an Automake <code>HEADERS</code> primary refers to the public header file <em>libjupiter.h</em>. Note at <span class="ent">➊</span> that we’re using the <code>include</code> prefix on this primary. You’ll recall that this prefix indicates that files specified in this primary are destined to be installed in the <code>$(includedir)</code> directory (for example, <em>/usr/(local/)include</em>). The <code>HEADERS</code> primary is similar to the <code>DATA</code> primary in that <span epub:type="pagebreak" id="page_190"/>it specifies a set of files that are to be treated simply as data to be installed without modification or preprocessing. The only really tangible difference is that the <code>HEADERS</code> primary restricts the possible installation locations to those that make sense for header files.</p>&#13;
<p class="indent">The <em>libjup/Makefile.am</em> file is a bit more complex, containing four lines as opposed to just one. This file is shown in <a href="ch07.xhtml#ch07ex1">Listing 7-1</a>.</p>&#13;
<pre><span class="ent">➊</span> lib_LTLIBRARIES = libjupiter.la&#13;
<span class="ent">➋</span> libjupiter_la_SOURCES = jup_print.c&#13;
<span class="ent">➌</span> libjupiter_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/common&#13;
<span class="ent">➍</span> libjupiter_la_LIBADD = ../common/libjupcommon.a</pre>&#13;
<p class="caption" id="ch07ex1"><em>Listing 7-1:</em> libjup/Makefile.am: <em>The initial version of this file</em></p>&#13;
<p class="indent">Let’s analyze this file, line by line. The line at <span class="ent">➊</span> is the primary specification, and it contains the usual prefix for libraries: <code>lib</code>. The products this prefix references will be installed in the <code>$(libdir)</code> directory. (We could have also used the <code>pkglib</code> prefix to indicate that we wanted our libraries installed into <code>$(libdir)</code><em>/jupiter</em>.) Here, we’re using the <code>LTLIBRARIES</code> primary rather than the original <code>LIBRARIES</code> primary. The use of <code>LTLIBRARIES</code> tells Automake to generate rules that use the <code>libtool</code> script rather than calling the compiler (and possibly the librarian) directly to generate the products.</p>&#13;
<p class="indent">The line at <span class="ent">➋</span> lists the sources that are to be used for the first (and only) product.</p>&#13;
<p class="indent">The line at <span class="ent">➌</span> indicates a set of C-preprocessor flags that are to be used on the compiler command line for locating the associated shared-library header files. These options indicate that the preprocessor should search the top-level <em>include</em> and <em>common</em> directories for header files referenced in the source code.</p>&#13;
<p class="indent">The last line (at <span class="ent">➍</span>) indicates a set of linker options for this product. In this case, we’re specifying that the <em>libjupcommon.a</em> static library should be linked into (that is, become part of) the <em>libjupiter.so</em> shared library.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The more experienced Autotools library developer will notice a subtle flaw in this</em> Makefile.am <em>file. Here’s a hint: it’s related to linking Libtool libraries against non-Libtool libraries. This concept presents a major stumbling block for many newcomers, so I’ve written the initial version of this file to illustrate the error. Not to worry, however—we’ll correct the flaw later in this chapter as we work through this issue in a logical fashion</em>.</p>&#13;
</div>&#13;
<p class="indent">There is an important concept regarding the <code>*_LIBADD</code> variables that you should strive to understand completely: Libraries that are consumed within, and yet built as part of, the same project should be referenced internally using relative paths, via either parent directory references or the <code>$(</code><code>top_builddir</code><code>)</code> variable, within the <em>build</em> directory hierarchy. Libraries that are external to a project generally don’t need to be referenced explicitly at all, because the project’s <code>configure</code> script should already have added appropriate <code>-L</code> and <code>-l</code> options for those libraries into the <code>$(LIBS)</code> environment variable when it processed the code generated by the <code>AC_CHECK_LIB</code> or <code>AC_SEARCH_LIBS</code> macro.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_191"/>Next, we’ll hook these new directories into the project’s build system. To do so, we need to modify the top-level <em>Makefile.am</em> and <em>configure.ac</em> files. These changes are shown in <a href="ch07.xhtml#ch07ex2">Listings 7-2</a> and <a href="ch07.xhtml#ch07ex3">7-3</a>, respectively.</p>&#13;
<pre><span class="ash">SUBDIRS = common</span> include libjup <span class="ash">src</span></pre>&#13;
<p class="caption" id="ch07ex2"><em>Listing 7-2:</em> Makefile.am: <em>Adding</em> include <em>and</em> libjup <em>to the <code>SUBDIRS</code> variable</em></p>&#13;
<pre>   <span class="ash">#                                               -*- Autoconf -*-</span>&#13;
   <span class="ash"># Process this file with autoconf to produce a configure script.</span>&#13;
&#13;
   <span class="ash">AC_PREREQ([2.69])</span>&#13;
   <span class="ash">AC_INIT([Jupiter],[1.0],[jupiter-bugs@example.org])</span>&#13;
   <span class="ash">AM_INIT_AUTOMAKE</span>&#13;
<span class="ent">➊</span> LT_PREREQ([2.4.6])&#13;
   LT_INIT([dlopen])&#13;
   <span class="ash">AC_CONFIG_SRCDIR([src/main.c])</span>&#13;
   <span class="ash">AC_CONFIG_HEADERS([config.h])</span>&#13;
&#13;
   <span class="ash"># Checks for programs.</span>&#13;
   <span class="ash">AC_PROG_CC</span>&#13;
<span class="ent">➋</span> <span class="ash">AC_PROG_INSTALL</span>&#13;
&#13;
   <span class="ash"># Checks for header files.</span>&#13;
   <span class="ash">AC_CHECK_HEADERS([stdlib.h])</span>&#13;
   <span class="codeitalic1a">--snip--</span>&#13;
   <span class="ash">AC_CONFIG_FILES([Makefile</span>&#13;
                    <span class="ash">common/Makefile</span>&#13;
                 <span class="ent">➌</span> include/Makefile&#13;
                    libjup/Makefile&#13;
                    <span class="ash">src/Makefile])</span>&#13;
   <span class="ash">AC_OUTPUT</span>&#13;
   <span class="codeitalic1a">--snip--</span></pre>&#13;
&#13;
<p class="caption" id="ch07ex3"><em>Listing 7-3:</em> configure.ac: <em>Adding the</em> include <em>and</em> libjup <em>directory makefiles</em></p>&#13;
<p class="indent">Three unrelated changes were required in <em>configure.ac</em>. The first is the addition at <span class="ent">➊</span> of the Libtool setup macros <code>LT_PREREQ</code> and <code>LT_INIT</code>. The <code>LT_PREREQ</code> macro works just like Autoconf’s <code>AC_PREREQ</code> macro (used a few lines higher). It indicates the earliest version of Libtool that can correctly process this project. You should choose the lowest reasonable values for the arguments in these macros because higher values needlessly restrict you and your co-maintainers to more recent versions of the Autotools.<sup><a id="ch07fn_9" href="footnote.xhtml#ch07fn9">9</a></sup> The <code>LT_INIT</code> macro initializes the Libtool system for this project.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_192"/>The second change is just as interesting. I removed the <code>AC_PROG_RANLIB</code> macro invocation after the line at <span class="ent">➋</span>. (And after all we went through to put it there in the first place!) Because Libtool is now building all of the project libraries, and because it understands all aspects of the library build process, we no longer need to instruct Autoconf to make sure <code>ranlib</code> is available. In fact, if you leave this macro in, you’ll get a warning when you execute <code>autoreconf -i</code>.</p>&#13;
<p class="indent">The last change is found at <span class="ent">➌</span> in the argument to <code>AC_CONFIG_FILES</code>, where we’ve added references to the two new <em>Makefile.am</em> files we added to the <em>include</em> and <em>libjup</em> directories.</p>&#13;
<h4 class="h4" id="ch07sec5-3"><em>Customizing Libtool with LT_INIT Options</em></h4>&#13;
<p class="noindent">You can specify default values for enabling or disabling static and shared libraries in the argument list passed into <code>LT_INIT</code>. The <code>LT_INIT</code> macro accepts a single, optional argument: a whitespace-separated list of keywords. The following are the most important keywords allowed in this list, along with an explanation of their proper use.</p>&#13;
<p class="noindentt"><span class="codestrong1">dlopen</span></p>&#13;
<p class="noindenti">This option enables checking for <code>dlopen</code> support. The <em>GNU Libtool Manual</em> states that this option should be used if the package makes use of the <code>-dlopen</code> and <code>-dlpreopen</code> flags in <code>libtool</code>; otherwise <code>libtool</code> will assume that the system does not support <em>dl-opening</em>. There’s only one reason for using the <code>-dlopen</code> or <code>-dlpreopen</code> flag: you intend to dynamically load and import shared-library functionality at runtime within your project’s source code. Additionally, these two options do very little unless you intend to use the <em>ltdl</em> library (rather than directly using the <em>dl</em> library) to manage your runtime dynamic linking. Thus, you should use this option only if you intend to use the <em>ltdl</em> library.</p>&#13;
<p class="noindentt"><span class="codestrong1">win32-dll</span></p>&#13;
<p class="noindenti">Use this option if your library is properly ported to a Windows DLL using <code>__declspec(dllimport)</code> and <code>__declspec(dllexport)</code>. If your library properly uses these keywords to import and export symbols for Windows DLLs, and you don’t use this option, then Libtool will only build static libraries on Windows. We’ll cover this topic in more detail in <a href="ch17.xhtml">Chapter 17</a>.</p>&#13;
<p class="noindentt"><span class="codestrong1">aix-soname=aix|svr4|both</span></p>&#13;
<p class="noindenti">Adds the flags <code>--with-aix-soname</code> to <code>configure</code>’s command line. Prior to version 2.4.4, Libtool always behaved as if <code>aix-soname</code> were set to <code>aix</code>. If you build shared libraries on AIX often, you’ll understand the meaning of this option. If you wish to learn more, read Section 5.4.1 of the <em>GNU Libtool Manual</em>.</p>&#13;
<p class="noindentt"><span class="codestrong1">disable-fast-install</span></p>&#13;
<p class="noindenti">This option changes the default behavior for <code>LT_INIT</code> to disable optimization for fast installation on systems where it matters. The concept of fast installation exists because uninstalled programs and libraries may <span epub:type="pagebreak" id="page_193"/>need to be executed from within the build tree (during <code>make check</code>, for example). On some systems, installation location affects the final linked binary image, so Libtool must either relink programs and libraries on these systems when <code>make install</code> is executed or else relink programs and libraries for <code>make check</code>. Libtool chooses to relink for <code>make check</code> by default, allowing the original binaries to be installed quickly without relinking during <code>make install</code>. The user can override this default, depending on platform support, by specifying <code>--enable-fast-install</code> to <code>configure</code>.</p>&#13;
<p class="noindentt"><span class="codestrong1">shared</span> and <span class="codestrong1">disable-shared</span></p>&#13;
<p class="noindenti">These two options change the default behavior for creating shared libraries. The effects of the <code>shared</code> option are default behavior on all systems where Libtool knows how to create shared libraries. The user may override the default shared library-generation behavior by specifying either <code>--disable-shared</code> or <code>--enable-shared</code> on the <code>configure</code> command line.</p>&#13;
<p class="noindentt"><span class="codestrong1">static</span> and <span class="codestrong1">disable-static</span></p>&#13;
<p class="noindenti">These two options change the default behavior for creating static libraries. The effects of the <code>static</code> option are default behavior on all systems where shared libraries have been disabled and on most systems where shared libraries have been enabled. If shared libraries are enabled, the user may override this default by specifying <code>--</code><code>disable-static</code> on the <code>configure</code> command line. Libtool will always generate static libraries on systems without shared libraries. Hence, you can’t (effectively) use the <code>disable-shared</code> and <code>disable-static</code> arguments to <code>LT_INIT</code> or the <code>--disable-shared</code> and <code>--disable-static</code> command line options for <code>configure</code> at the same time. (Note, however, that you may use the <code>shared</code> and <code>static</code> <code>LT_INIT</code> options or the <code>--enable-shared</code> and <code>--enable-static</code> command line options together.)</p>&#13;
<p class="noindentt"><span class="codestrong1">pic-only</span> and <span class="codestrong1">no-pic</span></p>&#13;
<p class="noindenti">These two options change the default behavior for creating and using PIC object code. The user may override the defaults set by these options by specifying <code>--without-pic</code> or <code>--with-pic</code> on the <code>configure</code> command line. I’ll discuss the meaning of PIC object code in “So What Is PIC, Anyway?” on <a href="ch07.xhtml#page_200">page 200</a>.</p>&#13;
<p class="indentt">Now that we’ve finished setting up the build system for the new library, we can move on to discussing the source code. <a href="ch07.xhtml#ch07ex4">Listing 7-4</a> shows the contents of the new <em>jup_print.c</em> source file that’s referenced in the second line of <em>libjup/Makefile.am</em>. <a href="ch07.xhtml#ch07ex5">Listing 7-5</a> shows the contents of the new <em>include/libjupiter.h</em> library header file.</p>&#13;
<pre>#include "config.h"&#13;
&#13;
#include "libjupiter.h"&#13;
#include "jupcommon.h"&#13;
&#13;
int jupiter_print(const char * name)&#13;
<span epub:type="pagebreak" id="page_194"/>{&#13;
     return print_routine(name);&#13;
}</pre>&#13;
<p class="caption" id="ch07ex4"><em>Listing 7-4:</em> libjup/jup_print.c: <em>The initial contents of the shared-library source file</em></p>&#13;
<pre>#ifndef LIBJUPITER_H_INCLUDED&#13;
#define LIBJUPITER_H_INCLUDED&#13;
&#13;
int jupiter_print(const char * name);&#13;
&#13;
#endif /* LIBJUPITER_H_INCLUDED */</pre>&#13;
<p class="caption" id="ch07ex5"><em>Listing 7-5:</em> include/libjupiter.h: <em>The initial contents of the shared-library public header file</em></p>&#13;
<p class="indent">This leads us to another general software-engineering principle. I’ve heard it called by many names, but the one I tend to use the most is the <em>DRY principle</em>—the acronym stands for <em>don’t repeat yourself</em>. C function prototypes are very useful because, when used correctly, they enforce the fact that the public’s view of a function is identical to the package maintainer’s view. All too often I’ve seen source files that don’t include their corresponding header files. It’s easy to make a small change in a function or prototype and then not duplicate it in the other location—unless you’ve included the public header file within the source file. When you do this consistently, the compiler catches any inconsistencies for you.</p>&#13;
<p class="indent">We also need to include the static library header file (<em>jupcommon.h</em>) because we call its function (<em>print_routine</em>) from within the public library function. You may have also noticed that I placed <em>config.h</em> first, immediately followed by the public header file—there’s a good reason for this. I’ve already stated in <a href="ch06.xhtml">Chapter 6</a> that <em>config.h</em> should always come first in every source file. Normally, I’d say the public header file should come first, but public header files should be written so that their functionality is never modified by <em>config.h</em>, so, technically, it should not matter if the public header file comes before or after <em>config.h</em>. For example, using a compiler-mode dependent type like <code>off_t</code> in a public header file will cause the application binary interface (ABI) to change not only from one platform to another (not necessarily a bad thing) but also on the same platform from one use to another, based on the compilation environment set up by consumer code (not a good thing). The fact is, you should write your public header files in such a way that it doesn’t really matter whether you include them before or after <em>config.h</em>; they should be purposely designed so they do not depend on anything that <em>can</em> be configured by <em>config.h</em>. For a more complete treatise on this topic, see “Item 1: Keeping Private Details out of Public Interfaces” on <a href="ch18.xhtml#page_499">page 499</a>.</p>&#13;
<p class="indent">By placing the public header file first in the source file (after <em>config.h</em>), we ensure that the use of this header file doesn’t depend on definitions in any internal header files in the project. For instance, let’s say the public header file has a hidden dependency on some construct (such as a type definition, structure, or preprocessor definition) defined in an internal header like <em>jupcommon.h</em>. If we include the public header file after <em>jupcommon.h</em>, <span epub:type="pagebreak" id="page_195"/>the dependency would be hidden when the compiler begins to process the public header file, because the required construct is already available in the <em>translation unit</em> (the source file combined with all of the included header files).</p>&#13;
<p class="indent">I’d like to make one final point about the contents of <a href="ch07.xhtml#ch07ex5">Listing 7-5</a>. The preprocessor conditional construct is commonly called an <em>include guard</em>. It is a mechanism for preventing your header files from inadvertently being included multiple times within the same translation unit. I use include guards routinely in all my header files, and it’s good practice to do so. A good optimizing compiler (<code>gcc</code>, for instance—specifically, its preprocessor) will recognize include guards in header files and skip the file entirely on subsequent inclusions within the same translation unit.<sup><a id="ch07fn_10" href="footnote.xhtml#ch07fn10">10</a></sup></p>&#13;
<p class="indent">Since a public header file will be consumed by foreign source code, it’s even more critical that you use include guards religiously in these header files. While you can control your own code base, you have no say over the code that one of your library consumers writes. What I’m advocating here is that you assume you’re the best programmer you know, and everyone else is a little below your skill level. You can do this nicely by not mentioning it to anyone, but you should <em>act</em> like it’s a fact when you write your public header files.</p>&#13;
<p class="indent">Next, we’ll modify the Jupiter application’s <code>main</code> function so that it calls into the shared library instead of the common static library. These changes are shown in <a href="ch07.xhtml#ch07ex6">Listing 7-6</a>.</p>&#13;
<pre><span class="ash">#include "config.h"</span>&#13;
&#13;
<span class="ash">#include "</span>libjupiter.h<span class="ash">"</span>&#13;
&#13;
<span class="ash">int main(int argc, char * argv[])</span>&#13;
<span class="ash">{</span>&#13;
    <span class="ash">return</span> jupiter_print<span class="ash">(argv[0]);</span>&#13;
<span class="ash">}</span></pre>&#13;
&#13;
<p class="caption" id="ch07ex6"><em>Listing 7-6:</em> src/main.c: <em>Changing <code>main</code> to call the shared-library function</em></p>&#13;
<p class="indent">Here, we’ve changed the print function from <code>print_routine</code>, found in the static library, to <code>jupiter_print</code>, as provided by the new shared library. We’ve also changed the header file included at the top from <em>libjupcommon.h</em> to <em>libjupiter.h</em>.</p>&#13;
<p class="indent">My choices of names for the public function and header file were arbitrary but based on a desire to provide a clean, rational, and informational public interface. The name <em>libjupiter.h</em> very clearly indicates that this header file specifies the public interface for <em>libjupiter.so</em>. I try to name library interface functions to make it clear that they are part of an interface. How you choose to name your public interface members—files, functions, structures, type definitions, preprocessor definitions, global data, and so on—is up to <span epub:type="pagebreak" id="page_196"/>you, but you should consider using a similar philosophy. Remember, the goal is to provide a great end-user experience. Intuitive naming should be a significant part of your strategy. For example, it is a good general practice to choose a common prefix for your program and library symbols.<sup><a id="ch07fn_11" href="footnote.xhtml#ch07fn11">11</a></sup></p>&#13;
<p class="indent">Finally, we must also modify the <em>src/Makefile.am</em> file to use our new shared library rather than the <em>libjupcommon.a</em> static library. These changes are shown in <a href="ch07.xhtml#ch07ex7">Listing 7-7</a>.</p>&#13;
<pre>   <span class="ash">bin_PROGRAMS = jupiter</span>&#13;
   <span class="ash">jupiter_SOURCES = main.c</span>&#13;
<span class="ent">➊</span> <span class="ash">jupiter_CPPFLAGS = -I$(top_srcdir)/</span>include&#13;
<span class="ent">➋</span> <span class="ash">jupiter_LDADD =</span> ../libjup/libjupiter.la&#13;
   <span class="ash"/><span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch07ex7"><em>Listing 7-7:</em> src/Makefile.am: <em>Adding shared-library references to the src directory makefile</em></p>&#13;
<p class="indent">Here, we’ve changed the <code>jupiter_CPPFLAGS</code> statement at <span class="ent">➊</span> so that it refers to the new top-level <em>include</em> directory rather than the <em>common</em> directory. We’ve also changed the <code>jupiter_LDADD</code> statement at <span class="ent">➋</span> so that it refers to the new Libtool shared-library object rather than the <em>libjupcommon.a</em> static library. All else remains the same. The syntax for referring to a Libtool library is identical to that for referring to an older, static library—only the library extension is different. The Libtool library extension <em>.la</em> stands for <em>libtool archive</em>.</p>&#13;
<p class="indent">Let’s take a step back for a moment. Do we actually need to make this change? No, of course not. The <code>jupiter</code> application will continue to work just fine the way we originally wrote it. Linking the code for the static library’s <code>print_routine</code> directly into the application works just as well as calling the new shared-library routine (which ultimately contains the same code, anyway). In fact, there is slightly more overhead in calling a shared-library routine because of the extra level of indirection when calling through a shared-library jump table.</p>&#13;
<p class="indent">In a real project, you might actually leave it the way it was. Because both public entry points, <code>main</code> and <code>jupiter_print</code>, call exactly the same function (<code>print_routine</code>) in <em>libjupcommon.a</em>, their functionality is identical. Why add even the slight overhead of a call through the public interface? Well, one reason is that you can take advantage of shared code. By using the shared-library function, you’re not duplicating code—either on disk or in memory. This is the DRY principle at work.</p>&#13;
<p class="indent">Another reason is to exercise the interface you’re providing for users of your shared library. You’ll catch bugs in your public interfaces more quickly if your project code uses your shared libraries exactly the way you expect other programs to use them.</p>&#13;
<p class="indent">In this situation, you might now consider simply moving the code from the static library into the shared library, thereby removing the need for the static library entirely. However, I’m going to beg your indulgence with my contrived example. In a more complex project, I might very well <span epub:type="pagebreak" id="page_197"/>have a need for this sort of configuration. Common code is often gathered together into static convenience libraries, and more often than not, only a portion of this common code is reused in shared libraries. I’m going to leave it the way it is here for the sake of its educational value.</p>&#13;
<h4 class="h4" id="ch07sec5-4"><em>Reconfigure and Build</em></h4>&#13;
<p class="noindent">Since we’ve added Libtool—a major new component—to our project build system, we’ll add the <code>-i</code> option to the <code>autoreconf</code> command line to ensure that all of the proper auxiliary files are installed into the project root directory:</p>&#13;
<pre>   $ <span class="codestrong1">autoreconf -i</span>&#13;
<span class="ent">➊</span> libtoolize: putting auxiliary files in '.'.&#13;
   libtoolize: copying file './ltmain.sh'&#13;
   libtoolize: Consider adding 'AC_CONFIG_MACRO_DIRS([m4])' to configure.ac,&#13;
   libtoolize: and rerunning libtoolize and aclocal.&#13;
   libtoolize: Consider adding '-I m4' to ACLOCAL_AMFLAGS in Makefile.am.&#13;
   configure.ac:8: installing './compile'&#13;
<span class="ent">➋</span> configure.ac:8: installing './config.guess'&#13;
   configure.ac:8: installing './config.sub'&#13;
   configure.ac:6: installing './install-sh'&#13;
   configure.ac:6: installing './missing'&#13;
   Makefile.am: installing './INSTALL'&#13;
   Makefile.am: installing './COPYING' using GNU General Public License v3 file&#13;
   Makefile.am:     Consider adding the COPYING file to the version control system&#13;
   Makefile.am:     for your code, to avoid questions about which license your&#13;
   project uses&#13;
   common/Makefile.am: installing './depcomp'&#13;
   parallel-tests: installing './test-driver'&#13;
   $</pre>&#13;
<p class="indent">Because we completely removed all generated and copied files from our project directory, most of these notifications have to do with replacing files we’ve already discussed. However, there are a few noteworthy exceptions.</p>&#13;
<p class="indent">First, notice the comments from <code>libtoolize</code> at <span class="ent">➊</span>. Most of them are simply suggesting that we move to the new Autotools convention of adding M4 macro files to a directory called <em>m4</em> in the project root directory. We’re going to ignore these comments for now, but in <a href="ch14.xhtml">Chapters 14</a> and <a href="ch15.xhtml">15</a>, we’ll actually do this for a real project.</p>&#13;
<p class="indent">As you can see at <span class="ent">➋</span>, it appears that the addition of Libtool has caused a few new files to be added to our project—namely, the <em>config.guess</em> and <em>config.sub</em> files. Another new file was added in the section at <span class="ent">➊</span> called <em>ltmain.sh</em>. The <code>configure</code> script uses <em>ltmain.sh</em> to build a project-specific version of <code>libtool</code> for the Jupiter project. I’ll describe the <code>config.guess</code> and <code>config.sub</code> scripts later.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_198"/>Let’s go ahead and execute <code>configure</code> and see what happens:</p>&#13;
<pre>$ <span class="codestrong1">./configure</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking for ld used by gcc... /usr/bin/ld&#13;
checking if the linker (/usr/bin/ld) is GNU ld... yes&#13;
checking for BSD- or MS-compatible name lister (nm)... /usr/bin/nm -B&#13;
checking the name lister (/usr/bin/nm -B) interface... BSD nm&#13;
checking whether ln -s works... yes&#13;
checking the maximum length of command line arguments... 1572864&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking for shl_load... no&#13;
checking for shl_load in -ldld... no&#13;
checking for dlopen... no&#13;
checking for dlopen in -ldl... yes&#13;
checking whether a program can dlopen itself... yes&#13;
checking whether a statically linked program can dlopen itself... no&#13;
checking whether stripping libraries is possible... yes&#13;
checking if libtool supports shared libraries... yes&#13;
checking whether to build shared libraries... yes&#13;
checking whether to build static libraries... yes&#13;
<span class="codeitalic1">--snip--</span>&#13;
configure: creating ./config.status&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">The first thing to note is that Libtool adds <em>significant</em> overhead to the configuration process. I’ve only shown a few of the output lines here that are new since we added Libtool. All we’ve added to the <em>configure.ac</em> file is the reference to the <code>LT_INIT</code> macro, but we’ve nearly doubled our <code>configure</code> output. This should give you some idea of the number of system characteristics that must be examined to create portable shared libraries. Fortunately, Libtool does a lot of the work for you.</p>&#13;
<p class="indent">Now, let’s run the <code>make</code> command and see what sort of output we get:</p>&#13;
<pre>   $ <span class="codestrong1">make</span>&#13;
   <span class="codeitalic1a">--snip--</span>&#13;
   <span class="ash">Making all in libjup</span>&#13;
   <span class="ash">make[2]: Entering directory '/.../jupiter/libjup'</span>&#13;
<span class="ent">➊</span> /bin/bash ../libtool    --tag=CC     --mode=compile <span class="ash">gcc -DHAVE_CONFIG_H -I. -I..</span>&#13;
   <span class="ash">-I../include -I../common     -g -O2 -MT libjupiter_la-jup_print.lo -MD -MP -MF</span>&#13;
   <span class="ash">.deps/libjupiter_la-jup_print.Tpo -c -o libjupiter_la-jup_print.lo `test -f</span>&#13;
   <span class="ash">'jup_print.c' || echo './'`jup_print.c</span>&#13;
<span class="ent">➋</span> libtool: compile:    <span class="ash">gcc -DHAVE_CONFIG_H -I. -I.. -I../include -I../common -g</span>&#13;
   <span class="ash">-O2 -MT libjupiter_la-jup_print.lo -MD -MP -MF .deps/libjupiter_la-jup_print.Tpo -c jup_print.c    -fPIC -DPIC -o .libs/libjupiter_la-jup_print.o</span>&#13;
<span class="ent">➌</span> libtool: compile:    <span class="ash">gcc -DHAVE_CONFIG_H -I. -I.. -I../include -I../common -g</span>&#13;
   <span class="ash">-O2 -MT libjupiter_la-jup_print.lo -MD -MP -MF .deps/libjupiter_la-jup_print.</span>&#13;
   <span class="ash">Tpo -c jup_print.c -o libjupiter_la-jup_print.o &gt;/dev/null 2&gt;&amp;1</span>&#13;
<span class="ent">➍</span> mv -f .deps/libjupiter_la-jup_print.Tpo .deps/libjupiter_la-jup_print.Plo&#13;
<span class="ent">➎</span> /bin/bash ../libtool    --tag=CC     --mode=link gcc    -g -O2     -o libjupiter.la&#13;
   -rpath /usr/local/lib libjupiter_la-jup_print.lo ../common/libjupcommon.a&#13;
   -lpthread&#13;
<span epub:type="pagebreak" id="page_199"/><span class="ent">➏</span> *** Warning: Linking the shared library libjupiter.la against the&#13;
   *** static library ../common/libjupcommon.a is not portable!&#13;
   <span class="ash">libtool: link: gcc -shared    -fPIC -DPIC    .libs/libjupiter_la-jup_print.o     ../</span>&#13;
   <span class="ash">common/libjupcommon.a -lpthread    -g -O2     -Wl,-soname -Wl,libjupiter.so.0 -o</span>&#13;
   <span class="ash">.libs/libjupiter.so.0.0.0</span>&#13;
<span class="ent">➐</span> <span class="ash">/usr/bin/ld: ../common/libjupcommon.a(print.o): relocation R_X86_64_32 against</span>&#13;
   <span class="ash">`.rodata.str1.1' can not be used when making a shared object;</span> recompile with&#13;
   -fPIC&#13;
   <span class="ash">../common/libjupcommon.a: error adding symbols: Bad value</span>&#13;
   <span class="ash">collect2: error: ld returned 1 exit status</span>&#13;
   <span class="ash">Makefile:389: recipe for target 'libjupiter.la' failed</span>&#13;
   <span class="ash">make[2]: *** [libjupiter.la] Error 1</span>&#13;
   <span class="ash">make[2]: Leaving directory '/.../jupiter/libjup'</span>&#13;
   <span class="ash">Makefile:391: recipe for target 'all-recursive' failed</span>&#13;
   <span class="ash">make[1]: *** [all-recursive] Error 1</span>&#13;
   <span class="ash">make[1]: Leaving directory '/.../jupiter'</span>&#13;
   <span class="ash">Makefile:323: recipe for target 'all' failed</span>&#13;
   <span class="ash">make: *** [all] Error 2</span>&#13;
   <span class="codeitalic1a">--</span><span class="codeitalic1a">snip--</span>&#13;
   $</pre>&#13;
<p class="indent">We seem to have some errors to fix. The first point of interest is that <code>libtool</code> is being executed at <span class="ent">➊</span> with a <code>--mode=compile</code> option, which causes <code>libtool</code> to act as a wrapper script around a somewhat modified version of a standard <code>gcc</code> command line. You can see the effects of this statement in the next two compiler command lines at <span class="ent">➋</span> and <span class="ent">➌</span>. <em>Two compiler commands?</em> That’s right. It appears that <code>libtool</code> is running the compiler twice against our source file.</p>&#13;
<p class="indent">A careful comparison of these two command lines shows that the first command is using two additional flags, <code>-fPIC</code> and <code>-DPIC</code>. The first line also appears to be directing the output file to a <em>.libs</em> subdirectory, whereas the second line is saving it in the current directory. Finally, both the <code>stdout</code> and <code>stderr</code> output streams are redirected to <em>/dev/null</em> in the second line.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Occasionally, you may run into a situation where a source file compiles fine in the first compilation but fails in the second due to a PIC-related source code error. These sorts of problems are rare, but they can be a real pain when they occur because <em><code>make</code></em> halts the build with an error but doesn’t give you any error messages to explain the problem! When you see this situation, simply pass the <em><code>-no-suppress</code></em> flag in the <em><code>CFLAGS</code></em> variable on the <em><code>make</code></em> command line in order to tell Libtool not to redirect output from the second compilation to</em> /dev/null.</p>&#13;
</div>&#13;
<p class="indent">This double-compile feature has caused a fair amount of anxiety on the Libtool mailing list over the years. Mostly, this is due to a lack of understanding of what Libtool is trying to do and why it’s necessary. Using Libtool’s various <code>configure</code> script command line options, you can force a single compilation, but doing so brings a certain loss of functionality, which I’ll explain here shortly.</p>&#13;
<p class="indent">The line at <span class="ent">➍</span> renames the dependency file from <em>*.Tpo</em> to <em>*.Plo</em>. You might recall from <a href="ch03.xhtml">Chapters 3</a> and <a href="ch06.xhtml">6</a> that dependency files contain <code>make</code> rules that <span epub:type="pagebreak" id="page_200"/>declare dependencies between source files and referenced header files. The C preprocessor generates these rules when you use the <code>-MT</code> compiler option. However, the overarching concept to understand here is that one Libtool command may (and often does) execute a group of shell commands.</p>&#13;
<p class="indent">The line at <span class="ent">➎</span> is another call to the <code>libtool</code> script, this time using the <code>--mode=link</code> option. This option generates a call to execute the compiler in <em>link mode</em>, passing all of the libraries and linker options specified in the <em>Makefile.am</em> file.</p>&#13;
<p class="indent">At <span class="ent">➏</span>, we come to the first problem—a portability warning about linking a shared library against a static library. Specifically, this warning is about linking a Libtool shared library against a non-Libtool static library. Notice that this is not an error. Were it not for additional errors we’ll encounter later, the library would be built in spite of this warning.</p>&#13;
<p class="indent">After the portability warning, <code>libtool</code> attempts to link the requested objects together into a shared library named <em>libjupiter.so.0.0.0</em> . But here the script runs into the real problem: at <span class="ent">➐</span>, a linker error indicates that somewhere from within <em>libjupcommon.a</em>—and more specifically, within <em>print.o</em>—an <code>x86_64</code> object relocation cannot be performed because the original source file (<em>print.c</em>) was apparently not compiled correctly. The linker is kind enough to tell us exactly what we need to do to fix the problem (highlighted in the example): we need to compile the source code using a <code>-fPIC</code> compiler option.</p>&#13;
<p class="indent">Now, if you were to encounter this error and didn’t know anything about the <code>-fPIC</code> option, you’d be wise to open the man page for <code>gcc</code> and study it before inserting compiler and linker options willy-nilly until the warning or error disappears (unfortunately, a common practice of inexperienced programmers). Software engineers should understand the meaning and nuances of every command line option used by the tools in their build systems. Otherwise, they don’t really know what they have when their build completes. It may work the way it should, but if it does, it’s by luck rather than by design. Good engineers know their tools, and the best way to learn is to study error messages and their fixes until the problem is well understood, before moving on.</p>&#13;
<h4 class="h4" id="ch07sec5-5"><em>So What Is PIC, Anyway?</em></h4>&#13;
<p class="noindent">When operating systems create new process address spaces, they typically load program-executable images at the same memory address. This magic address is system specific. Compilers and linkers understand this, and they know what the magic address is on any given system. Therefore, when they generate internal references to function calls or global data, they can generate those references as <em>absolute</em> addresses. If you were somehow able to load the executable at a different location in the process virtual address space, it would simply not work properly because the absolute addresses within the code would not be correct. At the very least, the program would crash when the processor jumped to the wrong location during a function call.</p>&#13;
<p class="indent">Consider <a href="ch07.xhtml#ch07fig1">Figure 7-1</a> for a moment. Assume we have a system whose magic executable load address is <code>0x10000000</code>; this diagram depicts two process address spaces within that system. In the process on the left, an <span epub:type="pagebreak" id="page_201"/>executable image is loaded correctly at address <code>0x10000000</code>. At some point in the code, a <code>jmp</code> instruction tells the processor to transfer control to the absolute address <code>0x10001000</code>, where it continues executing instructions in another area of the program.</p>&#13;
<div class="image"><img src="../images/07fig01.jpg" alt="Image"/></div>&#13;
<p class="caption" id="ch07fig1"><em>Figure 7-1: Absolute addressing in executable images</em></p>&#13;
<p class="indent">In the process on the right, the program is loaded incorrectly at address <code>0x20000000</code>. When that same branch instruction is encountered, the processor jumps to address <code>0x10001000</code> because that address is hardcoded into the program image. This, of course, fails—often spectacularly by crashing, but sometimes with more subtle and dastardly ramifications.</p>&#13;
<p class="indent">That’s how things work for program images. However, when a <em>shared library</em> is built for certain types of hardware (AMD64 included), neither the compiler nor the linker knows beforehand where the library will be loaded. This is because many libraries may be loaded into a process and the order in which they are loaded depends on how the <em>executable</em> is built, not the library. Furthermore, who’s to say which library owns location A and which one owns location B? The fact is, a library may be loaded <em>anywhere</em> into the process address space where there is space for it at the time it’s loaded. Only the operating system loader knows where it will finally reside—and even then, it only knows just before the library is actually loaded.<sup><a id="ch07fn_12" href="footnote.xhtml#ch07fn12">12</a></sup></p>&#13;
<p class="indent">As a result, shared libraries can only be built from a special class of object files called PIC objects. <em>PIC</em> is an acronym that stands for <span epub:type="pagebreak" id="page_202"/><em>position-independent code</em>, and it implies that references within the object code are not absolute but <em>relative</em>. When you use the <code>-fPIC</code> option on the compiler command line, the compiler will use somewhat less efficient relative addressing in branching instructions. Such position-independent code may be loaded anywhere.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig2">Figure 7-2</a> depicts the concept of relative addressing as used when generating PIC objects. With relative addressing, addresses work correctly regardless of where the image is loaded because they’re always encoded relative to the current instruction pointer. In <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>, the diagrams indicate a shared library loaded at the same addresses as those in <a href="ch07.xhtml#ch07fig1">Figure 7-1</a> (that is, <code>0x10000000</code> and <code>0x20000000</code>). In both cases, the dollar sign used in the <code>jmp</code> instruction represents the current instruction pointer (<code>IP</code>), so <code>$ + 0xC74</code> tells the processor that it should jump to the instruction starting <code>0xC74</code> bytes ahead of the current position of the instruction pointer.</p>&#13;
<div class="image"><img src="../images/07fig02.jpg" alt="Image"/></div>&#13;
<p class="caption" id="ch07fig2"><em>Figure 7-2: Relative addressing in shared-library images</em></p>&#13;
<p class="indent">There are various nuances to generating and using position-independent code, and you should become familiar with all of them before using them so you can choose the option that is most appropriate for your situation. For example, the GNU C compiler also supports a <code>-fpic</code> option (lowercase), which uses a slightly quicker but more limited mechanism to generate relocatable object code.<sup><a id="ch07fn_13" href="footnote.xhtml#ch07fn13">13</a></sup></p>&#13;
<h4 class="h4" id="ch07sec5-6"><span epub:type="pagebreak" id="page_203"/><em>Fixing the Jupiter PIC Problem</em></h4>&#13;
<p class="noindent">From what we now understand, one way to fix our linker error is to add the <code>-fPIC</code> option to the compiler command line for the source files that comprise the <em>libjupcommon.a</em> static library. <a href="ch07.xhtml#ch07ex8">Listing 7-8</a> illustrates the changes required to the <em>common/Makefile.am</em> file.</p>&#13;
<pre><span class="ash">noinst_LIBRARIES = libjupcommon.a</span>&#13;
<span class="ash">libjupcommon_a_SOURCES = jupcommon.h print.c</span>&#13;
libjupcommon_a_CFLAGS = -fPIC</pre>&#13;
<p class="caption" id="ch07ex8"><em>Listing 7-8:</em> common/Makefile.am: <em>Changes required for generation of PIC objects in a static library</em></p>&#13;
<p class="indent">And now let’s retry the build:</p>&#13;
<pre>   $ <span class="codestrong1">autoreconf</span>&#13;
   $ <span class="codestrong1">./configure</span>&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   $ <span class="codestrong1">make</span>&#13;
   <span class="ash">make    all-recursive</span>&#13;
   <span class="ash">make[1]: Entering directory '/.../jupiter'</span>&#13;
   <span class="ash">Making all in common</span>&#13;
   <span class="ash">make[2]: Entering directory '/.../jupiter/common'</span>&#13;
   <span class="ash">gcc -DHAVE_CONFIG_H -I. -I..</span>        -fPIC <span class="ash">-g -O2 -MT libjupcommon_a-print.o -MD</span>&#13;
   <span class="ash">-MP -MF .deps/libjupcommon_a-print.Tpo -c -o libjupcommon_a-print.o `test -f</span>&#13;
   <span class="ash">'print.c' || echo './'`print.c</span>&#13;
   <span class="codeitalic1a">--snip--</span>&#13;
   Making all in libjup&#13;
   make[2]: Entering directory '/.../jupiter/libjup'&#13;
   /bin/bash ../libtool    --tag=CC     --mode=link gcc    -g -O2     -o libjupiter.&#13;
   la -rpath /usr/local/lib libjupiter_la-jup_print.lo ../common/libjupcommon.a&#13;
   -lpthread&#13;
&#13;
<span class="ent">➊</span> *** Warning: Linking the shared library libjupiter.la against the&#13;
   *** static library ../common/libjupcommon.a is not portable!&#13;
   libtool: link: gcc -shared    -fPIC -DPIC    .libs/libjupiter_la-jup_print.o&#13;
   ../common/libjupcommon.a -lpthread    -g -O2     -Wl,-soname -Wl,libjupiter.so.0&#13;
   -o .libs/libjupiter.so.0.0.0&#13;
   libtool: link: (cd ".libs" &amp;&amp; rm -f "libjupiter.so.0" &amp;&amp; ln -s "libjupiter&#13;
   .so.0.0.0" "libjupiter.so.0")&#13;
   libtool: link: (cd ".libs" &amp;&amp; rm -f "libjupiter.so" &amp;&amp; ln -s "libjupiter&#13;
   .so.0.0.0" "libjupiter.so")&#13;
   libtool: link: ar cru .libs/libjupiter.a ../common/libjupcommon.a    libjupiter&#13;
   _la-jup_print.o&#13;
   ar: `u' modifier ignored since `D' is the default (see `U')&#13;
   libtool: link: ranlib .libs/libjupiter.a&#13;
   libtool: link: ( cd ".libs" &amp;&amp; rm -f "libjupiter.la" &amp;&amp; ln -s "../libjupiter&#13;
   .la" "libjupiter.la" )&#13;
   make[2]: Leaving directory&#13;
   <span class="codeitalic1">--snip</span><span class="codeitalic1">--</span>&#13;
   $</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_204"/>We now have a shared library built properly with position-independent code, as per system requirements. However, we still have that strange warning at <span class="ent">➊</span> about the portability of linking a Libtool library against a static library. The problem here is not in <em>what</em> we’re doing but rather <em>how</em> we’re doing it. You see, the concept of PIC does not apply to all hardware architectures. Some CPUs don’t support any form of absolute addressing in their instruction sets. As a result, native compilers for these platforms don’t support a <code>-fPIC</code> option—it has no meaning for them. Unknown options may be silently ignored, but in most cases, compilers stop on unknown options with an error message.</p>&#13;
<p class="indent">If we tried, for example, to compile this code on an IBM RS/6000 system using the native IBM compiler, it would hiccup when it came to the <code>-fPIC</code> option on the linker command line. This is because it doesn’t make sense to support such an option on a system where all code is generated as position-independent code.</p>&#13;
<p class="indent">One way we could get around this problem would be to make the <code>-fPIC</code> option conditional in <em>Makefile.am</em>, based on the target system and the tools we’re using. But that’s exactly the sort of problem that Libtool was designed to address! We’d have to account for all the different Libtool target system types and tool sets in order to handle the entire set of conditions that Libtool already handles. Additionally, some systems and compilers may require different command line options to accomplish the same goal.</p>&#13;
<p class="indent">The way around this portability problem, then, is to let Libtool generate the static library, as well. Libtool makes a distinction between static libraries that are installed as part of a developer package and static libraries that are only used internally within a project. It calls such internal static libraries <em>convenience</em> libraries, and whether or not a convenience library is generated depends on the prefix used with the <code>LTLIBRARIES</code> primary. If the <code>noinst</code> prefix is used, then Libtool assumes we want a convenience library, because there’s no point in generating a shared library that will never be installed. Thus, convenience libraries are always generated as non-installed static archives, which have no value unless they’re linked to other code within the project.</p>&#13;
<p class="indent">The reason for distinguishing between convenience libraries and other forms of static libraries is that convenience libraries are always built, whereas installed static libraries are only built if the <code>--enable-static</code> option is specified on the <code>configure</code> command line—or, conversely, if the <code>--disable-static</code> option is <em>not</em> specified and the default library type has been set to <code>static</code>. The conversion from an older static library to a newer Libtool convenience library is simple enough—all we have to do is add <code>LT</code> to the primary name and remove the <code>-fPIC</code> option and the <code>CFLAGS</code> variable (since there were no other options being used in that variable). Note also that I’ve changed the library extension from <em>.a</em> to <em>.la</em>. Don’t forget to change the prefix on the <code>SOURCES</code> variable to reflect the new name of the library—<em>libjupcommon.la</em>. These changes are highlighted in <a href="ch07.xhtml#ch07ex9">Listings 7-9</a> and <a href="ch07.xhtml#ch07ex10">7-10</a>.</p>&#13;
<p class="margin">Git tag 7.1</p>&#13;
<pre><span epub:type="pagebreak" id="page_205"/><span class="ash">noinst_</span>LT<span class="ash">LIBRARIES = libjupcommon.</span>l<span class="ash">a</span>&#13;
<span class="ash">libjupcommon_</span>l<span class="ash">a_SOURCES = jupcommon.h print.c</span></pre>&#13;
<p class="caption" id="ch07ex9"><em>Listing 7-9:</em> common/Makefile.am: <em>Changing from a static library to a Libtool static library</em></p>&#13;
<pre><span class="ash">lib_LTLIBRARIES = libjupiter.la</span>&#13;
<span class="ash">libjupiter_la_SOURCES = jup_print.c</span>&#13;
<span class="ash">libjupiter_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/common</span>&#13;
<span class="ash">libjupiter_la_LIBADD = ../common/libjupcommon.</span>l<span class="ash">a</span></pre>&#13;
<p class="caption" id="ch07ex10"><em>Listing 7-10:</em> libjup/Makefile.am: <em>Changing from a static library to a Libtool static library</em></p>&#13;
<p class="indent">Now when we try to build, here’s what we get:</p>&#13;
<pre>   $ <span class="codestrong1">make</span>&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   Making all in libjup&#13;
   make[2]: Entering directory '/.../jupiter/libjup'&#13;
<span class="ent">➊</span> /bin/bash ../libtool   --tag=CC   --mode=compile gcc -DHAVE_CONFIG_H -I. -I..&#13;
   -I../include -I../common    -g -O2 -MT libjupiter_la-jup_print.lo -MD -MP -MF&#13;
   .deps/libjupiter_la-jup_print.Tpo -c -o libjupiter_la-jup_print.lo `test -f&#13;
   'jup_print.c' || echo './'`jup_print.c&#13;
   libtool: compile:  gcc -DHAVE_CONFIG_H -I. -I.. -I../include -I../common -g&#13;
   -O2 -MT libjupiter_la-jup_print.lo -MD -MP -MF .deps/libjupiter_la-jup_print.&#13;
   Tpo -c jup_print.c  -fPIC -DPIC -o .libs/libjupiter_la-jup_print.o&#13;
   libtool: compile:  gcc -DHAVE_CONFIG_H -I. -I.. -I../include -I../common -g&#13;
   -O2 -MT libjupiter_la-jup_print.lo -MD -MP -MF .deps/libjupiter_la-jup_print.&#13;
   Tpo -c jup_print.c -o libjupiter_la-jup_print.o &gt;/dev/null 2&gt;&amp;1&#13;
   mv -f .deps/libjupiter_la-jup_print.Tpo .deps/libjupiter_la-jup_print.Plo&#13;
   /bin/bash ../libtool  --tag=CC   --mode=link gcc  -g -O2   -o libjupiter.la&#13;
   -rpath /usr/local/lib libjupiter_la-jup_print.lo ../common/libjupcommon.la&#13;
   -lpthread&#13;
   libtool: link: gcc -shared  -fPIC -DPIC  .libs/libjupiter_la-jup_print.o&#13;
   -Wl,--whole-archive ../common/.libs/libjupcommon.a -Wl,--no-whole-archive&#13;
   -lpthread  -g -O2   -Wl,-soname -Wl,libjupiter.so.0 -o .libs/libjupiter.&#13;
   so.0.0.0&#13;
   libtool: link: (cd ".libs" &amp;&amp; rm -f "libjupiter.so.0" &amp;&amp; ln -s "libjupiter.&#13;
   so.0.0.0" "libjupiter.so.0")&#13;
   libtool: link: (cd ".libs" &amp;&amp; rm -f "libjupiter.so" &amp;&amp; ln -s "libjupiter.&#13;
   so.0.0.0" "libjupiter.so")&#13;
   libtool: link: (cd .libs/libjupiter.lax/libjupcommon.a &amp;&amp; ar x "/.../jupiter/&#13;
   libjup/../common/.libs/libjupcommon.a")&#13;
<span class="ent">➋</span> libtool: link: ar cru .libs/libjupiter.a  libjupiter_la-jup_print.o&#13;
   .libs/libjupiter.lax/libjupcommon.a/print.o&#13;
   ar: `u' modifier ignored since `D' is the default (see `U')&#13;
   libtool: link: ranlib .libs/libjupiter.a&#13;
   libtool: link: rm -fr .libs/libjupiter.lax&#13;
   libtool: link: ( cd ".libs" &amp;&amp; rm -f "libjupiter.la" &amp;&amp; ln -s "../libjupiter.&#13;
   la" "libjupiter.la" )&#13;
   make[2]: Leaving directory '/.../jupiter/libjup'&#13;
   <span class="codeitalic1">--snip</span><span class="codeitalic1">--</span>&#13;
   $</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>You can see at <span class="ent">➋</span> that the common library is now built as a static convenience library because the <code>ar</code> utility builds <em>libjupcommon.a</em>. Libtool also seems to be building files with new and different extensions—a closer look will reveal extensions such as <em>.la</em> and <em>.lo</em> (check the line at <span class="ent">➊</span>). If you examine these files, you’ll find that they’re actually descriptive text files containing object and library metadata. <a href="ch07.xhtml#ch07ex11">Listing 7-11</a> shows the partial contents of <em>common/libjupcommon.la</em>.</p>&#13;
<pre>   # libjupcommon.la - a libtool library fil e&#13;
   # Generated by libtool (GNU libtool) 2.4.6 Debian-2.4.6-0.1&#13;
   #&#13;
   # Please DO NOT delete this file!&#13;
   # It is necessary for linking the library.&#13;
&#13;
   # The name that we can dlopen(3).&#13;
   dlname=''&#13;
&#13;
   # Names of this library.&#13;
<span class="ent">➊</span> library_names=''&#13;
&#13;
   # The name of the static archive.&#13;
<span class="ent">➋</span> old_library='libjupcommon.a'&#13;
&#13;
   # Linker flags that cannot go in dependency_libs.&#13;
   inherited_linker_flags=''&#13;
&#13;
   # Libraries that this one depends upon.&#13;
<span class="ent">➌</span> dependency_libs=' -lpthread'&#13;
   <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch07ex11"><em>Listing 7-11:</em> common/libjupcommon.la: <em>Textual metadata found in a library archive</em> (.la ) <em>file</em></p>&#13;
<p class="indent">The various fields in these files help the linker—or rather the <code>libtool</code> wrapper script—to determine certain options that the maintainer would otherwise have to remember and manually pass to the linker on the command line. For instance, the library’s shared and static names are documented at <span class="ent">➊</span> and <span class="ent">➋</span> here, as well as any library dependencies required by these libraries (at <span class="ent">➌</span>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This is a convenience library, so the shared library name is empty</em>.</p>&#13;
</div>&#13;
<p class="indent">In this library, we can see that <em>libjupcommon.a</em> depends on the <em>pthreads</em> library. But, by using Libtool, we don’t have to pass a <code>-lpthread</code> option on the <code>libtool</code> command line because <code>libtool</code> can detect from the contents of this metadata file (specifically, the line at <span class="ent">➌</span>) that the linker will need this option, and it passes the option for us.</p>&#13;
<p class="indent">Making these files human readable was a minor stroke of genius, as they can tell us a lot about Libtool libraries at a glance. These files are designed to be installed on an end user’s machine with their associated binaries, and, in fact, the <code>make install</code> rules that Automake generates for Libtool libraries do just this.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_207"/>Most Linux distros today are leaning toward filtering out <em>.la</em> files from official builds of library projects—that is, they don’t install them into the <em>/usr</em> directory structure because <em>.la</em> files are only useful during builds where packages are referencing Libtool libraries within a project directory structure. Since the distro provider has already pre-built everything for you and you won’t be building those packages yourself, they just take up space (albeit, not very much). When you link against a library (Libtool or otherwise) that’s installed on your system in the <em>/usr</em> directory structure, you’re using one of the <code>AC_CHECK</code>/<code>SEARCH</code> macros to find the library and link against the <em>.a</em> or <em>.so</em> file directly, so the <em>.la</em> file isn’t used in that case either.</p>&#13;
<h3 class="h3" id="ch07sec6">Summary</h3>&#13;
<p class="noindent">In this chapter, I outlined the basic rationale for shared libraries. As an exercise, we added a shared library to Jupiter that incorporates functionality from the convenience library we created earlier. We began with a more or less intuitive approach to incorporating a static library into a Libtool shared library, and in the process we discovered a more portable and correct way to do this using Libtool convenience libraries.</p>&#13;
<p class="indent">As with the other packages in the Autotools toolchain, Libtool gives you a lot of functionality and flexibility. But as you’ve probably noticed, with this degree of functionality and flexibility comes a price—complexity. The size of Jupiter’s configuration script increased dramatically with the addition of Libtool, and the time required to compile and link our project increased accordingly.</p>&#13;
<p class="indent">In the next chapter, we’re going to continue our discussion of Libtool by looking at library-versioning issues and Libtool’s solution to the portability problems presented by manual dynamic runtime library management.</p>&#13;
</body></html>