["```\nboost::scoped_ptr<PointedToType> my_ptr{ new PointedToType };\n```", "```\n#define CATCH_CONFIG_MAIN ➊\n#include \"catch.hpp\" ➋\n#include <boost/smart_ptr/scoped_ptr.hpp> ➌\n\nstruct DeadMenOfDunharrow { ➍\n  DeadMenOfDunharrow(const char* m=\"\") ➎\n    : message{ m } {\n    oaths_to_fulfill++; ➏\n  }\n  ~DeadMenOfDunharrow() {\n    oaths_to_fulfill--; ➐\n  }\n  const char* message;\n  static int oaths_to_fulfill;\n};\nint DeadMenOfDunharrow::oaths_to_fulfill{};\nusing ScopedOathbreakers = boost::scoped_ptr<DeadMenOfDunharrow>; ➑\n```", "```\n#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n```", "```\nTEST_CASE(\"ScopedPtr evaluates to\") {\n  SECTION(\"true when full\") {\n    ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; ➊\n    REQUIRE(aragorn); ➋\n  }\n  SECTION(\"false when empty\") {\n    ScopedOathbreakers aragorn; ➌\n    REQUIRE_FALSE(aragorn); ➍\n  }\n}\n```", "```\nTEST_CASE(\"ScopedPtr is an RAII wrapper.\") {\n  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 0); ➊\n  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; ➋\n  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➌\n  {\n    ScopedOathbreakers legolas{ new DeadMenOfDunharrow{} }; ➍\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); ➎\n  } ➏\n  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➐\n}\n```", "```\nTEST_CASE(\"ScopedPtr supports pointer semantics, like\") {\n  auto message = \"The way is shut\";\n  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{ message } }; ➊\n  SECTION(\"operator*\") {\n    REQUIRE((*aragorn).message == message); ➋\n  }\n  SECTION(\"operator->\") {\n    REQUIRE(aragorn->message == message); ➌\n  }\n  SECTION(\"get(), which returns a raw pointer\") {\n    REQUIRE(aragorn.get() != nullptr); ➍\n  }\n}\n```", "```\nTEST_CASE(\"ScopedPtr supports comparison with nullptr\") {\n  SECTION(\"operator==\") {\n    ScopedOathbreakers legolas{};\n    REQUIRE(legolas == nullptr); ➊\n  }\n  SECTION(\"operator!=\") {\n    ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} };\n    REQUIRE(aragorn != nullptr); ➋\n  }\n}\n```", "```\nTEST_CASE(\"ScopedPtr supports swap\") {\n  auto message1 = \"The way is shut.\";\n  auto message2 = \"Until the time comes.\";\n  ScopedOathbreakers aragorn {\n    new DeadMenOfDunharrow{ message1 } ➊\n  };\n  ScopedOathbreakers legolas {\n    new DeadMenOfDunharrow{ message2 } ➋\n  };\n  aragorn.swap(legolas); ➌\n  REQUIRE(legolas->message == message1); ➍\n  REQUIRE(aragorn->message == message2); ➎\n}\n```", "```\nTEST_CASE(\"ScopedPtr reset\") {\n  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; ➊\n  SECTION(\"destructs owned object.\") {\n    aragorn.reset(); ➋\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 0); ➌\n  }\n  SECTION(\"can replace an owned object.\") {\n    auto message = \"It was made by those who are Dead.\";\n    auto new_dead_men = new DeadMenOfDunharrow{ message }; ➍\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); ➎\n    aragorn.reset(new_dead_men); ➏\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➐\n    REQUIRE(aragorn->message == new_dead_men->message); ➑\n    REQUIRE(aragorn.get() == new_dead_men); ➒\n  }\n}\n```", "```\nvoid by_ref(const ScopedOathbreakers&) { } ➊\nvoid by_val(ScopedOathbreakers) { } ➋\n\nTEST_CASE(\"ScopedPtr can\") {\n  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow };\n  SECTION(\"be passed by reference\") {\n    by_ref(aragorn); ➌\n  }\n  SECTION(\"not be copied\") {\n    // DOES NOT COMPILE:\n    by_val(aragorn); ➍\n    auto son_of_arathorn = aragorn; ➐\n  }\n  SECTION(\"not be moved\") {\n    // DOES NOT COMPILE:\n    by_val(std::move(aragorn)); ➏\n    auto son_of_arathorn = std::move(aragorn); ➐\n  }\n}\n```", "```\nTEST_CASE(\"ScopedArray supports operator[]\") {\n  boost::scoped_array<int➊> squares{\n    new int➋[5] { 0, 4, 9, 16, 25 }\n  };\n  squares[0] = 1; ➌\n  REQUIRE(squares[0] == 1); ➍\n REQUIRE(squares[1] == 4);\n  REQUIRE(squares[2] == 9);\n}\n```", "```\nstd::unique_ptr<int> my_ptr{ new int{ 808 } };\n```", "```\nauto my_ptr = make_unique<int>(808);\n```", "```\nusing UniqueOathbreakers = std::unique_ptr<DeadMenOfDunharrow>;\n```", "```\nTEST_CASE(\"UniquePtr can be used in move\") {\n  auto aragorn = std::make_unique<DeadMenOfDunharrow>(); ➊\n  SECTION(\"construction\") {\n    auto son_of_arathorn{ std::move(aragorn) }; ➋\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➌\n  }\n  SECTION(\"assignment\") {\n    auto son_of_arathorn = std::make_unique<DeadMenOfDunharrow>(); ➍\n REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); ➎\n    son_of_arathorn = std::move(aragorn); ➏\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➐\n  }\n}\n```", "```\nTEST_CASE(\"UniquePtr to array supports operator[]\") {\n  std::unique_ptr<int[]➊> squares{\n    new int[5]{ 1, 4, 9, 16, 25 } ➋\n  };\n  squares[0] = 1; ➌\n  REQUIRE(squares[0] == 1); ➍\n  REQUIRE(squares[1] == 4);\n  REQUIRE(squares[2] == 9);\n}\n```", "```\nstd::unique_ptr<T, Deleter=std::default_delete<T>>\n```", "```\n#include <cstdio>\n\nauto my_deleter = [](int* x) { ➊\n  printf(\"Deleting an int at %p.\", x);\n  delete x;\n};\nstd::unique_ptr<int➋, decltype(my_deleter)➌> my_up{\n  new int,\n  my_deleter\n};\n```", "```\nFILE*➊ fopen(const char *filename➋, const char *mode➌);\n```", "```\nvoid fclose(FILE* file);\n```", "```\nint➊ fprintf(FILE* file➋, const char* format_string➌, ...➍);\n```", "```\n#include <cstdio>\n#include <memory>\n\nusing FileGuard = std::unique_ptr<FILE, int(*)(FILE*)>; ➊\n\nvoid say_hello(FileGuard file➋) {\n  fprintf(file.get(), \"HELLO DAVE\"); ➌\n}\n\nint main() {\n  auto file = fopen(\"HAL9000\", \"w\"); ➍\n  if (!file) return errno; ➎\n  FileGuard file_guard{ file, fclose }; ➏\n  // File open here\n  say_hello(std::move(file_guard)); ➐\n  // File closed here\n  return 0;\n}\n```", "```\nstd::shared_ptr<int> my_ptr{ new int{ 808 } };\n```", "```\nauto my_ptr = std::make_shared<int>(808);\n```", "```\nstd::shared_ptr<int➊> sh_ptr{\n  new int{ 10 }➋,\n  [](int* x) { delete x; } ➌,\n  std::allocator<int>{} ➍\n};\n```", "```\nauto sh_ptr = std::allocate_shared<int➊>(std::allocator<int>{}➋, 10➌);\n```", "```\nusing SharedOathbreakers = std::shared_ptr<DeadMenOfDunharrow>;\n```", "```\nTEST_CASE(\"SharedPtr can be used in copy\") {\n  auto aragorn = std::make_shared<DeadMenOfDunharrow>();\n  SECTION(\"construction\") {\n    auto son_of_arathorn{ aragorn }; ➊\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➋\n  }\n  SECTION(\"assignment\") {\n    SharedOathbreakers son_of_arathorn; ➌\n    son_of_arathorn = aragorn; ➍\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➎\n  }\n  SECTION(\"assignment, and original gets discarded\") {\n    auto son_of_arathorn = std::make_shared<DeadMenOfDunharrow>(); ➏\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2);➐\n    son_of_arathorn = aragorn; ➑\n    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➒\n  }\n}\n```", "```\nusing FileGuard = std::shared_ptr<FILE>;\n```", "```\nauto sp = std::make_shared<int>(808);\nstd::weak_ptr<int> wp{ sp };\n```", "```\nTEST_CASE(\"WeakPtr lock() yields\") {\n  auto message = \"The way is shut.\";\n  SECTION(\"a shared pointer when tracked object is alive\") {\n    auto aragorn = std::make_shared<DeadMenOfDunharrow>(message); ➊\n    std::weak_ptr<DeadMenOfDunharrow> legolas{ aragorn }; ➋\n    auto sh_ptr = legolas.lock(); ➌\n    REQUIRE(sh_ptr->message == message); ➍\n    REQUIRE(sh_ptr.use_count() == 2); ➎\n  }\n  SECTION(\"empty when shared pointer empty\") {\n    std::weak_ptr<DeadMenOfDunharrow> legolas;\n    {\n      auto aragorn = std::make_shared<DeadMenOfDunharrow>(message); ➏\n      legolas = aragorn; ➐\n    }\n auto sh_ptr = legolas.lock(); ➑\n    REQUIRE(nullptr == sh_ptr); ➒\n  }\n}\n```", "```\n#include <boost/smart_ptr/intrusive_ptr.hpp>\n\nusing IntrusivePtr = boost::intrusive_ptr<DeadMenOfDunharrow>; ➊\nsize_t ref_count{}; ➋\n\nvoid intrusive_ptr_add_ref(DeadMenOfDunharrow* d) {\n  ref_count++; ➌\n}\n\nvoid intrusive_ptr_release(DeadMenOfDunharrow* d) {\n ref_count--; ➍\n  if (ref_count == 0) delete d; ➎\n}\n```", "```\nTEST_CASE(\"IntrusivePtr uses an embedded reference counter.\") {\n  REQUIRE(ref_count == 0); ➊\n  IntrusivePtr aragorn{ new DeadMenOfDunharrow{} }; ➋\n  REQUIRE(ref_count == 1); ➌\n  {\n    IntrusivePtr legolas{ aragorn }; ➍\n    REQUIRE(ref_count == 2); ➎\n  }\n  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); ➏\n}\n```", "```\n#include <new>\n\nstatic size_t n_allocated, n_deallocated;\n\ntemplate <typename T>\nstruct MyAllocator {\n  using value_type = T; ➊\n  MyAllocator() noexcept{ } ➋\n  template <typename U>\n  MyAllocator(const MyAllocator<U>&) noexcept { } ➌\n  T* allocate(size_t n) { ➍\n    auto p = operator new(sizeof(T) * n);\n    ++n_allocated;\n    return static_cast<T*>(p);\n  }\n  void deallocate(T* p, size_t n) { ➎\n    operator delete(p);\n    ++n_deallocated;\n  }\n};\n\ntemplate <typename T1, typename T2>\nbool operator==(const MyAllocator<T1>&, const MyAllocator<T2>&) {\n  return true; ➏\n}\ntemplate <typename T1, typename T2>\nbool operator!=(const MyAllocator<T1>&, const MyAllocator<T2>&) {\n  return false; ➐\n}\n```", "```\nTEST_CASE(\"Allocator\") {\n  auto message = \"The way is shut.\";\n  MyAllocator<DeadMenOfDunharrow> alloc; ➊\n  {\n    auto aragorn = std::allocate_shared<DeadMenOfDunharrow>(alloc➋, message➌);\n    REQUIRE(aragorn->message == message); ➍\n    REQUIRE(n_allocated == 1); ➎\n    REQUIRE(n_deallocated == 0); ➏\n  }\n  REQUIRE(n_allocated == 1); ➐\n  REQUIRE(n_deallocated == 1); ➑\n}\n```", "```\nstruct Hal {\n  Hal(std::shared_ptr<FILE> file);\n  ~Hal();\n  void write_status();\n  std::shared_ptr<FILE> file;\n};\n```"]