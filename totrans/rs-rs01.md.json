["```\nlet x = 42;\nlet y = 43;\nlet var1 = &x;\nlet mut var2 = &x;\n1 var2 = &y;\n```", "```\nlet string = \"Hello world\";\n```", "```\nlet mut x;\n// this access would be illegal, nowhere to draw the flow from:\n// assert_eq!(x, 42);\n1 x = 42;\n// this is okay, can draw a flow from the value assigned above:\n2 let y = &x;\n// this establishes a second, mutable flow from x:\n3 x = 43;\n// this continues the flow from y, which in turn draws from x.\n// but that flow conflicts with the assignment to x!\n4 assert_eq!(*y, 42);\n```", "```\nlet x1 = 42;\nlet y1 = Box::new(84);\n{ // starts a new scope\n  1 let z = (x1, y1);\n  // z goes out of scope, and is dropped;\n  // it in turn drops the values from x1 and y1\n2 }\n// x1's value is Copy, so it was not moved into z\n3 let x2 = x1;\n// y1's value is not Copy, so it was moved into z\n4 // let y2 = y1;\n```", "```\nfn cache(input: &i32, sum: &mut i32) {\n  *sum = *input + *input;\n  assert_eq!(*sum, 2 * *input);\n}\n```", "```\nfn noalias(input: &i32, output: &mut i32) {\n  if *input == 1 {\n   1 *output = 2;\n  }\n2 if *input != 1 {\n     *output = 3;\n  }\n}\n```", "```\nlet x = 42;\nlet mut y = &x; // y is of type &i32\nlet z = &mut y; // z is of type &mut &i32\n```", "```\nfn replace_with_84(s: &mut Box<i32>) {\n  // this is not okay, as *s would be empty:\n1 // let was = *s;\n  // but this is:\n2 let was = std::mem::take(s);\n  // so is this:\n3 *s = was;\n  // we can exchange values behind &mut:\n  let mut r = Box::new(84);\n4 std::mem::swap(s, &mut r);\n  assert_ne!(*r, 84);\n}\nlet mut s = Box::new(42);\nreplace_with_84(&mut s);\n5\n```", "```\nlet mut x = Box::new(42);\n1 let r = &x;           // 'a\nif rand() > 0.5 {\n2 *x = 84;\n} else {\n3 println!(\"{}\", r);  // 'a\n}\n4\n```", "```\nlet mut x = Box::new(42);\n1 let mut z = &x;          // 'a\nfor i in 0..100 {\n2 println!(\"{}\", z);     // 'a\n3 x = Box::new(i);\n4 z = &x;                // 'a\n}\nprintln!(\"{}\", z);       // 'a\n```", "```\nstruct StrSplit<'s, 'p> {\n  delimiter: &'p str,\n  document: &'s str,\n}\nimpl<'s, 'p> Iterator for StrSplit<'s, 'p> {\n  type Item = &'s str;\n  fn next(&self) -> Option<Self::Item> {\n    todo!()\n  }\n}\nfn str_before(s: &str, c: char) -> Option<&str> {\n  StrSplit { document: s, delimiter: &c.to_string() }.next()\n}\n```", "```\nlet x: &'static str; // more useful, lives longer\nlet x: &'a      str; // less useful, lives shorter\n\nfn take_func1(&'static str) // stricter, so less useful\nfn take_func2(&'a str)      // less strict, more useful\n```", "```\nstruct MutStr<'a, 'b> {\n  s: &'a mut &'b str\n}\nlet mut s = \"hello\";\n1 *MutStr { s: &mut s }.s = \"world\";\nprintln!(\"{}\", s);\n```"]