<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Building and Rebuilding"><div class="titlepage"><div><div><h1 class="title"><a id="building_and_rebuilding"/>Chapter 3. Building and Rebuilding</h1></div></div></div><p><a id="iddle1158" class="indexterm"/><a id="iddle1662" class="indexterm"/>Knowing when and why targets are rebuilt and recipes run is fundamental to using GNU <code class="literal">make</code>. For simple makefiles, it’s easy to understand why a particular object file was built, but for real-world makefiles, building and rebuilding becomes complex. In addition, GNU <code class="literal">make</code> dependencies can be limiting because files are updated when the modification time of a prerequisite is later than the target. And in most cases, only a single target is updated by a single rule.</p><p>This chapter explains advanced techniques for handling dependencies in GNU <code class="literal">make</code>, including rebuilding when the recipe of a target changes, rebuilding when a checksum of a file changes, how best to implement recursive <code class="literal">make</code>, and how to build multiple targets in a single rule.</p><div class="sect1" title="Rebuilding When CPPFLAGS Changes"><div class="titlepage"><div><div><h1 class="title"><a id="rebuilding_when_cppflags_changes"/>Rebuilding When CPPFLAGS Changes</h1></div></div></div><p>This section shows you how to implement an important “missing feature” of GNU <code class="literal">make</code>: the ability to rebuild targets when the commands for those <a id="iddle1139" class="indexterm"/><a id="iddle1152" class="indexterm"/><a id="iddle1663" class="indexterm"/><a id="iddle1695" class="indexterm"/><a id="iddle1819" class="indexterm"/>targets change. GNU <code class="literal">make</code> rebuilds a target when it is <span class="emphasis"><em>out of date</em></span>; that is, it rebuilds when some of the prerequisites are newer than the target itself. But what if the target appears up-to-date when looking at file timestamps, but the actual commands to build the target have changed?</p><p>For example, what happens when a non-debug build is followed by a debug build (perhaps by running <code class="literal">make</code> followed by <code class="literal">make DEBUG=1</code>)? Unless the build has been structured so the names of targets depend on whether the build is debug or non-debug, nothing happens.</p><p>GNU <code class="literal">make</code> has no way of detecting that some targets ought to be rebuilt, because it doesn’t take into account any change to the commands in recipes. If, for example, <code class="literal">DEBUG=1</code> causes the flags passed to the compiler to change, the target should be rebuilt.</p><p>In this section you’ll learn how to make that happen in a few lines of GNU <code class="literal">make</code> code.</p><div class="sect2" title="An Example Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="example_makefile"/>An Example Makefile</h2></div></div></div><p>The example makefile in <a class="xref" href="ch03.html#example_makefile_for_demonstrating_the_r" title="Example 3-1. An example makefile for demonstrating the rebuilding when commands change system.">Example 3-1</a> is used throughout this section to demonstrate the <span class="emphasis"><em>rebuilding when commands change</em></span> system. To make the operation of the system very clear, I’ve avoided using built-in GNU <code class="literal">make</code> rules, so this makefile isn’t as simple as it could be:</p><div class="example"><a id="example_makefile_for_demonstrating_the_r"/><p class="title">Example 3-1. An example makefile for demonstrating the rebuilding when commands change system.</p><div class="example-contents"><pre class="programlisting">all: foo.o bar.o

foo.o: foo.c
→ $(COMPILE.C) -DDEBUG=$(DEBUG) -o $@ $&lt;

bar.o: bar.c
→ $(COMPILE.C) -o $@ $&lt;</pre></div></div><p>The makefile creates two <code class="literal">.o</code> files, <code class="literal">foo.o</code> and <code class="literal">bar.o</code>, by compiling corresponding <code class="literal">.c</code> files. The compilation is done using the built-in variable <code class="literal">COMPILE.C</code> (which will normally be the name of a suitable compiler for the system, followed by references to variables like <code class="literal">CPPFLAGS</code> and use of <code class="literal">$@</code> and <code class="literal">$&lt;</code> to compile the code into an object file).</p><p>A specific reference to <code class="literal">$(DEBUG)</code> is turned into a pre-processor variable called <code class="literal">DEBUG</code> using the compiler’s <code class="literal">-D</code> option. The contents of <code class="literal">foo.c</code> and <code class="literal">bar.c</code> have been omitted because they are irrelevant.</p><p>Here’s what happens when <code class="literal">make</code> is run with no command line options (which means that <code class="literal">DEBUG</code> is undefined):</p><a id="pro_id00221"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
g++  -c -DDEBUG= -o foo.o foo.c
g++  -c -o bar.o bar.c</pre><p><a id="iddle1505" class="indexterm"/><a id="iddle1572" class="indexterm"/><a id="iddle1747" class="indexterm"/>Now <code class="literal">foo.o</code> and <code class="literal">bar.o</code> have been created, so typing <code class="literal">make</code> again does nothing:</p><a id="pro_id00222"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
make: Nothing to be done for `all'.</pre><p>Typing <code class="literal">make DEBUG=1</code> also does nothing, even though the object file <code class="literal">foo.o</code> would likely be different if it were rebuilt with <code class="literal">DEBUG</code> defined (for example, it would likely contain extra debugging code controlled by <code class="literal">#ifdef</code>s that use the <code class="literal">DEBUG</code> variable in the source code):</p><a id="pro_id00223"/><pre class="programlisting">$ <span class="strong"><strong>make DEBUG=1</strong></span>
make: Nothing to be done for `all'.</pre><p>The <code class="literal">signature</code> system in the next section will correct that problem and require very little work for the makefile maintainer.</p></div><div class="sect2" title="Changing Our Example Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="changing_our_example_makefile"/>Changing Our Example Makefile</h2></div></div></div><p>To fix the problem in the preceding section, we’ll use a helper makefile called <code class="literal">signature</code>. We’ll look at how <code class="literal">signature</code> works in a moment; first let’s look at how to modify the makefile in <a class="xref" href="ch03.html#example_makefile_for_demonstrating_the_r" title="Example 3-1. An example makefile for demonstrating the rebuilding when commands change system.">Example 3-1</a> to use it:</p><a id="pro_id00224"/><pre class="programlisting"><span class="strong"><strong>include signature</strong></span>

all: foo.o bar.o

foo.o: foo.c
→ <span class="strong"><strong>$(call do,$$(COMPILE.C) -DDEBUG=$$(DEBUG) -o $$@ $$&lt;)</strong></span>

bar.o: bar.c
→ <span class="strong"><strong>$(call do,$$(COMPILE.C) -o $$@ $$&lt;)</strong></span>

<span class="strong"><strong>-include foo.o.sig bar.o.sig</strong></span></pre><p>Three changes were made to the file: first, <code class="literal">include signature</code> was added at the start so the code that handles the updating of <span class="emphasis"><em>signatures</em></span> is included. These signatures will capture the commands used to build files and be used to rebuild when the commands change.</p><p>Second, the commands in the two rules were wrapped with <code class="literal">$(call do,...)</code>, and the <code class="literal">$</code> signs for each command have been quoted with a second <code class="literal">$</code>.</p><p>Third, for each <code class="literal">.o</code> file being managed by signature, there’s an <code class="literal">include</code> of a corresponding <code class="literal">.sig</code> file. The final line of the makefile includes <code class="literal">foo.o.sig</code> (for <code class="literal">foo.o</code>) and <code class="literal">bar.o.sig</code> (for <code class="literal">bar.o</code>). Notice that <code class="literal">-include</code> is used instead of just <code class="literal">include</code> in case the <code class="literal">.sig</code> file is missing (<code class="literal">-include</code> doesn’t generate an error when one of the files to be included is not present).</p><p>Before you see how this works, here are some examples of it in operation:</p><a id="pro_id00225"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
g++  -c -DDEBUG= -o foo.o foo.c
g++  -c -o bar.o bar.c
$ <span class="strong"><strong>make</strong></span>
make: Nothing to be done for `all'.</pre><p>First, there’s a clean build (with no <code class="literal">.o</code> files present) and then a rerun of <code class="literal">make</code> to see that there’s nothing to do.</p><p>But setting <code class="literal">DEBUG</code> to <code class="literal">1</code> on the <code class="literal">make</code> command line now causes <code class="literal">foo.o</code> to rebuild:</p><a id="pro_id00226"/><pre class="programlisting">$ <span class="strong"><strong>make DEBUG=1</strong></span>
g++  -c -DDEBUG=1 -o foo.o foo.c</pre><p>This happens because its <span class="emphasis"><em>signature</em></span> (the actual commands to be run to build <code class="literal">foo.o</code>) has changed.</p><p>Of course, <code class="literal">bar.o</code> was not rebuilt because it was truly up-to-date (its object code was new and there were no command changes). Run <code class="literal">make DEBUG=1</code> again, and it’ll say there’s nothing to be done:</p><a id="pro_id00227"/><pre class="programlisting">$ <span class="strong"><strong>make DEBUG=1</strong></span>
make: Nothing to be done for `all'.
$ <span class="strong"><strong>make</strong></span>
g++  -c -DDEBUG= -o foo.o foo.c</pre><p>But just typing <code class="literal">make</code> (going back to a non-debug build) rebuilds <code class="literal">foo.o</code> again because <code class="literal">DEBUG</code> is now undefined.</p><p>The signature system also works for variables within recursive variables. In GNU <code class="literal">make</code>, <code class="literal">COMPILE.C</code> actually expands <code class="literal">CPPFLAGS</code> to create the complete compiler command line. Here’s what happens if <code class="literal">CPPFLAGS</code> is modified on the GNU <code class="literal">make</code> command line by adding a definition:</p><a id="pro_id00228"/><pre class="programlisting">$ <span class="strong"><strong>make CPPFLAGS+=-DFOO=foo</strong></span>
g++ -DFOO=foo -c -DDEBUG= -o foo.o foo.c
g++ -DFOO=foo -c -o bar.o bar.c</pre><p>Both <code class="literal">foo.o</code> and <code class="literal">bar.o</code> were rebuilt because <code class="literal">CPPFLAGS</code> changed (and because <code class="literal">CPPFLAGS</code> was part of the commands used to build those two object files).</p><p>Of course, changing a variable that isn’t referenced doesn’t update anything. For example:</p><a id="pro_id00229"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
g++  -c -DDEBUG= -o foo.o foo.c
g++  -c -o bar.o bar.c
$ <span class="strong"><strong>make SOMEVAR=42</strong></span>
make: Nothing to be done for `all'.</pre><p>Here we’re starting from a clean build and redefining <code class="literal">SOMEVAR</code>.</p></div><div class="sect2" title="How Signature Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_signature_works"/>How Signature Works</h2></div></div></div><p><a id="iddle1746" class="indexterm"/><a id="iddle1748" class="indexterm"/><a id="iddle1757" class="indexterm"/><a id="iddle1786" class="indexterm"/>To understand how <code class="literal">signature</code> works, first look inside a <code class="literal">.sig</code> file. The <code class="literal">.sig</code> files are automatically generated by rules in the <code class="literal">signature</code> makefile for each rule that uses the <code class="literal">$(call do,...)</code> form.</p><p>For example, here are the contents of the <code class="literal">foo.o.sig</code> file after the first clean build was run:</p><a id="pro_id00230"/><pre class="programlisting">$(eval @ := foo.o)
$(eval % := )
$(eval &lt; := foo.c)
$(eval ? := foo.o.force)
$(eval ^ := foo.c foo.o.force)
$(eval + := foo.c foo.o.force)
$(eval * := foo)

foo.o: foo.o.force

$(if $(call sne,$(COMPILE.C) -DDEBUG=$(DEBUG) -o $@ $&lt;,\
g++ -c -DDEBUG= -o foo.o foo.c),$(shell touch foo.o.force))</pre><p>The first seven lines capture the state of the automatic variables as defined when the <code class="literal">foo.o</code> rule is being processed. We need the values of these variables so we can compare the current commands for a rule (which likely use automatic variables) with the commands the last time the rule was run.</p><p>Next comes the line <code class="literal">foo.o: foo.o.force</code>. This states that <code class="literal">foo.o</code> must be rebuilt if <code class="literal">foo.o.force</code> is newer. It’s this line that causes <code class="literal">foo.o</code> to get rebuilt when the commands change, and it’s the next line that touches <code class="literal">foo.o.force</code> if the commands have changed.</p><p>The long <code class="literal">$(if)</code> statement uses the GMSL <code class="literal">sne</code> (string not equal) function to compare the current commands for <code class="literal">foo.o</code> (by expanding them) against their value the last time they were expanded. If the commands have changed, <code class="literal">$(shell touch foo.o.force)</code> is called.</p><p>Because the <code class="literal">.sig</code> files are processed when the makefile is being parsed (they are just makefiles, read using <code class="literal">include</code>), all the <code class="literal">.force</code> files will have been updated before any rules run. And so this small <code class="literal">.sig</code> file does all the work of forcing an object file to rebuild when commands change.</p><p>The <code class="literal">.sig</code> files are created by <code class="literal">signature</code>:</p><a id="pro_id00231"/><pre class="programlisting">include gmsl

last_target :=

dump_var = \$$(eval $1 := $($1))

define new_rule
@echo "$(call map,dump_var,@ % &lt; ? ^ + *)" &gt; $S
@$(if $(wildcard $F),,touch $F)
@echo $@: $F &gt;&gt; $S
endef
define do
$(eval S := $@.sig)$(eval F := $@.force)$(eval C := $(strip $1))
$(if $(call sne,$@,$(last_target)),$(call new_rule),$(eval last_target := $@))
@echo "S(subst ",\",$(subst $$,\$$,$$(if $$(call sne,$(strip $1),$C),$$(shell touch $F))))" &gt;&gt; $S
$C
endef</pre><p><a id="iddle1309" class="indexterm"/><a id="iddle1521" class="indexterm"/><a id="iddle1664" class="indexterm"/><a id="iddle1694" class="indexterm"/><a id="iddle1749" class="indexterm"/><a id="iddle1760" class="indexterm"/><a id="iddle1826" class="indexterm"/><a id="iddle1828" class="indexterm"/><code class="literal">signature</code> includes the GMSL and then defines the important <code class="literal">do</code> variable used to wrap the commands in a rule. When <code class="literal">do</code> is called, it creates the appropriate <code class="literal">.sig</code> file containing the state of all the automatic variables.</p><p>The <code class="literal">new_rule</code> function called by <code class="literal">do</code> captures the automatic variables. It uses the GMSL <code class="literal">map</code> function to call another function (<code class="literal">dump_var</code>) for each of <code class="literal">@ % &lt; ? ^ + *</code>. The <code class="literal">new_rule</code> function also ensures that the corresponding <code class="literal">.force</code> file has been created.</p><p>In addition, <code class="literal">do</code> writes out the complex <code class="literal">$(if)</code> statement that contains the unexpanded and expanded versions of the commands for the current rule. Then it actually runs the commands (that’s the <code class="literal">$C</code>) at the end.</p></div><div class="sect2" title="Limitations"><div class="titlepage"><div><div><h2 class="title"><a id="limitations"/>Limitations</h2></div></div></div><p>The signature system has some limitations that could trap the unwary. First, if the commands in a rule contain any side effects—for example, if they call <code class="literal">$(shell)</code>—the system may misbehave if there was an assumption that the side effect happens only once.</p><p>Second, it’s vital that <code class="literal">signature</code> is included before any of the <code class="literal">.sig</code> files.</p><p>Third, if the makefile is edited and the commands in a rule change, the signature system will not notice. If that happens, it’s vital to regenerate the corresponding target so the <code class="literal">.sig</code> is updated.</p><p>Try adding the following line at the end of the definition of <code class="literal">new_rule</code>:</p><a id="pro_id00232"/><pre class="programlisting">@echo $F: Makefile &gt;&gt; $S</pre><p>You can make the signature system automatically rebuild when the makefile changes by having the makefile as a prerequisite to each of the makefile’s targets. This line is the simplest way to achieve that.</p></div></div><div class="sect1" title="Rebuilding When a File’s Checksum Changes"><div class="titlepage"><div><div><h1 class="title"><a id="rebuilding_when_a_fileapostrophes_checks"/>Rebuilding When a File’s Checksum Changes</h1></div></div></div><p>Besides having GNU <code class="literal">make</code> rebuild targets when commands change, another common technique is to rebuild when the contents of a file change, not just the file’s timestamp.</p><p>This usually comes up because the timestamps on generated code, or in code extracted from a source code control system, are older than related objects, so GNU <code class="literal">make</code> does not know to rebuild the object. This can happen even when the contents of the file are different from the last time the object was built.</p><p><a id="iddle1279" class="indexterm"/><a id="iddle1528" class="indexterm"/><a id="iddle1534" class="indexterm"/><a id="iddle1827" class="indexterm"/>A common scenario is that an engineer working on a build on their local machine rebuilds all objects and later gets the latest version of source files from source code control. Some older source control systems set the timestamp on the source files to the timestamp of the file when it was checked in to source control; in that case, newly built object files may have timestamps that are newer than the (potentially changed) source code.</p><p>In this section you’ll learn a simple hack to get GNU <code class="literal">make</code> to do the right thing (rebuild) when the contents of a source file change.</p><div class="sect2" title="An Example Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="example_makefile-id00002"/>An Example Makefile</h2></div></div></div><p>The simple makefile in <a class="xref" href="ch03.html#simple_makefile_that_builds_foodoto_from" title="Example 3-2. A simple makefile that builds foo.o from foo.c and foo.h">Example 3-2</a> builds object file <code class="literal">foo.o</code> from <code class="literal">foo.c</code> and <code class="literal">foo.h</code> using the built-in rule to make a <code class="literal">.o</code> file from a <code class="literal">.c</code>:</p><div class="example"><a id="simple_makefile_that_builds_foodoto_from"/><p class="title">Example 3-2. A simple makefile that builds <code class="literal">foo.o</code> from <code class="literal">foo.c</code> and <code class="literal">foo.h</code></p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: foo.o

foo.o: foo.c foo.h</pre></div></div><p>If either <code class="literal">foo.c</code> or <code class="literal">foo.h</code> are newer than <code class="literal">foo.o</code>, then <code class="literal">foo.o</code> will be rebuilt.</p><p>If <code class="literal">foo.h</code> were to change without updating its timestamp, GNU <code class="literal">make</code> would do nothing. For example, if <code class="literal">foo.h</code> were updated from source code control, this makefile might do the wrong thing.</p><p>To work around this problem, we need a way to force GNU <code class="literal">make</code> to consider the contents of the file, not its timestamp. Because GNU <code class="literal">make</code> can handle timestamps internally only, we need to hack the makefile so that file timestamps are related to file contents.</p></div><div class="sect2" title="Digesting File Contents"><div class="titlepage"><div><div><h2 class="title"><a id="digesting_file_contents"/>Digesting File Contents</h2></div></div></div><p>An easy way to detect a change in a file is to use a message digest function, such as MD5, to generate a digest of the file. Because any change in the file will cause the digest to change, just examining the digest will be enough to detect a change in the file’s contents.</p><p>To force GNU <code class="literal">make</code> to check the contents of each file, we’ll associate a file with the extension <code class="literal">.md5</code> with every source code file to be tested. Each <code class="literal">.md5</code> file will contain the MD5 checksum of the corresponding source code file.</p><p>In <a class="xref" href="ch03.html#simple_makefile_that_builds_foodoto_from" title="Example 3-2. A simple makefile that builds foo.o from foo.c and foo.h">Example 3-2</a>, source code files <code class="literal">foo.c</code> and <code class="literal">foo.h</code> will have associated <code class="literal">.md5</code> files <code class="literal">foo.c.md5</code> and <code class="literal">foo.h.md5</code>. To generate the MD5 checksum, we use the <code class="literal">md5sum</code> utility: it outputs a hexadecimal string containing the MD5 checksum of its input file.</p><p>If we arrange for the <span class="emphasis"><em>timestamp</em></span> of the <code class="literal">.md5</code> file to change when the <span class="emphasis"><em>checksum</em></span> of the related file changes, GNU <code class="literal">make</code> can check the timestamp of the <code class="literal">.md5</code> file in lieu of the actual source file.</p><p>In our example, GNU <code class="literal">make</code> would check the timestamp of <code class="literal">foo.c.md5</code> and <code class="literal">foo.h.md5</code> to determine whether <code class="literal">foo.o</code> needs to be rebuilt.</p></div><div class="sect2" title="The Modified Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="modified_makefile"/>The Modified Makefile</h2></div></div></div><p><a id="iddle1297" class="indexterm"/><a id="iddle1529" class="indexterm"/>Here’s the completed makefile that checks the MD5 checksum of source files so that objects are rebuilt when the contents of those files (and hence their checksums) change:</p><a id="pro_id00233"/><pre class="programlisting">to-md5 = $1 $(addsuffix .md5,$1)

.PHONY: all
all: foo.o

foo.o: $(call to-md5,foo.c foo.h)

%.md5: FORCE
→ @$(if $(filter-out $(shell cat $@ 2&gt;/dev/null),$(shell md5sum $*)),md5sum $* &gt; $@)

FORCE:</pre><p>Notice first that the prerequisite list for <code class="literal">foo.o</code> has changed from <code class="literal">foo.c foo.h</code> to <code class="literal">$(call to-md5,foo.c foo.h)</code>. The <code class="literal">to-md5</code> function defined in the makefile adds the suffix <code class="literal">.md5</code> to all the filenames in its argument.</p><p>So after expansion, the line reads:</p><a id="pro_id00234"/><pre class="programlisting">foo.o: foo.c foo.h foo.c.md5 foo.h.md5.</pre><p>This tells GNU <code class="literal">make</code> to rebuild <code class="literal">foo.o</code> if either of the <code class="literal">.md5</code> files is newer, as well as if either <code class="literal">foo.c</code> or <code class="literal">foo.h</code> is newer.</p><p>To ensure that the <code class="literal">.md5</code> files always contain the correct timestamp, they are always rebuilt. Each <code class="literal">.md5</code> file is remade by the <code class="literal">%.md5: FORCE</code> rule. The use of the empty rule <code class="literal">FORCE:</code> means that the <code class="literal">.md5</code> files are examined every time. Use of <code class="literal">FORCE</code> here is a little like using <code class="literal">.PHONY</code>: if there’s no file called <code class="literal">FORCE</code>, GNU <code class="literal">make</code> will build it (there’s no recipe so nothing happens) and then GNU <code class="literal">make</code> will consider <code class="literal">FORCE</code> to be newer than the <code class="literal">%.md5</code> file and rebuild it. Because we can’t do <code class="literal">.PHONY: %.md5</code>, we use this <code class="literal">FORCE</code> trick instead.</p><p>The commands for the <code class="literal">%.md5: FORCE</code> rule will only actually rebuild the <code class="literal">.md5</code> file if it doesn’t exist or if the checksum stored in the <code class="literal">.md5</code> file is different from the corresponding file’s checksum, which works as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">$(shell md5sum $*)</code> checksums the file that matches the <code class="literal">%</code> part of <code class="literal">%.md5</code>. For example, when this rule is being used to generate the <code class="literal">foo.h.md5</code> file, then <code class="literal">%</code> matches <code class="literal">foo.h</code> and <code class="literal">foo.h</code> is stored in <code class="literal">$*</code>.</p></li><li class="listitem"><p><code class="literal">$(shell cat $@ 2&gt;/dev/null)</code> gets the contents of the current <code class="literal">.md5</code> file (or a blank if it doesn’t exist; note how the <code class="literal">2&gt;/dev/null</code> means that errors are ignored). Then, the <code class="literal">$(filter-out)</code> compares the checksum retrieved from the <code class="literal">.md5</code> file and the checksum generated by <code class="literal">md5sum</code>. If they are the same, the <code class="literal">$(filter-out)</code> is an empty string.</p></li><li class="listitem"><p><a id="iddle1573" class="indexterm"/><a id="iddle1905" class="indexterm"/>If the checksum has changed, the rule will actually run <code class="literal">md5sum $* &gt; $@</code>, which will update the <code class="literal">.md5</code> file’s contents and timestamp. The stored checksum will be available for later use when running GNU <code class="literal">make</code> again, and the changed timestamp on the <code class="literal">.md5</code> file will cause the related object file to be built.</p></li></ol></div></div><div class="sect2" title="The Hack in Action"><div class="titlepage"><div><div><h2 class="title"><a id="hack_in_action"/>The Hack in Action</h2></div></div></div><p>To see how the hack updates an object file when one of its prerequisites changes checksum, let’s create files <code class="literal">foo.c</code> and <code class="literal">foo.h</code> and run GNU <code class="literal">make</code>:</p><a id="pro_id00235"/><pre class="programlisting">$ <span class="strong"><strong>touch foo.c foo.h</strong></span>
$ <span class="strong"><strong>ls</strong></span>
foo.c foo.h makefile
$ <span class="strong"><strong>make</strong></span>
cc -c -o foo.o foo.c
$ <span class="strong"><strong>ls</strong></span>
foo.c foo.c.md5 foo.h foo.h.md5 foo.o makefile</pre><p>GNU <code class="literal">make</code> generates the object file <code class="literal">foo.o</code> and two <code class="literal">.md5</code> files, <code class="literal">foo.c.md5</code> and <code class="literal">foo.h.md5</code>. Each <code class="literal">.md5</code> file contains the checksum of the file:</p><a id="pro_id00236"/><pre class="programlisting">$ <span class="strong"><strong>cat foo.c.md5</strong></span>
d41d8cd98f00b204e9800998ecf8427e foo.c</pre><p>First, we verify that everything is up-to-date and then verify that changing the timestamp on either <code class="literal">foo.c</code> or <code class="literal">foo.h</code> causes <code class="literal">foo.o</code> to be rebuilt:</p><a id="pro_id00237"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
make: Nothing to be done for `all'.
$ <span class="strong"><strong>touch foo.c</strong></span>
$ <span class="strong"><strong>make</strong></span>
cc  -c -o foo.o foo.c
$ <span class="strong"><strong>make</strong></span>
make: Nothing to be done for `all'.
$ <span class="strong"><strong>touch foo.h</strong></span>
$ <span class="strong"><strong>make</strong></span>
cc -c -o foo.o foo.c</pre><p>To demonstrate that changing the contents of a source file will cause <code class="literal">foo.o</code> to be rebuilt, we can cheat by changing the contents of, say, <code class="literal">foo.h</code> and then <code class="literal">touch foo.o</code> to make <code class="literal">foo.o</code> newer than <code class="literal">foo.h</code>, which would normally mean that <code class="literal">foo.o</code> would not be built.</p><p>As a result, we know that <code class="literal">foo.o</code> is newer than <code class="literal">foo.h</code> but that <code class="literal">foo.h</code>’s contents have changed since the last time <code class="literal">foo.o</code> was built:</p><a id="pro_id00238"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
make: Nothing to be done for `all'.
$ <span class="strong"><strong>cat foo.h.md5</strong></span>
d41d8cd98f00b204e9800998ecf8427e foo.h
$ <span class="strong"><strong>cat &gt;&gt; foo.h</strong></span>
// Add a comment
$ <span class="strong"><strong>touch foo.o</strong></span>
$ <span class="strong"><strong>make</strong></span>
cc  -c -o foo.o foo.c
$ <span class="strong"><strong>cat foo.h.md5</strong></span>
65f8deea3518fcb38fd2371287729332 foo.h</pre><p><a id="iddle1018" class="indexterm"/><a id="iddle1190" class="indexterm"/><a id="iddle1197" class="indexterm"/>You can see that <code class="literal">foo.o</code> was rebuilt, even though it was newer than all the related source files, and that <code class="literal">foo.h.md5</code> has been updated with the new checksum of <code class="literal">foo.h</code>.</p></div><div class="sect2" title="Improving the Code"><div class="titlepage"><div><div><h2 class="title"><a id="improving_the_code"/>Improving the Code</h2></div></div></div><p>We can make a couple of improvements to the code: the first is an optimization. When the checksum of a file has changed the rule to update, the <code class="literal">.md5</code> file actually ends up running <code class="literal">md5sum</code> twice on the same file with the same result. That’s a waste of time. If you are using GNU <code class="literal">make</code> 3.80 or later, it’s possible to store the output of <code class="literal">md5sum $*</code> in a temporary variable called <code class="literal">CHECKSUM</code> and just use the variable:</p><a id="pro_id00239"/><pre class="programlisting">%.md5: FORCE
→ @$(eval CHECKSUM := $(shell md5sum $*))$(if $(filter-out \
$(shell cat $@ 2&gt;/dev/null),$(CHECKSUM)),echo $(CHECKSUM) &gt; $@)</pre><p>The second improvement is to make the checksum insensitive to changes in whitespace in a source file. After all, it would be a pity if two developers’ differing opinions on the right amount of indentation caused object files to rebuild when nothing else had changed.</p><p>The <code class="literal">md5sum</code> utility does not have a way of ignoring whitespace, but it’s easy enough to pass the source file through <code class="literal">tr</code> to strip whitespace before handing it to <code class="literal">md5sum</code> for checksumming. (However, note that removing all whitespace might not be a good idea, at least not for most languages.)</p></div></div><div class="sect1" title="Automatic Dependency Generation"><div class="titlepage"><div><div><h1 class="title"><a id="automatic_dependency_generation"/>Automatic Dependency Generation</h1></div></div></div><p>Any project larger than a simple example faces a dependency management problem. Dependencies must be generated and kept up to date as engineers modify the project. GNU <code class="literal">make</code> provides no tools for dealing with this. All GNU <code class="literal">make</code> provides is a mechanism for expressing the relationships between files with its familiar <span class="emphasis"><em><code class="literal">target</code></em></span> <code class="literal">:</code> <span class="emphasis"><em><code class="literal">prerequisite1 prerequisite2</code></em></span> <code class="literal">...</code> syntax.</p><p>GNU <code class="literal">make</code>’s dependency syntax is flawed because it is more than just a list of prerequisites: the first prerequisite has a special meaning. Anything to the right of the <code class="literal">:</code> is a prerequisite, but the first prerequisite where there’s a recipe (that is, commands) is special: it’s the prerequisite that is assigned to the automatic variable <code class="literal">$&lt;</code> and is also frequently the prerequisite passed to the compiler (or other command) to generate the target.</p><p><a id="iddle1192" class="indexterm"/>The <code class="literal">$&lt;</code> variable is also special in another way. Sometimes a target will have a recipe and other rules specifying prerequisites. For example, it’s not uncommon to see something like this:</p><a id="pro_id00240"/><pre class="programlisting">foo.o: foo.c
4 @compile -o $@ $&lt;

foo.o: myheader.h string.h</pre><p>The value of <code class="literal">$&lt;</code> is set from the rule that has a recipe (it will be <code class="literal">foo.c</code> in this case).</p><p>Take a look at this:</p><a id="pro_id00241"/><pre class="programlisting">foo.o: foo.c header.h system.h
→ @echo Compiling $@ from $&lt;...</pre><p>which outputs</p><a id="pro_id00242"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Compiling foo.o from foo.c...</pre><p>Here <code class="literal">foo.o</code> is built if <code class="literal">foo.c</code>, <code class="literal">header.h</code>, or <code class="literal">system.h</code> change, but the rule also states that <code class="literal">foo.o</code> is made from <code class="literal">foo.c</code>. Say our example were written like this:</p><a id="pro_id00243"/><pre class="programlisting">foo.o: foo.c
foo.o: header.h system.h
→ @echo Compiling $@ from $&lt;...</pre><p>The output would be:</p><a id="pro_id00244"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Compiling foo.o from header.h...</pre><p>This is clearly wrong.</p><div class="sect2" title="An Example Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="example_makefile-id00003"/>An Example Makefile</h2></div></div></div><p>The biggest problem is generating all the rules expressing all the dependencies for a large project. The rest of this section uses the following contrived example makefile as a starting point:</p><a id="pro_id00245"/><pre class="programlisting">.PHONY: all
all: foo.o bar.o baz.o

foo.o: foo.c foo.h common.h header.h
bar.o: bar.c bar.h common.h header.h ba.h
baz.o: baz.c baz.h common.h header.h ba.h</pre><p><a id="iddle1107" class="indexterm"/><a id="iddle1426" class="indexterm"/><a id="iddle1500" class="indexterm"/>Three object files (<code class="literal">foo.o</code>, <code class="literal">bar.o</code>, and <code class="literal">baz.o</code>) are built from corresponding <code class="literal">.c</code> files (<code class="literal">foo.c</code>, <code class="literal">bar.c</code>, and <code class="literal">baz.c</code>). Each <code class="literal">.o</code> file has dependencies on various different header files, as shown in the last three lines of the makefile. The makefile uses GNU <code class="literal">make</code>’s built-in rules to perform compilation using the system’s compiler.</p><p>There’s no mention here of the final executable being built. The reason is that this example focuses on dealing with dependencies between sources and objects; relationships between objects are usually easier to maintain by hand because there are fewer of them and the relationships are part of the product design.</p></div><div class="sect2" title="makedepend and make depend"><div class="titlepage"><div><div><h2 class="title"><a id="makedepend_and_make_depend"/>makedepend and make depend</h2></div></div></div><p>Because maintaining any real makefile by hand is impossible, many projects use the widely available <code class="literal">makedepend</code> program. <code class="literal">makedepend</code> reads C and C++ files, looks at the <code class="literal">#include</code> statements, opens the files that are included, and builds the dependency lines automatically. A basic way of incorporating <code class="literal">makedepend</code> in a project is a special <code class="literal">depend</code> target, as shown in <a class="xref" href="ch03.html#using_makedepend_in_your_makefile" title="Example 3-3. Using makedepend in your makefile">Example 3-3</a>.</p><div class="example"><a id="using_makedepend_in_your_makefile"/><p class="title">Example 3-3. Using <code class="literal">makedepend</code> in your makefile</p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: foo.o bar.o baz.o

SRCS = foo.c bar.c baz.c

DEPENDS = dependencies.d
.PHONY: depend
depend:
→ @makedepend -f - $(SRCS) &gt; $(DEPENDS)

-include $(DEPENDS)</pre></div></div><p>Executing <code class="literal">make depend</code> with this makefile causes the <code class="literal">depend</code> rule to execute, which runs <code class="literal">makedepend</code> on the sources (defined in the <code class="literal">SRCS</code> variable) and outputs the dependency lines to a file called <code class="literal">dependencies.d</code> (defined by the <code class="literal">DEPENDS</code> variable).</p><p>The makefile adds the dependencies in its final line by including the <code class="literal">dependencies.d</code> file. <code class="literal">dependencies.d</code> would look like this:</p><a id="pro_id00246"/><pre class="programlisting"># DO NOT DELETE

foo.o: foo.h header.h common.h
bar.o: bar.h header.h common.h ba.h
baz.o: baz.h header.h common.h ba.h</pre><p>Notice that <code class="literal">makedepend</code> doesn’t try to define the relationship between an object file (like <code class="literal">foo.o</code>) and the source file it is made from (<code class="literal">foo.c</code>). In this case GNU <code class="literal">make</code>’s standard rules will find the related <code class="literal">.c</code> file automatically.</p></div><div class="sect2" title="Automating makedepend and Removing make depend"><div class="titlepage"><div><div><h2 class="title"><a id="automating_makedepend_and_removing_make"/>Automating makedepend and Removing make depend</h2></div></div></div><p><a id="iddle1501" class="indexterm"/>Two problems exist with the <code class="literal">make depend</code> style. Running <code class="literal">make depend</code> can be slow, because every source file must be searched, even if there are no changes. Also, it’s a manual step: before every <code class="literal">make</code> the user will have to do <code class="literal">make depend</code> to ensure that the dependencies are correct. The solution to these problems is automation.</p><p><a class="xref" href="ch03.html#automatically_running_makedepend_when_ne" title="Example 3-4. Automatically running makedepend when needed">Example 3-4</a> shows another version of the makefile from <a class="xref" href="ch03.html#using_makedepend_in_your_makefile" title="Example 3-3. Using makedepend in your makefile">Example 3-3</a>:</p><div class="example"><a id="automatically_running_makedepend_when_ne"/><p class="title">Example 3-4. Automatically running <code class="literal">makedepend</code> when needed</p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: foo.o bar.o baz.o

SRCS = foo.c bar.c baz.c

%.d : %.c
→ @makedepend -f - $&lt; | sed 's,\($*\.o\)[ :]*,\1 $@ : ,g' &gt; $@

-include $(SRCS:.c=.d)</pre></div></div><p>This version still uses <code class="literal">makedepend</code> to generate dependencies but automates the process and only runs <code class="literal">makedepend</code> for sources that have changed. It works by associating a <code class="literal">.d</code> file with each <code class="literal">.c</code>. For example, <code class="literal">foo.o</code> (built from <code class="literal">foo.c</code>) has a <code class="literal">foo.d</code> file that just contains the dependency line for <code class="literal">foo.o</code>.</p><p>Here are the contents of <code class="literal">foo.d</code>:</p><a id="pro_id00247"/><pre class="programlisting"># DO NOT DELETE

foo.o foo.d : foo.h header.h common.h</pre><p>Notice one addition: this line specifies when to rebuild <code class="literal">foo.o</code>, but also that <code class="literal">foo.d</code> should be rebuilt under the same conditions. If any of the sources associated with <code class="literal">foo.o</code> change, <code class="literal">foo.d</code> is rebuilt. <code class="literal">foo.c</code> isn’t mentioned in this list because it’s mentioned as part of the pattern rule for rebuilding a <code class="literal">.d</code> file (the <code class="literal">%.d : %.c</code> rule in the main makefile means that <code class="literal">foo.d</code> will be rebuilt if <code class="literal">foo.c</code> changes). <code class="literal">foo.d</code> was added to the dependency line created by <code class="literal">makedepend</code> using the <code class="literal">sed</code> magic shown in <a class="xref" href="ch03.html#automatically_running_makedepend_when_ne" title="Example 3-4. Automatically running makedepend when needed">Example 3-4</a>.</p><p>The final line of the main makefile includes all the <code class="literal">.d</code> files: the <code class="literal">$(SRCS:.c=.d)</code> transforms the list of sources in the <code class="literal">SRCS</code> variable by changing the extension from <code class="literal">.c</code> to <code class="literal">.d</code>. The <code class="literal">include</code> also tells GNU <code class="literal">make</code> to check whether the <code class="literal">.d</code> files need rebuilding.</p><p>GNU <code class="literal">make</code> will check if there are rules to rebuild included makefiles (in this case the <code class="literal">.d</code> files), rebuild them if necessary (following the dependencies specified in the makefile), and then restart. This makefile remaking feature (<span class="emphasis"><em><a class="ulink" href="http://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html">http://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html</a></em></span>) means that simply typing <code class="literal">make</code> will do the right thing: it’ll rebuild any dependency files that need rebuilding but only if the sources have changed. Then GNU <code class="literal">make</code> will perform the build, taking the new dependencies into account.</p></div><div class="sect2" title="Making Deleted Files Disappear from Dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="making_deleted_files_disappear_from_depe"/>Making Deleted Files Disappear from Dependencies</h2></div></div></div><p><a id="iddle1014" class="indexterm"/><a id="iddle1188" class="indexterm"/><a id="iddle1194" class="indexterm"/><a id="iddle1914" class="indexterm"/>Unfortunately, our makefile breaks with a fatal error if a source file is removed. If <code class="literal">header.h</code> is no longer needed, all references to it are removed from the <code class="literal">.c</code> files, the file is removed from disk, and running <code class="literal">make</code> produces the following error:</p><a id="pro_id00248"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
No rule to make target `header.h', needed by `foo.d'.</pre><p>This happens because <code class="literal">header.h</code> is still mentioned in <code class="literal">foo.d</code> as a prerequisite of <code class="literal">foo.d</code>; hence, <code class="literal">foo.d</code> cannot be rebuilt. You can fix this by making the generation of <code class="literal">foo.d</code> smarter:</p><a id="pro_id00249"/><pre class="programlisting"># DO NOT DELETE

foo.d : $(wildcard foo.h header.h common.h)
foo.o : foo.h header.h common.h</pre><p>The new <code class="literal">foo.d</code> includes the dependencies for <code class="literal">foo.o</code> and <code class="literal">foo.d</code> separately. <code class="literal">foo.d</code>’s dependencies are wrapped in a call to GNU <code class="literal">make</code>’s <code class="literal">$(wildcard)</code> function.</p><p>And here’s the updated makefile with a new invocation of <code class="literal">makedepend</code> followed by a <code class="literal">sed</code> line that creates the modified <code class="literal">.d</code> file:</p><a id="pro_id00250"/><pre class="programlisting">.PHONY: all
all: foo.o bar.o baz.o

SRCS = foo.c bar.c baz.c

%.d : %.c
→ @makedepend -f - $&lt; | sed 's,\($*\.o\)[ :]*\(.*\),$@ : $$\(wildcard \2\)\n\1 : \2,g' &gt; $@

-include $(SRCS:.c=.d)</pre><p>Removing a header file now doesn’t break the <code class="literal">make</code>: when <code class="literal">foo.d</code> is parsed, the dependency line for <code class="literal">foo.d</code> is passed through <code class="literal">$(wildcard)</code>. When there are no globbing symbols like <code class="literal">*</code> or <code class="literal">?</code> in the filename, <code class="literal">$(wildcard)</code> acts as a simple existence filter, removing from the list any files that do not exist. So if <code class="literal">header.h</code> had been removed, the first line of <code class="literal">foo.d</code> would be equivalent to this:</p><a id="pro_id00251"/><pre class="programlisting">foo.d : foo.h common.h</pre><p>The <code class="literal">make</code> would work correctly. This example makefile now works when <code class="literal">.c</code> files are added (the user just updates <code class="literal">SRCS</code> and the new <code class="literal">.d</code> file is created automatically), when <code class="literal">.c</code> files are removed (the user updates <code class="literal">SRCS</code> and the old <code class="literal">.d</code> file is ignored), when headers are added (because that requires altering an existing <code class="literal">.c</code> or <code class="literal">.h</code>, the <code class="literal">.d</code> file will be regenerated), and when headers are removed (the <code class="literal">$(wildcard)</code> hides the deletion and the <code class="literal">.d</code> file is regenerated).</p><p><a id="iddle1133" class="indexterm"/><a id="iddle1502" class="indexterm"/><a id="iddle1755" class="indexterm"/><a id="iddle1840" class="indexterm"/>A possible optimization is to remove the need for GNU <code class="literal">make</code> to restart by merging the rule that makes the <code class="literal">.d</code> file into the rule that makes the <code class="literal">.o</code>:</p><a id="pro_id00252"/><pre class="programlisting">.PHONY: all
all: foo.o bar.o baz.o

SRCS = foo.c bar.c baz.c

%.o : %.c
→ @makedepend -f - $&lt; | sed 's,\($*\.o\)[ :]*\(.*\),$@ : $$\(wildcard \2\)\n\1 : \2,g' &gt; $*.d
→ @$(COMPILE.c) -o $@ $&lt;

-include $(SRCS:.c=.d)</pre><p>Because the <code class="literal">.d</code> file is updated if and only if the <code class="literal">.o</code> file needs to be updated (both are updated when any of the sources for the <code class="literal">.o</code> change), it’s possible to have the <code class="literal">makedepend</code> happen at the same time as the compilation.</p><p>This rule uses <code class="literal">$*</code>, another GNU <code class="literal">make</code> variable. <code class="literal">$*</code> is the part of the pattern <code class="literal">%.c</code> that matches the <code class="literal">%</code>. If this rule is building <code class="literal">foo.o</code> from <code class="literal">foo.c</code>, <code class="literal">$*</code> is just <code class="literal">foo</code>. <code class="literal">$*</code> creates the name of the <code class="literal">.d</code> file that <code class="literal">makedepend</code> writes to.</p><p>This version does not use GNU <code class="literal">make</code>’s makefile remaking system. There are no rules for making <code class="literal">.d</code> files (they are made as a side effect of making the <code class="literal">.o</code> files), so GNU <code class="literal">make</code> doesn’t have to restart. This provides the best combination of accuracy and speed.</p><p>In general, it’s a bad idea to have a rule that makes multiple files because it’s impossible for GNU <code class="literal">make</code> to find the rule that makes a file if it’s created as a side effect of something else. In this case, that behavior is desired: we want to hide the creation of <code class="literal">.d</code> files from GNU <code class="literal">make</code> so it doesn’t try to make them and then have to restart.</p><p>Tom Tromey proposed a similar idea without the <code class="literal">$(wildcard)</code> trick. You can find this and more information about building dependency files on GNU <code class="literal">make</code> maintainer Paul Smith’s website at <span class="emphasis"><em><a class="ulink" href="http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/">http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/</a></em></span>.</p></div><div class="sect2" title="Doing Away with makedepend"><div class="titlepage"><div><div><h2 class="title"><a id="doing_away_with_makedepend"/>Doing Away with makedepend</h2></div></div></div><p>Additionally, it’s possible to omit <code class="literal">makedepend</code> altogether if you are using GNU <code class="literal">gcc</code>, <code class="literal">llvm</code>, or <code class="literal">clang</code>, or a similar compiler.</p><p>An <code class="literal">-MD</code> option does the work of <code class="literal">makedepend</code> at the same time as the compilation:</p><a id="pro_id00253"/><pre class="programlisting">.PHONY: all
all: foo.o bar.o baz.o

SRCS = foo.c bar.c baz.c

%.o : %.c
→ @$(COMPILE.c) -MD -o $@ $&lt;
→ @sed -i 's,\($*\.o\)[ :]*\(.*\),$@ : $$\(wildcard \2\)\n\1 : \2,g' $*.d

-include $(SRCS:.c=.d)</pre><p><a id="iddle1071" class="indexterm"/><a id="iddle1308" class="indexterm"/><a id="iddle1812" class="indexterm"/>For example, the compilation step for <code class="literal">foo.o</code> will create <code class="literal">foo.d</code> from <code class="literal">foo.c</code>. Then, <code class="literal">sed</code> is run on the <code class="literal">foo.d</code> to add the extra line for <code class="literal">foo.d</code> containing the <code class="literal">$(wildcard)</code>.</p></div><div class="sect2" title="Using gcc -MP"><div class="titlepage"><div><div><h2 class="title"><a id="using_gcc_-mp"/>Using gcc -MP</h2></div></div></div><p><code class="literal">gcc</code> also has the <code class="literal">-MP</code> option, which attempts to deal with the problem of disappearing files by creating empty rules to “build” missing files. For example, it’s possible to eliminate the <code class="literal">sed</code> magic completely, using the <code class="literal">-MP</code> option in place of <code class="literal">-MD</code>:</p><a id="pro_id00254"/><pre class="programlisting">.PHONY: all
all: foo.o bar.o baz.o

SRCS = foo.c bar.c baz.c

%.o : %.c
→ @$(COMPILE.c) -MP -o $@ $&lt;

-include $(SRCS:.c=.d)</pre><p>The <code class="literal">foo.d</code> file will look like this:</p><a id="pro_id00255"/><pre class="programlisting">foo.o : foo.h header.h common.h 
foo.h :
header.h :
common.h :</pre><p>If, for example, <code class="literal">foo.h</code> is deleted, <code class="literal">make</code> will not complain because it will find the empty rule (<code class="literal">foo.h :</code>) to build it, and the missing file error will be prevented. However, it is vital that the <code class="literal">foo.d</code> file be updated every time <code class="literal">foo.o</code> is built. If it’s not, <code class="literal">foo.d</code> will still contain <code class="literal">foo.h</code> as a prerequisite, and <code class="literal">foo.o</code> will rebuild every time <code class="literal">make</code> is run because <code class="literal">make</code> will attempt to build <code class="literal">foo.h</code> (forcing a <code class="literal">foo.o</code> build) using the empty rule.</p></div></div><div class="sect1" title="Atomic Rules in GNU make"><div class="titlepage"><div><div><h1 class="title"><a id="atomic_rules_in_gnu_make"/>Atomic Rules in GNU make</h1></div></div></div><p>A fundamental law of GNU <code class="literal">make</code> physics is that each rule builds one and only one file (called a <span class="emphasis"><em>target</em></span>). There are exceptions to that rule (which we’ll see in the rest of this section), but nevertheless, for any normal GNU <code class="literal">make</code> rule such as</p><a id="pro_id00256"/><pre class="programlisting">a: b c
→ @command</pre><p>there’s only one file mentioned to the left of the <code class="literal">:</code>. That’s the filename that gets put into the <code class="literal">$@</code> automatic variable. It’s expected that <code class="literal">command</code> will actually update that file.</p><p><a id="iddle1130" class="indexterm"/><a id="iddle1145" class="indexterm"/><a id="iddle1595" class="indexterm"/><a id="iddle1612" class="indexterm"/>This section explains what to do if a command updates more than one file and how to express that so GNU <code class="literal">make</code> knows that more than one file was updated and behaves correctly.</p><div class="sect2" title="What Not to Do"><div class="titlepage"><div><div><h2 class="title"><a id="what_not_to_do"/>What Not to Do</h2></div></div></div><p>Imagine a command that makes two files (<code class="literal">a</code> and <code class="literal">b</code>) from the same prerequisites in a single step. In this section, such a command is simulated with <code class="literal">touch a b</code>, but in reality it could be much more complex than that.</p><p><a class="xref" href="ch03.html#what_not_to_do-id00004" title="Example 3-5. What not to do">Example 3-5</a> shows what not to do:</p><div class="example"><a id="what_not_to_do-id00004"/><p class="title">Example 3-5. What not to do</p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: a b

a b: c d
→ touch a b</pre></div></div><p>At first glance <a class="xref" href="ch03.html#what_not_to_do-id00004" title="Example 3-5. What not to do">Example 3-5</a> looks correct; it seems to say that <code class="literal">a</code> and <code class="literal">b</code> are built from <code class="literal">c</code> and <code class="literal">d</code> by a single command. If you run this in <code class="literal">make</code>, you can get output like this (especially if you use the <code class="literal">-j</code> option to run a parallel build):</p><a id="pro_id00257"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
touch a b
touch a b</pre><p>The command was run twice. In this case that’s harmless, but for a real command that does real work, running twice is almost certainly the wrong thing to do. Also, if you use the <code class="literal">-j</code> option to run in parallel, you can end up with the command running more than once and simultaneously with itself.</p><p>The reason is that GNU <code class="literal">make</code> actually interprets the makefile as:</p><a id="pro_id00258"/><pre class="programlisting">.PHONY: all
all: a b

a: c d
→ touch a b

b: c d
→ touch a b</pre><p>There are two separate rules (one declares that it builds <code class="literal">a</code>; the other says it builds <code class="literal">b</code>) that both build <code class="literal">a</code> and <code class="literal">b</code>.</p></div><div class="sect2" title="Using Pattern Rules"><div class="titlepage"><div><div><h2 class="title"><a id="using_pattern_rules"/>Using Pattern Rules</h2></div></div></div><p>GNU <code class="literal">make</code> does have a way to build more than one target in a single rule using a pattern rule. Pattern rules can have an arbitrary number of target patterns and still be treated as a single rule.</p><p><a id="iddle1220" class="indexterm"/><a id="iddle1466" class="indexterm"/><a id="iddle1703" class="indexterm"/>For example:</p><a id="pro_id00259"/><pre class="programlisting">%.foo %.bar %.baz:
→ command</pre><p>This means that files with the extensions <code class="literal">.foo</code>, <code class="literal">.bar</code>, and <code class="literal">.baz</code> (and of course the same prefix that will match against the <code class="literal">%</code>) will be built with a single invocation of <code class="literal">command</code>.</p><p>Suppose that the makefile looked like this:</p><a id="pro_id00260"/><pre class="programlisting">.PHONY: all
all: a.foo a.bar a.baz

%.foo %.bar %.baz:
→ command</pre><p>Then, <code class="literal">command</code> would be invoked just once. In fact, it’s enough to specify that just one of the targets and the pattern rule will run:</p><a id="pro_id00261"/><pre class="programlisting">.PHONY: all
all: a.foo

%.foo %.bar %.baz:
→ command</pre><p>This can be very useful. For example:</p><a id="pro_id00262"/><pre class="programlisting">$(OUT)/%.lib $(OUT)/%.dll: $(VERSION_RESOURCE)
→ link /nologo /dll /fixed:no /incremental:no  \
   /map:'$(call to_dos,$(basename $@).map)'    \
   /out:'$(call to_dos,$(basename $@).dll)'    \
   /implib:'$(call to_dos,$(basename $@).lib)' \
        $(LOADLIBES) $(LDLIBS)                 \
   /pdb:'$(basename $@).pdb'                   \
   /machine:x86                                \
   $^</pre><p>This is an actual rule from a real makefile that builds a <code class="literal">.lib</code> and its associated <code class="literal">.dll</code> in one go.</p><p>Of course, if the files don’t have a common part in their names, using a pattern rule won’t work. It doesn’t work for the simple example at the beginning of this section, but there is an alternative.</p></div><div class="sect2" title="Using a Sentinel File"><div class="titlepage"><div><div><h2 class="title"><a id="using_a_sentinel_file"/>Using a Sentinel File</h2></div></div></div><p>A possible workaround to using a pattern rule is to introduce a single file to indicate whether any of the targets of a multi-target rule have been built. <a id="iddle1001" class="indexterm"/><a id="iddle1070" class="indexterm"/>Creating a single “indicator” file turns multiple files into a single file, and GNU <code class="literal">make</code> understands single files. Here’s <a class="xref" href="ch03.html#what_not_to_do-id00004" title="Example 3-5. What not to do">Example 3-5</a>, rewritten:</p><a id="pro_id00263"/><pre class="programlisting">.PHONY: all
all: a b

a b: .sentinel
→ @:

.sentinel: c d
→ touch a b
→ touch .sentinel</pre><p>The rule to build <code class="literal">a</code> and <code class="literal">b</code> can be run only once because only one prerequisite is specified (<code class="literal">.sentinel</code>). If <code class="literal">c</code> or <code class="literal">d</code> are newer, <code class="literal">.sentinel</code> gets rebuilt (and hence <code class="literal">a</code> and <code class="literal">b</code> are rebuilt). If the makefile asks for either <code class="literal">a</code> or <code class="literal">b</code>, they are rebuilt via the <code class="literal">.sentinel</code> file.</p><p>The funny <code class="literal">@:</code> command in the <code class="literal">a b</code> rule just means that there are commands to build <code class="literal">a</code> and <code class="literal">b</code> but they do nothing.</p><p>It would be nice to make this transparent. That’s where the <code class="literal">atomic</code> function comes in. The <code class="literal">atomic</code> function sets up the sentinel file automatically, based on the names of the targets to be built, and creates the necessary rules:</p><a id="pro_id00264"/><pre class="programlisting">sp :=
sp +=
sentinel = .sentinel.$(subst $(sp),_,$(subst /,_,$1))
atomic = $(eval $1: $(call sentinel,$1) ; @:)$(call sentinel,$1): $2 ; touch $$@

.PHONY: all
all: a b

$(call atomic,a b,c d)
→ touch a b</pre><p>All we’ve done is replace the original <code class="literal">a b : c d</code> rule with a call to <code class="literal">atomic</code>. The first argument is the list of targets that need to be built atomically; the second argument is the list of prerequisites.</p><p><code class="literal">atomic</code> uses the <code class="literal">sentinel</code> function to create a unique sentinel filename (in the case of targets <code class="literal">a b</code> the sentinel filename is <code class="literal">.sentinel.a_b</code>) and then sets up the necessary rules.</p><p>Expanding <code class="literal">atomic</code> in this makefile would be the same as doing this:</p><a id="pro_id00265"/><pre class="programlisting">.PHONY: all
all: a b

a b: .sentinel.a_b ; @:

.sentinel.a_b: c d ; touch $@
→ touch a b</pre><p><a id="iddle1092" class="indexterm"/><a id="iddle1189" class="indexterm"/><a id="iddle1193" class="indexterm"/><a id="iddle1209" class="indexterm"/><a id="iddle1425" class="indexterm"/><a id="iddle1562" class="indexterm"/><a id="iddle1670" class="indexterm"/><a id="iddle1704" class="indexterm"/>There’s one flaw with this technique. If you delete <code class="literal">a</code> or <code class="literal">b</code>, you must also delete the related sentinel file or the files won’t get rebuilt.</p><p>To work around this, you can have the makefile delete the sentinel file if necessary by checking to see if any of the targets being built are missing. Here’s the updated code:</p><a id="pro_id00266"/><pre class="programlisting">sp :=
sp +=
sentinel = .sentinel.$(subst $(sp),_,$(subst /,_,$1))
atomic = $(eval $1: $(call sentinel,$1) ; @:)$(call sentinel,$1):  \
$2 ; touch $$@ $(foreach t,$1,$(if $(wildcard $t),,$(shell rm -f   \
$(call sentinel,$1))))

.PHONY: all
all: a b

$(call atomic,a b,c d)
→ touch a b</pre><p>Now <code class="literal">atomic</code> runs through the targets. If any are missing—detected by the <code class="literal">$(wildcard)</code>—the sentinel file is deleted.</p></div></div><div class="sect1" title="Painless Non-recursive make"><div class="titlepage"><div><div><h1 class="title"><a id="painless_non-recursive_make"/>Painless Non-recursive make</h1></div></div></div><p>Once a makefile project reaches a certain size (usually when it has dependencies on subprojects), it’s inevitable that the build master writes a rule that contains a call to <code class="literal">$(MAKE)</code>. And right there the build master has created a recursive <code class="literal">make</code>: a <code class="literal">make</code> that executes an entire other <code class="literal">make</code> process. It’s incredibly tempting to do this because conceptually, recursive <code class="literal">make</code> is simple: if you need to build a subproject, just go to its directory and run <code class="literal">make</code> via <code class="literal">$(MAKE)</code>.</p><p>But it has one major flaw: once you start a separate <code class="literal">make</code> process, all information about dependencies is lost. The parent <code class="literal">make</code> doesn’t know whether the subproject <code class="literal">make</code> really needed to happen, so it has to run it every time, and that can be slow. Fixing that problem isn’t easy, but non-recursive <code class="literal">make</code>s are powerful once implemented.</p><p>One common objection to using non-recursive <code class="literal">make</code> is that with recursive <code class="literal">make</code> it’s possible to go to anywhere in a source code tree and type <code class="literal">make</code>. Doing so typically builds the objects that are defined by the makefile at that level in the tree (and possibly below that, if the makefile recurses).</p><p>Non-recursive <code class="literal">make</code> systems (based on <code class="literal">include</code> statements instead of <code class="literal">make</code> invocations) often do not offer this flexibility, and GNU <code class="literal">make</code> must be run from the top-level directory. Even though non-recursive GNU <code class="literal">make</code> is typically more efficient (running from the top-level directory should be quick), it’s important to be able to give developers the same level of functionality as a recursive <code class="literal">make</code> system.</p><p><a id="iddle1671" class="indexterm"/>This section outlines a pattern for a non-recursive GNU <code class="literal">make</code> system that supports the familiar <code class="literal">make</code>-anywhere style common to recursive GNU <code class="literal">make</code> systems. Typing <code class="literal">make</code> in a directory will build everything in that directory and below, but there are no recursive <code class="literal">$(MAKE)</code> invocations. The single <code class="literal">make</code> that runs knows about all the dependencies across projects and subprojects, and it can build efficiently.</p><div class="sect2" title="A Simple Recursive Make"><div class="titlepage"><div><div><h2 class="title"><a id="simple_recursive_make"/>A Simple Recursive Make</h2></div></div></div><p>Imagine a project with the following subdirectories:</p><a id="pro_id00267"/><pre class="programlisting">/src/
/src/library/
/src/executable/</pre><p><code class="literal">/src/</code> is the top-level directory and is where you’d type <code class="literal">make</code> to get a full build. Inside <code class="literal">/src/</code> is a <code class="literal">library/</code> directory that builds a library called <code class="literal">lib.a</code> from source files <code class="literal">lib1.c</code> and <code class="literal">lib2.c</code>:</p><a id="pro_id00268"/><pre class="programlisting">/src/library/lib1.c
/src/library/lib2.c</pre><p>The <code class="literal">/src/executable/</code> directory builds an executable file called <code class="literal">exec</code> from two source files (<code class="literal">foo.c</code> and <code class="literal">bar.c</code>) and links with the library <code class="literal">lib.a</code>:</p><a id="pro_id00269"/><pre class="programlisting">/src/executable/foo.c
/src/executable/bar.c</pre><p>The classic recursive <code class="literal">make</code> solution is to put a makefile in each subdirectory. Each makefile contains rules to build that directory’s objects, and a top-level makefile recurses into each subdirectory. Here are the contents of such a recursive makefile (<code class="literal">/src/makefile</code>):</p><a id="pro_id00270"/><pre class="programlisting">SUBDIRS = library executable

.PHONY: all
all:
→ for dir in $(SUBDIRS); do \
→ $(MAKE) -C $$dir;         \
→ done</pre><p>This enters each directory in turn and runs <code class="literal">make</code> to build first the library and then the executable. The dependency between the executable and the library (that is, the fact that the library needs to be built before the executable) is implicit in the order in which the directories are specified in <code class="literal">SUBDIRS</code>.</p><p>Here’s an example of an improvement on using a <code class="literal">for</code> loop using phony targets for each directory:</p><a id="pro_id00271"/><pre class="programlisting">SUBDIRS = library executable

.PHONY: $(SUBDIRS)
$(SUBDIRS):
→ $(MAKE) -C $@

.PHONY: all
all: $(SUBDIRS)

executable: library</pre><p>You unwind the loop inside the rule for <code class="literal">all</code>, create separate rules for each subdirectory, and explicitly specify the dependency between <code class="literal">executable</code> and <code class="literal">library</code>. This code is much clearer, but it’s still recursive with separate <code class="literal">make</code> invocations for each subdirectory.</p></div><div class="sect2" title="A Flexible Non-recursive make System"><div class="titlepage"><div><div><h2 class="title"><a id="flexible_non-recursive_make_system"/>A Flexible Non-recursive make System</h2></div></div></div><p>When moving to non-recursive <code class="literal">make</code>, the ideal top-level makefile would look like <a class="xref" href="ch03.html#small_non-recursive_makefile" title="Example 3-6. A small non-recursive makefile">Example 3-6</a>.</p><div class="example"><a id="small_non-recursive_makefile"/><p class="title">Example 3-6. A small non-recursive makefile</p><div class="example-contents"><pre class="programlisting">SUBDIRS = library executable

include $(addsuffix /makefile,$(SUBDIRS))</pre></div></div><p>This simply says to include the makefile from each subdirectory. The trick is to make that work! Before you see how, here are the skeletons of the contents of the makefiles in the <code class="literal">library</code> and <code class="literal">executable</code> subdirectories:</p><a id="pro_id00272"/><pre class="programlisting"># /src/library/Makefile

include root.mak
include top.mak

SRCS := lib1.c lib2.c
BINARY := lib
BINARY_EXT := $(_LIBEXT)
include bottom.mak</pre><p>and</p><a id="pro_id00273"/><pre class="programlisting"># /src/executable/Makefile

include root.mak
include top.mak
SRCS := foo.c foo.c
BINARY := exec
BINARY_EXT := $(_EXEEXT)

include bottom.mak</pre><p><a id="iddle1126" class="indexterm"/><a id="iddle1287" class="indexterm"/>Each of those makefiles specifies the source files to be built (in the <code class="literal">SRCS</code> variable), the name of the final linked binary (in the <code class="literal">BINARY</code> variable), and the type of the binary (using the <code class="literal">BINARY_EXT</code> variable, which is set from special variables <code class="literal">_LIBEXT</code> and <code class="literal">_EXEEXT</code>).</p><p>Both the makefiles <code class="literal">include</code> the common makefiles <code class="literal">root.mak</code>, <code class="literal">top.mak</code>, and <code class="literal">bottom.mak</code>, which are located in the <code class="literal">/src/</code> directory.</p><p>Because the <code class="literal">.mak</code> included makefiles are not in the subdirectories, GNU <code class="literal">make</code> needs to go looking for them. To find the <code class="literal">.mak</code> files in <code class="literal">/src</code>, do this:</p><a id="pro_id00274"/><pre class="programlisting">$ <span class="strong"><strong>make -I /src</strong></span></pre><p>Here, you use the <code class="literal">-I</code> command line option that adds a directory to the <code class="literal">include</code> search path.</p><p>It’s unfortunate to ask a user to add anything to the <code class="literal">make</code> command line. To avoid that, you can create a simple method of automatically walking up the source tree to find the <code class="literal">.mak</code> files. Here’s the actual makefile for <code class="literal">/src/ library</code>:</p><a id="pro_id00275"/><pre class="programlisting">sp :=
sp +=
_walk = $(if $1,$(wildcard /$(subst $(sp),/,$1)/$2) $(call _walk,$(wordlist 2,$(words $1),x $1),$2))
_find = $(firstword $(call _walk,$(strip $(subst /, ,$1)),$2))
_ROOT := $(patsubst %/root.mak,%,$(call _find,$(CURDIR),root.mak))

include $(_ROOT)/root.mak
include $(_ROOT)/top.mak

SRCS := lib1.c lib2.c
BINARY := lib
BINARY_EXT := $(_LIBEXT)

include $(_ROOT)/bottom.mak</pre><p>The <code class="literal">_find</code> function walks up a directory tree starting from the directory in <code class="literal">$1</code>, looking for the file named <code class="literal">$2</code>. The actual find is achieved by calling the <code class="literal">_walk</code> function, which walks up the tree, finding every instance of the file <code class="literal">$2</code> in each of the successively shorter paths from <code class="literal">$1</code>.</p><p>The block of code at the start of the makefile finds the location of <code class="literal">root.mak</code>, which is in the same directory as <code class="literal">top.mak</code> and <code class="literal">bottom.mak</code> (namely, <code class="literal">/src</code>), and saves that directory in <code class="literal">_ROOT</code>.</p><p>Then, the makefile can use <code class="literal">$(_ROOT)/</code> to <code class="literal">include</code> the <code class="literal">root.mak</code>, <code class="literal">top.mak</code>, and <code class="literal">bottom.mak</code> makefiles without any need to type anything other than <code class="literal">make</code>.</p><p><a id="iddle1609" class="indexterm"/>Here are the contents of the first included makefile (<code class="literal">root.mak</code>):</p><a id="pro_id00276"/><pre class="programlisting">_push = $(eval _save$1 := $(MAKEFILE_LIST))
_pop = $(eval MAKEFILE_LIST := $(_save$1))
_INCLUDE = $(call _push,$1)$(eval include $(_ROOT)/$1/Makefile)$(call _pop,$1)
DEPENDS_ON = $(call _INCLUDE,$1)
DEPENDS_ON_NO_BUILD = $(eval _NO_RULES := T)$(call _INCLUDE,$1)$(eval _NO_RULES :=)</pre><p>For the moment, ignore its contents and return to what these functions are used for when looking at dependencies between modules. The real work begins with <code class="literal">top.mak</code>:</p><a id="pro_id00277"/><pre class="programlisting">_OUTTOP ?= /tmp/out

.PHONY: all
all:

_MAKEFILES := $(filter %/Makefile,$(MAKEFILE_LIST))
_INCLUDED_FROM := $(patsubst $(_ROOT)/%,%,$(if $(_MAKEFILES), \
$(patsubst %/Makefile,%,$(word $(words $(_MAKEFILES)),$(_MAKEFILES)))))
ifeq ($(_INCLUDED_FROM),)
_MODULE := $(patsubst $(_ROOT)/%,%,$(CURDIR))
else
_MODULE := $(_INCLUDED_FROM)
endif
_MODULE_PATH := $(_ROOT)/$(_MODULE)
_MODULE_NAME := $(subst /,_,$(_MODULE))
$(_MODULE_NAME)_OUTPUT := $(_OUTTOP)/$(_MODULE)

_OBJEXT := .o
_LIBEXT := .a
_EXEEXT :=</pre><p>The <code class="literal">_OUTTOP</code> variable defines the top-level directory into which all binary output (object files and so on) will be placed. Here it has the default value of <code class="literal">/tmp/out</code>, and it’s defined with <code class="literal">?=</code> so it can be overridden on the command line.</p><p>Next, <code class="literal">top.mak</code> sets up the default target for GNU <code class="literal">make</code> as the classic <code class="literal">all</code>. Here it has no dependencies, but they are added later for each module that will be built.</p><p>Thereafter, a number of variables end up setting the <code class="literal">_MODULE_PATH</code> to the full path to the module directory being built. For example, when building the <code class="literal">library</code> module, <code class="literal">_MODULE_PATH</code> would be <code class="literal">/src/library</code>. Setting this variable is complex because determining the module directory has to be independent of the directory from which GNU <code class="literal">make</code> was executed (so that the library can be built from the top-level, for a <code class="literal">make all</code>, or from the individual <code class="literal">library</code> directory, for an individual developer build, or the library can even be included as a dependency on a different module).</p><p>The <code class="literal">_MODULE_NAME</code> is simply the path relative to the root of the tree with <code class="literal">/</code> replaced by <code class="literal">_</code>. In <a class="xref" href="ch03.html#what_not_to_do-id00004" title="Example 3-5. What not to do">Example 3-5</a>, the two modules have <code class="literal">_MODULE_NAME</code>s: <code class="literal">library</code> and <code class="literal">executable</code>. But if <code class="literal">library</code> had a subdirectory containing a module called <code class="literal">sublibrary</code>, then its <code class="literal">_MODULE_NAME</code> would be <code class="literal">library_sublibrary</code>.</p><p>The <code class="literal">_MODULE_NAME</code> is also used to create the <code class="literal">$(_MODULE_NAME)_OUTPUT</code> special variable, which has a computed name based on <code class="literal">_MODULE_NAME</code>. So for the <code class="literal">library</code> module, the variable <code class="literal">library_OUTPUT</code> is created with the full path of the directory into which <code class="literal">library</code>’s object files should be written. The output path is based on <code class="literal">_OUTTOP</code> and the relative path to the module being built. As a result, the <code class="literal">/tmp/out</code> tree mirrors the source tree.</p><p>Finally, some standard definitions of extensions used on filenames are set up. Definitions for Linux systems are used here, but these can easily be changed for systems such as Windows that don’t use <code class="literal">.o</code> for an object file or <code class="literal">.a</code> for a library.</p><p><code class="literal">bottom.mak</code> uses these variables to set up the rules that will actually build the module:</p><a id="pro_id00278"/><pre class="programlisting">$(_MODULE_NAME)_OBJS := $(addsuffix $(_OBJEXT),$(addprefix \
$($(_MODULE_NAME)_OUTPUT)/,$(basename $(SRCS)))) $(DEPS)
$(_MODULE_NAME)_BINARY := $($(_MODULE_NAME)_OUTPUT)/$(BINARY)$(BINARY_EXT)

ifneq ($(_NO_RULES),T)
ifneq ($($(_MODULE_NAME)_DEFINED),T)
all: $($(_MODULE_NAME)_BINARY)

.PHONY: $(_MODULE_NAME)
$(_MODULE_NAME): $($(_MODULE_NAME)_BINARY)
_IGNORE := $(shell mkdir -p $($(_MODULE_NAME)_OUTPUT))

_CLEAN := clean-$(_MODULE_NAME)
.PHONY: clean $(_CLEAN)
clean: $(_CLEAN)
$(_CLEAN):
→ rm -rf $($(patsubst clean-%,%,$@)_OUTPUT)

$($(_MODULE_NAME)_OUTPUT)/%.o: $(_MODULE_PATH)/%.c
→ @$(COMPILE.c) -o '$@' '$&lt;'
$($(_MODULE_NAME)_OUTPUT)/$(BINARY).a: $($(_MODULE_NAME)_OBJS)
→ @$(AR) r '$@' $^
→ @ranlib '$@'
$($(_MODULE_NAME)_OUTPUT)/$(BINARY)$(_EXEEXT): $($(_MODULE_NAME)_OBJS)
→ @$(LINK.cpp) $^ -o'$@'

$(_MODULE_NAME)_DEFINED := T
endif
endif</pre><p>The first thing <code class="literal">bottom.mak</code> does is set up two variables with computed names: <code class="literal">$(_MODULE_NAME)_OBJS</code> (which is the list of object files in the module computed from the <code class="literal">SRCS</code> variable by transforming the extension) and <code class="literal">$(_MODULE_NAME)_BINARY</code> (which is the name of the binary file created by the module; this would typically be the library or executable being built).</p><p><a id="iddle1115" class="indexterm"/><a id="iddle1191" class="indexterm"/><a id="iddle1544" class="indexterm"/>We include the <code class="literal">DEPS</code> variable, so the <code class="literal">$(_MODULE_NAME)_OBJS</code> variable also includes any object files that the module needs but doesn’t build. Later you’ll see how this is used to define a dependency between the library and executable.</p><p>Next, if rules for this module have not previously been set up (controlled by the <code class="literal">$(_MODULE_NAME)_DEFINED</code> variable) and have not been explicitly disabled by the <code class="literal">_NO_RULES</code> variable, the actual rules to build the module are defined.</p><p>In this example, rules for Linux are shown. This is where you’d change this example for another operating system.</p><p><code class="literal">all</code> has the current binary, from <code class="literal">$(_MODULE_NAME)_BINARY</code>, added as a prerequisite so that the module gets built when a full build is done. Then there’s a rule that associates the module name with the module binary so that it’s possible to type something like <code class="literal">make library</code> at the top level of the build to build just the library.</p><p>Then there’s a general <code class="literal">clean</code> rule and a module-specific clean (for the <code class="literal">library</code> module there’s a rule called <code class="literal">clean-library</code> to just clean its objects). <code class="literal">clean</code> is implemented as a simple <code class="literal">rm -rf</code> because all the output is organized in a specific subdirectory of <code class="literal">_OUTTOP</code>.</p><p>After that a <code class="literal">$(shell)</code> is used to set up the directory where the module’s output will go. Finally, specific rules associate the object files in this module’s output directory with source files in this module’s source directory.</p><p>With all that infrastructure in place, we can finally come to the makefile in the <code class="literal">executable</code> directory:</p><a id="pro_id00279"/><pre class="programlisting">sp :=
sp +=
_walk = $(if $1,$(wildcard /$(subst $(sp),/,$1)/$2) $(call _walk,$(wordlist 2,$(words $1),x $1),$2))
_find = $(firstword $(call _walk,$(strip $(subst /, ,$1)),$2))
_ROOT := $(patsubst %/root.mak,%,$(call _find,$(CURDIR),root.mak))

include $(_ROOT)/root.mak

$(call DEPENDS_ON,library)

include $(_ROOT)/top.mak

SRCS := foo.c bar.c
BINARY := exec
BINARY_EXT := $(_EXEEXT)
DEPS := $(library_BINARY)

include $(_ROOT)/bottom.mak</pre><p>This looks a lot like the makefile for the library, but there are differences. Because the executable needs the library, the <code class="literal">DEPS</code> line specifies that the executable depends on the binary file created by the library. And because each module has unique variables for objects and binaries, it’s easy to define that dependency by referring to <code class="literal">$(library_BINARY)</code>, which will expand to the full path to the library file created by the library module.</p><p><a id="iddle1114" class="indexterm"/><a id="iddle1135" class="indexterm"/>To ensure that <code class="literal">$(library_BINARY)</code> is defined, it’s necessary to include the makefile from the <code class="literal">library</code> directory. The <code class="literal">root.mak</code> file provides two functions that make this trivial: <code class="literal">DEPENDS_ON</code> and <code class="literal">DEPENDS_ON_NO_BUILD</code>.</p><p><code class="literal">DEPENDS_ON_NO_BUILD</code> just sets up the variables for the specified module so they can be used in the makefile. If that function were used in the <code class="literal">executable</code> makefile, the library (<code class="literal">lib.a</code>) would have to exist for the executable to build successfully. On the other hand, <code class="literal">DEPENDS_ON</code> is used here to ensure that the <code class="literal">library</code> will get built if necessary.</p><p><code class="literal">DEPENDS_ON_NO_BUILD</code> provides functionality similar to a classic recursive build, which doesn’t know how to build that library but depends on it. <code class="literal">DEPENDS_ON</code> is more flexible because without recursion, you can specify a relationship and make sure that code is built.</p></div><div class="sect2" title="Using the Non-recursive make System"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_non-recursive_make_system"/>Using the Non-recursive make System</h2></div></div></div><p>The non-recursive <code class="literal">make</code> system provides great flexibility. Here are a few examples that illustrate that the non-recursive <code class="literal">make</code> system is just as flexible as a recursive one (and more so!).</p><p>Building everything from the top level is a simple <code class="literal">make</code> (in these examples, we use the command <code class="literal">make -n</code> so the commands are clearly shown):</p><a id="pro_id00280"/><pre class="programlisting">$ <span class="strong"><strong>cd /src</strong></span>
$ <span class="strong"><strong>make -n</strong></span>
cc  -c -o '/tmp/out/library/lib1.o' '/home/jgc/doc/nonrecursive/library/lib1.c'
cc  -c -o '/tmp/out/library/lib2.o' '/home/jgc/doc/nonrecursive/library/lib2.c'
ar r '/tmp/out/library/lib.a' /tmp/out/library/lib1.o /tmp/out/library/lib2.o
ranlib '/tmp/out/library/lib.a'
cc  -c -o '/tmp/out/executable/foo.o' '/home/jgc/doc/nonrecursive/executable/foo.c'
cc  -c -o '/tmp/out/executable/bar.o' '/home/jgc/doc/nonrecursive/executable/bar.c'
g++ /tmp/out/executable/foo.o /tmp/out/executable/bar.o /tmp/out/library/lib.a -o'/tmp/out/
executable/exec'</pre><p>Cleaning everything is simple too:</p><a id="pro_id00281"/><pre class="programlisting">$ <span class="strong"><strong>cd /src</strong></span>
$ <span class="strong"><strong>make -n clean</strong></span>
rm -rf /tmp/out/library
rm -rf /tmp/out/executable</pre><p>From the top-level directory, it’s possible to ask for any individual module to be built or cleaned:</p><a id="pro_id00282"/><pre class="programlisting">$ <span class="strong"><strong>cd /src</strong></span>
$ <span class="strong"><strong>make -n clean-library</strong></span>
rm -rf /tmp/out/library
$ <span class="strong"><strong>make -n library</strong></span>
cc  -c -o '/tmp/out/library/lib1.o' '/home/jgc/doc/nonrecursive/library/lib1.c'
cc  -c -o '/tmp/out/library/lib2.o' '/home/jgc/doc/nonrecursive/library/lib2.c'
ar r '/tmp/out/library/lib.a' /tmp/out/library/lib1.o /tmp/out/library/lib2.o
ranlib '/tmp/out/library/lib.a'</pre><p><a id="iddle1796" class="indexterm"/>And if we ask that the <code class="literal">executable</code> module be built, the <code class="literal">library</code> gets built at the same time because of the dependency:</p><a id="pro_id00283"/><pre class="programlisting">$ <span class="strong"><strong>cd /src</strong></span>
$ <span class="strong"><strong>make -n executable</strong></span>
cc -c -o '/tmp/out/executable/foo.o' '/home/jgc/doc/nonrecursive/executable/foo.c'
cc -c -o '/tmp/out/executable/bar.o' '/home/jgc/doc/nonrecursive/executable/bar.c'
cc -c -o '/tmp/out/library/lib1.o' '/home/jgc/doc/nonrecursive/library/lib1.c'
cc -c -o '/tmp/out/library/lib2.o' '/home/jgc/doc/nonrecursive/library/lib2.c'
ar r '/tmp/out/library/lib.a' /tmp/out/library/lib1.o /tmp/out/library/lib2.o
ranlib '/tmp/out/library/lib.a'
g++ /tmp/out/executable/foo.o /tmp/out/executable/bar.o /tmp/out/library/lib.a -o'/tmp/out/
executable/exec'</pre><p>Okay, so much for the top level. If we pop down into the <code class="literal">library</code> module, we can build or clean it just as easily:</p><a id="pro_id00284"/><pre class="programlisting">$ <span class="strong"><strong>cd /src/library</strong></span>
$ <span class="strong"><strong>make -n clean</strong></span>
rm -rf /tmp/out/library
$ <span class="strong"><strong>make -n</strong></span>
cc  -c -o '/tmp/out/library/lib1.o' '/home/jgc/doc/nonrecursive/library/lib1.c'
cc  -c -o '/tmp/out/library/lib2.o' '/home/jgc/doc/nonrecursive/library/lib2.c'
ar r '/tmp/out/library/lib.a' /tmp/out/library/lib1.o /tmp/out/library/lib2.o
ranlib '/tmp/out/library/lib.a'</pre><p>Of course, doing this in the <code class="literal">executable</code> directory will build the <code class="literal">library</code> as well:</p><a id="pro_id00285"/><pre class="programlisting">$ <span class="strong"><strong>cd /src/executable</strong></span>
$ <span class="strong"><strong>make -n</strong></span>
cc  -c -o '/tmp/out/library/lib1.o' '/home/jgc/doc/nonrecursive/library/lib1.c'
cc  -c -o '/tmp/out/library/lib2.o' '/home/jgc/doc/nonrecursive/library/lib2.c'
ar r '/tmp/out/library/lib.a' /tmp/out/library/lib1.o /tmp/out/library/lib2.o
ranlib '/tmp/out/library/lib.a'
cc  -c -o '/tmp/out/executable/foo.o' '/home/jgc/doc/nonrecursive/executable/foo.c'
cc  -c -o '/tmp/out/executable/bar.o' '/home/jgc/doc/nonrecursive/executable/bar.c'
g++   /tmp/out/executable/foo.o /tmp/out/executable/bar.o /tmp/out/library/lib.a -o'/tmp/out/
executable/exec'</pre></div><div class="sect2" title="What About Submodules?"><div class="titlepage"><div><div><h2 class="title"><a id="what_about_submodulesquestion_mark"/>What About Submodules?</h2></div></div></div><p>Suppose that the source tree was actually</p><a id="pro_id00286"/><pre class="programlisting">/src/
/src/library/
/src/library/sublibrary
/src/executable/</pre><p><a id="iddle1196" class="indexterm"/>where there’s an additional <code class="literal">sublibrary</code> under the <code class="literal">library</code> that builds <code class="literal">slib.a</code> from <code class="literal">slib1.c</code> and <code class="literal">slib2.c</code> using the following makefile:</p><a id="pro_id00287"/><pre class="programlisting">sp :=
sp +=
_walk = $(if $1,$(wildcard /$(subst $(sp),/,$1)/$2) $(call _walk,$(wordlist 2,$(words $1),x $1),$2))
_find = $(firstword $(call _walk,$(strip $(subst /, ,$1)),$2))
_ROOT := $(patsubst %/root.mak,%,$(call _find,$(CURDIR),root.mak))

include $(_ROOT)/root.mak
include $(_ROOT)/top.mak

SRCS := slib1.c slib2.c
BINARY := slib
BINARY_EXT := $(_LIBEXT)

include $(_ROOT)/bottom.mak</pre><p>To specify that <code class="literal">library</code> has a dependency of <code class="literal">sublibrary</code> is as simple as adding a <code class="literal">DEPENDS_ON</code> call to the makefile in the library directory:</p><a id="pro_id00288"/><pre class="programlisting">sp :=
sp +=
_walk = $(if $1,$(wildcard /$(subst $(sp),/,$1)/$2) $(call _walk,$(wordlist 2,$(words $1),x $1),$2))
_find = $(firstword $(call _walk,$(strip $(subst /, ,$1)),$2))
_ROOT := $(patsubst %/root.mak,%,$(call _find,$(CURDIR),root.mak))

include $(_ROOT)/root.mak

$(call DEPENDS_ON,library/sublibrary)

include $(_ROOT)/top.mak

SRCS := lib1.c lib2.c
BINARY := lib
BINARY_EXT := $(_LIBEXT)

include $(_ROOT)/bottom.mak</pre><p>In this example, there’s no <code class="literal">DEPS</code> line, so the <code class="literal">library</code> doesn’t depend on <code class="literal">sublibrary</code> at the object level. We’re simply declaring <code class="literal">sublibrary</code> as a submodule of library that needs to be built if <code class="literal">library</code> is.</p><p>Going back and repeating the previous examples, we see that the <code class="literal">sublibrary</code> has been successfully included in the <code class="literal">library</code> build (and automatically in the <code class="literal">executable</code> build).</p><p>Here’s the full build from the top, followed by a <code class="literal">clean</code>:</p><a id="pro_id00289"/><pre class="programlisting">$ <span class="strong"><strong>cd /src</strong></span>
$ <span class="strong"><strong>make -n</strong></span>
cc  -c -o '/tmp/out/library/sublibrary/slib1.o' '/home/jgc/doc/nonrecursive/library/sublibrary/
slib1.c'
cc  -c -o '/tmp/out/library/sublibrary/slib2.o' '/home/jgc/doc/nonrecursive/library/sublibrary/
slib2.c'
ar r '/tmp/out/library/sublibrary/slib.a' /tmp/out/library/sublibrary/slib1.o /tmp/out/library/
sublibrary/slib2.o
ranlib '/tmp/out/library/sublibrary/slib.a'
cc  -c -o '/tmp/out/library/lib1.o' '/home/jgc/doc/nonrecursive/library/lib1.c'
cc  -c -o '/tmp/out/library/lib2.o' '/home/jgc/doc/nonrecursive/library/lib2.c'
ar r '/tmp/out/library/lib.a' /tmp/out/library/lib1.o /tmp/out/library/lib2.o
ranlib '/tmp/out/library/lib.a'
cc  -c -o '/tmp/out/executable/foo.o' '/home/jgc/doc/nonrecursive/executable/foo.c'
cc  -c -o '/tmp/out/executable/bar.o' '/home/jgc/doc/nonrecursive/executable/bar.c'
g++   /tmp/out/executable/foo.o /tmp/out/executable/bar.o /tmp/out/library/lib.a -o'/tmp/out/
executable/exec'
$ <span class="strong"><strong>make -n clean</strong></span>
rm -rf /tmp/out/library/sublibrary
rm -rf /tmp/out/library
rm -rf /tmp/out/executable</pre><p>Here, we ask for the <code class="literal">sublibrary</code> to be built:</p><a id="pro_id00290"/><pre class="programlisting">$ <span class="strong"><strong>cd /src</strong></span>
$ <span class="strong"><strong>make -n clean-library_sublibrary</strong></span>
rm -rf /tmp/out/library/sublibrary
$ <span class="strong"><strong>make -n library_sublibrary</strong></span>
cc -c -o '/tmp/out/library/sublibrary/slib1.o' '/home/jgc/doc/nonrecursive/library/sublibrary/
slib1.c'
cc -c -o '/tmp/out/library/sublibrary/slib2.o' '/home/jgc/doc/nonrecursive/library/sublibrary/
slib2.c'
ar r '/tmp/out/library/sublibrary/slib.a' /tmp/out/library/sublibrary/slib1.o /tmp/out/library/
sublibrary/slib2.o
ranlib '/tmp/out/library/sublibrary/slib.a'</pre><p>And if we ask that the <code class="literal">executable</code> module be built, the <code class="literal">library</code> gets built at the same time (and also the <code class="literal">sublibrary</code>) because of the dependency:</p><a id="pro_id00291"/><pre class="programlisting">$ <span class="strong"><strong>cd /src/executable</strong></span>
$ <span class="strong"><strong>make -n executable</strong></span>
cc  -c -o '/tmp/out/library/sublibrary/slib1.o' '/home/jgc/doc/nonrecursive/library/sublibrary/
slib1.c'
cc  -c -o '/tmp/out/library/sublibrary/slib2.o' '/home/jgc/doc/nonrecursive/library/sublibrary/
slib2.c'
ar r '/tmp/out/library/sublibrary/slib.a' /tmp/out/library/sublibrary/slib1.o /tmp/out/library/
sublibrary/slib2.o
ranlib '/tmp/out/library/sublibrary/slib.a'
cc  -c -o '/tmp/out/library/lib1.o' '/home/jgc/doc/nonrecursive/library/lib1.c'
cc  -c -o '/tmp/out/library/lib2.o' '/home/jgc/doc/nonrecursive/library/lib2.c'
ar r '/tmp/out/library/lib.a' /tmp/out/library/lib1.o /tmp/out/library/lib2.o
ranlib '/tmp/out/library/lib.a'
cc  -c -o '/tmp/out/executable/foo.o' '/home/jgc/doc/nonrecursive/executable/foo.c'
cc  -c -o '/tmp/out/executable/bar.o' '/home/jgc/doc/nonrecursive/executable/bar.c'
g++   /tmp/out/executable/foo.o /tmp/out/executable/bar.o /tmp/out/library/lib.a -o'/tmp/out/
executable/exec'</pre><p>Although not as simple to code as a recursive <code class="literal">make</code>, this non-recursive system is very flexible. It allows dependencies between individual binary files across modules, which is not possible with recursive <code class="literal">make</code>, and it allows this without losing the “go to any directory and type <code class="literal">make</code>” notion that engineers know.</p><p>GNU <code class="literal">make</code> is incredibly powerful (which is partly why it’s still around after so many years), but when projects become large, makefiles can get unwieldy. With what you learned in this chapter, you can now simplify makefiles to work around GNU <code class="literal">make</code>’s weaknesses so that large projects are made simpler and more reliable.</p></div></div></div></body></html>