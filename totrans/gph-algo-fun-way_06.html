<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label="45"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch4">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">DEPTH-FIRST SEARCH</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">A few natural questions arise when we consider the realm of graph search algorithms. Why do we want to search a graph? What are we looking for? Didn’t we already find all the nodes when we created the graph? To some extent, the term <i>graph search</i> undersells the generality of these algorithms. Graph search algorithms provide a mechanism for systematically traversing all the nodes in a graph. We could use this ability to search for a particular node, such as finding treasure hidden in a maze, or to otherwise enumerate and analyze the graph.</p>&#13;
<p class="TX">We’ll begin our exploration of graph search with <i>depth-first search</i>. This algorithm traverses the nodes of a graph by exploring one edge at a time leading out from the current node, progressing deeper and deeper into the graph before backtracking and trying alternate paths. It is arguably one <span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label="46"/>of the most powerful, flexible, and useful graph algorithms covered in this book, supplying the core logic for many of the more advanced algorithms in later chapters.</p>&#13;
<p class="TX">What makes depth-first search so useful is its simplicity and adaptability. It can be implemented in a relatively simple recursive function, and, with minor additions, it can compile an extensive amount of information about the graph. This allows it to serve the role of the trusty kitchen mixer, helping us create everything from basic bread to a wedding cake.</p>&#13;
<p class="TX">This chapter presents possible use cases for depth-first search, then covers the recursive and stack-based algorithms for this search. We show how depth-first search can be used to determine a graph’s connected components, then discuss two useful extensions to this search: depth-first search trees and iterative deepening.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-35"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">To provide an overview of how depth-first search works and why it’s useful, let’s go over a few cases where we might use this search in our daily lives.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-36"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring a Hedge Maze</samp></h4>&#13;
<p class="TNI1">Imagine standing at the entrance of a vast hedge maze. As nervousness sets in, you remind yourself that this isn’t a mythical Greek labyrinth with a minotaur waiting to attack the unsuspecting adventurer. You’re only facing a multi-acre challenge of your spatial and navigational abilities. The bored teenage attendant mutters a not-so-reassuring consolation: “They usually remember to patrol the maze and pick up lost hikers before closing time.”</p>&#13;
<p class="TX">In this case, graph search corresponds to searching the graph for one special node, the exit, starting at the entrance node. As shown in <a href="#fig4-1">Figure 4-1</a>, there are multiple valid ways you could represent the maze as a graph. <a href="#fig4-1">Figure 4-1(a)</a> shows the shape of the maze itself. As shown in <a href="#fig4-1">Figure 4-1(b)</a>, you could partition the physical space into cells and call each one a node with edges to reachable adjacent spaces. Alternatively, as in <a href="#fig4-1">Figure 4-1(c)</a>, you could create nodes only for the entrance, exit, and decision points. The paths between these special points become the graph’s edges.</p>&#13;
<figure class="IMG"><img id="fig4-1" class="img100" src="../images/f04001.jpg" alt="(A) shows a maze on a 5 × 5 grid. (B) shows the maze as a graph where each of the 25 grid cells corresponds to a node. (C) shows the maze as a graph with 11 nodes representing the decision points and dead ends." width="1601" height="497"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A maze (a) with two different graph representations (b) and (c)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label="47"/>We’ll return to this maze example throughout the chapter as a fun and easy way to visualize ourselves wandering the graph. The maze example also provides amusing real-world counterparts to marking nodes or choosing which edge to take. More importantly, we can add monsters at any point for a little excitement: all the best labyrinths involve some danger.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-37"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Learning a New Subject</samp></h4>&#13;
<p class="TNI1">Learning a new subject can be viewed as a graph exploration problem. Each node represents a subtopic of interest and edges represent the references between them. The graph search represents the learning journey through the various subtopics. The goal is not to reach a particular node, but rather to cover relevant parts of the topic graph.</p>&#13;
<p class="TX">For example, consider the general topic of geology. An intrepid student sets out to learn everything they can about the subject, starting with the topic of rocks. As they read about each subtopic, they build a graph of related knowledge, as shown in <a href="#fig4-2">Figure 4-2</a>. Their studies follow threads deep into the details. A reference to igneous rocks leads to an interest in obsidian, then volcanoes, and then making the classic baking soda and vinegar volcano science project. Another path takes them through metamorphic rocks to marble, where they venture down a related path of interior decorating and flooring installation.</p>&#13;
<figure class="IMG"><img id="fig4-2" class="img100" src="../images/f04002.jpg" alt="A graph representing learning topics. Nodes represent topics, such as volcano and rocks, and are connected to adjacent topics. Rocks shares edges with igneous, metamorphic, and sedimentary." width="1387" height="723"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: A graph of subtopics starting from the topic of rocks</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The graph in <a href="#fig4-2">Figure 4-2</a> is woefully incomplete. Not only are many fascinating subjects (such as subduction zones and bauxite) omitted, but there are also more connections linking the subjects than the figure can show. Many different rocks would share links to common elements or minerals. Exploring the entire topic graph for this one area could take a lifetime. As we will see in this chapter and the next, the type of search we use can have a profound impact on the order in which we approach the topics.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label="48"/>&#13;
<h4 class="H2" id="sec4"><span id="h-38"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Reachability</samp></h4>&#13;
<p class="TNI1">In our daily lives, we often want to know whether some path exists to a certain node from a given starting node. For example, we might use a graph of flights to check whether we can travel between two cities, or we might use a social network to check if a rumor will spread from one person to another.</p>&#13;
<p class="TX">Consider the network of people represented in <a href="#fig4-3">Figure 4-3</a>. Each node represents a person, and an edge from node <i>u</i> to node <i>v</i> indicates that person <i>u</i> is willing to share information with person <i>v</i>. A useful factoid discovered by person 0 can be passed through the graph to persons 1, 3, and 4. In the case of person 3, the information first travels through persons 1 and 4. However, persons 2 and 5 are left out altogether, because there is no path of knowledge-sharing that goes to either of them.</p>&#13;
<figure class="IMG"><img id="fig4-3" class="img40" src="../images/f04003.jpg" alt="A directed graph with six nodes. Node 5 has two outgoing edges to nodes 2 and 4 and a single incoming edge from node 2." width="502" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: An example directed graph with six nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We will explore the concept of <i>reachability</i> and <i>connected components</i> for undirected graphs later in this chapter, and we’ll discuss algorithms for those problems on directed graphs in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>. For now, it is sufficient to see how a graph search can answer the reachability question. The starting node <i>S</i> and goal node <i>G</i> are given. All we need to do is start a search from node <i>S</i> and check whether it finds node <i>G</i>. If so, there must exist some path between them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h-39"/><samp class="SANS_Futura_Std_Bold_B_11">Recursive Depth-First Search</samp></h3>&#13;
<p class="TNI1">We commonly implement depth-first search as a <i>recursive algorithm</i>, where the core functionality is called once for each node. This section presents the code for this search and shows how it progresses through an example graph.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1"><a href="#list4-1">Listing 4-1</a> shows a bare-bones version of depth-first search.</p>&#13;
<span id="list4-1"/>&#13;
<pre><code>def dfs_recursive_basic(g: Graph, ind: int, seen: list): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> seen[ind] = True&#13;
    current: Node = g.nodes[ind]&#13;
&#13;
    for edge in current.get_edge_list():&#13;
        neighbor: int = edge.to_node&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if not seen[neighbor]:&#13;
            dfs_recursive_basic(g, neighbor, seen)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label="49"/>&#13;
&#13;
def depth_first_search_basic(g: Graph, start: int):&#13;
    seen: list = [False] * g.num_nodes&#13;
    dfs_recursive_basic(g, start, seen)&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: The core depth-first search recursive function</samp></p>&#13;
<p class="TX">The recursive helper function takes several pieces of information: the graph itself (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>), the index of the current node being explored (<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>), and a list mapping each node to whether it has already been visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>). The code starts by marking the current node as visited <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> and retrieving the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> data structure. It then checks each of the node’s neighbors by iterating through the list of edges. For any node that has not already been visited <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>, it recursively calls the search on that node.</p>&#13;
<p class="TX">The outer function sets up the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> list and starts the depth-first search from a specific starting node index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>). This outer function searches from only a single starting node and thus visits only nodes that are reachable from that node. If we want to visit every node, we need to start a search from every previously unseen node. As shown in <a href="#list4-2">Listing 4-2</a>, we expand the outer function to iterate over the nodes in order and call the recursive depth-first search from every unseen node.</p>&#13;
<span id="list4-2"/>&#13;
<pre><code>def depth_first_search_basic_all(g: Graph): &#13;
    seen: list = [False] * g.num_nodes&#13;
    for ind in range(g.num_nodes):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if not seen[ind]:&#13;
            dfs_recursive_basic(g, ind, seen)&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: A depth-first search that explores all nodes in the graph</samp></p>&#13;
<p class="TX">After initializing the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> list, the code loops over each node index, checks whether it has been visited in a previous depth-first search <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>, and, if not, starts a new depth-first search from that node.</p>&#13;
<p class="TX">While this code performs a depth-first search, it doesn’t do anything interesting with the search. This is like taking a nice walk through the maze, but not recording anything about the solution. Let’s consider the simple addition of keeping track of our path. This is equivalent to bringing a notebook into the maze and recording which directions we take.</p>&#13;
<p class="TX">The code for recording the path traveled during the depth-first search uses an additional list—the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> node index visited immediately before the current one:</p>&#13;
<pre><code>def dfs_recursive_path(g: Graph, ind: int, seen: list, last: list): &#13;
    seen[ind] = True&#13;
    current: Node = g.nodes[ind]&#13;
&#13;
    for edge in current.get_edge_list():&#13;
        neighbor: int = edge.to_node&#13;
        if not seen[neighbor]:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> last[neighbor] = ind&#13;
            dfs_recursive_path(g, neighbor, seen, last)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label="50"/>&#13;
&#13;
def depth_first_search_path(g: Graph) -&gt; list: &#13;
    seen: list = [False] * g.num_nodes&#13;
    last: list = [-1] * g.num_nodes&#13;
&#13;
    for ind in range(g.num_nodes):&#13;
        if not seen[ind]:&#13;
            dfs_recursive_path(g, ind, seen, last)&#13;
    return last&#13;
</code></pre>&#13;
<p class="TX">The recursive function starts the same way as the earlier basic version. The current node’s index is marked as seen, the current node is retrieved, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop checks whether each of the node’s neighbors has already been visited. It is only when exploring new nodes that there is a difference in behavior. Before recursively calling the depth-first search on the new node, the code records that the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>) immediately preceded the next node (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>) <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. As discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list provides all the information needed to reconstruct the path taken by the search.</p>&#13;
<p class="TX">The outer function is similarly modified to initialize and pass in this list of previous nodes <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list uses an indicator value of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to indicate that there is no preceding node. Nodes with values of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> at the end of the search were the starting nodes for the various depth-first searches.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig4-4">Figure 4-4</a> shows an example of recursive depth-first search on an undirected graph with 10 nodes. Each subfigure shows the state immediately after the current node is marked seen in the function. The dashed circle indicates the current node being explored. The shaded nodes are the ones that have been visited (and thus marked seen). The <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> vector shows how the path through the graph evolves during the search.</p>&#13;
<p class="TX">The search starts in <a href="#fig4-4">Figure 4-4(a)</a> at node 0, which has three neighbors: nodes 1, 5, and 7. We can visualize this in the context of an adventurer exploring a labyrinth (a little more exciting than a hedge maze). Node 0 represents the adventurer standing at the first intersection, considering the three possible branches ahead. They do not know which one will lead to the exit and which will result in a dead end.</p>&#13;
<p class="TX">The search chooses the first neighbor, node 1, and recursively triggers a depth-first search. During the exploration of node 1 in <a href="#fig4-4">Figure 4-4(b)</a>, we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> has been updated to indicate that node 1 was reached from node 0. As our adventurer walks from intersection 0 to intersection 1, they record this step in a little notebook to preserve the information for future generations.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label="51"/>&#13;
<figure class="IMG"><img id="fig4-4" class="img70" src="../images/f04004.jpg" alt="Ten subfigures show the stages of the search. In (A), node 0 is circled. In (B), node 1 is now circled and the last array’s entry for index 1 has been updated from -1 to 0." width="1674" height="2316"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: A recursive depth-first search on a graph with 10 nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_52" aria-label="52"/>Depth-first search always moves from one node to a directly connected one. Similarly, our adventurer continues down one path until they hit a dead end. Then, possibly full of panic and dread, they backtrack to try alternate loops while firmly hoping they do not run into any monsters or sarcastic maze attendants. Since backtracking consists of returning to an adjacent room, it makes physical sense.</p>&#13;
<p class="TX">The search continues through the entire graph, recursively exploring the neighbors in order of increasing node index. In the labyrinth example, this corresponds to our explorer wandering deeper into the maze and backtracking at dead ends. Because of the structure of both the graph and the depth-first search, the path to reach a node is not necessarily the shortest. For example, while node 5 can be reached directly from node 0, the search encounters it via the path [0, 1, 2, 4, 9, 8, 5].</p>&#13;
<p class="TX">In this example, all the nodes were reachable from a single starting node. However, as noted in the last section, this might not always be the case. As shown in <a href="#list4-2">Listing 4-2</a>, we might need to start multiple depth- first searches from different initial nodes in order to fully cover the graph.</p>&#13;
<p class="TX">The simplicity of depth-first search can be a drawback. The decision of which neighbor to explore is arbitrary (here based on index ordering), instead of using information we might have about the world. If our adventurer is in a labyrinth with an exit to the west, they might prioritize moving west to moving east. We will see some approaches for incorporating such heuristic information in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-42"/><samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search with a Stack</samp></h3>&#13;
<p class="TNI1">Instead of using recursion, we can also implement depth-first search as an iterative function by using a <i>stack</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2"><span id="sec9"/><span id="h-43"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1"><a href="#list4-3">Listing 4-3</a> uses the standard Python <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp> as our stack (with <samp class="SANS_TheSansMonoCd_W5Regular_11">append</samp> serving as the traditional stack <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>).</p>&#13;
<span id="list4-3"/>&#13;
<pre><code>def depth_first_search_stack(g: Graph, start: int) -&gt; list: &#13;
    seen: list = [False] * g.num_nodes&#13;
    last: list = [-1] * g.num_nodes&#13;
    to_explore: list = []<span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label="53"/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> to_explore.append(start)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> while to_explore:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> ind = to_explore.pop()&#13;
        if not seen[ind]:&#13;
            current: Node = g.nodes[ind]&#13;
            seen[ind] = True&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> all_edges: list = current.get_sorted_edge_list()&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> all_edges.reverse()&#13;
            for edge in all_edges:&#13;
                neighbor: int = edge.to_node&#13;
                if not seen[neighbor]:&#13;
                    last[neighbor] = ind&#13;
                    to_explore.append(neighbor)&#13;
    return last&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: A stack-based depth-first search</samp></p>&#13;
<p class="TX">The code for the iterative depth-first search starts by initializing our helper data structures. In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> lists, the function also uses a stack named <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp> to track which node indices it needs to explore in the future. The function starts by pushing the initial node onto the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp> stack <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The majority of the work in the function is done within a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that iterates over the elements in <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp> until the stack is empty <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. At each iteration, the top index is popped from the stack <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> and, if it hasn’t previously been seen, is explored. As in the recursive function, the code retrieves the node data structure and marks the index as having been seen. It then retrieves a list of all edges <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates over all outgoing edges; the code sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> value of the as-yet-unseen nodes and adds them to the stack.</p>&#13;
<p class="TX">For consistency of ordering with other examples, the code in <a href="#list4-3">Listing 4-3</a> reverses the list to examine neighbors in <i>decreasing</i> order of the neighbor’s index <span class="CodeAnnotationCode" aria-label="annotation5">❺</span>. This is not a necessary component of the algorithm.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2"><span id="sec10"/><span id="h-44"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig4-5">Figure 4-5</a> shows the execution of the iterative depth-first search using a stack. As in <a href="#fig4-4">Figure 4-4</a>, the current node is indicated with a dashed circle and the visited nodes are shaded.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label="54"/>&#13;
<figure class="IMG"><img id="fig4-5" class="img100" src="../images/f04005.jpg" alt="Eleven subfigures show the stages of the search. In (B), node 0 is circled and the last array has values of 0 for entries 1, 5, and 7. In (C), node 1 is now circled and the last array’s entry for index 2 has been updated from -1 to 1." width="1671" height="1666"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: An iterative depth-first search on a graph with 10 nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This implementation of the stack-based approach differs from the recursive implementation in two interesting ways. First, the last array changes to reflect the <i>latest</i> path leading to the node before the node is visited. In <a href="#fig4-5">Figure 4-5(b)</a>, the last list indicates the path to node 5 comes from node 0, because the search has seen node 5 is a neighbor of node 0. However, as the depth-first search progresses, the entry for node 5 is updated. In <a href="#fig4-5">Figure 4-5(d)</a>, the search finds a more recent path to node 5 through node 2. In <a href="#fig4-5">Figure 4-5(h)</a>, it finds another path through node 8.</p>&#13;
<p class="TX">Second, the stack of nodes to explore in this case includes <i>duplicates</i>, such as the three instances of node 5 in <a href="#fig4-5">Figure 4-5(h)</a>. This is because, as described in the previous paragraph, depth-first search may see multiple paths to a node as it explores more deeply. These duplicates do not affect <span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label="55"/>the accuracy of the algorithm because we check that a node is unvisited whenever we pop an index off the stack. However, they can increase memory usage. With modifications, and an additional running-time cost, we could extend the code to keep only the instance of the index that is highest on the stack.</p>&#13;
<p class="TX">The difference between the recursive and stack-based approaches corresponds to how our explorer tracks their journey through the labyrinth. In both cases, they note which rooms they have visited in their <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> notebook. In the stack-based approach, however, they maintain a second notebook labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>. Instead of just walking into unvisited adjacent rooms, as in the recursive approach, the explorer carefully writes out all unvisited rooms adjacent to their current room. Before changing rooms, they check which room they most recently added to their notebook and proceed to that one.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-45"/><samp class="SANS_Futura_Std_Bold_B_11">Finding Connected Components</samp></h3>&#13;
<p class="TNI1">We can use depth-first search to find the sets of connected components in an undirected graph. As discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, a connected component in an undirected graph is a set of nodes such that each node in the set can reach every other node in the set. If we start a depth-first search from a single node in the graph, it will visit only the nodes reachable from that starting node. In an undirected graph, these visited nodes make up a connected component. By rerunning the depth-first search from any unseen nodes, as in <a href="#list4-2">Listing 4-2</a>, we can map all connected components in a graph.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h-46"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The following code conducts a depth-first search from each unseen node, while also maintaining information on which node is in which connected component:</p>&#13;
<pre><code>def dfs_recursive_cc(g: Graph, ind: int, component: list, curr_comp: int):  &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> component[ind] = curr_comp&#13;
    current: Node = g.nodes[ind]&#13;
&#13;
    for edge in current.get_edge_list():&#13;
        neighbor: int = edge.to_node&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if component[neighbor] == -1:&#13;
            dfs_recursive_cc(g, neighbor, component, curr_comp)&#13;
&#13;
def dfs_connected_components(g: Graph) -&gt; list:&#13;
    component: list = [-1] * g.num_nodes&#13;
    curr_comp: int = 0&#13;
&#13;
    for ind in range(g.num_nodes):&#13;
        if component[ind] == -1:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> dfs_recursive_cc(g, ind, component, curr_comp)&#13;
            curr_comp += 1&#13;
&#13;
    return component&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label="56"/>The code modifies the recursive depth-first search function so that it uses a single list (<samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>) to track both whether a node has been visited and, if so, which component it is in. The recursive function starts by setting the current node’s component <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Before exploring a neighbor, it checks whether it is already part of an existing component (and thus visited) <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">The outer function starts by setting up the helper data structures, including a list mapping each node to its component number (<samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>) and a counter of the current component number (<samp class="SANS_TheSansMonoCd_W5Regular_11">curr_comp</samp>). As with the exhaustive depth-first search from <a href="#list4-2">Listing 4-2</a>, the code then iterates over each node and checks whether it has been visited. If not, it starts a depth-first search from that node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. During each depth-first search, it fills in more values of the <samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp> list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2"><span id="sec13"/><span id="h-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig4-6">Figure 4-6</a> shows an example of this algorithm on a graph with three connected components. Shaded circles indicate the nodes seen after each iteration, and the dashed circle indicates the starting node for that iteration’s search.</p>&#13;
<figure class="IMG"><img id="fig4-6" class="img100" src="../images/f04006.jpg" alt="A graph with eight nodes and three connected components. In subfigure B, node 0 is circled and nodes 0, 1, 2, and 4 are shaded.]" width="1524" height="1270"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: The steps of connected component detection based on depth-first search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label="57"/><a href="#fig4-6">Figure 4-6(a)</a> shows the state of the graph before the first search, when none of the nodes have been seen or assigned a component number. As shown in <a href="#fig4-6">Figure 4-6(b)</a>, the first search starts at node 0 and finds the component {0, 1, 2, 4}. <a href="#fig4-6">Figure 4-6(c)</a> shows the second search starting at node 3, the first unseen node, and finding the component {3, 7}. The final search in <a href="#fig4-6">Figure 4-6(d)</a> starts at node 5 and finds the component {5, 6}.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h-48"/><samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search Trees and Forests</samp></h3>&#13;
<p class="TNI1">If we save the edges traversed during a depth-first search, we can capture useful information about the structure of both the search and the graph itself. The connected components from the previous section are only one such type of information. Consider searching an undirected graph like the one shown in <a href="#fig4-7">Figure 4-7(a)</a>.</p>&#13;
<figure class="IMG"><img id="fig4-7" class="img100" src="../images/f04007.jpg" alt="(A) shows an undirected graph with seven nodes. Node 0 connected to nodes 1 and 4. (B) shows a tree with node 0 at the root and nodes 1 and 4 as its two children." width="1231" height="633"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: An undirected graph (a) and an example depth-first search tree (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The order in which a particular search explores the nodes (and traverses the edges) defines a tree structure called a <i>depth-first search tree</i> (or sometimes just a <i>depth-first tree</i>) that summarizes the search. Each edge traversed is included in the tree. The hierarchy of nodes is determined by the order in which depth-first search encounters them. If the search progresses from node <i>u</i> to an unvisited node <i>v</i>, then <i>u</i> will be the parent of <i>v</i> in the tree. Alternatively, using the concept of our <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array from the code in this chapter, the parent of a tree node within index <i>i</i> is <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i]</samp>. <a href="#fig4-7">Figure 4-7(b)</a> shows the depth-first search tree for a search starting at node 0.</p>&#13;
<p class="TX">Depth-first search trees are not unique, but rather they depend on where the search starts, as shown in <a href="#fig4-8">Figure 4-8</a>. Starting the search at node 2 of the same undirected graph in <a href="#fig4-8">Figure 4-8(a)</a> leads to a different depth-first search tree in <a href="#fig4-8">Figure 4-8(b)</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label="58"/>&#13;
<figure class="IMG"><img id="fig4-8" class="img100" src="../images/f04008.jpg" alt="(A) shows the same undirected graph as Figure 4-7(a). (B) shows a tree with node 2 at the root and nodes 1, 3, and 5 as its children." width="1148" height="546"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: An undirected graph (a) and an alternate depth-first search tree (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As noted earlier, a single depth-first search might not explore the entire graph, meaning we might need to run multiple depth-first searches for completeness. This gives rise to the concept of a <i>depth-first search forest</i> (or, alternately, just a <i>depth-first forest</i>), in which each individual depth-first search generates a single tree data structure with the initial node as the root. The forest is the collection of individual trees. As shown in <a href="#fig4-9">Figure 4-9</a>, this arises naturally for undirected graphs anytime there are disconnected components. The two disconnected components {0, 1, 2, 3, 4, 6} and {5, 7, 8} in <a href="#fig4-9">Figure 4-9(a)</a> form two different trees in <a href="#fig4-9">Figure 4-9(b)</a>.</p>&#13;
<figure class="IMG"><img id="fig4-9" class="img100" src="../images/f04009.jpg" alt="(A) shows a graph with two connected components. (B) shows two trees, one with node 0 as a root and one with node 5 as the root." width="1281" height="521"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: An undirected graph with two non-connected components (a) and example depth-first search trees (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In directed graphs, whether we need to run multiple searches can depend on our chosen starting node. <a href="#fig4-10">Figure 4-10</a> shows an example directed graph and its depth-first search forest. <a href="#fig4-10">Figure 4-10(a)</a> depicts the original directed graph, while <a href="#fig4-10">Figure 4-10(b)</a> shows the depth-first search forest that results from checking the nodes in order of increasing index.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label="59"/>&#13;
<figure class="IMG"><img id="fig4-10" class="img100" src="../images/f04010.jpg" alt="(A) shows a directed graph with nine nodes. (B) shows three trees with root nodes 0, 5, and 7." width="1677" height="526"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: An example graph (a) and a corresponding depth-first search forest (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because we are ordering by increasing index, we check node 5 before either node 7 or 8. This results in a separate tree for 5 in our forest because we cannot reach any other node from 5. However, 5 is reachable by nodes 7 and 8. If we had checked either of those nodes first, then node 5 would have been in their tree. The structure of the forest is determined by both the graph and the order in which we search the nodes.</p>&#13;
<p class="TX">In later chapters we will use the structure of depth-first search trees to help us understand the behavior of depth-first search itself. For now, just know that these trees capture information about the progression of depth-first search through a given graph.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-49"/><samp class="SANS_Futura_Std_Bold_B_11">Iterative Deepening</samp></h3>&#13;
<p class="TNI1">One major disadvantage of depth-first search is that it can waste time on long (or deep) dead ends when there is a closer state of interest. Imagine a spelunker lost in an underground cave system. Multiple paths branch out ahead of them, some leading toward the surface, others turning deeper into the caves. To make it out alive, they would like to use a search strategy that doesn’t require a 10-mile trip farther underground only to hit a dead end, forcing them to backtrack and try a different option.</p>&#13;
<p class="TX"><i>Iterative deepening</i> is a strategy to limit excessively deep paths during a depth-first search. Instead of continuing along one path until it ends, the algorithm starts with a predefined depth and cuts off exploration when that depth is reached. If the entire search returns without finding the objective, iterative deepening increases the maximum depth and reruns the search. It continues this process until the objective is found or the entire graph is searched.</p>&#13;
<p class="TX">Consider what happens if our lost spelunker tethers themselves to a fixed-length rope. The spelunker uses the rope to limit how far into the cave system they’re willing to venture. They follow one path until they hit the end of the rope. Even if there are more passages ahead, they backtrack and explore alternative paths that are still reachable with the current tether. Only when they have exhausted all possible paths do they upgrade <span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label="60"/>to a longer tether. This prevents them from going too far in the wrong direction before trying some of the other options.</p>&#13;
<p class="TX">At first glance, iterative deepening might seem like a colossal waste. It ends up exploring nearby nodes multiple times (with multiple max depths). A node one step from the starting node would be explored every iteration. Similarly, our spelunker will visit the first intersection multiple times.</p>&#13;
<p class="TX">Yet this approach can be useful in some situations. Consider a tree-like graph as shown in <a href="#fig4-11">Figure 4-11</a>. A normal depth-first search will progress down a single branch until the very end. If the tree is deep, this can be quite a few nodes.</p>&#13;
<figure class="IMG"><img id="fig4-11" class="img30" src="../images/f04011.jpg" alt="A binary tree with five layers, branching from left to right." width="461" height="836"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: A graph that branches out like a tree</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In contrast, as shown in <a href="#fig4-12">Figure 4-12</a>, iterative deepening effectively searches the tree level by level. During the first iteration (max depth of 1), only three nodes are explored. During the second iteration (max depth of 2), seven nodes are explored, including four new nodes.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label="61"/>&#13;
<figure class="IMG"><img id="fig4-12" class="img100" src="../images/f04012.jpg" alt="(A) shows the binary tree from Figure 4-11 with only the root node shaded. (B) shows the same binary tree with the root node and its two children shaded. (C) shows the same tree with the leftmost seven nodes shaded." width="1586" height="875"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The first three iterations of iterative deepening</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For a balanced, complete binary tree like the one in <a href="#fig4-11">Figure 4-11</a>, each iteration takes approximately twice the time and explores twice the nodes of the iteration before it. As we will see in the next chapter, iterative deepening results in a search pattern similar to breadth-first search.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h-50"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">Depth-first search is a core graph algorithm that we will use throughout the rest of this book, building numerous extensions from its simple recursive formulation. In the world of graph algorithms, this search is a fundamental building block. Later in the book, we’ll use graph search algorithms, including many modifications of depth-first search, to uncover the inherent ordering of nodes in directed graphs or propose node labeling in graph coloring.</p>&#13;
<p class="TX">Unfortunately, depth-first search is not always the perfect solution. It does not use heuristics when choosing the next node to explore. Worse, it is prone to traversing long dead ends.</p>&#13;
<p class="TX">Upcoming chapters will cover both techniques that build from depth-first search and alternate search algorithms that avoid some of its pitfalls. First, however, we consider a different type of search: breadth-first search.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>