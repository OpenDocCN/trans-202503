- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Distributing Security Resources to Guard a Space
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分配安全资源以保护空间
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'The remainder of the book will focus on a single, extremely practical application.
    Known as the art gallery problem, this classic application has plenty of research
    for us to leverage and deals with efficiently distributing security resources
    to guard a space. Efficiency is an imperative for today’s security teams: there
    are always more assets to protect than there are resources to protect them. In
    its grandest form, the art gallery problem ties together the two main disciplines
    we’ve been studying: graph theory and computational geometry. It’s fitting, then,
    that this part of the book will also represent the most complete Python application
    yet, going beyond a conceptual design and into the realm of a full-fledged software
    project. We’ll cover the design, development, and delivery options for a modern
    Python project, including graphics, distributed computation, and licensing your
    application to users.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分将专注于一个单一且极具实用性的应用。这个经典应用被称为艺术画廊问题，它有大量的研究可以为我们所用，并涉及如何高效地分配安全资源来保护一个空间。效率是当今安全团队的首要任务：保护的资产总是比保护这些资产的资源要多。在其最宏大的形式下，艺术画廊问题将我们所学习的两大主要学科结合起来：图论和计算几何。因此，这一部分也将代表本书迄今为止最完整的Python应用，超越了概念设计，进入了完整软件项目的领域。我们将涉及现代Python项目的设计、开发和交付选项，包括图形、分布式计算以及如何将你的应用授权给用户。
- en: The goal for this part of the book is to develop a *minimum viable product (MVP)*,
    which can be considered a step up from a proof of concept. As you’ve seen, a proof
    of concept proves that an idea is worth pursuing and defines the framework for
    future development. It’s usually constrained to only the functions necessary to
    get an idea off the ground—no bells or whistles included. An MVP design, on the
    other hand, is concerned with the smallest number of features you could produce
    to bring an idea to market and “be competitive.” Typically this means adding features
    like a GUI as well as user-friendly elements, such as save and restore functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这一部分的目标是开发一个*最小可行产品（MVP）*，它可以被看作是概念验证的一个进阶版本。如你所见，概念验证证明一个想法值得追求，并定义了未来开发的框架。它通常仅限于实现让想法得以起步所需的基本功能——没有任何多余的附加功能。而MVP设计则关注你能开发的最少功能集，以便将一个想法推向市场并“具备竞争力”。通常，这意味着添加像图形用户界面（GUI）以及用户友好的元素，如保存和恢复功能。
- en: 'There’s no exact set of features that make an application viable, because they’re
    ultimately dictated by the expectations of the users in that particular market.
    For example, in the security market, users have come to expect features like single
    sign-on (SSO), data encryption, push notifications, and so on. Does this mean
    you need to develop all of these features before you can bring a security tool
    to the market? Absolutely not! Think minimally and ask yourself, “What features
    do all the applications similar to mine share?” When you’re developing a product
    for users, it’s tempting to try to anticipate all their needs up front, but this
    mentality is impractical and expensive: you’ll often end up solving problems that
    no one would have encountered (edge-case code) or developing features that only
    confuse new users. If you instead release a product that contains a minimal set
    of clearly labeled features, you can get feedback on the actual problems users
    see and conveniences they’re missing. Iterative improvement plans allow you to
    focus development time on features that will actually be useful.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一套确切的功能组合能够使一个应用程序变得可行，因为这些功能最终是由特定市场用户的期望决定的。例如，在安全市场中，用户已经习惯了像单点登录（SSO）、数据加密、推送通知等功能。这是否意味着在推出一个安全工具之前，你需要开发所有这些功能？绝对不是！要以最简的方式思考，并问自己：“所有与我类似的应用程序都具备哪些功能？”当你为用户开发产品时，可能会很容易想提前预测他们的所有需求，但这种心态既不现实也很昂贵：你往往会解决一些没有人遇到的问题（边缘情况代码），或者开发一些只会让新用户困惑的功能。如果你发布一个只包含少量明确标注功能的产品，你就能获得关于用户实际遇到的问题和他们缺失的便利功能的反馈。迭代改进计划能让你把开发时间集中在那些实际有用的功能上。
- en: Now let’s jump into the art gallery problem, which asks, “What is the minimum
    number of guards that need to be placed in a gallery (represented by an *n*-vertex
    simple polygon) such that all points of the interior are visible?” This is a resource
    planning problem similar to the fire station placement problem from [Chapter 9](c09.xhtml).
    A good plan for the placement of security personnel, checkpoints, and monitoring
    devices can reduce the number of incidents a security team will need to respond
    to from the start. It can also improve the response time when an incident does
    occur, thus reducing the overall risk. Unfortunately, there are often differing
    levels of understanding among human planners on a security team, which can lead
    to poorly planned (or poorly implemented) security controls. That’s why I’m always
    searching for ways to automate portions of my team’s planning.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探讨艺术画廊问题，它问的是：“在一个画廊中（由一个*n*顶点的简单多边形表示），需要放置最少的守卫才能确保所有内部点都能被看到？” 这是一个资源规划问题，类似于[第9章](c09.xhtml)中的消防站布置问题。一个好的安全人员、检查点和监控设备布置计划可以减少从一开始就需要响应的事件数量。它还可以在发生事件时改善响应时间，从而降低总体风险。不幸的是，安全团队中的人类规划人员通常对问题的理解程度不同，这可能导致计划不当（或实施不当）的安全控制。这就是为什么我总是在寻找自动化我们团队部分规划的方式。
- en: 'It was during one of these searches that I discovered the art gallery problem,
    which addressed the very problem I was researching: the efficient deployment of
    security resources for buildings with what we’ll call “untraditional” layouts.
    As you’ll see, not all building designs lend themselves equally well to being
    guarded, so before we get into the details of the problem, we’ll cover the use
    cases for the application we plan to develop. Then we’ll be ready to start developing
    the core of the application logic. We’ll cover the existing research and show
    the theory in its simplest form. We’ll then move on to defining the two data representations
    we’re going to use in solving the problem and discuss the data structures. Finally,
    we’ll go beyond the base model to allow for more realistic deployments by adding
    advanced concepts like field of view and budget constraints.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这些搜索过程中，我发现了艺术画廊问题，它解决了我正在研究的那个问题：如何高效地部署安全资源，尤其是对于那些我们称之为“非传统”布局的建筑。如你所见，并非所有的建筑设计都同样适合守卫，因此在深入问题细节之前，我们将先介绍我们计划开发的应用程序的使用案例。然后，我们将准备好开始开发应用程序的核心逻辑。我们会介绍现有的研究，并以最简单的形式展示理论。接下来，我们将定义用于解决问题的两种数据表示，并讨论数据结构。最后，我们将超越基础模型，加入诸如视野和预算限制等高级概念，从而实现更为现实的部署。
- en: Determining the Minimum Number of Guards
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定最小守卫人数
- en: 'We’ll use the original problem statement as our first use case: a user wants
    to know the minimum number of guards to protect an unconventional floor plan.
    We want all the guards together to be able to observe the whole gallery (all points
    of the interior, or the walls, in the original problem statement). For this use
    case, our application will need functions that can encode floor plans in a data
    format the computer can analyze as well as an algorithm that can do the actual
    guard placement. We’ll go through that in the rest of this chapter, once we’ve
    covered a few more use cases.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用原始问题陈述作为第一个使用案例：一个用户想知道保护一个非常规楼层平面图所需的最小守卫人数。我们希望所有的守卫一起能够观察整个画廊（在原始问题陈述中，所有的内部点或墙壁）。对于这个使用案例，我们的应用程序需要能够将楼层平面图编码成计算机可以分析的数据格式的功能，以及一个可以执行实际守卫布置的算法。我们将在本章的后续部分介绍这些内容，先介绍一些其他的使用案例。
- en: 'The next use case deals with informing the architectural design of secure facilities
    and can be summarized like so: a user wants to analyze the security coverage and
    layout of a building. Prior to building a secure facility, the CAD drafts of a
    few potential floor plans are run through a *building information modeling (BIM)*
    program. The hypothetical building designs are rated on the difficulty to secure,
    access to emergency exits, accessibility features (like ramps and elevators),
    and more. For this use case, the application will need to define the effective
    coverage for different types of security equipment, including human guards’ cameras
    and other electronic sensors.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个用例涉及到为安全设施的建筑设计提供参考，可以概括为：用户希望分析建筑物的安全覆盖范围和布局。在建造一个安全设施之前，一些潜在楼层平面的CAD草图将通过*建筑信息建模（BIM）*程序进行处理。假设的建筑设计将根据安全难度、紧急出口的通道、无障碍设施（如坡道和电梯）等进行评级。对于这个用例，应用程序需要定义不同类型的安全设备的有效覆盖范围，包括人类警卫、摄像头和其他电子传感器。
- en: Of course, this analysis can also inform an attacker of flaws in a security
    layout. Every heist movie has a scene where the protagonists lay out the blueprint
    for their target and start to mark where the impossibly large number of security
    controls are, until they spot a flaw. Sensor blind spots are a favorite trope
    for these films, but the truth is that blind spots are a real-world consideration.
    By observing the guards and sensors in use, you can make a fairly accurate coverage
    map. Finding blind spots is often a simple matter of searching for the model’s
    technical specifications document. Information such as field of view, often given
    in degrees, as well as effective range, given in feet or meters, tells you not
    only where the device can detect but also where it can’t! To support this use
    case, the application we’re developing will create a visual layout of how the
    gallery is divided among the security resources. A user will be able to inspect
    the layout to see any gaps in the coverage. We’ll also develop a solver that will
    suggest additional vertices where guards can be placed to achieve customizable
    coverage goals, and we’ll add the concepts of distance, field of view, and effective
    range so we can differentiate between a guard, camera, motion sensor, and so forth.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种分析也可以为攻击者提供安全布局的缺陷。每一部盗窃电影中都有一个场景，主角们会摆出目标的蓝图，开始标出无数的安全控制设备，直到他们发现一个漏洞。传感器盲区是这些电影中的常见桥段，但实际上，盲区确实是现实中的一个重要考量。通过观察使用中的警卫和传感器，可以制作出相当准确的覆盖图。寻找盲区通常只是一个简单的搜索模型技术规格文档的过程。像视场角度（通常以度为单位）和有效范围（以英尺或米为单位）这样的信息，告诉你设备不仅可以在哪里检测，还能告诉你它无法检测到哪里！为了支持这个用例，我们正在开发的应用程序将创建一个安全资源如何划分画廊的可视化布局。用户可以检查该布局，查看覆盖范围中的任何空隙。我们还将开发一个求解器，建议可以放置警卫的额外顶点，以实现可自定义的覆盖目标，同时引入距离、视场角和有效范围等概念，以便区分警卫、摄像头、运动传感器等设备。
- en: 'Many buildings, particularly galleries and museums, are multistory buildings,
    so we can assume a professional using our software would want it to work on all
    the floor plans. Because the project needs to contain multiple assets, such as
    the shape data and the floor plan itself, it’s also safe to assume a user will
    want a way to back up their work or resume working across multiple sessions. We’ll
    wrap these all together in the final use case: a user wants to plan security for
    multiple floors of the same building across multiple work sessions. The program
    we develop will do this by creating a set of custom objects that can be serialized,
    encoded, and stored in a compressed file between sessions. We’re going to treat
    each floor of a multilevel building as separate 2D floor plans that can be grouped
    into a single multifloor project. Each floor will contain an image representing
    the background used to trace the gallery shape as well as all of the geometric
    information added by the user.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多建筑，特别是画廊和博物馆，都是多层建筑，因此我们可以假设使用我们软件的专业人士希望它能够适用于所有楼层平面图。由于项目需要包含多个资产，例如形状数据和楼层平面图本身，因此我们也可以合理推测用户希望有一种方法来备份他们的工作，或者在多个工作会话中恢复工作。我们将在最终的用例中将这些需求整合在一起：用户希望在多个工作会话中规划同一建筑物多个楼层的安全。我们开发的程序将通过创建一组可以序列化、编码并存储在压缩文件中的自定义对象来实现这一目标。我们将把多层建筑的每一层当作独立的2D楼层平面图，并将它们归为一个多楼层项目。每一层将包含一张图像，代表用来追踪画廊形状的背景，以及用户添加的所有几何信息。
- en: 'Studying blueprints and CAD designs of buildings is an excellent habit to form,
    especially for physical penetration testers. Simply by knowing the layout of a
    facility and walking confidently, I’ve passed myself off as belonging in a building.
    After all, who would know that “utility closet #2” is on the basement level, west
    end, if not someone who had been there before? Pair that knowledge of the layout
    with a clipboard, toolbox, or other official-looking props, and it’s often just
    as good as a building pass.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '学习建筑物的蓝图和CAD设计是一项非常好的习惯，尤其是对于物理渗透测试人员。仅仅通过了解一个设施的布局并自信地走进去，我就能把自己伪装成建筑物的一部分。毕竟，谁知道“设备间
    #2”位于地下层西端，如果不是曾经来过那里的人呢？将对布局的了解与一个文件夹、工具箱或其他看起来像官方道具的物品配对，它通常和建筑通行证一样有效。'
- en: Now that we have our use cases, we can start diving into the nuts and bolts.
    Let’s start by reviewing the original problem and some research performed in the
    past. We’ll then cover the solution steps in depth and discuss additional constraints
    you can add to customize the results to specific needs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了使用场景，可以开始深入探讨细节。我们先回顾一下原始问题以及过去的一些研究工作。接着，我们将深入讨论解决步骤，并讨论可以添加的额外约束条件，以便根据具体需求定制结果。
- en: Art Gallery Problem Theory
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 艺术画廊问题理论
- en: 'The first well-known theorem on the art gallery problem was written in 1973
    by computer scientist and professor Václav Chvátal. This question was posed to
    him by a former University of Washington mathematics professor, Victor Klee:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个著名的艺术画廊问题定理是由计算机科学家兼教授 Václav Chvátal 于 1973 年提出的。这个问题是由华盛顿大学的数学教授 Victor
    Klee 提出的：
- en: Given the floor plan of a weirdly shaped art gallery having *n* straight sides,
    how many guards will we need to post, in the worst case, so that every bit of
    wall is visible to a guard?
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定一个形状奇特的艺术画廊的平面图，假设它有 *n* 条直边，在最坏情况下，我们需要派遣多少名守卫才能确保每一段墙都能被守卫看到？
- en: The *Chvátal AGP theorem* gives an upper bound that states, “At most *n* / 3
    guards is always sufficient, and sometimes required, to cover a polygon with *n*
    vertices.”^([1](b01.xhtml#c11-endnote-001)) Chvátal assumed in his proof that
    guards would be placed on the vertices, but *Chvátal’s upper bound* remains true
    even if the restriction of guards at corners is loosened to “guards anywhere within
    the interior of the polygon.” The 3 constant comes from decomposing the shape
    of the gallery into triangles, based on the reasoning that you would only ever
    need one guard per triangular section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chvátal AGP 定理* 给出了一个上限，声明：“最多 *n* / 3 名守卫总是足够的，有时甚至是必须的，以覆盖一个具有 *n* 个顶点的多边形。”^([1](b01.xhtml#c11-endnote-001))
    Chvátal 在他的证明中假设守卫将被放置在顶点上，但即使放宽守卫只能站在角落的限制，变成“守卫可以在多边形内部的任何地方”，*Chvátal 的上限*
    依然成立。这个 3 常数来自于将画廊的形状分解为三角形，基于这样一种推理：你永远只需要每个三角形区域一个守卫。'
- en: 'Chvátal’s work was later simplified by mathematics professor Steve Fisk, who
    reduced the problem to a three-color problem, defining it as follows: “Under what
    conditions can the regions of a planar map be colored in three colors so that
    no two regions with a common boundary have the same color?” The three-color problem
    can be represented easily as a graph, where each vertex of the gallery’s shape
    constitutes a node and each edge marks a shared wall segment between two vertices.
    You can then treat the problem as a *vertex-coloring problem*, where two nodes
    of the same color can’t be directly connected by an edge. The graph version of
    the coloring problem is a popular method to analyze connectivity, so NetworkX
    includes a function to solve it for us, known as *greedy coloring*, that we’ll
    leverage in our solution. [Figure 11-1](#figure11-1) shows the simplest case of
    the greedy coloring algorithm.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Chvátal 的工作后来被数学教授 Steve Fisk 简化，他将这个问题简化为一个三色问题，定义如下：“在什么条件下，平面地图的区域可以被三种颜色着色，使得任何两个有共同边界的区域都不会有相同的颜色？”三色问题可以轻松地表示为图形，其中画廊形状的每个顶点构成一个节点，每条边表示两个顶点之间的共享墙段。然后，你可以将问题视为一个
    *顶点着色问题*，即相同颜色的两个节点不能通过边直接连接。着色问题的图形版本是分析连通性的一种常用方法，因此 NetworkX 包含了一个已知为 *贪婪着色*
    的函数来解决这个问题，我们将在解决方案中利用它。[图 11-1](#figure11-1) 展示了贪婪着色算法的最简单情况。
- en: '![](image_fi/502567c11/f11001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11001.png)'
- en: 'Figure 11-1: Solving the simplest art gallery problem'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：解决最简单的艺术画廊问题
- en: The leftmost image in [Figure 11-1](#figure11-1) shows a triangle polygon. The
    upper bound of *n* / 3 = 3 / 3 = 1 means we should need only one guard to observe
    the entire interior. The middle image shows the result of converting the triangle
    into a graph representation. Finally, the rightmost image shows the result of
    the greedy coloring algorithm. As expected, each node gets colored a different
    color, meaning placing one guard at any one of those points would enable them
    to observe all the walls. This is the core of the process. To expand the algorithm,
    we just need to solve a series of interconnected triangles, as you’ll see in the
    next section on the geometric and graph representations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In a 2008 thesis paper, Mikael Pålsson and Joachim Ståhl examine the three-color
    algorithm and propose a set of alternate “rectangular” algorithms (ones that operate
    on orthogonal polygons only) specifically designed with camera placement in mind.^([2](b01.xhtml#c11-endnote-002))
    Pålsson and Ståhl were able to address several practical pitfalls of Chvátal’s
    theorem. First, by restricting themselves to orthogonal polygons, they reduce
    the upper bound to *n* / 4\. Second, their camera placement version of the problem
    addresses concerns like limited field of view, effective range, and obstacles,
    which apply equally well to human guards as well as cameras. These additional
    goals make the placement selection more realistic than the standard formulation.
    We’ll discuss field of view and effective range more in a bit. We’ll also add
    the ability to weight areas to prioritize the required coverage. Other constraints,
    such as making sure that each camera is visible to another camera (common in high-security
    areas), won’t be covered but are definitely worth your time to research.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Because it uses orthogonal polygons, Pålsson and Ståhl’s approach is less practical
    for general use in planning security layouts. Anywhere there’s a diagonal or curved
    wall will require multiple small rectangles to approximate the shape. One of my
    favorite examples of unconventional architecture is the Guggenheim Museum in New
    York, shown in [Figure 11-2](#figure11-2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11002.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: The Guggenheim, designed by Frank Lloyd Wright (© 2023 Frank Lloyd
    Wright Foundation. All Rights Reserved. Licensed by Artists Rights Society.)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: On the left you can see a top-down view of the lower level, the lecture auditorium.
    The grid laid over the floor plan represents 8 square feet. As you can see, near
    the rounded walls and near the diagonal walls, the squares are cut off in places.
    These are the areas where a purely orthogonal approach would struggle. On the
    right you can see a cross section of the museum showing the circular structure
    that continues throughout the majority of the building. It makes for beautiful
    architecture, but it also makes the museum difficult to map with orthogonal polygons.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: To counter the shortcomings of the orthogonal approach, we’re going to allow
    users to draw one or more complex polygons directly on top of an image of the
    building’s floor plan. We’ll treat each individual polygon as a distinct area
    that needs to be guarded, similar to the original problem definition. Each polygon
    will be subdivided using a modified triangular tessellation called a constrained
    Delaunay triangulation. We’ll then convert the tessellated geometry into an unweighted
    graph, which we can solve using the greedy coloring algorithm from NetworkX. This
    process allows users to input unconventional floor plans like that of the Guggenheim
    and solve them for a wide variety of potential scenarios, while still respecting
    the real-world limitations of the resources involved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Geometric and Graph Representations of the Gallery
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s consider how we’d represent the gallery space as a `Polygon` object,
    just as we represented the park in [Chapter 7](c07.xhtml). [Figure 11-3](#figure11-3)
    shows the example gallery.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11003.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Representing the gallery with a polygon and graph'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: On the left you see the polygon; the gray area represents the interior of the
    gallery. On the right you see the translation of the shape into a simple NetworkX
    graph. There are a number of ways you could convert the information in a `Polygon`
    into a graph, but often the simplest option is to iterate over the vertices of
    the `Polygon`’s exterior, as in [Listing 11-1](#listing11-1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: Creating the gallery representations'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 11-1](#listing11-1), we first define the gallery `Polygon` ❶ by
    passing in the list of vertices as before. Then we add the first node, which represents
    the vertices at index 0 in the coordinates list ❷. Each node in the graph is keyed
    by its index in the vertex list to help keep the two representations logically
    tied together. The first point serves as an anchor for the shape and makes it
    easier to create the edges—we’ll do this momentarily. Before we do so, however,
    we have to add the coordinates to a position list called `pos` ❸, which will make
    it easier to display the graph so that it matches the shape of the polygon. Next,
    we loop over the remaining vertices ❹ to finish filling in the graph. For each
    remaining vertex, we add an edge between the previously defined node at `i-1`
    and the current node at `i` ❺. Adding the edge creates the node *V*[(][*i*][)]
    and adds the edge *E*[(][*i*] [– 1,][*i*][)] in one line. Storing the coordinate
    information for the vertex as node metadata can serve as a more flexible alternative
    to the `pos` list. We’ll do so by passing the coordinates in the `coords` parameter
    ❻. Finally, if `i` is equal to the last index, it’s time to create the final closing
    edge between the last node defined and the anchor node at index 0 ❼.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to generate the two representations of the gallery, let’s
    go over the process of solving the art gallery problem in detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Securing the Gallery
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护画廊
- en: We’ve already covered the start of the art gallery problem (AGP) algorithm,
    which creates the two base data structures we’ll be working with. The next step
    in the process is to tessellate the geometric shape into triangles and add the
    resulting edges to the graph representations. Remember, any changes that you make
    to one representation need to be done to the other as well, to maintain their
    logical equivalence. Rather than using the Shapely `triangulate` function as we
    did in [Chapter 7](c07.xhtml), we’re going to use a purpose-built wrapper library
    called Triangle. The underlying application is a C-based program, also called
    Triangle, which was created by Professor Jonathan Shewchuk.^([3](b01.xhtml#c11-endnote-003))
    There are several reasons for choosing Triangle over Shapely. First, the Shapely
    version performs what’s known as a Delaunay triangulation, which in its pure form
    doesn’t respect edges; on the other hand, the Triangle library performs a *constrained*
    Delaunay triangulation, which can respect boundaries. [Listing 11-2](#listing11-2)
    shows the code to tessellate the gallery polygon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了艺术画廊问题（AGP）算法的开始部分，该部分创建了我们将要使用的两个基本数据结构。接下来的步骤是将几何形状切割成三角形，并将生成的边添加到图形表示中。记住，对其中一个表示所做的任何更改也需要在另一个表示中完成，以保持它们的逻辑等价性。与我们在[第7章](c07.xhtml)中使用的Shapely
    `triangulate`函数不同，我们将使用一个专门构建的包装库，名为Triangle。底层应用程序是一个基于C的程序，也叫做Triangle，由乔纳森·谢吴奇克教授创建。^([3](b01.xhtml#c11-endnote-003))选择Triangle而非Shapely有多个原因。首先，Shapely版本执行的是所谓的德劳内（三角剖分），在其纯粹形式中并不尊重边界；而Triangle库执行的是*约束*德劳内三角剖分，能够尊重边界。[列表11-2](#listing11-2)展示了切割画廊多边形的代码。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-2: Performing the triangular tessellation with the Triangle library'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-2：使用Triangle库执行三角剖分
- en: The `triangulate` function expects a dictionary with two required keys. The
    `vertices` key holds the coordinates for the exterior of the shape. The `segments`
    key holds the edges that should be enforced while performing the tessellation.
    We pass the dictionary as the first argument to the `triangulate` function. The
    second optional argument is a string containing the settings to pass to the underlying
    application. There are a large number of configuration flags, and you can pass
    multiple arguments in the string. The `p` flag tells the library to treat the
    shape as a *planar straight-line graph*. The `e` flag tells the library to return
    the edge list as part of the result. Having the list included saves us a step
    when updating the graph representation, as we can simply compare the edges in
    the result to the edges in the graph and add any that are missing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`triangulate`函数期望接收一个包含两个必需键的字典。`vertices`键包含形状外部的坐标。`segments`键包含在执行切割时应强制执行的边。我们将字典作为第一个参数传递给`triangulate`函数。第二个可选参数是一个字符串，包含传递给底层应用程序的设置。配置标志有很多，你可以在字符串中传递多个参数。`p`标志告诉库将形状视为*平面直线图*。`e`标志告诉库将边列表作为结果的一部分返回。包含边列表可以节省我们更新图形表示的一步，因为我们可以简单地将结果中的边与图形中的边进行比较，添加任何缺失的边。'
- en: The `triangulate` function returns a dictionary. It includes a list called `vertices`
    that sets the ID for each vertex based on its position in this list. We’ll need
    this when decoding the rest of the outputs. The other two keys we’re interested
    in at the moment are the `triangles` key, which contains a list of triplets representing
    the three points making up each triangle, and the `edges` key, which contains
    a list of all the edges resulting from the triangulation. Both the `triangles`
    and `edges` use the node ID to denote vertices, so an entry in the triangle table
    like `[6, 1, 0]` means the sixth, first, and zeroth vertices form a triangle.
    If you look at the graph representation on the right side of [Figure 11-3](#figure11-3)
    again, you’ll see that adding an edge from node 6 to node 1 (*E*[(6,1)]) does
    indeed form a triangle with node 0\. The `edges` list contains all of the original
    edges plus all the additional edges needed to form the triangles (like the edge
    *E*[(6,1)] just mentioned). You can use either the `edges` list or the `triangles`
    list to update the graph representation. The Jupyter notebook has an example of
    using the `triangles` list, but I chose the `edges` list for the code in [Listing
    11-3](#listing11-3) because it’s more succinct.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-3: Updating the gallery representations'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a copy of the original graph *G* to work on. We loop over the
    `edges` list in the triangulated result. For each edge, we check if it’s already
    in the edge list for *G*[2]. If it’s not, we add it. The result is a triangulated
    representation of the gallery in both a geometric and graph representation, as
    in [Figure 11-4](#figure11-4).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11004.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: The result of triangulating the example gallery'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the division line segments added to the graph on the left-hand
    plot match the new edges added to the graph on the right-hand plot. The set of
    vertices and segments resulting from the tessellations is technically referred
    to as a *mesh*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now ready to color the graph using the `greedy_color` function, which
    you’ll need to import from the `networkx.algorithms.coloring` library like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The response from the function is a dictionary keyed off the node identifier.
    The value represents a numeric index for the color group the node belongs to.
    [Figure 11-5](#figure11-5) shows the solution for the example gallery.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11005.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: Result of greedy coloring the example gallery'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: On the left you can see the solution found by the coloring algorithm. For the
    right side of the plot, I’ve removed the triangulation edges because we no longer
    need them once the coloring is done. I’ve also represented the color groups using
    different shapes—squares, diamonds, and circles—to make them easier to distinguish.
    You can think of each group as a potential deployment plan for guards. As you
    can see, not all deployments have the same number of guard positions, though.
    The circle group has three nodes in it while the others only have two; this means
    positioning guards at the locations marked by the circle nodes would require you
    to deploy an additional guard to cover all the walls.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧显示的是由着色算法找到的解决方案。在图的右侧，我已经移除了三角化边，因为一旦着色完成，我们不再需要它们。我还使用不同的形状—方形、菱形和圆形—来表示颜色组，以便更容易区分它们。你可以把每个组看作是一个潜在的守卫部署计划。如你所见，并不是所有的部署都有相同数量的守卫位置。圆形组有三个节点，而其他组只有两个；这意味着如果将守卫安排在圆形节点标记的位置，你需要部署一个额外的守卫来覆盖所有墙面。
- en: You can compare the deployments that are tied for the lowest number of nodes
    to see what practical advantages and disadvantages each offers. For example, the
    square and diamond groups both require only two guards, but the diamond deployment
    places the guards closer to each other than the square deployment. While this
    may seem like small difference, in the real world having two guards in closer
    proximity allows them to support each other more efficiently; therefore, assuming
    these deployments were my only options, I would choose the diamond deployment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以比较节点数最少的几种部署，看看每种部署方案提供的实际优缺点。例如，方形和菱形的部署组都只需要两个守卫，但菱形部署将守卫安排得比方形部署更靠近。虽然这看起来是一个微小的差异，但在现实中，两个守卫更接近可以更高效地相互支援；因此，假设这些部署是我的唯一选择，我会选择菱形部署。
- en: Now that you’ve seen the basic solution concept applied to the example gallery,
    it’s time to start refining the process and making the solution more practical
    for real-world use. The rest of this chapter focuses on refining the theoretical
    approach you’ve just seen to address some of the practical concerns mentioned
    earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到应用于示例画廊的基本解决方案概念，是时候开始优化这一过程，并使解决方案更具实用性，以便在现实世界中使用。本章的其余部分将重点关注完善你刚刚看到的理论方法，以解决之前提到的一些实际问题。
- en: Mapping Guard Coverage
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖范围映射
- en: So far, we’ve ignored the scale of the gallery. The original problem assumes
    guards have perfect, infinite vision that isn’t affected by lighting, distance,
    or crowds. But in a real-world scenario, the deployment needs to account for these
    factors with some type of maximum coverage threshold per guard location. If we
    say the scale for the example gallery is 1:300 m (meaning one unit on the graph
    is equal to 300 meters), the length of the edge *E*[(0,1)] is 600 m *E*[(0,1)]
    = 2 × 300 m = 600 m (this is about 1,968.5 feet). The area of the gallery, then,
    is about 241 m² (2,594 square feet).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们忽略了画廊的规模。原始问题假设守卫拥有完美的、无限的视力，不受光线、距离或人群的影响。但在现实场景中，部署需要考虑这些因素，并为每个守卫位置设定某种最大覆盖阈值。如果我们说示例画廊的比例是1:300米（意味着图中的一个单位等于300米），则边*E*[(0,1)]的长度是600米，*E*[(0,1)]
    = 2 × 300米 = 600米（约合1,968.5英尺）。因此，画廊的面积大约是241平方米（2,594平方英尺）。
- en: 'Using only two guards for a floor plan of that size is likely to leave gaps
    in the coverage. Add in the other environmental factors that affect visibility,^([4](b01.xhtml#c11-endnote-004))
    such as elevation (created by a slope in the floors) and lighting (often dimmed
    in portions of a gallery for dramatic effect), and it’s clear two guards would
    be woefully inadequate to secure the gallery. Therefore, we need to improve on
    the simplifications made in the theoretical model. We’ll do so by acknowledging
    that guards are really only able to guard so much area at a time. This is my second
    major reason for choosing the Triangle library: it supports the idea of a *maximum
    area threshold*, whereas the Shapely version of the function doesn’t. The maximum
    area threshold sets the largest area of any triangle created during the tessellation.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: If you consider each triangle as a zone that needs to be guarded, you can assign
    them to guard positions to create an area of responsibility (AOR) map that shows
    which positions are responsible for which zones as well as the overall coverage
    distribution (we saw an AOR map in [Chapter 9](c09.xhtml) with the fire station
    example). The smaller the area for each zone triangle, the closer together the
    triangles will be clustered, and therefore more triangles will be needed to tessellate
    the whole gallery. More triangles mean more points in the tessellation, which
    translates to more guard positions. It also means more color (or shape) groups
    are needed to represent them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the math, let’s say each zone triangle should be a maximum area
    of 30 m² (close to 323 square feet), which scales down to an area of 0.1 unit
    per triangle. We can tell Triangle to tessellate the gallery into triangles with
    a maximum area of 30 m² by adding the `a` flag to the arguments string followed
    by the scaled maximum area 0.1:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To do the tessellation, the `triangulate` function will add the points necessary
    (often called *Steiner points*) for the geometry to split triangles larger than
    the maximum area until they’re all below the threshold. [Figure 11-6](#figure11-6)
    shows the result of the tessellation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11006.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Maximum zone area 30 m² solutions'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: On the left you can see the graph representation of the mesh. On the right you
    can see the different potential guard deployments. Since each node is a member
    of multiple triangles, the guard at that position will be responsible for all
    the triangular slices the node is a member of. Additionally, if there are any
    triangles that aren’t directly connected to one of the guard positions (as is
    the case with triangle `[3, 4, 10]` in the lower right of the gallery), we assign
    that triangle to the closest guard position to generate the AOR map. Solving the
    graph coloring required the algorithm to add a fourth group, represented by the
    star nodes. Remember, you can think of the additional groups as more potential
    deployment options and the additional points within a deployment as more guards
    being added to that deployment. In this example, the circle deployment and the
    star deployments both have three positions to cover, while the square and diamond
    deployments both require four. By the same logic as before, I’d pick the circle
    deployment because it places the guard positions closer together, whereas the
    star deployment leaves one position relatively isolated. [Figure 11-7](#figure11-7)
    shows the AOR map generated from the circle deployment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11007.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: Creating an AOR map from a selected deployment'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The left side of the figure shows the default assignment of triangles to guards.
    The black triangle is the uncovered triangle mentioned previously. On the right
    side of the figure, you can see the result of assigning the triangle to be covered
    by the closest guard position. This does create a slight imbalance in the deployment.
    The light gray AOR contains five triangles (and therefore more square footage),
    while the other two AORs have only four.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-4](#listing11-4) shows the function for assigning triangles to
    guards based on the deployment group:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-4: Assigning triangles to guard nodes'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The `assign_triangles` function takes in a copy of the triangulated graph, `g`;
    the result of the `triangulate` function, `triangulated`; and finally, the ID
    for the deployment of interest, `group_id`. We begin by collecting the nodes that
    represent the guard positions into a list called `guard_nodes` based on the provided
    group ID ❶. We then create a dictionary to hold the output of the function until
    the `return` statement. The keys will be the node identifiers and the values will
    be an empty list that will eventually contain all triangles (as `Polygon` objects)
    that are assigned to that node ❷.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: To begin filling the `triangles` lists, we loop over all the triangles in `triangulated`.
    Each of these triangles represents the collection of graph nodes that form the
    triangle ❸. We turn the nodes into a `Polygon` by looking up the coordinates for
    the triangle using the provided graph `g` ❹. The next step is to check if the
    triangle nodes already contain one of the guard positions. If they do, then one
    of the three points will be in the `guard_nodes` list ❺. If the triangle isn’t
    directly connected to a guard, we determine which guard it’s closest to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a dictionary called `dists` that is keyed off of the guard node’s
    ID. The value for each key will be the result of the Shapely function `t_poly.distance`,
    which measures the minimum distance between the triangle polygon and a `Point`
    object representing the guard station ❻. We then find the minimum entry in the
    `dists` dictionary using the `min` function. Passing in the dictionary key list
    in the `key` parameter tells the function to return the key that has the lowest
    value instead of the value itself ❼. We use this key to assign the polygon to
    the proper list in `triangles` ❽. Finally, we return the `triangles` dictionary
    to conclude the function ❾.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We can determine the exact area of each AOR by summing the area of all the triangles
    associated with it, as in [Listing 11-5](#listing11-5).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-5: Summing AOR areas'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'For each key in the resulting `triangles` dictionary, we do a `sum` operation
    on the list of triangle areas associated with it. Notice we adjust the scale by
    multiplying each area by the scaling factor (in this case `300`). The result of
    the code for the example should be:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One important note about the triangle assignment function: it’s really only
    a heuristic. Depending on the shape of the gallery and the location of the different
    edges and vertices, it’s possible to assign a triangle to a guard that is “closer”
    (as measured by minimum straight-line distance, or as the crow flies) to one guard
    position but logically should be assigned to another guard. You can improve the
    function by taking into account whether the straight-line distance measured by
    Shapely intersects the body of the gallery; if it does, this indicates that the
    measurement traveled through walls and is therefore shorter than it would be in
    reality (unless your guards can phase through solid objects like concrete walls).
    You could then change the function so that it assigns the triangles to the guard
    position with the shortest distance that doesn’t intersect with any walls.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to change the deployment to add another guard position that
    covers the uncovered triangle. Looking closely at the graph representation on
    the right side of [Figure 11-6](#figure11-6), you can see the star at node position
    3 also could have been a circle. Sometimes there will be multiple possible solutions,
    and the coloring algorithm has to settle on the one it feels is optimal (which
    means it attempts to evenly distribute color groups as much as possible). Rather
    than just assigning the uncovered triangle to a guard position, you might opt
    to change the star node to another circle node; this maintains the validity of
    the solution but leaves every triangle covered by the deployment. On the other
    hand, it also means adding another guard to the deployment, making it less optimal
    in that sense. A future improvement for your application may involve letting users
    select the assignment strategy during the AOR map creation based on their specific
    use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Defining Obstructed Areas
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve covered the algorithm, how it deals with scaling, and basic AOR
    coverage maps, it’s time to deal with complex polygons. As you might recall from
    [Chapter 7](c07.xhtml), these are polygons that have holes representing areas
    of the floor plan that can’t be accessed or that obstruct visibility (a giant
    column of granite, for example).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, dealing with holes inside the Triangle library is fairly easy. For
    each hole we want to define, we pass the `triangulate` function a point inside
    the hole (any point will do). The algorithm then removes triangles until it hits
    a vertex defined in the `segments` portion of the dictionary. Be aware that it’s
    possible to accidentally remove all the triangles if you improperly enclose the
    hole in segments. If this happens, you won’t receive anything back in the `triangles`
    key, so you might want to update your implementation to handle this condition
    with some form of validity check.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To get the point for a hole, you can use the Shapely `representative_point`
    function, which returns a `Point` object guaranteed to be inside the boundaries
    of the shape the function was called on. The great thing about using the representative
    point is that, because Shapely doesn’t care whether the point is centered in the
    shape, it can compute it quickly. As long as the point falls within the given
    shape it is considered representative, which works great for Triangle since it
    needs to know only where to begin removing triangles from.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-6](#listing11-6) shows the code to create the tessellation for
    the complex polygon.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-6: Tessellating the complex polygon'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the exterior coordinates for the gallery polygon into a
    list named `ext_3`. In this case the points form a large square-shaped gallery.
    Next, we define the coordinates for the hole vertices in a list named `int_3`.
    These points form a smaller square hole placed directly in the center of the larger
    square exterior. We then create the list of vertices in a variable named `verts`,
    which is a concatenated list of all exterior and interior coordinates in the shape.
    We can calculate the representative point for the hole by casting the `int_3`
    list as its own polygon and calling the `representative_point` function mentioned
    previously.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The `hole_p` variable now holds a `Point` whose `x` and `y` values can be used
    to identify the hole region to the Triangle library ❶. Because Triangle doesn’t
    work directly with `Point` objects, we must extract the coordinate information
    into a list ❷. Next, we create the `segs` list, which contains the list of edges
    that must be respected by the tessellation algorithm. Rather than using coordinates,
    the edges use the indices of the two vertices as the start and end of each segment.
    In more complex floor plans, it can be easier to take the segment list directly
    from the edges in the graph representation. Just be sure that all the edges and
    nodes are entered correctly, or you’ll get some unexpected results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can construct the parameter dictionary for calling the `triangulate`
    function. The only change from the previous parameter dictionary is the addition
    of the `holes` key ❸, which holds a list of coordinates that represent a point
    inside a hole to be removed. When dealing with multiple holes, you need to calculate
    a representative point for each and add it to the holes list in the dictionary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-8](#figure11-8) shows the steps performed on the example complex
    polygon gallery.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11008.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Applying the AGP algorithm to a complex polygon'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: From left to right you can see the entire solution process applied to the gallery.
    The white square in the leftmost plot represents the hole in the middle of the
    gallery; the darker gray area represents the usable floor plan. In the second
    plot, you can see the result of converting the geometry into a graph. Notice that
    the hole section is entirely surrounded by edges. These edges are boundaries passed
    into the Triangle’s `triangulate` function in the `segments` key (along with the
    exterior edges, as before). The third image shows the result of tessellating the
    shape with respect to the hole. The `triangulate` function begins by creating
    the tessellation without respecting the holes and then starts removing triangles,
    beginning with any triangle that contains a point in the holes list; it continues
    removing adjacent triangles until it reaches one of the edges in the segments
    list. I didn’t apply an area constraint, so the result is a triangulation with
    the fewest number of triangles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The fourth plot shows the updated graph, which is ready for color solving to
    be applied. As you can see, none of the edges in the second or third plots cross
    into the hole space; this indicates Triangle has respected our request to ignore
    that portion of the space when generating the mesh. The final plot on the right
    shows the result of assigning the deployment groups based on the coloring solution.
    There are four potential deployments, all of which consist of two guard stations.
    If the hole weren’t present, you would theoretically need only one guard for the
    whole gallery.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing Guard Coverage Areas
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we’ll refine our model to address another implicit assumption we’ve made:
    that all areas of the gallery are equally important and therefore the guard deployments
    should be evenly distributed. For example, a bank may weigh the monitoring of
    private offices lower than that of the lobby and therefore require different resources
    to protect the different spaces. To address this, we’ll refine our initial mesh
    to respect the importance (or weight) of each region of the floor plan. The underlying
    Triangle program supports multiple maximum areas (read in from custom data files),
    which allows us to get creative with how we define different AORs. To pull the
    example into our world of art gallery security, perhaps you believe the gallery
    floor needs fewer guards than the lecture hall, where people tend to gather in
    larger groups. You can see the result of assigning regions applied to the example
    square gallery in [Figure 11-9](#figure11-9).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11009.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: The gallery when region assignment is added'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: On the left of the figure you can see the four numbered regions I defined for
    the square gallery example. The center of each region is marked by a star as well
    as its region number. These regions are segment-bounded portions of the overall
    gallery polygon, so they can be defined using any point within the segment bounds
    (similar to the way holes are defined). In this case, I added four theoretical
    segments (the diagonal separators) to the list of segment bounds already defined
    to enclose the regions. They’re theoretical because, unlike the other segments
    that represent walls and other physical structures, the region segments represent
    logical borders between areas, not physical ones. Bear in mind that Triangle doesn’t
    know the difference, so it’s up to us to track which segments belong to which
    class. We can do so by taking advantage of edge attributes stored in the graph
    representation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: To let Triangle know that we have regions of interest, we also need to update
    the input dictionary we pass to the wrapper to include the `regions` key, as shown
    in [Listing 11-7](#listing11-7).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-7: Adding the region definitions for tessellation'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The value for the `regions` key is a nested list. Each entry contains x- and
    y-coordinates representing a point within the associated region. During the initial
    tessellation, triangles within the bounding segments found around each region’s
    representative point are assigned the value in the third position. The fourth
    position in the list, and all subsequent ones, can contain a numeric region attribute
    (such as a modified visibility value to mark regions with softer lighting). The
    values of any region attributes you include will be inherited by the triangles
    within the region.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the regions are defined, we can perform the initial tessellation. We’ll
    tell Triangle to include the region information in the result by adding the `A`
    flag to the `triangulate` function call:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The resulting mesh is shown on the right side of [Figure 11-9](#figure11-9).
    The dots with the numbers inside each triangle show which region identifier has
    been assigned to it. So far, the process is identical to the previous one, so
    the mesh remains unchanged.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to save the result in a special group of files; these are essentially
    the same data in the dictionary written out to flat text files. We need to do
    this so that we can have Triangle reload the files during the refinement stage.
    Unfortunately, the wrapper library doesn’t include any functions to save, so I
    had to write my own based off the file specification in the underlying program’s
    documentation. The project code has all the functions necessary to create the
    expected files, but they’re long and fairly boring, so I’ll skip detailing them
    here. All you need to do is import the `DataSaver` class I’ve included with the
    chapter code, as shown in [Listing 11-8](#listing11-8).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-8: Saving the tessellation result to Triangle project files'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the `DataSaver` instance, passing it the `triangulated`
    dictionary in the first parameter and the project name in the second. You can
    also optionally pass in a version number and directory. If you don’t pass these
    in, the version number will automatically be set to 1 and the directory will be
    the current working directory of the script. The `set_region_areas` function stores
    the list of maximum areas, and the index in the list is the same as the region
    index. If you pass in a list that is shorter than the number of regions, the remaining
    regions are treated as though they had no area constraint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set the region areas before we save the project using `save_project`
    so that the saver knows how to mark each triangle during the file creation. Once
    `save_file` function has completed, you’ll have a list of files in the directory
    you specified (or the current working directory, as I mentioned). Each file is
    named like so: *<project name>_<version number>.<part>* where *<part>* is one
    of the file types expected by Triangle (with a *.node*, *.ele*, *.area*, or *.poly*
    file extension). Therefore, the code in [Listing 11-8](#listing11-8) will create
    a file named */myproject/square_1.area* (among others). The *.area* file is of
    particular interest because it contains the maximum area for each triangle, which
    we just set by virtue of its region association.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to refine the mesh by reloading the saved data and performing
    another tessellation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We call the `load` function from the wrapper library and pass in the directory
    where the project files were stored, as well as the project name, including the
    version. These inputs find and load the data from the associated files created
    in [Listing 11-5](#listing11-5). Finally, we create the refined mesh by calling
    the `triangulate` function once again, this time on the loaded data. The option
    string `ra` tells Triangle to refine a previously generated mesh (the `r` flag)
    and to refine the mesh using constrained triangle areas (the `a` flag). Because
    Triangle is refining a mesh, and we’ve asked it to constrain the area, it will
    attempt to locate the project’s *.area* file and use that information while creating
    the refined mesh.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: During the refinement step, each triangle in the original tessellation is compared
    against the area defined in the *.area* file. If the area is larger than the maximum
    defined, the algorithm splits the triangle into smaller ones. You can see the
    result of the region areas being applied to the tessellation of the square gallery
    in [Figure 11-10](#figure11-10).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11010.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: Creating a multiregion tessellation'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left, you can see the region assignment. The areas passed in to the
    `DataSaver` class were `[-1,0.1,-1,0.3]`, which can be interpreted as: region
    0 has no maximum area constraint (marked by any negative value); region 1 has
    a maximum area constraint of 0.1; region 2 also has no constraint applied; and
    finally region 3 has a maximum area constraint of 0.3\. On the right side, region
    1 has been broken up into many small triangles, while region 3 has been divided
    up into slightly larger triangles. The result is more guard positions in region
    1 than region 3, and increased coverage in both compared to the other two zones
    with no constraints applied.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We can save the refined mesh using another instance of the `DataSaver` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We pass in the `refined` mesh result, project name, and version once again.
    It’s standard practice to increment the version for each subsequent mesh you refine,
    so this refined mesh would be the second version of the square project. We don’t
    need to define the region areas this time unless we want to perform any further
    refinements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’d be nice if you could just add as many guards as you wanted to
    the deployment. Unfortunately, we rarely have the budget for more than some number
    of guards per shift or for some fixed number of sensor devices we can deploy per
    floor. We can tell Triangle the maximum number of Steiner points it can add to
    achieve the tessellation with the `S` flag. For example, let’s say we can only
    afford to deploy three extra guards to the square gallery. [Figure 11-11](#figure11-11)
    shows the result of adding this constraint during the refinement step.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11011.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: Refined mesh with three guards'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: On the left, you can see the mesh we generated previously, with no restriction
    on the addition of guard points. On the right, you can see the mesh generated
    from the refinement where I restricted the output to three additional guard positions.
    Bear in mind that I didn’t change the maximum area constraint I defined earlier,
    which clearly the mesh on the right doesn’t achieve. Once Triangle runs out of
    Steiner points it can add, it can’t divide the larger triangles anymore and so
    it stops. If you’re asked to divide the gallery into small zones and then cover
    those zones with only three additional guards, you can use this result to show
    that it’s a mathematical impossibility to accomplish both goals. Hopefully this
    result gets you the budget increase you need for those additional guards!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Security Camera Field of View
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next feature to address is adding the field of view and effective range
    parameters. When discussing human guards, the field of view and effective range
    are very different from person to person so assigning these parameters is a bit
    fuzzy. Intuition and educated estimates are your best friend in these cases. However,
    when you think of guard positions as electronic devices, such as cameras or motion
    detectors, the data is easier to locate. For example, I searched Google for “security
    camera data sheet” and selected the first model I saw: Ocuity model number HMNC100
    from NetGear. After reviewing the technical data for the model (available from
    the manufacturer’s website), I found that the listed field of view was 107 degrees
    and the effective range was 7 m in total darkness (thanks to built-in infrared
    lighting). The distance during normal operational lighting is often not listed
    because the answer depends on how much detail you need to be able to distinguish,
    the focal length of the camera (which may or may not be listed in the user documents),
    and the number of pixels used to encode the information (often given as a megapixel
    rating, where 1MP is equal to one million pixels). To get a good number for effective
    distance, the best method is often to just test the camera under the conditions
    of interest.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume the normal effective range *r(d)* is 20 times greater than the
    night range, *r*(*n*) = 7 m (*r*(*n*) × 20 = 140 m or about 460 feet). Since we’re
    approximating things, I’m also going to change the field of view Δ from 107 to
    104 because 107 is prime and therefore can’t be divided up into equal segments;
    this makes computing the points representing the edges of the field of view harder.
    On the other hand, 104 can be divided by several factors, including 2, which is
    also helpful for keeping the math simple. I’ll define the starting angle ϴ[(0)]
    for each of the four internal guard nodes `[4, 5, 6, 7]` as `[180, 134, 45, 351]`,
    respectively. We can define the positive peripheral angle as ![m11001](image_fi/502567c11/m11001.png)
    and the negative peripheral angle as ![m11002](image_fi/502567c11/m11002.png).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can create some number of intermediary angles between the two peripheral
    angles by dividing the field of view into eight segments of 13 degrees each:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: δ = Δ / 8 = 13
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the `cos` and `sin` functions for each of the angles:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'A : = [ θ( p ) − i δ] ∀ i ∈ ℤ0 − 8'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12](#figure11-12) shows the approximated coverage if you positioned
    one of these cameras at each of the four internal guard positions from the square
    example in [Figure 11-8](#figure11-8), using the starting angles just mentioned.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11012.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: Defining the field of view polygons'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12](#figure11-12) shows the approximate field of view coverage resulting
    from placing one of those cameras at each of the corners of the internal hole.
    As you can see, there are clearly large areas the cameras aren’t able to adequately
    cover. Furthermore, you can see someone could theoretically approach each camera
    position without ever entering the field of vision of any camera. These are examples
    of the blind spots mentioned earlier in the chapter. As a defender, you’d want
    to add more coverage to prevent these gaps. As an attacker, you could consider
    all of the uncovered assets as potentially good targets.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: One last note about field of view mapping. I’ve assumed that the cameras are
    pointed and then left stationary. Several high-end cameras include a device called
    a gimbal that allows a remote operator to move the camera as needed. Some mid-level
    cameras also include the ability to automatically sweep back and forth across
    an area. These types of cameras are becoming less popular these days, but they’re
    still good to be aware of; not all field of view maps are going to be static.
    Be sure to look out for features like these when you’re analyzing the data sheets
    for devices; you may need to update your implementation to produce the full range
    of vision for these cases.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have all the code necessary to solve the core of the art gallery problem,
    including methods for handling real-world constraints, such as limited budgets
    and effective range for sensors. We’ve discussed the power of the Triangle library
    and combined it with Shapely and NetworkX to model the problem with both a geometric
    and graph representation. Perhaps most important of all, you should now be comfortable
    explaining the AGP theory and discussing the practical constraints applied within
    the application. There’s a large body of research you can tap into to continue
    developing your understanding of the problem. I didn’t even touch on how the greedy
    color algorithm functions under the hood, for example.^([5](b01.xhtml#c11-endnote-005))
    Node coloring in general is a great graph theory topic with many applications
    outside the AGP, but for our purposes, studying node-coloring algorithms can help
    you understand the solutions your application outputs (and how you can potentially
    modify them) more completely. For a more in-depth description of the geometric
    implications of different gallery layouts, check out the paper “Note on an Art
    Gallery Problem.”^([6](b01.xhtml#c11-endnote-006))
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To continue developing the core of the system, you can identify additional use
    cases that may be of interest to the users you want to serve. For example, you
    might want a use case to cover users who want to compare before and after deployment
    plans. Once you collect the use cases, you can develop the additional functions
    needed to support them. Additionally, you can continue to refine the functions
    included here. The triangle assignment function is one excellent area to improve
    upon using one of the options we discussed previously. Remember, you don’t necessarily
    need to develop all of these features before taking your application to the market.
    Developing an MVP is all about picking the key features that make your application
    useful to users. Oftentimes, figuring out these key features is a matter of analyzing
    competitive software offerings and answering the questions, “What features do
    all these applications offer?” and “What features does my application offer that
    the others do not?”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Once you can answer those two questions, you’re ready to move on to the next
    chapters, where we’ll go from the core algorithm developed in this chapter to
    a full-fledged Python application. We’ll finish out the project by mapping out
    the user interaction, adding graphics, selecting a modern processing architecture,
    and deciding whether to add application licensing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
