- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Distributing Security Resources to Guard a Space
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分配安全资源以保护空间
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'The remainder of the book will focus on a single, extremely practical application.
    Known as the art gallery problem, this classic application has plenty of research
    for us to leverage and deals with efficiently distributing security resources
    to guard a space. Efficiency is an imperative for today’s security teams: there
    are always more assets to protect than there are resources to protect them. In
    its grandest form, the art gallery problem ties together the two main disciplines
    we’ve been studying: graph theory and computational geometry. It’s fitting, then,
    that this part of the book will also represent the most complete Python application
    yet, going beyond a conceptual design and into the realm of a full-fledged software
    project. We’ll cover the design, development, and delivery options for a modern
    Python project, including graphics, distributed computation, and licensing your
    application to users.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分将专注于一个单一且极具实用性的应用。这个经典应用被称为艺术画廊问题，它有大量的研究可以为我们所用，并涉及如何高效地分配安全资源来保护一个空间。效率是当今安全团队的首要任务：保护的资产总是比保护这些资产的资源要多。在其最宏大的形式下，艺术画廊问题将我们所学习的两大主要学科结合起来：图论和计算几何。因此，这一部分也将代表本书迄今为止最完整的Python应用，超越了概念设计，进入了完整软件项目的领域。我们将涉及现代Python项目的设计、开发和交付选项，包括图形、分布式计算以及如何将你的应用授权给用户。
- en: The goal for this part of the book is to develop a *minimum viable product (MVP)*,
    which can be considered a step up from a proof of concept. As you’ve seen, a proof
    of concept proves that an idea is worth pursuing and defines the framework for
    future development. It’s usually constrained to only the functions necessary to
    get an idea off the ground—no bells or whistles included. An MVP design, on the
    other hand, is concerned with the smallest number of features you could produce
    to bring an idea to market and “be competitive.” Typically this means adding features
    like a GUI as well as user-friendly elements, such as save and restore functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这一部分的目标是开发一个*最小可行产品（MVP）*，它可以被看作是概念验证的一个进阶版本。如你所见，概念验证证明一个想法值得追求，并定义了未来开发的框架。它通常仅限于实现让想法得以起步所需的基本功能——没有任何多余的附加功能。而MVP设计则关注你能开发的最少功能集，以便将一个想法推向市场并“具备竞争力”。通常，这意味着添加像图形用户界面（GUI）以及用户友好的元素，如保存和恢复功能。
- en: 'There’s no exact set of features that make an application viable, because they’re
    ultimately dictated by the expectations of the users in that particular market.
    For example, in the security market, users have come to expect features like single
    sign-on (SSO), data encryption, push notifications, and so on. Does this mean
    you need to develop all of these features before you can bring a security tool
    to the market? Absolutely not! Think minimally and ask yourself, “What features
    do all the applications similar to mine share?” When you’re developing a product
    for users, it’s tempting to try to anticipate all their needs up front, but this
    mentality is impractical and expensive: you’ll often end up solving problems that
    no one would have encountered (edge-case code) or developing features that only
    confuse new users. If you instead release a product that contains a minimal set
    of clearly labeled features, you can get feedback on the actual problems users
    see and conveniences they’re missing. Iterative improvement plans allow you to
    focus development time on features that will actually be useful.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一套确切的功能组合能够使一个应用程序变得可行，因为这些功能最终是由特定市场用户的期望决定的。例如，在安全市场中，用户已经习惯了像单点登录（SSO）、数据加密、推送通知等功能。这是否意味着在推出一个安全工具之前，你需要开发所有这些功能？绝对不是！要以最简的方式思考，并问自己：“所有与我类似的应用程序都具备哪些功能？”当你为用户开发产品时，可能会很容易想提前预测他们的所有需求，但这种心态既不现实也很昂贵：你往往会解决一些没有人遇到的问题（边缘情况代码），或者开发一些只会让新用户困惑的功能。如果你发布一个只包含少量明确标注功能的产品，你就能获得关于用户实际遇到的问题和他们缺失的便利功能的反馈。迭代改进计划能让你把开发时间集中在那些实际有用的功能上。
- en: Now let’s jump into the art gallery problem, which asks, “What is the minimum
    number of guards that need to be placed in a gallery (represented by an *n*-vertex
    simple polygon) such that all points of the interior are visible?” This is a resource
    planning problem similar to the fire station placement problem from [Chapter 9](c09.xhtml).
    A good plan for the placement of security personnel, checkpoints, and monitoring
    devices can reduce the number of incidents a security team will need to respond
    to from the start. It can also improve the response time when an incident does
    occur, thus reducing the overall risk. Unfortunately, there are often differing
    levels of understanding among human planners on a security team, which can lead
    to poorly planned (or poorly implemented) security controls. That’s why I’m always
    searching for ways to automate portions of my team’s planning.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探讨艺术画廊问题，它问的是：“在一个画廊中（由一个*n*顶点的简单多边形表示），需要放置最少的守卫才能确保所有内部点都能被看到？” 这是一个资源规划问题，类似于[第9章](c09.xhtml)中的消防站布置问题。一个好的安全人员、检查点和监控设备布置计划可以减少从一开始就需要响应的事件数量。它还可以在发生事件时改善响应时间，从而降低总体风险。不幸的是，安全团队中的人类规划人员通常对问题的理解程度不同，这可能导致计划不当（或实施不当）的安全控制。这就是为什么我总是在寻找自动化我们团队部分规划的方式。
- en: 'It was during one of these searches that I discovered the art gallery problem,
    which addressed the very problem I was researching: the efficient deployment of
    security resources for buildings with what we’ll call “untraditional” layouts.
    As you’ll see, not all building designs lend themselves equally well to being
    guarded, so before we get into the details of the problem, we’ll cover the use
    cases for the application we plan to develop. Then we’ll be ready to start developing
    the core of the application logic. We’ll cover the existing research and show
    the theory in its simplest form. We’ll then move on to defining the two data representations
    we’re going to use in solving the problem and discuss the data structures. Finally,
    we’ll go beyond the base model to allow for more realistic deployments by adding
    advanced concepts like field of view and budget constraints.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这些搜索过程中，我发现了艺术画廊问题，它解决了我正在研究的那个问题：如何高效地部署安全资源，尤其是对于那些我们称之为“非传统”布局的建筑。如你所见，并非所有的建筑设计都同样适合守卫，因此在深入问题细节之前，我们将先介绍我们计划开发的应用程序的使用案例。然后，我们将准备好开始开发应用程序的核心逻辑。我们会介绍现有的研究，并以最简单的形式展示理论。接下来，我们将定义用于解决问题的两种数据表示，并讨论数据结构。最后，我们将超越基础模型，加入诸如视野和预算限制等高级概念，从而实现更为现实的部署。
- en: Determining the Minimum Number of Guards
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定最小守卫人数
- en: 'We’ll use the original problem statement as our first use case: a user wants
    to know the minimum number of guards to protect an unconventional floor plan.
    We want all the guards together to be able to observe the whole gallery (all points
    of the interior, or the walls, in the original problem statement). For this use
    case, our application will need functions that can encode floor plans in a data
    format the computer can analyze as well as an algorithm that can do the actual
    guard placement. We’ll go through that in the rest of this chapter, once we’ve
    covered a few more use cases.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用原始问题陈述作为第一个使用案例：一个用户想知道保护一个非常规楼层平面图所需的最小守卫人数。我们希望所有的守卫一起能够观察整个画廊（在原始问题陈述中，所有的内部点或墙壁）。对于这个使用案例，我们的应用程序需要能够将楼层平面图编码成计算机可以分析的数据格式的功能，以及一个可以执行实际守卫布置的算法。我们将在本章的后续部分介绍这些内容，先介绍一些其他的使用案例。
- en: 'The next use case deals with informing the architectural design of secure facilities
    and can be summarized like so: a user wants to analyze the security coverage and
    layout of a building. Prior to building a secure facility, the CAD drafts of a
    few potential floor plans are run through a *building information modeling (BIM)*
    program. The hypothetical building designs are rated on the difficulty to secure,
    access to emergency exits, accessibility features (like ramps and elevators),
    and more. For this use case, the application will need to define the effective
    coverage for different types of security equipment, including human guards’ cameras
    and other electronic sensors.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个用例涉及到为安全设施的建筑设计提供参考，可以概括为：用户希望分析建筑物的安全覆盖范围和布局。在建造一个安全设施之前，一些潜在楼层平面的CAD草图将通过*建筑信息建模（BIM）*程序进行处理。假设的建筑设计将根据安全难度、紧急出口的通道、无障碍设施（如坡道和电梯）等进行评级。对于这个用例，应用程序需要定义不同类型的安全设备的有效覆盖范围，包括人类警卫、摄像头和其他电子传感器。
- en: Of course, this analysis can also inform an attacker of flaws in a security
    layout. Every heist movie has a scene where the protagonists lay out the blueprint
    for their target and start to mark where the impossibly large number of security
    controls are, until they spot a flaw. Sensor blind spots are a favorite trope
    for these films, but the truth is that blind spots are a real-world consideration.
    By observing the guards and sensors in use, you can make a fairly accurate coverage
    map. Finding blind spots is often a simple matter of searching for the model’s
    technical specifications document. Information such as field of view, often given
    in degrees, as well as effective range, given in feet or meters, tells you not
    only where the device can detect but also where it can’t! To support this use
    case, the application we’re developing will create a visual layout of how the
    gallery is divided among the security resources. A user will be able to inspect
    the layout to see any gaps in the coverage. We’ll also develop a solver that will
    suggest additional vertices where guards can be placed to achieve customizable
    coverage goals, and we’ll add the concepts of distance, field of view, and effective
    range so we can differentiate between a guard, camera, motion sensor, and so forth.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种分析也可以为攻击者提供安全布局的缺陷。每一部盗窃电影中都有一个场景，主角们会摆出目标的蓝图，开始标出无数的安全控制设备，直到他们发现一个漏洞。传感器盲区是这些电影中的常见桥段，但实际上，盲区确实是现实中的一个重要考量。通过观察使用中的警卫和传感器，可以制作出相当准确的覆盖图。寻找盲区通常只是一个简单的搜索模型技术规格文档的过程。像视场角度（通常以度为单位）和有效范围（以英尺或米为单位）这样的信息，告诉你设备不仅可以在哪里检测，还能告诉你它无法检测到哪里！为了支持这个用例，我们正在开发的应用程序将创建一个安全资源如何划分画廊的可视化布局。用户可以检查该布局，查看覆盖范围中的任何空隙。我们还将开发一个求解器，建议可以放置警卫的额外顶点，以实现可自定义的覆盖目标，同时引入距离、视场角和有效范围等概念，以便区分警卫、摄像头、运动传感器等设备。
- en: 'Many buildings, particularly galleries and museums, are multistory buildings,
    so we can assume a professional using our software would want it to work on all
    the floor plans. Because the project needs to contain multiple assets, such as
    the shape data and the floor plan itself, it’s also safe to assume a user will
    want a way to back up their work or resume working across multiple sessions. We’ll
    wrap these all together in the final use case: a user wants to plan security for
    multiple floors of the same building across multiple work sessions. The program
    we develop will do this by creating a set of custom objects that can be serialized,
    encoded, and stored in a compressed file between sessions. We’re going to treat
    each floor of a multilevel building as separate 2D floor plans that can be grouped
    into a single multifloor project. Each floor will contain an image representing
    the background used to trace the gallery shape as well as all of the geometric
    information added by the user.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多建筑，特别是画廊和博物馆，都是多层建筑，因此我们可以假设使用我们软件的专业人士希望它能够适用于所有楼层平面图。由于项目需要包含多个资产，例如形状数据和楼层平面图本身，因此我们也可以合理推测用户希望有一种方法来备份他们的工作，或者在多个工作会话中恢复工作。我们将在最终的用例中将这些需求整合在一起：用户希望在多个工作会话中规划同一建筑物多个楼层的安全。我们开发的程序将通过创建一组可以序列化、编码并存储在压缩文件中的自定义对象来实现这一目标。我们将把多层建筑的每一层当作独立的2D楼层平面图，并将它们归为一个多楼层项目。每一层将包含一张图像，代表用来追踪画廊形状的背景，以及用户添加的所有几何信息。
- en: 'Studying blueprints and CAD designs of buildings is an excellent habit to form,
    especially for physical penetration testers. Simply by knowing the layout of a
    facility and walking confidently, I’ve passed myself off as belonging in a building.
    After all, who would know that “utility closet #2” is on the basement level, west
    end, if not someone who had been there before? Pair that knowledge of the layout
    with a clipboard, toolbox, or other official-looking props, and it’s often just
    as good as a building pass.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '学习建筑物的蓝图和CAD设计是一项非常好的习惯，尤其是对于物理渗透测试人员。仅仅通过了解一个设施的布局并自信地走进去，我就能把自己伪装成建筑物的一部分。毕竟，谁知道“设备间
    #2”位于地下层西端，如果不是曾经来过那里的人呢？将对布局的了解与一个文件夹、工具箱或其他看起来像官方道具的物品配对，它通常和建筑通行证一样有效。'
- en: Now that we have our use cases, we can start diving into the nuts and bolts.
    Let’s start by reviewing the original problem and some research performed in the
    past. We’ll then cover the solution steps in depth and discuss additional constraints
    you can add to customize the results to specific needs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了使用场景，可以开始深入探讨细节。我们先回顾一下原始问题以及过去的一些研究工作。接着，我们将深入讨论解决步骤，并讨论可以添加的额外约束条件，以便根据具体需求定制结果。
- en: Art Gallery Problem Theory
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 艺术画廊问题理论
- en: 'The first well-known theorem on the art gallery problem was written in 1973
    by computer scientist and professor Václav Chvátal. This question was posed to
    him by a former University of Washington mathematics professor, Victor Klee:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个著名的艺术画廊问题定理是由计算机科学家兼教授 Václav Chvátal 于 1973 年提出的。这个问题是由华盛顿大学的数学教授 Victor
    Klee 提出的：
- en: Given the floor plan of a weirdly shaped art gallery having *n* straight sides,
    how many guards will we need to post, in the worst case, so that every bit of
    wall is visible to a guard?
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定一个形状奇特的艺术画廊的平面图，假设它有 *n* 条直边，在最坏情况下，我们需要派遣多少名守卫才能确保每一段墙都能被守卫看到？
- en: The *Chvátal AGP theorem* gives an upper bound that states, “At most *n* / 3
    guards is always sufficient, and sometimes required, to cover a polygon with *n*
    vertices.”^([1](b01.xhtml#c11-endnote-001)) Chvátal assumed in his proof that
    guards would be placed on the vertices, but *Chvátal’s upper bound* remains true
    even if the restriction of guards at corners is loosened to “guards anywhere within
    the interior of the polygon.” The 3 constant comes from decomposing the shape
    of the gallery into triangles, based on the reasoning that you would only ever
    need one guard per triangular section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chvátal AGP 定理* 给出了一个上限，声明：“最多 *n* / 3 名守卫总是足够的，有时甚至是必须的，以覆盖一个具有 *n* 个顶点的多边形。”^([1](b01.xhtml#c11-endnote-001))
    Chvátal 在他的证明中假设守卫将被放置在顶点上，但即使放宽守卫只能站在角落的限制，变成“守卫可以在多边形内部的任何地方”，*Chvátal 的上限*
    依然成立。这个 3 常数来自于将画廊的形状分解为三角形，基于这样一种推理：你永远只需要每个三角形区域一个守卫。'
- en: 'Chvátal’s work was later simplified by mathematics professor Steve Fisk, who
    reduced the problem to a three-color problem, defining it as follows: “Under what
    conditions can the regions of a planar map be colored in three colors so that
    no two regions with a common boundary have the same color?” The three-color problem
    can be represented easily as a graph, where each vertex of the gallery’s shape
    constitutes a node and each edge marks a shared wall segment between two vertices.
    You can then treat the problem as a *vertex-coloring problem*, where two nodes
    of the same color can’t be directly connected by an edge. The graph version of
    the coloring problem is a popular method to analyze connectivity, so NetworkX
    includes a function to solve it for us, known as *greedy coloring*, that we’ll
    leverage in our solution. [Figure 11-1](#figure11-1) shows the simplest case of
    the greedy coloring algorithm.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Chvátal 的工作后来被数学教授 Steve Fisk 简化，他将这个问题简化为一个三色问题，定义如下：“在什么条件下，平面地图的区域可以被三种颜色着色，使得任何两个有共同边界的区域都不会有相同的颜色？”三色问题可以轻松地表示为图形，其中画廊形状的每个顶点构成一个节点，每条边表示两个顶点之间的共享墙段。然后，你可以将问题视为一个
    *顶点着色问题*，即相同颜色的两个节点不能通过边直接连接。着色问题的图形版本是分析连通性的一种常用方法，因此 NetworkX 包含了一个已知为 *贪婪着色*
    的函数来解决这个问题，我们将在解决方案中利用它。[图 11-1](#figure11-1) 展示了贪婪着色算法的最简单情况。
- en: '![](image_fi/502567c11/f11001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11001.png)'
- en: 'Figure 11-1: Solving the simplest art gallery problem'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：解决最简单的艺术画廊问题
- en: The leftmost image in [Figure 11-1](#figure11-1) shows a triangle polygon. The
    upper bound of *n* / 3 = 3 / 3 = 1 means we should need only one guard to observe
    the entire interior. The middle image shows the result of converting the triangle
    into a graph representation. Finally, the rightmost image shows the result of
    the greedy coloring algorithm. As expected, each node gets colored a different
    color, meaning placing one guard at any one of those points would enable them
    to observe all the walls. This is the core of the process. To expand the algorithm,
    we just need to solve a series of interconnected triangles, as you’ll see in the
    next section on the geometric and graph representations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](#figure11-1)中的最左边图像显示了一个三角形多边形。*n* / 3 = 3 / 3 = 1的上界意味着我们只需要一个守卫来观察整个内部。中间的图像显示了将三角形转换为图表示的结果。最后，最右边的图像展示了贪心着色算法的结果。正如预期的那样，每个节点都被涂上了不同的颜色，这意味着在这些点中的任何一个放置守卫都能使其观察到所有墙面。这是该过程的核心。为了扩展算法，我们只需要解决一系列相互连接的三角形，正如你在接下来的几节中会看到的几何和图表示一样。'
- en: In a 2008 thesis paper, Mikael Pålsson and Joachim Ståhl examine the three-color
    algorithm and propose a set of alternate “rectangular” algorithms (ones that operate
    on orthogonal polygons only) specifically designed with camera placement in mind.^([2](b01.xhtml#c11-endnote-002))
    Pålsson and Ståhl were able to address several practical pitfalls of Chvátal’s
    theorem. First, by restricting themselves to orthogonal polygons, they reduce
    the upper bound to *n* / 4\. Second, their camera placement version of the problem
    addresses concerns like limited field of view, effective range, and obstacles,
    which apply equally well to human guards as well as cameras. These additional
    goals make the placement selection more realistic than the standard formulation.
    We’ll discuss field of view and effective range more in a bit. We’ll also add
    the ability to weight areas to prioritize the required coverage. Other constraints,
    such as making sure that each camera is visible to another camera (common in high-security
    areas), won’t be covered but are definitely worth your time to research.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在2008年的一篇论文中，Mikael Pålsson和Joachim Ståhl研究了三色算法，并提出了一套替代的“矩形”算法（仅对直角多边形操作），这些算法特别为相机布置而设计。^([2](b01.xhtml#c11-endnote-002))
    Pålsson和Ståhl成功解决了Chvátal定理的几个实际问题。首先，通过限制自己只使用直角多边形，他们将上界降到了*n* / 4。其次，他们针对相机布置问题，解决了诸如视野有限、有效范围和障碍物等问题，这些问题同样适用于人类守卫和相机。这些附加目标使得布置选择比标准公式更加现实。稍后我们将进一步讨论视野和有效范围。我们还将增加对区域加权的能力，以优先考虑所需的覆盖范围。其他约束条件，比如确保每个相机都能被另一个相机看到（在高安全区域中很常见），不会在此讨论，但确实值得你去研究。
- en: Because it uses orthogonal polygons, Pålsson and Ståhl’s approach is less practical
    for general use in planning security layouts. Anywhere there’s a diagonal or curved
    wall will require multiple small rectangles to approximate the shape. One of my
    favorite examples of unconventional architecture is the Guggenheim Museum in New
    York, shown in [Figure 11-2](#figure11-2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了直角多边形，Pålsson和Ståhl的方法对于一般的安全布局规划不太实用。任何存在对角线或曲线墙壁的地方都需要多个小矩形来逼近形状。我最喜欢的非传统建筑之一是位于纽约的古根海姆博物馆，展示在[图
    11-2](#figure11-2)中。
- en: '![](image_fi/502567c11/f11002.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11002.png)'
- en: 'Figure 11-2: The Guggenheim, designed by Frank Lloyd Wright (© 2023 Frank Lloyd
    Wright Foundation. All Rights Reserved. Licensed by Artists Rights Society.)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：古根海姆博物馆，由Frank Lloyd Wright设计（© 2023 Frank Lloyd Wright Foundation。版权所有。由Artists
    Rights Society授权）。
- en: On the left you can see a top-down view of the lower level, the lecture auditorium.
    The grid laid over the floor plan represents 8 square feet. As you can see, near
    the rounded walls and near the diagonal walls, the squares are cut off in places.
    These are the areas where a purely orthogonal approach would struggle. On the
    right you can see a cross section of the museum showing the circular structure
    that continues throughout the majority of the building. It makes for beautiful
    architecture, but it also makes the museum difficult to map with orthogonal polygons.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是下层的俯视图，讲座大厅。地面平面图上覆盖的网格代表8平方英尺。如你所见，在圆形墙壁附近和对角线墙壁附近，方格在某些地方被切断。这些地方是纯直角方法会遇到困难的区域。右侧则展示了博物馆的横截面，显示了贯穿大部分建筑的圆形结构。这为建筑带来了美丽的外观，但也使得用直角多边形绘制博物馆地图变得困难。
- en: To counter the shortcomings of the orthogonal approach, we’re going to allow
    users to draw one or more complex polygons directly on top of an image of the
    building’s floor plan. We’ll treat each individual polygon as a distinct area
    that needs to be guarded, similar to the original problem definition. Each polygon
    will be subdivided using a modified triangular tessellation called a constrained
    Delaunay triangulation. We’ll then convert the tessellated geometry into an unweighted
    graph, which we can solve using the greedy coloring algorithm from NetworkX. This
    process allows users to input unconventional floor plans like that of the Guggenheim
    and solve them for a wide variety of potential scenarios, while still respecting
    the real-world limitations of the resources involved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服正交方法的缺点，我们将允许用户直接在建筑物平面图的图像上绘制一个或多个复杂的多边形。我们将把每个单独的多边形视为需要防护的独立区域，类似于原始问题定义。每个多边形将通过一种修改过的三角形镶嵌方法进行细分，称为约束德劳内三角剖分。然后，我们将把镶嵌后的几何形状转换成一个无权图，可以使用NetworkX中的贪心着色算法来求解。这个过程允许用户输入像古根海姆博物馆那样不规则的平面图，并在遵循现实资源限制的同时，求解出各种潜在的场景。
- en: Geometric and Graph Representations of the Gallery
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画廊的几何和图形表示
- en: Now let’s consider how we’d represent the gallery space as a `Polygon` object,
    just as we represented the park in [Chapter 7](c07.xhtml). [Figure 11-3](#figure11-3)
    shows the example gallery.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如何将画廊空间表示为一个`Polygon`对象，就像我们在[第7章](c07.xhtml)中表示公园一样。[图11-3](#figure11-3)展示了一个示例画廊。
- en: '![](image_fi/502567c11/f11003.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11003.png)'
- en: 'Figure 11-3: Representing the gallery with a polygon and graph'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3：用多边形和图形表示画廊
- en: On the left you see the polygon; the gray area represents the interior of the
    gallery. On the right you see the translation of the shape into a simple NetworkX
    graph. There are a number of ways you could convert the information in a `Polygon`
    into a graph, but often the simplest option is to iterate over the vertices of
    the `Polygon`’s exterior, as in [Listing 11-1](#listing11-1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是多边形，灰色区域表示画廊的内部。右侧是将形状转换为简单的NetworkX图的结果。你可以有多种方式将`Polygon`中的信息转换为图形，但最简单的选项通常是迭代`Polygon`外部的顶点，如[清单11-1](#listing11-1)所示。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: Creating the gallery representations'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-1：创建画廊表示
- en: In [Listing 11-1](#listing11-1), we first define the gallery `Polygon` ❶ by
    passing in the list of vertices as before. Then we add the first node, which represents
    the vertices at index 0 in the coordinates list ❷. Each node in the graph is keyed
    by its index in the vertex list to help keep the two representations logically
    tied together. The first point serves as an anchor for the shape and makes it
    easier to create the edges—we’ll do this momentarily. Before we do so, however,
    we have to add the coordinates to a position list called `pos` ❸, which will make
    it easier to display the graph so that it matches the shape of the polygon. Next,
    we loop over the remaining vertices ❹ to finish filling in the graph. For each
    remaining vertex, we add an edge between the previously defined node at `i-1`
    and the current node at `i` ❺. Adding the edge creates the node *V*[(][*i*][)]
    and adds the edge *E*[(][*i*] [– 1,][*i*][)] in one line. Storing the coordinate
    information for the vertex as node metadata can serve as a more flexible alternative
    to the `pos` list. We’ll do so by passing the coordinates in the `coords` parameter
    ❻. Finally, if `i` is equal to the last index, it’s time to create the final closing
    edge between the last node defined and the anchor node at index 0 ❼.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单11-1](#listing11-1)中，我们首先通过传入顶点列表来定义画廊的`Polygon` ❶，如之前所示。然后，我们添加第一个节点，表示坐标列表中索引为0的顶点
    ❷。图中的每个节点都通过其在顶点列表中的索引来键入，以帮助保持这两种表示的逻辑关联。第一个点作为形状的锚点，使得创建边变得更加容易——我们稍后将完成这一步。然后，在此之前，我们必须将坐标添加到一个名为`pos`
    ❸的位置列表中，这样可以更方便地展示图形，使其与多边形的形状匹配。接下来，我们遍历剩余的顶点 ❹，完成图的构建。对于每个剩余的顶点，我们在之前定义的节点`i-1`和当前节点`i`之间添加一条边
    ❺。添加边会创建节点*V*[(][*i*][)]，并在一行中添加边*E*[(][*i*] [– 1,][*i*][)]。将顶点的坐标信息存储为节点的元数据，可以作为比`pos`列表更灵活的替代方式。我们将通过在`coords`参数中传递坐标来实现
    ❻。最后，如果`i`等于最后一个索引，说明该是时候在最后一个定义的节点与锚节点（索引为0）之间创建最后的闭合边了 ❼。
- en: Now that we have a way to generate the two representations of the gallery, let’s
    go over the process of solving the art gallery problem in detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了生成画廊两种表示方法的方法，让我们详细介绍如何求解艺术画廊问题的过程。
- en: Securing the Gallery
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护画廊
- en: We’ve already covered the start of the art gallery problem (AGP) algorithm,
    which creates the two base data structures we’ll be working with. The next step
    in the process is to tessellate the geometric shape into triangles and add the
    resulting edges to the graph representations. Remember, any changes that you make
    to one representation need to be done to the other as well, to maintain their
    logical equivalence. Rather than using the Shapely `triangulate` function as we
    did in [Chapter 7](c07.xhtml), we’re going to use a purpose-built wrapper library
    called Triangle. The underlying application is a C-based program, also called
    Triangle, which was created by Professor Jonathan Shewchuk.^([3](b01.xhtml#c11-endnote-003))
    There are several reasons for choosing Triangle over Shapely. First, the Shapely
    version performs what’s known as a Delaunay triangulation, which in its pure form
    doesn’t respect edges; on the other hand, the Triangle library performs a *constrained*
    Delaunay triangulation, which can respect boundaries. [Listing 11-2](#listing11-2)
    shows the code to tessellate the gallery polygon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了艺术画廊问题（AGP）算法的开始部分，该部分创建了我们将要使用的两个基本数据结构。接下来的步骤是将几何形状切割成三角形，并将生成的边添加到图形表示中。记住，对其中一个表示所做的任何更改也需要在另一个表示中完成，以保持它们的逻辑等价性。与我们在[第7章](c07.xhtml)中使用的Shapely
    `triangulate`函数不同，我们将使用一个专门构建的包装库，名为Triangle。底层应用程序是一个基于C的程序，也叫做Triangle，由乔纳森·谢吴奇克教授创建。^([3](b01.xhtml#c11-endnote-003))选择Triangle而非Shapely有多个原因。首先，Shapely版本执行的是所谓的德劳内（三角剖分），在其纯粹形式中并不尊重边界；而Triangle库执行的是*约束*德劳内三角剖分，能够尊重边界。[列表11-2](#listing11-2)展示了切割画廊多边形的代码。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-2: Performing the triangular tessellation with the Triangle library'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-2：使用Triangle库执行三角剖分
- en: The `triangulate` function expects a dictionary with two required keys. The
    `vertices` key holds the coordinates for the exterior of the shape. The `segments`
    key holds the edges that should be enforced while performing the tessellation.
    We pass the dictionary as the first argument to the `triangulate` function. The
    second optional argument is a string containing the settings to pass to the underlying
    application. There are a large number of configuration flags, and you can pass
    multiple arguments in the string. The `p` flag tells the library to treat the
    shape as a *planar straight-line graph*. The `e` flag tells the library to return
    the edge list as part of the result. Having the list included saves us a step
    when updating the graph representation, as we can simply compare the edges in
    the result to the edges in the graph and add any that are missing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`triangulate`函数期望接收一个包含两个必需键的字典。`vertices`键包含形状外部的坐标。`segments`键包含在执行切割时应强制执行的边。我们将字典作为第一个参数传递给`triangulate`函数。第二个可选参数是一个字符串，包含传递给底层应用程序的设置。配置标志有很多，你可以在字符串中传递多个参数。`p`标志告诉库将形状视为*平面直线图*。`e`标志告诉库将边列表作为结果的一部分返回。包含边列表可以节省我们更新图形表示的一步，因为我们可以简单地将结果中的边与图形中的边进行比较，添加任何缺失的边。'
- en: The `triangulate` function returns a dictionary. It includes a list called `vertices`
    that sets the ID for each vertex based on its position in this list. We’ll need
    this when decoding the rest of the outputs. The other two keys we’re interested
    in at the moment are the `triangles` key, which contains a list of triplets representing
    the three points making up each triangle, and the `edges` key, which contains
    a list of all the edges resulting from the triangulation. Both the `triangles`
    and `edges` use the node ID to denote vertices, so an entry in the triangle table
    like `[6, 1, 0]` means the sixth, first, and zeroth vertices form a triangle.
    If you look at the graph representation on the right side of [Figure 11-3](#figure11-3)
    again, you’ll see that adding an edge from node 6 to node 1 (*E*[(6,1)]) does
    indeed form a triangle with node 0\. The `edges` list contains all of the original
    edges plus all the additional edges needed to form the triangles (like the edge
    *E*[(6,1)] just mentioned). You can use either the `edges` list or the `triangles`
    list to update the graph representation. The Jupyter notebook has an example of
    using the `triangles` list, but I chose the `edges` list for the code in [Listing
    11-3](#listing11-3) because it’s more succinct.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`triangulate`函数返回一个字典。它包括一个名为`vertices`的列表，该列表根据每个顶点在此列表中的位置设置每个顶点的ID。在解码其余输出时，我们将需要这个信息。我们目前感兴趣的另外两个键是`triangles`键，它包含一个表示构成每个三角形的三个点的三元组列表，以及`edges`键，它包含三角化结果中所有的边列表。`triangles`和`edges`都使用节点ID来表示顶点，因此三角形表中的一个条目如`[6,
    1, 0]`意味着第六、第一和零号顶点组成一个三角形。如果你再次查看[图 11-3](#figure11-3)右侧的图形表示，你会看到从节点6到节点1的边(*E*[(6,1)])确实和节点0形成一个三角形。`edges`列表包含所有原始边以及构成三角形所需的所有附加边（就像前面提到的边*E*[(6,1)]）。你可以使用`edges`列表或`triangles`列表来更新图形表示。Jupyter
    notebook中有一个使用`triangles`列表的示例，但我在[列表 11-3](#listing11-3)中的代码选择了`edges`列表，因为它更简洁。'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-3: Updating the gallery representations'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-3：更新画廊表示
- en: First, we create a copy of the original graph *G* to work on. We loop over the
    `edges` list in the triangulated result. For each edge, we check if it’s already
    in the edge list for *G*[2]. If it’s not, we add it. The result is a triangulated
    representation of the gallery in both a geometric and graph representation, as
    in [Figure 11-4](#figure11-4).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个原始图形*G*的副本进行处理。我们遍历三角化结果中的`edges`列表。对于每一条边，我们检查它是否已经存在于*G*[2]的边列表中。如果没有，我们就将其添加进去。最终结果是一个同时具有几何表示和图表示的画廊三角化表示，如[图
    11-4](#figure11-4)所示。
- en: '![](image_fi/502567c11/f11004.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11004.png)'
- en: 'Figure 11-4: The result of triangulating the example gallery'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：示例画廊的三角化结果
- en: You can see that the division line segments added to the graph on the left-hand
    plot match the new edges added to the graph on the right-hand plot. The set of
    vertices and segments resulting from the tessellations is technically referred
    to as a *mesh*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，左侧图表中添加到图形中的分割线段与右侧图表中添加的新增边相匹配。由镶嵌产生的顶点和线段集合在技术上被称为*网格*。
- en: 'We’re now ready to color the graph using the `greedy_color` function, which
    you’ll need to import from the `networkx.algorithms.coloring` library like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`greedy_color`函数来为图形着色，你需要从`networkx.algorithms.coloring`库中导入该函数，方法如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The response from the function is a dictionary keyed off the node identifier.
    The value represents a numeric index for the color group the node belongs to.
    [Figure 11-5](#figure11-5) shows the solution for the example gallery.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是一个以节点标识符为键的字典。值表示该节点所属的颜色组的数字索引。[图 11-5](#figure11-5)显示了示例画廊的解决方案。
- en: '![](image_fi/502567c11/f11005.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11005.png)'
- en: 'Figure 11-5: Result of greedy coloring the example gallery'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5：贪婪着色示例画廊的结果
- en: On the left you can see the solution found by the coloring algorithm. For the
    right side of the plot, I’ve removed the triangulation edges because we no longer
    need them once the coloring is done. I’ve also represented the color groups using
    different shapes—squares, diamonds, and circles—to make them easier to distinguish.
    You can think of each group as a potential deployment plan for guards. As you
    can see, not all deployments have the same number of guard positions, though.
    The circle group has three nodes in it while the others only have two; this means
    positioning guards at the locations marked by the circle nodes would require you
    to deploy an additional guard to cover all the walls.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧显示的是由着色算法找到的解决方案。在图的右侧，我已经移除了三角化边，因为一旦着色完成，我们不再需要它们。我还使用不同的形状—方形、菱形和圆形—来表示颜色组，以便更容易区分它们。你可以把每个组看作是一个潜在的守卫部署计划。如你所见，并不是所有的部署都有相同数量的守卫位置。圆形组有三个节点，而其他组只有两个；这意味着如果将守卫安排在圆形节点标记的位置，你需要部署一个额外的守卫来覆盖所有墙面。
- en: You can compare the deployments that are tied for the lowest number of nodes
    to see what practical advantages and disadvantages each offers. For example, the
    square and diamond groups both require only two guards, but the diamond deployment
    places the guards closer to each other than the square deployment. While this
    may seem like small difference, in the real world having two guards in closer
    proximity allows them to support each other more efficiently; therefore, assuming
    these deployments were my only options, I would choose the diamond deployment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以比较节点数最少的几种部署，看看每种部署方案提供的实际优缺点。例如，方形和菱形的部署组都只需要两个守卫，但菱形部署将守卫安排得比方形部署更靠近。虽然这看起来是一个微小的差异，但在现实中，两个守卫更接近可以更高效地相互支援；因此，假设这些部署是我的唯一选择，我会选择菱形部署。
- en: Now that you’ve seen the basic solution concept applied to the example gallery,
    it’s time to start refining the process and making the solution more practical
    for real-world use. The rest of this chapter focuses on refining the theoretical
    approach you’ve just seen to address some of the practical concerns mentioned
    earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到应用于示例画廊的基本解决方案概念，是时候开始优化这一过程，并使解决方案更具实用性，以便在现实世界中使用。本章的其余部分将重点关注完善你刚刚看到的理论方法，以解决之前提到的一些实际问题。
- en: Mapping Guard Coverage
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖范围映射
- en: So far, we’ve ignored the scale of the gallery. The original problem assumes
    guards have perfect, infinite vision that isn’t affected by lighting, distance,
    or crowds. But in a real-world scenario, the deployment needs to account for these
    factors with some type of maximum coverage threshold per guard location. If we
    say the scale for the example gallery is 1:300 m (meaning one unit on the graph
    is equal to 300 meters), the length of the edge *E*[(0,1)] is 600 m *E*[(0,1)]
    = 2 × 300 m = 600 m (this is about 1,968.5 feet). The area of the gallery, then,
    is about 241 m² (2,594 square feet).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们忽略了画廊的规模。原始问题假设守卫拥有完美的、无限的视力，不受光线、距离或人群的影响。但在现实场景中，部署需要考虑这些因素，并为每个守卫位置设定某种最大覆盖阈值。如果我们说示例画廊的比例是1:300米（意味着图中的一个单位等于300米），则边*E*[(0,1)]的长度是600米，*E*[(0,1)]
    = 2 × 300米 = 600米（约合1,968.5英尺）。因此，画廊的面积大约是241平方米（2,594平方英尺）。
- en: 'Using only two guards for a floor plan of that size is likely to leave gaps
    in the coverage. Add in the other environmental factors that affect visibility,^([4](b01.xhtml#c11-endnote-004))
    such as elevation (created by a slope in the floors) and lighting (often dimmed
    in portions of a gallery for dramatic effect), and it’s clear two guards would
    be woefully inadequate to secure the gallery. Therefore, we need to improve on
    the simplifications made in the theoretical model. We’ll do so by acknowledging
    that guards are really only able to guard so much area at a time. This is my second
    major reason for choosing the Triangle library: it supports the idea of a *maximum
    area threshold*, whereas the Shapely version of the function doesn’t. The maximum
    area threshold sets the largest area of any triangle created during the tessellation.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用两个守卫来覆盖如此大的平面图，可能会导致覆盖出现空隙。再加上其他影响能见度的环境因素，^([4](b01.xhtml#c11-endnote-004))，比如地面坡度引起的高差和照明（画廊的某些部分通常为了戏剧效果而调暗），显然两个守卫不足以保护整个画廊。因此，我们需要改进理论模型中的简化假设。我们将通过承认守卫一次只能保护有限的区域来做到这一点。这是我选择
    Triangle 库的第二个主要原因：它支持*最大区域阈值*的概念，而 Shapely 版本的函数不支持。最大区域阈值设置了镶嵌过程中创建的任何三角形的最大面积。
- en: If you consider each triangle as a zone that needs to be guarded, you can assign
    them to guard positions to create an area of responsibility (AOR) map that shows
    which positions are responsible for which zones as well as the overall coverage
    distribution (we saw an AOR map in [Chapter 9](c09.xhtml) with the fire station
    example). The smaller the area for each zone triangle, the closer together the
    triangles will be clustered, and therefore more triangles will be needed to tessellate
    the whole gallery. More triangles mean more points in the tessellation, which
    translates to more guard positions. It also means more color (or shape) groups
    are needed to represent them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将每个三角形视为需要守卫的区域，你可以将它们分配到守卫位置，以创建一个责任区（AOR）地图，显示哪些位置负责哪些区域，以及整体的覆盖分布（我们在[第
    9 章](c09.xhtml)的消防站示例中看到过 AOR 地图）。每个区域三角形的面积越小，三角形之间的间距就越小，因此需要更多的三角形来镶嵌整个画廊。更多的三角形意味着镶嵌中会有更多的点，从而导致更多的守卫位置。这也意味着需要更多的颜色（或形状）组来表示它们。
- en: 'To simplify the math, let’s say each zone triangle should be a maximum area
    of 30 m² (close to 323 square feet), which scales down to an area of 0.1 unit
    per triangle. We can tell Triangle to tessellate the gallery into triangles with
    a maximum area of 30 m² by adding the `a` flag to the arguments string followed
    by the scaled maximum area 0.1:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化数学计算，假设每个区域三角形的最大面积应为 30 平方米（接近 323 平方英尺），这相当于每个三角形面积为 0.1 单位。我们可以告诉 Triangle
    将画廊镶嵌成最大面积为 30 平方米的三角形，方法是将 `a` 标志添加到参数字符串中，后跟缩放后的最大面积 0.1：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To do the tessellation, the `triangulate` function will add the points necessary
    (often called *Steiner points*) for the geometry to split triangles larger than
    the maximum area until they’re all below the threshold. [Figure 11-6](#figure11-6)
    shows the result of the tessellation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行镶嵌，`triangulate` 函数会添加必要的点（通常称为*Steiner 点*），使得几何图形将大于最大面积的三角形划分为更小的三角形，直到它们都低于阈值。[图
    11-6](#figure11-6) 显示了镶嵌的结果。
- en: '![](image_fi/502567c11/f11006.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11006.png)'
- en: 'Figure 11-6: Maximum zone area 30 m² solutions'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：最大区域面积 30 平方米的解决方案
- en: On the left you can see the graph representation of the mesh. On the right you
    can see the different potential guard deployments. Since each node is a member
    of multiple triangles, the guard at that position will be responsible for all
    the triangular slices the node is a member of. Additionally, if there are any
    triangles that aren’t directly connected to one of the guard positions (as is
    the case with triangle `[3, 4, 10]` in the lower right of the gallery), we assign
    that triangle to the closest guard position to generate the AOR map. Solving the
    graph coloring required the algorithm to add a fourth group, represented by the
    star nodes. Remember, you can think of the additional groups as more potential
    deployment options and the additional points within a deployment as more guards
    being added to that deployment. In this example, the circle deployment and the
    star deployments both have three positions to cover, while the square and diamond
    deployments both require four. By the same logic as before, I’d pick the circle
    deployment because it places the guard positions closer together, whereas the
    star deployment leaves one position relatively isolated. [Figure 11-7](#figure11-7)
    shows the AOR map generated from the circle deployment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是网格的图表示，右侧则展示了不同的潜在守卫部署。由于每个节点属于多个三角形，因此该位置的守卫将负责该节点所属的所有三角形区域。此外，如果有任何三角形没有直接连接到某个守卫位置（例如，右下角画廊中的三角形`[3,
    4, 10]`），我们会将该三角形分配给距离最近的守卫位置，从而生成 AOR 图。解决图着色问题需要算法添加第四组，由星形节点表示。记住，你可以将额外的组视为更多的潜在部署选项，而部署中的额外点则表示更多的守卫被添加到该部署中。在这个例子中，圆形部署和星形部署都需要覆盖三个位置，而方形和菱形部署则需要四个位置。按照之前的逻辑，我会选择圆形部署，因为它将守卫位置安排得更紧凑，而星形部署则留下了一个相对孤立的位置。[图
    11-7](#figure11-7) 显示了从圆形部署生成的 AOR 图。
- en: '![](image_fi/502567c11/f11007.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11007.png)'
- en: 'Figure 11-7: Creating an AOR map from a selected deployment'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-7：从选定的部署创建 AOR 图
- en: The left side of the figure shows the default assignment of triangles to guards.
    The black triangle is the uncovered triangle mentioned previously. On the right
    side of the figure, you can see the result of assigning the triangle to be covered
    by the closest guard position. This does create a slight imbalance in the deployment.
    The light gray AOR contains five triangles (and therefore more square footage),
    while the other two AORs have only four.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图的左侧显示了三角形分配给守卫的默认方式。黑色三角形是前面提到的未覆盖三角形。在图的右侧，你可以看到将三角形分配给最近的守卫位置进行覆盖的结果。这确实在部署中产生了轻微的不平衡。浅灰色的
    AOR 包含了五个三角形（因此覆盖面积更大），而其他两个 AOR 只有四个三角形。
- en: '[Listing 11-4](#listing11-4) shows the function for assigning triangles to
    guards based on the deployment group:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-4](#listing11-4) 显示了根据部署组将三角形分配给守卫的函数：'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-4: Assigning triangles to guard nodes'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4：将三角形分配给守卫节点
- en: The `assign_triangles` function takes in a copy of the triangulated graph, `g`;
    the result of the `triangulate` function, `triangulated`; and finally, the ID
    for the deployment of interest, `group_id`. We begin by collecting the nodes that
    represent the guard positions into a list called `guard_nodes` based on the provided
    group ID ❶. We then create a dictionary to hold the output of the function until
    the `return` statement. The keys will be the node identifiers and the values will
    be an empty list that will eventually contain all triangles (as `Polygon` objects)
    that are assigned to that node ❷.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign_triangles` 函数接受三角化图 `g` 的副本、`triangulate` 函数的结果 `triangulated`，以及感兴趣部署的
    ID `group_id`。我们首先基于提供的组 ID ❶，将代表守卫位置的节点收集到名为 `guard_nodes` 的列表中。接着，我们创建一个字典来保存函数的输出，直到
    `return` 语句。字典的键是节点标识符，值是一个空列表，最终将包含分配给该节点的所有三角形（作为 `Polygon` 对象）❷。'
- en: To begin filling the `triangles` lists, we loop over all the triangles in `triangulated`.
    Each of these triangles represents the collection of graph nodes that form the
    triangle ❸. We turn the nodes into a `Polygon` by looking up the coordinates for
    the triangle using the provided graph `g` ❹. The next step is to check if the
    triangle nodes already contain one of the guard positions. If they do, then one
    of the three points will be in the `guard_nodes` list ❺. If the triangle isn’t
    directly connected to a guard, we determine which guard it’s closest to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始填充`triangles`列表，我们遍历`triangulated`中的所有三角形。每个三角形代表了构成三角形❸的图形节点集合。我们通过查找图形`g`中该三角形的坐标，将节点转换为`Polygon`❹。下一步是检查三角形节点是否已经包含了某个守卫位置。如果包含，则三个点中的一个将出现在`guard_nodes`列表中❺。如果三角形与守卫没有直接连接，我们将确定它与哪个守卫位置更接近。
- en: Next, we create a dictionary called `dists` that is keyed off of the guard node’s
    ID. The value for each key will be the result of the Shapely function `t_poly.distance`,
    which measures the minimum distance between the triangle polygon and a `Point`
    object representing the guard station ❻. We then find the minimum entry in the
    `dists` dictionary using the `min` function. Passing in the dictionary key list
    in the `key` parameter tells the function to return the key that has the lowest
    value instead of the value itself ❼. We use this key to assign the polygon to
    the proper list in `triangles` ❽. Finally, we return the `triangles` dictionary
    to conclude the function ❾.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`dists`的字典，字典的键是守卫节点的ID。每个键的值将是Shapely函数`t_poly.distance`的结果，该函数测量三角形多边形与表示守卫位置的`Point`对象之间的最小距离❻。然后，我们使用`min`函数查找`dists`字典中的最小条目。通过在`key`参数中传递字典的键列表，函数会返回具有最低值的键，而不是值本身❼。我们使用该键将多边形分配到`triangles`中的正确列表❽。最后，我们返回`triangles`字典以结束该函数❾。
- en: We can determine the exact area of each AOR by summing the area of all the triangles
    associated with it, as in [Listing 11-5](#listing11-5).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过求和与每个AOR相关的所有三角形的面积来确定每个AOR的精确面积，如[示例11-5](#listing11-5)所示。
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-5: Summing AOR areas'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例11-5：求和AOR面积
- en: 'For each key in the resulting `triangles` dictionary, we do a `sum` operation
    on the list of triangle areas associated with it. Notice we adjust the scale by
    multiplying each area by the scaling factor (in this case `300`). The result of
    the code for the example should be:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结果中`triangles`字典中的每个键，我们对与之关联的三角形面积列表执行`sum`操作。注意我们通过将每个面积乘以缩放因子（此例中为`300`）来调整比例。示例代码的结果应该是：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One important note about the triangle assignment function: it’s really only
    a heuristic. Depending on the shape of the gallery and the location of the different
    edges and vertices, it’s possible to assign a triangle to a guard that is “closer”
    (as measured by minimum straight-line distance, or as the crow flies) to one guard
    position but logically should be assigned to another guard. You can improve the
    function by taking into account whether the straight-line distance measured by
    Shapely intersects the body of the gallery; if it does, this indicates that the
    measurement traveled through walls and is therefore shorter than it would be in
    reality (unless your guards can phase through solid objects like concrete walls).
    You could then change the function so that it assigns the triangles to the guard
    position with the shortest distance that doesn’t intersect with any walls.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于三角形分配函数，有一点重要的说明：它实际上只是一个启发式方法。根据画廊的形状以及不同边缘和顶点的位置，有可能将一个三角形分配给“更接近”的守卫（通过最小直线距离来衡量，或者说是直线距离），但从逻辑上讲，它应该分配给另一个守卫。你可以通过考虑Shapely测量的直线距离是否与画廊的主体相交来改进该函数；如果相交，这表明测量路径穿过了墙壁，因此比实际情况要短（除非你的守卫能够穿透像混凝土墙壁这样的实心物体）。你可以改变函数，使其将三角形分配给不与任何墙壁相交的、具有最短距离的守卫位置。
- en: Another option is to change the deployment to add another guard position that
    covers the uncovered triangle. Looking closely at the graph representation on
    the right side of [Figure 11-6](#figure11-6), you can see the star at node position
    3 also could have been a circle. Sometimes there will be multiple possible solutions,
    and the coloring algorithm has to settle on the one it feels is optimal (which
    means it attempts to evenly distribute color groups as much as possible). Rather
    than just assigning the uncovered triangle to a guard position, you might opt
    to change the star node to another circle node; this maintains the validity of
    the solution but leaves every triangle covered by the deployment. On the other
    hand, it also means adding another guard to the deployment, making it less optimal
    in that sense. A future improvement for your application may involve letting users
    select the assignment strategy during the AOR map creation based on their specific
    use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是更改部署，添加一个额外的防护位置来覆盖未覆盖的三角形。仔细观察[图 11-6](#figure11-6)右侧的图形表示，你会发现节点位置 3
    的星形也可能是一个圆形。有时候会有多个可能的解决方案，着色算法必须选择它认为最优的一个（这意味着它尽可能均匀地分配颜色组）。与其直接将未覆盖的三角形分配给防护位置，你可能会选择将星形节点更改为另一个圆形节点；这样可以保持解决方案的有效性，同时确保每个三角形都被部署覆盖。另一方面，这也意味着需要向部署中添加一个额外的防护，这在某种意义上降低了其最优性。你应用的未来改进可能会允许用户在创建
    AOR 地图时根据其特定需求选择分配策略。
- en: Defining Obstructed Areas
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义受阻区域
- en: Now that we’ve covered the algorithm, how it deals with scaling, and basic AOR
    coverage maps, it’s time to deal with complex polygons. As you might recall from
    [Chapter 7](c07.xhtml), these are polygons that have holes representing areas
    of the floor plan that can’t be accessed or that obstruct visibility (a giant
    column of granite, for example).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了算法、它如何处理缩放以及基本的 AOR 覆盖地图，是时候处理复杂多边形了。如你在[第 7 章](c07.xhtml)中回顾的那样，这些多边形有孔洞，代表着不能访问的区域或遮挡视野的区域（例如，一块巨大的花岗岩柱子）。
- en: Luckily, dealing with holes inside the Triangle library is fairly easy. For
    each hole we want to define, we pass the `triangulate` function a point inside
    the hole (any point will do). The algorithm then removes triangles until it hits
    a vertex defined in the `segments` portion of the dictionary. Be aware that it’s
    possible to accidentally remove all the triangles if you improperly enclose the
    hole in segments. If this happens, you won’t receive anything back in the `triangles`
    key, so you might want to update your implementation to handle this condition
    with some form of validity check.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Triangle 库中处理孔洞相对简单。对于我们要定义的每个孔洞，我们向 `triangulate` 函数传递一个位于孔洞内的点（任何点都可以）。算法会不断移除三角形，直到遇到字典中
    `segments` 部分定义的一个顶点。需要注意的是，如果你不小心将孔洞包围在段内，可能会意外地移除所有三角形。如果发生这种情况，你将不会在 `triangles`
    键中收到任何结果，因此你可能需要更新实现，使用某种有效性检查来处理这种情况。
- en: To get the point for a hole, you can use the Shapely `representative_point`
    function, which returns a `Point` object guaranteed to be inside the boundaries
    of the shape the function was called on. The great thing about using the representative
    point is that, because Shapely doesn’t care whether the point is centered in the
    shape, it can compute it quickly. As long as the point falls within the given
    shape it is considered representative, which works great for Triangle since it
    needs to know only where to begin removing triangles from.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取孔洞的点，可以使用 Shapely 的 `representative_point` 函数，该函数返回一个 `Point` 对象，保证位于调用该函数的形状的边界内。使用代表性点的好处在于，Shapely
    不在乎点是否位于形状的中心，因此能够快速计算。只要该点位于给定形状内，就被认为是代表性点，这对于三角形来说非常有效，因为它只需要知道从哪里开始移除三角形。
- en: '[Listing 11-6](#listing11-6) shows the code to create the tessellation for
    the complex polygon.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-6](#listing11-6) 展示了创建复杂多边形镶嵌的代码。'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-6: Tessellating the complex polygon'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：镶嵌复杂多边形
- en: We start by defining the exterior coordinates for the gallery polygon into a
    list named `ext_3`. In this case the points form a large square-shaped gallery.
    Next, we define the coordinates for the hole vertices in a list named `int_3`.
    These points form a smaller square hole placed directly in the center of the larger
    square exterior. We then create the list of vertices in a variable named `verts`,
    which is a concatenated list of all exterior and interior coordinates in the shape.
    We can calculate the representative point for the hole by casting the `int_3`
    list as its own polygon and calling the `representative_point` function mentioned
    previously.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过定义画廊多边形的外部坐标，将其存储在名为`ext_3`的列表中。在此情况下，点的排列形成了一个大致的正方形画廊。接下来，我们定义一个名为`int_3`的列表，用于存储洞的顶点坐标。这些点形成一个较小的正方形洞，直接放置在较大正方形外部的中心位置。然后，我们创建一个名为`verts`的顶点列表，它是所有外部和内部坐标的连接列表。我们可以通过将`int_3`列表作为其自身的多边形，并调用前面提到的`representative_point`函数来计算洞的代表点。
- en: The `hole_p` variable now holds a `Point` whose `x` and `y` values can be used
    to identify the hole region to the Triangle library ❶. Because Triangle doesn’t
    work directly with `Point` objects, we must extract the coordinate information
    into a list ❷. Next, we create the `segs` list, which contains the list of edges
    that must be respected by the tessellation algorithm. Rather than using coordinates,
    the edges use the indices of the two vertices as the start and end of each segment.
    In more complex floor plans, it can be easier to take the segment list directly
    from the edges in the graph representation. Just be sure that all the edges and
    nodes are entered correctly, or you’ll get some unexpected results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`hole_p`变量现在保存着一个`Point`，其`x`和`y`值可用于向Triangle库标识洞区域 ❶。由于Triangle无法直接处理`Point`对象，我们必须将坐标信息提取到一个列表中
    ❷。接下来，我们创建了`segs`列表，其中包含必须被镶嵌算法遵守的边列表。与使用坐标不同，边缘使用两个顶点的索引作为每条边的起始和结束点。在更复杂的平面图中，直接从图的表示中获取边缘列表可能更方便。只需确保所有边缘和节点都已正确输入，否则您将得到一些意外的结果。'
- en: Finally, we can construct the parameter dictionary for calling the `triangulate`
    function. The only change from the previous parameter dictionary is the addition
    of the `holes` key ❸, which holds a list of coordinates that represent a point
    inside a hole to be removed. When dealing with multiple holes, you need to calculate
    a representative point for each and add it to the holes list in the dictionary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以构建用于调用`triangulate`函数的参数字典。与之前的参数字典唯一的区别是增加了`holes`键 ❸，它包含一个坐标列表，表示需要移除的洞内的某个点。当处理多个洞时，您需要为每个洞计算一个代表点，并将其添加到字典中的洞列表中。
- en: '[Figure 11-8](#figure11-8) shows the steps performed on the example complex
    polygon gallery.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-8](#figure11-8)展示了应用于示例复杂多边形画廊的步骤。'
- en: '![](image_fi/502567c11/f11008.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11008.png)'
- en: 'Figure 11-8: Applying the AGP algorithm to a complex polygon'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-8：将AGP算法应用于复杂多边形
- en: From left to right you can see the entire solution process applied to the gallery.
    The white square in the leftmost plot represents the hole in the middle of the
    gallery; the darker gray area represents the usable floor plan. In the second
    plot, you can see the result of converting the geometry into a graph. Notice that
    the hole section is entirely surrounded by edges. These edges are boundaries passed
    into the Triangle’s `triangulate` function in the `segments` key (along with the
    exterior edges, as before). The third image shows the result of tessellating the
    shape with respect to the hole. The `triangulate` function begins by creating
    the tessellation without respecting the holes and then starts removing triangles,
    beginning with any triangle that contains a point in the holes list; it continues
    removing adjacent triangles until it reaches one of the edges in the segments
    list. I didn’t apply an area constraint, so the result is a triangulation with
    the fewest number of triangles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，您可以看到应用于画廊的整个解决过程。最左侧图中的白色正方形代表画廊中央的洞；较暗的灰色区域表示可用的平面图。在第二幅图中，您可以看到将几何形状转换为图的结果。请注意，洞部分被完全边界围绕。这些边界作为`segments`键（与之前的外部边界一起）传入Triangle的`triangulate`函数。第三张图片展示了根据洞进行镶嵌的结果。`triangulate`函数首先在不考虑洞的情况下创建镶嵌，然后开始移除三角形，从包含洞内点的三角形开始；它会继续移除相邻的三角形，直到遇到`segments`列表中的边缘。由于没有应用面积约束，因此结果是一个包含最少三角形的三角化。
- en: The fourth plot shows the updated graph, which is ready for color solving to
    be applied. As you can see, none of the edges in the second or third plots cross
    into the hole space; this indicates Triangle has respected our request to ignore
    that portion of the space when generating the mesh. The final plot on the right
    shows the result of assigning the deployment groups based on the coloring solution.
    There are four potential deployments, all of which consist of two guard stations.
    If the hole weren’t present, you would theoretically need only one guard for the
    whole gallery.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个图显示了更新后的图形，准备应用颜色求解。如你所见，第二和第三个图中的任何边都没有跨入孔区空间；这表明Triangle在生成网格时尊重了我们忽略该部分空间的请求。右侧的最终图显示了基于着色解决方案分配部署组的结果。有四个潜在的部署，每个部署由两个保安岗位组成。如果没有孔区，你理论上只需要一个保安就能覆盖整个画廊。
- en: Prioritizing Guard Coverage Areas
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先考虑安保覆盖区域
- en: 'Next, we’ll refine our model to address another implicit assumption we’ve made:
    that all areas of the gallery are equally important and therefore the guard deployments
    should be evenly distributed. For example, a bank may weigh the monitoring of
    private offices lower than that of the lobby and therefore require different resources
    to protect the different spaces. To address this, we’ll refine our initial mesh
    to respect the importance (or weight) of each region of the floor plan. The underlying
    Triangle program supports multiple maximum areas (read in from custom data files),
    which allows us to get creative with how we define different AORs. To pull the
    example into our world of art gallery security, perhaps you believe the gallery
    floor needs fewer guards than the lecture hall, where people tend to gather in
    larger groups. You can see the result of assigning regions applied to the example
    square gallery in [Figure 11-9](#figure11-9).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将完善我们的模型，解决另一个我们之前隐含的假设：即认为画廊的所有区域同等重要，因此安保人员的部署应该是均匀分布的。例如，一家银行可能会认为私人办公室的监控不如大厅重要，因此需要不同的资源来保护不同的区域。为了解决这个问题，我们将优化最初的网格，以体现楼层平面图中各区域的重要性（或权重）。底层的Triangle程序支持多个最大区域（通过自定义数据文件读取），这使我们能够在定义不同的AOR（活动区域）时更加灵活。为了将这个例子与我们的艺术画廊安保相结合，也许你认为画廊的楼层比讲座厅需要的保安更少，因为人们倾向于在讲座厅形成更大的群体。你可以在[图
    11-9](#figure11-9)中看到将区域分配应用于方形画廊的结果。
- en: '![](image_fi/502567c11/f11009.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11009.png)'
- en: 'Figure 11-9: The gallery when region assignment is added'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9：添加区域分配后的画廊
- en: On the left of the figure you can see the four numbered regions I defined for
    the square gallery example. The center of each region is marked by a star as well
    as its region number. These regions are segment-bounded portions of the overall
    gallery polygon, so they can be defined using any point within the segment bounds
    (similar to the way holes are defined). In this case, I added four theoretical
    segments (the diagonal separators) to the list of segment bounds already defined
    to enclose the regions. They’re theoretical because, unlike the other segments
    that represent walls and other physical structures, the region segments represent
    logical borders between areas, not physical ones. Bear in mind that Triangle doesn’t
    know the difference, so it’s up to us to track which segments belong to which
    class. We can do so by taking advantage of edge attributes stored in the graph
    representation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左侧，你可以看到我为方形画廊示例定义的四个编号区域。每个区域的中心用星号标出，并显示该区域的编号。这些区域是整体画廊多边形的分段边界部分，因此可以使用任何在该段边界内的点来定义（类似于定义孔的方式）。在这种情况下，我在已经定义的分段边界列表中添加了四个理论分段（对角线分隔线）以包围这些区域。它们是理论性的，因为与表示墙壁和其他物理结构的其他分段不同，区域分段表示的是区域之间的逻辑边界，而不是物理边界。请记住，Triangle并不了解这些差异，因此由我们来跟踪哪些分段属于哪个类别。我们可以利用图形表示中存储的边缘属性来做到这一点。
- en: To let Triangle know that we have regions of interest, we also need to update
    the input dictionary we pass to the wrapper to include the `regions` key, as shown
    in [Listing 11-7](#listing11-7).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Triangle知道我们有感兴趣的区域，我们还需要更新传递给包装器的输入字典，加入`regions`键，如[清单 11-7](#listing11-7)所示。
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-7: Adding the region definitions for tessellation'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-7：为镶嵌添加区域定义
- en: The value for the `regions` key is a nested list. Each entry contains x- and
    y-coordinates representing a point within the associated region. During the initial
    tessellation, triangles within the bounding segments found around each region’s
    representative point are assigned the value in the third position. The fourth
    position in the list, and all subsequent ones, can contain a numeric region attribute
    (such as a modified visibility value to mark regions with softer lighting). The
    values of any region attributes you include will be inherited by the triangles
    within the region.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`regions`键的值是一个嵌套列表。每个条目包含表示相关区域内某个点的x和y坐标。在初步网格划分过程中，围绕每个区域代表点找到的边界段中的三角形将被分配第三位置的值。列表中的第四个位置以及后续的每个位置可以包含一个数字区域属性（例如，修改后的可见性值，以标记具有更柔和光照的区域）。你所包含的任何区域属性的值将被区域内的三角形继承。'
- en: 'Once the regions are defined, we can perform the initial tessellation. We’ll
    tell Triangle to include the region information in the result by adding the `A`
    flag to the `triangulate` function call:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了区域，我们就可以进行初步的网格划分。我们将通过在`triangulate`函数调用中添加`A`标志来告诉Triangle将区域信息包含在结果中：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The resulting mesh is shown on the right side of [Figure 11-9](#figure11-9).
    The dots with the numbers inside each triangle show which region identifier has
    been assigned to it. So far, the process is identical to the previous one, so
    the mesh remains unchanged.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的网格显示在[图11-9](#figure11-9)的右侧。每个三角形内的数字表示已分配给该三角形的区域标识符。到目前为止，过程与之前相同，因此网格保持不变。
- en: The next step is to save the result in a special group of files; these are essentially
    the same data in the dictionary written out to flat text files. We need to do
    this so that we can have Triangle reload the files during the refinement stage.
    Unfortunately, the wrapper library doesn’t include any functions to save, so I
    had to write my own based off the file specification in the underlying program’s
    documentation. The project code has all the functions necessary to create the
    expected files, but they’re long and fairly boring, so I’ll skip detailing them
    here. All you need to do is import the `DataSaver` class I’ve included with the
    chapter code, as shown in [Listing 11-8](#listing11-8).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将结果保存在一组特殊的文件中；这些文件本质上是字典中的相同数据写入到平面文本文件中。我们需要这样做，以便在精化阶段重新加载文件。不幸的是，包装库不包括任何保存功能，因此我必须根据底层程序文档中的文件规范编写自己的函数。项目代码包含了创建预期文件所需的所有功能，但它们很长而且相当枯燥，所以我在这里跳过详细介绍。你只需导入我在本章代码中提供的`DataSaver`类，如[清单11-8](#listing11-8)所示。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-8: Saving the tessellation result to Triangle project files'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-8：将网格划分结果保存到Triangle项目文件
- en: We start by defining the `DataSaver` instance, passing it the `triangulated`
    dictionary in the first parameter and the project name in the second. You can
    also optionally pass in a version number and directory. If you don’t pass these
    in, the version number will automatically be set to 1 and the directory will be
    the current working directory of the script. The `set_region_areas` function stores
    the list of maximum areas, and the index in the list is the same as the region
    index. If you pass in a list that is shorter than the number of regions, the remaining
    regions are treated as though they had no area constraint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`DataSaver`实例，将`triangulated`字典作为第一个参数，项目名称作为第二个参数传入。你还可以选择性地传入版本号和目录。如果不传入，版本号将自动设置为1，目录则为脚本的当前工作目录。`set_region_areas`函数存储最大区域列表，列表中的索引与区域索引相同。如果你传入的列表比区域数量短，那么剩余的区域将被视为没有面积约束。
- en: 'We need to set the region areas before we save the project using `save_project`
    so that the saver knows how to mark each triangle during the file creation. Once
    `save_file` function has completed, you’ll have a list of files in the directory
    you specified (or the current working directory, as I mentioned). Each file is
    named like so: *<project name>_<version number>.<part>* where *<part>* is one
    of the file types expected by Triangle (with a *.node*, *.ele*, *.area*, or *.poly*
    file extension). Therefore, the code in [Listing 11-8](#listing11-8) will create
    a file named */myproject/square_1.area* (among others). The *.area* file is of
    particular interest because it contains the maximum area for each triangle, which
    we just set by virtue of its region association.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`save_project`保存项目之前，我们需要设置区域面积，以便保存器知道如何在文件创建过程中标记每个三角形。一旦`save_file`函数完成，你将会在你指定的目录（或者如我之前提到的当前工作目录）中看到一系列文件。每个文件命名方式如下：*<项目名称>_<版本号>.<部分>*，其中*<部分>*是Triangle预期的文件类型之一（带有*.node*、*.ele*、*.area*或*.poly*扩展名）。因此，[清单
    11-8](#listing11-8)中的代码将创建一个名为*/myproject/square_1.area*的文件（还有其他文件）。*.area*文件尤为重要，因为它包含每个三角形的最大面积，这是我们通过区域关联设置的。
- en: 'Next we need to refine the mesh by reloading the saved data and performing
    another tessellation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过重新加载保存的数据并执行另一次网格剖分来细化网格：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We call the `load` function from the wrapper library and pass in the directory
    where the project files were stored, as well as the project name, including the
    version. These inputs find and load the data from the associated files created
    in [Listing 11-5](#listing11-5). Finally, we create the refined mesh by calling
    the `triangulate` function once again, this time on the loaded data. The option
    string `ra` tells Triangle to refine a previously generated mesh (the `r` flag)
    and to refine the mesh using constrained triangle areas (the `a` flag). Because
    Triangle is refining a mesh, and we’ve asked it to constrain the area, it will
    attempt to locate the project’s *.area* file and use that information while creating
    the refined mesh.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从包装库中调用`load`函数，并传入存储项目文件的目录以及项目名称（包括版本）。这些输入用于查找并加载在[清单 11-5](#listing11-5)中创建的相关文件中的数据。最后，我们通过再次调用`triangulate`函数来创建细化后的网格，这次是在加载的数据上进行操作。选项字符串`ra`告诉Triangle细化先前生成的网格（`r`标志）并使用约束的三角形区域来细化网格（`a`标志）。由于Triangle正在细化网格，并且我们要求它使用约束区域，它将尝试定位项目的*.area*文件，并在创建细化网格时使用该信息。
- en: During the refinement step, each triangle in the original tessellation is compared
    against the area defined in the *.area* file. If the area is larger than the maximum
    defined, the algorithm splits the triangle into smaller ones. You can see the
    result of the region areas being applied to the tessellation of the square gallery
    in [Figure 11-10](#figure11-10).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在细化步骤中，原始网格剖分中的每个三角形都会与*.area*文件中定义的区域进行比较。如果区域大于定义的最大面积，算法会将该三角形分割成更小的三角形。你可以在[图
    11-10](#figure11-10)中看到区域面积应用到正方形画廊网格剖分的结果。
- en: '![](image_fi/502567c11/f11010.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11010.png)'
- en: 'Figure 11-10: Creating a multiregion tessellation'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-10：创建多区域网格剖分
- en: 'On the left, you can see the region assignment. The areas passed in to the
    `DataSaver` class were `[-1,0.1,-1,0.3]`, which can be interpreted as: region
    0 has no maximum area constraint (marked by any negative value); region 1 has
    a maximum area constraint of 0.1; region 2 also has no constraint applied; and
    finally region 3 has a maximum area constraint of 0.3\. On the right side, region
    1 has been broken up into many small triangles, while region 3 has been divided
    up into slightly larger triangles. The result is more guard positions in region
    1 than region 3, and increased coverage in both compared to the other two zones
    with no constraints applied.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你可以看到区域分配。传递给`DataSaver`类的区域面积为`[-1,0.1,-1,0.3]`，可以解读为：区域 0 没有最大面积约束（由任何负值标记）；区域
    1 的最大面积约束为 0.1；区域 2 同样没有应用约束；最后，区域 3 的最大面积约束为 0.3。右侧显示，区域 1 被分割成了许多小三角形，而区域 3
    则被分割成了稍大的三角形。结果是，区域 1 中的防护位置比区域 3 多，而这两个区域与没有约束的其他两个区域相比，覆盖面积更大。
- en: 'We can save the refined mesh using another instance of the `DataSaver` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个`DataSaver`类实例来保存细化后的网格：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We pass in the `refined` mesh result, project name, and version once again.
    It’s standard practice to increment the version for each subsequent mesh you refine,
    so this refined mesh would be the second version of the square project. We don’t
    need to define the region areas this time unless we want to perform any further
    refinements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次传入`refined`网格结果、项目名称和版本。每次细化网格时都按标准做法增加版本号，因此这个细化后的网格将是方形项目的第二个版本。这次我们不需要定义区域区域，除非我们想要进行进一步的细化。
- en: Of course, it’d be nice if you could just add as many guards as you wanted to
    the deployment. Unfortunately, we rarely have the budget for more than some number
    of guards per shift or for some fixed number of sensor devices we can deploy per
    floor. We can tell Triangle the maximum number of Steiner points it can add to
    achieve the tessellation with the `S` flag. For example, let’s say we can only
    afford to deploy three extra guards to the square gallery. [Figure 11-11](#figure11-11)
    shows the result of adding this constraint during the refinement step.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你可以向部署中添加任意数量的守卫，那就太好了。不幸的是，我们很少有预算为每班次配备更多的守卫，或者为每层楼部署固定数量的传感器设备。我们可以通过`S`标志告诉Triangle它可以添加的最大Steiner点数，以实现切割。比如说，假设我们只能负担得起在方形画廊部署三个额外的守卫。[图11-11](#figure11-11)显示了在细化步骤中加入这个约束后的结果。
- en: '![](image_fi/502567c11/f11011.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11011.png)'
- en: 'Figure 11-11: Refined mesh with three guards'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-11：带有三个守卫的细化网格
- en: On the left, you can see the mesh we generated previously, with no restriction
    on the addition of guard points. On the right, you can see the mesh generated
    from the refinement where I restricted the output to three additional guard positions.
    Bear in mind that I didn’t change the maximum area constraint I defined earlier,
    which clearly the mesh on the right doesn’t achieve. Once Triangle runs out of
    Steiner points it can add, it can’t divide the larger triangles anymore and so
    it stops. If you’re asked to divide the gallery into small zones and then cover
    those zones with only three additional guards, you can use this result to show
    that it’s a mathematical impossibility to accomplish both goals. Hopefully this
    result gets you the budget increase you need for those additional guards!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你可以看到我们之前生成的网格，那里没有添加守卫点的限制。在右侧，你可以看到从细化中生成的网格，我将输出限制为三个额外的守卫位置。请记住，我没有更改之前定义的最大区域约束，显然右侧的网格并没有满足这个约束。一旦Triangle无法再添加Steiner点，它就无法进一步划分较大的三角形，因此它会停止。如果要求你将画廊划分为小区域，然后用仅三个额外的守卫来覆盖这些区域，你可以用这个结果证明同时实现这两个目标在数学上是不可能的。希望这个结果能为你争取到增加这些额外守卫的预算！
- en: Mapping Security Camera Field of View
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全摄像头视野映射
- en: 'The next feature to address is adding the field of view and effective range
    parameters. When discussing human guards, the field of view and effective range
    are very different from person to person so assigning these parameters is a bit
    fuzzy. Intuition and educated estimates are your best friend in these cases. However,
    when you think of guard positions as electronic devices, such as cameras or motion
    detectors, the data is easier to locate. For example, I searched Google for “security
    camera data sheet” and selected the first model I saw: Ocuity model number HMNC100
    from NetGear. After reviewing the technical data for the model (available from
    the manufacturer’s website), I found that the listed field of view was 107 degrees
    and the effective range was 7 m in total darkness (thanks to built-in infrared
    lighting). The distance during normal operational lighting is often not listed
    because the answer depends on how much detail you need to be able to distinguish,
    the focal length of the camera (which may or may not be listed in the user documents),
    and the number of pixels used to encode the information (often given as a megapixel
    rating, where 1MP is equal to one million pixels). To get a good number for effective
    distance, the best method is often to just test the camera under the conditions
    of interest.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来需要处理的特性是添加视场和有效范围参数。在讨论人类守卫时，视场和有效范围因人而异，因此分配这些参数有些模糊。在这种情况下，直觉和有根据的估算是最好的朋友。然而，当你把守卫位置看作电子设备时，比如摄像头或运动探测器，数据就容易找到。例如，我在
    Google 上搜索了“监控摄像头数据表”，并选择了我看到的第一个型号：NetGear 的 Ocuity 型号 HMNC100。通过查看该型号的技术数据（可以在制造商网站上找到），我发现列出的视场角度为
    107 度，完全黑暗中的有效范围为 7 米（得益于内置红外照明）。在正常工作照明条件下的距离通常没有列出，因为答案取决于你需要区分的细节程度、摄像头的焦距（可能在用户文档中没有列出），以及用于编码信息的像素数量（通常以百万像素（MP）为单位，1MP
    等于一百万个像素）。为了获得有效距离的较好数值，最好的方法通常是直接在感兴趣的条件下测试摄像头。
- en: We’ll assume the normal effective range *r(d)* is 20 times greater than the
    night range, *r*(*n*) = 7 m (*r*(*n*) × 20 = 140 m or about 460 feet). Since we’re
    approximating things, I’m also going to change the field of view Δ from 107 to
    104 because 107 is prime and therefore can’t be divided up into equal segments;
    this makes computing the points representing the edges of the field of view harder.
    On the other hand, 104 can be divided by several factors, including 2, which is
    also helpful for keeping the math simple. I’ll define the starting angle ϴ[(0)]
    for each of the four internal guard nodes `[4, 5, 6, 7]` as `[180, 134, 45, 351]`,
    respectively. We can define the positive peripheral angle as ![m11001](image_fi/502567c11/m11001.png)
    and the negative peripheral angle as ![m11002](image_fi/502567c11/m11002.png).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设正常有效范围 *r(d)* 是夜间范围 *r*(*n*) 的 20 倍，*r*(*n*) = 7 米（*r*(*n*) × 20 = 140 米，即约
    460 英尺）。由于我们在做近似计算，我还将视场 Δ 从 107 改为 104，因为 107 是质数，无法均分成相等的段；这会使得计算视场边缘的点变得更困难。另一方面，104
    可以被多个因子整除，包括 2，这也有助于简化计算。我将定义四个内部守卫节点 `[4, 5, 6, 7]` 的起始角度 ϴ[(0)] 分别为 `[180, 134,
    45, 351]`。我们可以将正向外围角定义为 ![m11001](image_fi/502567c11/m11001.png)，负向外围角定义为 ![m11002](image_fi/502567c11/m11002.png)。
- en: 'Finally, we can create some number of intermediary angles between the two peripheral
    angles by dividing the field of view into eight segments of 13 degrees each:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过将视场分成 8 个 13 度的段落，来创建两外围角之间的一些中介角度：
- en: δ = Δ / 8 = 13
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: δ = Δ / 8 = 13
- en: 'We can then use the `cos` and `sin` functions for each of the angles:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以对每个角度使用 `cos` 和 `sin` 函数：
- en: 'A : = [ θ( p ) − i δ] ∀ i ∈ ℤ0 − 8'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'A : = [ θ( p ) − i δ] ∀ i ∈ ℤ0 − 8'
- en: '[Figure 11-12](#figure11-12) shows the approximated coverage if you positioned
    one of these cameras at each of the four internal guard positions from the square
    example in [Figure 11-8](#figure11-8), using the starting angles just mentioned.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-12](#figure11-12) 显示了如果你将其中一台摄像头放置在 [图 11-8](#figure11-8) 中方形示例的四个内部守卫位置之一，并使用刚才提到的起始角度时，视场的近似覆盖情况。'
- en: '![](image_fi/502567c11/f11012.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c11/f11012.png)'
- en: 'Figure 11-12: Defining the field of view polygons'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-12：定义视场多边形
- en: '[Figure 11-12](#figure11-12) shows the approximate field of view coverage resulting
    from placing one of those cameras at each of the corners of the internal hole.
    As you can see, there are clearly large areas the cameras aren’t able to adequately
    cover. Furthermore, you can see someone could theoretically approach each camera
    position without ever entering the field of vision of any camera. These are examples
    of the blind spots mentioned earlier in the chapter. As a defender, you’d want
    to add more coverage to prevent these gaps. As an attacker, you could consider
    all of the uncovered assets as potentially good targets.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-12](#figure11-12)展示了将其中一台相机放置在内部孔的每个角落时，视场覆盖的近似情况。如您所见，明显有大面积区域是相机无法充分覆盖的。此外，您还可以看到，理论上，有人可以在不进入任何相机视野的情况下，接近每个相机位置。这些就是本章早些时候提到的盲区示例。作为防守方，您需要增加更多的覆盖范围来防止这些空隙。作为攻击方，您可以将所有未覆盖的资产视为潜在的好目标。'
- en: One last note about field of view mapping. I’ve assumed that the cameras are
    pointed and then left stationary. Several high-end cameras include a device called
    a gimbal that allows a remote operator to move the camera as needed. Some mid-level
    cameras also include the ability to automatically sweep back and forth across
    an area. These types of cameras are becoming less popular these days, but they’re
    still good to be aware of; not all field of view maps are going to be static.
    Be sure to look out for features like these when you’re analyzing the data sheets
    for devices; you may need to update your implementation to produce the full range
    of vision for these cases.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视场映射的最后一点说明。我假设这些相机是指向并保持静止的。几款高端相机包括一种叫做云台的装置，可以让远程操作员根据需要移动相机。部分中端相机也包括自动前后扫视一个区域的功能。这些类型的相机近年来变得不太流行，但仍然值得了解；并非所有的视场地图都是静态的。在分析设备数据表时，务必留意这些特性；您可能需要更新实现，以适应这些情况下的完整视野范围。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You now have all the code necessary to solve the core of the art gallery problem,
    including methods for handling real-world constraints, such as limited budgets
    and effective range for sensors. We’ve discussed the power of the Triangle library
    and combined it with Shapely and NetworkX to model the problem with both a geometric
    and graph representation. Perhaps most important of all, you should now be comfortable
    explaining the AGP theory and discussing the practical constraints applied within
    the application. There’s a large body of research you can tap into to continue
    developing your understanding of the problem. I didn’t even touch on how the greedy
    color algorithm functions under the hood, for example.^([5](b01.xhtml#c11-endnote-005))
    Node coloring in general is a great graph theory topic with many applications
    outside the AGP, but for our purposes, studying node-coloring algorithms can help
    you understand the solutions your application outputs (and how you can potentially
    modify them) more completely. For a more in-depth description of the geometric
    implications of different gallery layouts, check out the paper “Note on an Art
    Gallery Problem.”^([6](b01.xhtml#c11-endnote-006))
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经掌握了解决艺术画廊问题核心所需的所有代码，包括处理现实世界约束条件的方法，如有限预算和传感器有效范围。我们已经讨论了Triangle库的强大功能，并将其与Shapely和NetworkX结合，采用几何和图形表示法对问题进行了建模。也许最重要的是，您现在应该能够自如地解释AGP理论，并讨论应用中所涉及的实际约束条件。您可以利用大量的研究资料继续深入理解这个问题。例如，我甚至没有涉及贪心着色算法如何在后台运行。^([5](b01.xhtml#c11-endnote-005))
    一般来说，节点着色是一个伟大的图论话题，除了AGP之外，它还有很多应用；但就我们来说，研究节点着色算法可以帮助您更全面地理解您的应用输出的解决方案（以及您可能如何修改它们）。关于不同画廊布局的几何含义，您可以查看论文《艺术画廊问题注解》以获得更深入的描述。^([6](b01.xhtml#c11-endnote-006))
- en: To continue developing the core of the system, you can identify additional use
    cases that may be of interest to the users you want to serve. For example, you
    might want a use case to cover users who want to compare before and after deployment
    plans. Once you collect the use cases, you can develop the additional functions
    needed to support them. Additionally, you can continue to refine the functions
    included here. The triangle assignment function is one excellent area to improve
    upon using one of the options we discussed previously. Remember, you don’t necessarily
    need to develop all of these features before taking your application to the market.
    Developing an MVP is all about picking the key features that make your application
    useful to users. Oftentimes, figuring out these key features is a matter of analyzing
    competitive software offerings and answering the questions, “What features do
    all these applications offer?” and “What features does my application offer that
    the others do not?”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续开发系统的核心，你可以识别可能对目标用户有吸引力的额外用例。例如，你可能希望有一个用例来覆盖那些想要比较部署前后计划的用户。一旦收集了这些用例，你可以开发支持它们所需的额外功能。此外，你还可以继续完善此处包含的功能。三角形分配功能是一个优秀的改进领域，你可以使用我们之前讨论过的某个选项来提升它。记住，你不一定需要在将应用程序推向市场之前开发所有这些功能。开发最小可行产品（MVP）的关键在于选择那些能让你的应用对用户有用的核心功能。通常，确定这些核心功能就是分析竞争软件并回答两个问题：“这些应用都提供了哪些功能？”以及“我的应用提供了哪些其他应用没有的功能？”
- en: Once you can answer those two questions, you’re ready to move on to the next
    chapters, where we’ll go from the core algorithm developed in this chapter to
    a full-fledged Python application. We’ll finish out the project by mapping out
    the user interaction, adding graphics, selecting a modern processing architecture,
    and deciding whether to add application licensing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能回答这两个问题，你就可以继续进入下一章，我们将从本章开发的核心算法，扩展为一个完整的 Python 应用程序。我们将通过绘制用户交互图、添加图形、选择现代处理架构以及决定是否添加应用程序许可，来完成这个项目。
