- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributing Security Resources to Guard a Space
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The remainder of the book will focus on a single, extremely practical application.
    Known as the art gallery problem, this classic application has plenty of research
    for us to leverage and deals with efficiently distributing security resources
    to guard a space. Efficiency is an imperative for today’s security teams: there
    are always more assets to protect than there are resources to protect them. In
    its grandest form, the art gallery problem ties together the two main disciplines
    we’ve been studying: graph theory and computational geometry. It’s fitting, then,
    that this part of the book will also represent the most complete Python application
    yet, going beyond a conceptual design and into the realm of a full-fledged software
    project. We’ll cover the design, development, and delivery options for a modern
    Python project, including graphics, distributed computation, and licensing your
    application to users.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal for this part of the book is to develop a *minimum viable product (MVP)*,
    which can be considered a step up from a proof of concept. As you’ve seen, a proof
    of concept proves that an idea is worth pursuing and defines the framework for
    future development. It’s usually constrained to only the functions necessary to
    get an idea off the ground—no bells or whistles included. An MVP design, on the
    other hand, is concerned with the smallest number of features you could produce
    to bring an idea to market and “be competitive.” Typically this means adding features
    like a GUI as well as user-friendly elements, such as save and restore functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no exact set of features that make an application viable, because they’re
    ultimately dictated by the expectations of the users in that particular market.
    For example, in the security market, users have come to expect features like single
    sign-on (SSO), data encryption, push notifications, and so on. Does this mean
    you need to develop all of these features before you can bring a security tool
    to the market? Absolutely not! Think minimally and ask yourself, “What features
    do all the applications similar to mine share?” When you’re developing a product
    for users, it’s tempting to try to anticipate all their needs up front, but this
    mentality is impractical and expensive: you’ll often end up solving problems that
    no one would have encountered (edge-case code) or developing features that only
    confuse new users. If you instead release a product that contains a minimal set
    of clearly labeled features, you can get feedback on the actual problems users
    see and conveniences they’re missing. Iterative improvement plans allow you to
    focus development time on features that will actually be useful.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s jump into the art gallery problem, which asks, “What is the minimum
    number of guards that need to be placed in a gallery (represented by an *n*-vertex
    simple polygon) such that all points of the interior are visible?” This is a resource
    planning problem similar to the fire station placement problem from [Chapter 9](c09.xhtml).
    A good plan for the placement of security personnel, checkpoints, and monitoring
    devices can reduce the number of incidents a security team will need to respond
    to from the start. It can also improve the response time when an incident does
    occur, thus reducing the overall risk. Unfortunately, there are often differing
    levels of understanding among human planners on a security team, which can lead
    to poorly planned (or poorly implemented) security controls. That’s why I’m always
    searching for ways to automate portions of my team’s planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was during one of these searches that I discovered the art gallery problem,
    which addressed the very problem I was researching: the efficient deployment of
    security resources for buildings with what we’ll call “untraditional” layouts.
    As you’ll see, not all building designs lend themselves equally well to being
    guarded, so before we get into the details of the problem, we’ll cover the use
    cases for the application we plan to develop. Then we’ll be ready to start developing
    the core of the application logic. We’ll cover the existing research and show
    the theory in its simplest form. We’ll then move on to defining the two data representations
    we’re going to use in solving the problem and discuss the data structures. Finally,
    we’ll go beyond the base model to allow for more realistic deployments by adding
    advanced concepts like field of view and budget constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Minimum Number of Guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use the original problem statement as our first use case: a user wants
    to know the minimum number of guards to protect an unconventional floor plan.
    We want all the guards together to be able to observe the whole gallery (all points
    of the interior, or the walls, in the original problem statement). For this use
    case, our application will need functions that can encode floor plans in a data
    format the computer can analyze as well as an algorithm that can do the actual
    guard placement. We’ll go through that in the rest of this chapter, once we’ve
    covered a few more use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next use case deals with informing the architectural design of secure facilities
    and can be summarized like so: a user wants to analyze the security coverage and
    layout of a building. Prior to building a secure facility, the CAD drafts of a
    few potential floor plans are run through a *building information modeling (BIM)*
    program. The hypothetical building designs are rated on the difficulty to secure,
    access to emergency exits, accessibility features (like ramps and elevators),
    and more. For this use case, the application will need to define the effective
    coverage for different types of security equipment, including human guards’ cameras
    and other electronic sensors.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this analysis can also inform an attacker of flaws in a security
    layout. Every heist movie has a scene where the protagonists lay out the blueprint
    for their target and start to mark where the impossibly large number of security
    controls are, until they spot a flaw. Sensor blind spots are a favorite trope
    for these films, but the truth is that blind spots are a real-world consideration.
    By observing the guards and sensors in use, you can make a fairly accurate coverage
    map. Finding blind spots is often a simple matter of searching for the model’s
    technical specifications document. Information such as field of view, often given
    in degrees, as well as effective range, given in feet or meters, tells you not
    only where the device can detect but also where it can’t! To support this use
    case, the application we’re developing will create a visual layout of how the
    gallery is divided among the security resources. A user will be able to inspect
    the layout to see any gaps in the coverage. We’ll also develop a solver that will
    suggest additional vertices where guards can be placed to achieve customizable
    coverage goals, and we’ll add the concepts of distance, field of view, and effective
    range so we can differentiate between a guard, camera, motion sensor, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many buildings, particularly galleries and museums, are multistory buildings,
    so we can assume a professional using our software would want it to work on all
    the floor plans. Because the project needs to contain multiple assets, such as
    the shape data and the floor plan itself, it’s also safe to assume a user will
    want a way to back up their work or resume working across multiple sessions. We’ll
    wrap these all together in the final use case: a user wants to plan security for
    multiple floors of the same building across multiple work sessions. The program
    we develop will do this by creating a set of custom objects that can be serialized,
    encoded, and stored in a compressed file between sessions. We’re going to treat
    each floor of a multilevel building as separate 2D floor plans that can be grouped
    into a single multifloor project. Each floor will contain an image representing
    the background used to trace the gallery shape as well as all of the geometric
    information added by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Studying blueprints and CAD designs of buildings is an excellent habit to form,
    especially for physical penetration testers. Simply by knowing the layout of a
    facility and walking confidently, I’ve passed myself off as belonging in a building.
    After all, who would know that “utility closet #2” is on the basement level, west
    end, if not someone who had been there before? Pair that knowledge of the layout
    with a clipboard, toolbox, or other official-looking props, and it’s often just
    as good as a building pass.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our use cases, we can start diving into the nuts and bolts.
    Let’s start by reviewing the original problem and some research performed in the
    past. We’ll then cover the solution steps in depth and discuss additional constraints
    you can add to customize the results to specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Art Gallery Problem Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first well-known theorem on the art gallery problem was written in 1973
    by computer scientist and professor Václav Chvátal. This question was posed to
    him by a former University of Washington mathematics professor, Victor Klee:'
  prefs: []
  type: TYPE_NORMAL
- en: Given the floor plan of a weirdly shaped art gallery having *n* straight sides,
    how many guards will we need to post, in the worst case, so that every bit of
    wall is visible to a guard?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The *Chvátal AGP theorem* gives an upper bound that states, “At most *n* / 3
    guards is always sufficient, and sometimes required, to cover a polygon with *n*
    vertices.”^([1](b01.xhtml#c11-endnote-001)) Chvátal assumed in his proof that
    guards would be placed on the vertices, but *Chvátal’s upper bound* remains true
    even if the restriction of guards at corners is loosened to “guards anywhere within
    the interior of the polygon.” The 3 constant comes from decomposing the shape
    of the gallery into triangles, based on the reasoning that you would only ever
    need one guard per triangular section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chvátal’s work was later simplified by mathematics professor Steve Fisk, who
    reduced the problem to a three-color problem, defining it as follows: “Under what
    conditions can the regions of a planar map be colored in three colors so that
    no two regions with a common boundary have the same color?” The three-color problem
    can be represented easily as a graph, where each vertex of the gallery’s shape
    constitutes a node and each edge marks a shared wall segment between two vertices.
    You can then treat the problem as a *vertex-coloring problem*, where two nodes
    of the same color can’t be directly connected by an edge. The graph version of
    the coloring problem is a popular method to analyze connectivity, so NetworkX
    includes a function to solve it for us, known as *greedy coloring*, that we’ll
    leverage in our solution. [Figure 11-1](#figure11-1) shows the simplest case of
    the greedy coloring algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: Solving the simplest art gallery problem'
  prefs: []
  type: TYPE_NORMAL
- en: The leftmost image in [Figure 11-1](#figure11-1) shows a triangle polygon. The
    upper bound of *n* / 3 = 3 / 3 = 1 means we should need only one guard to observe
    the entire interior. The middle image shows the result of converting the triangle
    into a graph representation. Finally, the rightmost image shows the result of
    the greedy coloring algorithm. As expected, each node gets colored a different
    color, meaning placing one guard at any one of those points would enable them
    to observe all the walls. This is the core of the process. To expand the algorithm,
    we just need to solve a series of interconnected triangles, as you’ll see in the
    next section on the geometric and graph representations.
  prefs: []
  type: TYPE_NORMAL
- en: In a 2008 thesis paper, Mikael Pålsson and Joachim Ståhl examine the three-color
    algorithm and propose a set of alternate “rectangular” algorithms (ones that operate
    on orthogonal polygons only) specifically designed with camera placement in mind.^([2](b01.xhtml#c11-endnote-002))
    Pålsson and Ståhl were able to address several practical pitfalls of Chvátal’s
    theorem. First, by restricting themselves to orthogonal polygons, they reduce
    the upper bound to *n* / 4\. Second, their camera placement version of the problem
    addresses concerns like limited field of view, effective range, and obstacles,
    which apply equally well to human guards as well as cameras. These additional
    goals make the placement selection more realistic than the standard formulation.
    We’ll discuss field of view and effective range more in a bit. We’ll also add
    the ability to weight areas to prioritize the required coverage. Other constraints,
    such as making sure that each camera is visible to another camera (common in high-security
    areas), won’t be covered but are definitely worth your time to research.
  prefs: []
  type: TYPE_NORMAL
- en: Because it uses orthogonal polygons, Pålsson and Ståhl’s approach is less practical
    for general use in planning security layouts. Anywhere there’s a diagonal or curved
    wall will require multiple small rectangles to approximate the shape. One of my
    favorite examples of unconventional architecture is the Guggenheim Museum in New
    York, shown in [Figure 11-2](#figure11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: The Guggenheim, designed by Frank Lloyd Wright (© 2023 Frank Lloyd
    Wright Foundation. All Rights Reserved. Licensed by Artists Rights Society.)'
  prefs: []
  type: TYPE_NORMAL
- en: On the left you can see a top-down view of the lower level, the lecture auditorium.
    The grid laid over the floor plan represents 8 square feet. As you can see, near
    the rounded walls and near the diagonal walls, the squares are cut off in places.
    These are the areas where a purely orthogonal approach would struggle. On the
    right you can see a cross section of the museum showing the circular structure
    that continues throughout the majority of the building. It makes for beautiful
    architecture, but it also makes the museum difficult to map with orthogonal polygons.
  prefs: []
  type: TYPE_NORMAL
- en: To counter the shortcomings of the orthogonal approach, we’re going to allow
    users to draw one or more complex polygons directly on top of an image of the
    building’s floor plan. We’ll treat each individual polygon as a distinct area
    that needs to be guarded, similar to the original problem definition. Each polygon
    will be subdivided using a modified triangular tessellation called a constrained
    Delaunay triangulation. We’ll then convert the tessellated geometry into an unweighted
    graph, which we can solve using the greedy coloring algorithm from NetworkX. This
    process allows users to input unconventional floor plans like that of the Guggenheim
    and solve them for a wide variety of potential scenarios, while still respecting
    the real-world limitations of the resources involved.
  prefs: []
  type: TYPE_NORMAL
- en: Geometric and Graph Representations of the Gallery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s consider how we’d represent the gallery space as a `Polygon` object,
    just as we represented the park in [Chapter 7](c07.xhtml). [Figure 11-3](#figure11-3)
    shows the example gallery.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Representing the gallery with a polygon and graph'
  prefs: []
  type: TYPE_NORMAL
- en: On the left you see the polygon; the gray area represents the interior of the
    gallery. On the right you see the translation of the shape into a simple NetworkX
    graph. There are a number of ways you could convert the information in a `Polygon`
    into a graph, but often the simplest option is to iterate over the vertices of
    the `Polygon`’s exterior, as in [Listing 11-1](#listing11-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: Creating the gallery representations'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 11-1](#listing11-1), we first define the gallery `Polygon` ❶ by
    passing in the list of vertices as before. Then we add the first node, which represents
    the vertices at index 0 in the coordinates list ❷. Each node in the graph is keyed
    by its index in the vertex list to help keep the two representations logically
    tied together. The first point serves as an anchor for the shape and makes it
    easier to create the edges—we’ll do this momentarily. Before we do so, however,
    we have to add the coordinates to a position list called `pos` ❸, which will make
    it easier to display the graph so that it matches the shape of the polygon. Next,
    we loop over the remaining vertices ❹ to finish filling in the graph. For each
    remaining vertex, we add an edge between the previously defined node at `i-1`
    and the current node at `i` ❺. Adding the edge creates the node *V*[(][*i*][)]
    and adds the edge *E*[(][*i*] [– 1,][*i*][)] in one line. Storing the coordinate
    information for the vertex as node metadata can serve as a more flexible alternative
    to the `pos` list. We’ll do so by passing the coordinates in the `coords` parameter
    ❻. Finally, if `i` is equal to the last index, it’s time to create the final closing
    edge between the last node defined and the anchor node at index 0 ❼.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to generate the two representations of the gallery, let’s
    go over the process of solving the art gallery problem in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the Gallery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already covered the start of the art gallery problem (AGP) algorithm,
    which creates the two base data structures we’ll be working with. The next step
    in the process is to tessellate the geometric shape into triangles and add the
    resulting edges to the graph representations. Remember, any changes that you make
    to one representation need to be done to the other as well, to maintain their
    logical equivalence. Rather than using the Shapely `triangulate` function as we
    did in [Chapter 7](c07.xhtml), we’re going to use a purpose-built wrapper library
    called Triangle. The underlying application is a C-based program, also called
    Triangle, which was created by Professor Jonathan Shewchuk.^([3](b01.xhtml#c11-endnote-003))
    There are several reasons for choosing Triangle over Shapely. First, the Shapely
    version performs what’s known as a Delaunay triangulation, which in its pure form
    doesn’t respect edges; on the other hand, the Triangle library performs a *constrained*
    Delaunay triangulation, which can respect boundaries. [Listing 11-2](#listing11-2)
    shows the code to tessellate the gallery polygon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: Performing the triangular tessellation with the Triangle library'
  prefs: []
  type: TYPE_NORMAL
- en: The `triangulate` function expects a dictionary with two required keys. The
    `vertices` key holds the coordinates for the exterior of the shape. The `segments`
    key holds the edges that should be enforced while performing the tessellation.
    We pass the dictionary as the first argument to the `triangulate` function. The
    second optional argument is a string containing the settings to pass to the underlying
    application. There are a large number of configuration flags, and you can pass
    multiple arguments in the string. The `p` flag tells the library to treat the
    shape as a *planar straight-line graph*. The `e` flag tells the library to return
    the edge list as part of the result. Having the list included saves us a step
    when updating the graph representation, as we can simply compare the edges in
    the result to the edges in the graph and add any that are missing.
  prefs: []
  type: TYPE_NORMAL
- en: The `triangulate` function returns a dictionary. It includes a list called `vertices`
    that sets the ID for each vertex based on its position in this list. We’ll need
    this when decoding the rest of the outputs. The other two keys we’re interested
    in at the moment are the `triangles` key, which contains a list of triplets representing
    the three points making up each triangle, and the `edges` key, which contains
    a list of all the edges resulting from the triangulation. Both the `triangles`
    and `edges` use the node ID to denote vertices, so an entry in the triangle table
    like `[6, 1, 0]` means the sixth, first, and zeroth vertices form a triangle.
    If you look at the graph representation on the right side of [Figure 11-3](#figure11-3)
    again, you’ll see that adding an edge from node 6 to node 1 (*E*[(6,1)]) does
    indeed form a triangle with node 0\. The `edges` list contains all of the original
    edges plus all the additional edges needed to form the triangles (like the edge
    *E*[(6,1)] just mentioned). You can use either the `edges` list or the `triangles`
    list to update the graph representation. The Jupyter notebook has an example of
    using the `triangles` list, but I chose the `edges` list for the code in [Listing
    11-3](#listing11-3) because it’s more succinct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: Updating the gallery representations'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a copy of the original graph *G* to work on. We loop over the
    `edges` list in the triangulated result. For each edge, we check if it’s already
    in the edge list for *G*[2]. If it’s not, we add it. The result is a triangulated
    representation of the gallery in both a geometric and graph representation, as
    in [Figure 11-4](#figure11-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: The result of triangulating the example gallery'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the division line segments added to the graph on the left-hand
    plot match the new edges added to the graph on the right-hand plot. The set of
    vertices and segments resulting from the tessellations is technically referred
    to as a *mesh*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now ready to color the graph using the `greedy_color` function, which
    you’ll need to import from the `networkx.algorithms.coloring` library like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The response from the function is a dictionary keyed off the node identifier.
    The value represents a numeric index for the color group the node belongs to.
    [Figure 11-5](#figure11-5) shows the solution for the example gallery.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: Result of greedy coloring the example gallery'
  prefs: []
  type: TYPE_NORMAL
- en: On the left you can see the solution found by the coloring algorithm. For the
    right side of the plot, I’ve removed the triangulation edges because we no longer
    need them once the coloring is done. I’ve also represented the color groups using
    different shapes—squares, diamonds, and circles—to make them easier to distinguish.
    You can think of each group as a potential deployment plan for guards. As you
    can see, not all deployments have the same number of guard positions, though.
    The circle group has three nodes in it while the others only have two; this means
    positioning guards at the locations marked by the circle nodes would require you
    to deploy an additional guard to cover all the walls.
  prefs: []
  type: TYPE_NORMAL
- en: You can compare the deployments that are tied for the lowest number of nodes
    to see what practical advantages and disadvantages each offers. For example, the
    square and diamond groups both require only two guards, but the diamond deployment
    places the guards closer to each other than the square deployment. While this
    may seem like small difference, in the real world having two guards in closer
    proximity allows them to support each other more efficiently; therefore, assuming
    these deployments were my only options, I would choose the diamond deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the basic solution concept applied to the example gallery,
    it’s time to start refining the process and making the solution more practical
    for real-world use. The rest of this chapter focuses on refining the theoretical
    approach you’ve just seen to address some of the practical concerns mentioned
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Guard Coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve ignored the scale of the gallery. The original problem assumes
    guards have perfect, infinite vision that isn’t affected by lighting, distance,
    or crowds. But in a real-world scenario, the deployment needs to account for these
    factors with some type of maximum coverage threshold per guard location. If we
    say the scale for the example gallery is 1:300 m (meaning one unit on the graph
    is equal to 300 meters), the length of the edge *E*[(0,1)] is 600 m *E*[(0,1)]
    = 2 × 300 m = 600 m (this is about 1,968.5 feet). The area of the gallery, then,
    is about 241 m² (2,594 square feet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using only two guards for a floor plan of that size is likely to leave gaps
    in the coverage. Add in the other environmental factors that affect visibility,^([4](b01.xhtml#c11-endnote-004))
    such as elevation (created by a slope in the floors) and lighting (often dimmed
    in portions of a gallery for dramatic effect), and it’s clear two guards would
    be woefully inadequate to secure the gallery. Therefore, we need to improve on
    the simplifications made in the theoretical model. We’ll do so by acknowledging
    that guards are really only able to guard so much area at a time. This is my second
    major reason for choosing the Triangle library: it supports the idea of a *maximum
    area threshold*, whereas the Shapely version of the function doesn’t. The maximum
    area threshold sets the largest area of any triangle created during the tessellation.'
  prefs: []
  type: TYPE_NORMAL
- en: If you consider each triangle as a zone that needs to be guarded, you can assign
    them to guard positions to create an area of responsibility (AOR) map that shows
    which positions are responsible for which zones as well as the overall coverage
    distribution (we saw an AOR map in [Chapter 9](c09.xhtml) with the fire station
    example). The smaller the area for each zone triangle, the closer together the
    triangles will be clustered, and therefore more triangles will be needed to tessellate
    the whole gallery. More triangles mean more points in the tessellation, which
    translates to more guard positions. It also means more color (or shape) groups
    are needed to represent them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the math, let’s say each zone triangle should be a maximum area
    of 30 m² (close to 323 square feet), which scales down to an area of 0.1 unit
    per triangle. We can tell Triangle to tessellate the gallery into triangles with
    a maximum area of 30 m² by adding the `a` flag to the arguments string followed
    by the scaled maximum area 0.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To do the tessellation, the `triangulate` function will add the points necessary
    (often called *Steiner points*) for the geometry to split triangles larger than
    the maximum area until they’re all below the threshold. [Figure 11-6](#figure11-6)
    shows the result of the tessellation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Maximum zone area 30 m² solutions'
  prefs: []
  type: TYPE_NORMAL
- en: On the left you can see the graph representation of the mesh. On the right you
    can see the different potential guard deployments. Since each node is a member
    of multiple triangles, the guard at that position will be responsible for all
    the triangular slices the node is a member of. Additionally, if there are any
    triangles that aren’t directly connected to one of the guard positions (as is
    the case with triangle `[3, 4, 10]` in the lower right of the gallery), we assign
    that triangle to the closest guard position to generate the AOR map. Solving the
    graph coloring required the algorithm to add a fourth group, represented by the
    star nodes. Remember, you can think of the additional groups as more potential
    deployment options and the additional points within a deployment as more guards
    being added to that deployment. In this example, the circle deployment and the
    star deployments both have three positions to cover, while the square and diamond
    deployments both require four. By the same logic as before, I’d pick the circle
    deployment because it places the guard positions closer together, whereas the
    star deployment leaves one position relatively isolated. [Figure 11-7](#figure11-7)
    shows the AOR map generated from the circle deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: Creating an AOR map from a selected deployment'
  prefs: []
  type: TYPE_NORMAL
- en: The left side of the figure shows the default assignment of triangles to guards.
    The black triangle is the uncovered triangle mentioned previously. On the right
    side of the figure, you can see the result of assigning the triangle to be covered
    by the closest guard position. This does create a slight imbalance in the deployment.
    The light gray AOR contains five triangles (and therefore more square footage),
    while the other two AORs have only four.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-4](#listing11-4) shows the function for assigning triangles to
    guards based on the deployment group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: Assigning triangles to guard nodes'
  prefs: []
  type: TYPE_NORMAL
- en: The `assign_triangles` function takes in a copy of the triangulated graph, `g`;
    the result of the `triangulate` function, `triangulated`; and finally, the ID
    for the deployment of interest, `group_id`. We begin by collecting the nodes that
    represent the guard positions into a list called `guard_nodes` based on the provided
    group ID ❶. We then create a dictionary to hold the output of the function until
    the `return` statement. The keys will be the node identifiers and the values will
    be an empty list that will eventually contain all triangles (as `Polygon` objects)
    that are assigned to that node ❷.
  prefs: []
  type: TYPE_NORMAL
- en: To begin filling the `triangles` lists, we loop over all the triangles in `triangulated`.
    Each of these triangles represents the collection of graph nodes that form the
    triangle ❸. We turn the nodes into a `Polygon` by looking up the coordinates for
    the triangle using the provided graph `g` ❹. The next step is to check if the
    triangle nodes already contain one of the guard positions. If they do, then one
    of the three points will be in the `guard_nodes` list ❺. If the triangle isn’t
    directly connected to a guard, we determine which guard it’s closest to.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a dictionary called `dists` that is keyed off of the guard node’s
    ID. The value for each key will be the result of the Shapely function `t_poly.distance`,
    which measures the minimum distance between the triangle polygon and a `Point`
    object representing the guard station ❻. We then find the minimum entry in the
    `dists` dictionary using the `min` function. Passing in the dictionary key list
    in the `key` parameter tells the function to return the key that has the lowest
    value instead of the value itself ❼. We use this key to assign the polygon to
    the proper list in `triangles` ❽. Finally, we return the `triangles` dictionary
    to conclude the function ❾.
  prefs: []
  type: TYPE_NORMAL
- en: We can determine the exact area of each AOR by summing the area of all the triangles
    associated with it, as in [Listing 11-5](#listing11-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: Summing AOR areas'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each key in the resulting `triangles` dictionary, we do a `sum` operation
    on the list of triangle areas associated with it. Notice we adjust the scale by
    multiplying each area by the scaling factor (in this case `300`). The result of
    the code for the example should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One important note about the triangle assignment function: it’s really only
    a heuristic. Depending on the shape of the gallery and the location of the different
    edges and vertices, it’s possible to assign a triangle to a guard that is “closer”
    (as measured by minimum straight-line distance, or as the crow flies) to one guard
    position but logically should be assigned to another guard. You can improve the
    function by taking into account whether the straight-line distance measured by
    Shapely intersects the body of the gallery; if it does, this indicates that the
    measurement traveled through walls and is therefore shorter than it would be in
    reality (unless your guards can phase through solid objects like concrete walls).
    You could then change the function so that it assigns the triangles to the guard
    position with the shortest distance that doesn’t intersect with any walls.'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to change the deployment to add another guard position that
    covers the uncovered triangle. Looking closely at the graph representation on
    the right side of [Figure 11-6](#figure11-6), you can see the star at node position
    3 also could have been a circle. Sometimes there will be multiple possible solutions,
    and the coloring algorithm has to settle on the one it feels is optimal (which
    means it attempts to evenly distribute color groups as much as possible). Rather
    than just assigning the uncovered triangle to a guard position, you might opt
    to change the star node to another circle node; this maintains the validity of
    the solution but leaves every triangle covered by the deployment. On the other
    hand, it also means adding another guard to the deployment, making it less optimal
    in that sense. A future improvement for your application may involve letting users
    select the assignment strategy during the AOR map creation based on their specific
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Obstructed Areas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve covered the algorithm, how it deals with scaling, and basic AOR
    coverage maps, it’s time to deal with complex polygons. As you might recall from
    [Chapter 7](c07.xhtml), these are polygons that have holes representing areas
    of the floor plan that can’t be accessed or that obstruct visibility (a giant
    column of granite, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, dealing with holes inside the Triangle library is fairly easy. For
    each hole we want to define, we pass the `triangulate` function a point inside
    the hole (any point will do). The algorithm then removes triangles until it hits
    a vertex defined in the `segments` portion of the dictionary. Be aware that it’s
    possible to accidentally remove all the triangles if you improperly enclose the
    hole in segments. If this happens, you won’t receive anything back in the `triangles`
    key, so you might want to update your implementation to handle this condition
    with some form of validity check.
  prefs: []
  type: TYPE_NORMAL
- en: To get the point for a hole, you can use the Shapely `representative_point`
    function, which returns a `Point` object guaranteed to be inside the boundaries
    of the shape the function was called on. The great thing about using the representative
    point is that, because Shapely doesn’t care whether the point is centered in the
    shape, it can compute it quickly. As long as the point falls within the given
    shape it is considered representative, which works great for Triangle since it
    needs to know only where to begin removing triangles from.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-6](#listing11-6) shows the code to create the tessellation for
    the complex polygon.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-6: Tessellating the complex polygon'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the exterior coordinates for the gallery polygon into a
    list named `ext_3`. In this case the points form a large square-shaped gallery.
    Next, we define the coordinates for the hole vertices in a list named `int_3`.
    These points form a smaller square hole placed directly in the center of the larger
    square exterior. We then create the list of vertices in a variable named `verts`,
    which is a concatenated list of all exterior and interior coordinates in the shape.
    We can calculate the representative point for the hole by casting the `int_3`
    list as its own polygon and calling the `representative_point` function mentioned
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: The `hole_p` variable now holds a `Point` whose `x` and `y` values can be used
    to identify the hole region to the Triangle library ❶. Because Triangle doesn’t
    work directly with `Point` objects, we must extract the coordinate information
    into a list ❷. Next, we create the `segs` list, which contains the list of edges
    that must be respected by the tessellation algorithm. Rather than using coordinates,
    the edges use the indices of the two vertices as the start and end of each segment.
    In more complex floor plans, it can be easier to take the segment list directly
    from the edges in the graph representation. Just be sure that all the edges and
    nodes are entered correctly, or you’ll get some unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can construct the parameter dictionary for calling the `triangulate`
    function. The only change from the previous parameter dictionary is the addition
    of the `holes` key ❸, which holds a list of coordinates that represent a point
    inside a hole to be removed. When dealing with multiple holes, you need to calculate
    a representative point for each and add it to the holes list in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-8](#figure11-8) shows the steps performed on the example complex
    polygon gallery.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Applying the AGP algorithm to a complex polygon'
  prefs: []
  type: TYPE_NORMAL
- en: From left to right you can see the entire solution process applied to the gallery.
    The white square in the leftmost plot represents the hole in the middle of the
    gallery; the darker gray area represents the usable floor plan. In the second
    plot, you can see the result of converting the geometry into a graph. Notice that
    the hole section is entirely surrounded by edges. These edges are boundaries passed
    into the Triangle’s `triangulate` function in the `segments` key (along with the
    exterior edges, as before). The third image shows the result of tessellating the
    shape with respect to the hole. The `triangulate` function begins by creating
    the tessellation without respecting the holes and then starts removing triangles,
    beginning with any triangle that contains a point in the holes list; it continues
    removing adjacent triangles until it reaches one of the edges in the segments
    list. I didn’t apply an area constraint, so the result is a triangulation with
    the fewest number of triangles.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth plot shows the updated graph, which is ready for color solving to
    be applied. As you can see, none of the edges in the second or third plots cross
    into the hole space; this indicates Triangle has respected our request to ignore
    that portion of the space when generating the mesh. The final plot on the right
    shows the result of assigning the deployment groups based on the coloring solution.
    There are four potential deployments, all of which consist of two guard stations.
    If the hole weren’t present, you would theoretically need only one guard for the
    whole gallery.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing Guard Coverage Areas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we’ll refine our model to address another implicit assumption we’ve made:
    that all areas of the gallery are equally important and therefore the guard deployments
    should be evenly distributed. For example, a bank may weigh the monitoring of
    private offices lower than that of the lobby and therefore require different resources
    to protect the different spaces. To address this, we’ll refine our initial mesh
    to respect the importance (or weight) of each region of the floor plan. The underlying
    Triangle program supports multiple maximum areas (read in from custom data files),
    which allows us to get creative with how we define different AORs. To pull the
    example into our world of art gallery security, perhaps you believe the gallery
    floor needs fewer guards than the lecture hall, where people tend to gather in
    larger groups. You can see the result of assigning regions applied to the example
    square gallery in [Figure 11-9](#figure11-9).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: The gallery when region assignment is added'
  prefs: []
  type: TYPE_NORMAL
- en: On the left of the figure you can see the four numbered regions I defined for
    the square gallery example. The center of each region is marked by a star as well
    as its region number. These regions are segment-bounded portions of the overall
    gallery polygon, so they can be defined using any point within the segment bounds
    (similar to the way holes are defined). In this case, I added four theoretical
    segments (the diagonal separators) to the list of segment bounds already defined
    to enclose the regions. They’re theoretical because, unlike the other segments
    that represent walls and other physical structures, the region segments represent
    logical borders between areas, not physical ones. Bear in mind that Triangle doesn’t
    know the difference, so it’s up to us to track which segments belong to which
    class. We can do so by taking advantage of edge attributes stored in the graph
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: To let Triangle know that we have regions of interest, we also need to update
    the input dictionary we pass to the wrapper to include the `regions` key, as shown
    in [Listing 11-7](#listing11-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-7: Adding the region definitions for tessellation'
  prefs: []
  type: TYPE_NORMAL
- en: The value for the `regions` key is a nested list. Each entry contains x- and
    y-coordinates representing a point within the associated region. During the initial
    tessellation, triangles within the bounding segments found around each region’s
    representative point are assigned the value in the third position. The fourth
    position in the list, and all subsequent ones, can contain a numeric region attribute
    (such as a modified visibility value to mark regions with softer lighting). The
    values of any region attributes you include will be inherited by the triangles
    within the region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the regions are defined, we can perform the initial tessellation. We’ll
    tell Triangle to include the region information in the result by adding the `A`
    flag to the `triangulate` function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The resulting mesh is shown on the right side of [Figure 11-9](#figure11-9).
    The dots with the numbers inside each triangle show which region identifier has
    been assigned to it. So far, the process is identical to the previous one, so
    the mesh remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to save the result in a special group of files; these are essentially
    the same data in the dictionary written out to flat text files. We need to do
    this so that we can have Triangle reload the files during the refinement stage.
    Unfortunately, the wrapper library doesn’t include any functions to save, so I
    had to write my own based off the file specification in the underlying program’s
    documentation. The project code has all the functions necessary to create the
    expected files, but they’re long and fairly boring, so I’ll skip detailing them
    here. All you need to do is import the `DataSaver` class I’ve included with the
    chapter code, as shown in [Listing 11-8](#listing11-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-8: Saving the tessellation result to Triangle project files'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the `DataSaver` instance, passing it the `triangulated`
    dictionary in the first parameter and the project name in the second. You can
    also optionally pass in a version number and directory. If you don’t pass these
    in, the version number will automatically be set to 1 and the directory will be
    the current working directory of the script. The `set_region_areas` function stores
    the list of maximum areas, and the index in the list is the same as the region
    index. If you pass in a list that is shorter than the number of regions, the remaining
    regions are treated as though they had no area constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set the region areas before we save the project using `save_project`
    so that the saver knows how to mark each triangle during the file creation. Once
    `save_file` function has completed, you’ll have a list of files in the directory
    you specified (or the current working directory, as I mentioned). Each file is
    named like so: *<project name>_<version number>.<part>* where *<part>* is one
    of the file types expected by Triangle (with a *.node*, *.ele*, *.area*, or *.poly*
    file extension). Therefore, the code in [Listing 11-8](#listing11-8) will create
    a file named */myproject/square_1.area* (among others). The *.area* file is of
    particular interest because it contains the maximum area for each triangle, which
    we just set by virtue of its region association.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to refine the mesh by reloading the saved data and performing
    another tessellation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We call the `load` function from the wrapper library and pass in the directory
    where the project files were stored, as well as the project name, including the
    version. These inputs find and load the data from the associated files created
    in [Listing 11-5](#listing11-5). Finally, we create the refined mesh by calling
    the `triangulate` function once again, this time on the loaded data. The option
    string `ra` tells Triangle to refine a previously generated mesh (the `r` flag)
    and to refine the mesh using constrained triangle areas (the `a` flag). Because
    Triangle is refining a mesh, and we’ve asked it to constrain the area, it will
    attempt to locate the project’s *.area* file and use that information while creating
    the refined mesh.
  prefs: []
  type: TYPE_NORMAL
- en: During the refinement step, each triangle in the original tessellation is compared
    against the area defined in the *.area* file. If the area is larger than the maximum
    defined, the algorithm splits the triangle into smaller ones. You can see the
    result of the region areas being applied to the tessellation of the square gallery
    in [Figure 11-10](#figure11-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: Creating a multiregion tessellation'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left, you can see the region assignment. The areas passed in to the
    `DataSaver` class were `[-1,0.1,-1,0.3]`, which can be interpreted as: region
    0 has no maximum area constraint (marked by any negative value); region 1 has
    a maximum area constraint of 0.1; region 2 also has no constraint applied; and
    finally region 3 has a maximum area constraint of 0.3\. On the right side, region
    1 has been broken up into many small triangles, while region 3 has been divided
    up into slightly larger triangles. The result is more guard positions in region
    1 than region 3, and increased coverage in both compared to the other two zones
    with no constraints applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can save the refined mesh using another instance of the `DataSaver` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We pass in the `refined` mesh result, project name, and version once again.
    It’s standard practice to increment the version for each subsequent mesh you refine,
    so this refined mesh would be the second version of the square project. We don’t
    need to define the region areas this time unless we want to perform any further
    refinements.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’d be nice if you could just add as many guards as you wanted to
    the deployment. Unfortunately, we rarely have the budget for more than some number
    of guards per shift or for some fixed number of sensor devices we can deploy per
    floor. We can tell Triangle the maximum number of Steiner points it can add to
    achieve the tessellation with the `S` flag. For example, let’s say we can only
    afford to deploy three extra guards to the square gallery. [Figure 11-11](#figure11-11)
    shows the result of adding this constraint during the refinement step.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: Refined mesh with three guards'
  prefs: []
  type: TYPE_NORMAL
- en: On the left, you can see the mesh we generated previously, with no restriction
    on the addition of guard points. On the right, you can see the mesh generated
    from the refinement where I restricted the output to three additional guard positions.
    Bear in mind that I didn’t change the maximum area constraint I defined earlier,
    which clearly the mesh on the right doesn’t achieve. Once Triangle runs out of
    Steiner points it can add, it can’t divide the larger triangles anymore and so
    it stops. If you’re asked to divide the gallery into small zones and then cover
    those zones with only three additional guards, you can use this result to show
    that it’s a mathematical impossibility to accomplish both goals. Hopefully this
    result gets you the budget increase you need for those additional guards!
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Security Camera Field of View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next feature to address is adding the field of view and effective range
    parameters. When discussing human guards, the field of view and effective range
    are very different from person to person so assigning these parameters is a bit
    fuzzy. Intuition and educated estimates are your best friend in these cases. However,
    when you think of guard positions as electronic devices, such as cameras or motion
    detectors, the data is easier to locate. For example, I searched Google for “security
    camera data sheet” and selected the first model I saw: Ocuity model number HMNC100
    from NetGear. After reviewing the technical data for the model (available from
    the manufacturer’s website), I found that the listed field of view was 107 degrees
    and the effective range was 7 m in total darkness (thanks to built-in infrared
    lighting). The distance during normal operational lighting is often not listed
    because the answer depends on how much detail you need to be able to distinguish,
    the focal length of the camera (which may or may not be listed in the user documents),
    and the number of pixels used to encode the information (often given as a megapixel
    rating, where 1MP is equal to one million pixels). To get a good number for effective
    distance, the best method is often to just test the camera under the conditions
    of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume the normal effective range *r(d)* is 20 times greater than the
    night range, *r*(*n*) = 7 m (*r*(*n*) × 20 = 140 m or about 460 feet). Since we’re
    approximating things, I’m also going to change the field of view Δ from 107 to
    104 because 107 is prime and therefore can’t be divided up into equal segments;
    this makes computing the points representing the edges of the field of view harder.
    On the other hand, 104 can be divided by several factors, including 2, which is
    also helpful for keeping the math simple. I’ll define the starting angle ϴ[(0)]
    for each of the four internal guard nodes `[4, 5, 6, 7]` as `[180, 134, 45, 351]`,
    respectively. We can define the positive peripheral angle as ![m11001](image_fi/502567c11/m11001.png)
    and the negative peripheral angle as ![m11002](image_fi/502567c11/m11002.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can create some number of intermediary angles between the two peripheral
    angles by dividing the field of view into eight segments of 13 degrees each:'
  prefs: []
  type: TYPE_NORMAL
- en: δ = Δ / 8 = 13
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the `cos` and `sin` functions for each of the angles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A : = [ θ( p ) − i δ] ∀ i ∈ ℤ0 − 8'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12](#figure11-12) shows the approximated coverage if you positioned
    one of these cameras at each of the four internal guard positions from the square
    example in [Figure 11-8](#figure11-8), using the starting angles just mentioned.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c11/f11012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: Defining the field of view polygons'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12](#figure11-12) shows the approximate field of view coverage resulting
    from placing one of those cameras at each of the corners of the internal hole.
    As you can see, there are clearly large areas the cameras aren’t able to adequately
    cover. Furthermore, you can see someone could theoretically approach each camera
    position without ever entering the field of vision of any camera. These are examples
    of the blind spots mentioned earlier in the chapter. As a defender, you’d want
    to add more coverage to prevent these gaps. As an attacker, you could consider
    all of the uncovered assets as potentially good targets.'
  prefs: []
  type: TYPE_NORMAL
- en: One last note about field of view mapping. I’ve assumed that the cameras are
    pointed and then left stationary. Several high-end cameras include a device called
    a gimbal that allows a remote operator to move the camera as needed. Some mid-level
    cameras also include the ability to automatically sweep back and forth across
    an area. These types of cameras are becoming less popular these days, but they’re
    still good to be aware of; not all field of view maps are going to be static.
    Be sure to look out for features like these when you’re analyzing the data sheets
    for devices; you may need to update your implementation to produce the full range
    of vision for these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have all the code necessary to solve the core of the art gallery problem,
    including methods for handling real-world constraints, such as limited budgets
    and effective range for sensors. We’ve discussed the power of the Triangle library
    and combined it with Shapely and NetworkX to model the problem with both a geometric
    and graph representation. Perhaps most important of all, you should now be comfortable
    explaining the AGP theory and discussing the practical constraints applied within
    the application. There’s a large body of research you can tap into to continue
    developing your understanding of the problem. I didn’t even touch on how the greedy
    color algorithm functions under the hood, for example.^([5](b01.xhtml#c11-endnote-005))
    Node coloring in general is a great graph theory topic with many applications
    outside the AGP, but for our purposes, studying node-coloring algorithms can help
    you understand the solutions your application outputs (and how you can potentially
    modify them) more completely. For a more in-depth description of the geometric
    implications of different gallery layouts, check out the paper “Note on an Art
    Gallery Problem.”^([6](b01.xhtml#c11-endnote-006))
  prefs: []
  type: TYPE_NORMAL
- en: To continue developing the core of the system, you can identify additional use
    cases that may be of interest to the users you want to serve. For example, you
    might want a use case to cover users who want to compare before and after deployment
    plans. Once you collect the use cases, you can develop the additional functions
    needed to support them. Additionally, you can continue to refine the functions
    included here. The triangle assignment function is one excellent area to improve
    upon using one of the options we discussed previously. Remember, you don’t necessarily
    need to develop all of these features before taking your application to the market.
    Developing an MVP is all about picking the key features that make your application
    useful to users. Oftentimes, figuring out these key features is a matter of analyzing
    competitive software offerings and answering the questions, “What features do
    all these applications offer?” and “What features does my application offer that
    the others do not?”
  prefs: []
  type: TYPE_NORMAL
- en: Once you can answer those two questions, you’re ready to move on to the next
    chapters, where we’ll go from the core algorithm developed in this chapter to
    a full-fledged Python application. We’ll finish out the project by mapping out
    the user interaction, adding graphics, selecting a modern processing architecture,
    and deciding whether to add application licensing.
  prefs: []
  type: TYPE_NORMAL
