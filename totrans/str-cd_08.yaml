- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CLIPS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'Back in the 1980s and 1990s, there was a hot new topic in artificial intelligence:
    *expert systems*, that is, programs that attempt to capture the knowledge of human
    experts in a particular domain in the form of rules, particularly `if-then` rules.
    In 1985, NASA developed CLIPS (“C Language Integrated Production System”) to create
    expert systems. CLIPS has been developed and maintained since then, becoming public
    domain software in 1996.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll use CLIPS to get a feel for what an expert system is
    and how to create one, at least a primitive one. We’ll introduce CLIPS, and with
    it, the concepts behind expert systems. Then we’ll explore the language through
    a series of four examples: a calculator, a second look at the family relationships
    we explored with Prolog in [Chapter 1](ch01.xhtml#ch01), a simple factory simulation,
    and a complete expert system for the classification of iris flowers. We’ll end
    the chapter with a brief discussion of CLIPS as an atypical programming language.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Installation**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing CLIPS is similar to installing SNOBOL. First, we need the tarball,
    *clips_core_source_631.tar.gz*, which we download from *[https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/](https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/)*.
    Example files are in *examples_631.tar.gz*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Expand the archive and build CLIPS.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, run CLIPS to make sure it works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the expression `(1+2)*3` becomes `(* (+ 1 2) 3)`. CLIPS, like Lisp,
    uses *S-expressions*, which are lists of items surrounded by parentheses. S-expressions
    are often nested, as in the example here, where the S-expression `(+ 1 2)` is
    nested inside the outer expression beginning with `*`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The main CLIPS site is at *[http://www.clipsrules.net/](http://www.clipsrules.net/)*.
    You can download the CLIPS 6.31 documentation from there, though we’ll introduce
    the essential elements of the system as we use it. If you see a version later
    than 6.31, go ahead and use it. The probability of CLIPS changing to the point
    where our examples no longer work is extremely low.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Origins and Philosophy**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand CLIPS, we must first better understand what an expert system is.
    Expert systems were popular in the 1980s, and it was hoped then that they would
    prove helpful as a more general approach to artificial intelligence. We’ll discuss
    whether this hope was realized later in the chapter, but for now, note that the
    large-scale application of expert systems never happened.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: An *expert system* is a computer program capable of inferring conclusions from
    a set of rules and facts. The rules are intended to capture the knowledge of a
    human expert in a specific domain, thereby allowing the software to perform similarly
    depending on the facts available. This is an abstract definition, and there is
    certainly room for other nuanced statements related to what an expert system is,
    but you’ll appreciate what an expert system is as we explore CLIPS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'An expert system is a collection of facts, rules (a knowledge base), and an
    inference engine to use those facts and rules to reach conclusions. Expert systems
    use facts and rules to determine behavior. For example, an expert system monitoring
    a building might have a rule like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `door-is-open`, `time-is-after-midnight`, and `signal-the-police` are
    all facts. Note that the last fact is one that the rule puts into the knowledge
    base when the rule fires. In other words, the rule *asserts* the fact, which later
    might cause another rule to fire.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In CLIPS this might be written as
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll get to the exact syntax of a CLIPS rule in a bit, but even now, we can
    start to see what is going on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Put enough of these rules together and you have a system embodying a tiny knowledge
    domain. In other words, the system is an expert in that tiny domain. At least,
    that’s the hope.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Viewed this way, an expert system might be thought of as a glorified set of
    `if-then` statements. And in a way, it is, but much can happen in the `then` part,
    thereby enabling the system to respond in a sophisticated manner, provided the
    developer captured the essential knowledge of the domain expert and properly arranged
    that knowledge in the form of rules firing in response to a particular set of
    facts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Expert systems rely on forward chaining. This is in contrast to a language like
    Prolog, which uses backward chaining. *Forward chaining* systems process the data
    embodied in the facts they know to find valid conclusions. In contrast, *backward
    chaining* systems work from the goal to find true statements that support the
    goal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: A forward chaining system explores all known facts to select rules to evaluate,
    or *fire*. A system like CLIPS places rules to fire on an *agenda* and then uses
    *conflict resolution* to select which specific rule to fire. Firing a rule may
    update the set of known facts, causing other rules to fire, in which case, CLIPS
    continues to run until the agenda is empty or until it is explicitly told to stop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Internally, CLIPS uses the *Rete algorithm* to perform inference, that is, to
    find conclusions by applying a set of rules to a collection of facts. Unlike the
    other programming languages we’ve explored (except Prolog), CLIPS incorporates
    advanced concepts in its inference engine that are worth digging into if you are
    curious; however, these concepts are well beyond what we intend to explore here.
    Our concern is the language and how to think in terms of it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: As you saw earlier, syntactically, CLIPS looks like Lisp, using S-expressions,
    or prefix notation, where *f* (*x*, *y*) becomes (*f* *x* *y*) so the function
    moves inside the parentheses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'CLIPS is a multiparadigm language: it is declarative at its base because of
    the inference engine and how code normally runs, but it is also procedural, with
    standard control structures, and object oriented, though we’ll completely ignore
    that aspect of the language here. CLIPS runs from the command line with its REPL,
    which is how we’ll use it; however, it’s also possible to embed it in another
    application.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see CLIPS in action and then walk through some examples to show us how
    to work with the system. Along the way, we’ll introduce different aspects of the
    language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**The Language**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s run one of the demos that comes with CLIPS. We won’t look at the code—it’s
    beyond what we want to consider—but it will show us how to work with the system
    and serves as a nice example of how an expert system works. The example is in
    *wine.clp*. The purpose of the expert system is to recommend a wine to go with
    a dinner we are preparing. The program will ask us questions and, based on our
    responses, generate a list of recommended wines with probabilities to select a
    good pairing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with CLIPS***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A typical session with *wine.clp* looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we load *wine.clp*. Not shown is CLIPS reporting the successful compilation
    of the various code components in the file. After loading, CLIPS must be reset
    before running. Resetting is necessary to configure CLIPS because it places a
    set of initial facts on the facts list. If the `(reset)` step is skipped, running
    *wine.clp* will display the `SELECTED WINES` banner and nothing more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The wine demo asks the user a series of questions. Based on the user’s response,
    the demo provides a list of selected wines with a probability of pairing with
    the indicated meal. Reset and run the demo a second time, enter the same responses,
    and the list should be the same. CLIPS is working through a set of rules and will
    arrive at the same conclusion each time the inputs match. There is nothing stochastic,
    no randomness, to what CLIPS is doing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'While the system is running, the set of facts may change and new inputs may
    be read. The agenda changes in response to rules that can fire. A `reset` configures
    CLIPS by defining the initial set of facts. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we tell CLIPS to run the wine program without issuing a `(reset)` first.
    The header is shown, nothing more. Asking for the current set of facts returns
    only the default initial fact (`f-0`). Asking for the agenda returns nothing as
    the agenda is empty. When the agenda is empty, CLIPS stops. We then reset CLIPS
    and ask for the facts a second time. Now we see the initial set of facts defined
    by *wine.clp*. We don’t need to understand the structure right now, only see that
    the list of facts has been configured. Asking for the agenda now shows one activation,
    `start`. An activated rule is one where the conditions have been met. The wine
    demo is now ready. When we call `run`, the `start` rule will become active.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing Hello World***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s implement our old friend, “Hello, world!” We’ll write two versions. The
    first uses the inference engine by defining a rule that always fires. The second
    is purely procedural, proving that CLIPS does support imperative programming.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The file *hello0.clp* contains
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll detail the syntax of `defrule` in the next section. For now, know that
    it defines a rule named `hello`. The portion of a rule after the arrow (`=>`)
    is the part that runs, which is the `then` portion. There is nothing to the left
    of the arrow because this rule always fires or fires if `initial-fact`, `f-0`
    above, is defined, which it is by default.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the rule we need only use `(run)` as there is nothing to configure
    regarding other facts and the agenda. Running the program looks like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Excellent; our rule fired. However, you might have a question. If the rule `hello`
    is set to fire when `initial-fact` is present, which it always is, why doesn’t
    CLIPS print “Hello, world!” forever? There is nothing removing the initial fact,
    so it’s still present. Why doesn’t the rule match again and again? This is because
    CLIPS fires a rule only once for each set of matching conditions. This is known
    as *refraction* (this term is borrowed from neuroscience, where it is related
    to the time delay after a neuron fires before it can fire again).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The file *hello0.clp* defined a rule and used CLIPS’s inference engine to fire
    it. CLIPS allows imperative programming as well. The file *hello1.clp* contains
    the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can run this from the command line as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Use `-f` or `-f2` to execute a program from the command line. The second option
    (`-f2`) disables load messages. Calling `(exit)` keeps the program from showing
    the `CLIPS>` prompt after running. The file *hello1.clp* uses `deffunction` to
    define a function named `hello` that is then called before exiting to print the
    message. The `t` after `printout` specifies the output file—in this case the terminal.
    CLIPS’s support for imperative programming covers all the expected control structures
    like `if-then` and `while`. We won’t discuss those elements here, but do consult
    the CLIPS documentation to learn about them. A good place for control structures
    is in the action part of a rule.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: CLIPS manipulates facts with rules and input. The rules, when active, affect
    the agenda, and it is the agenda that drives a CLIPS program. Let’s learn more
    about facts and rules.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '***Facts and Rules***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve already seen a bit about facts and rules, but to understand the examples
    that follow, we’ll need a more thorough understanding. Let’s dive in.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Facts**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Facts* are asserted (`assert`) and retracted (`retract`) as needed when rules
    fire. Simple facts are straightforward to add. For example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Three facts are asserted. The first might indicate to a running system managing
    a car that the emergency brake is on. The other two are the symbols `roses-are`
    and `violets-are` along with symbols for colors. Equivalent to an atom in Prolog,
    a *symbol* in CLIPS is a set of characters that represents itself, unlike a variable,
    which is a name given to a value. A symbol has no value. A set of facts may be
    defined at one time with `deffacts`. Facts defined this way are put on the facts
    list when `(reset)` is executed. Consider the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 三个事实被声明。第一个可能指示一个运行中的系统正在管理一辆车，表示紧急刹车已被激活。另两个则是`roses-are`和`violets-are`符号，以及与颜色相关的符号。在
    CLIPS 中，相当于 Prolog 中的原子，*符号*是一组代表自身的字符，与变量不同，变量是赋予值的名称。符号没有值。一组事实可以通过`deffacts`一次性定义。通过这种方式定义的事实将在执行`(reset)`时被放入事实列表中。考虑以下例子：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, CLIPS has only the initial fact at first. Then, a `deffacts`
    statement named `arthropods` defines a set of facts. There are three facts defined,
    each a type of arthropod followed by the number of legs. (Of course, some arthropod
    enthusiasts may object that trilobites vary in the number of legs, but 48 isn’t
    a bad guess.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，CLIPS 最初只有一个初始事实。然后，一个名为`arthropods`的`deffacts`语句定义了一组事实。定义了三个事实，每个事实是某种类型的节肢动物，后面跟着它的腿数。（当然，一些节肢动物爱好者可能会反对三叶虫的腿数不固定，但48条腿也不是一个差的猜测。）
- en: The next line uses `(facts)`, but our newly declared facts are not present.
    When `assert` was used above, the facts appeared immediately. However, with `deffacts`,
    we must use `(reset)` first and then the facts appear. Any previously defined
    facts are lost as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用了`(facts)`，但我们新声明的事实并不存在。当上面使用`assert`时，事实立即出现。然而，使用`deffacts`时，我们必须先使用`(reset)`，然后事实才会出现。之前定义的任何事实也会丢失。
- en: 'Complex facts have many parts, some of which may be updated as CLIPS runs.
    CLIPS provides a mechanism for defining complex facts. For example, the file *coin.clp*
    defines a fact template for ancient Roman coins along with facts related to specific
    Roman coins:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂事实有很多部分，其中一些部分可能会在 CLIPS 运行时被更新。CLIPS 提供了一种定义复杂事实的机制。例如，文件*coin.clp*定义了一个关于古罗马硬币的事实模板，并包含与特定罗马硬币相关的事实：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `deftemplate` defines a fact template named `roman-coin` with an optional
    comment string. The fields of a fact are called *slots*. The template defines
    four fields: `emperor`, `denomination`, `obverse`, and `reverse`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`deftemplate`定义了一个名为`roman-coin`的事实模板，并可附带一个可选的注释字符串。事实的字段称为*槽*。该模板定义了四个字段：`emperor`、`denomination`、`obverse`和`reverse`。
- en: With `roman-coin` defined, we can then assert some facts about specific coins
    using `deffacts`. The first relates to a silver denarius of the first-century
    emperor Otho, one of the “Twelve Caesars” who ruled from January 15 to April 16
    in the year 69\. A denarius was the usual day’s wage for a Roman soldier. The
    second coin is a small bronze coin, loose change of the time, minted by Constantine
    the Great around the year 325.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`roman-coin`之后，我们可以使用`deffacts`来断言一些特定硬币的事实。第一个涉及的是公元一世纪的皇帝奥图（Otho）的银德纳里乌斯硬币，他是“十二凯撒”之一，统治时间为公元69年1月15日至4月16日。德纳里乌斯是罗马士兵的常规日薪。第二枚硬币是一枚小型铜币，是当时的零钱，约公元325年由大帝君士坦丁铸造。
- en: Let’s inform CLIPS about these coins.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些硬币信息告知 CLIPS。
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After loading *coin.clp*, we reset and look at the known facts. There are the
    new coins. During execution, CLIPS will often assert and retract facts. Here,
    we manually retract the first coin fact with `retract`, and after running `(facts)`
    again we see that it is no longer present. Notice that the fact numbers do not
    change after this. Fact `f-2` is still fact `f-2`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 加载*coin.clp*后，我们进行重置并查看已知的事实。新的硬币信息已显示。在执行过程中，CLIPS 会经常断言和撤回事实。在这里，我们通过`retract`手动撤回第一个硬币事实，运行`(facts)`后，我们看到该事实已不再存在。请注意，在此之后，事实编号没有发生变化。事实`f-2`仍然是事实`f-2`。
- en: '**Rules**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**规则**'
- en: '*Rules* are `if-then` constructs. The syntax for a rule is'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*规则*是`if-then`结构。规则的语法是'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The (<lefthand-side>), or LHS, is a set of zero or more conditions that attempt
    to match facts. The conditions are ANDed, which means that all must match for
    the rule to fire. When the rule does fire, everything on the (<righthand-side>),
    or RHS, is executed. These are the rule’s *actions*. Typically, the actions alter
    the set of facts in some way to move the program forward. However, the actions
    may also have side effects, like printing information or requesting information
    from the user (this is where CLIPS’s imperative coding abilities come into play).
    Rules with a matching LHS are placed on the agenda to execute their respective
    RHSs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: As rules match, they may also bind variables that are local to the rule. CLIPS
    variables follow the expected naming convention, but they must be referenced with
    a leading question mark. For example, `?x` refers to the variable `x`. Binding
    on the LHS of a rule is useful as the bound variables may be used on the RHS.
    We’ll see examples of this later in the chapter. To bind a variable directly,
    that is, to assign something to it, use the `bind` statement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here’s a hypothetical rule to react to a security breach.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The rule name is `react-security-breach`. The LHS, the part before `=>`, is
    the condition that matches a fact of the form `security-breach` `<type>`, where
    the actual type is bound to `?typ`. For example, `(security-breach hacker)` would
    match the rule and bind the symbol `hacker` to the variable `?typ`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The LHS has a funny bit of syntax: `?r <-`. When the `security-breach` fact
    matches, it returns the fact number, which is bound to `?r`. The RHS of the rule,
    the part after `=>`, uses `?r` to `retract` the matched fact. As we are processing
    the security breach, we remove the trigger for this rule. Because of refraction,
    the rule will fire only once for the specific fact `(security-breach` `hacker)`.
    Retracting the fact removes it, so when it is asserted again, the rule will fire
    once more.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The RHS of this rule asserts `(log-security-breach ?typ)` to add a new fact.
    Note the use of `?typ`, which CLIPS extracted from the LHS of the rule. Asserting
    this fact acts as a trigger for another rule that will write some information
    to a logfile or perhaps send an alert email to the IT department. The final part
    of the rule prints the alert so we can see it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'If the rule is in *security.clp*, we load and run it as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To trigger the rule after reset, we must assert a security breach, which in
    this case is a hacker security breach. Running it shows us the security alert
    message indicating the rule fired. If we examine the known facts, we see a new
    one, `f-2`, which is the fact asserted by our rule.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: CLIPS is large, powerful, and reasonably complex. Let’s spend the remainder
    of the chapter exploring selected examples to illustrate how CLIPS works, at least
    at the level we’ll use it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**CLIPS in Action**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build our intuition about CLIPS, in this section we’ll walk through four
    examples. The first is an elementary calculator, just enough to get our feet wet.
    Next, we’ll revisit the Greek god family tree from [Chapter 1](ch01.xhtml#ch01)
    to see CLIPS’s take on it. Following that is a basic factory simulation, which
    illustrates how a CLIPS expert system might operate when monitoring something
    in the real world. Lastly, we’ll build an expert system for iris flowers to compare
    a rule-based classifier with the SNOBOL nearest neighbor classifier of [Chapter
    5](ch05.xhtml#ch05).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '***An Elementary Calculator***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This example implements a calculator. For the calculator, we need four rules.
    The first rule handles the startup message and informs the user. The next rule
    handles binary operators like plus and multiply. Next, we need a rule for unary
    operations like sine and cosine. The final rule accepts input from the user and
    asserts the operation for the binary or unary rule to act upon. The source code
    is in *math.clp*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-1](ch06.xhtml#ch06list1) contains the set of initial facts and the
    `start` rule.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-1: Initializing the calculator*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Here, there are two initial facts. The first is `(startup)`, and the second
    is `@ 0`. We’ll use the `@` fact to keep the result of the last operation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The LHS of the `start` rule matches `(startup)`, which is asserted when CLIPS
    is reset because of `deffacts`. This rule does three things: first, it prints
    a set of instructions for the user; second, it retracts `(startup)` so it is no
    longer in the facts list; and third, it asserts `(get-next-operation)`. We’ll
    use this fact to request input from the user.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-2](ch06.xhtml#ch06list2) shows the `get-operation` rule.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-2: Processing user input*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The `get-operation` rule fires only when `(get-next-operation)` is in the facts
    list. As `start` places this fact on the list after it is done, the `get-operation`
    rule will fire immediately after `start` ends. As CLIPS fires rules only once,
    when matched, we retract `(get-next-operation)` so the rule will fire the next
    time it is asserted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of `get-operation` displays a prompt of spaces and then binds
    `?expr` to the string typed by the user. After a quick check to see if the user
    entered `end`, the operation is asserted. The `explode$` function takes a string
    and splits it into a list, the elements of which become the fields of the `operation`
    fact. CLIPS refers to lists as *multifields*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The instructions tell the user to enter expressions carefully. A unary expression
    is the function name followed by one or more spaces and an argument consisting
    of either a number or `@` to use the previous result. A binary expression is the
    first operand, spaces, operation, spaces, and second operand. When exploded, the
    `operation` fact will contain three fields if it’s a binary expression or two
    if it’s a unary expression.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Now consider [Listing 6-3](ch06.xhtml#ch06list3), which processes unary expressions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-3: Processing a unary expression*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `unary-math` rule is triggered by an `operation` fact with two fields. The
    first is the function (`?func`) and the second is the argument to the function
    (`?x`). The last result is also part of the LHS, so we can pull it from the facts
    list. Both the operation and last result are retracted, meaning they will be asserted
    again later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The rule asserts `(get-next-operation)` to fire `get-operation` again to acquire
    the next expression from the user. The remainder of the rule performs the requested
    operation. If `?x` is `@`, `?x` is updated to be the previous result (`?last`).
    The actual operation generates an output value, `?y`, which is printed and asserted
    as the new previous result, which is the `@` fact.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Binary expressions are processed by [Listing 6-4](ch06.xhtml#ch06list4).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-4: Processing a binary expression*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: This rule is substantially the same as the unary expression case, but matches
    an operation with two arguments instead of one. CLIPS knows which rule to fire,
    `unary-math` or `binary-math`, because of the number of fields in the `operation`
    fact.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see *math.clp* in action.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: User entries are in bold, demonstrating both binary and unary expressions, most
    of which use the previous result. Note that spaces are required between operands
    and operators.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'This example exposes a general pattern: store information on the facts list
    and use assertions and retractions to arrange the flow of the program. The calculator
    begins with the startup message, which then asserts a fact to cause `get-operation`
    to fire, thereby acquiring and processing input from the user. In turn, that rule
    asserts the fact of the desired operation. The inference engine causes the proper
    binary or unary rule to fire to process the request. Those rules retract and reassert
    the last result, so the version in the fact list is always correct. They also
    reassert `(get-next-operation)` to acquire more input from the user. This keeps
    the program running until `(halt)` is executed.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '***Family Redux***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml#ch01), we used Prolog to explore the sometimes unusual
    family relationships among the ancient Greek gods. Let’s revisit that example
    now to understand what CLIPS might do with the same set of facts. This example
    is in *family.clp*. Let’s walk through the code, then run it to see what manner
    of output we get.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-5](ch06.xhtml#ch06list5) is only partial. See *family.clp* for the
    complete set of facts.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-5: Some facts about the Olympians*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: As with Prolog, we declare some gods as male and other gods as female before
    listing parent-child relationships in the form `(parent x y)`, which means `X`
    is a parent of `Y`. If gods were considered married, the facts list captures that
    as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-6](ch06.xhtml#ch06list6) gives us rules capturing basic family relationships.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-6: Rules capturing basic relationships*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the first `defrule` in [Listing 6-6](ch06.xhtml#ch06list6),
    `x` is the father of `y` if `x` is a parent of `y` and `x` is male. The LHS of
    the rules captures the relationship from the facts binding variables. For example,
    the `father` rule binds both `?x` and `?y`, meaning it will fire if there is a
    set of `(parent x y)` and `(male x)` facts in the facts list where the same `x`
    is parent of `y` and also male. Therefore, for a rule’s LHS, variables with the
    same name must be the same for every part of the condition to be true. When the
    rule fires, it simply outputs the now proven fact that `x` is the father of `y`.
    Notice that nothing is added to or removed from the facts list by these rules.
    These rules produce output only. Refraction will prevent the rule from firing
    more than once for the same set of facts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The rule for `mother` is almost the same as `father`. The rules for `wife` and
    `husband` include a logical-OR because `married` might be specified as `(married`
    `zeus hera)` or `(married hera zeus)`. Again, the rules make no change to the
    facts list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-7](ch06.xhtml#ch06list7) shows us three more rules from *family.clp*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-7: Rules capturing sibling relationships*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The first rules capture the idea of siblings and the following two rules embody
    the ideas of sister and brother.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For `x` to be the brother of Y, `x` must be male and `x` and `y` must be siblings.
    To be siblings, `x` and `y` must have a parent in common. The rules of [Listing
    6-7](ch06.xhtml#ch06list7) capture siblings and then assert that `x` and `y` are
    siblings. Once asserted, the `brother` and `sister` rules can fire because the
    new fact that `x` and `y` are siblings is now part of the fact list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The LHS of the rules includes a `test` to make sure that `x` and `y` are not
    the same person, as we don’t normally think of ourselves as our own siblings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: There is no startup rule in *family.clp* like we had for *math.clp*. Instead,
    the fact list is initialized by `(reset)`, and `(run)` immediately begins using
    the fact list to satisfy the rules, place them on the agenda, and execute the
    RHS for all possible matches. Therefore, unlike Prolog, which gave us a result
    and waited patiently for us to request another or stop, CLIPS will run as long
    as it can match facts to rules and execute them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If you load *family.clp* and execute `(reset)` and `(run)`, you should see a
    flurry of output—119 lines’ worth, to be exact. The output is all the possible
    relationships CLIPS was able to pull out of the initial set of facts. For example,
    the list begins with
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: giving us a mix of husbands, wives, fathers, sisters, and so on. It would be
    nice to organize this list in some way, that is, to programmatically capture the
    relationships by type instead of dumping line after line. Fortunately, CLIPS is
    a full-service programming language. One way we can apply some order to the output
    is to capture instances of different types so we can report them at will.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 6-8: Storing relationship output*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The file *family2.clp* stores brothers and sisters in global lists. Only brothers
    and sisters are considered in this case, but it would be straightforward to include
    other family relationships. The essential pieces of *family2.clp* are in [Listing
    6-8](ch06.xhtml#ch06list8). The initial set of facts has been excluded from the
    listing, as has the rule `sibling`, which is unchanged from the version in [Listing
    6-7](ch06.xhtml#ch06list7).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-8](ch06.xhtml#ch06list8) begins with two new lines, instances of
    `defglobal`, which is CLIPS-speak for defining a global variable. CLIPS uses asterisks
    around the names of global variables, so we define two empty lists, the output
    of `create$` with no arguments, to hold brothers and sisters: `?*brothers*` and
    `?*sisters*`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: To accumulate information about brothers and sisters, we modify the `brother`
    and `sister` rules. The LHS of each rule remains the same, but the RHS consists
    of two calls to `bind`. The first uses `create$` to make a list of `?x`, the symbols
    `is`, `sister` or `brother`, `to`, and `?y`. This list is passed to `implode$`,
    which makes a string from a list. Therefore, the output of `implode$` is a string,
    such as `dionysus is brother to artemis`, that we store in `?msg`. The second
    `bind` again uses `create$` to append the new string to the end of the existing
    list. In this way, every discovery of a brother or sister relationship is stored
    in the corresponding string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: If we load *family2.clp* and call `(reset)` followed by `(run)`, we get no output.
    However, CLIPS did its job. To see this we need functions to print the lists.
    Enter the functions `brothers` and `sisters`. Neither function requires arguments
    and both use CLIPS’s `foreach` loop to iterate over the lists to print one element
    per line.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Give *family2.clp* a try. First load, reset, and run as usual, and then list
    the sisters. For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Calling `(brothers)` produces the other list. The *family2.clp* example shows
    how to combine procedural (imperative) programming with CLIPS’s rules engine.
    Now, let’s look at a factory simulation to see how rules can be ordered to fire
    in a specified sequence.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '***At the Factory***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this example, we’ll simulate the monitoring of a factory. The factory has
    pumps that must be turned on and then turned off three seconds later. Additionally,
    from time to time, an emergency must be serviced before turning on the pumps.
    Our simulation’s true purpose is to demonstrate *salience*, which determines the
    firing order for rules if multiple rules are on the agenda. Salience should be
    used with care, but it is sometimes necessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-9](ch06.xhtml#ch06list9) shows us a few necessary utility functions.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-9: Some utility functions*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The first line defines a global variable, `?*base*`, which holds the current
    epoch seconds value returned by `(time)`. It’s set when the program loads. We’re
    using it with the `ftime` function to return the number of seconds since the program
    was loaded.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: CLIPS has a function called `(random)` to return a random integer, which is
    really the return value of the C `rand` function. To get a floating-point value
    in [0, 1), we take the remainder of this integer when divided by 1,000,000 and
    divide that by 1,000,000\. This approach is adequate for our purposes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The system pauses before monitoring the state of the factory, hence defining
    `(pause)`, which accepts the number of seconds and runs a `while` loop waiting
    for the time to elapse. This is very CPU intensive, but, again, it is acceptable
    for our purposes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The rules responding to events in the factory are in [Listing 6-10](ch06.xhtml#ch06list10).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-10: The factory rules*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three rules: `emergency`, `pumps-on`, and `pumps-off`. As before,
    the rules have a LHS and a RHS. There is also a new statement, `declare`, which
    sets the `salience` to an integer, which must be in the range [–10,000, 10,000].
    Higher salience rules fire before lower salience rules when multiple rules are
    on the agenda. The default salience value is 0.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The first rule in [Listing 6-10](ch06.xhtml#ch06list10) uses a salience of `100`.
    This is the emergency rule, and we want to ensure it fires immediately after being
    placed on the agenda; therefore, we give it a salience larger than any other rule.
    The `pumps-on` and `pumps-off` rules each have a salience of `5`. Salience is
    for ordering execution on the agenda, and the numeric value has no other meaning.
    Therefore, the fact that `emergency` has a salience 20 times greater than that
    of the other rules doesn’t mean anything other than that it fires first.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The `emergency` rule does nothing more than inform the user that an emergency
    condition exists, that is, the fact `emergency-alert` has been asserted. Notice
    that the fact has been retracted. If not, the rule would not fire again when a
    new `emergency-alert` is placed on the facts list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The `pumps-on` rule displays the pump start time and then asserts `pumps-off`
    `-time` as three seconds beyond the current time. The assertion fires `pumps-off`.
    This rule uses `if` to check whether the current time is beyond the desired stop
    time. If it is, the `pumps-off-time` fact is retracted and the off message displayed.
    If the full three seconds has not yet elapsed, `refresh` is used to cause `pumps-off`
    to fire again even though it already matched the `pumps-off-time` fact. Using
    `refresh` eliminates the need to retract the `pumps-off-time` fact only to assert
    it again.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The main factory monitor loop is the rule `monitor` (see [Listing 6-11](ch06.xhtml#ch06list11)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 6-11: The monitor rule*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The `monitor` rule uses a salience of `0`, which is the default value. Doing
    this means the pump and emergency rules will always fire before this rule. The
    idea is to monitor the factory until something worthwhile happens and then react
    to the situation before returning to monitor the factory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: This is a simulation, so “monitor the factory” means use `(rand)` to assert
    events with random probabilities. For any execution of `monitor`, there’s a 20
    percent chance the pumps will be turned on. Likewise, there is a 5 percent chance
    an emergency alert will be issued. After a 0.2 second pause, the program refreshes
    the `monitor` rule to make it fire again. To prep the system, `deffacts` places
    `monitor-loop` on the facts list when `(reset)` is executed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s run the simulation and see what it tells us.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This run activated the pumps and, as desired, turned them off after three seconds.
    There was one emergency alert. The factory simulation has no end condition, so
    use CTRL-`\` to exit. This is the source of the `Quit` message in the listing
    above.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***An Iris Expert System***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.xhtml#ch05), we built a nearest neighbor classifier in SNOBOL.
    The nearest neighbor classifier is an example of machine learning, a statistical
    approach using training data to build a model that captures something essential
    about the data and allows for predictions when given new, unknown data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: An expert system attempts to encapsulate expert knowledge to capture enough
    about a particular domain to make informed decisions. This section uses “expert”
    knowledge of iris flowers to build a simple expert system. The result is a system
    that asks us questions about an unknown iris flower to decide what type of iris
    it is.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, I’m not an expert in iris flowers. But that isn’t too much of
    a limitation in this case, as we can cheat a bit. We’ll use machine learning to
    build a *decision tree* classifier for irises. A decision tree is a series of
    yes or no questions that ultimately lead from the tree’s root to a leaf, which
    identifies the flower. Translating a decision tree into a simple expert system
    is straightforward, so we’ll use the “expertise” captured by the decision tree
    to build the expert system. This isn’t all that different from a human interviewing
    an iris expert to extract essential knowledge then encoded in a series of questions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, our plan of attack is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Use the iris training data to build a decision tree classifier.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the associated test data to characterize the resulting tree’s accuracy.
    Our expert system will use the same sequence of questions, so we’ll get the same
    accuracy from CLIPS if we implement things correctly.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Translate the questions of the decision tree into a set of CLIPS rules.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the system with the iris test dataset.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First is the decision tree classifier. The code to train the classifier and
    output a tree representation is in the file *make_iris_tree.py*. You do not need
    to run it. The tree we’ll work with is in *iris_tree.png*. If you want to generate
    a new tree, perhaps as an exercise in doing the translation to CLIPS yourself,
    you’ll need to install scikit-learn (*[https://scikit-learn.org/](https://scikit-learn.org/)*)
    and Matplotlib (*[https://matplotlib.org/](https://matplotlib.org/)*). scikit-learn
    uses some randomization when building the tree; therefore, each run of *make_iris_tree.py*
    results in a slightly different level of performance. The particular tree we’re
    using here is 98 percent accurate on the iris test dataset (*iris_test_data.txt*).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](ch06.xhtml#ch06fig1) shows us the decision tree classifier.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/06fig01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: The iris classifier decision tree*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The root of the tree is at the top, following normal computer science convention
    for representing a tree data structure. Each box is a node of the tree. If the
    box isn’t a leaf, the first line of the box is a question asked of the user. If
    the answer to the question is “yes,” move to the next lower box on the left. If
    the answer is “no,” move to the lower box on the right. Answer enough questions
    and you’ll eventually get to a leaf. The class label given there identifies the
    flower: *I. setosa*, *I. versicolor*, or *I. virginica*.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: All boxes have additional lines of text. The *Gini score* is a measure used
    to generate the decision tree. Samples is a vector of three elements, one for
    each of the three iris flower types. It shows the split by type at that node when
    using the training data. The class label is the most correct label to give the
    flower if one stops at that node. For the leaves, the class label matches a value
    vector with only one class, meaning the decision tree was able to successfully
    partition the training data with 100 percent accuracy.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use the decision tree? Let’s walk through a test sample. The expert
    system will ask us about measurements made from an unknown iris flower. There
    are four measurements: sepal length, sepal width, petal length, and petal width,
    all in centimeters. See [Figure 6-2](ch06.xhtml#ch06fig2) if you need a reminder
    of basic flower anatomy.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/06fig02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: Basic flower anatomy*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Our test case has the measurements
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '| sepal length | 6.8 cm |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| sepal width | 2.8 cm |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| petal length | 4.8 cm |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| petal width | 1.4 cm |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: and is an instance of *I. versicolor* (class label 1). The path through the
    decision tree for this example is in [Figure 6-3](ch06.xhtml#ch06fig3).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/06fig03.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: A path through the decision tree*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We can place the questions asked at each node of the decision tree into [Table
    6-1](ch06.xhtml#ch06tab1).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** The Questions and Responses for the Iris Expert System'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '| **Question** | **Text** | **Yes** | **No** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| Q1 | Is petal width ≤ 0.8? | setosa | Q2 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| Q2 | Is petal length ≤ 4.75? | Q3 | Q4 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| Q3 | Is petal width ≤ 1.65? | versicolor | virginica |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| Q4 | Is petal width ≤ 1.75? | Q5 | Q6 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| Q5 | Is petal length ≤ 5.05? | versicolor | Q7 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| Q6 | Is petal length ≤ 4.85? | Q8 | virginica |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| Q7 | Is sepal length ≤ 6.05? | versicolor | virginica |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| Q8 | Is sepal length ≤ 5.95? | versicolor | virginica |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: Each row of the table is a question. If the answer to a question is yes, we
    move to the indicated question or, if we now know the type, return the label.
    Notice that if the petal width is ≤ 0.8, the flower is an instance of *I. setosa*
    and there is no need to ask any further questions. This means of the three classes
    in the dataset, one is easily distinguished from the other two, but the remaining
    two need more work to tell apart. With the table, we now have what we need to
    implement the expert system. We begin with Q1, as that is the root of the tree,
    and move to other questions or endpoints based on the user’s response to each
    question.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The full expert system is in *irises.clp*. We’ll work through the code in sections
    beginning with the initial facts and helper rules (see [Listing 6-12](ch06.xhtml#ch06list12)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 6-12: Facts and helper rules*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The program begins with the `start` rule, which fires because `initial-facts`
    places it on the facts list when `(reset)` is run. It also defines a `state` fact,
    set to `1` for question Q1, and the text of the question itself. When `startup`
    fires, it prints instructions for the user and retracts itself. The presence of
    the `question` rule fires `ask-question`, which displays the question text and
    asserts the user’s response: `y` or `n`. A full system would, naturally, validate
    the user’s input. Rule `output-result` reports when we have a valid label and
    halts.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Asserting a `response` fact causes a question rule to fire. There are 16 of
    them, two each for Q1 through Q8 in [Table 6-1](ch06.xhtml#ch06tab1), one each
    for a yes or no response. Let’s look at the first pair of rules. You should review
    *irises.clp* yourself to see the entire program.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-13](ch06.xhtml#ch06list13) shows us the first two rules for Q1,
    that is, the first row of [Table 6-1](ch06.xhtml#ch06tab1).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 6-13: Some iris rules*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if the user’s response to Q1 is “yes,” rule `q1-yes` fires.
    [Table 6-1](ch06.xhtml#ch06tab1) says a “yes” response to Q1 means the sample
    is an instance of *I. setosa*. Therefore, rule `q1-yes` asserts `label`, causing
    `output-result` from [Listing 6-12](ch06.xhtml#ch06list12) to fire, tell us the
    iris type, and halt.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: If the user’s response to Q1 is “no,” rule `q1-no` fires instead. [Table 6-1](ch06.xhtml#ch06tab1)
    says to move to Q2 in this case, so the RHS of `q1-no` asserts `state 2` and the
    proper `question`, which `ask-question` in [Listing 6-12](ch06.xhtml#ch06list12)
    dutifully asks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'As the user answers questions, CLIPS moves from state to state until it reaches
    a rule with a known label. For example, if we run *irises.clp* for the test sample
    above we get the output shown in [Listing 6-14](ch06.xhtml#ch06list14):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 6-14: Using the expert system*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: If you are patient enough, you can work through every example in the *iris_test_data.txt*
    file in the *SNOBOL/datasets* directory. Matching the reported labels against
    the known labels in *iris_test_labels.txt* will tell you that the iris expert
    system is 98 percent accurate, meaning it makes one mistake out of every 50 test
    samples. The SNOBOL nearest neighbor classifier is 96 percent accurate on the
    same test data using the same training data. Therefore, in this case, the expert
    system is quite good. Of course, our “expert knowledge” of iris flowers came from
    the training data in the first place, so we didn’t implement a true expert system.
    We merely encapsulated knowledge synthesized from a statistical model. I’ll have
    more to say about this in the discussion up next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section give us a good feel for CLIPS, but, as stated earlier,
    CLIPS is much more than we can explore here. For example, we ignored CLIPS’s object-oriented
    abilities and the fact that CLIPS is designed to play nicely when integrated into
    other applications. A quick review of Google Scholar shows that academic papers
    referencing CLIPS are still being written, to say nothing of industrial uses for
    CLIPS that are likely never discussed in print.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expert systems are often considered “old-school” or even “failures,” but that
    isn’t fair. You won’t hear the term *expert system* too much these days, but they
    are alive and well under the term *business rule management system.* For example,
    DROOLS (*[https://www.drools.org/](https://www.drools.org/)*) is an open source
    rules-based system in active development with a large user base and supporting
    documentation, including multiple books. As a general approach to artificial intelligence,
    expert systems are passé, replaced by the phenomenal success of deep learning
    and neural networks, which represent a connectionist view of cognition, not the
    computational view embodied by an expert system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Expert systems are rigid. Once coded, they are not easily modified. Additionally,
    the rules often contain gaps, missing elements, or paths that are not specified.
    If a rule-based system claims to cover a topic, how would we know we’ve tested
    all the corner cases and all the possible sets of inputs? It becomes difficult,
    perhaps exponentially difficult, as the rules become more complex and intertwined.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The iris expert system shown earlier used “knowledge” extracted from a machine
    learning model. What if, instead, we needed to extract the rules from an expert
    gardener? The expert certainly knows how to identify iris flowers, but how do
    we get that knowledge out of the expert’s head and into a set of rules for CLIPS?
    The process of mapping an expert’s knowledge to rules is known as *knowledge extraction*,
    and it is an Achilles’ heel of sorts for expert systems. The concept of an expert
    system is seductive, but the realization is difficult at best. To be sure, the
    iris expert won’t know that a petal width less than 0.8 cm means the flower is
    almost certainly *I. setosa*, even if able to identify that species with almost
    perfect precision. How is that then captured and coded? Careful interviewing,
    which is highly time consuming, to say nothing of potentially irritating to the
    interviewee, might generate more general rules, but none would be as specific
    as those extracted by the decision tree. For example, one rule asks in a particular
    circumstance if the petal length is less than 4.75 cm, versus less than 4.85 cm
    in another. I doubt any expert would consider a millimeter difference in petal
    length of any importance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: CLIPS’s use has faded as expert systems have fallen out of favor, but it is
    still maintained. There are likely many CLIPS-based expert systems out there,
    quietly running in the background and invisible to the general public.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Because of its multiparadigm nature, CLIPS is, of course, a Turing-complete
    language. Indeed, one could use CLIPS without any reference to the rules engine
    if desired. As a framework for an expert system, CLIPS has stood the test of time,
    so if you find yourself in a situation where an expert system seems appropriate,
    CLIPS is an option. For us, CLIPS is an atypical language, but one we should be
    familiar with and keep in our back pocket for those times when the appropriate
    situation arises. In terms of thinking about coding, CLIPS requires a different
    approach if we want to use the rules engine. That fact alone warrants including
    CLIPS in our explorations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The CLIPS expert system was the focus of this chapter. We introduced the language
    and the concept of an expert system before exploring the basics: facts and rules.
    The bulk of the chapter saw us work through four examples illustrating the core
    of CLIPS. We learned how rules respond to facts by building an elementary calculator.
    We then re-explored family relationships to illustrate the difference between
    CLIPS and Prolog when generating inferences from collections of facts. The next
    example used a factory simulation to demonstrate arranging the firing sequence
    of rules by manipulating their salience. The final example was our most elaborate.
    We used a learned decision tree to implement a collection of rules, those that
    might have been created by an expert to let us categorize different types of iris
    flowers by answering a few yes or no questions.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: CLIPS is our last atypical programming language. We move now to the first of
    our esolangs and into the realm of what I’m calling “eccentric programming languages.”
    We’ll begin with ABC, a tiny language that will serve us well to introduce the
    weirdly wonderful world of esolangs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
