- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: COMPOSITE DATA TYPES AND MEMORY OBJECTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复合数据类型和内存对象**
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)'
- en: Composite data types are composed of other, more primitive, types. Examples
    include pointers, arrays, records or structures, tuples, and unions. Many high-level
    languages (HLLs) provide syntactical abstractions for these composite data types
    that make them easy to declare and use, while hiding their underlying complexities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 复合数据类型由其他更基础的类型组成。例如，指针、数组、记录或结构、元组和联合体等。许多高级语言（HLLs）为这些复合数据类型提供了语法抽象，使它们易于声明和使用，同时隐藏了其底层的复杂性。
- en: Though the costs of using these composite data types are not terrible, a programmer
    who doesn’t understand them can easily introduce inefficiencies into an application.
    This chapter provides an overview of those costs to better enable you to write
    great code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用这些复合数据类型的成本并不算高，但如果程序员不理解它们，容易在应用程序中引入低效问题。本章将概述这些成本，帮助你更好地编写优秀的代码。
- en: '**7.1 Pointer Types**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.1 指针类型**'
- en: A *[pointer](gloss01.xhtml#gloss01_194)* is a variable whose value refers to
    some other object. High-level languages like Pascal and C/C++ hide the simplicity
    of pointers behind a wall of abstraction. This added complexity can be intimidating
    if you don’t understand what’s going on behind the scenes. However, a little knowledge
    will go a long way toward easing your mind.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *[指针](gloss01.xhtml#gloss01_194)* 是一个变量，其值指向另一个对象。像 Pascal 和 C/C++ 这样的高级语言通过抽象层隐藏了指针的简单性。如果你不了解背后的运作原理，这种增加的复杂性可能会让人感到害怕。然而，一些基础知识能帮助你轻松理解这一点。
- en: 'Let’s start with something simple: an array. Consider the following array declaration
    in Pascal:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始：一个数组。考虑以下 Pascal 中的数组声明：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`M` is an array with 1,024 integers in it, indexed from `M[0]` to `M[1023]`.
    Each array element can hold an integer value that is independent of the others.
    In other words, this array gives you 1,024 different integer variables, each of
    which you access via array index rather than by name.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`M` 是一个包含 1,024 个整数的数组，索引从 `M[0]` 到 `M[1023]`。每个数组元素都可以容纳一个独立的整数值，彼此之间不受影响。换句话说，这个数组为你提供了
    1,024 个不同的整数变量，每个变量都可以通过数组索引来访问，而不是通过名称。'
- en: 'The statement `M[0]:=100` stores the value `100` into the first element of
    the array `M`. Now consider the following two statements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 `M[0]:=100` 将值 `100` 存储到数组 `M` 的第一个元素中。现在考虑以下两条语句：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These two statements do the same thing as `M[0]:=100;`. You can use any integer
    expression in the range `0` through `1023` as an index of this array. The following
    statements *still* perform the same operation as the earlier statement:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条语句与 `M[0]:=100;` 执行的是相同的操作。你可以使用任何整数表达式，范围从 `0` 到 `1023`，作为该数组的索引。以下语句 *依然*
    执行与之前相同的操作：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But how about the following?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，下面的情况如何呢？
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Whoa! Now that takes a few moments to digest. However, if you take it slowly,
    you’ll realize that these two instructions perform the same operation as before.
    The first statement stores `0` into array element `M[1]`. The second statement
    fetches the value of `M[1]`, which is `0`, and uses that value to determine where
    it stores the value `100`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这需要一些时间来消化。然而，如果你慢慢思考，你会意识到这两条指令与之前执行的是相同的操作。第一条语句将 `0` 存储到数组元素 `M[1]` 中。第二条语句获取
    `M[1]` 的值（即 `0`），并使用该值来确定存储值 `100` 的位置。
- en: If you’re willing to accept this example as reasonable—perhaps bizarre, but
    usable nonetheless—then you’ll have no problems with pointers, because `M[1]`
    is a pointer! Well, not really, but if you were to change `M` to “memory” and
    treat each element of this array as a separate memory location, then this meets
    the definition of a pointer—that is, a memory variable whose value is the address
    of some other memory object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意接受这个例子作为合理的——也许有点奇怪，但仍然可以使用——那么你将不会对指针感到困惑，因为 `M[1]` 就是一个指针！好吧，严格来说不是，但如果你把
    `M` 改成 “memory”，并把该数组的每个元素当作一个独立的内存位置，那么这就符合指针的定义——也就是说，一个内存变量，其值是指向另一个内存对象的地址。
- en: '***7.1.1 Pointer Implementation***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.1 指针实现***'
- en: Although most languages implement pointers using memory addresses, a pointer
    is actually an abstraction of a memory address. Therefore, a language could define
    a pointer using any mechanism that maps the value of the pointer to the address
    of some object in memory. Some implementations of Pascal, for example, use offsets
    from some fixed memory address as pointer values. Some languages (including dynamic
    languages like LISP) implement pointers by using *double indirection*; that is,
    the pointer object contains the address of some memory variable whose value is
    the address of the object to be accessed. This approach may seem convoluted, but
    it offers certain advantages in a complex memory management system. However, for
    simplicity’s sake, this chapter will assume that, as defined earlier, a pointer
    is a variable whose value is the address of some other object in memory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数语言使用内存地址实现指针，但指针实际上是内存地址的一种抽象。因此，一种语言可以使用任何机制来定义指针，映射指针的值到内存中某个对象的地址。例如，某些Pascal的实现使用从某个固定内存地址的偏移量作为指针值。某些语言（包括像LISP这样的动态语言）通过使用*双级间接访问*来实现指针；也就是说，指针对象包含某个内存变量的地址，而该内存变量的值是要访问的对象的地址。这种方法看起来可能很复杂，但在复杂的内存管理系统中，它提供了某些优势。然而，为了简化起见，本章将假设，如前所定义，指针是一个变量，其值是内存中某个对象的地址。
- en: 'As you’ve seen in examples from previous chapters, you can indirectly access
    an object using a pointer with two 32-bit 80x86 machine instructions (or with
    a similar sequence on other CPUs), as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前几章的示例中所见，你可以通过使用一个指针和两条32位80x86机器指令（或者在其他CPU上使用类似的指令序列）间接访问一个对象，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Access to data via double indirection is less efficient than the straight pointer
    implementation because it takes an extra machine instruction to fetch the data
    from memory. This isn’t obvious in an HLL like C/C++ or Pascal, where you’d use
    double indirection as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双级间接访问数据的效率低于直接指针实现，因为它需要额外的机器指令从内存中获取数据。在像C/C++或Pascal这样的高级语言中，这一点并不明显，你会像下面这样使用双级间接访问：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This looks very similar to single indirection. In assembly language, however,
    you’ll see the extra work involved:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与单级间接访问非常相似。然而，在汇编语言中，你会看到额外的工作：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Contrast this with the two earlier assembly instructions needed to access an
    object using single indirection. Because double indirection requires 50 percent
    more code than single indirection, many languages implement pointers using single
    indirection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与之前两条汇编指令进行对比，后者用于通过单级间接访问对象。因为双级间接访问比单级间接访问需要多50%的代码，许多语言实现指针时采用单级间接访问。
- en: '***7.1.2 Pointers and Dynamic Memory Allocation***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.2 指针与动态内存分配***'
- en: Pointers typically reference anonymous variables that you allocate on the *[heap](gloss01.xhtml#gloss01_109)*
    (a region in memory reserved for dynamic storage allocation) using memory allocation/deallocation
    functions like `malloc()`/`free()` in C, `new()`/`dispose()` in Pascal, and `new()`/`delete()`
    in C++ (note, however, that C++11 and later prefer `std::unique_ptr` and `std_shared_ptr`
    for memory allocation, with automatic memory deallocation). Java, Swift, C++11
    (and later) and other more modern languages only provide a function equivalent
    to `new()`. These languages handle deallocation automatically via garbage collection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指针通常引用你在*[堆](gloss01.xhtml#gloss01_109)*上分配的匿名变量（堆是为动态存储分配保留的内存区域），通过像C中的`malloc()`/`free()`，Pascal中的`new()`/`dispose()`，以及C++中的`new()`/`delete()`这样的内存分配/释放函数（然而，C++11及以后的版本更倾向于使用`std::unique_ptr`和`std_shared_ptr`进行内存分配，且自动进行内存释放）。Java、Swift、C++11（及以后的版本）和其他更现代的语言只提供与`new()`等效的函数。这些语言通过垃圾回收自动处理内存释放。
- en: Objects you allocate on the heap are known as *[anonymous variables](gloss01.xhtml#gloss01_12)*
    because you refer to them by their address rather than by a name. And because
    the allocation functions return the address of an object on the heap, you typically
    store the function’s return result into a pointer variable. While the pointer
    variable may have a name, that name applies to the pointer’s data (an address),
    not the object referenced by this address.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你在堆上分配的对象被称为*[匿名变量](gloss01.xhtml#gloss01_12)*，因为你是通过它们的地址而不是名称来引用它们的。而且，由于分配函数返回堆上对象的地址，你通常将函数的返回结果存储到一个指针变量中。虽然指针变量可能有一个名称，但这个名称适用于指针的数据（一个地址），而不是该地址所引用的对象。
- en: '***7.1.3 Pointer Operations and Pointer Arithmetic***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.3 指针操作与指针运算***'
- en: Most languages that provide the pointer data type let you assign addresses to
    pointer variables, compare pointer values for equality or inequality, and indirectly
    reference an object via a pointer. Some languages allow additional operations,
    as you’ll see in this section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提供指针数据类型的语言允许你为指针变量分配地址，比较指针值的相等性或不相等性，并通过指针间接引用一个对象。有些语言还允许进行额外的操作，正如你将在本节中看到的那样。
- en: 'Many languages enable you to do limited arithmetic with pointers. At the very
    least, these languages provide the ability to add an integer constant to, or subtract
    one from, a pointer. To understand the purpose of these two arithmetic operations,
    note the syntax of the `malloc()` function in the C standard library:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言允许你对指针进行有限的算术运算。至少，这些语言提供了将整数常量加到指针上，或者从指针中减去一个整数的能力。为了理解这两种算术运算的目的，请注意C标准库中`malloc()`函数的语法：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The parameter you pass `malloc()` specifies the number of bytes of storage
    to allocate. A good C programmer generally supplies an expression like `sizeof(int)`
    as this parameter. The `sizeof()` function returns the number of bytes needed
    by its single parameter. Therefore, `sizeof(int)` tells `malloc()` to allocate
    at least enough storage for an `int` variable. Now consider the following call
    to `malloc()`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给`malloc()`的参数指定了要分配的存储字节数。一个好的C程序员通常会像`sizeof(int)`这样的表达式作为此参数传递。`sizeof()`函数返回其单个参数所需的字节数。因此，`sizeof(int)`告诉`malloc()`至少分配足够的存储空间来存放一个`int`类型的变量。现在考虑以下对`malloc()`的调用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the size of an integer is 4 bytes, this call to `malloc()` will allocate
    storage for 32 bytes, at consecutive addresses in memory (see [Figure 7-1](ch07.xhtml#ch07fig01)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个整数的大小是4个字节，那么对`malloc()`的这个调用将为32个字节分配存储空间，地址连续分布在内存中（参见[图7-1](ch07.xhtml#ch07fig01)）。
- en: '![image](../images/07fig01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig01.jpg)'
- en: '*Figure 7-1: Memory allocation with `malloc(sizeof(int) * 8)`*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：使用`malloc(sizeof(int) * 8)`进行内存分配*'
- en: The pointer that `malloc()` returns contains the address of the first integer
    in this set, so the C program can directly access only the very first of these
    eight integers. To access the individual addresses of the other seven integers,
    you need to add an integer offset to that *base* address. On machines that support
    byte-addressable memory (such as the 80x86), the address of each successive integer
    in memory is the address of the previous integer plus the integer’s size. For
    example, if a call to the C standard library `malloc()` routine returns the memory
    address `$0300_1000`, then the eight integers that `malloc()` allocates will reside
    at the memory addresses shown in [Table 7-1](ch07.xhtml#ch07tab01).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()`返回的指针包含这个集合中第一个整数的地址，因此C程序只能直接访问这八个整数中的第一个。要访问其他七个整数的单独地址，你需要在该*基*地址上加上一个整数偏移量。在支持字节可寻址内存的机器（例如80x86）上，内存中每个连续整数的地址是前一个整数地址加上该整数的大小。例如，如果对C标准库`malloc()`例程的调用返回内存地址`$0300_1000`，那么`malloc()`分配的八个整数将位于[表7-1](ch07.xhtml#ch07tab01)中显示的内存地址。'
- en: '**Table 7-1:** Integer Addresses Allocated for Base Address `$0300_1000`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 分配给基地址`$0300_1000`的整数地址'
- en: '| **Integer** | **Memory addresses** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **整数** | **内存地址** |'
- en: '| `0` | `$0300_1000..$0300_1003` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `$0300_1000..$0300_1003` |'
- en: '| `1` | `$0300_1004..$0300_1007` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `$0300_1004..$0300_1007` |'
- en: '| `2` | `$0300_1008..$0300_100b` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `$0300_1008..$0300_100b` |'
- en: '| `3` | `$0300_100c..$0300_100f` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `$0300_100c..$0300_100f` |'
- en: '| `4` | `$0300_1010..$0300_1013` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `$0300_1010..$0300_1013` |'
- en: '| `5` | `$0300_1014..$0300_1017` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `$0300_1014..$0300_1017` |'
- en: '| `6` | `$0300_1018..$0300_101b` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `$0300_1018..$0300_101b` |'
- en: '| `7` | `$0300_101c..$0300_101f` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `$0300_101c..$0300_101f` |'
- en: '**7.1.3.1 Adding an Integer to a Pointer**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.3.1 将整数加到指针上**'
- en: 'Because these integers described in the preceding section are exactly 4 bytes
    apart, we add 4 to the address of the first integer to obtain the address of the
    second integer; add 4 to the address of the second integer to get the address
    of the third integer; and so on. In assembly language, we could access these eight
    integers using the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前面章节描述的这些整数之间的间隔正好是4个字节，我们将4加到第一个整数的地址，以获得第二个整数的地址；将4加到第二个整数的地址，以得到第三个整数的地址；以此类推。在汇编语言中，我们可以通过以下代码访问这八个整数：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the use of the 80x86 indexed addressing mode to access the eight integers
    that `malloc()` allocates. The EAX register maintains the base (first) address
    of the eight integers that this code allocates, and the constant in the addressing
    mode of the `mov()` instructions selects the offset of the specific integer from
    this base address.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用80x86索引寻址模式来访问`malloc()`分配的八个整数。EAX寄存器保持着这段代码分配的八个整数的基址（第一个地址），而`mov()`指令中的常量在寻址模式中选择了该基址偏移量所对应的具体整数。
- en: Most CPUs use byte addresses for memory objects. Therefore, when a program allocates
    multiple copies of some *n*-byte object in memory, the objects won’t begin at
    consecutive memory addresses; instead, they’ll appear in memory at addresses that
    are *n* bytes apart. Some machines, however, don’t allow a program to access memory
    at an arbitrary address in memory; rather, they require it to access data on address
    boundaries that are a multiple of a word, a double word, or even a quad word.
    Any attempt to access memory on some other boundary will raise an exception and
    potentially halt the application. If an HLL supports pointer arithmetic, it must
    account for this fact and provide a generic pointer arithmetic scheme that’s portable
    across many different CPU architectures. The most common solution that HLLs use
    when adding an integer offset to a pointer is to multiply that offset by the size
    of the object that the pointer references. That is, if you’ve got a pointer `p`
    to a 16-byte object in memory, then `p + 1` points 16 bytes beyond the address
    where `p` points. Likewise, `p + 2` points 32 bytes beyond that address. As long
    as the size of the data object is a multiple of the required alignment size (which
    the compiler can enforce by adding padding bytes, if necessary), this scheme avoids
    problems on those architectures that require aligned data access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CPU使用字节地址来表示内存对象。因此，当程序在内存中分配多个* n *字节的对象时，这些对象不会从连续的内存地址开始；相反，它们会出现在相距*n*字节的内存地址上。然而，一些机器不允许程序在内存中的任意地址访问数据；相反，它们要求在字、双字甚至四字对齐的地址边界上访问数据。任何尝试在其他边界上访问内存的行为都会引发异常，并可能导致应用程序停止。如果高级语言支持指针运算，它必须考虑这一事实，并提供一个通用的指针运算方案，能够在不同的CPU架构上移植。高级语言在给指针添加整数偏移时，最常见的解决方案是将偏移量乘以指针所引用对象的大小。也就是说，如果你有一个指向16字节对象的指针`p`，那么`p
    + 1`指向比`p`指向的地址向后16字节的地方。同样，`p + 2`指向该地址向后32字节的地方。只要数据对象的大小是所需对齐大小的倍数（编译器可以通过必要时添加填充字节来强制此约束），这种方案就能避免在需要对齐数据访问的架构上出现问题。
- en: Note that the addition operator only makes sense between a pointer and an integer
    value. For example, in C/C++ you can indirectly access objects in memory using
    an expression like `*(p + i)` (where `p` is a pointer to an object and `i` is
    an integer value). It doesn’t make sense to add two pointers together, or to add
    other data types to a pointer. For example, adding a floating-point value to a
    pointer isn’t logical. (What would it mean to reference the data at some base
    address plus 1.5612?) Integers—signed and unsigned—are the only reasonable values
    to add to a pointer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有在指针和整数值之间，使用加法运算符才有意义。例如，在C/C++中，你可以使用表达式`*(p + i)`（其中`p`是指向对象的指针，`i`是整数值）间接访问内存中的对象。将两个指针相加，或者将其他数据类型加到指针上，是没有意义的。例如，将浮点数值加到指针上就不合逻辑。（将数据引用设为某个基地址加上1.5612又意味着什么呢？）整数——有符号和无符号——是唯一可以加到指针上的合理值。
- en: On the other hand, not only can you add an integer to a pointer, but you can
    also add a pointer to an integer and the result is still a pointer (both `p` `+`
    `i` and `i` `+` `p` are legal). This is because addition is *[commutative](gloss01.xhtml#gloss01_55)*—the
    order of the operands does not affect the result.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你不仅可以将整数加到指针上，还可以将指针加到整数上，结果仍然是一个指针（`p` `+` `i`和`i` `+` `p`都是合法的）。这是因为加法是*
    [交换律](gloss01.xhtml#gloss01_55)*——操作数的顺序不影响结果。
- en: '**7.1.3.2 Subtracting an Integer from a Pointer**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.3.2 从指针中减去整数**'
- en: Subtracting an integer from a pointer references a memory location immediately
    before the address held in the pointer. However, subtraction is not commutative,
    and subtracting a pointer from an integer is not a legal operation (`p` `-` `i`
    is legal, but `i` `-` `p` is not).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从指针中减去一个整数表示指针所指向地址之前的一个内存位置。然而，减法不是交换的，且将指针减去一个整数不是合法操作（`p` `-` `i`是合法的，但`i`
    `-` `p`则不合法）。
- en: In C/C++ `*(p` `-` `i)` accesses the `ith` ^(object immediately before the object
    at which `p` points. In 80x86 assembly language, as in assembly on many processors,
    you can also specify a negative constant offset when using an indexed addressing
    mode. For example:)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中，`*(p` `-` `i)` 访问 `p` 所指向的对象之前的第 `i` 个对象。在 80x86 汇编语言中，像许多处理器上的汇编语言一样，你也可以在使用索引寻址模式时指定负常数偏移。例如：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Keep in mind that 80x86 assembly language uses byte offsets, not object offsets
    (as C/C++ does). Therefore, this statement loads into EAX the double word in memory
    immediately preceding the memory address in EBX.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，80x86 汇编语言使用的是字节偏移，而不是对象偏移（如 C/C++ 所做的那样）。因此，这条语句将把紧接在 EBX 中内存地址之前的双字加载到
    EAX 中。
- en: '**7.1.3.3 Subtracting a Pointer from a Pointer**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.3.3 从指针中减去指针**'
- en: 'In contrast to addition, it makes sense to subtract the value of one pointer
    variable from another. Consider the following C/C++ code, which proceeds through
    a string of characters looking for the first `e` character that follows the first
    `a` that it finds:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法不同，从一个指针变量减去另一个指针变量是有意义的。考虑以下 C/C++ 代码，它通过字符字符串查找第一个紧跟在第一个 `a` 后面的 `e` 字符：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Subtracting one pointer from the other produces the number of data objects that
    exist between them (in this case, `ePtr` and `aPtr` point at characters, so the
    subtraction result produces the number of characters, or bytes, between the two
    pointers).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个指针减去另一个指针会得到它们之间存在的数据对象数量（在此例中，`ePtr` 和 `aPtr` 指向字符，所以减法结果会得到两个指针之间的字符数或字节数）。
- en: The subtraction of two pointer values makes sense only if they both reference
    the same data structure (for example, pointing at characters within the same string,
    as in this C/C++ example) in memory. Although C/C++ (and certainly assembly language)
    will allow you to subtract two pointers that point at completely different objects
    in memory, the result will probably have very little meaning.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当两个指针都指向同一数据结构（例如，在内存中指向同一字符串中的字符，如此 C/C++ 示例所示）时，两个指针相减才有意义。虽然 C/C++（以及汇编语言）允许你减去指向内存中完全不同对象的两个指针，但结果可能几乎没有什么意义。
- en: For pointer subtraction in C/C++, the base types of the two pointers must be
    identical (that is, the two pointers must contain the addresses of two objects
    whose types are identical). This restriction exists because pointer subtraction
    in C/C++ produces the number of objects, not the number of bytes, between the
    two pointers. It wouldn’t make any sense to compute the number of objects between
    a byte in memory and a double word in memory; would you be counting the number
    of bytes or the number of double words? In assembly language you can get away
    with this (and the result is always the number of bytes between the two pointers),
    but it still doesn’t make much sense semantically.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中进行指针相减时，两个指针的基本类型必须相同（即，两个指针必须包含两个对象的地址，这些对象的类型是相同的）。这一限制存在的原因是，C/C++
    中的指针相减会产生两个指针之间的对象数量，而不是字节数量。如果你计算内存中的字节和双字之间的对象数量，那就没有意义了；你是要计算字节数还是双字数呢？在汇编语言中你可以这样做（结果始终是两个指针之间的字节数），但从语义上讲，这样做也没有太大意义。
- en: The subtraction of two pointers could return a negative number if the left pointer
    operand is at a lower memory address than the right pointer operand. Depending
    on your language and its implementation, you may need to take the absolute value
    of the result if you’re interested only in the distance between the two pointers
    and you don’t care which pointer contains the greater address.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两个指针相减可能会返回负数，如果左侧的指针操作数的内存地址低于右侧的指针操作数。根据你的编程语言及其实现方式，如果你只关心两个指针之间的距离而不在乎哪个指针包含更大的地址，你可能需要取结果的绝对值。
- en: '**7.1.3.4 Comparing Pointers**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.3.4 比较指针**'
- en: Almost every language that supports pointers will let you compare two pointers
    to see whether or not they are equal. Comparing two pointers will tell you whether
    they reference the same object in memory. Some languages (such as assembly and
    C/C++) will also let you compare two pointers to see if one pointer is less than
    or greater than the other. Such a comparison only makes sense, however, if both
    pointers have the same base type and contain the address of some object within
    the same data structure (such as an array, string, or record). If you find that
    one pointer is less than the other, this tells you that it references an object
    within the data structure that appears before the object referenced by the second
    pointer. The converse is true for the greater-than comparison.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有支持指针的语言都会允许你比较两个指针，看看它们是否相等。比较两个指针将告诉你它们是否引用了内存中的同一个对象。一些语言（如汇编和C/C++）还允许你比较两个指针，看看一个指针是否小于或大于另一个指针。然而，只有当两个指针具有相同的基类型并包含同一数据结构（如数组、字符串或记录）中某个对象的地址时，这种比较才有意义。如果你发现一个指针小于另一个指针，这意味着它引用的数据结构中的某个对象出现在第二个指针所引用的对象之前。大于比较的反向情况也适用。
- en: '**7.2 Arrays**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.2 数组**'
- en: After strings, arrays are probably the most common composite (or *aggregate*)
    data type. Abstractly, an array is an aggregate data type whose members (elements)
    are all of the same type. You select a member from the array by specifying its
    array index with an integer (or with some value whose underlying representation
    is an integer, such as character, enumerated, and Boolean types). In this chapter,
    we’ll assume that the integer indices of an array are numerically contiguous (though
    this is not required). That is, if both `x` and `y` are valid indices of the array,
    and if `x` `<` `y`, then all `i` such that `x` `<` `i` `<` `y` are also valid
    indices. We’ll also assume that array elements occupy contiguous locations in
    memory. Therefore, an array with five elements will appear in memory as shown
    in [Figure 7-2](ch07.xhtml#ch07fig02).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串之后，数组可能是最常见的复合（或 *聚合*）数据类型。从抽象角度来看，数组是一个聚合数据类型，其成员（元素）都是相同类型的。你可以通过指定数组索引（一个整数或某些底层表示为整数的值，如字符、枚举和布尔类型）来选择数组中的成员。在本章中，我们假设数组的整数索引是连续的（尽管这并不是必须的）。也就是说，如果`x`和`y`都是数组的有效索引，并且`x`
    `<` `y`，那么所有满足`x` `<` `i` `<` `y`的`i`也是有效的索引。我们还假设数组元素在内存中占据连续的存储位置。因此，包含五个元素的数组在内存中的表现如[图7-2](ch07.xhtml#ch07fig02)所示。
- en: '![image](../images/07fig02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig02.jpg)'
- en: '*Figure 7-2: Array layout in memory*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：数组在内存中的布局*'
- en: The *base address* of an array is the address of its first element and occupies
    the lowest memory location. The second array element directly follows the first
    in memory, the third element follows the second, and so on. There is no requirement
    that the indices start at `0`; they can start with any number as long as they’re
    contiguous. However, we’ll begin arrays at index `0` unless there’s a good reason
    to do otherwise.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的*基地址*是其第一个元素的地址，并占据最低的内存位置。第二个数组元素直接跟在第一个元素之后，第三个元素紧随其后，以此类推。索引不要求从`0`开始；它们可以从任何数字开始，只要是连续的。然而，除非有充分的理由，否则我们将数组从索引`0`开始。
- en: Whenever you apply the indexing operator to an array, the result is the array
    element specified by that index. For example, `A[i]` chooses the `i`th element
    from array `A`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你对数组应用索引运算符时，结果就是该索引指定的数组元素。例如，`A[i]`选择数组`A`中的第`i`个元素。
- en: '***7.2.1 Array Declarations***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.2.1 数组声明***'
- en: 'Array declarations are very similar across many HLLs. C, C++, and Java all
    let you declare an array by specifying the total number of elements in it. The
    syntax for an array declaration in these languages is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明在许多高级语言中都非常相似。C、C++和Java都允许你通过指定数组中元素的总数来声明数组。这些语言中的数组声明语法如下：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are some sample C/C++ array declarations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些典型的C/C++数组声明：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you declare these arrays as automatic variables, then C/C++ “initializes”
    them with whatever bit patterns exist in memory. If, on the other hand, you declare
    these arrays as static objects, then C/C++ zeros out each array element. If you
    want to initialize an array yourself, you can use the following C/C++ syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些数组声明为自动变量，那么C/C++会用内存中存在的任何位模式来“初始化”它们。另一方面，如果你将这些数组声明为静态对象，那么C/C++会将每个数组元素初始化为零。如果你想自己初始化数组，可以使用以下C/C++语法：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s a typical example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的例子：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Swift array declarations are a bit different from other C-based languages.
    Swift array declarations take one of the following two (equivalent) forms:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 数组声明与其他 C 类语言略有不同。Swift 数组声明有以下两种（等效的）形式：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unlike other languages, arrays in Swift are purely dynamic. You don’t normally
    specify the number of elements when you first create the array; instead, you add
    elements to the array as needed using functions like `append()` or `insert()`.
    If you want to predeclare an array with some number of elements, you use this
    special array constructor form:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，Swift 中的数组是纯动态的。你通常在第一次创建数组时不会指定元素的数量；相反，你可以使用`append()`或`insert()`等函数按需将元素添加到数组中。如果你想预声明一个具有一定数量元素的数组，你可以使用这种特殊的数组构造形式：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, initial_value is a value of type element_type and elements
    is the number of array elements to create in the array. For example, the following
    Swift code creates two arrays of 100 `Int` values, each initialized to `0`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，initial_value 是元素类型的值，elements 是要在数组中创建的元素数量。例如，以下 Swift 代码创建了两个包含 100
    个 `Int` 值的数组，每个数组元素初始化为 `0`：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can still extend the size of this array (for example, by using the `append()`
    function); because Swift arrays are dynamic, their size can grow or shrink at
    runtime.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以扩展这个数组的大小（例如，通过使用`append()`函数）；因为 Swift 数组是动态的，它们的大小可以在运行时增长或缩小。
- en: 'Swift arrays can be created with initial values, as these examples demonstrate:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 数组可以通过初始值来创建，以下示例展示了这一点：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'C# arrays are also dynamic objects; though their syntax is slightly different
    from Swift, the concept is the same:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C# 数组也是动态对象；尽管它们的语法与 Swift 略有不同，但概念是相同的：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, type is the data type (for example, `double` or `int`), array_name is
    the array variable name, and elements is the number of elements to allocate in
    the array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，type 是数据类型（例如，`double` 或 `int`），array_name 是数组变量名，elements 是要在数组中分配的元素数量。
- en: 'You can also initialize C# arrays in a declaration as follows (other syntaxes
    are possible; this is just a simple example):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过以下方式在声明时初始化 C# 数组（其他语法也是可能的；这只是一个简单的示例）：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The array declaration syntax in HLA (High-Level Assembly) takes the following
    form, which is semantically equivalent to the C/C++ declaration:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: HLA（高级汇编语言）中的数组声明语法如下，它在语义上等同于 C/C++ 的声明：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here are some examples of HLA array declarations that allocate storage for
    uninitialized arrays (the second example assumes that you have defined the `integer`
    data type in a `type` section of the HLA program):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 HLA 数组声明的示例，它们为未初始化的数组分配存储空间（第二个示例假设你已在 HLA 程序的 `type` 部分定义了 `integer`
    数据类型）：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also initialize the array elements using declarations like the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下声明方式来初始化数组元素：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Both of these definitions create arrays with eight elements. The first definition
    initializes each 4-byte `real32` array element with one of the values in the range
    `0.0` through `7.0`. The second declaration initializes each `integer` array element
    with one of the values in the range `8` through `15`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义都会创建包含八个元素的数组。第一个定义将每个 4 字节的 `real32` 数组元素初始化为 `0.0` 到 `7.0` 范围内的某个值。第二个声明将每个
    `integer` 数组元素初始化为 `8` 到 `15` 范围内的某个值。
- en: 'Pascal/Delphi uses the following syntax to declare an array:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal/Delphi 使用以下语法来声明数组：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As in the previous examples, array_name is the identifier, and data_type is
    the type of each element in this array. Unlike C/C++, Java, Swift, and HLA, in
    Free Pascal/Delphi you specify the upper and lower bounds of the array rather
    than the array’s size. The following are typical array declarations in Pascal:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，array_name 是标识符，data_type 是该数组中每个元素的类型。与 C/C++、Java、Swift 和 HLA 不同，在
    Free Pascal/Delphi 中，你指定的是数组的上下界，而不是数组的大小。以下是 Pascal 中的典型数组声明：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although these Pascal examples start their indices at `0`, Pascal does not
    require it. The following Pascal array declaration is also perfectly valid:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些 Pascal 示例的索引从`0`开始，但 Pascal 并不要求如此。以下 Pascal 数组声明也是完全有效的：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The program that declares this array would use indices `1998` through `2039`
    when accessing elements of this array, not `0` through `41`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 声明该数组的程序在访问该数组的元素时会使用`1998`到`2039`的索引，而不是`0`到`41`。
- en: Many Pascal compilers provide a very useful feature to help you locate defects
    in your programs. Whenever you access an element of an array, these compilers
    automatically insert code that will verify that the array index is within the
    bounds specified by the declaration. This extra code will stop the program if
    the index is out of range. For example, if an index into `Profits``ByYear` is
    outside the range `1998` through `2039`, the program will abort with an error.^([1](footnotes.xhtml#fn7_1a))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Pascal编译器提供一个非常有用的功能，可以帮助你定位程序中的缺陷。每当你访问数组的一个元素时，这些编译器会自动插入代码，以验证数组索引是否在声明中指定的范围内。如果索引超出范围，这段额外的代码会使程序停止。例如，如果对`Profits``ByYear`的索引超出了`1998`到`2039`的范围，程序将因错误而中止。^([1](footnotes.xhtml#fn7_1a))
- en: 'Generally, array indices are integer values, though some languages allow other
    *ordinal types* (data types that use an underlying integer representation). For
    example, Pascal allows `char` and `boolean` array indices. In Pascal, it’s perfectly
    reasonable and useful to declare an array as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数组的索引是整数值，尽管一些语言允许使用其他*序数类型*（使用底层整数表示的数据类型）作为索引。例如，Pascal允许`char`和`boolean`作为数组索引。在Pascal中，声明一个数组如下是完全合理且有用的：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You access elements of `alphaCnt` using a character expression as the array
    index. For example, consider the following Pascal code, which initializes each
    element of `alphaCnt` to `0` (assuming `ch:char` appears in the `var` section):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过字符表达式作为数组索引来访问`alphaCnt`的元素。例如，考虑以下Pascal代码，它将`alphaCnt`的每个元素初始化为`0`（假设`ch:char`出现在`var`部分）：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Assembly language and C/C++ treat most ordinal values as special instances of
    integer values, so they are legal array indices. Most implementations of BASIC
    allow a floating-point number as an array index, though BASIC always truncates
    the value to an integer before using it as an index.^([2](footnotes.xhtml#fn7_2a))
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言和C/C++将大多数序数值视为整数值的特殊实例，因此它们是合法的数组索引。大多数BASIC实现允许使用浮点数作为数组索引，尽管BASIC在使用浮点数作为索引前会将其截断为整数。^([2](footnotes.xhtml#fn7_2a))
- en: '***7.2.2 Array Representation in Memory***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.2.2 数组在内存中的表示***'
- en: Abstractly, an array is a collection of variables that you access using an index.
    Semantically, we can define an array any way we please, as long as it maps distinct
    indices to distinct objects in memory and always maps the same index to the same
    object. In practice, however, most languages use a few common algorithms that
    provide efficient access to the array data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象的角度来看，数组是一个变量集合，你可以通过索引来访问这些变量。从语义上讲，我们可以根据自己的需求定义数组，只要它将不同的索引映射到内存中的不同对象，并且始终将相同的索引映射到相同的对象。然而，在实际应用中，大多数语言使用一些常见的算法来提供对数组数据的高效访问。
- en: The number of bytes of storage an array consumes is the product of the number
    of elements multiplied by the number of bytes per element in the array. Many languages
    also add a few bytes of padding at the end of the array so that the total length
    of the array is an even multiple of a nice value like 4 or 8 (on a 32- or 64-bit
    machine, a compiler may append bytes to the array in order to extend its length
    to some multiple of the machine’s word size). However, a program must *not* depend
    on these extra padding bytes, because they may or may not be present. Some compilers
    always put them in, some never do, and still others put them in depending on the
    type of object that immediately follows the array in memory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数组占用的存储字节数是数组元素个数与每个元素所占字节数的乘积。许多语言还会在数组的末尾添加一些填充字节，以确保数组的总长度是4或8等常见值的偶数倍（在32位或64位机器上，编译器可能会向数组添加字节，以使其长度扩展为机器字大小的倍数）。然而，程序**不应该**依赖这些额外的填充字节，因为它们可能存在也可能不存在。一些编译器总是添加这些字节，一些则从不添加，还有一些则根据内存中紧跟数组的对象类型决定是否添加。
- en: Many optimizing compilers attempt to start an array at a memory address that
    is an even multiple of some common size like 2, 4, or 8 bytes. Effectively, this
    adds padding bytes before the beginning of the array or, if you prefer to think
    of it this way, after the previous object in memory (see [Figure 7-3](ch07.xhtml#ch07fig03)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多优化编译器会尝试将数组的起始内存地址设置为某个常见大小（如2、4或8字节）的偶数倍。实际上，这就相当于在数组开始前添加填充字节，或者如果你愿意这样理解的话，添加到内存中上一个对象之后（见[图
    7-3](ch07.xhtml#ch07fig03)）。
- en: '![image](../images/07fig03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Adding padding bytes before an array*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：在数组前添加填充字节*'
- en: 'On machines that do not support byte-addressable memory, compilers that attempt
    to place the first element of an array on an easily accessed boundary will allocate
    storage for an array on whatever boundary the machine supports. If the size of
    each array element is less than the minimum size memory object the CPU supports,
    the compiler implementer has two options:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持字节寻址内存的机器上，编译器会尝试将数组的第一个元素放置在一个容易访问的边界上，并根据机器支持的边界分配数组的存储空间。如果每个数组元素的大小小于CPU支持的最小内存对象大小，编译器实现者有两个选择：
- en: Allocate the smallest accessible memory object for each element of the array.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个数组元素分配最小可访问的内存对象。
- en: Pack multiple array elements into a single memory cell.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个数组元素打包成一个内存单元。
- en: The first option has the advantage of being fast, but it wastes memory because
    each array element carries along some extra storage that it doesn’t need. The
    second option is compact but slower, as it requires extra instructions to pack
    and unpack data when accessing array elements. Compilers on such machines often
    let you specify whether you want the data packed or unpacked so you can choose
    between space and speed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择的优点是速度快，但它浪费内存，因为每个数组元素携带了一些不需要的额外存储。第二种选择则更紧凑，但较慢，因为它需要额外的指令来打包和解包数据以访问数组元素。这些机器上的编译器通常允许你指定是否希望数据打包或解包，这样你就可以在空间和速度之间做出选择。
- en: If you’re working on a byte-addressable machine (like the 80x86), you probably
    don’t have to worry about this issue. However, if you’re using an HLL and your
    code might wind up running on a different machine in the future, you should choose
    an array organization that is efficient on all machines.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在字节寻址的机器上工作（例如80x86），你可能不需要担心这个问题。然而，如果你使用的是高级语言（HLL），并且你的代码将来可能在其他机器上运行，你应该选择一种在所有机器上都高效的数组组织方式。
- en: '***7.2.3 Accessing Elements of an Array***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.2.3 访问数组元素***'
- en: 'If you allocate all the storage for an array in contiguous memory locations,
    and the first index of the array is `0`, then accessing an element of a one-dimensional
    array is simple. You can compute the address of any given element of an array
    using the following formula:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为一个数组分配了连续的内存位置，并且数组的第一个索引是`0`，那么访问一维数组的元素非常简单。你可以使用以下公式计算数组中任何给定元素的地址：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Element_Size is the number of bytes that each array element occupies. Thus,
    if each array element is of type `byte`, the Element_Size field is `1` and the
    computation is very simple. If each element is a `word` (or another 2-byte type),
    then Element_Size is `2`, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Element_Size是每个数组元素所占的字节数。因此，如果每个数组元素是`byte`类型，Element_Size字段为`1`，计算就非常简单。如果每个元素是`word`（或其他2字节类型），那么Element_Size就是`2`，依此类推。
- en: 'Consider the following Pascal array declaration:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Pascal数组声明：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To access an element of the `SixteenInts` on a byte-addressable machine, assuming
    4-byte integers, you’d use this calculation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字节寻址机器上访问`SixteenInts`数组的元素，假设是4字节的整数，你可以使用以下计算：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In assembly language (where you would actually have to do this calculation
    manually rather than having the compiler do it for you), you’d use code like the
    following to access array element `SixteenInts[index]`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中（在这种情况下你需要手动进行计算，而不是让编译器为你做这件事），你可以使用以下代码来访问数组元素`SixteenInts[index]`：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***7.2.4 Multidimensional Arrays***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.2.4 多维数组***'
- en: Most CPUs can easily handle one-dimensional arrays. Unfortunately, though, there’s
    no magic addressing mode that lets you easily access elements of multidimensional
    arrays. That takes some work and several machine instructions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CPU可以轻松处理一维数组。不幸的是，没有一种神奇的寻址模式可以让你轻松访问多维数组的元素。访问多维数组元素需要一些工作和多个机器指令。
- en: Before discussing how to declare or access multidimensional arrays, let’s look
    at how to implement them in memory. The first challenge is figuring out how to
    store a multidimensional object in a one-dimensional memory space.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何声明或访问多维数组之前，让我们先看看如何在内存中实现它们。第一个挑战是弄清楚如何将一个多维对象存储在一维内存空间中。
- en: 'Consider for a moment a Pascal array of the following form:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个Pascal数组，形式如下：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This array contains 16 bytes organized as four rows of four characters. We need
    to map each of the 16 bytes in this array to each of the 16 contiguous bytes in
    main memory. [Figure 7-4](ch07.xhtml#ch07fig04) shows one way to do this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含16个字节，按四行四列的方式组织。我们需要将这个数组中的每个16个字节映射到主内存中的16个连续字节。[图 7-4](ch07.xhtml#ch07fig04)展示了这样做的一种方式。
- en: '![image](../images/07fig04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig04.jpg)'
- en: '*Figure 7-4: Mapping a 4×4 array to sequential memory locations*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：将 4×4 数组映射到顺序内存位置*'
- en: 'The actual mapping is not important as long as it adheres to two rules:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 只要遵循以下两条规则，实际的映射方式并不重要：
- en: No two entries in the array can occupy the same memory location(s).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组中的任何两个元素不能占用相同的内存位置。
- en: Each element in the array must always map to the same memory location.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组中的每个元素必须始终映射到相同的内存位置。
- en: 'Therefore, you need a function with two input parameters—one for a row and
    one for a column value—that produces an offset into a contiguous block of 16 memory
    locations. Any function that satisfies these two constraints will work fine. However,
    what you really want is a mapping function that computes efficiently at runtime
    and works for arrays with any number of dimensions and any bounds on those dimensions.
    While there are numerous functions that fit this bill, there are two categories
    that most HLLs use: *[row-major ordering](gloss01.xhtml#gloss01_218)* and *[column-major
    ordering](gloss01.xhtml#gloss01_54)*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要一个具有两个输入参数的函数——一个用于行，一个用于列的值——该函数会产生一个偏移量，指向连续的 16 个内存位置块。任何满足这两个约束条件的函数都能正常工作。然而，你真正需要的是一个映射函数，它能够在运行时高效计算，并且适用于任何维度和任意维度范围的数组。虽然有许多符合这些条件的函数，但大多数高级语言使用的是两种类型：*[行主序排列](gloss01.xhtml#gloss01_218)*
    和 *[列主序排列](gloss01.xhtml#gloss01_54)*。
- en: Before I actually describe row- and column-major ordering, let’s go over some
    terminology. The term *row index* describes a numeric index into a row; that is,
    if a single row were treated as a one-dimensional array, the row index would be
    the index into that array. *Column index* has a similar meaning; if a single column
    were treated as a one-dimensional array, the column index would be the index into
    that array. If you look back at [Figure 7-4](ch07.xhtml#ch07fig04), the numbers
    0, 1, 2, and 3 above each column are the *column numbers*, and those same values
    to the left of the rows are the *row numbers*. It’s easy to get confused with
    this terminology because *the column number is the same value as the row index*;
    that is, the column number is equivalent to an index into any one of the four
    rows. Similarly, *a row number is the same value as a column index*. This book
    uses the terms *row index* and *column index*, but note that other authors may
    use the terms *row* and *column* to mean row number and column number.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我真正描述行主序和列主序排列之前，让我们先回顾一些术语。*行索引*指的是对行的数字索引；也就是说，如果将单行视为一维数组，行索引将是该数组的索引。*列索引*有类似的含义；如果将单列视为一维数组，列索引将是该数组的索引。如果你回头看看[图
    7-4](ch07.xhtml#ch07fig04)，在每一列上方的数字 0、1、2 和 3 是*列号*，而位于行左侧的这些相同数字则是*行号*。这个术语容易让人混淆，因为*列号与行索引相同*；也就是说，列号等同于索引任何一行中的位置。类似地，*行号与列索引相同*。本书使用术语*行索引*和*列索引*，但请注意，其他作者可能使用*行*和*列*来指代行号和列号。
- en: '**7.2.4.1 Row-Major Ordering**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.2.4.1 行主序排列**'
- en: Row-major ordering assigns array elements to successive memory locations by
    moving across a row and then down the columns. [Figure 7-5](ch07.xhtml#ch07fig05)
    demonstrates this mapping.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 行主序排列通过先横向遍历一行，再纵向遍历列，将数组元素分配到连续的内存位置。[图 7-5](ch07.xhtml#ch07fig05) 演示了这种映射方式。
- en: '![image](../images/07fig05.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig05.jpg)'
- en: '*Figure 7-5: Row-major ordering*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：行主序排列*'
- en: Row-major ordering is the method employed by most high-level programming languages,
    including Pascal, C/C++, Java, C#, Ada, and Modula-2\. This organization is very
    easy to implement and easy to use in machine language. The conversion from a two-dimensional
    structure to a linear sequence is very intuitive. [Figure 7-6](ch07.xhtml#ch07fig06)
    provides another view of the ordering of a 4×4 array.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 行主序排列是大多数高级编程语言采用的方法，包括 Pascal、C/C++、Java、C#、Ada 和 Modula-2。这种组织方式非常容易实现，并且在机器语言中使用也很方便。从二维结构到线性序列的转换非常直观。[图
    7-6](ch07.xhtml#ch07fig06) 提供了 4×4 数组排列的另一种视图。
- en: '![image](../images/07fig06.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig06.jpg)'
- en: '*Figure 7-6: Another view of row-major ordering for a 4×4 array*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：4×4 数组的行主序排列的另一种视图*'
- en: 'The function that converts the set of multidimensional array indices into a
    single offset is a slight modification of the formula for computing the address
    of an element of a one-dimensional array. The formula to compute the offset for
    a 4×4 two-dimensional row-major-ordered array given an access of this form:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将多维数组索引集转换为单个偏移量的函数，是计算一维数组元素地址公式的轻微修改。计算 4×4 二维行主序数组的偏移量公式，假设访问形式如下：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As usual, Base_Address is the address of the array’s first element (`A[0][0]`
    in this case) and Element_Size is the size of an individual element of the array,
    in bytes. row_size is the number of elements in one row of the array (`4`, in
    this case, because each row has four elements). Assuming Element_Size is `1`,
    this formula computes the offsets shown in [Table 7-2](ch07.xhtml#ch07tab02) from
    the base address.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，Base_Address 是数组第一个元素的地址（此例为 `A[0][0]`），Element_Size 是数组单个元素的大小（以字节为单位）。row_size
    是数组中每行的元素数量（在此例中为 `4`，因为每行有四个元素）。假设 Element_Size 为 `1`，此公式计算的偏移量如[表 7-2](ch07.xhtml#ch07tab02)所示，从基地址开始。
- en: '**Table 7-2:** Offsets for Two-Dimensional Row-Major-Ordered Array'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-2：** 二维行主序数组的偏移量'
- en: '| **Column index** | **Row index** | **Offset into array** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **列索引** | **行索引** | **数组偏移量** |'
- en: '| --- | --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0` | `0` | `0` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` |'
- en: '| `0` | `2` | `2` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `2` | `2` |'
- en: '| `0` | `3` | `3` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `3` | `3` |'
- en: '| `1` | `0` | `4` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `4` |'
- en: '| `1` | `1` | `5` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `5` |'
- en: '| `1` | `2` | `6` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `2` | `6` |'
- en: '| `1` | `3` | `7` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `3` | `7` |'
- en: '| `2` | `0` | `8` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `0` | `8` |'
- en: '| `2` | `1` | `9` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `1` | `9` |'
- en: '| `2` | `2` | `10` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `2` | `10` |'
- en: '| `2` | `3` | `11` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `3` | `11` |'
- en: '| `3` | `0` | `12` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `0` | `12` |'
- en: '| `3` | `1` | `13` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `1` | `13` |'
- en: '| `3` | `2` | `14` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `2` | `14` |'
- en: '| `3` | `3` | `15` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `3` | `15` |'
- en: 'The following C/C++ code access sequential memory locations in a row-major-ordered
    array:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 C/C++ 代码访问行主序数组中的顺序内存位置：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is only slightly more complex. Consider the following C/C++ array declaration:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维数组，计算内存偏移量的公式只稍微复杂一点。考虑以下 C/C++ 数组声明：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you have an array access similar to `A[`depth_index`][`col_index`][`row_index`]`,
    then the computation that yields the offset into memory is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有类似 `A[`depth_index`][`col_index`][`row_index`]` 的数组访问，那么计算内存偏移量的公式为：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, Element_Size is the size, in bytes, of a single array element.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Element_Size 是单个数组元素的大小，以字节为单位。
- en: 'If you’ve got an *n*-dimensional array declared in C/C++ as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 C/C++ 中声明了一个 *n* 维数组，如下所示：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'and you wish to access the following element of this array:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你希望访问该数组中的以下元素：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'then you can compute the address of a particular array element using the following
    algorithm:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下算法计算特定数组元素的地址：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**7.2.4.2 Column-Major Ordering**'
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.2.4.2 列主序**'
- en: Column-major ordering, the other common array element address function, is used
    by FORTRAN and various dialects of BASIC (such as older versions of Microsoft
    BASIC) to index arrays. A column-major-ordered array is organized as shown in
    [Figure 7-7](ch07.xhtml#ch07fig07).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列主序是另一种常见的数组元素地址函数，FORTRAN 和各种 BASIC 方言（如旧版的 Microsoft BASIC）使用列主序索引数组。列主序数组的组织方式如[图
    7-7](ch07.xhtml#ch07fig07)所示。
- en: '![image](../images/07fig07.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig07.jpg)'
- en: '*Figure 7-7: Column-major ordering*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：列主序*'
- en: The formula for computing the address of an array element when using column-major
    ordering is very similar to that for row-major ordering. The difference is that
    you reverse the order of the index and size variables in the computation. That
    is, rather than working from the leftmost index to the rightmost, you operate
    from right to left.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列主序访问数组元素的地址计算公式与行主序非常相似。不同之处在于，你需要在计算中反转索引和大小变量的顺序。也就是说，不是从最左边的索引开始到最右边，而是从右向左操作。
- en: 'For a two-dimensional column-major array, the formula is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维列主序数组，公式如下：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For a three-dimensional column-major array, the formula is the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维列主序数组，公式如下：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And so on. Other than using these new formulas, accessing elements of an array
    using column-major ordering is identical to accessing arrays using row-major ordering.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如此类推。除了使用这些新公式外，使用列主序访问数组元素与使用行主序访问数组元素是相同的。
- en: '**7.2.4.3 Declaring Multidimensional Arrays**'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.2.4.3 声明多维数组**'
- en: An “*m* × *n*” array has `m` × `n` elements and requires `m` × `n` × Element_Size
    bytes of storage. To allocate storage for an array, you must reserve this amount
    of memory. With one-dimensional arrays, the syntax is very similar among the different
    HLLs. However, their syntax starts to diverge with multidimensional arrays.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“*m* × *n*”的数组有 `m` × `n` 个元素，并且需要 `m` × `n` × 元素大小字节的存储空间。为了分配数组存储空间，你必须预留这些内存。对于一维数组，不同高级语言的语法非常相似。然而，在多维数组的声明上，它们的语法开始有所不同。
- en: 'In C, C++, and Java, you use the following syntax to declare a multidimensional
    array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在C、C++和Java中，你使用以下语法来声明多维数组：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For example, here’s a three-dimensional array declaration in C/C++:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是一个C/C++中的三维数组声明：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example creates an array with 64 elements organized with a depth of 4 by
    2 rows by 8 columns. Assuming each `int` object requires 4 bytes, this array consumes
    256 bytes of storage.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建了一个包含64个元素的数组，组织成4个深度、2行和8列。假设每个 `int` 对象需要4个字节，那么这个数组占用256个字节的存储空间。
- en: 'Pascal’s syntax supports two equivalent ways of declaring multidimensional
    arrays:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal的语法支持两种等效的方式来声明多维数组：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'C# uses the following syntax to define multidimensional arrays:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: C#使用以下语法来定义多维数组：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Semantically, there are only two major differences among different languages.
    The first is whether the array declaration specifies the overall size of each
    array dimension or the upper and lower bounds. The second is whether the starting
    index is `0`, `1`, or a user-specified value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，不同语言之间只有两个主要区别。第一个是数组声明是否指定每个数组维度的整体大小，还是指定上下边界。第二个是起始索引是 `0`、`1` 还是用户指定的值。
- en: Swift doesn’t really support multidimensional arrays in the traditional sense.
    It allows you to create arrays of arrays (of arrays . . .), which can provide
    the same functionality as multidimensional arrays, but behave in subtly different
    ways. See “[Swift Array Implementation](#sec7_2_4_5)” on page [179](#sec7_2_4_5)
    for more details.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 在传统意义上并不真正支持多维数组。它允许你创建数组的数组（数组的数组……），这些数组可以提供与多维数组相同的功能，但表现方式略有不同。有关更多细节，请参阅第[179](#sec7_2_4_5)页的
    “[Swift 数组实现](#sec7_2_4_5)”。
- en: '**7.2.4.4 Accessing Elements of a Multidimensional Array**'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.2.4.4 访问多维数组的元素**'
- en: It’s so easy to access an element of a multidimensional array in an HLL that
    many programmers do so without considering the associated costs. In this section,
    to give you a clearer picture of those costs, we’ll look at some of the assembly
    language sequences you’ll need to access elements of a multidimensional array.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中，访问多维数组的元素是如此简单，以至于许多程序员在不考虑相关成本的情况下就这样做。在本节中，为了让你对这些成本有更清晰的了解，我们将查看一些需要访问多维数组元素时的汇编语言序列。
- en: 'Consider again the C/C++ declaration of the `ThreeDInts` array from the previous
    section:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑上一节中 C/C++ 的 `ThreeDInts` 数组声明：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In C/C++, if you wanted to set element `[i][j][k]` of this array to `n`, you’d
    probably use the following statement:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，如果你想将该数组的元素 `[i][j][k]` 设置为 `n`，你可能会使用以下语句：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This statement, however, hides a great deal of complexity. Recall the formula
    needed to access an element of a three-dimensional array:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个语句隐藏了很多复杂性。回想一下访问三维数组元素所需的公式：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `ThreeDInts` example does not avoid this calculation, it only hides it
    from you. The machine code that the C/C++ compiler generates is similar to the
    following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreeDInts` 示例并没有避免此计算，它只是将其隐藏了。C/C++ 编译器生成的机器码类似于以下内容：'
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Actually, `ThreeDInts` is special. The sizes of all the array dimensions are
    nice powers of 2\. This means that the CPU can use shifts instead of multiplication
    instructions to multiply EBX by 2 and by 4 in this example. Because shifts are
    often faster than multiplication, a decent C/C++ compiler will generate the following
    code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`ThreeDInts` 是特殊的。所有数组维度的大小都是很好的2的幂。这意味着CPU可以使用移位操作代替乘法指令，将EBX乘以2和4。在这个示例中，由于移位操作通常比乘法更快，一个不错的C/C++编译器会生成如下代码：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that a compiler can use this faster code only if an array dimension is
    a power of 2; this is why many programmers attempt to declare arrays with those
    dimensions. Of course, if you must declare extra elements in the array to achieve
    this goal, you may wind up wasting space (especially with higher-dimensional arrays)
    to achieve only a small increase in speed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，编译器只有在数组维度是 2 的幂时，才能使用更快的代码；这也是为什么许多程序员尝试声明具有这些维度的数组。当然，如果你必须在数组中声明额外的元素来实现这一目标，可能会浪费空间（尤其是在高维数组中），从而只获得微小的速度提升。
- en: For example, if you need a 10×10 array and you’re using row-major ordering,
    you could create a 10×16 array to allow the use of a shift (by 4) instruction
    rather than a multiply (by 10) instruction. When using column-major ordering,
    you’d probably want to declare a 16×10 array to achieve the same effect, since
    row-major calculation doesn’t use the size of the first dimension when calculating
    an offset into an array, and column-major calculation doesn’t use the size of
    the second dimension when calculating an offset. In either case, however, the
    array would wind up having 160 elements instead of 100 elements. Only you can
    decide if this extra space is worth the minor improvement in speed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要一个 10×10 的数组，并且使用行主序排列，你可以创建一个 10×16 的数组，以便使用移位（乘以 4）指令，而不是乘法（乘以 10）指令。当使用列主序排列时，你可能希望声明一个
    16×10 的数组来实现相同的效果，因为行主序计算在计算数组偏移量时不使用第一维的大小，而列主序计算则不使用第二维的大小。在任何情况下，数组最终都会有 160
    个元素，而不是 100 个元素。只有你能决定这种额外的空间是否值得为了略微提高的速度进行牺牲。
- en: '**7.2.4.5 Swift Array Implementation**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.2.4.5 Swift 数组实现**'
- en: 'Swift arrays are different from those found in many other languages. First
    of all, Swift arrays are an opaque type based on `struct` objects (rather than
    just a collection of elements in memory). Swift doesn’t guarantee that array elements
    appear in continuous memory locations. However, the language provides the following
    `ContiguousArray` type specification, which guarantees they’ll appear in contiguous
    memory locations (as in C/C++ and other languages):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 数组与许多其他语言中的数组不同。首先，Swift 数组是基于 `struct` 对象的封闭类型（而不仅仅是内存中的元素集合）。Swift 不保证数组元素出现在连续的内存位置。然而，语言提供了以下
    `ContiguousArray` 类型规范，它保证数组元素会出现在连续的内存位置（如 C/C++ 及其他语言中）：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So far, so good. With contiguous arrays, the storage of the actual array data
    matches other languages. However, when you start declaring multidimensional arrays,
    the similarity ends. As noted earlier, Swift doesn’t actually have multidimensional
    arrays; instead, it supports *arrays of arrays*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切正常。使用连续数组时，实际数组数据的存储方式与其他语言相匹配。然而，当你开始声明多维数组时，相似性就结束了。如前所述，Swift 实际上并没有多维数组；相反，它支持
    *数组的数组*。
- en: For most programming languages, where an array object is strictly the sequence
    of array elements in memory, an array of arrays and a multidimensional array are
    the same thing. However, Swift uses descriptor (`struct`-based) objects to specify
    an array. Like string descriptors, Swift arrays consist of a data structure containing
    various fields (like the current number of array elements and one or more pointers
    to the actual array data).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数编程语言，数组对象严格来说是内存中数组元素的顺序，数组的数组和多维数组是相同的。然而，Swift 使用描述符（基于 `struct`）对象来指定数组。像字符串描述符一样，Swift
    数组由包含多个字段的数据结构组成（如当前数组元素的数量和一个或多个指向实际数组数据的指针）。
- en: 'When you create an array of arrays, you’re actually creating an array of these
    descriptors, with each pointing at a subarray. Consider the following two (equivalent)
    Swift array-of-arrays declarations (`a1` and `a2`) and sample program:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个数组的数组时，实际上是在创建一个包含这些描述符的数组，每个描述符指向一个子数组。考虑以下两个（等效的）Swift 数组数组声明（`a1` 和
    `a2`）及示例程序：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running this program produces the following output:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该程序会产生以下输出：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For two-dimensional arrays you would expect this type of output. However, internally,
    `a1` and `a2` are one-dimensional arrays with two elements each. Those two elements
    are array descriptors that themselves point at arrays, each containing three elements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维数组，你会期待这种类型的输出。然而，实际上，`a1` 和 `a2` 是一维数组，每个数组有两个元素。这两个元素是数组描述符，它们本身指向包含三个元素的数组。
- en: It is unlikely that the six array elements associated with `a2` will appear
    in contiguous memory locations, even though `a2` is a `ContiguousArray` type.
    The two array descriptors held in `a2` may appear in contiguous memory locations,
    but that doesn’t necessarily carry over to the six data elements at which they
    collectively point.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `a2` 是一个 `ContiguousArray` 类型，但与 `a2` 相关的六个数组元素不太可能出现在连续的内存位置中。`a2` 中保存的两个数组描述符可能出现在连续的内存位置，但这并不一定会延续到它们共同指向的六个数据元素。
- en: 'Because Swift allocates arrays dynamically, the rows in a two-dimensional array
    could have differing element counts. Consider the following modification to the
    previous Swift program:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Swift 动态分配数组，二维数组中的行可能具有不同的元素数量。请考虑对之前的 Swift 程序进行以下修改：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Running this program produces the following output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序将产生以下输出：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The two rows in the `a2` array have differing sizes. This could be useful or
    a source of defects, depending on what you’re trying to accomplish.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`a2` 数组中的两行具有不同的大小。根据你要完成的任务，这可能是有用的，也可能是缺陷的来源。'
- en: One way to get standard multidimensional array storage in Swift is to declare
    a one-dimensional `ContiguousArray` with sufficient elements for all the elements
    of the multidimensional array. Then use the row-major (or column-major) functionality,
    without the element size operand, to compute the index into the array.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中获取标准的多维数组存储的一种方式是声明一个一维的 `ContiguousArray`，其元素数量足够存储多维数组的所有元素。然后使用行主序（或列主序）功能，在不需要元素大小操作数的情况下计算数组中的索引。
- en: '**7.3 Records/Structures**'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.3 记录/结构体**'
- en: Another major composite data structure is the Pascal *[record](gloss01.xhtml#gloss01_213)*
    or C/C++ *structure*. The Pascal terminology is probably better, as it avoids
    confusion with the term *data structure*, so we’ll generally use *record* here.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的复合数据结构是 Pascal 的 *[记录](gloss01.xhtml#gloss01_213)* 或 C/C++ 的 *结构体*。Pascal
    的术语可能更好，因为它避免了与 *数据结构* 这一术语的混淆，因此我们在这里一般使用 *记录*。
- en: An array is *homogeneous*, meaning that its elements are all of the same type.
    A record, on the other hand, is *heterogeneous*—its elements can have differing
    types. The purpose of a record is to let you encapsulate logically related values
    into a single object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 *同质* 的，意味着它的所有元素都是相同类型的。另一方面，记录是 *异质* 的——它的元素可以具有不同的类型。记录的目的是让你将逻辑相关的值封装到一个单一的对象中。
- en: Arrays let you select a particular element via an integer index. With records,
    you must select an element, known as a *[field](gloss01.xhtml#gloss01_96)*, by
    the field’s name. Each of the field names within the record must be unique; that
    is, you can’t use the same field name two or more times in the same record. However,
    all field names are local to their record, and you can reuse those names elsewhere
    in the program.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 数组让你可以通过整数索引选择特定元素。使用记录时，你必须通过字段的名称选择元素，这些元素被称为 *[字段](gloss01.xhtml#gloss01_96)*。记录中的每个字段名称必须是唯一的；也就是说，你不能在同一记录中多次使用相同的字段名称。然而，所有字段名称都是本地于它们的记录的，你可以在程序的其他地方重用这些名称。
- en: '***7.3.1 Records in Pascal/Delphi***'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.3.1 Pascal/Delphi 中的记录***'
- en: 'Here’s a typical record declaration for a `Student` data type in Pascal/Delphi:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Pascal/Delphi 中 `Student` 数据类型的典型记录声明：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Many Pascal compilers allocate all of the fields in contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name,^([3](footnotes.xhtml#fn7_3a))
    the next 2 bytes for the major code, the next 12 bytes for the Social Security
    number, and so on.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Pascal 编译器会将所有字段分配到连续的内存位置。这意味着 Pascal 会为姓名预留前 65 字节，^([3](footnotes.xhtml#fn7_3a))
    为专业代码预留接下来的 2 字节，为社会安全号码预留接下来的 12 字节，以此类推。
- en: '***7.3.2 Records in C/C++***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.3.2 C/C++ 中的记录***'
- en: 'Here’s the same declaration in C/C++:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同声明的 C/C++ 版本：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Because C++ structures are actually a specialized form of the class declaration,
    they behave differently from C structures and may include extra data in memory
    that is not present in the C variant. (This is why the memory storage for structures
    in C++ may be different; see “[Memory Storage of Records](#sec7_3_5)” on page
    [184](#sec7_3_5)). There are also differences in namespaces and other minor distinctions
    between C and C++ structures.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C++ 结构体实际上是类声明的一个专门形式，因此它们的行为与 C 结构体不同，并且可能包含在 C 变体中没有的额外数据（这就是 C++ 中结构体的内存存储可能不同的原因；详见第
    [184](#sec7_3_5) 页的 “[记录的内存存储](#sec7_3_5)”）。C 和 C++ 结构体之间还有命名空间等一些小区别。
- en: 'As it turns out, though, you can tell C++ to compile a true C `struct` definition
    using the `extern` `"C"` block as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以告诉 C++ 使用 `extern` `"C"` 块按如下方式编译一个真正的 C `struct` 定义：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**NOTE**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Java doesn’t support anything corresponding to the C `struct`—it supports
    only classes (see “[Classes](#sec7_5)” on page [192](#sec7_5)).*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java 不支持与 C `struct` 相对应的任何东西——它只支持类（参见第 [192](#sec7_5) 页的“[类](#sec7_5)”）。*'
- en: '***7.3.3 Records in HLA***'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.3.3 HLA 中的记录***'
- en: 'In HLA, you can also create structure types using the `record`/`endrecord`
    declaration. For example, you would encode the record from the previous sections
    as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HLA 中，你也可以使用 `record`/`endrecord` 声明来创建结构类型。例如，你可以如下编码前面章节中的记录：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, the HLA declaration is very similar to the Pascal declaration.
    To stay consistent with the Pascal declaration, this example uses character arrays
    rather than strings for the `Name` and `SSN` (Social Security number) fields.
    In a typical HLA record declaration, you’d probably use a `string` type for at
    least the `Name` field (keeping in mind that a string variable is a 4-byte pointer).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，HLA 声明与 Pascal 声明非常相似。为了与 Pascal 声明保持一致，这个例子使用字符数组而不是字符串来表示 `Name` 和 `SSN`（社会安全号码）字段。在典型的
    HLA 记录声明中，你可能会使用 `string` 类型来表示至少是 `Name` 字段（请记住，字符串变量是一个 4 字节的指针）。
- en: '***7.3.4 Records (Tuples) in Swift***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.3.4 Swift 中的记录（元组）***'
- en: Although Swift doesn’t support the concept of a record, you can simulate one
    using a Swift *[tuple](gloss01.xhtml#gloss01_247)*. While Swift does not store
    record (tuple) elements in memory in the same way as other programming languages
    (see “[Memory Storage of Records](#sec7_3_5)” on page [184](#sec7_3_5)), tuples
    are a useful construct if you want to create a composite/aggregate data type without
    the overhead of a class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Swift 不支持记录的概念，但你可以使用 Swift *[元组](gloss01.xhtml#gloss01_247)* 来模拟一个记录。虽然
    Swift 不像其他编程语言那样以相同方式存储记录（元组）元素（参见第 [184](#sec7_3_5) 页的“[记录的内存存储](#sec7_3_5)”），但是如果你想创建一个复合/聚合数据类型，而不想增加类的开销，元组是一个有用的构造。
- en: 'A Swift tuple is simply a list of values in the following form:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 元组只是以以下形式组织的值列表：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The types of the values within the tuple don’t need to be identical.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 元组中值的类型不需要完全相同。
- en: 'Swift typically uses tuples to return multiple values from functions. Consider
    the following short Swift code fragment:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 通常使用元组从函数返回多个值。考虑以下简短的 Swift 代码片段：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `returns3Ints()` function returns three values (`1`, `2`, and `3`). The
    following statement stores those three integer values into `r1`, `r2`, and `r3`,
    respectively:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`returns3Ints()` 函数返回三个值（`1`、`2` 和 `3`）。以下语句将这三个整数值分别存储到 `r1`、`r2` 和 `r3` 中：'
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can also assign tuples to a single variable and access “fields” of the
    tuple using integer indices as the field names:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将元组赋值给一个单一变量，并通过整数索引作为字段名称访问元组的“字段”：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Of course, using field names like `.0` results in very hard-to-maintain code.
    While you could create records out of tuples, referring to the fields by an integer
    index is rarely suitable in real-world programs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用像 `.0` 这样的字段名称会导致非常难以维护的代码。虽然你可以通过元组创建记录，但通过整数索引引用字段在实际程序中很少适用。
- en: 'Fortunately, Swift allows you to assign each tuple field a label, which you
    can then use instead of an integer index to refer to the field. Consider the following
    Swift code fragment:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Swift 允许你为每个元组字段分配一个标签，然后你可以使用该标签代替整数索引来引用字段。考虑以下 Swift 代码片段：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Using Swift tuples this way is the syntactical equivalent of using a Pascal
    or HLA record (or a C structure). Keep in mind, however, that the storage of the
    tuple in memory might not map to the same layout as a record or structure in these
    other languages. Like arrays in Swift, tuples are an opaque type, without a guaranteed
    definition for how Swift will store them in memory.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 Swift 元组在语法上等同于使用 Pascal 或 HLA 记录（或 C 结构）。然而，请记住，元组在内存中的存储方式可能与这些其他语言中的记录或结构的布局不一致。像
    Swift 中的数组一样，元组是一个不透明类型，没有保证定义 Swift 如何在内存中存储它们。
- en: '***7.3.5 Memory Storage of Records***'
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.3.5 记录的内存存储***'
- en: 'The following Pascal example demonstrates a typical `Student` variable declaration:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Pascal 示例演示了一个典型的 `Student` 变量声明：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Given the earlier declaration for the Pascal `Student` data type, this allocates
    81 bytes of storage laid out in memory as shown in [Figure 7-8](ch07.xhtml#ch07fig08).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面为 Pascal `Student` 数据类型的声明，这将分配 81 字节的存储，并按图 [7-8](ch07.xhtml#ch07fig08)
    所示的方式布局在内存中。
- en: '![image](../images/07fig08.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig08.jpg)'
- en: '*Figure 7-8: Student data structure storage in memory*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：学生数据结构在内存中的存储*'
- en: If the label `John` corresponds to the *base address* of this record, then the
    `Name` field is at offset `John+0`, the `Major` field is at offset `John+65`,
    the `SSN` field is at offset `John+67`, and so on.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签 `John` 对应于该记录的 *基地址*，那么 `Name` 字段位于偏移量 `John+0`，`Major` 字段位于偏移量 `John+65`，`SSN`
    字段位于偏移量 `John+67`，依此类推。
- en: 'Most programming languages let you refer to a record field by its name rather
    than by its numeric offset into the record. The typical syntax for field access
    uses the *dot operator* to select a field from a record variable. Given the variable
    `John` from the previous example, here’s how you could access various fields in
    this record:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言允许你通过字段名称而非数字偏移量来引用记录字段。访问字段的典型语法使用 *点运算符* 从记录变量中选择一个字段。假设变量 `John` 来自前面的示例，以下是你如何访问该记录中的不同字段：
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[Figure 7-8](ch07.xhtml#ch07fig08) suggests that all fields of a record appear
    in memory in the order of their declaration, and this is usually the case in practice.
    In theory, though, a compiler can freely place the fields anywhere in memory that
    it chooses. The first field usually appears at the lowest address in the record,
    the second field appears at the next highest address, the third field follows
    the second field in memory, and so on.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8](ch07.xhtml#ch07fig08) 表明，记录的所有字段在内存中按声明顺序出现，通常在实际应用中是这样的。不过从理论上讲，编译器可以自由地将字段放置在内存中的任何位置。第一个字段通常出现在记录的最低地址，第二个字段出现在下一个较高的地址，第三个字段紧跟第二个字段在内存中依次排列，依此类推。'
- en: '[Figure 7-8](ch07.xhtml#ch07fig08) also suggests that compilers pack the fields
    into adjacent memory locations with no gaps between them. While this is true for
    many languages, it’s certainly not the most common memory organization for a record.
    For performance reasons, most compilers actually align the fields of a record
    on appropriate memory boundaries. The exact details vary by language, compiler
    implementation, and CPU, but a typical compiler places fields at an offset within
    the record’s storage area that is “natural” for that particular field’s data type.
    On the 80x86, for example, compilers that follow the Intel ABI (application binary
    interface) allocate 1-byte objects at any offset within the record, words only
    at even offsets, and double-word or larger objects on double-word boundaries.
    Although not all 80x86 compilers support the Intel ABI, most do, which allows
    records to be shared among functions and procedures written in different languages
    on the 80x86\. Other CPU manufacturers provide their own ABI for their processors,
    and programs that adhere to an ABI can share binary data at runtime with other
    programs that adhere to the same ABI.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8](ch07.xhtml#ch07fig08) 还表明，编译器将字段打包到相邻的内存位置，没有它们之间的间隙。虽然许多语言都如此，但这并不是记录最常见的内存组织方式。出于性能考虑，大多数编译器实际上会将记录的字段按适当的内存边界对齐。具体的细节因语言、编译器实现和
    CPU 而异，但典型的编译器会将字段放置在记录存储区内的偏移位置，这个位置对该字段的数据类型是“自然的”。以 80x86 为例，遵循 Intel ABI（应用二进制接口）的编译器将
    1 字节对象分配到记录中的任何偏移量，单字只分配到偶数偏移量，双字或更大的对象则在双字边界上分配。尽管并非所有 80x86 编译器都支持 Intel ABI，但大多数支持，这使得记录能够在不同语言编写的函数和过程之间共享。在
    80x86 上，其他 CPU 厂商为其处理器提供了自己的 ABI，遵循 ABI 的程序可以在运行时与其他遵循相同 ABI 的程序共享二进制数据。'
- en: In addition to aligning the fields of a record at reasonable offset boundaries,
    most compilers also ensure that the length of the entire record is a multiple
    of 2, 4, 8, or even 16 bytes. As mentioned earlier in the chapter, they accomplish
    this by appending padding bytes to fill out the record’s size. This ensures that
    the record’s length is an even multiple of the size of the largest scalar (noncomposite
    data type) object in the record or the CPU’s optimal alignment size, whichever
    is smaller. For example, if a record has fields whose lengths are 1, 2, 4, 8,
    and 10 bytes, then an 80x86 compiler generally will pad the record’s length so
    that it is an even multiple of 8\. This allows you to create an array of records
    and be assured that each record in the array starts at a reasonable address in
    memory.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在合理的偏移边界对齐记录的字段外，大多数编译器还确保整个记录的长度是2、4、8甚至16字节的倍数。如本章前面提到的，它们通过附加填充字节来填充记录的大小。这样可以确保记录的长度是记录中最大标量（非复合数据类型）对象的大小或CPU的最佳对齐大小的最小倍数。例如，如果一个记录的字段长度分别是1、2、4、8和10字节，那么一个80x86编译器通常会为记录的长度添加填充，使其成为8的倍数。这可以让您创建一个记录数组，并确保数组中的每个记录都从内存中的合理地址开始。
- en: Although some CPUs don’t allow access to objects in memory at misaligned addresses,
    many compilers allow you to disable the automatic alignment of fields within a
    record. Generally, the compiler has an option you can use to globally disable
    this feature. Many compilers also provide a `pragma` or a `packed` keyword that
    lets you turn off field alignment on a record-by-record basis. Disabling the automatic
    field alignment feature may save some memory by eliminating the padding bytes
    between the fields and at the end of the record (again, provided that field misalignment
    is acceptable on your CPU). However, the program may run a little bit slower when
    it needs to access misaligned values in memory.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管某些CPU不允许访问内存中不对齐地址的对象，但许多编译器允许您禁用记录中字段的自动对齐。通常，编译器会提供一个选项，允许您全局禁用此功能。许多编译器还提供一个`pragma`或`packed`关键字，允许您逐个记录地禁用字段对齐。禁用自动字段对齐功能可以通过消除字段之间以及记录末尾的填充字节来节省一些内存（前提是您的CPU能够接受字段不对齐）。然而，当程序需要访问内存中不对齐的值时，它的运行速度可能会稍微变慢。
- en: 'One reason to use a packed record is to gain manual control over the alignment
    of the record’s fields. For example, suppose you have a couple of functions written
    in two different languages, and both functions need to access some data in a record.
    Suppose also that the two compilers for these functions do not use the same field
    alignment algorithm. A record declaration like the following (in Pascal) may not
    be compatible with the way both functions access the record data:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包记录的一个原因是可以手动控制记录字段的对齐方式。例如，假设您有两个不同语言编写的函数，这两个函数都需要访问记录中的某些数据。假设这两个函数的编译器使用的字段对齐算法不同。像下面这样的记录声明（在Pascal中）可能与这两个函数访问记录数据的方式不兼容：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The problem here is that the first compiler could use the offsets 0, 2, and
    4 for the `bField`, `wField`, and `dField` fields, respectively, while the second
    compiler might use offsets 0, 4, and 8.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，第一个编译器可能会分别为`bField`、`wField`和`dField`字段使用偏移量0、2和4，而第二个编译器可能会使用偏移量0、4和8。
- en: 'Suppose, however, that the first compiler allows you to specify the `packed`
    keyword before the `record` keyword, causing the compiler to store each field
    immediately following the previous one. Although using the `packed` keyword doesn’t
    make the records compatible with both functions, it does allow you to manually
    add padding fields to the record declaration, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设第一个编译器允许您在`record`关键字前指定`packed`关键字，这会导致编译器将每个字段紧跟着前一个字段存储。虽然使用`packed`关键字并不能使记录与两个函数兼容，但它确实允许您手动向记录声明中添加填充字段，如下所示：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Adding padding manually can make code maintenance a real chore. However, if
    incompatible compilers need to share data, it’s a trick worth knowing. For the
    exact details on packed records, consult your language’s reference manual.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 手动添加填充可能会使代码维护变得非常麻烦。然而，如果不兼容的编译器需要共享数据，这是一个值得了解的技巧。关于打包记录的具体细节，请查阅您编程语言的参考手册。
- en: '**7.4 Discriminant Unions**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.4 判别联合**'
- en: A discriminant union (or just *[union](gloss01.xhtml#gloss01_252)*) is very
    similar to a record. Like records, unions have fields that you access using dot
    notation. In many languages, the only syntactical difference between records and
    unions is the use of the keyword `union` rather than `record`. Semantically, however,
    there’s a big difference between them. In a record, each field has its own offset
    from the base address of the record, and the fields do not overlap. In a union,
    however, all fields have the same offset, 0, and all the fields of the union overlap.
    As a result, the size of a record is the sum of the sizes of all the fields (plus,
    possibly, some padding bytes), whereas a union’s size is the size of its largest
    field (plus, possibly, some padding bytes at the end).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 判别联合（或简称 *[联合](gloss01.xhtml#gloss01_252)*）与记录非常相似。像记录一样，联合也有字段，可以使用点号表示法进行访问。在许多语言中，记录和联合之间唯一的语法区别是使用
    `union` 关键字而不是 `record`。然而，从语义上讲，它们之间有很大的区别。在记录中，每个字段都有自己的偏移量，从记录的基地址开始，字段不重叠。然而，在联合中，所有字段的偏移量都是
    0，所有字段都重叠。因此，记录的大小是所有字段大小的总和（可能还有一些填充字节），而联合的大小是其最大字段的大小（可能还有一些填充字节）。
- en: Because the fields of a union overlap, you might think it’s of little use in
    a real-world program. After all, if the fields all overlap, then changing the
    value of one field changes the values of all the others as well. This means that
    union fields are *mutually exclusive*—that is, you can use only one at a time.
    While it’s true that this makes unions less generally applicable than records,
    they still have many uses.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于联合的字段重叠，你可能会认为它在实际程序中几乎没什么用。毕竟，如果所有字段都重叠，那么更改一个字段的值会改变所有其他字段的值。这意味着联合字段是 *互斥的*——也就是说，你一次只能使用一个字段。虽然这确实使得联合比记录更不通用，但它们仍然有很多用途。
- en: '***7.4.1 Unions in C/C++***'
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.4.1 C/C++ 中的联合***'
- en: 'Here’s an example of a union declaration in C/C++:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 C/C++ 中联合声明的示例：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Assuming the C/C++ compiler allocates 4 bytes for unsigned integers, the size
    of a `unionType` object will be 4 bytes (because all three fields are 4-byte objects).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 C/C++ 编译器为无符号整数分配 4 个字节，那么 `unionType` 对象的大小将为 4 个字节（因为所有三个字段都是 4 字节的对象）。
- en: '**NOTE**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Unfortunately, Java doesn’t support discriminant unions due to the safety
    issues involved. You can implement some features of discriminant unions using
    subclassing, but Java does not support explicitly sharing memory locations among
    different variables.*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*不幸的是，由于涉及到安全问题，Java 不支持判别联合。你可以通过子类化实现判别联合的一些功能，但 Java 不支持在不同变量之间显式共享内存位置。*'
- en: '***7.4.2 Unions in Pascal/Delphi***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.4.2 Pascal/Delphi 中的联合***'
- en: 'Pascal/Delphi use *case-variant records* to create a discriminant union. The
    syntax for a case-variant record is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal/Delphi 使用 *变体记录* 来创建判别联合。变体记录的语法如下：
- en: '[PRE73]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, tag is either a type identifier (such as `boolean`, `char`,
    or some user-defined type) or a field declaration of the form identifier`:`type.
    If the tag item takes this latter form, then identifier becomes another field
    of the record, not a member of the *variant section* (those declarations following
    the `case`), and has the specified type. In addition, the Pascal compiler could
    generate code that raises an exception whenever the application attempts to access
    any of the variant fields except the one specified by the value of the tag field.
    In practice, though, almost no Pascal compilers do this check. Still, keep in
    mind that the Pascal language standard suggests that compilers should do it, so
    some compilers out there might.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，tag 是一个类型标识符（例如 `boolean`、`char` 或某个用户定义的类型），或者是一个字段声明，形式为 identifier`:`type。如果标签项采用后一种形式，那么
    identifier 就成了记录的另一个字段，而不是 *变体部分*（那些跟在 `case` 后面的声明），并具有指定的类型。此外，Pascal 编译器可以生成代码，当应用程序尝试访问任何变体字段（除了由标签字段的值指定的字段）时，会引发异常。然而，实际上几乎没有
    Pascal 编译器做这个检查。尽管如此，记住 Pascal 语言标准建议编译器应该这样做，因此一些编译器可能会这样做。
- en: 'Here’s an example of two different case-variant record declarations in Pascal:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Pascal 中两个不同的变体记录声明示例：
- en: '[PRE74]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As you can see in the `hasTagRecord` union, a Pascal case-variant record does
    not require any normal record fields. This is true even if you do not have a tag
    field.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `hasTagRecord` 联合中看到的，Pascal 的变体记录不需要任何普通的记录字段。即使你没有标签字段，这也是真的。
- en: '***7.4.3 Unions in Swift***'
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.4.3 Swift 中的联合***'
- en: 'Swift does not directly support the concept of a discriminant union. Unlike
    Java, however, Swift does provide an alternative—equivalent to Pascal’s case-variant
    record—that supports the safe use of unions: enumerated data types.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 不直接支持判别联合体的概念。然而，Swift 提供了一个替代方案——相当于 Pascal 的变体记录——支持安全使用联合体：枚举数据类型。
- en: 'Consider the following Swift enumeration definition:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下 Swift 枚举定义：
- en: '[PRE75]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'So far, this is just an enumerated data type that has nothing to do with unions.
    However, we can attach a value (actually, a tuple of values) to each case in an
    enumerated data type. Consider the following Swift program, which demonstrates
    `enum` *[associated values](gloss01.xhtml#gloss01_17)*:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这只是一个枚举数据类型，与联合体无关。不过，我们可以为枚举数据类型的每个枚举项附加一个值（实际上是一个元组值）。请考虑以下 Swift 程序，它演示了
    `enum` *[关联值](gloss01.xhtml#gloss01_17)*：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This program produces the following output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序生成以下输出：
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: A variable of type `EnumType` takes on one of the enumeration values `isInt`,
    `isReal`, or `isString` (these are the three constants of type `EnumType`). In
    addition to whatever internal encoding Swift chooses for these three constants
    (probably `0`, `1`, and `2`, though their actual values are irrelevant), Swift
    associates an integer value with `isInt`, a 64-bit double-precision floating-point
    value with `isReal`, and a string value with `isString`. The three `let` statements
    assign the appropriate values to `EnumType` variables; as you can see, to assign
    the value you include it in parentheses after the constant’s name. You can then
    extract the value using a `switch` statement.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnumType` 类型的变量会获取枚举值之一：`isInt`、`isReal` 或 `isString`（这三者是 `EnumType` 类型的常量）。除了
    Swift 为这三种常量选择的内部编码（可能是 `0`、`1` 和 `2`，尽管它们的实际值并不重要）外，Swift 会将一个整数值与 `isInt` 关联，将一个
    64 位双精度浮动点数值与 `isReal` 关联，并将一个字符串值与 `isString` 关联。这三个 `let` 语句将适当的值赋给 `EnumType`
    变量；如你所见，为了赋值，你需要将其放在常量名称后的括号中。然后，你可以使用 `switch` 语句提取该值。'
- en: '***7.4.4 Unions in HLA***'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.4.4 HLA 中的联合体***'
- en: 'HLA supports unions as well; here’s a typical union declaration:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 同样支持联合体；以下是一个典型的联合体声明：
- en: '[PRE78]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***7.4.5 Memory Storage of Unions***'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.4.5 联合体的内存存储***'
- en: 'As noted previously, the big difference between a union and a record is the
    fact that records allocate storage for each field at different offsets, whereas
    unions overlay all of the fields at the same offset in memory. For example, consider
    the following HLA record and union declarations:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，联合体与记录体之间的最大区别在于，记录体为每个字段分配不同偏移量的存储，而联合体则将所有字段重叠在内存中的同一偏移量。例如，考虑以下 HLA
    记录体和联合体声明：
- en: '[PRE79]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If you declare a variable, `n`, of type `numericRec`, you access the fields
    as `n.i`, `n.u`, and `n.r`, exactly as though you had declared the `n` variable
    to be type `numericUnion`. However, the size of a `numericRec` object is 16 bytes,
    because the record contains two double-word fields and a quad-word (`real64`)
    field. The size of a `numericUnion` variable, though, is 8 bytes. [Figure 7-9](ch07.xhtml#ch07fig09)
    shows the memory arrangement of the `i`, `u`, and `r` fields in both the record
    and union.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个变量 `n`，类型为 `numericRec`，你可以像访问 `numericUnion` 类型的变量一样，通过 `n.i`、`n.u`
    和 `n.r` 访问各字段。然而，`numericRec` 对象的大小是 16 字节，因为该记录包含两个双字字段和一个四字（`real64`）字段。相比之下，`numericUnion`
    变量的大小为 8 字节。[图 7-9](ch07.xhtml#ch07fig09) 显示了记录和联合体中 `i`、`u` 和 `r` 字段的内存布局。
- en: '![image](../images/07fig09.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig09.jpg)'
- en: '*Figure 7-9: Layout of a union versus a record variable*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：联合体与记录变量的布局*'
- en: Note that Swift `enum` types are opaque. They may not store the associated values
    from each enumeration case in the same memory address—and even if they currently
    do, there’s no guarantee they will in future versions of Swift.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Swift 的 `enum` 类型是不可见的。它们可能不会将每个枚举项的关联值存储在相同的内存地址中——即使它们目前存储在相同的内存位置，未来版本的
    Swift 也不能保证它们会保持如此。
- en: '***7.4.6 Other Uses of Unions***'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.4.6 联合体的其他用途***'
- en: 'In addition to conserving memory, another common reason why programmers use
    unions is to create aliases in their code. An *alias* is a second name for some
    memory object. Although aliases are often a source of confusion in a program and
    should be used sparingly, sometimes it’s convenient to use them. For example,
    in some section of your program you might need to constantly use type coercion
    to refer to a particular object. To avoid this, you could use a union variable
    with each field representing one of the different types you want to use for the
    object. Consider the following HLA code fragment:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节省内存，程序员使用联合体的另一个常见原因是为了在代码中创建别名。*别名*是某个内存对象的第二个名称。尽管别名往往会导致程序中的混淆，因此应该谨慎使用，但有时使用它们会更加方便。例如，在程序的某些部分，你可能需要不断地使用类型强制转换来引用特定对象。为了避免这种情况，你可以使用一个联合体变量，每个字段代表你想要为对象使用的不同类型。考虑以下HLA代码片段：
- en: '[PRE80]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'With a declaration like this, you can manipulate an `uns32` object by accessing
    `v.u`. If, at some point, you need to treat the LO byte of this `uns32` variable
    as a character, you can do so by simply accessing the `v.c` variable as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的声明，你可以通过访问`v.u`来操作`uns32`对象。如果在某些时候，你需要将这个`uns32`变量的LO字节当作字符来处理，只需按照以下方式访问`v.c`变量即可：
- en: '[PRE81]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Another common practice is to use unions to disassemble a larger object into
    its constituent bytes. Consider the following C/C++ code fragment:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的做法是使用联合体将一个较大的对象拆解成其组成的字节。考虑以下C/C++代码片段：
- en: '[PRE82]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Although composing and decomposing data types this way is a useful trick to
    employ every now and then, keep in mind that this code isn’t portable. The HO
    and LO bytes of a multibyte object appear at different addresses on big-endian
    versus little-endian machines. As a result, this code fragment works fine on little-endian
    machines, but fails to display the correct bytes on big-endian CPUs. Any time
    you use unions to decompose larger objects, you should be aware of this limitation.
    Still, this trick is usually much more efficient than using shift lefts, shift
    rights, and AND operations, so you’ll see it used quite a bit.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管以这种方式组合和拆解数据类型是一个偶尔使用的有用技巧，但请记住，这段代码不可移植。在大端和小端机器上，多字节对象的高字节（HO）和低字节（LO）出现在不同的地址。因此，这段代码在小端机器上运行正常，但在大端CPU上无法显示正确的字节。每当你使用联合体来拆解更大的对象时，应该意识到这一限制。尽管如此，这种技巧通常比使用左移、右移和与操作要高效得多，因此你会看到它被广泛使用。
- en: '**NOTE**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Swift’s type safety system does not allow you to access a collection of bits
    as different types using discriminant unions. If you really want to convert one
    type to another by raw bit assignment, you can use the Swift `unsafeBitCast()`
    function. See the Swift standard library documentation for more details.*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*Swift的类型安全系统不允许你使用判别联合体将比特集合作为不同类型访问。如果你真的想通过原始位赋值将一种类型转换为另一种类型，可以使用Swift的`unsafeBitCast()`函数。详情请参阅Swift标准库文档。*'
- en: '**7.5 Classes**'
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.5 类**'
- en: At first glance, classes in a programming language like C++, Object Pascal,
    or Swift look like they are simple extensions to records (or structures) and should
    have a similar memory organization. Indeed, most programming languages do organize
    class data fields in memory very similarly to records and structures. The compiler
    lays out the fields in sequential memory locations as it encounters them in a
    class declaration. However, classes have several additional features that you
    won’t find in pure record and structures; specifically, member functions (functions
    declared inside a class), inheritance, and polymorphism have a big impact on how
    compilers implement class objects in memory.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，像C++、Object Pascal或Swift这样的编程语言中的类看起来像是记录（或结构）的简单扩展，应该具有类似的内存组织。事实上，大多数编程语言确实非常类似地组织类的数据字段到内存中，就像记录和结构一样。编译器按照在类声明中遇到字段的顺序，将字段布局到连续的内存位置。然而，类有几个额外的特性，是纯粹的记录和结构中没有的；具体来说，成员函数（在类中声明的函数）、继承和多态对编译器如何在内存中实现类对象有很大的影响。
- en: 'Consider the following HLA structure and HLA class declarations:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下HLA结构和HLA类声明：
- en: '[PRE83]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As with records, HLA allocates storage for all `var` fields in a class sequentially.
    Indeed, if a class consists only of `var` data fields, its memory representation
    is nearly identical to that of a corresponding record declaration (see [Figures
    7-10](ch07.xhtml#ch07fig10) and [7-11](ch07.xhtml#ch07fig11)).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录类型一样，HLA为类中的所有`var`字段按顺序分配存储空间。实际上，如果一个类仅由`var`数据字段组成，它的内存表示几乎与相应的记录声明完全相同（参见[图7-10](ch07.xhtml#ch07fig10)和[图7-11](ch07.xhtml#ch07fig11)）。
- en: '![image](../images/07fig10.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig10.jpg)'
- en: '*Figure 7-10: Layout of the HLA `student` record*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-10：HLA `student` 记录的布局*'
- en: '![image](../images/07fig11.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig11.jpg)'
- en: '*Figure 7-11: Layout of the HLA `student2` class*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-11：HLA `student2` 类的布局*'
- en: As you can see from these figures, the difference is the presence of the VMT
    pointer field at the beginning of the `student2` class data. *[VMT](gloss01.xhtml#gloss01_259)*,
    which stands for *[virtual method table](gloss01.xhtml#gloss01_257)*, is a pointer
    to an array of pointers to the methods (functions) associated with the class.^([4](footnotes.xhtml#fn7_4a))
    In the `student2` example, the VMT field would point at a table containing two
    32-bit pointers—one pointing at the `setName()` method and one pointing at the
    `getName()` method. When a program calls one of the virtual methods `setName()`
    or `getName()` in this class, it does not call them directly at their address
    in memory. Instead, it fetches the address of the VMT from the object in memory,
    uses that pointer to fetch the specific method address (`setName()` will likely
    be at the first index into the VMT and `getName()` at the second), and then use
    the fetched address to call the method indirectly.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些图中可以看出，区别在于`student2`类数据的开始处存在VMT指针字段。*VMT*，即*虚拟方法表*，是指向与类相关联的函数（方法）指针数组的指针。^([4](footnotes.xhtml#fn7_4a))
    在`student2`示例中，VMT字段指向一个包含两个32位指针的表——一个指向`setName()`方法，一个指向`getName()`方法。当程序调用此类中的虚拟方法`setName()`或`getName()`时，它不会直接通过它们在内存中的地址调用这些方法。相反，它会从对象中获取VMT的地址，利用该指针获取具体方法的地址（`setName()`可能位于VMT的第一个索引，`getName()`位于第二个索引），然后使用获取到的地址间接调用方法。
- en: '***7.5.1 Inheritance***'
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.5.1 继承***'
- en: 'Obtaining the method address from the VMT is a lot of work. Why would the compiled
    code do this rather than calling the method directly? The reason is because of
    a pair of magical features that classes and objects support: inheritance and polymorphism.
    Consider the following HLA class declaration:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从VMT中获取方法地址是一项繁琐的工作。那么，为什么编译后的代码要这样做，而不是直接调用方法呢？原因在于类和对象支持的一对神奇特性：继承和多态。考虑以下HLA类声明：
- en: '[PRE84]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `student3` class inherits all the data fields and methods from the `student2`
    class (as specified by the `inherits` clause in the class declaration) and then
    defines a new data field, `extraTime`, that allots extra time, in minutes, for
    the student during examinations. The `student3` declaration also defines a new
    method, `setName()`, that replaces the original `setName()` method in the `student2`
    class (it also defines an overridden `create` procedure, but we’ll ignore this
    for now). The memory layout for a `student3` object appears in [Figure 7-12](ch07.xhtml#ch07fig12).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`student3`类继承了`student2`类的所有数据字段和方法（如类声明中的`inherits`子句所指定），然后定义了一个新的数据字段`extraTime`，它为学生在考试期间分配额外的时间，单位为分钟。`student3`的声明还定义了一个新的方法`setName()`，它替代了`student2`类中原来的`setName()`方法（它还定义了一个重写的`create`过程，但我们现在暂时忽略这一点）。`student3`对象的内存布局见[图7-12](ch07.xhtml#ch07fig12)。'
- en: '![image](../images/07fig12.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig12.jpg)'
- en: '*Figure 7-12: Layout of the HLA `student3` class*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-12：HLA `student3` 类的布局*'
- en: In memory, the difference between the `student2` and `student3` objects is the
    extra 2 bytes at the end of the `student3` data structure and the value held by
    the VMT field. For `student2` objects the VMT field points at the VMT for the
    `student2` class (there is only one actual `student2` VMT in memory, and all `student2`
    objects contain a pointer to it). If we have a pair of `student2` objects named
    `John` and `Joan`, their VMT fields will both contain the address of the same
    VMT in memory, which has the information shown in [Table 7-3](ch07.xhtml#ch07tab03).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，`student2` 和 `student3` 对象的区别在于 `student3` 数据结构末尾的额外 2 个字节以及 VMT 字段所保存的值。对于
    `student2` 对象，VMT 字段指向 `student2` 类的 VMT（内存中只有一个实际的 `student2` VMT，所有 `student2`
    对象都包含指向它的指针）。如果我们有一对名为 `John` 和 `Joan` 的 `student2` 对象，它们的 VMT 字段将都包含指向同一个内存中
    VMT 的地址，这个地址包含了 [表 7-3](ch07.xhtml#ch07tab03) 中显示的信息。
- en: '**Table 7-3:** VMT Entries for `student2` VMT'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-3:** `student2` VMT 的条目'
- en: '| **Offset^([5](footnotes.xhtml#fn7_5a))** | **Entry** |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量^([5](footnotes.xhtml#fn7_5a))** | **条目** |'
- en: '| 0 (bytes) | Pointer to the (`student2`) `setName()` method |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 0（字节） | 指向 (`student2`) `setName()` 方法的指针 |'
- en: '| 4 (bytes) | Pointer to the `getName()` method |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 4（字节） | 指向 `getName()` 方法的指针 |'
- en: Now consider the case where we have a `student3` object in memory (let’s name
    it `Jenny`). The memory layout for `Jenny` is similar to that of `John` and `Joan`
    (see [Figures 7-11](ch07.xhtml#ch07fig11) and [7-12](ch07.xhtml#ch07fig12)). However,
    whereas the VMT fields in `John` and `Joan` both contain the same value (a pointer
    to the `student2` VMT), the VMT field for the `Jenny` object will point at the
    `student3` VMT (see [Table 7-4](ch07.xhtml#ch07tab04)).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑我们在内存中有一个 `student3` 对象（我们称它为 `Jenny`）。`Jenny` 的内存布局与 `John` 和 `Joan` 类似（参见
    [图 7-11](ch07.xhtml#ch07fig11) 和 [7-12](ch07.xhtml#ch07fig12)）。然而，尽管 `John` 和
    `Joan` 中的 VMT 字段都包含相同的值（指向 `student2` VMT 的指针），但 `Jenny` 对象的 VMT 字段将指向 `student3`
    VMT（参见 [表 7-4](ch07.xhtml#ch07tab04)）。
- en: '**Table 7-4:** VMT Entries for `student3` VMT'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-4:** `student3` VMT 的条目'
- en: '| **Offset** | **Entry** |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **条目** |'
- en: '| 0 (bytes) | Pointer to the (`student3`) `setName()` method |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 0（字节） | 指向 (`student3`) `setName()` 方法的指针 |'
- en: '| 4 (bytes) | Pointer to the `getName()` method |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 4（字节） | 指向 `getName()` 方法的指针 |'
- en: 'Although the `student3` VMT looks almost identical to the `student2` VMT, there
    is one critical difference: the first entry in [Table 7-3](ch07.xhtml#ch07tab03)
    points at the `student2` `setName()` method, whereas the first entry in [Table
    7-4](ch07.xhtml#ch07tab04) points at the `student3` `setName()` method.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `student3` VMT 看起来与 `student2` VMT 几乎相同，但有一个关键的区别：在 [表 7-3](ch07.xhtml#ch07tab03)
    中的第一个条目指向 `student2` 的 `setName()` 方法，而 [表 7-4](ch07.xhtml#ch07tab04) 中的第一个条目指向
    `student3` 的 `setName()` 方法。
- en: 'Adding fields inherited from a *[base class](gloss01.xhtml#gloss01_23)* to
    another class must be done carefully. Remember, an important attribute of a class
    that inherits fields from a base class is that you can use a pointer to the base
    class to access its fields, even if the pointer contains the address of some other
    class (that inherits the fields from the base class). Consider the following classes:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 将从 *[基类](gloss01.xhtml#gloss01_23)* 继承的字段添加到另一个类中时，必须小心操作。记住，一个从基类继承字段的类的一个重要特征是，你可以使用指向基类的指针来访问其字段，即使该指针包含的是指向其他类的地址（该类继承了基类的字段）。考虑以下类：
- en: '[PRE85]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Because both `tChildClassA` and `tChildClassB` inherit the fields of `tBaseClass`,
    these two child classes include the `i`, `j`, and `r` fields as well as their
    own specific fields.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `tChildClassA` 和 `tChildClassB` 都继承了 `tBaseClass` 的字段，这两个子类包含了 `i`、`j` 和
    `r` 字段以及它们各自特有的字段。
- en: For inheritance to work properly, the `i`, `j`, and `r` fields must appear at
    the same offsets in all child classes as they do in `tBaseClass`. This way, an
    instruction of the form `mov((type tBaseClass [ebx]).i, eax);` will correctly
    access the `i` field even if EBX points at an object of type `tChildClassA` or
    `tChildClassB`. [Figure 7-13](ch07.xhtml#ch07fig13) shows the layout of the child
    and base classes.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保继承正常工作，`i`、`j` 和 `r` 字段在所有子类中的偏移量必须与在 `tBaseClass` 中相同。这样，即使 EBX 指向的是 `tChildClassA`
    或 `tChildClassB` 类型的对象，像 `mov((type tBaseClass [ebx]).i, eax);` 这样的指令也能正确访问 `i`
    字段。[图 7-13](ch07.xhtml#ch07fig13) 显示了子类和基类的布局。
- en: Note that the new fields in the two child classes bear no relation to one another,
    even if they have the same name (for example, the `c` fields in the two child
    classes do not lie at the same offset). Although the two child classes share the
    fields they inherit from their common base class, any new fields they add are
    unique and separate. Two fields in different classes share the same offset only
    by coincidence if those fields are not inherited from a common base class.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个子类中的新字段相互之间没有任何关联，即使它们的名称相同（例如，两个子类中的`c`字段并不位于相同的偏移量）。尽管两个子类共享它们从公共基类继承的字段，但它们添加的任何新字段都是唯一且独立的。如果两个类中的字段共享相同的偏移量，那只是巧合，前提是这些字段并未从公共基类继承。
- en: All classes (even those that aren’t related to one another) place the pointer
    to the VMT at the same offset within the object (typically offset 0). There is
    a single VMT associated with each class in a program; even when classes inherit
    fields from some base class, their VMT (generally) differs from the base class’s
    VMT. [Figure 7-14](ch07.xhtml#ch07fig14) shows how objects of type `tBaseClass`,
    `tChildClassA`, and `tChildClassB` point at their specific VMTs.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类（即使它们彼此之间没有关系）都会在对象的相同偏移量处放置指向VMT的指针（通常是偏移量0）。每个程序中的类都有一个唯一的VMT；即使类从某个基类继承字段，它们的VMT（通常）也会与基类的VMT不同。[图7-14](ch07.xhtml#ch07fig14)展示了`
    tBaseClass`、`tChildClassA`和` tChildClassB`类型的对象如何指向它们各自的VMT。
- en: '![image](../images/07fig13.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig13.jpg)'
- en: '*Figure 7-13: Layout of base and child classes in memory*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-13：内存中基类和子类的布局*'
- en: '![image](../images/07fig14.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig14.jpg)'
- en: '*Figure 7-14: VMT references from objects*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-14：对象中的VMT引用*'
- en: 'Whenever a child class inherits fields from some base class, the child class’s
    VMT also inherits entries from the base class’s VMT. For example, the VMT for
    the class `tBaseClass` contains only a single entry—a pointer to the method `tBaseClass.mBase()`.
    The VMT for the class `tChildClassA` contains two entries: pointers to `tBaseClass.mBase()`
    and `tChildClassA.mA()`. Because `tChildClassB` doesn’t define any new methods
    or iterators, its VMT contains only a single entry: a pointer to the `tBaseClass.mBase()`
    method. Note that `tChildClassB`’s VMT is identical to `tBaseclass`’s table. Nevertheless,
    HLA produces two distinct VMTs. [Figure 7-15](ch07.xhtml#ch07fig15) shows this
    relationship.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 每当子类从某个基类继承字段时，子类的虚拟方法表（VMT）也会继承基类的虚拟方法表中的条目。例如，`tBaseClass`类的VMT只包含一个条目——指向方法`tBaseClass.mBase()`的指针。`tChildClassA`类的VMT包含两个条目：指向`tBaseClass.mBase()`和`tChildClassA.mA()`的方法指针。由于`tChildClassB`没有定义任何新的方法或迭代器，它的VMT只包含一个条目：指向`tBaseClass.mBase()`方法的指针。请注意，`tChildClassB`的VMT与`tBaseClass`的VMT完全相同。尽管如此，HLA仍然生成了两个不同的VMT。[图7-15](ch07.xhtml#ch07fig15)展示了这种关系。
- en: '![image](../images/07fig15.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig15.jpg)'
- en: '*Figure 7-15: Layout of base and child classes in memory*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-15：内存中基类和子类的布局*'
- en: '***7.5.2 Class Constructors***'
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.5.2 类构造函数***'
- en: Before you can actually call any methods in a VMT, you have to make sure that
    the table is actually present in memory (holding the addresses of the methods
    defined in a class), and you also have to initialize the VMT pointer field in
    every class you create. If you’re using an HLL (such as C++, C#, Java, or Swift),
    the compiler will automatically generate the VMTs for you when you compile the
    class definitions. As for initializing the VMT pointer field in the object itself,
    that’s usually handled by the default constructor (object initialization function)
    for each class. All this work is hidden from an HLL programmer. That’s why these
    class examples are using HLA—in assembly language (even a high-level assembly
    language), very little is hidden from you. With HLA examples, then, you get to
    see exactly how objects work and the cost of using them.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在你实际调用VMT中的任何方法之前，必须确保该表格已经存在于内存中（存储类中定义的方法地址），你还必须初始化你创建的每个类中的VMT指针字段。如果你使用的是高级语言（如C++、C#、Java或Swift），编译器在你编译类定义时会自动为你生成VMT。至于初始化对象本身中的VMT指针字段，通常由每个类的默认构造函数（对象初始化函数）来处理。所有这些工作对于高级语言程序员来说都是隐藏的。这就是为什么这些类示例使用HLA的原因——在汇编语言（即使是高级汇编语言）中，很少有东西是隐藏的。因此，在HLA示例中，你可以清楚地看到对象如何工作，以及使用它们的代价。
- en: 'To begin with, HLA does not automatically create the VMTs for you. You must
    explicitly declare them in your code for each class you define. For the `student2`
    and `student3` examples, you can declare them as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，HLA不会自动为你创建VMT。你必须在代码中显式声明每个你定义的类的VMT。例如，对于`student2`和`student3`示例，你可以按如下方式声明它们：
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Technically, these don’t have to appear in a `readonly` section (they could
    also appear in an HLA `static` section); however, you’ll never change the VMT
    values, so this section is a good place to declare them.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这些不必出现在`readonly`部分（它们也可以出现在HLA的`static`部分）；然而，你永远不会更改VMT的值，因此这个部分是声明它们的好地方。
- en: 'The `VMT` declarations in this example define two symbols you can access in
    the HLA program: `student2._VMT_` and `student3._VMT_`. These symbols correspond
    to the address of the first entry in each VMT. Somewhere in your code (typically
    in the constructor procedure), you need to initialize the VMT field of the object
    with the address of the VMT for the associated class. The HLA convention for the
    class constructors appears in the following code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的`VMT`声明定义了两个符号，你可以在HLA程序中访问：`student2._VMT_`和`student3._VMT_`。这些符号对应于每个VMT中的第一个条目的地址。在你的代码中的某个地方（通常是在构造函数中），你需要使用相关类的VMT地址来初始化对象的VMT字段。HLA的类构造函数约定如下所示：
- en: '[PRE87]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`student2.create()` and `student3.create()` are *class procedures* (also known
    as *static class methods* or *functions* in some languages). The main point to
    class procedures is that the code calls them directly, not indirectly (that is,
    through the VMT). So, if you call `John.create()` or `Joan.create()`, you’re always
    going to call the `student2.create()` class procedure. Likewise, if you call `Jenny.create()`—or
    any `student3` variable’s `create` constructor—you’ll always be calling the `student3.create()`
    procedure.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`student2.create()`和`student3.create()`是*类过程*（在某些语言中也称为*静态类方法*或*函数*）。类过程的主要特点是代码直接调用它们，而不是间接调用（即通过VMT）。因此，如果你调用`John.create()`或`Joan.create()`，你总是会调用`student2.create()`类过程。同样，如果你调用`Jenny.create()`——或者任何`student3`变量的`create`构造函数——你总是会调用`student3.create()`过程。'
- en: 'The two statements:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条语句：
- en: '[PRE88]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: copy the address of the VMT (for the given class) into the VMT pointer field
    (`this._pVMT_`) in the objects being created.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 将VMT的地址（针对给定类）复制到正在创建的对象的VMT指针字段（`this._pVMT_`）中。
- en: 'Note the following statement in the `student3.create()` constructor:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`student3.create()`构造函数中的以下语句：
- en: '[PRE89]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Upon arriving at this point, the 80x86 ESI register contains a pointer to a
    `student3` object. The text `(type student2 [esi])` typecasts this to a `student2`
    pointer. This winds up calling the parent class’s constructor (in order to initialize
    any fields in the base class).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这一点时，80x86的ESI寄存器包含指向`student3`对象的指针。文本`(type student2 [esi])`将其类型转换为`student2`指针。这将最终调用父类的构造函数（以初始化基类中的任何字段）。
- en: 'Finally, consider the following code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑以下代码：
- en: '[PRE90]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If you look at the `_pVMT_` entries in the `John` and `Joan` objects, you’ll
    find that they contain the address of the VMT for the `student2` class. Likewise,
    the `_pVMT_` field of the `Jenny` object contains the address of the VMT for the
    `student3` class.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`John`和`Joan`对象中的`_pVMT_`条目，你会发现它们包含`student2`类的VMT地址。同样，`Jenny`对象的`_pVMT_`字段包含`student3`类的VMT地址。
- en: '***7.5.3 Polymorphism***'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.5.3 多态性***'
- en: 'If you have an HLA `student2` variable (that is, a variable that contains a
    pointer to a `student2` object in memory), you can call the `setName()` method
    for that object using the following HLA code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个HLA `student2`变量（即一个包含指向`student2`对象的指针的变量），你可以使用以下HLA代码调用该对象的`setName()`方法：
- en: '[PRE91]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'These particular calls are examples of high-level activity taking place in
    HLA. The machine code that the HLA compiler emits for the first of these statements
    looks something like the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定的调用是HLA中高级活动的示例。HLA编译器为这些语句中的第一个生成的机器代码大致如下所示：
- en: '[PRE92]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here’s what this code is doing:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这段代码在做什么：
- en: The first line copies the address held in the `John` pointer into the ESI register.
    This is because most indirect accesses on the 80x86 take place in a register,
    not in memory variables.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行将`John`指针所持有的地址复制到ESI寄存器中。这是因为在80x86架构中，大多数间接访问操作发生在寄存器中，而不是内存变量中。
- en: The VMT pointer is a field in the `student2` object structure. The code needs
    to obtain the pointer to the `setName()` method, held in the VMT. The `_pVMT_`
    field of the object (which is in memory) holds the address of the VMT. Once again,
    we must load this into a register to access that data indirectly. The program
    copies the VMT pointer into the 80x86 EDI register.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VMT指针是`student2`对象结构中的一个字段。代码需要获取指向VMT中`setName()`方法的指针。对象的`_pVMT_`字段（在内存中）保存着VMT的地址。我们必须将其加载到寄存器中，以间接访问该数据。程序将VMT指针复制到80x86的EDI寄存器中。
- en: The VMT (at which EDI now points) contains two entries. The first entry (offset
    0) contains the address of the `student2.setName()` method; the second entry (offset
    4) contains the address of the `student2.getName()` method. Because we want to
    call the `student2.setName()` method, the third instruction in this sequence calls
    the method at the address held in the memory location pointed at by `[edi+0]`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VMT（现在由EDI指向的内存位置）包含两个条目。第一个条目（偏移量0）包含`student2.setName()`方法的地址；第二个条目（偏移量4）包含`student2.getName()`方法的地址。因为我们想调用`student2.setName()`方法，所以该指令序列中的第三条指令调用了内存位置`[edi+0]`所指向地址处的方法。
- en: As you can see, this is quite a bit more work than calling `student.``setName()`
    directly. Why do we go through all this effort? After all, we know that `John`
    and `Joan` are both `student2` objects. We also know that `Jenny` is a `student3`
    object. So, we ought to be able to call the `student2.setName()` or `student3.setName()`
    methods directly. That would take only one machine instruction, which is both
    faster and shorter.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这比直接调用`student.``setName()`方法要复杂得多。为什么我们要这么做呢？毕竟我们知道`John`和`Joan`都是`student2`对象。我们还知道`Jenny`是`student3`对象。所以我们本应该能直接调用`student2.setName()`或`student3.setName()`方法。这将只需要一条机器指令，既更快又更简短。
- en: 'The reason for all this extra work is to support polymorphism. Suppose we declare
    a generic `student2` object:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 进行所有这些额外工作的原因是为了支持多态性。假设我们声明了一个通用的`student2`对象：
- en: '[PRE93]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'What happens when we assign the value of `Jenny` to `student` and call `student.setName()`?
    Well, the code sequence is identical to that for the call for `John` given earlier.
    That is, the code loads the pointer held in `student` into the ESI register, copies
    the `_pVMT_` field into the EDI register, and then jumps indirectly through the
    first entry of the VMT (which points at the `setName()` method). There is, however,
    one major difference between this example and the previous: in this case, `student`
    is pointing at a `student3` object in memory. So, when the code loads the address
    of the VMT into the EDI register, EDI is actually pointing at the `student3` VMT,
    not the `student2` VMT (as was the case when we used the `John` pointer). Therefore,
    when the program calls the `setName()` method, it’s actually calling the `student3.setName()`
    method, not the `student2.setName()` method. This behavior is the basis for polymorphism
    in modern object-oriented programming languages.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Jenny`的值赋给`student`并调用`student.setName()`时会发生什么？嗯，代码序列与之前调用`John`的代码完全相同。也就是说，代码将`student`中的指针加载到ESI寄存器，将`_pVMT_`字段复制到EDI寄存器，然后通过VMT的第一个条目间接跳转（该条目指向`setName()`方法）。然而，这个例子和前一个例子之间有一个主要区别：在这种情况下，`student`指向内存中的一个`student3`对象。所以，当代码将VMT的地址加载到EDI寄存器时，EDI实际上指向的是`student3`的VMT，而不是`student2`的VMT（就像我们使用`John`指针时的情况）。因此，当程序调用`setName()`方法时，实际上是在调用`student3.setName()`方法，而不是`student2.setName()`方法。这种行为是现代面向对象编程语言中多态的基础。
- en: '***7.5.4 Abstract Methods and Abstract Base Classes***'
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.5.4 抽象方法和抽象基类***'
- en: An *[abstract base class](gloss01.xhtml#gloss01_2)* exists solely to supply
    a set of common fields to its derived classes. You never declare variables whose
    type is an abstract base class; you always use one of the derived classes. An
    abstract base class is a template for creating other classes, nothing more.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*【抽象基类】(gloss01.xhtml#gloss01_2)*仅存在于为其派生类提供一组共同字段。你永远不会声明类型为抽象基类的变量；你总是使用某个派生类。抽象基类是用于创建其他类的模板，仅此而已。'
- en: The only difference in syntax between a standard base class and an abstract
    base class is the presence of at least one abstract method declaration. An *[abstract
    method](gloss01.xhtml#gloss01_3)* is a special method that does not have an actual
    implementation in the abstract base class. Any attempt to call that method will
    raise an exception. If you’re wondering what possible good an abstract method
    could be, keep reading.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 标准基类和抽象基类在语法上的唯一区别是至少有一个抽象方法声明。一个*【抽象方法】(gloss01.xhtml#gloss01_3)*是一个特殊方法，在抽象基类中没有实际的实现。任何尝试调用该方法的行为都会引发异常。如果你在想抽象方法到底有什么用，那就继续阅读吧。
- en: 'Suppose you want to create a set of classes to hold numeric values. One class
    could represent unsigned integers, another class could represent signed integers,
    a third could implement BCD values, and a fourth could support `real64` values.
    While you could create four separate classes that function independently of one
    another, doing so passes up an opportunity to make this set of classes more convenient
    to use. To understand why, consider the following HLA class declarations:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一组类来存储数字值。一个类可以表示无符号整数，另一个类可以表示有符号整数，第三个类可以实现BCD值，第四个类可以支持`real64`值。虽然你可以创建四个独立的类，它们各自独立工作，但这样做错失了将这组类变得更易于使用的机会。为了理解为什么，请考虑以下HLA类声明：
- en: '[PRE94]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The implementation of these classes is not unreasonable. They have fields for
    the data, and they have a `put()` method that, presumably, writes the data to
    the standard output device. They probably have other methods and procedures to
    implement various operations on the data. There are, however, two problems with
    these classes, one minor and one major, both occurring because these classes do
    not inherit any fields from a common base class.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的实现是合理的。它们有用于数据的字段，并且有一个`put()`方法，假设该方法将数据写入标准输出设备。它们可能还有其他方法和过程来实现对数据的各种操作。然而，这些类有两个问题，一个是次要问题，另一个是主要问题，都是因为这些类没有从一个共同的基类继承任何字段。
- en: The minor problem is that you have to repeat the declaration of several common
    fields in these classes. For example, the `put()` method is declared in each class.^([6](footnotes.xhtml#fn7_6a))
    The major problem is that this approach is not generic—that is, you can’t create
    a generic pointer to a “numeric” object and perform operations like addition,
    subtraction, and output on that value (regardless of the underlying numeric representation).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 次要问题是你必须在这些类中重复声明几个公共字段。例如，`put()`方法在每个类中都有声明。^([6](footnotes.xhtml#fn7_6a))
    主要问题是这种方法不是通用的——也就是说，你不能创建一个指向“numeric”对象的通用指针，并对该值执行加法、减法和输出等操作（不管其底层的数字表示方式如何）。
- en: 'We can easily solve these two problems by turning the previous class declarations
    into a set of derived classes. The following code demonstrates an easy way to
    do this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将之前的类声明转换为一组派生类，轻松解决这两个问题。以下代码演示了实现这一点的简便方法：
- en: '[PRE95]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: First, by making the `put()` method inherit from `numeric`, this code encourages
    the derived classes to always use the name `put()`, which makes the program easier
    to maintain. Second, because this example uses derived classes, it’s possible
    to create a pointer to the `numeric` type and load that pointer with the address
    of a `uint`, `sint`, or `r64` object. The pointer can invoke the methods found
    in the `numeric` class to do functions like addition, subtraction, or numeric
    output. Therefore, the application that uses this pointer doesn’t need to know
    the exact data type; it deals with numeric values only in a generic fashion.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过使`put()`方法继承自`numeric`，这段代码鼓励派生类始终使用`put()`这个名称，从而使程序更易于维护。其次，因为这个例子使用了派生类，所以可以创建一个指向`numeric`类型的指针，并用`uint`、`sint`或`r64`对象的地址来填充该指针。该指针可以调用`numeric`类中找到的方法来执行加法、减法或数值输出等功能。因此，使用这个指针的应用程序不需要知道确切的数据类型；它只需以通用的方式处理数值。
- en: One problem with this scheme is that it’s possible to declare and use variables
    of type `numeric`. Unfortunately, such numeric variables aren’t capable of representing
    any type of number (notice that the data storage for the numeric fields actually
    appears in the derived classes). Worse, because you’ve declared the `put()` method
    in the `numeric` class, you actually have to write some code to implement that
    method even though you should never really call it; the actual implementation
    should occur only in the derived classes. While you could write a dummy method
    that prints an error message (or, better yet, raises an exception), you shouldn’t
    have to resort to that. Fortunately, there’s no reason to do so—if you use *abstract*
    methods.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案的一个问题是，可以声明和使用`numeric`类型的变量。不幸的是，这种`numeric`变量无法表示任何类型的数字（请注意，`numeric`字段的实际数据存储实际上出现在派生类中）。更糟糕的是，因为你已经在`numeric`类中声明了`put()`方法，所以实际上你必须编写一些代码来实现该方法，即使你不应该真正调用它；实际的实现应该只出现在派生类中。虽然你可以编写一个虚拟方法来打印错误消息（或者更好的是，抛出异常），但你不应该不得不这样做。幸运的是，没有理由这么做——如果你使用*抽象*方法的话。
- en: 'The HLA `abstract` keyword, when it follows a method declaration, tells HLA
    that you aren’t going to provide an implementation of the method for this class.
    Instead, all derived classes are responsible for providing a concrete implementation
    for the abstract method. HLA will raise an exception if you attempt to call an
    abstract method directly. The following code modifies the `numeric` class to convert
    `put()` to an abstract method:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 的 `abstract` 关键字，如果出现在方法声明后面，表示你不会为这个类提供该方法的实现。相反，所有派生类都负责为抽象方法提供具体实现。如果你尝试直接调用抽象方法，HLA
    会抛出异常。以下代码修改了 `numeric` 类，将 `put()` 方法转换为抽象方法：
- en: '[PRE96]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: An abstract base class has at least one abstract method. But you don’t have
    to make *all* methods abstract in an abstract base class; it’s perfectly legal
    to declare some standard methods (and, of course, provide their implementation)
    within it.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类至少有一个抽象方法。但你不必让抽象基类中的 *所有* 方法都是抽象的；在其中声明一些标准方法（当然，还可以提供它们的实现）是完全合法的。
- en: Abstract method declarations provide a mechanism by which a base class can specify
    some generic methods that the derived classes must implement. If the derived classes
    don’t provide concrete implementations of all abstract methods, that makes them
    abstract base classes themselves.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法声明提供了一种机制，通过该机制，基类可以指定一些派生类必须实现的通用方法。如果派生类没有提供所有抽象方法的具体实现，它们自己也将成为抽象基类。
- en: A little earlier, you read that you should never create variables whose type
    is an abstract base class. Remember, if you attempt to execute an abstract method,
    the program will immediately raise an exception to complain about this illegal
    method call.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 之前你读到过，不应该创建类型为抽象基类的变量。记住，如果你尝试执行抽象方法，程序会立即抛出异常，抱怨这个非法的函数调用。
- en: '**7.6 Classes in C++**'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.6 C++ 中的类**'
- en: Up to this point, all the examples of classes and objects have used HLA. That
    made sense because the discussion concerned the low-level implementation of classes,
    which is something HLA illustrates well. However, you may not ever use HLA in
    a program you write. So now we’ll look at how high-level languages implement classes
    and objects. As C++ was one of the earliest HLLs to support classes, we’ll start
    with it.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的类和对象示例都使用了 HLA。这是有道理的，因为讨论的是类的低级实现，而 HLA 很好地展示了这一点。然而，你可能在编写的程序中永远不会使用
    HLA。所以现在我们来看看高级语言是如何实现类和对象的。由于 C++ 是最早支持类的高级语言之一，我们将从它开始。
- en: 'Here’s a variant of the `student2` class in C++:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 C++ 中 `student2` 类的一个变体：
- en: '[PRE97]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first major difference from HLA’s classes is the presence of the `private`,
    `protected`, and `public` keywords. C++ and other HLLs make a concerted effort
    to support *encapsulation* (information hiding), and these three keywords are
    one of the main tools C++ uses to enforce it. Scope, privacy, and encapsulation
    are syntactical issues that are useful for software engineering constructs, but
    they really don’t impact the *implementation* of classes and objects in memory.
    Thus, since this book’s focus is implementation, we’ll leave further discussion
    of encapsulation for *[WGC4](gloss01.xhtml#gloss01_266)* and *[WGC5](gloss01.xhtml#gloss01_267)*.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HLA 类的主要区别之一是 `private`、`protected` 和 `public` 关键字的存在。C++ 及其他高级语言（HLL）都努力支持
    *封装*（信息隐藏），而这三个关键字是 C++ 强制执行封装的主要工具之一。作用域、隐私和封装是有助于软件工程构造的语法问题，但它们实际上并不影响类和对象在内存中的
    *实现*。因此，由于本书的重点是实现，我们将在 *[WGC4](gloss01.xhtml#gloss01_266)* 和 *[WGC5](gloss01.xhtml#gloss01_267)*
    中进一步讨论封装问题。
- en: The layout of the C++ `student2` object in memory will be very similar to the
    HLA variant (of course, different compilers could lay things out differently,
    but the basic idea of data fields and the VMT still applies).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中 `student2` 对象在内存中的布局将与 HLA 变体非常相似（当然，不同的编译器可能会有不同的布局，但数据字段和虚拟方法表（VMT）的基本思想仍然适用）。
- en: 'Here’s an example of inheritance in C++:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 C++ 中继承的一个例子：
- en: '[PRE98]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Structures and classes are almost identical in C++. The main difference between
    the two is that the default visibility at the beginning of a class is `private`,
    whereas the default visibility for `struct` is `public`. So, we could rewrite
    the `student3` class as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，结构体和类几乎是相同的。两者之间的主要区别在于，类的默认可见性是 `private`，而 `struct` 的默认可见性是 `public`。因此，我们可以将
    `student3` 类重写如下：
- en: '[PRE99]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '***7.6.1 Abstract Member Functions and Classes in C++***'
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.6.1 C++ 中的抽象成员函数和类***'
- en: 'C++ has an especially weird way of declaring abstract member functions—you
    place “`= 0;`” after the function definition in the class, like so:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: C++有一种特别奇怪的声明抽象成员函数的方式——你需要在类中为函数定义添加“`= 0;`”，如下所示：
- en: '[PRE100]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: As with HLA, if a class contains at least one abstract function, the class is
    an abstract class. Note that abstract functions must also be virtual, as they
    must be overridden in some derived class to be useful.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 与HLA类似，如果一个类包含至少一个抽象函数，那么该类就是一个抽象类。需要注意的是，抽象函数也必须是虚函数，因为它们必须在某个派生类中被重写才能有用。
- en: '***7.6.2 Multiple Inheritance in C++***'
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.6.2 C++中的多重继承***'
- en: 'C++ is one of the few modern programming languages that supports *[multiple
    inheritance](gloss01.xhtml#gloss01_168)*; that is, a class can inherit the data
    and member functions from multiple classes. Consider the following C++ code fragment:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: C++是为数不多的几种现代编程语言之一，支持*[多重继承](gloss01.xhtml#gloss01_168)*；也就是说，一个类可以从多个类继承数据和成员函数。考虑以下C++代码片段：
- en: '[PRE101]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In this example, class `c` inherits all the information from classes `a` and
    `b`. In memory, a typical C++ compiler will create an object like that shown in
    [Figure 7-16](ch07.xhtml#ch07fig16).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`c`类继承了来自`a`和`b`类的所有信息。在内存中，典型的C++编译器会创建如[图7-16](ch07.xhtml#ch07fig16)所示的对象。
- en: '![image](../images/07fig16.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig16.jpg)'
- en: '*Figure 7-16: Multiple inheritance memory layout*'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-16：多重继承的内存布局*'
- en: The `VMT` pointer entry points at a typical VMT containing the addresses of
    the `setI()`, `setJ()`, and `setK()` methods (as shown in [Figure 7-17](ch07.xhtml#ch07fig17)).
    If you call the `setI()` method, the compiler will generate code that loads the
    `this` pointer with the address of the `VMT` pointer entry in the object (the
    base address of the `c` object in [Figure 7-16](ch07.xhtml#ch07fig16)). Upon entry
    into `setI()`, the system believes that `this` is pointing at an object of type
    `a`. In particular, the `this.VM``T` field points at a VMT whose first (and, as
    far as type `a` is concerned, only) entry is the address of the `setI()` method.
    Likewise, at offset `(this+4`) in memory (as the `VMT` pointer is 4 bytes), the
    `setI()` method will find the `i` data value. As far as the `setI()` method is
    concerned, `this` is pointing at a class type `a` object (even though it’s actually
    pointing at a type `c` object).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`VMT`指针条目指向一个典型的VMT，其中包含`setI()`、`setJ()`和`setK()`方法的地址（如[图7-17](ch07.xhtml#ch07fig17)所示）。如果你调用`setI()`方法，编译器会生成代码，将`this`指针加载为对象中`VMT`指针条目的地址（即[图7-16](ch07.xhtml#ch07fig16)中`c`对象的基地址）。当进入`setI()`方法时，系统认为`this`指向的是一个`a`类型的对象。特别地，`this.VMT`字段指向一个VMT，其第一个（也是对于`a`类型来说唯一的）条目是`setI()`方法的地址。同样，在内存中的偏移量`(this+4)`处（因为`VMT`指针是4字节），`setI()`方法将找到`i`数据值。对于`setI()`方法来说，`this`指向的是一个`a`类型的对象（尽管它实际上指向的是一个`c`类型的对象）。'
- en: '![image](../images/07fig17.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig17.jpg)'
- en: '*Figure 7-17: Multiple inheritance `this` values*'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-17：多重继承中的`this`值*'
- en: When you call the `setK()` method, the system also passes the base address of
    the `c` object. Of course, `setK()` is expecting a type `c` object and `this`
    is pointing at a type `c` object, so all the offsets into the object are exactly
    as `setK()` expects. Note that objects of type `c` (and methods in the `c` class)
    will normally ignore the `VMT2` pointer field in the `c` object.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`setK()`方法时，系统还会传递`c`对象的基地址。当然，`setK()`方法期望的是一个类型为`c`的对象，而`this`指针指向的是类型为`c`的对象，因此对象中的所有偏移量都完全符合`setK()`的预期。需要注意的是，`c`类型的对象（以及`c`类中的方法）通常会忽略`c`对象中的`VMT2`指针字段。
- en: The problem occurs when the program attempts to call the `setJ()` method. Because
    `setJ()` belongs to class `b`, it expects `this` to hold the address of a VMT
    pointer pointing at a VMT for class `b`. It also expects to find data field `j`
    at offset (`this+4`). Were we to pass the `c` object’s `this` pointer to `setJ()`,
    accessing (`this+4`) would reference the `i` data field, not `j`. Furthermore,
    were a class `b` method to make a call to another method in class `b` (such as
    `setJ()` making a recursive call to itself), the VMT pointer would be wrong—it
    points at a VMT with a pointer to `setI()` at offset 0, whereas class `b` expects
    it to point at a VMT with a pointer to `setJ()` at offset 0\. To resolve this
    issue, a typical C++ compiler will insert an extra VMT pointer into the `c` object
    immediately prior to the `j` data field. It will initialize this second VMT field
    to point into the `c` VMT at the location where the class `b` method pointers
    begin (see [Figure 7-17](ch07.xhtml#ch07fig17)). When calling a method in class
    `b`, the compiler will emit code that initializes the `this` pointer with the
    address of this second VMT pointer (rather than pointing at the beginning of `c`-type
    object in memory). Now, upon entry to a class `b` method—such as `setJ()`—`this`
    will point at a legitimate VMT pointer for class `b`, and the `j` data field will
    appear at the offset (`this+4`) that class `b` methods expect.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在程序尝试调用 `setJ()` 方法时。因为 `setJ()` 属于类 `b`，它期望 `this` 持有指向类 `b` 的 VMT 指针的地址。它还期望在偏移量（`this+4`）处找到数据字段
    `j`。如果我们将 `c` 对象的 `this` 指针传递给 `setJ()`，访问（`this+4`）将引用数据字段 `i`，而不是 `j`。此外，如果类
    `b` 的某个方法调用了类 `b` 中的另一个方法（例如 `setJ()` 递归调用自身），VMT 指针将是错误的——它指向的是包含指向 `setI()`
    的指针的 VMT，而类 `b` 期望它指向的是包含指向 `setJ()` 的指针的 VMT（偏移量为 0）。为了解决这个问题，典型的 C++ 编译器会在 `c`
    对象中 `j` 数据字段之前插入一个额外的 VMT 指针。它将初始化这个第二个 VMT 字段，使其指向 `c` 的 VMT 中类 `b` 方法指针开始的位置（见
    [图 7-17](ch07.xhtml#ch07fig17)）。当调用类 `b` 的方法时，编译器会生成代码，将 `this` 指针初始化为指向这个第二个
    VMT 指针的地址（而不是指向内存中 `c` 类型对象的开头）。现在，在进入类 `b` 的方法时——比如 `setJ()`——`this` 将指向一个合法的
    VMT 指针，并且 `j` 数据字段将出现在类 `b` 方法所期望的偏移量（`this+4`）处。
- en: '**7.7 Classes in Java**'
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.7 Java 中的类**'
- en: 'Java, as a C-based language, has class definitions that are somewhat similar
    to C++ (though Java doesn’t support multiple inheritance and has a more rational
    way of declaring abstract methods). Here’s a sample set of Java class declarations
    to give you a sense of how they work:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Java 作为一种基于 C 的语言，其类定义与 C++ 有些相似（尽管 Java 不支持多重继承，并且具有更合理的抽象方法声明方式）。下面是一些 Java
    类声明的示例，以帮助你理解它们是如何工作的：
- en: '[PRE102]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**7.8 Classes in Swift**'
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.8 Swift 中的类**'
- en: 'Swift is also a member of the C language tree. Like C++, Swift allows you to
    declare classes using the `class` or `struct` keyword. Unlike C++, Swift structures
    and classes are different things. A Swift structure is somewhat like a C++ class
    variable, whereas a Swift class is similar to a C++ pointer to an object. In Swift
    terminology, structures are *value* objects and classes are *reference* objects.
    Basically, when you create a structure object, Swift allocates sufficient memory
    for the entire object and binds that storage to the variable.^([7](footnotes.xhtml#fn7_7a))
    Like Java, Swift doesn’t support multiple inheritance; only single inheritance
    is legal. Also note that Swift doesn’t support abstract member functions or classes.
    Here’s an example of a pair of Swift classes:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 也是 C 语言家族的一员。像 C++ 一样，Swift 允许使用 `class` 或 `struct` 关键字声明类。与 C++ 不同的是，Swift
    的结构体和类是两种不同的概念。Swift 的结构体有点像 C++ 类的变量，而 Swift 类则类似于 C++ 中指向对象的指针。在 Swift 的术语中，结构体是
    *值* 类型对象，类是 *引用* 类型对象。基本上，当你创建一个结构体对象时，Swift 会为整个对象分配足够的内存，并将这块存储与变量绑定起来。^([7](footnotes.xhtml#fn7_7a))
    与 Java 一样，Swift 不支持多重继承；仅支持单一继承。同时，注意 Swift 不支持抽象成员函数或类。下面是一对 Swift 类的示例：
- en: '[PRE103]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In Swift, all member functions are virtual by default. Also, the `init()` function
    is Swift’s constructor. Destructors have the name `deinit()`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，所有成员函数默认都是虚拟函数。此外，`init()` 函数是 Swift 的构造函数。析构函数的名称是 `deinit()`。
- en: '**7.9 Protocols and Interfaces**'
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.9 协议和接口**'
- en: Java and Swift don’t support multiple inheritance, because it has some logical
    problems. The classic example is the “diamond lattice” data structure. This occurs
    when two classes (say, `b` and `c`) both inherit information from the same class
    (say, `a`) and then a fourth class (say, `d`) inherits from both `b` and `c`.
    As a result, `d` inherits the data from `a` twice—once through `b` and once through
    `c`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Java 和 Swift 不支持多重继承，因为它存在一些逻辑问题。经典的例子是“钻石格”数据结构。这发生在两个类（比如 `b` 和 `c`）都从同一个类（比如
    `a`）继承信息，然后一个第四个类（比如 `d`）从 `b` 和 `c` 继承。因此，`d` 从 `a` 继承数据两次——一次通过 `b`，一次通过 `c`。
- en: Although multiple inheritance can lead to some weird problems like this, there’s
    no question that being able to inherit from multiple locations is often useful.
    Thus, the solution in languages such as Java and Swift is to allow a class to
    inherit methods or functions from multiple sources but to inherit data fields
    from only a single ancestor class. This avoids most of the problems with multiple
    inheritance (specifically, an ambiguous choice of inherited data fields) while
    allowing programmers to include methods from various sources. Java calls such
    extensions *interfaces*, and Swift calls them *protocols*.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多重继承可能会导致一些奇怪的问题，比如这样的问题，但毫无疑问，能够从多个地方继承通常是有用的。因此，像 Java 和 Swift 这样的语言的解决方案是允许一个类从多个来源继承方法或函数，但只从一个祖先类继承数据字段。这避免了多重继承的大部分问题（特别是继承的数据字段的模糊选择），同时允许程序员从不同来源包含方法。Java
    称这种扩展为 *接口*，Swift 称其为 *协议*。
- en: 'Here’s an example of a couple of Swift protocol declarations and a class supporting
    that protocol:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这是几个 Swift 协议声明和支持该协议的类的示例：
- en: '[PRE104]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Swift protocols don’t supply any functions. Instead, a class that supports a
    protocol promises to provide an implementation of the functions the protocol(s)
    specify. In the preceding example, the `supportsProtocols` class is responsible
    for supplying all functions required by the protocols it supports. Effectively,
    protocols are like abstract classes containing only abstract methods—the inheriting
    class must provide actual implementations for all the abstract methods.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 协议不提供任何函数。相反，支持协议的类承诺提供协议所指定的函数的实现。在前面的示例中，`supportsProtocols` 类负责提供它所支持的协议所要求的所有函数。实际上，协议就像只包含抽象方法的抽象类——继承类必须为所有抽象方法提供实际的实现。
- en: 'Here’s the previous example coded in Java and demonstrating its comparable
    mechanism, the interface:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前示例在 Java 中的代码，它演示了相应的机制——接口：
- en: '[PRE105]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Interfaces and protocols behave somewhat like base class types in Java and
    Swift. If you instantiate a class object and assign that instance to a variable
    that is an interface/protocol type, you can execute the supported member functions
    for that interface or protocol. Consider the following Java example:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和协议在行为上有些类似于 Java 和 Swift 中的基类类型。如果你实例化一个类对象，并将该实例分配给一个接口/协议类型的变量，你可以执行该接口或协议所支持的成员函数。考虑以下
    Java 示例：
- en: '[PRE106]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Here’s a comparable example in Swift:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在 Swift 中的类似示例：
- en: '[PRE107]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You implement a protocol or interface using a pointer to a VMT that contains
    the addresses of the functions declared in that protocol or interface. So, the
    data structure for the Swift `g` class in the previous example would have three
    VMT pointers in it—one for protocol `a`, one for protocol `d`, and one for the
    class `g` (holding a pointer to the `local()` function).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过指向包含该协议或接口中声明的函数地址的 VMT 来实现一个协议或接口。因此，在前面的示例中，Swift `g` 类的数据结构会有三个 VMT 指针——一个指向协议
    `a`，一个指向协议 `d`，一个指向类 `g`（保存指向 `local()` 函数的指针）。
- en: When you create a variable whose type is a protocol/interface (`x` in the previous
    example), the variable holds the VMT pointer for that protocol. In the current
    example, the assignment of `g()` to the `x` variable actually just copies the
    VMT pointer for protocol `a` into `x`. Then, when the code executes `x.b` and
    `x.c`, it obtains the addresses of the actual functions from the VMT.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个类型为协议/接口的变量（在前面的示例中是 `x`）时，变量会保存该协议的 VMT 指针。在当前示例中，将 `g()` 赋值给 `x` 变量实际上只是将协议
    `a` 的 VMT 指针复制到 `x` 中。然后，当代码执行 `x.b` 和 `x.c` 时，它会从 VMT 中获取实际函数的地址。
- en: '**7.10 Generics and Templates**'
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.10 泛型和模板**'
- en: Although classes and objects allow software engineers to extend their systems
    in ways that aren’t possible without object-oriented programming, objects don’t
    provide a completely generic solution. *Generics*, first introduced by the ML
    programming language in 1973 and popularized by the Ada programming language,
    provide the key missing feature to extensibility that plain object-oriented programming
    was missing. Today, most modern programming languages—C++ (templates), Swift,
    Java, HLA (via macros), and Delphi—support some form of generic programming. In
    the generic programming style, you develop algorithms that operate on arbitrary
    data types to be defined in the future, and supply the actual data type immediately
    prior to using the generic type.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类和对象允许软件工程师以面向对象编程无法实现的方式扩展他们的系统，但对象并没有提供完全通用的解决方案。*泛型*，最早由 ML 编程语言在 1973
    年引入，并通过 Ada 编程语言普及，为扩展性提供了面向对象编程所缺失的关键功能。今天，大多数现代编程语言——C++（模板）、Swift、Java、HLA（通过宏）和
    Delphi——都支持某种形式的泛型编程。在泛型编程风格中，你会开发能够操作任意数据类型的算法，这些数据类型将在未来定义，并且在使用泛型类型之前立即提供实际的数据类型。
- en: The classic example is a linked list. It’s very easy to write a simple, singly
    linked list class—say, to manage a list of integers. However, after creating your
    list of integers, you decide you need a list of doubles. A quick copy-and-paste
    operation (plus changing the node type from `int` to `double`), and you’ve got
    a class that handles linked lists of double values. Oh wait, now you want a list
    of strings? Another cut-and-paste operation, and you’ve got lists of strings.
    Now you need a list of objects? Okay, yet another cut-and-paste. . . . You get
    the idea. Before too long, you’ve created a half-dozen different list classes
    and, whoops, you discover a bug in the original implementation. Now you get to
    go back and correct that bug in every list class you’ve created. Good luck with
    that, if you’ve used the list implementation in several different projects (you’ve
    just discovered why “cut and paste” programming is not considered great code).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的例子是链表。编写一个简单的单链表类非常容易——比如，管理一个整数列表。然而，在创建了整数列表后，你决定需要一个双精度浮点数的列表。只需快速复制粘贴（再把节点类型从
    `int` 改成 `double`），你就得到了一个处理双精度浮点数链表的类。等等，现在你需要一个字符串列表？再来一次复制粘贴，你就得到了字符串列表。现在你需要一个对象列表？好吧，再来一次复制粘贴……你明白了吧。不久之后，你就创建了半打不同的列表类，结果，哦不，你在原始实现中发现了一个
    bug。现在，你得回去修复所有你创建的列表类中的这个 bug。如果你在多个不同的项目中使用了这些列表实现（你刚刚发现了“复制粘贴”编程为什么不被认为是优秀代码）。
- en: Generics (C++ templates) come to the rescue. With a generic class definition,
    you specify only the algorithms (methods/member functions) that manipulate the
    list; you don’t worry about the node type. You fill in the node type when you
    declare an object of the generic class type. To create integer, double, string,
    or object lists, you simply provide the type you want to the generic list class,
    and that’s it. Should you discover a bug in the original (generic) implementation,
    all you do is fix the defect once and recompile your code; everywhere you’ve used
    the generic type, the compilation applies the correction.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型（C++ 模板）来解救你了。通过泛型类定义，你只需指定操作列表的算法（方法/成员函数）；你无需担心节点类型。当你声明泛型类类型的对象时，再填充节点类型。要创建整数、双精度浮点数、字符串或对象列表，你只需向泛型列表类提供你想要的类型，仅此而已。如果你在原始（泛型）实现中发现了
    bug，你只需修复该缺陷并重新编译代码；在你使用泛型类型的每个地方，编译都会应用修正。
- en: 'Here’s a C++ node and list definition:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 C++ 节点和列表定义：
- en: '[PRE108]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `<T>` sequence in this C++ code is a *[parameterized type](gloss01.xhtml#gloss01_190)*.
    This means that you’ll supply a type and the compiler will substitute that type
    everywhere it sees `T` in the template. So, in the preceding code, if you supply
    `int` as the parameter type, the C++ compiler will substitute `int` for every
    instance of `T`. To create a list of integers and doubles, you could use the following
    C++ code:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 C++ 代码中的`<T>`序列是一个 *[参数化类型](gloss01.xhtml#gloss01_190)*。这意味着你将提供一个类型，编译器将在模板中看到
    `T` 的每个位置时都用该类型进行替换。因此，在前面的代码中，如果你提供 `int` 作为参数类型，C++ 编译器将用 `int` 替换所有的 `T`。要创建一个整数和双精度浮点数的列表，你可以使用以下
    C++ 代码：
- en: '[PRE109]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The easiest way to implement generics is by using macros. When a compiler sees
    a declaration such as `list <int> integerList;` it expands the associated template
    code, substituting `int` for `T` throughout the expansion.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 实现泛型的最简单方法是使用宏。当编译器看到类似`list <int> integerList;`的声明时，它会展开相关的模板代码，并将`int`替换为`T`，在整个展开过程中如此。
- en: 'Because template expansion can generate a massive amount of code, modern compilers
    try to optimize the process wherever possible. For example, if you declare two
    variables like so:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模板展开可能会生成大量代码，现代编译器尽可能优化这一过程。例如，如果你声明两个变量如下：
- en: '[PRE110]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: there’s really no need to create two separate `list` classes, both of type `int`.
    Clearly, the template expansions would be identical, so any decent compiler would
    use the same class definition for both declarations.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 其实没有必要为两种类型为`int`的`list`类分别创建两个独立的类。显然，模板展开结果是相同的，因此任何一个合格的编译器都会对这两个声明使用相同的类定义。
- en: Even smarter compilers would recognize that some functions, like `remove()`,
    don’t really care about the underlying node data type. The basic removal operation
    is the same for all data types; as the list data type uses a pointer for the node
    data, there’s no reason to generate different `remove()` functions for each type.
    With polymorphism, a single `remove()` member function would work fine. Recognizing
    this requires a little more sophistication on the compiler’s part, but it’s certainly
    doable.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是更智能的编译器，也会意识到某些函数（如`remove()`）其实并不关心底层节点的数据类型。基本的移除操作对于所有数据类型都是相同的；由于列表数据类型使用指针指向节点数据，所以没有理由为每种类型生成不同的`remove()`函数。借助多态性，一个`remove()`成员函数就能正常工作。编译器识别这一点需要更多的复杂度，但这是完全可行的。
- en: Ultimately, however, template/generic expansion is a macro expansion process.
    Anything else that happens is simply an optimization by the compiler.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终模板/泛型展开是一个宏展开过程。任何其他发生的事情仅仅是编译器的优化。
- en: '**7.11 For More Information**'
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.11 更多信息**'
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言的艺术*。第二版。旧金山：No Starch Press，2010年。
- en: 'Knuth, Donald. *The Art of Computer Programming, Volume I: Fundamental Algorithms*.
    3rd ed. Boston: Addison-Wesley Professional, 1997.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth, Donald. *计算机程序设计的艺术, 第一卷：基础算法*。第三版。波士顿：Addison-Wesley Professional，1997年。
