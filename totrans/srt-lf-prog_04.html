<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_93"/><strong><span class="big">4</span><br/>COMPUTER ANATOMY</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">You learned about the properties of bits and ways of using them to represent things in <a href="ch01.xhtml#ch01">Chapter 1</a>. In <a href="ch02.xhtml#ch02">Chapters 2</a> and <a href="ch03.xhtml#ch03">3</a>, you learned why we use bits and how they’re implemented in hardware. You also learned about a number of basic building blocks and how they could be combined into more complex configurations. In this chapter, you’ll learn how those building blocks can be combined into a circuit that can manipulate bits. That circuit is called a <em>computer</em>.</p>
<p class="indent">There are many ways of constructing a computer. The one we’ll build in this chapter was chosen for ease of explanation, not because it’s the best possible design. And although simple computers work, a lot of additional <span epub:type="pagebreak" id="page_94"/>complexity is required to make them work <em>well</em>. This chapter sticks to the simple computer; the next two chapters cover some of the extra complications.</p>
<p class="indent">There are three big pieces in a modern computer. These are the <em>memory</em>, the <em>input and output (I/O)</em>, and the <em>central processing unit (CPU)</em>. This section covers how these pieces relate to each other. <a href="ch03.xhtml#ch03">Chapter 3</a> introduced memory, and <a href="ch05.xhtml#ch05">Chapter 5</a> covers computers and memory in more detail. I/O is the subject of <a href="ch06.xhtml#ch06">Chapter 6</a>. The CPU lives in what I’m calling “City Center” in this chapter.</p>
<h3 class="h3" id="ch04lev1sec1"><strong>Memory</strong></h3>
<p class="noindent">Computers need someplace to keep the bits that they’re manipulating. That place is memory, as you learned in <a href="ch03.xhtml#ch03">Chapter 3</a>. Now it’s time to find out how computers use it.</p>
<p class="indent">Memory is like a long street full of houses. Each house is exactly the same size and has room for a certain number of bits. Building codes have pretty much settled on 1 byte per house. And just like on a real street, each house has an <em>address</em>, which is just a number. If you have 64 MiB of memory in your computer, that’s 64 × 1,024 × 1,024 = 67,108,864 bytes (or 536,870,912 bits). The bytes have addresses from 0 to 67,108,863. This numbering makes sense, unlike the numbering on many real streets.</p>
<p class="indent">It’s pretty common to refer to a memory <em>location</em>, which is just memory at a particular address, such as 3 Memory Lane (see <a href="ch04.xhtml#ch04fig01">Figure 4-1</a>).</p>
<div class="image"><a id="ch04fig01"/><img src="../images/04fig01.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-1: Memory Lane</em></p>
<p class="indent">Just because the basic unit of memory is a byte doesn’t mean we always look at it that way. For example, 32-bit computers usually organize their memory in 4-byte chunks, while 64-bit computers usually organize their memory in 8-byte chunks. Why does that matter? It’s like having a four- or eight-lane highway instead of a one-lane road. More lanes can handle more traffic because more bits can get on the data bus. When we address memory, we need to know what we’re addressing. Addressing long words is different from addressing bytes because there are 4 bytes to a long word on a 32-bit computer, and 8 bytes to a long word on a 64-bit computer. In <a href="ch04.xhtml#ch04fig02">Figure 4-2</a>, for example, long-word address 1 contains byte addresses 4, 5, 6, and 7.</p>
<p class="indent">Another way to look at it is that the street in a 32-bit computer contains fourplexes, not single houses, and each fourplex contains two duplexes. That means we can address an individual unit, a duplex, or a whole building.</p>
<span epub:type="pagebreak" id="page_95"/>
<div class="image"><a id="ch04fig02"/><img src="../images/04fig02.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-2: Memory highway</em></p>
<p class="indent">You may have noticed that each building straddles the highway such that each byte has its own assigned lane, and a long word takes up the whole road. Bits commute to and from City Center on a bus that has four seats, one for each byte. The doors are set up so that there’s one seat for each lane. On most modern computers, the bus stops only at one building on each trip from City Center. This means we can’t do things like form a long word from bytes 5, 6, 7, and 8, because that would mean that the bus would have to make two trips: one to building 0 and one to building 1. Older computers contained a complicated loading dock that allowed this, but planners noticed that it wasn’t all that useful and so they cut it out of the budget on newer models. Trying to get into two buildings at the same time, as shown in <a href="ch04.xhtml#ch04fig03">Figure 4-3</a>, is called a <em>nonaligned access</em>.</p>
<div class="image"><a id="ch04fig03"/><img src="../images/04fig03.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-3: Aligned and nonaligned accesses</em></p>
<p class="indent">There are lots of different kinds of memory, as we saw in the previous chapter. Each has a different <em>price/performance ratio</em>. For example, SRAM is fast and expensive, like the highways near where the politicians live. Disk is cheap and slow—the dirt road of memory.</p>
<p class="indent">Who gets to sit in which seat when commuting on the bus? Does byte 0 or byte 3 get to sit in the leftmost seat when a long word heads into town? It depends on the processor you’re using, because designers have made them both ways. Both work, so it’s pretty much a theological debate. In fact, the <span epub:type="pagebreak" id="page_96"/>term <em>endian</em>—based on the royal edicts in Lilliput and Blefuscu in Jonathan Swift’s <em>Gulliver’s Travels</em> regarding which was the proper end on which to crack open a soft-boiled egg—is used to describe the difference.</p>
<p class="indent">Byte 0 goes into the rightmost seat in little-endian machines like Intel processors. Byte 0 goes into the leftmost seat in big-endian machines like Motorola processors. <a href="ch04.xhtml#ch04fig04">Figure 4-4</a> compares the two arrangements.</p>
<div class="image"><a id="ch04fig04"/><img src="../images/04fig04.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-4: Big- and little-endian arrangements</em></p>
<p class="indent">Endianness is something to keep in mind when you’re transferring information from one device to another, because you don’t want to inadvertently shuffle the data. A notable instance of this occurred when the UNIX operating system was ported from the PDP-11 to an IBM Series/1 computer. A program that was supposed to print out “Unix” printed out “nUxi” instead, as the bytes in the 16-bit words got swapped. This was sufficiently humorous that the term <em>nuxi syndrome</em> was coined to refer to byte-ordering problems.</p>
<h3 class="h3" id="ch04lev1sec2"><strong>Input and Output</strong></h3>
<p class="noindent">A computer that couldn’t communicate with the outside world wouldn’t be very useful. We need some way to get things in and out of the computer. This is called <em>I/O</em> for <em>input/output</em>. Things that connect to the I/O are called <em>I/O devices</em>. Since they’re on the periphery of the computer, they’re also often called <em>peripheral devices</em> or just <em>peripherals</em>.</p>
<p class="indent">Computers used to have a separate I/O avenue, as shown in <a href="ch04.xhtml#ch04fig05">Figure 4-5</a>, that was similar to Memory Lane. This made sense when computers were physically huge, because they weren’t squeezed into small packages with a limited number of electrical connections. Also, Memory Lane wasn’t very long, so it didn’t make sense to limit the number of addresses just to support I/O.</p>
<div class="image"><a id="ch04fig05"/><img src="../images/04fig05.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-5: Separate memory and I/O buses</em></p>
<p class="indent">Memory Lane is much longer now that 32- and 64-bit computers are common. It’s so long that there aren’t houses at every address; many empty lots are available. In other words, there are addresses that have no memory associated with them. As a result, it now makes more sense to set aside a portion of Memory Lane for I/O devices. It’s like the industrial district on the edge of town. Also, as more circuitry is crammed into a package that has a limited number of connections, it just makes sense for I/O to be on the same bus as memory.</p>
<p class="indent">Many computers are designed with standard input/output <em>slots</em> so that I/O devices can be connected in a uniform manner. This is done sort of <span epub:type="pagebreak" id="page_97"/>like how property was distributed in the Old West; the unincorporated territory is partitioned into a set of land grants, as shown in <a href="ch04.xhtml#ch04fig06">Figure 4-6</a>. Each slot holder gets the use of all addresses up to its borders. Often there is a specific address in each slot that contains some sort of identifier so that City Center can conduct a census to determine who’s living in each slot.</p>
<div class="image"><a id="ch04fig06"/><img src="../images/04fig06.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-6: Shared memory and I/O bus</em></p>
<p class="indent">We often use a shipping metaphor and say that things are hooked up to <em>I/O ports</em>.</p>
<h3 class="h3" id="ch04lev1sec3"><strong>The Central Processing Unit</strong></h3>
<p class="noindent">The <em>central processing unit (CPU)</em> is the part of the computer that does the actual computing. It lives at City Center in our analogy. Everything else is the supporting cast. The CPU is made up of many distinct pieces that we’ll learn about in this section.</p>
<h4 class="h4" id="ch04lev2sec1"><strong><em>Arithmetic and Logic Unit</em></strong></h4>
<p class="noindent">The <em>arithmetic logic unit (ALU)</em> is one of the main pieces of a CPU. It’s the part that knows how to do arithmetic, Boolean algebra, and other operations. <a href="ch04.xhtml#ch04fig07">Figure 4-7</a> shows a simple diagram of an ALU.</p>
<div class="image"><a id="ch04fig07"/><img src="../images/04fig07.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-7: A sample ALU</em></p>
<p class="indent">The <em>operands</em> are just bits that may represent numbers. The operation code, or <em>opcode</em>, is a number that tells the ALU what <em>operator</em> to apply to the operands. The <em>result</em>, of course, is what we get when we apply the operator to the operands.</p>
<p class="indent"><span epub:type="pagebreak" id="page_98"/>The <em>condition codes</em> contain extra information about the result. They are usually stored in a <em>condition code register</em>. A register, which we saw back in <a href="ch03.xhtml#ch03">Chapter 3</a>, is just a special piece of memory that’s on a different street from the rest of the memory—the street with the expensive, custom homes. A typical condition code register is shown in <a href="ch04.xhtml#ch04fig08">Figure 4-8</a>. The numbers on top of the boxes are the bit numbers, which is a convenient way to refer to them. Note that some of the bits are not used; this is not unusual.</p>
<div class="image"><a id="ch04fig08"/><img src="../images/04fig08.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-8: A condition code register</em></p>
<p class="indent">The <em>N</em> is set to 1 if the result of the last operation is a negative number. The <em>Z</em> bit is set to 1 if the result of the last operation is 0. The <em>O</em> bit is set to 1 if the result of the last operation created an overflow or underflow.</p>
<p class="indent"><a href="ch04.xhtml#ch04tab01">Table 4-1</a> shows what an ALU might do.</p>
<p class="tabcap" id="ch04tab01"><strong>Table 4-1:</strong> Sample ALU Opcodes</p>
<table class="topbot-d">
<colgroup>
<col style="width:10%"/>
<col style="width:10%"/>
<col style="width:80%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Opcode</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Mnemonic</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>0000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">clr</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Ignore the operands; make each bit of the result 0 (clear).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>0001</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">set</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Ignore the operands; make each bit of the result 1.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>0010</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">not</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Ignore B; turn 0s from A to 1s and vice versa.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>0011</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">neg</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Ignore B; the result is the two’s complement of A, –A.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>0100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">shl</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Shift A left by the low 4 bits of B (see next section).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>0101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">shr</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Shift A right by the low 4 bits of B (see next section).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>0110</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Unused.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>0111</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Unused.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>1000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">load</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Pass operand B to the result.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>1001</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">and</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The result is A AND B for each bit in the operands.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>1010</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">or</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">The result is A OR B for each bit in the operands.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>1011</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">xor</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The result is A XOR B for each bit in the operands.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>1100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">add</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">The result is A + B.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>1101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">sub</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The result is A – B.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>1110</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">cmp</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Set condition codes based on B – A (compare).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>1111</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Unused.</p></td>
</tr>
</tbody>
</table>
<p class="indent"><span epub:type="pagebreak" id="page_99"/>The ALU may appear mysterious, but it’s really just some logic gates feeding a selector, which you’ve seen before. <a href="ch04.xhtml#ch04fig09">Figure 4-9</a> shows the general design of an ALU, omitting some of the more complicated functions for the sake of simplicity.</p>
<div class="image"><a id="ch04fig09"/><img src="../images/04fig09.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-9: ALU partial internals</em></p>
<h4 class="h4" id="ch04lev2sec2"><strong><em>Shiftiness</em></strong></h4>
<p class="noindent">You may have noticed the shift operations in <a href="ch04.xhtml#ch04tab01">Table 4-1</a>. A left shift moves every bit left one position, throwing away the leftmost bit and moving a 0 into the vacated rightmost position. If we left-shift 01101001 (105<sub>10</sub>) by 1, we’ll get 11010010 (210<sub>10</sub>). This is pretty handy because left-shifting a number one position multiplies it by 2.</p>
<p class="indent">A right shift moves every bit right one position, throwing away the rightmost bit and moving a 0 into the vacated leftmost position. If we right-shift 01101001 (105<sub>10</sub>) by 1, we’ll get 00110100 (52<sub>10</sub>). This divides a number by 2, throwing away the remainder.</p>
<p class="indent">The value of the MSB (most significant bit) lost when left-shifting or the LSB (least significant bit) when right-shifting is often needed, so it’s saved in the condition code register. Let’s make believe that our CPU saves it in the <em>O</em> bit.</p>
<p class="indent">You might have noticed that everything in the ALU looks like it can be implemented in combinatorial logic except these shift instructions. You can build <em>shift registers</em> out of flip-flops where the contents are shifted one bit position per clock.</p>
<p class="indent">A sequential shift register (shown in <a href="ch04.xhtml#ch04fig10">Figure 4-10</a>) is slow because it takes one clock per bit in the worst case.</p>
<div class="image"><a id="ch04fig10"/><img src="../images/04fig10.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-10: A sequential shift register</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_100"/>We can solve this by constructing a <em>barrel shifter</em> entirely out of combinatorial logic using one of our logic building blocks, the selector (refer back to <a href="ch02.xhtml#ch02fig47">Figure 2-47</a>). To build an 8-bit shifter, we would need eight of the 8:1 selectors.</p>
<p class="indent">There is one selector for each bit, as shown in <a href="ch04.xhtml#ch04fig11">Figure 4-11</a>.</p>
<div class="image"><a id="ch04fig11"/><img src="../images/04fig11.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-11: A combinatorial barrel shifter</em></p>
<p class="indent">The amount of right shift is provided on S<sub>0-2</sub>. You can see that with no shift (000 for S), input bit 0 (I<sub>0</sub>) gets passed to output bit 0 (O<sub>0</sub>), I<sub>1</sub> to O<sub>1</sub>, and so on. When S is 001, the outputs are shifted right by one because that’s the way the inputs are wired up to the selector. When S is 010, the outputs are shifted right by two, and so on. In other words, we have all eight possibilities wired and just select the one we want.</p>
<p class="indent">You may wonder why I keep showing these logic diagrams as if they’re built out of old 7400 series parts. Functions such as gates, multiplexors, demultiplexors, adders, latches, and so on are available as predefined components in integrated circuit design systems. They’re used just like the old components, except instead of sticking lots of the 7400 series parts I mentioned in <a href="ch02.xhtml#ch02">Chapter 2</a> onto a circuit board, we now assemble similar components into a single chip using design software.</p>
<p class="indent">You may have noticed the absence of multiplication and division operations in our simple ALU. That’s because they’re much more complicated and don’t really show us anything we haven’t already seen. You know that multiplication can be performed by repeated addition; that’s the sequential version. You can also build a combinatorial multiplier by cascading barrel shifters and adders, keeping in mind that a left shift multiplies a number by 2.</p>
<p class="indent">Shifters are a key element for the implementation of floating-point arithmetic; the exponents are used to shift the mantissas to line up the binary points so that they can be added together, subtracted, and so on.</p>
<h4 class="h4" id="ch04lev2sec3"><strong><em>Execution Unit</em></strong></h4>
<p class="noindent">The <em>execution unit</em> of a computer, also known as the <em>control unit</em>, is the boss. The ALU isn’t much use by itself, after all—something has to tell it what to do. The execution unit grabs opcodes and operands from the <span epub:type="pagebreak" id="page_101"/>right places in memory, tells the ALU what operations to perform, and puts the results back in memory. Hopefully, it does all that in an order that serves some useful purpose. (By the way, we’re using the “to perform” definition of <em>execute</em>. No bits are actually killed.)</p>
<p class="indent">How might the execution unit do this? We give it a list of instructions, things like “add the number in location 10 to the number in location 12 and put the result in location 14.” Where does the execution unit find these instructions? In memory! The technical name for what we have here is a <em>stored-program computer</em>. It has its genesis in work by English wizard Alan Turing (1912–1954).</p>
<p class="indent">That’s right, we have yet another way of looking at bits and interpreting them. <em>Instructions</em> are bit patterns that tell the computer what to do. The bit patterns are part of the design of a particular CPU. They’re not some general standard, like numbers, so an Intel Core i7 CPU would likely have a different bit pattern for the <code>inc A</code> instruction than an ARM Cortex-A CPU.</p>
<p class="indent">How does the execution unit know where to look for an instruction in memory? It uses a <em>program counter</em> (often abbreviated <em>PC</em>), which is sort of like a mail carrier, or like a big arrow labeled “You are here.” Shown in <a href="ch04.xhtml#ch04fig12">Figure 4-12</a>, the program counter is another register, one of those pieces of memory on the special side street. It’s constructed from a counter (see “<a href="ch03.xhtml#ch03lev2sec6">Counters</a>” on <a href="ch03.xhtml#page_77">page 77</a>) instead of a vanilla register (see “<a href="ch03.xhtml#ch03lev2sec7">Registers</a>” on <a href="ch03.xhtml#page_78">page 78</a>). You can view the counter as a register with additional counting functionality.</p>
<div class="image"><a id="ch04fig12"/><img src="../images/04fig12.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-12: A program counter</em></p>
<p class="indent">The program counter contains a memory address. In other words, it points at, or <em>references</em>, a location in memory. The execution unit fetches an instruction from the location referenced by the program counter. There are special instructions that change the value of the program counter, which we’ll see shortly. Unless we’re executing one of these, the program counter is <em>incremented</em> (that is, the size of one instruction is added to it) after the instruction is executed so that the next instruction will come from the next memory location. Note that CPUs have some initial program counter value, usually 0, when the power is turned on. The counter we saw in <a href="ch03.xhtml#ch03fig17">Figure 3-17</a> has inputs to support all these functions.</p>
<p class="indent"><span epub:type="pagebreak" id="page_102"/>It all works kind of like a treasure hunt. The computer goes to a certain place in memory and finds a note. It reads that note, which tells it to do something, and then goes someplace else to get the next note, and so on.</p>
<h3 class="h3" id="ch04lev1sec4"><strong>Instruction Set</strong></h3>
<p class="noindent">The notes that computers find in memory during their treasure hunt are called <em>instructions</em>. This section goes into what those instructions contain.</p>
<h4 class="h4" id="ch04lev2sec4"><strong><em>Instructions</em></strong></h4>
<p class="noindent">To see what sort of instructions might we find in a CPU, and how we choose bit patterns for them, our example assumes a computer with 16-bit-wide instructions.</p>
<p class="indent">Let’s try dividing our instruction into four fields—the opcode plus addresses for two operands and result—as shown in <a href="ch04.xhtml#ch04fig13">Figure 4-13</a>.</p>
<div class="image"><a id="ch04fig13"/><img src="../images/04fig13.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-13: Three-address instruction layout</em></p>
<p class="indent">This may seem like a good idea, but it doesn’t work very well. Why? Because we only have room for 4 bits of address for each of the operands and the result. It’s kind of hard to address a useful amount of memory when you have only 16 addresses. We could make the instruction bigger, but even if we went to 64-bit-wide instructions, we’d have only 20 bits of address, which would reach only a mebibyte of memory. Modern machines have gibibytes of memory.</p>
<p class="indent">Another approach would be to duplicate the DRAM addressing trick we saw in <a href="ch03.xhtml#ch03fig23">Figure 3-23</a>. We could have an <em>address extension register</em> and load it with the high-order address bits using a separate instruction. This technique was used by Intel to allow its 32-bit machines to access more than 4-GiB of memory. Intel called it PAE, for <em>physical address extension</em>. Of course, it takes extra time to load this register, and lots of register loads are required if we need memory on both sides of the boundary created by this approach.</p>
<p class="indent">There’s an even more important reason why the three-address format doesn’t work well, though: it counts on some magic, nonexistent form of memory that allows three different locations to be addressed at the same time. All three memory blocks in <a href="ch04.xhtml#ch04fig14">Figure 4-14</a> are the same memory device; there aren’t three address buses and three data buses.</p>
<span epub:type="pagebreak" id="page_103"/>
<div class="image"><a id="ch04fig14"/><img src="../images/04fig14.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-14: Unworkable computer architecture</em></p>
<p class="indent">We could make this work by having one register hold the contents of operand A and another hold the contents of operand B. The hardware would need to do the following:</p>
<ol>
<li class="noindent">Load the instruction from memory using the address in the program counter.</li>
<li class="noindent">Load the operand A register using the address from the operand A portion of the instruction.</li>
<li class="noindent">Load the operand B register using the address from the operand B portion of the instruction.</li>
<li class="noindent">Store the result in memory using the address from the result portion of the instruction.</li>
</ol>
<p class="indent">That’s a lot of complicated hardware. If each of these steps took a clock cycle, then it would take four cycles just to get something done. We should take a hint from the fact that we can access only one memory location at a time and design our instruction set accordingly. More address bits would be available if we tried to address only one thing at a time.</p>
<p class="indent">We can do that by adding another house to the register street. We’ll call this register the <em>accumulator</em>, or <em>A</em> register for short, and it will hold the result from the ALU. Rather than doing an operation between two memory locations, we’ll do it between one memory location and the accumulator. Of course, we’ll have to add a <em>store</em> instruction that stores the contents of the accumulator in a memory location. So now we can lay out our instructions as shown in <a href="ch04.xhtml#ch04fig15">Figure 4-15</a>.</p>
<div class="image"><a id="ch04fig15"/><img src="../images/04fig15.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-15: Single-address instruction layout</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_104"/>This gets us more address bits, but it takes more instructions to get things done. We used to be able to have an instruction that said:</p>
<p class="equation"><em>C</em> = <em>A</em> + <em>B</em></p>
<p class="indent">But now we need three instructions:</p>
<p class="equation">Accumulator = <em>A</em><br/>Accumulator = Accumulator + <em>B</em><br/><em>C</em> = Accumulator</p>
<p class="indent">You might notice that we just replaced one instruction with three, effectively making the instruction bigger and contradicting ourselves. That’s true for this simple case, but it’s not true in general. Let’s say we needed to calculate this:</p>
<p class="equation"><em>D</em> = <em>A</em> + <em>B</em> + <em>C</em></p>
<p class="indent">We couldn’t do that in a single instruction even if it could access three addresses because now we need four. We’d have to do it like this:</p>
<p class="equation">Intermediate = <em>A</em> + <em>B</em><br/><em>D</em> = Intermediate + <em>C</em></p>
<p class="indent">Sticking with 12 bits of address, we’d need 40-bit instructions to handle three address plus the opcode. And we’d need two of these instructions for a total of 80 bits to calculate <em>D</em>. Using the single-address version of the instructions requires four instructions for a total of 64 bits.</p>
<p class="equation">Accumulator = <em>A</em><br/>Accumulator = Accumulator + <em>B</em><br/>Accumulator = Accumulator + <em>C</em><br/><em>D</em> = Accumulator</p>
<h4 class="h4" id="ch04lev2sec5"><strong><em>Addressing Modes</em></strong></h4>
<p class="noindent">Using an accumulator managed to get us 12 address bits, and although being able to address 4,096 bytes is much better than 16, it’s still not enough. This way of addressing memory is known as <em>direct addressing</em>, which just means that the address is the one given in the instruction.</p>
<p class="indent">We can address more memory by adding <em>indirect addressing</em>. With indirect addressing, we get the address from the memory location contained in the instruction, rather than directly from the instruction itself. For example, let’s say memory location 12 contains the value 4,321, and memory location 4,321 contains 345. If we used direct addressing, loading from location 12 would get 4,321, while indirect addressing would get 345, the contents of location 4,321.</p>
<p class="indent">This is all fine for dealing with memory, but sometimes we just need to get constant numbers. For example, if we need to count to 10, we need some <span epub:type="pagebreak" id="page_105"/>way of loading that number. We can do this with yet another addressing mode, called <em>immediate mode addressing</em>. Here the address is just treated as a number, so, using the previous example, loading 12 in immediate mode would get 12. <a href="ch04.xhtml#ch04fig16">Figure 4-16</a> compares these addressing modes.</p>
<div class="image"><a id="ch04fig16"/><img src="../images/04fig16.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-16: Addressing modes</em></p>
<p class="indent">Clearly, direct addressing is slower than immediate addressing as it takes a second memory access. Indirect is slower still as it takes a third memory access.</p>
<h4 class="h4" id="ch04lev2sec6"><strong><em>Condition Code Instructions</em></strong></h4>
<p class="noindent">There are still a few things missing from our CPU, such as instructions that work with the condition codes. We’ve seen that these codes are set by addition, subtraction, and comparison. But we need some way of setting them to known values and some way of looking at the values. We can do that by adding a <code>cca</code> instruction that copies the contents of the condition code register to the accumulator and an <code>acc</code> instruction that copies the contents of the accumulator to the condition code register.</p>
<h4 class="h4" id="ch04lev2sec7"><strong><em>Branching</em></strong></h4>
<p class="noindent">Now we have instructions that can do all sorts of things, but all we can do is execute a list of them from start to finish. That’s not all that useful. We’d really like to have programs that can make decisions and select portions of code to execute. Those would take instructions that let us change the value of the program counter. These are called <em>branch</em> instructions, and they cause the program counter to be loaded with a new address. By itself, that’s not any more useful than just being able to execute a list of instructions. But branch instructions don’t always branch; they look at the condition codes and branch only if the conditions are met. Otherwise, the program counter is incremented normally, and the instruction following the branch instruction is executed next. Branch instructions need a few bits to hold the condition, as shown in <a href="ch04.xhtml#ch04tab02">Table 4-2</a>.</p>
<span epub:type="pagebreak" id="page_106"/>
<p class="tabcap" id="ch04tab02"><strong>Table 4-2:</strong> Branch Instruction Conditions</p>
<table class="topbot-d">
<colgroup>
<col style="width:10%"/>
<col style="width:10%"/>
<col style="width:80%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Code</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Mnemonic</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">bra</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Branch always.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>001</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">bov</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Branch if the O (overflow) condition code bit is set.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>010</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">beq</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Branch if the Z (zero) condition code bit is set.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>011</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">bne</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Branch if the Z condition code bit is not set.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">blt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Branch if N (negative) is set and Z is clear.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">ble</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Branch if N or Z is set.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>110</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">bgt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Branch if N is clear and Z is clear.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>111</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">bge</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Branch if N is clear or Z is set.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Sometimes we need to explicitly change the contents of the program counter. We have two special instructions to help with this: <code>pca</code>, which copies the current program counter value to the accumulator, and <code>apc</code>, which copies the contents of the accumulator to the program counter.</p>
<h4 class="h4" id="ch04lev2sec8"><strong><em>Final Instruction Set</em></strong></h4>
<p class="noindent">Let’s integrate all these features into our instruction set, as shown in <a href="ch04.xhtml#ch04fig17">Figure 4-17</a>.</p>
<div class="image"><a id="ch04fig17"/><img src="../images/04fig17.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-17: The final instruction layout</em></p>
<p class="indent">We have three <em>addressing modes</em>, which means that we need 2 bits in order to select the mode. The unused fourth-bit combination is used for operations that don’t involve memory.</p>
<p class="indent">The addressing mode and opcode decode into instructions, as you can see in <a href="ch04.xhtml#ch04tab03">Table 4-3</a>. Note that the branch conditions are merged into the opcodes. The opcodes for addressing mode 3 are used for operations that involve only the accumulator. A side effect of the complete implementation is that the opcodes don’t exactly match the ALU that we saw in <a href="ch04.xhtml#ch04tab01">Table 4-1</a>. This is not unusual and requires some additional logic.</p>
<span epub:type="pagebreak" id="page_107"/>
<p class="tabcap" id="ch04tab03"><strong>Table 4-3:</strong> Addressing Modes and Opcodes</p>
<table class="topbot-d">
<colgroup>
<col style="width:20%"/>
<col style="width:20%"/>
<col style="width:20%"/>
<col style="width:20%"/>
<col style="width:20%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: bottom;" class="tablel-h" rowspan="2"><p class="tab_thc"><strong>Opcode</strong></p></td>
<td style="vertical-align: top;" class="table-h" colspan="4"><p class="tab_thc"><strong>Addressing mode</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Direct (00)</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Indirect (01)</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Immediate (10)</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>None (11)</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>0000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">load</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">load</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">load</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"><code>0001</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">and</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">and</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">and</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">set</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>0010</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">or</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">or</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">ore</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">not</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"><code>0011</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">xor</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">xor</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">xor</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">neg</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>0100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">add</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">add</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">add</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">shl</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"><code>0101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">sub</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">sub</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">sub</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">shr</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>0110</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">cmp</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">cmp</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">cmp</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">acc</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"><code>0111</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">store</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">store</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">cca</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>1000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">bra</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">bra</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">bra</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">apc</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"><code>1001</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">bov</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">bov</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">bov</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">pca</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>1010</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">beq</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">beq</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">beq</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"><code>1011</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">bne</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">bne</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">bne</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>1100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">blt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">blt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">blt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"><code>1101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">ble</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">bge</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">ble</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"><code>1110</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">bgt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">bgt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">bgt</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-ba"><p class="tabac"><code>1111</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabac">bge</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabac">bge</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabac">bge</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabac"> </p></td>
</tr>
</tbody>
</table>
<p class="indent">The shift-left and shift-right instructions put some of the otherwise unused bits to use as a count of the number of positions to shift, as shown in <a href="ch04.xhtml#ch04fig18">Figure 4-18</a>.</p>
<div class="image"><a id="ch04fig18"/><img src="../images/04fig18.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-18: Shift instruction layout</em></p>
<p class="indent">Now we can actually instruct the computer to do something by writing a <em>program</em>, which is just a list of instructions that carry out some task. We’ll compute all Fibonacci (Italian mathematician, 1175–1250) numbers up to 200. Fibonacci numbers are pretty cool; the number of petals on flowers, for example, are Fibonacci numbers. The first two Fibonacci numbers are 0 and 1. We get the next one by adding them together. We keep adding the new number to the previous one to get the sequence, which is 0, 1, 1, 2, 3, 5, 8, 13, and so on. The process looks like <a href="ch04.xhtml#ch04fig19">Figure 4-19</a>.</p>
<span epub:type="pagebreak" id="page_108"/>
<div class="image"><a id="ch04fig19"/><img src="../images/04fig19.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-19: Flowchart for Fibonacci sequence program</em></p>
<p class="indent">The short program shown in <a href="ch04.xhtml#ch04tab04">Table 4-4</a> implements this process. The Instruction column is divided into fields as per <a href="ch04.xhtml#ch04fig17">Figure 4-17</a>. The addresses in the comments are decimal numbers.</p>
<p class="tabcap" id="ch04tab04"><strong>Table 4-4:</strong> Machine Language Program to Compute Fibonacci Sequence</p>
<table class="topbot-d">
<colgroup>
<col style="width:10%"/>
<col style="width:30%"/>
<col style="width:60%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Address</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Instruction</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>0000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>10 0000 0000000000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Clear the accumulator (load 0 immediate).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>0001</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>00 0111 0001100100</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Store the accumulator (0) in memory location 100.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>0010</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>10 0000 0000000001</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Load 1 into the accumulator (load 1 immediate).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>0011</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>00 0111 0001100101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Store the accumulator (1) in memory location 101.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>0100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>00 0000 0001100100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Load the accumulator from memory location 100.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>0101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>10 0100 0001100101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Add the contents of memory location 101 to the accumulator.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>0110</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>00 0111 0001100110</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Store the accumulator in memory location 102.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>0111</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>00 0000 0001100101</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Load the accumulator from memory location 101.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>1000</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>00 0111 0001100100</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Store it in memory location 100.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>1001</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>00 0000 0001100110</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Load the accumulator from memory location 102.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>1010</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"><code>00 0111 0001100101</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Store it in memory location 101.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>1011</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac"><code>10 0110 0011001000</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Compare the contents of the accumulator to the number 200.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-va"><p class="tabac"><code>1100</code></p></td>
<td style="vertical-align: top;" class="table-va"><p class="tabac"><code>00 0111 0000000100</code></p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba">Do another number if the last one was less than 200 by branching to address 4 (0100).</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch04lev1sec5"><span epub:type="pagebreak" id="page_109"/><strong>The Final Design</strong></h3>
<p class="noindent">Let’s put all the pieces that we’ve seen so far together into an actual computer. We’ll need a few pieces of “glue” to make it all work.</p>
<h4 class="h4" id="ch04lev2sec9"><strong><em>The Instruction Register</em></strong></h4>
<p class="noindent">You might be fooled into thinking that the computer just executes the Fibonacci program one instruction at a time. But more is happening behind the scenes. What does it take to execute an instruction? There’s a <em>state machine</em> doing the two-step, shown in <a href="ch04.xhtml#ch04fig20">Figure 4-20</a>.</p>
<div class="image"><a id="ch04fig20"/><img src="../images/04fig20.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-20: The fetch-execute cycle</em></p>
<p class="indent">The first thing that we have to do is to fetch an instruction from memory. Once we have that instruction, then we can worry about executing it.</p>
<p class="indent">Executing instructions usually involves accessing memory. That means we need someplace to keep the instruction handy while we’re using memory for some other task. In <a href="ch04.xhtml#ch04fig21">Figure 4-21</a>, we add an <em>instruction register</em> to our CPU to hold the current instruction.</p>
<div class="image"><a id="ch04fig21"/><img src="../images/04fig21.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-21: Adding an instruction register</em></p>
<h4 class="h4" id="ch04lev2sec10"><strong><em>Data Paths and Control Signals</em></strong></h4>
<p class="noindent">Here comes the complicated part. We need a way to feed the contents of the program counter to the memory address bus and a way to feed the memory data into the instruction register. We can do a similar exercise to determine all the different connections required to implement everything in our instruction set as detailed in <a href="ch04.xhtml#ch04tab04">Table 4-4</a>. We end up with <a href="ch04.xhtml#ch04fig22">Figure 4-22</a>, which probably seems confusing. But it’s really just things we’ve seen before: some registers, some selectors, the ALU, and a tri-state buffer.</p>
<p class="indent">Although this looks pretty complicated, it’s just like a road map. And it’s way simpler than a real city map. The address selector is just a three-way intersection, and the data selector is a four-way. There are connections hanging off of the address bus and data bus for things like the I/O devices that we’ll discuss in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>
<span epub:type="pagebreak" id="page_110"/>
<div class="image"><a id="ch04fig22"/><img src="../images/04fig22.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-22: Data paths and control signals</em></p>
<p class="indent">The only new part is the <em>indirect address register</em>. We need that because we need somewhere to hold indirect addresses fetched from memory, similar to how the instruction register holds instructions fetched from memory.</p>
<p class="indent">For simplicity, <a href="ch04.xhtml#ch04fig22">Figure 4-22</a> omits the system clock that goes to all of the registers and memory. In the simple register case, just assume the register is loaded on the next clock if enabled. Likewise, the program counter and memory do what their control signals tell them to do on each clock. All the other components, such as the selectors, are purely combinatorial and don’t use the clock.</p>
<h4 class="h4" id="ch04lev2sec11"><strong><em>Traffic Control</em></strong></h4>
<p class="noindent">Now that you’re familiar with all the inputs and outputs, it’s time to build our traffic control unit. Let’s look at a couple of examples of how it needs to behave.</p>
<p class="indent"><span epub:type="pagebreak" id="page_111"/>Fetching is common to all instructions. The following signals are involved:</p>
<ul>
<li class="noindent">The <code>address source</code> must be set to select the program counter.</li>
<li class="noindent">The memory must be enabled, and the read-write signal <code>r/<span class="bar">w</code></span> must be set to read (1).</li>
<li class="noindent">The instruction register must be enabled.</li>
</ul>
<p class="indent">For our next example, we’ll store the contents of the accumulator at the memory address pointed to by the address contained in the instruction—in other words, using indirect addressing. Fetching works as before.</p>
<p class="indent">Get the indirect address from memory:</p>
<ul>
<li class="noindent">The <code>address source</code> must be set to select the instruction register, which gets us the address portion of the instruction.</li>
<li class="noindent">Memory is enabled, and <code>r/<span class="bar">w</code></span> is set to read (1).</li>
<li class="noindent">The indirect address register is enabled.</li>
</ul>
<p class="indent">Store the accumulator in that address:</p>
<ul>
<li class="noindent">The <code>address source</code> must be set to select the indirect address register.</li>
<li class="noindent">The data bus <code>enable</code> must be set.</li>
<li class="noindent">Memory is enabled and <code>r/<span class="bar">w</code></span> is set to write (0).</li>
<li class="noindent">The program counter is incremented.</li>
</ul>
<p class="indent">Since multiple steps are involved in fetching and executing instructions, we need a counter to track them. The counter contents plus the opcode and mode portions of the instruction are all we need to generate all the control signals. We need 2 bits of counter because three states are needed to execute our most complicated instructions, as illustrated in <a href="ch04.xhtml#ch04fig23">Figure 4-23</a>.</p>
<div class="image"><a id="ch04fig23"/><img src="../images/04fig23.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-23: Random logic traffic control</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_112"/>This is a big box full of what’s called <em>random logic</em>. All the logic diagrams we’ve seen so far follow some regular pattern. Functional blocks, such as selectors and registers, are assembled from simpler blocks in a clear manner. Sometimes, such as when we’re implementing our traffic control unit, we have a set of inputs that must be mapped to a set of outputs to accomplish a task that has no regularity. The schematic looks like a rat’s nest of connections—hence the descriptor “random.”</p>
<p class="indent">But there’s another way we could implement our traffic control unit. Instead of random logic, we could use a hunk of memory. The address would be formed from the counter outputs plus the opcode and mode portions of the instruction, as shown in <a href="ch04.xhtml#ch04fig24">Figure 4-24</a>.</p>
<div class="image"><a id="ch04fig24"/><img src="../images/04fig24.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-24: Memory-based traffic control</em></p>
<p class="indent">Each 19-bit memory word is laid out as shown in <a href="ch04.xhtml#ch04fig25">Figure 4-25</a>.</p>
<div class="image"><a id="ch04fig25"/><img src="../images/04fig25.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-25: The layout of a microcode word</em></p>
<p class="indent">This might strike you as somewhat strange. On the one hand, it’s just another state machine implemented using memory instead of random logic. On the other, it sure looks like a simple computer. Both interpretations are correct. It is a state machine because computers are state machines. But it is also a computer because it’s programmable.</p>
<p class="indent">This type of implementation is called <em>microcoded</em>, and the contents of memory are called <em>microcode</em>. Yes, we’re using a small computer as part of the implementation of our larger one.</p>
<p class="indent">Let’s look at the portion of the <em>microinstructions</em>, shown in <a href="ch04.xhtml#ch04fig26">Figure 4-26</a>, that implement the examples we’ve discussed.</p>
<span epub:type="pagebreak" id="page_113"/>
<div class="image"><a id="ch04fig26"/><img src="../images/04fig26.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 4-26: Microcode example</em></p>
<p class="indent">As you might expect, it’s hard to avoid abusing a good idea. There are machines that have a <em>nanocoded</em> block that implements a <em>microcoded</em> block that implements the instruction set.</p>
<p class="indent">Using ROM for the microcode memory makes a certain amount of sense, because otherwise we’d need to keep a copy of the microcode somewhere else and we’d require additional hardware to load the microcode. However, there are situations where RAM, or a mix of ROM and RAM, is justified. Some Intel CPUs have writable microcode that can be patched to fix bugs. A few machines, such as the HP-2100 series, had a <em>writable control store</em>, which was microcode RAM that could be used to extend the basic instruction set.</p>
<p class="indent">Machines that have writable microcode today rarely permit users to modify it for several reasons. Manufacturers don’t want users to rely on microcode they themselves write for their applications because once users become dependent on it, manufacturers have difficulty making changes. Also, buggy microcode can damage the machine—for example, it could turn on both the memory <em>enable</em> and data bus <em>enable</em> at the same time in our CPU, connecting together totem-pole outputs in a way that might burn out the transistors.</p>
<h3 class="h3" id="ch04lev1sec6"><strong>RISC vs. CISC Instruction Sets</strong></h3>
<p class="noindent">Designers used to create instructions for computers that seemed to be useful but that resulted in some pretty complicated machines. In the 1980s, American computer scientists David Patterson at Berkeley and John Hennessey at Stanford did statistical analyses of programs and discovered that many of the complicated instructions were rarely used. They pioneered the design of machines that contained only the instructions that accounted for most of a program’s time; less used instructions were eliminated and replaced by combinations of other instructions. These were called <em>RISC</em> machines, for <em>reduced instruction set computers</em>. Older designs were called <em>CISC</em> machines, for <em>complicated instruction set computers</em>.</p>
<p class="indent">One of the hallmarks of RISC machines is that they have a <em>load-store architecture</em>. This means there are two categories of instructions: one for accessing memory and one for everything else.</p>
<p class="indent">Of course, computer use has changed over time. Patterson and Hennessey’s original statistics were done before computers were <span epub:type="pagebreak" id="page_114"/>commonly used for things like audio and video. Statistics on newer programs are prompting designers to add new instructions to RISC machines. Today’s RISC machines are actually more complicated than the CISC machines of yore.</p>
<p class="indent">One of the CISC machines that had a big impact was the PDP-11 from Digital Equipment Corporation. This machine had eight general-purpose registers instead of the single accumulator we used in our example. These registers could be used for indirect addressing. In addition, <em>autoincrement</em> and <em>autodecrement</em> modes were supported. These modes enabled the values in the registers to be incremented or decremented before or after use. This allowed for some very efficient programs. For example, let’s say we want to copy <em>n</em> bytes of memory starting at a source address to memory starting at a destination address. We can put the source address in register 0, the destination in register 1, and the count in register 2. We’ll skip the actual bits here because there’s no real need to learn the PDP-11 instruction set. <a href="ch04.xhtml#ch04tab05">Table 4-5</a> shows what these instructions do.</p>
<p class="tabcap" id="ch04tab05"><strong>Table 4-5:</strong> PDP-11 Copy Memory Program</p>
<table class="topbot-d">
<colgroup>
<col style="width:10%"/>
<col style="width:90%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Address</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Copy the contents of the memory location whose address is in register 0 to the memory location whose address is in register 1, then add 1 to each register.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Subtract 1 from the contents of register 2 and then compare the result to 0.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-va"><p class="taba">2</p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba">Branch to location 0 if the result was not 0.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Why should we care about this? The C programming language, a follow-on to B (which was a follow-on to BCPL), was developed on the PDP-11. C’s use of <em>pointers</em>, a higher-level abstraction of indirect addressing, combined with features from B such as the autoincrement and autodecrement operators, mapped well to the PDP-11 architecture. C became very influential and has affected the design of many other languages, including C++, Java, and JavaScript.</p>
<h3 class="h3" id="ch04lev1sec7"><strong>Graphics Processing Units</strong></h3>
<p class="noindent">You’ve probably heard about <em>graphics processing units</em>, or GPUs. These are mostly outside the scope of this book but are worth a quick mention.</p>
<p class="indent">Graphics is a massive paint-by-numbers exercise. It’s not uncommon to have 8 million color spots to paint and need to paint them 60 times per second if you want video to work well. That works out to around a half-billion memory accesses per second.</p>
<p class="indent">Graphics is specialized work and doesn’t require all the features of a general-purpose CPU. And it’s something that parallelizes nicely: painting multiple spots at a time can improve performance.</p>
<p class="indent"><span epub:type="pagebreak" id="page_115"/>Two features distinguish GPUs. First, they have large numbers of simple processors. Second, they have much wider memory buses than CPUs, which means they can access memory much faster. GPUs have a fire hose instead of a garden hose.</p>
<p class="indent">GPUs have acquired more general-purpose features over time. Work has been done to make them programmable using variants of standard programming languages, and they are now used for certain classes of applications that can take advantage of their architectures. GPUs were in short supply when this book was written because they were all being snapped up for Bitcoin mining.</p>
<h3 class="h3" id="ch04lev1sec8"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, we’ve created an actual computer using the building blocks introduced in previous chapters. Though simple, the machine we designed in this chapter could actually be built and programmed. It’s missing some elements found in real computers, however, such as stacks and memory management hardware. We’ll learn about those in <a href="ch05.xhtml#ch05">Chapter 5</a>.<span epub:type="pagebreak" id="page_116"/></p>
</body></html>