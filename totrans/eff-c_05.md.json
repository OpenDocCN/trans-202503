["```\na = 6;\n```", "```\nc = a + b;\n```", "```\n; // null statement, does nothing\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">++count;</samp>\n```", "```\n{\n  static int count = 0;\n  c += a;\n  ++count;\n}\n```", "```\nif (`expression`)\n  `substatement`\n```", "```\nbool safediv(int dividend, int divisor, int *quotient) {\n❶ if (!quotient) return false;\n❷ if ((divisor == 0) || ((dividend == INT_MIN) && (divisor == -1)))\n  ❸ return false;\n❹ *quotient = dividend / divisor;\n  return true;\n}\n```", "```\nif (`expression`)\n  `substatement1`\nelse\n  `substatement2`\n```", "```\nif (`expr1`)\n  `substatement1`\nelse if (`expr2`)\n  `substatement2`\nelse if (`expr3`)\n  `substatement3`\nelse\n  `substatement4`\n```", "```\nvoid printgrade(unsigned int marks) {\n  if (marks >= 90) {\n    puts(\"YOUR GRADE : A\");\n  } else if (marks >= 80) {\n    puts(\"YOUR GRADE : B\");\n  } else if (marks >= 70) {\n    puts(\"YOUR GRADE : C\");\n  } else {\n    puts(\"YOUR GRADE : Failed\");\n  }\n}\n```", "```\nif (condition)\n  conditionally_executed();\nunconditionally_executed(); // always executed\n```", "```\nif (condition)\n  conditionally_executed();\n  also_conditionally_executed(); // ????\nunconditionally_executed(); // always executed\n```", "```\nif (condition) {\n  conditionally_executed();\n  also_conditionally_executed(); // fixed it\n}\nunconditionally_executed(); // always executed\n```", "```\nif (condition) {\n  conditionally_executed();\n}\nunconditionally_executed(); // always executed\n```", "```\nif (!quotient) return false;\n```", "```\nswitch (marks/10) {\n  case 10:\n  case 9:\n    puts(\"YOUR GRADE : A\");\n    break;\n  case 8:\n    puts(\"YOUR GRADE : B\");\n    break;\n  case 7:\n    puts(\"YOUR GRADE : C\");\n    break;\n  default:\n    puts(\"YOUR GRADE : Failed\");\n}\n```", "```\ntypedef enum {Savings, Checking, MoneyMarket} AccountType;\nvoid assignInterestRate(AccountType account) {\n  double interest_rate;\n  switch (account) {\n    case Savings:\n      interest_rate = 3.0;\n      break;\n    case Checking:\n      interest_rate = 1.0;\n      break;\n    case MoneyMarket:\n      interest_rate = 4.5;\n      break;\n  }\n  printf(\"Interest rate = %g.\\n\", interest_rate);\n}\n```", "```\ntypedef enum {Savings, Checking, MoneyMarket, CD} AccountType;\n```", "```\ntypedef enum {Savings, Checking, MoneyMarket, CD} AccountType;\nvoid assignInterestRate(AccountType account) {\n  double interest_rate;\n  switch (account) {\n    case Savings:\n      interest_rate = 3.0;\n      break;\n    case Checking:\n      interest_rate = 1.0;\n      break;\n    case MoneyMarket:\n      interest_rate = 4.5;\n      break;\n    case CD:\n      interest_rate = 7.5;\n      break;\n **default: abort();**\n  }\n  printf(\"Interest rate = %g.\\n\", interest_rate);\n  return;\n}\n```", "```\nvoid f(unsigned int x) {\n  while (x > 0) {\n    printf(\"%d\\n,\" x);\n    --x;\n  }\n  return;\n}\n```", "```\nvoid *memset(void *dest, int val, size_t n) {\n  unsigned char *ptr = (unsigned char*)dest;\n  while (n-- > 0)\n    *ptr++ = (unsigned char)val;\n  return dest;\n}\n```", "```\ndo\n  `statement`\nwhile (`expression`);\n```", "```\n#include <stdio.h>\n// `--snip--`\nint count;\nfloat quant;\nchar units[21], item[21];\ndo {\n  count = fscanf(stdin, \"%f%20s of %20s\", &quant, units, item);\n  fscanf(stdin,\"%*[^\\n]\");\n} while (!feof(stdin) && !ferror(stdin));\n// `--snip--`\n```", "```\nfor (`clause1`; `expression2`; `expression3`)\n  `statement`\n```", "```\nvoid *memset(void *dest, int val, size_t n) {\n  unsigned char *ptr = (unsigned char *)dest;\n  for (❶ size_t i = 0; ❷ i < n; ❸ ++i) {\n *(ptr + i) = (unsigned char)val;\n  }\n  return dest;\n}\n```", "```\nstruct node {\n  int data;\n  struct node *next;\n};\nstruct node *p;\n```", "```\nfor (p = head; p != nullptr; p = p->next) {\n  free(p);\n}\n```", "```\np = head;\nwhile (p != nullptr) {\n  free(p);\n  p = p->next;\n}\n```", "```\nfor (p = head; p != nullptr; p = q) {\n  q = p->next;\n  free(p);\n}\n```", "```\n /* executed statements */\n  goto location;\n  /* skipped statements */\nlocation:\n  /* executed statements */\n```", "```\nint do_something(void) {\n  FILE *file1, *file2;\n  object_t *obj;\n  int ret_val = 0; // initially assume a successful return value\n\n  file1 = fopen(\"a_file\", \"w\");\n  if (file1 == nullptr) {\n    return -1;\n  }\n\n  file2 = fopen(\"another_file\", \"w\");\n  if (file2 == nullptr) {\n    ret_val = -1;\n **goto FAIL_FILE2;**\n  }\n\n  obj = malloc(sizeof(*obj));\n  if (obj == nullptr) {\n    ret_val = -1;\n **goto FAIL_OBJ;**\n  }\n\n  // operate on allocated resources\n\n  // clean up everything\n  free(obj);\n**FAIL_OBJ:**  // otherwise, close only the resources we opened\n  fclose(file2);\n**FAIL_FILE2:**\n  fclose(file1);\n  return ret_val;\n}\n```", "```\nwhile (/* _ */) {\n  // `--snip--`\n  continue;\n  // `--snip--`\nEND_LOOP_BODY: ;\n}\n```", "```\ndo {\n  // `--snip--`\n  continue;\n  // `--snip--`\nEND_LOOP_BODY: ;\n} while (/* _ */);\n```", "```\nfor (/* _ */) {\n  // `--snip--`\n  continue;\n  // `--snip--`\nEND_LOOP_BODY: ;\n}\n```", "```\n#include <stdio.h>\nint main(void) {\n  char c;\n  for(;;) {\n    puts(\"Press any key, Q to quit: \");\n    c = toupper(getchar());\n    if (c == 'Q') **break**;\n    // `--snip--`\n  }\n} // loop exits when either q or Q is pressed\n```", "```\nsize_t find_element(size_t len, int arr[len], int key) {\n  size_t pos = (size_t)-1;\n  // traverse arr and search for key\n  for (size_t i = 0; i < len; ++i) {\n if (arr[i] == key) {\n      pos = i;\n **break**;// terminate loop\n    }\n  }\n  return pos;\n}\n```", "```\nint sum(int x, int y, int z) {\n  return x + y + z;\n}\n```", "```\nint absolute_value(int a) {\n  if (a < 0) {\n    return -a;\n  }\n}\n```", "```\nint absolute_value(int a) {\n  if (a < 0) {\n    return -a;\n  }\n **return a;**\n}\n```"]