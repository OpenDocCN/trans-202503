<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;THE STRING INSTRUCTIONS"><div class="titlepage"><div><div><h1 class="title"><a id="the_string_instructions"/>Chapter 11. THE STRING INSTRUCTIONS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e51522"/><img alt="THE STRING INSTRUCTIONS" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>A <span class="emphasis"><em>string</em></span> is a collection of values stored in contiguous memory locations. Strings are usually arrays of bytes, words, or (on 80386 and later processors) double words. The 80x86 microprocessor family supports several instructions specifically designed to cope with strings. This chapter explores some of the uses of these string instructions.<a class="indexterm" id="IDX-CHP-11-0001"/><a class="indexterm" id="IDX-CHP-11-0002"/><a class="indexterm" id="IDX-CHP-11-0003"/><a class="indexterm" id="IDX-CHP-11-0004"/></p><p>The 80x86 CPUs can process three types of strings: byte strings, word strings, and double-word strings. They can move strings, compare strings, search for a specific value within a string, initialize a string to a fixed value, and do other primitive operations on strings. The 80x86's string instructions are also useful for manipulating arrays, tables, and records. You can easily assign or compare such data structures using the string instructions. Using string instructions may speed up your array-manipulation code considerably.<a class="indexterm" id="IDX-CHP-11-0005"/><a class="indexterm" id="IDX-CHP-11-0006"/><a class="indexterm" id="IDX-CHP-11-0007"/></p><div class="sect1" title="11.1 The 80x86 String Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="the_80x86_string_instructions"/>11.1 The 80x86 String Instructions</h1></div></div></div><p>All members of the 80x86 family support five different string instructions: <code class="literal">movs</code><em class="replaceable"><code>x</code></em>, <code class="literal">cmps</code><em class="replaceable"><code>x</code></em>, <code class="literal">scas</code><em class="replaceable"><code>x</code></em>, <code class="literal">lods</code><em class="replaceable"><code>x</code></em>, and <code class="literal">stosx</code>.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-1" id="CHP-11-FN-1">128</a>]</sup> (<em class="replaceable"><code>x</code></em> = <code class="literal">b</code>, <code class="literal">w</code>, or <code class="literal">d</code> for byte, word, or double word, respectively; this text will generally drop the <em class="replaceable"><code>x</code></em> suffix when talking about these string instructions in a general sense.) They are the string primitives on which you can build most other string operations. How you use these five instructions is the topic of the sections that follow.<a class="indexterm" id="IDX-CHP-11-0008"/><a class="indexterm" id="IDX-CHP-11-0009"/><a class="indexterm" id="IDX-CHP-11-0010"/><a class="indexterm" id="IDX-CHP-11-0011"/><a class="indexterm" id="IDX-CHP-11-0012"/><a class="indexterm" id="IDX-CHP-11-0013"/><a class="indexterm" id="IDX-CHP-11-0014"/><a class="indexterm" id="IDX-CHP-11-0015"/><a class="indexterm" id="IDX-CHP-11-0016"/><a class="indexterm" id="IDX-CHP-11-0017"/><a class="indexterm" id="IDX-CHP-11-0018"/><a class="indexterm" id="IDX-CHP-11-0019"/><a class="indexterm" id="IDX-CHP-11-0020"/><a class="indexterm" id="IDX-CHP-11-0021"/><a class="indexterm" id="IDX-CHP-11-0022"/><a class="indexterm" id="IDX-CHP-11-0023"/><a class="indexterm" id="IDX-CHP-11-0024"/><a class="indexterm" id="IDX-CHP-11-0025"/><a class="indexterm" id="IDX-CHP-11-0026"/><a class="indexterm" id="IDX-CHP-11-0027"/><a class="indexterm" id="IDX-CHP-11-0028"/><a class="indexterm" id="IDX-CHP-11-0029"/><a class="indexterm" id="IDX-CHP-11-0030"/><a class="indexterm" id="IDX-CHP-11-0031"/><a class="indexterm" id="IDX-CHP-11-0032"/><a class="indexterm" id="IDX-CHP-11-0033"/><a class="indexterm" id="IDX-CHP-11-0034"/><a class="indexterm" id="IDX-CHP-11-0035"/><a class="indexterm" id="IDX-CHP-11-0036"/><a class="indexterm" id="IDX-CHP-11-0037"/><a class="indexterm" id="IDX-CHP-11-0038"/></p><a id="I_programlisting11_d1e51744"/><pre class="programlisting">For MOVS:
     movsb();
     movsw();
     movsd();

For CMPS:
     cmpsb();
     cmpsw();
     cmpsd();

For SCAS:
     scasb();
     scasw();
     scasd();

For STOS:
     stosb();
     stosw();
     stosd();

For LODS:
     lodsb();
     lodsw();
     lodsd();</pre><div class="sect2" title="11.1.1 How the String Instructions Operate"><div class="titlepage"><div><div><h2 class="title"><a id="how_the_string_instructions_operate"/>11.1.1 How the String Instructions Operate</h2></div></div></div><p>The string instructions operate on blocks (contiguous linear arrays) of memory. For example, the <code class="literal">movs</code> instruction moves a sequence of bytes from one memory location to another. The <code class="literal">cmps</code> instruction compares two blocks of memory. The <code class="literal">scas</code> instruction scans a block of memory for a particular value. These string instructions often require three operands: a destination block address, a source block address, and (optionally) an element count. For example, when using the <code class="literal">movs</code> instruction to copy a string, you need a source address, a destination address, and a count (the number of string elements to move).</p><p>Unlike other instructions, which operate on memory, the string instructions don't have any explicit operands. The operands for the string instructions are as follows:<a class="indexterm" id="IDX-CHP-11-0039"/><a class="indexterm" id="IDX-CHP-11-0040"/><a class="indexterm" id="IDX-CHP-11-0041"/><a class="indexterm" id="IDX-CHP-11-0042"/><a class="indexterm" id="IDX-CHP-11-0043"/><a class="indexterm" id="IDX-CHP-11-0044"/><a class="indexterm" id="IDX-CHP-11-0045"/><a class="indexterm" id="IDX-CHP-11-0046"/><a class="indexterm" id="IDX-CHP-11-0047"/><a class="indexterm" id="IDX-CHP-11-0048"/><a class="indexterm" id="IDX-CHP-11-0049"/><a class="indexterm" id="IDX-CHP-11-0050"/><a class="indexterm" id="IDX-CHP-11-0051"/><a class="indexterm" id="IDX-CHP-11-0052"/><a class="indexterm" id="IDX-CHP-11-0053"/><a class="indexterm" id="IDX-CHP-11-0054"/><a class="indexterm" id="IDX-CHP-11-0055"/><a class="indexterm" id="IDX-CHP-11-0056"/><a class="indexterm" id="IDX-CHP-11-0057"/><a class="indexterm" id="IDX-CHP-11-0058"/><a class="indexterm" id="IDX-CHP-11-0059"/><a class="indexterm" id="IDX-CHP-11-0060"/><a class="indexterm" id="IDX-CHP-11-0061"/><a class="indexterm" id="IDX-CHP-11-0062"/><a class="indexterm" id="IDX-CHP-11-0063"/><a class="indexterm" id="IDX-CHP-11-0064"/><a class="indexterm" id="IDX-CHP-11-0065"/><a class="indexterm" id="IDX-CHP-11-0066"/><a class="indexterm" id="IDX-CHP-11-0067"/><a class="indexterm" id="IDX-CHP-11-0068"/><a class="indexterm" id="IDX-CHP-11-0069"/><a class="indexterm" id="IDX-CHP-11-0070"/><a class="indexterm" id="IDX-CHP-11-0071"/><a class="indexterm" id="IDX-CHP-11-0072"/><a class="indexterm" id="IDX-CHP-11-0073"/><a class="indexterm" id="IDX-CHP-11-0074"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ESI (source index) register</p></li><li class="listitem"><p>EDI (destination index) register</p></li><li class="listitem"><p>ECX (count) register</p></li><li class="listitem"><p>AL/AX/EAX register</p></li><li class="listitem"><p>The direction flag in the FLAGS register<a class="indexterm" id="IDX-CHP-11-0075"/><a class="indexterm" id="IDX-CHP-11-0076"/></p></li></ul></div><p>For example, one variant of the <code class="literal">movs</code> (move string) instruction copies ECX elements from the source address specified by ESI to the destination address specified by EDI. Likewise, the <code class="literal">cmps</code> instruction compares the string pointed at by ESI, of length ECX, to the string pointed at by EDI.</p><p>Not all string instructions have source and destination memory operands (only <code class="literal">movs</code> and <code class="literal">cmps</code> support them). For example, the <code class="literal">scas</code> instruction (scan a string) compares the value in the accumulator (AL, AX, or EAX) to values in memory.</p></div><div class="sect2" title="11.1.2 The rep/repe/repz and repnz/repne Prefixes"><div class="titlepage"><div><div><h2 class="title"><a id="the_rep_solidus_repe_solidus_repz_and_re"/>11.1.2 The rep/repe/repz and repnz/repne Prefixes</h2></div></div></div><p>The string instructions, by themselves, do not operate on strings of data. The <code class="literal">movs</code> instruction, for example, will only copy a single byte, word, or double word. When the <code class="literal">movs</code> instruction executes, it ignores the value in the ECX register. The repeat prefixes tell the 80x86 to do a multibyte string operation. The syntax for the repeat prefix is as follows:</p><a id="I_programlisting11_d1e51962"/><pre class="programlisting">For MOVS:
     rep.movsb();
     rep.movsw();
     rep.movsd();

For CMPS:
     repe.cmpsb();     // Note: repz is a synonym for repe.
     repe.cmpsw();
     repe.cmpsd();

     repne.cmpsb();    // Note: repnz is a synonym for repne.
     repne.cmpsw();
     repne.cmpsd();

For SCAS:
     repe.scasb();     // Note: repz is a synonym for repe.
     repe.scasw();
     repe.scasd();

     repne.scasb();    // Note: repnz is a synonym for repne.
     repne.scasw();
     repne.scasd();

For STOS:
     rep.stosb();
     rep.stosw();
     rep.stosd();</pre><p>You don't normally use the repeat prefixes with the <code class="literal">lods</code> instruction.<a class="indexterm" id="IDX-CHP-11-0077"/><a class="indexterm" id="IDX-CHP-11-0078"/><a class="indexterm" id="IDX-CHP-11-0079"/><a class="indexterm" id="IDX-CHP-11-0080"/><a class="indexterm" id="IDX-CHP-11-0081"/><a class="indexterm" id="IDX-CHP-11-0082"/></p><p>When specifying the repeat prefix before a string instruction, the string instruction repeats its operation ECX times.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-2" id="CHP-11-FN-2">129</a>]</sup> Without the repeat prefix, the instruction operates only on a single element (byte, word, or double word).</p><p>You can use repeat prefixes to process entire strings with a single instruction. You can use the string instructions, without the repeat prefix, as string primitive operations to synthesize more powerful string operations.</p></div><div class="sect2" title="11.1.3 The Direction Flag"><div class="titlepage"><div><div><h2 class="title"><a id="the_direction_flag"/>11.1.3 The Direction Flag</h2></div></div></div><p>In addition to the ESI, EDI, ECX, and AL/AX/EAX registers, one other register controls the operation of the 80x86's string instructions—the EFLAGs register. Specifically, the <span class="emphasis"><em>direction flag</em></span> in the flags register controls how the CPU processes strings.</p><p>If the direction flag is clear, the CPU increments ESI and EDI after operating on each string element. For example, executing <code class="literal">movs</code> will move the byte, word, or double word at ESI to EDI and will then increment ESI and EDI by 1, 2, or 4. When specifying the <code class="literal">rep</code> prefix before this instruction, the CPU increments ESI and EDI for each element in the string (the count in ECX specifies the number of elements). At completion, the ESI and EDI registers will be pointing at the first item beyond the strings.</p><p>If the direction flag is set, the 80x86 decrements ESI and EDI after it processes each string element (again, ECX specifies the number of string elements). After a repeated string operation, the ESI and EDI registers will be pointing at the first byte, word, or double word before the strings if the direction flag was set.</p><p>You can change the direction flag's value using the <code class="literal">cld</code> (clear direction flag) and <code class="literal">std</code> (set direction flag) instructions. When using these instructions inside a procedure, keep in mind that they modify the machine state. Therefore, you may need to save the direction flag during the execution of that procedure. The following example exhibits the kinds of problems you might encounter.</p><a id="I_programlisting11_d1e52033"/><pre class="programlisting">procedure Str2; @nodisplay;
begin Str2;

          std();
     &lt;&lt; Do some string operations. &gt;&gt;
          .
          .
          .
end Str2;
          .
          .
          .
          cld();
     &lt;&lt; Do some operations. &gt;&gt;
          Str2();
     &lt;&lt; Do some string operations requiring D=0. &gt;&gt;</pre><p>This code will not work properly. The calling code assumes that the direction flag is clear after <code class="literal">Str2</code> returns. However, this isn't true. Therefore, the string operations executed after the call to <code class="literal">Str2</code> will not function properly.<a class="indexterm" id="IDX-CHP-11-0083"/><a class="indexterm" id="IDX-CHP-11-0084"/></p><p>There are a couple of ways to handle this problem. The first, and probably the most obvious, is always to insert the <code class="literal">cld</code> or <code class="literal">std</code> instructions immediately before executing a sequence of one or more string instructions. This ensures that the direction flag is always set properly for your code. The other alternative is to save and restore the direction flag using the <code class="literal">pushfd</code> and <code class="literal">popfd</code> instructions. Using these two techniques, the code above would look like the following examples.</p><p>Always issuing <code class="literal">cld</code> or <code class="literal">std</code> before a string instruction:</p><a id="I_programlisting11_d1e52073"/><pre class="programlisting">procedure Str2; @nodisplay;
begin Str2;

          std();
     &lt;&lt; Do some string operations. &gt;&gt;
          .
          .
          .

end Str2;
          .
          .
          .
          cld();
     &lt;&lt; Do some operations. &gt;&gt;
          Str2();
          cld();
     &lt;&lt; Do some string operations requiring D=0. &gt;&gt;</pre><p>Saving and restoring the flags register:<a class="indexterm" id="IDX-CHP-11-0085"/><a class="indexterm" id="IDX-CHP-11-0086"/><a class="indexterm" id="IDX-CHP-11-0087"/><a class="indexterm" id="IDX-CHP-11-0088"/><a class="indexterm" id="IDX-CHP-11-0089"/><a class="indexterm" id="IDX-CHP-11-0090"/><a class="indexterm" id="IDX-CHP-11-0091"/></p><a id="I_programlisting11_d1e52105"/><pre class="programlisting">procedure Str2; @nodisplay;
begin Str2;

          pushfd();
          std();
     &lt;&lt; Do some string operations. &gt;&gt;
          .
          .
          .
          popfd();
end Str2;
          .

          .
          cld();
     &lt;&lt; Do some operations. &gt;&gt;
          Str2();
     &lt;&lt; Do some string operations requiring D=0. &gt;&gt;</pre><p>If you use the <code class="literal">pushfd</code> and <code class="literal">popfd</code> instructions to save and restore the flags register, keep in mind that you're saving and restoring all the flags. This makes it somewhat difficult to return information in other flag bits. For example, it's a bit of work to return an error condition in the carry flag if you use <code class="literal">pushfd</code> and <code class="literal">popfd</code> to preserve the direction flag in the procedure.</p><p>A third solution is to always ensure that the direction flag is clear except for the execution of a particular sequence that requires it to be set. For example, many library calls and some operating systems always assume that the direction flag is clear when you call them. Most standard C library functions work this way, for example. You can follow this convention by always assuming that the direction flag is clear, and then make sure you clear it immediately after a sequence that requires the use of <code class="literal">std</code>.</p></div><div class="sect2" title="11.1.4 The movs Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_movs_instruction"/>11.1.4 The movs Instruction</h2></div></div></div><p>The <code class="literal">movs</code> instruction uses the following syntax:<a class="indexterm" id="IDX-CHP-11-0092"/></p><a id="I_programlisting11_d1e52139"/><pre class="programlisting">movsb()
     movsw()
     movsd()
     rep.movsb()
     rep.movsw()
     rep.movsd()</pre><p>The <code class="literal">movsb</code> (move string, bytes) instruction fetches the byte at address ESI, stores it at address EDI, and then increments or decrements the ESI and EDI registers by 1. If the <code class="literal">rep</code> prefix is present, the CPU checks ECX to see if it contains 0. If not, then it moves the byte from ESI to EDI and decrements the ECX register. This process repeats until ECX becomes 0. If ECX contains 0 upon initial execution, the <code class="literal">movs</code> instruction will not copy any data bytes.</p><p>The <code class="literal">movsw</code> (move string, words) instruction fetches the word at address ESI, stores it at address EDI, and then increments or decrements ESI and EDI by 2. If there is a <code class="literal">rep</code> prefix, then the CPU repeats this procedure ECX times.</p><p>The <code class="literal">movsd</code> instruction operates in a similar fashion on double words. It increments or decrements ESI and EDI by 4 after each data movement.</p><p>When you use the <code class="literal">rep</code> prefix, the <code class="literal">movsb</code> instruction moves the number of bytes you specify in the ECX register. The following code segment copies 384 bytes from <code class="literal">CharArray1</code> to <code class="literal">CharArray2</code>:</p><a id="I_programlisting11_d1e52179"/><pre class="programlisting">CharArray1: byte[ 384 ];
     CharArray2: byte[ 384 ];
          .
          .
          .
          cld();
          lea( esi, CharArray1 );
          lea( edi, CharArray2 );
          mov( 384, ecx );
          rep.movsb();</pre><p>If you substitute <code class="literal">movsw</code> for <code class="literal">movsb</code>, then the preceding code will move 384 words (768 bytes) rather than 384 bytes:</p><a id="I_programlisting11_d1e52189"/><pre class="programlisting">WordArray1: word[ 384 ];
     WordArray2: word[ 384 ];
          .
          .
          .
          cld();
          lea( esi, WordArray1 );
          lea( edi, WordArray2 );
          mov( 384, ecx );
          rep.movsw();</pre><p>Remember, the ECX register contains the element count, not the byte count. When using the <code class="literal">movsw</code> instruction, the CPU moves the number of words specified in the ECX register. Similarly, <code class="literal">movsd</code> moves the number of double words you specify in the ECX register, not the number of bytes.</p><p>If you've set the direction flag before executing a <code class="literal">movsb/movsw/movsd</code> instruction, the CPU decrements the ESI and EDI registers after moving each string element. This means that the ESI and EDI registers must point at the last element of their respective strings before executing a <code class="literal">movsb</code>, <code class="literal">movsw</code>, or <code class="literal">movsd</code> instruction. For example:</p><a id="I_programlisting11_d1e52214"/><pre class="programlisting">CharArray1: byte[ 384 ];
     CharArray2: byte[ 384 ];
          .
          .
          .
          cld();
          lea( esi, CharArray1[383] );
          lea( edi, CharArray2[383] );
          mov( 384, ecx );
          rep.movsb();</pre><p>Although there are times when processing a string from tail to head is useful (see the <code class="literal">cmps</code> description in <a class="xref" href="ch11.html#the_cmps_instruction" title="11.1.5 The cmps Instruction">11.1.5 The cmps Instruction</a>), generally you'll process strings in the forward direction because that's more straightforward. There is one class of string operations where being able to process strings in both directions is absolutely mandatory: moving strings when the source and destination blocks overlap. Consider what happens in the following code:</p><a id="I_programlisting11_d1e52223"/><pre class="programlisting">CharArray1: byte;
     CharArray2: byte[ 384 ];
          .
          .
          .
          cld();
          lea( esi, CharArray1 );
          lea( edi, CharArray2 );
          mov( 384, ecx );
          rep.movsb();</pre><p>This sequence of instructions treats <code class="literal">CharArray1</code> and <code class="literal">CharArray2</code> as a pair of 384-byte strings. However, the last 383 bytes in the <code class="literal">CharArray1</code> array overlap the first 383 bytes in the <code class="literal">CharArray2</code> array. Let's trace the operation of this code byte by byte.</p><p>When the CPU executes the <code class="literal">movsb</code> instruction, it copies the byte at ESI (<code class="literal">CharArray1</code>) to the byte pointed at by EDI (<code class="literal">CharArray2</code>). Then it increments ESI and EDI, decrements ECX by 1, and repeats this process. Now the ESI register points at <code class="literal">CharArray1+1</code> (which is the address of <code class="literal">CharArray2</code>), and the EDI register points at <code class="literal">CharArray2+1</code>. The <code class="literal">movsb</code> instruction copies the byte pointed at by ESI to the byte pointed at by EDI. However, this is the byte originally copied from location <code class="literal">CharArray1</code>. So the <code class="literal">movsb</code> instruction copies the value originally in location <code class="literal">CharArray1</code> to both locations <code class="literal">CharArray2</code> and <code class="literal">CharArray2+1</code>. Again, the CPU increments ESI and EDI, decrements ECX, and repeats this operation. Now the <code class="literal">movsb</code> instruction copies the byte from location <code class="literal">CharArray1+2</code> (<code class="literal">CharArray2+1</code>) to location <code class="literal">CharArray2+2</code>. But once again, this is the value that originally appeared in location <code class="literal">CharArray1</code>. Each repetition of the loop copies the next element in <code class="literal">CharArray1[0]</code> to the next available location in the <code class="literal">CharArray2</code> array. Pictorially, it looks something like <a class="xref" href="ch11.html#copying_data_between_two_overlapping_arr" title="Figure 11-1. Copying data between two overlapping arrays (forward direction)">Figure 11-1</a>.<a class="indexterm" id="IDX-CHP-11-0093"/></p><p>The end result is that the <code class="literal">movsb</code> instruction replicates <code class="literal">X</code> throughout the string. The <code class="literal">movsb</code> instruction copies the source operand into the memory location, which will become the source operand for the very next move operation, which causes the replication.</p><div class="figure"><a id="copying_data_between_two_overlapping_arr"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject11_d1e52322"/><img alt="Copying data between two overlapping arrays (forward direction)" src="tagoreillycom20100401nostarchimages578075.png"/></div></div><p class="title">Figure 11-1. Copying data between two overlapping arrays (forward direction)</p></div><p>If you really want to move one array into another when they overlap like this, you should move each element of the source string to the destination string starting at the end of the two strings, as shown in <a class="xref" href="ch11.html#using_a_backward_copy_to_copy_data_in_ov" title="Figure 11-2. Using a backward copy to copy data in overlapping arrays">Figure 11-2</a>.</p><p>Setting the direction flag and pointing ESI and EDI at the end of the strings will allow you to (correctly) move one string to another when the two strings overlap and the source string begins at a lower address than the destination string. If the two strings overlap and the source string begins at a higher address than the destination string, then clear the direction flag and point ESI and EDI at the beginning of the two strings.</p><p>If the two strings do not overlap, then you can use either technique to move the strings around in memory. Generally, operating with the direction flag clear is the easiest, so that makes the most sense.</p><div class="figure"><a id="using_a_backward_copy_to_copy_data_in_ov"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject11_d1e52339"/><img alt="Using a backward copy to copy data in overlapping arrays" src="tagoreillycom20100401nostarchimages578077.png"/></div></div><p class="title">Figure 11-2. Using a backward copy to copy data in overlapping arrays</p></div><p>You shouldn't use the <code class="literal">movs</code><em class="replaceable"><code>x</code></em> instruction to fill an array with a single byte, word, or double-word value. Another string instruction, <code class="literal">stos</code>, is much better for this purpose. However, for arrays whose elements are 1, 2, or 4 bytes, you can use the <code class="literal">movs</code> instruction to initialize the entire array to the content of the first element.<a class="indexterm" id="IDX-CHP-11-0094"/><a class="indexterm" id="IDX-CHP-11-0095"/><a class="indexterm" id="IDX-CHP-11-0096"/></p><p>The <code class="literal">movs</code> instruction is sometimes more efficient when copying double words than it is copying bytes or words. On some systems, it typically takes the same amount of time to copy a byte using <code class="literal">movsb</code> as it does to copy a double word using <code class="literal">movsd</code>. Therefore, if you are moving a large number of bytes from one array to another, the copy operation will be faster if you can use the movsd instruction rather than the <code class="literal">movsb</code> instruction. If the number of bytes you wish to move is an even multiple of 4, this is a trivial change; just divide the number of bytes to copy by 4, load this value into ECX, and then use the <code class="literal">movsb</code> instruction. If the number of bytes is not evenly divisible by 4, then you can use the <code class="literal">movsd</code> instruction to copy all but the last 1, 2, or 3 bytes of the array (that is, the remainder after you divide the byte count by 4). For example, if you want to efficiently move 4,099 bytes, you can do so with the following instruction sequence.<a class="indexterm" id="IDX-CHP-11-0097"/></p><a id="I_programlisting11_d1e52394"/><pre class="programlisting">lea( esi, Source );
     lea( edi, Destination );
     mov( 1024, ecx );    // Copy 1024 dwords = 4096 bytes.
     rep.movsd();
     movsw();             // Copy bytes 4097 and 4098.
     movsb();             // Copy the last byte.</pre><p>Using this technique to copy data never requires more than three <code class="literal">movs</code><em class="replaceable"><code>x</code></em> instructions because you can copy 1, 2, or 3 bytes with no more than two <code class="literal">movsb</code> and <code class="literal">movsw</code> instructions. The scheme above is most efficient if the two arrays are aligned on double-word boundaries. If not, you might want to move the <code class="literal">movsb</code> or <code class="literal">movsw</code> instruction (or both) before the <code class="literal">movsd</code> so that the <code class="literal">movsd</code> instruction works with double-word-aligned data.</p><p>If you do not know the size of the block you are copying until the program executes, you can still use code like the following to improve the performance of a block move of bytes:</p><a id="I_programlisting11_d1e52424"/><pre class="programlisting">lea( esi, Source );
     lea( edi, Dest );
     mov( Length, ecx );
     shr( 2, ecx );     // Divide by 4.
     if( @nz ) then     // Only execute movsd if 4 or more bytes.

          rep.movsd();  // Copy the dwords.

     endif;
     mov( Length, ecx );
     and( %11, ecx );   // Compute (Length mod 4).
     if( @nz ) then     // Only execute movsb if #bytes/4 &lt;&gt; 0.

          rep.movsb();  // Copy the remaining 1, 2, or 3 bytes.

     endif;</pre><p>On many computer systems, the <code class="literal">movsd</code> instruction provides about the fastest way to copy bulk data from one location to another. While there are, arguably, faster ways to copy the data on certain CPUs, ultimately the memory bus performance is the limiting factor, and the CPUs are generally much faster than the memory bus. Therefore, unless you have a special system, writing fancy code to improve memory-to-memory transfers is probably a waste of time. Also note that Intel has improved the performance of the <code class="literal">movs</code><em class="replaceable"><code>x</code></em> instructions on later processors so that <code class="literal">movsb</code> operates almost as efficiently as <code class="literal">movsw</code> and <code class="literal">movsd</code> when copying the same number of bytes. Therefore, when working on a later 80x86 processor, it may be more efficient to simply use <code class="literal">movsb</code> to copy the specified number of bytes rather than go through all the complexity outlined above. The bottom line is this: If the speed of a block move matters to you, try it several different ways and pick the fastest (or the simplest, if they all run the same speed, which is likely).</p></div><div class="sect2" title="11.1.5 The cmps Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_cmps_instruction"/>11.1.5 The cmps Instruction</h2></div></div></div><p>The <code class="literal">cmps</code> instruction compares two strings. The CPU compares the string referenced by EDI to the string pointed at by ESI. ECX contains the length of the two strings (when using the <code class="literal">repe</code> or <code class="literal">repne</code> prefix). Like the <code class="literal">movs</code> instruction, HLA allows several different forms of this instruction:<a class="indexterm" id="IDX-CHP-11-0098"/><a class="indexterm" id="IDX-CHP-11-0099"/></p><a id="I_programlisting11_d1e52474"/><pre class="programlisting">cmpsb();
     cmpsw();
     cmpsd();

     repe.cmpsb();
     repe.cmpsw();
     repe.cmpsd();

     repne.cmpsb();
     repne.cmpsw();
     repne.cmpsd();</pre><p>As for the <code class="literal">movs</code> instruction, you specify the actual operand addresses in the ESI and EDI registers.</p><p>Without a repeat prefix, the <code class="literal">cmps</code> instruction subtracts the value at location EDI from the value at ESI and updates the flags. Other than updating the flags, the CPU doesn't use the difference produced by this subtraction. After comparing the two locations, <code class="literal">cmps</code> increments or decrements the ESI and EDI registers by 1, 2, or 4 (for <code class="literal">cmpsb/cmpsw/cmpsd</code>, respectively). <code class="literal">cmps</code> increments the ESI and EDI registers if the direction flag is clear and decrements them otherwise.</p><p>Of course, you will not tap the real power of the <code class="literal">cmps</code> instruction using it to compare single bytes, words, or double words in memory. This instruction shines when you use it to compare whole strings. With <code class="literal">cmps</code>, you can compare consecutive elements in a string until you find a match or until consecutive elements do not match.</p><p>To compare two strings to see if they are equal or not equal, you must compare corresponding elements in a string until they don't match. Consider the following strings:</p><a id="I_programlisting11_d1e52505"/><pre class="programlisting">"String1"
"String1"</pre><p>The only way to determine that these two strings are equal is to compare each character in the first string to the corresponding character in the second. After all, the second string could have been <code class="literal">String2</code>, which definitely is not equal to <code class="literal">String1</code>. Once you encounter a character in the destination string that does not equal the corresponding character in the source string, the comparison can stop. You needn't compare any other characters in the two strings.</p><p>The <code class="literal">repe</code> prefix accomplishes this operation. It will compare successive elements in a string as long as they are equal and ECX is greater than 0. We could compare the two strings above using the following 80x86 assembly language code:<a class="indexterm" id="IDX-CHP-11-0100"/></p><a id="I_programlisting11_d1e52525"/><pre class="programlisting">cld();
     mov( AdrsString1, esi );
     mov( AdrsString2, edi );
     mov( 7, ecx );
     repe.cmpsb();</pre><p>After the execution of the <code class="literal">cmpsb</code> instruction, you can test the flags using the standard (unsigned) conditional jump instructions. This lets you check for equality, inequality, less than, greater than, and so on.</p><p>Character strings are usually compared using <span class="emphasis"><em>lexicographical ordering</em></span>. In lexicographical ordering, the least significant element of a string carries the most weight. This is in direct contrast to standard integer comparisons, where the most significant portion of the number carries the most weight. Furthermore, the length of a string affects the comparison only if the two strings are identical up to the length of the shorter string. For example, <code class="literal">Zebra</code> is less than <code class="literal">Zebras</code> because it is the shorter of the two strings; however, <code class="literal">Zebra</code> is greater than <code class="literal">AAAAAAAAAAH!</code> even though <code class="literal">Zebra</code> is shorter. Lexicographical comparisons compare corresponding elements until encountering a character that doesn't match or until encountering the end of the shorter string. If a pair of corresponding characters do not match, then this algorithm compares the two strings based on that single character. If the two strings match up to the length of the shorter string, we must compare their length. The two strings are equal if and only if their lengths are equal and each corresponding pair of characters in the two strings are identical. Lexicographical ordering is the standard alphabetical ordering you've grown up with.<a class="indexterm" id="IDX-CHP-11-0101"/><a class="indexterm" id="IDX-CHP-11-0102"/></p><p>For character strings, use the <code class="literal">cmps</code> instruction in the following manner:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The direction flag must be cleared before comparing the strings.</p></li><li class="listitem"><p>Use the <code class="literal">cmpsb</code> instruction to compare the strings on a byte-by-byte basis. Even if the strings contain an even number of characters, you cannot use the <code class="literal">cmpsw</code> or <code class="literal">cmpsd</code> instructions. They do not compare strings in lexicographical order.</p></li><li class="listitem"><p>You must load the ECX register with the length of the smaller string.</p></li><li class="listitem"><p>Use the <code class="literal">repe</code> prefix.</p></li><li class="listitem"><p>The ESI and EDI registers must point at the very first character in the two strings you want to compare.</p></li></ul></div><p>After the execution of the <code class="literal">cmps</code> instruction, if the two strings were equal, their lengths must be compared in order to finish the comparison. The following code compares a couple of character strings:</p><a id="I_programlisting11_d1e52600"/><pre class="programlisting">mov( AdrsStr1, esi );
     mov( AdrsStr2, edi );
     mov( LengthSrc, ecx );
     if( ecx &gt; LengthDest ) then  // Put the length of the
                                  // shorter string in ecx.
          mov( LengthDest, ecx );

     endif;
     repe.cmpsb();
     if( @z ) then                // If equal to the length of the
                                  // shorter string, cmp lengths.
          mov( LengthSrc, ecx );
          cmp( ecx, LengthDest );

     endif;</pre><p>If you're using bytes to hold the string lengths, you should adjust this code appropriately (that is, use a <code class="literal">movzx</code> instruction to load the lengths into ECX). HLA strings use a double word to hold the current length value, so this isn't an issue when using HLA strings.</p><p>You can also use the <code class="literal">cmps</code> instruction to compare multiword integer values (that is, extended-precision integer values). Because of the amount of setup required for a string comparison, this isn't practical for integer values less than six or eight double words in length, but for large integer values, it's an excellent way to compare such values. Unlike for character strings, we cannot compare integer strings using lexicographical ordering. When comparing strings, we compare the characters from the least significant byte to the most significant byte. When comparing integers, we must compare the values from the most significant byte (or word/double word) down to the least significant byte, word, or double word. So, to compare two 32-byte (256-bit) integer values, use the following code on the 80x86:</p><a id="I_programlisting11_d1e52612"/><pre class="programlisting">std();
     lea( esi, SourceInteger[28] );
     lea( edi, DestInteger[28] );
     mov( 8, ecx );
     rep.cmpsd();</pre><p>This code compares the integers from their most significant dword down to the least significant dword. The <code class="literal">cmpsd</code> instruction finishes when the two values are unequal or upon decrementing ECX to 0 (implying that the two values are equal). Once again, the flags provide the result of the comparison.</p><p>The <code class="literal">repne</code> prefix will instruct the <code class="literal">cmps</code> instruction to compare successive string elements as long as they do not match. The 80x86 flags are of little use after the execution of this instruction. Either the ECX register is 0 (in which case the two strings are totally different), or it contains the number of elements compared in the two strings until a match is found. While this form of the <code class="literal">cmps</code> instruction isn't particularly useful for comparing strings, it is useful for locating the first pair of matching items in a couple of byte, word, or double-word arrays. In general, though, you'll rarely use the <code class="literal">repne</code> prefix with <code class="literal">cmps</code>.</p><p>One last thing to keep in mind with using the <code class="literal">cmps</code> instruction: The value in the ECX register determines the number of elements to process, not the number of bytes. Therefore, when using <code class="literal">cmpsw</code>, ECX specifies the number of words to compare. Likewise, for <code class="literal">cmpsd</code>, ECX contains the number of double words to process.<a class="indexterm" id="IDX-CHP-11-0103"/></p></div><div class="sect2" title="11.1.6 The scas Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_scas_instruction"/>11.1.6 The scas Instruction</h2></div></div></div><p>The <code class="literal">cmps</code> instruction compares two strings against each other. You do not use it to search for a particular element within a string. For example, you could not use the <code class="literal">cmps</code> instruction to quickly scan for a 0 throughout some other string. You can use the <code class="literal">scas</code> (scan string) instruction for this task.<a class="indexterm" id="IDX-CHP-11-0104"/></p><p>Unlike the <code class="literal">movs</code> and <code class="literal">cmps</code> instructions, the <code class="literal">scas</code> instruction requires only a destination string (pointed at by EDI) rather than both a source and destination string. The source operand is the value in the AL (scasb), AX (<code class="literal">scasw</code>), or EAX (<code class="literal">scasd</code>) register. The <code class="literal">scas</code> instruction compares the value in the accumulator (AL, AX, or EAX) against the value pointed at by EDI and then increments (or decrements) EDI by 1, 2, or 4. The CPU sets the flags according to the result of the comparison. While this might be useful on occasion, <code class="literal">scas</code> is a lot more useful when using the <code class="literal">repe</code> and <code class="literal">repne</code> prefixes.</p><p>With the <code class="literal">repe</code> prefix (repeat while equal), <code class="literal">scas</code> scans the string searching for an element that does not match the value in the accumulator. When using the <code class="literal">repne</code> prefix (repeat while not equal), <code class="literal">scas</code> scans the string, searching for the first string element that is equal to the value in the accumulator.</p><p>You're probably wondering, "Why do these prefixes do exactly the opposite of what they ought to do?" The preceding paragraphs haven't quite phrased the operation of the <code class="literal">scas</code> instruction properly. When using the <code class="literal">repe</code> prefix with <code class="literal">scas</code>, the 80x86 scans through the string while the value in the accumulator is equal to the string operand. This is equivalent to searching through the string for the first element that does not match the value in the accumulator. The <code class="literal">scas</code> instruction with <code class="literal">repne</code> scans through the string while the accumulator is not equal to the string operand. Of course, this form searches for the first value in the string that matches the value in the accumulator register. The <code class="literal">scas</code> instructions take the following forms:</p><a id="I_programlisting11_d1e52735"/><pre class="programlisting">scasb()
     scasw()
     scasd()

     repe.scasb()
     repe.scasw()
     repe.scasd()

     repne.scasb()
     repne.scasw()
     repne.scasd()</pre><p>Like the <code class="literal">cmps</code> and <code class="literal">movs</code> instructions, the value in the ECX register specifies the number of elements, not bytes, to process when using a repeat prefix.</p></div><div class="sect2" title="11.1.7 The stos Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_stos_instruction"/>11.1.7 The stos Instruction</h2></div></div></div><p>The <code class="literal">stos</code> instruction stores the value in the accumulator at the location specified by EDI. After storing the value, the CPU increments or decrements EDI depending on the state of the direction flag. Although the <code class="literal">stos</code> instruction has many uses, its primary use is to initialize arrays and strings to a constant value. For example, if you have a 256-byte array you want to clear out with zeros, use the following code:<a class="indexterm" id="IDX-CHP-11-0105"/><a class="indexterm" id="IDX-CHP-11-0106"/><a class="indexterm" id="IDX-CHP-11-0107"/><a class="indexterm" id="IDX-CHP-11-0108"/></p><a id="I_programlisting11_d1e52772"/><pre class="programlisting">cld();
     lea( edi, DestArray );
     mov( 64, ecx );          // 64 double words = 256 bytes.
     xor( eax, eax );         // Zero out eax.
     rep.stosd();</pre><p>This code writes 64 double words rather than 256 bytes because a single <code class="literal">stosd</code> operation is faster than four <code class="literal">stosb</code> operations.</p><p>The <code class="literal">stos</code> instructions take six forms. They are:</p><a id="I_programlisting11_d1e52787"/><pre class="programlisting">stosb();
     stosw();
     stosd();

     rep.stosb();
     rep.stosw();
     rep.stosd();</pre><p>The <code class="literal">stosb</code> instruction stores the value in the AL register into the specified memory location(s), the <code class="literal">stosw</code> instruction stores the AX register into the specified memory location(s), and the <code class="literal">stosd</code> instruction stores EAX into the specified location(s).</p><p>Keep in mind that the <code class="literal">stos</code> instruction is useful only for initializing a byte, word, or double-word array to a constant value. If you need to initialize an array with elements that have different values, you cannot use the <code class="literal">stos</code> instruction.</p></div><div class="sect2" title="11.1.8 The lods Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_lods_instruction"/>11.1.8 The lods Instruction</h2></div></div></div><p>The <code class="literal">lods</code> instruction is unique among the string instructions. You will probably never use a repeat prefix with this instruction. The <code class="literal">lods</code> instruction copies the byte, word, or double word pointed at by ESI into the AL, AX, or EAX register, after which it increments or decrements the ESI register by 1, 2, or 4. Repeating this instruction via the repeat prefix would serve almost no purpose whatsoever because the accumulator register will be overwritten each time the <code class="literal">lods</code> instruction repeats. At the end of the repeat operation, the accumulator will contain the last value read from memory.<a class="indexterm" id="IDX-CHP-11-0109"/></p><p>Instead, use the <code class="literal">lods</code> instruction to fetch bytes (<code class="literal">lodsb</code>), words (<code class="literal">lodsw</code>), or double words (<code class="literal">lodsd</code>) from memory for further processing. By using the <code class="literal">lods</code> and <code class="literal">stos</code> instructions, you can synthesize powerful string operations.</p><p>Like the <code class="literal">stos</code> instruction, the <code class="literal">lods</code> instructions take six forms:<a class="indexterm" id="IDX-CHP-11-0110"/></p><a id="I_programlisting11_d1e52859"/><pre class="programlisting">lodsb();
     lodsw();
     lodsd();

     rep.lodsb();
     rep.lodsw();
     rep.lodsd();</pre><p>As mentioned earlier, you'll rarely, if ever, use the <code class="literal">rep</code> prefixes with these instructions.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-3" id="CHP-11-FN-3">130</a>]</sup> The 80x86 increments or decrements ESI by 1, 2, or 4 depending on the direction flag and whether you're using the <code class="literal">lodsb</code>, <code class="literal">lodsw</code>, or <code class="literal">lodsd</code> instruction.</p></div><div class="sect2" title="11.1.9 Building Complex String Functions from lods and stos"><div class="titlepage"><div><div><h2 class="title"><a id="building_complex_string_functions_from_l"/>11.1.9 Building Complex String Functions from lods and stos</h2></div></div></div><p>The 80x86 supports only five different string instructions: <code class="literal">movs</code>, <code class="literal">cmps</code>, <code class="literal">scas</code>, <code class="literal">lods</code>, and <code class="literal">stos</code>.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-4" id="CHP-11-FN-4">131</a>]</sup> These certainly aren't the only string operations you'll ever want to use. However, you can use the <code class="literal">lods</code> and <code class="literal">stos</code> instructions to easily generate any particular string operation you like. For example, suppose you wanted a string operation that converts all the uppercase characters in a string to lowercase. You could use the following code:</p><a id="I_programlisting11_d1e52917"/><pre class="programlisting">mov( StringAddress, esi );  // Load string address into esi.
     mov( esi, edi );            // Also point edi here.
     mov( (type str.strRec [esi]).length, ecx );

     repeat

          lodsb();               // Get the next character in the string.
          if( al in 'A'..'Z' ) then

               or( $20, al );    // Convert uppercase to lowercase.

          endif;
          stosb();               // Store converted char into string.
          dec( ecx );

     until( @z );                // Zero flag is set when ecx is 0.</pre><p>Because the <code class="literal">lods</code> and <code class="literal">stos</code> instructions use the accumulator as an intermediary location, you can use any accumulator operation to quickly manipulate string elements.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-1" id="ftn.CHP-11-FN-1">128</a>] </sup>The 80x86 processor support two additional string instructions, <code class="literal">ins</code> and <code class="literal">outs</code>, which input strings of data from an input port or output strings of data to an output port. We will not consider these instructions because they are privileged instructions, and you cannot execute them in a standard 32-bit OS application.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-2" id="ftn.CHP-11-FN-2">129</a>] </sup>Except for the <code class="literal">cmps</code> instruction, which repeats <span class="emphasis"><em>at most</em></span> the number of times specified in the ECX register.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-3" id="ftn.CHP-11-FN-3">130</a>] </sup>They appear here simply because they are allowed. They're not very useful, but they are allowed. About the only use for this form of the instruction is to "touch" items in the cache so they are preloaded into the cache. However, there are better ways to accomplish this.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-4" id="ftn.CHP-11-FN-4">131</a>] </sup>Not counting <code class="literal">ins</code> and <code class="literal">outs</code>, which we're ignoring here.</p></div></div></div>
<div class="sect1" title="11.2 Performance of the 80x86 String Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="performance_of_the_80x86_string_instruct"/>11.2 Performance of the 80x86 String Instructions</h1></div></div></div><p>In the early 80x86 processors, the string instructions provided the most efficient way to manipulate strings and blocks of data. However, these instructions are not part of Intel's RISC Core instruction set, and as such, they can be slower than doing the same operations using discrete instructions. Intel has optimized the <code class="literal">movs</code> instruction on later processors so that it operates about as rapidly as possible, but the other string instructions can be fairly slow. As always, it's a good idea to implement performance-critical algorithms using different algorithms (with and without the string instructions) and compare their performance to determine which solution to use.<a class="indexterm" id="IDX-CHP-11-0111"/><a class="indexterm" id="IDX-CHP-11-0112"/></p><p>Keep in mind that the string instructions run at different speeds relative to other instructions depending on which processor you're using. Therefore, it's a good idea to try your experiments on the processors where you expect your code to run. Note that on most processors, the <code class="literal">movs</code> instruction is faster than the corresponding discrete instructions. Intel has worked hard to keep <code class="literal">movs</code> optimized because so much performance-critical code uses it.</p><p>Although the string instructions can be slower than discrete instructions, there is no question that the string instructions are generally more compact than the discrete code that achieves the same result.</p></div>
<div class="sect1" title="11.3 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id10"/>11.3 For More Information</h1></div></div></div><p>The HLA Standard Library contains hundreds of string and pattern-matching functions you may find useful. All of this appears in source form at <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> or <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a>; you should check out some of that source code if you want to see some examples of string instructions in action. Note also that some of the HLA Standard Library routines use discrete instructions to implement certain high-performance algorithms. You may want to look at that code as an example of such code. The 16-bit edition of this book (which appears on the website) discusses the implementation of several character-string functions using the 80x86 string instructions. Check out that edition for additional examples (those examples do not appear here because of the performance problems with the string instructions). Finally, for general information about string functions, check out the HLA Standard Library reference manual. It explains the operation of the string and pattern-matching functions found in the HLA Standard Library.</p></div></body></html>