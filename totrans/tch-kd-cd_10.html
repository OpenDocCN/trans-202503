<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Game Programming: Coding for Fun"><div class="titlepage"><div><div><h1 class="title"><a id="game_programming_coding_for_fun"/>Chapter 10. Game Programming: Coding for Fun</h1></div></div></div><p><a id="iddle1364" class="indexterm"/>In <a class="xref" href="ch09.html" title="Chapter 9. User Interaction: Get into the Game">Chapter 9</a>, we combined animation and user interaction to make a fun app. In this chapter, we’ll build on those concepts and add elements of game design to create a game from the ground up. We’ll combine our ability to draw animations on the screen with our ability to handle user interaction, like mouse movement, to create a classic Pong-type game we’ll call <span class="emphasis"><em>Smiley Pong</em></span>.</p><p><a id="iddle1369" class="indexterm"/><a id="iddle1668" class="indexterm"/>Games that we enjoy playing have certain <span class="emphasis"><em>elements of game design</em></span>. Here is a breakdown of our Smiley Pong design:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="A playing field or game board"><span class="title"><strong><span class="strong"><strong>A playing field or game board</strong></span></strong></span>. A black screen represents half a Ping-Pong board.</p></li><li class="listitem"><p title="Goals and achievements"><span class="title"><strong><span class="strong"><strong>Goals and achievements</strong></span></strong></span>. The player tries to score points and avoid losing lives.</p></li><li class="listitem"><p title="Playing pieces (game characters and objects)"><span class="title"><strong><span class="strong"><strong>Playing pieces (game characters and objects)</strong></span></strong></span>. The player has a ball and a paddle.</p></li><li class="listitem"><p title="Rules"><span class="title"><strong><span class="strong"><strong>Rules</strong></span></strong></span>. The player scores a point if the ball hits the paddle, but the player loses a life if the ball hits the bottom of the screen.</p></li><li class="listitem"><p title="Mechanics"><span class="title"><strong><span class="strong"><strong>Mechanics</strong></span></strong></span>. We’ll make the paddle move left and right with the mouse, defending the bottom of the screen; the ball may move faster as the game progresses.</p></li><li class="listitem"><p title="Resources"><span class="title"><strong><span class="strong"><strong>Resources</strong></span></strong></span>. The player will have five lives or turns to score as many points as they can.</p></li></ul></div><div class="informalfigure"><a id="med_id00129a"/><div class="mediaobject"><a id="med_id00129"/><img src="httpatomoreillycomsourcenostarchimages2189029.png.jpg" alt="image with no caption"/></div></div><p>Games use these elements to engage players. An effective game has a mix of these elements, making the game easy to play but challenging to win.</p><div class="sect1" title="Building a Game Skeleton: Smiley Pong, Version 1.0"><div class="titlepage"><div><div><h1 class="title"><a id="building_a_game_skeleton_smiley_pongcomm"/>Building a Game Skeleton: Smiley Pong, Version 1.0</h1></div></div></div><p>Pong, shown in <a class="xref" href="ch10.html#atariapostrophes_famous_pong_game_from_1" title="Figure 10-1. Atari’s famous Pong game from 1972">Figure 10-1</a>, was one of the earliest arcade video games, dating back to the 1960s and ’70s. More than 40 years later, it’s still fun to play.</p><div class="figure"><a id="atariapostrophes_famous_pong_game_from_1"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00130"/><img src="httpatomoreillycomsourcenostarchimages2189031.png.jpg" alt="Atari’s famous Pong game from 1972"/><div class="caption"><p><a id="iddle1669" class="indexterm"/><a id="iddle1886" class="indexterm"/><a id="iddle1892" class="indexterm"/><span class="emphasis"><em>Wikimedia Commons</em></span></p></div></div></div><p class="title">Figure 10-1. Atari’s famous Pong game from 1972</p></div><p>The gameplay for a single-player version of Pong is simple. A paddle moves along one edge of the screen (we’ll place our paddle at the bottom) and rebounds a ball, in our case a smiley face. Players gain a point each time they hit the ball, and they lose a point (or a life) every time they miss.</p><p>We’ll use our bouncing smiley face program from <a class="xref" href="ch08.html" title="Chapter 8. Timers and Animation: What Would Disney Do?">Chapter 8</a> as the foundation for the game. Using <span class="emphasis"><em>SmileyBounce2.py</em></span> (<a class="xref" href="ch08.html#putting_it_all_together-id00019" title="Putting It All Together">Putting It All Together</a>) as our base, we already have a smoothly animated smiley ball bouncing off the sides of the window, and we’ve already taken care of the <code class="literal">while</code> loop that keeps the animation going until the user quits. To make Smiley Pong, we’ll add a paddle that follows the mouse along the bottom of the screen, and we’ll add more collision detection to see when the smiley ball hits the paddle. The final touch will be to start with zero points and five lives, give the player a point when they hit the ball, and take away a life when the ball bounces off the bottom of the screen. <a class="xref" href="ch10.html#smiley_pong_game_weapostrophell_build" title="Figure 10-2. The Smiley Pong game we’ll build">Figure 10-2</a> shows what we’re working toward. When we’re finished, our final program will look like the one in <a class="xref" href="ch10.html#putting_it_all_together-id00029" title="Putting It All Together">Putting It All Together</a>.</p><div class="figure"><a id="smiley_pong_game_weapostrophell_build"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00131"/><img src="httpatomoreillycomsourcenostarchimages2189033.png.jpg" alt="The Smiley Pong game we’ll build"/></div></div><p class="title">Figure 10-2. The Smiley Pong game we’ll build</p></div><p><a id="iddle1367" class="indexterm"/><a id="iddle1893" class="indexterm"/>The first feature we’ll add to the former <span class="emphasis"><em>SmileyBounce2.py</em></span> app is the paddle.</p><div class="sect2" title="Drawing a Board and Game Pieces"><div class="titlepage"><div><div><h2 class="title"><a id="drawing_a_board_and_game_pieces"/>Drawing a Board and Game Pieces</h2></div></div></div><p>In our finished game, the paddle will move along the bottom of the screen, following the mouse’s movement as the user tries to keep the ball from hitting the bottom edge.</p><p>To get the paddle started, we’ll add this information to the setup section of our app:</p><a id="pro_id00167"/><pre class="programlisting">WHITE = (255,255,255)
paddlew = 200
paddleh = 25
paddlex = 300
paddley = 550</pre><p>These variables will help us create a paddle that is simply a white rectangle of width 200 and height 25. We’ll want the coordinates of its top-left corner to start at (300, 550) so that the paddle starts off slightly above the bottom edge and centered horizontally on the 800 × 600 screen.</p><p><a id="iddle1382" class="indexterm"/><a id="iddle1553" class="indexterm"/><a id="iddle2014" class="indexterm"/><a id="iddle2050" class="indexterm"/>But we’re not going to draw this rectangle yet. Those variables would be enough to draw a rectangle on the screen the first time, but our paddle needs to follow the user’s mouse movements. We want to draw the paddle on the screen centered around where the user moves the mouse in the <span class="emphasis"><em>x</em></span> direction (side to side), while keeping the y-coordinate fixed near the bottom of the screen. To do this, we need the x-coordinates of the mouse’s position. We can get the position of the mouse by using <code class="literal">pygame.mouse.get_pos()</code>. In this case, since we care only about the x-coordinate of <code class="literal">get_pos()</code>, and since <span class="emphasis"><em>x</em></span> comes first in our mouse position, we can get the x-coordinate of the mouse with this:</p><a id="pro_id00168"/><pre class="programlisting">paddlex = pygame.mouse.get_pos()[0]</pre><p>But remember that Pygame <span class="emphasis"><em>starts</em></span> drawing a rectangle at the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) position we provide, and it draws the rest of the rectangle to the right of and below that location. To center the paddle where the mouse is positioned, we need to subtract half the paddle’s width from the mouse’s x-position, putting the mouse halfway through the paddle:</p><a id="pro_id00169"/><pre class="programlisting">paddlex -= paddlew/2</pre><p>Now that we know the center of the paddle will always be where the mouse is, all we need to do in our game loop is to draw the paddle rectangle on the screen:</p><a id="pro_id00170"/><pre class="programlisting">pygame.draw.rect(screen, WHITE, (paddlex, paddley, paddlew, paddleh))</pre><p>If you add those three lines before the <code class="literal">pygame.display.update()</code> in the <code class="literal">while</code> loop in <span class="emphasis"><em>SmileyBounce2.py</em></span> and add the paddle color, <code class="literal">paddlew</code>, <code class="literal">paddleh</code>, <code class="literal">paddlex</code>, and <code class="literal">paddley</code> to the setup section, you’ll see the paddle follow your mouse. But the ball won’t bounce off the paddle yet because we haven’t added the logic to test whether the ball has collided with it. That’s our next step.</p></div><div class="sect2" title="Keeping Score"><div class="titlepage"><div><div><h2 class="title"><a id="keeping_score"/>Keeping Score</h2></div></div></div><p>Keeping score is part of what makes a game fun. Points, lives, stars—whatever you use to keep score, there’s a sense of achievement that comes from seeing your score increase. In our Smiley Pong game, we want the user to gain a point every time the ball hits the paddle and lose a life when they miss the ball and it hits <a id="iddle1374" class="indexterm"/><a id="iddle1844" class="indexterm"/><a id="iddle1894" class="indexterm"/>the bottom of the screen. Our next task is to add logic to make the ball bounce off the paddle and gain points, as well as to subtract a life when the ball hits the bottom of the screen. <a class="xref" href="ch10.html#as_the_smiley_ball_bounces_off_the_paddl" title="Figure 10-3. As the smiley ball bounces off the paddle at the bottom, we’ll add points to our player’s score.">Figure 10-3</a> shows what your game might look like after a player gains some points. Notice how the point display has been updated to 8.</p><div class="figure"><a id="as_the_smiley_ball_bounces_off_the_paddl"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00132"/><img src="httpatomoreillycomsourcenostarchimages2189035.png.jpg" alt="As the smiley ball bounces off the paddle at the bottom, we’ll add points to our player’s score."/></div></div><p class="title">Figure 10-3. As the smiley ball bounces off the paddle at the bottom, we’ll add points to our player’s score.</p></div><p>As mentioned earlier, we’ll start our game with zero points and five lives in the setup portion of our code:</p><a id="pro_id00171"/><pre class="programlisting">points = 0
lives = 5</pre><p>Next we have to figure out when to add to <code class="literal">points</code> and when to take away from <code class="literal">lives</code>.</p><div class="sect3" title="Subtracting a Life"><div class="titlepage"><div><div><h3 class="title"><a id="subtracting_a_life"/>Subtracting a Life</h3></div></div></div><p>Let’s start with subtracting a life. We know that if the ball hits the bottom edge of the screen, the player has missed it with the paddle, so they should lose a life.</p><p><a id="iddle1069" class="indexterm"/><a id="iddle1178" class="indexterm"/><a id="iddle1371" class="indexterm"/>To add the logic for subtracting a life when the ball hits the bottom of the screen, we have to break our <code class="literal">if</code> statement for hitting the top <span class="emphasis"><em>or</em></span> bottom of the screen (<code class="literal">if picy &lt;= 0 or picy &gt;= 500</code>) into two parts, top and bottom separately. If the ball hits the top of the screen (<code class="literal">picy &lt;= 0</code>), we just want it to bounce back, so we’ll change the direction of the ball’s speed in the <span class="emphasis"><em>y</em></span> direction with <code class="literal">-speedy</code>:</p><a id="pro_id00172"/><pre class="programlisting"><span class="orange">if</span> picy &lt;= 0:
    speedy = -speedy</pre><p>If the ball bounces off the bottom (<code class="literal">picy &gt;= 500</code>), we want to deduct a life from <code class="literal">lives</code> and then have the ball bounce back:</p><a id="pro_id00173"/><pre class="programlisting"><span class="orange">if</span> picy &gt;= 500:
    lives -= 1
    speedy = -speedy</pre><p>Subtracting a life is done, so now we need to add points. In <a class="xref" href="ch09.html#smileypopcomma_version_1dot0" title="SmileyPop, Version 1.0">SmileyPop, Version 1.0</a>, we saw that Pygame contains functions that make it easier to check for collisions. But since we’re building this Smiley Pong game from scratch, let’s see how we can write our own code to check for collisions. The code might come in handy in a future app, and writing it is a valuable problem-solving exercise.</p></div><div class="sect3" title="Hitting the Ball with the Paddle"><div class="titlepage"><div><div><h3 class="title"><a id="hitting_the_ball_with_the_paddle"/>Hitting the Ball with the Paddle</h3></div></div></div><p>To check for the ball bouncing off the paddle, we need to look at how the ball might come into contact with the paddle. It could hit the top-left corner of the paddle, it could hit the top-right corner of the paddle, or it could bounce directly off the top of the paddle.</p><div class="informalfigure"><a id="med_id00133a"/><div class="mediaobject"><a id="med_id00133"/><img src="httpatomoreillycomsourcenostarchimages2189037.png.jpg" alt="image with no caption"/></div></div><p>When you’re figuring out the logic for detecting collisions, it helps to draw it out on paper and label the corners and edges where you need to check for a possible collision. <a class="xref" href="ch10.html#two_collision_cases_between_the_paddle_a" title="Figure 10-4. Two collision cases between the paddle and our smiley ball">Figure 10-4</a> shows a sketch of the paddle and the two corner collision cases with the ball.</p><div class="figure"><a id="two_collision_cases_between_the_paddle_a"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00134"/><img src="httpatomoreillycomsourcenostarchimages2189039.png.jpg" alt="Two collision cases between the paddle and our smiley ball"/></div></div><p class="title">Figure 10-4. Two collision cases between the paddle and our smiley ball</p></div><p><a id="iddle1070" class="indexterm"/><a id="iddle1179" class="indexterm"/><a id="iddle1895" class="indexterm"/>Because we want the ball to bounce realistically off the paddle, we want to check for the cases where the bottom center of the ball just touches the corners of the paddle at the left and right extremes. We want to make sure the player scores a point not only when the ball bounces directly off the top of the paddle but also whenever it bounces off the paddle’s corners. To do this, we’ll see if the ball’s vertical location is near the bottom of the screen where the paddle is, and if so, we’ll check whether the ball’s horizontal location would allow it to hit the paddle.</p><p>First, let’s figure out what range of x-coordinate values would allow the ball to hit the paddle. Since the middle of the ball would be half the width of the ball across from its <code class="literal">(picx, picy)</code> top-left corner, we’ll add the width of the ball as a variable in the setup section of our app:</p><a id="pro_id00174"/><pre class="programlisting">picw = 100</pre><p>As shown in <a class="xref" href="ch10.html#two_collision_cases_between_the_paddle_a" title="Figure 10-4. Two collision cases between the paddle and our smiley ball">Figure 10-4</a>, the ball could hit the top-left corner of the paddle when <code class="literal">picx</code> plus half the width of the picture (<code class="literal">picw/2</code>) touches <code class="literal">paddlex</code>, the x-coordinate of the left corner of the paddle. In code, we could test this condition as part of an <code class="literal">if</code> statement: <code class="literal">picx + picw/2 &gt;= paddlex</code>.</p><p>We use the <span class="emphasis"><em>greater than or equal to</em></span> condition because the ball can be farther right (greater than <code class="literal">paddlex</code> in the <span class="emphasis"><em>x</em></span> direction) and still hit the paddle; the corner case is just the first pixel for which the player gets a point for hitting the paddle. All the x-coordinate values between the left corner and the right corner of the paddle are valid hits, so they should award the user a point and bounce the ball back.</p><p>To find that top-right corner case, we can see from the figure that we’re requiring the middle of the ball, whose x-coordinate <a id="iddle1425" class="indexterm"/>is <code class="literal">picx + picw/2</code>, to be less than or equal to the top-right corner of the paddle, whose x-coordinate is <code class="literal">paddlex + paddlew</code> (or the starting x-coordinate of the paddle plus the paddle’s width). In code, this would be <code class="literal">picx + picw/2 &lt;= paddlex + paddlew</code>.</p><p>We can put these two together into a single <code class="literal">if</code> statement, but that’s not quite enough. Those x-coordinates cover the whole screen from the left corner of the paddle to the right corner, from the top of the screen to the bottom. With just the x-coordinates determined, our ball could be anywhere in the <span class="emphasis"><em>y</em></span> direction, so we need to narrow that down. It’s not enough to know that our ball is within the <span class="emphasis"><em>horizontal</em></span> limits of the paddle; we also have to know that our ball is within the <span class="emphasis"><em>vertical</em></span> range of y-coordinate values that could allow it to collide with the paddle.</p><p>We know that the top of our paddle is located at 550 pixels in the <span class="emphasis"><em>y</em></span> direction, near the bottom of the screen, because our setup includes the line <code class="literal">paddley = 550</code> and the rectangle begins at that y-coordinate and continues down for 25 pixels, our paddle’s height stored in <code class="literal">paddleh</code>. We know our picture is 100 pixels tall, so let’s store that as a variable, <code class="literal">pich</code> (for picture height), that we can add to our setup section: <code class="literal">pich = 100</code>.</p><p>For our ball’s y-coordinate to hit the paddle, the <code class="literal">picy</code> location plus the picture’s height, <code class="literal">pich</code>, needs to be at least <code class="literal">paddley</code> or greater for the bottom of the picture (<code class="literal">picy + pich</code>) to touch the top of the paddle (<code class="literal">paddley</code>). Part of our <code class="literal">if</code> statement for the ball hitting the paddle in the <span class="emphasis"><em>y</em></span> direction would be <code class="literal">if picy + pich &gt;= paddley</code>. But this condition alone would allow the ball to be anywhere greater than <code class="literal">paddley</code>, even at the bottom edge of the screen. We don’t want the user to be able to get points for moving the paddle into the ball after the ball has hit the bottom edge, so we need another <code class="literal">if</code> condition that sets the maximum y-coordinate value we’ll give points for.</p><div class="informalfigure"><a id="med_id00135a"/><div class="mediaobject"><a id="med_id00135"/><img src="httpatomoreillycomsourcenostarchimages2189041.png.jpg" alt="image with no caption"/></div></div><p>A natural choice for the maximum y-coordinate value for earning a point might be the bottom of the paddle, or <code class="literal">paddley + paddleh</code> (the paddle’s y-coordinate, plus its height). But if the bottom of our ball is past the bottom of the paddle, the player shouldn’t get a point for hitting the ball, so we want <code class="literal">picy + pich</code> (the bottom of the ball) to be less than or equal to <code class="literal">paddley + paddleh</code>—in other words, <code class="literal">picy + pich &lt;= paddley + paddleh</code>.</p><p><a id="iddle1005" class="indexterm"/><a id="iddle1102" class="indexterm"/><a id="iddle1366" class="indexterm"/><a id="iddle1842" class="indexterm"/>There’s just one more condition to check. Remember that the ball and paddle are virtual; that is, they don’t exist in the real world, don’t have actual edges, and don’t interact like real game pieces do. We could move our paddle through the ball even when it’s bouncing back up from the bottom edge. We don’t want to award points when the player has clearly missed the ball, so before awarding a point, let’s check to make sure the ball is headed down, in addition to being within the vertical and horizontal range of the paddle. We can tell the ball is headed down the screen if the ball’s speed in the <span class="emphasis"><em>y</em></span> direction (<code class="literal">speedy</code>) is greater than zero. When <code class="literal">speedy &gt; 0</code>, the ball is moving down the screen in the positive <span class="emphasis"><em>y</em></span> direction.</p><p>We now have the conditions we need to create the two <code class="literal">if</code> statements that will check whether the ball hit the paddle:</p><a id="pro_id00175"/><pre class="programlisting"><span class="orange">if</span> picy + pich &gt;= paddley <span class="orange">and</span> picy + pich &lt;= paddley + paddleh \
   <span class="orange">and</span> speedy &gt; 0:
    <span class="orange">if</span> picx + picw/2 &gt;= paddlex <span class="orange">and</span> picx + picw/2 &lt;= paddlex + \
       paddlew:</pre><p>First, we check whether the ball is within the vertical range to be able to touch the paddle and whether it’s heading downward instead of upward. Then, we check whether the ball is within the horizontal range to be able to touch the paddle.</p><p>In both of these <code class="literal">if</code> statements, the compound conditions made the statement too long to fit on our screen. The backslash character, <code class="literal">\</code>, allows us to continue a long line of code by wrapping around to the next line. You can choose to type a long line of code all on a single line, or you can wrap the code to fit the screen by ending the first line with a backslash <code class="literal">\</code>, pressing ENTER, and continuing the code on the next line. We have some long lines of logic in the games in this chapter, so you’ll see the backslash in several of the code listings. Just remember that Python will read any lines separated by a backslash as a single line of code.</p></div><div class="sect3" title="Adding a Point"><div class="titlepage"><div><div><h3 class="title"><a id="adding_a_point"/>Adding a Point</h3></div></div></div><p>Let’s build the logic to bounce the ball and award a point. To complete our paddle logic, we add two more lines right after the two <code class="literal">if</code> statements:</p><a id="pro_id00176"/><pre class="programlisting"><span class="orange">if</span> picy + pich &gt;= paddley <span class="orange">and</span> picy + pich &lt;= paddley + paddleh \
   <span class="orange">and</span> speedy &gt; 0:
<span class="orange">if</span> picx + picw/2 &gt;= paddlex <span class="orange">and</span> picx + picw/2 &lt;= paddlex + \
   paddlew:
    points += 1
    speedy = -speedy</pre><p><a id="iddle1368" class="indexterm"/><a id="iddle1843" class="indexterm"/><a id="iddle1896" class="indexterm"/>Adding a point is easy: <code class="literal">points += 1</code>. Changing the direction of the ball so it looks like it bounced off the paddle is easy too; we just reverse our speed in the <span class="emphasis"><em>y</em></span> direction to make it go back up the screen: <code class="literal">speedy = -speedy</code>.</p><p>You can run the program with those changes and see the ball bounce off the paddle. Each time the paddle hits the ball, you’re earning a point, and whenever the ball misses the paddle, you’re losing a life, but we’re not showing those on the screen yet. Let’s do that next.</p></div></div><div class="sect2" title="Showing the Score"><div class="titlepage"><div><div><h2 class="title"><a id="showing_the_score"/>Showing the Score</h2></div></div></div><p>We have the logic we need to add points and subtract lives, but we don’t see the points on the screen as we play. In this section, we’ll draw text to the screen to give the user feedback while they’re playing, as shown in <a class="xref" href="ch10.html#smiley_pongcomma_version_1dot0comma_is_b" title="Figure 10-5. Smiley Pong, version 1.0, is becoming a real game!">Figure 10-5</a>.</p><div class="figure"><a id="smiley_pongcomma_version_1dot0comma_is_b"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00136"/><img src="httpatomoreillycomsourcenostarchimages2189043.png.jpg" alt="Smiley Pong, version 1.0, is becoming a real game!"/></div></div><p class="title">Figure 10-5. Smiley Pong, version 1.0, is becoming a real game!</p></div><p><a id="iddle1269" class="indexterm"/><a id="iddle1324" class="indexterm"/><a id="iddle1800" class="indexterm"/><a id="iddle1938" class="indexterm"/><a id="iddle1959" class="indexterm"/><a id="iddle2008" class="indexterm"/>The first step is putting together the string of text that we want to display. In a typical video game, we’d see our points and how many lives or turns we have left— for example, <span class="emphasis"><em>Lives: 4, Points: 32</em></span>. We already have variables with the number of lives (<code class="literal">lives</code>) and total points (<code class="literal">points</code>). All we have to do is use the <code class="literal">str()</code> function to turn those numbers into their text equivalent (<code class="literal">5</code> becomes <code class="literal">"5"</code>) and add text to indicate what the numbers mean in each pass through our game loop:</p><div class="informalfigure"><a id="med_id00137a"/><div class="mediaobject"><a id="med_id00137"/><img src="httpatomoreillycomsourcenostarchimages2189045.png.jpg" alt="image with no caption"/></div></div><a id="pro_id00177"/><pre class="programlisting">draw_string = <span class="green">"Lives: "</span> + <span class="violet">str</span>(lives) + <span class="green">" Points: "</span> + <span class="violet">str</span>(points)</pre><p>Our string variable will be called <code class="literal">draw_string</code>, and it contains the text we’d like to draw on the screen to display to users as they play. To draw that text on the screen, we need to have an object or variable that is connected to the text-drawing module <code class="literal">pygame.font</code>. A <span class="emphasis"><em>font</em></span> is another name for a <span class="emphasis"><em>typeface</em></span>, or the style characters are drawn in, like Arial or Times New Roman. In the setup section of your app, add the following line:</p><a id="pro_id00178"/><pre class="programlisting">font = pygame.font.SysFont(<span class="green">"Times"</span>, 24)</pre><p>This creates a variable we’ll call <code class="literal">font</code> that will allow us to draw on the Pygame display in 24-point Times. You can make your text larger or smaller, but for now, 24 points will work. Next we’ll draw the text; that should be added into the game loop, right after our <code class="literal">draw_string</code> declaration. To draw the text on the window, we first draw the string on a surface of its own with the <code class="literal">render()</code> command on the <code class="literal">font</code> object we created:</p><a id="pro_id00179"/><pre class="programlisting">text = font.render(draw_string, <span class="orange">True</span>, WHITE)</pre><p>This creates a variable called <code class="literal">text</code> to store a surface that contains the white pixels that make up all the letters, numbers, and symbols of our string. The next step will get the dimensions (width and height) of that surface. Longer strings will render or draw wider, while shorter strings will take fewer pixels to draw. The <a id="iddle1109" class="indexterm"/><a id="iddle1384" class="indexterm"/>same goes for larger fonts versus smaller fonts. The text string will be rendered on a rectangular surface, so we’ll call our variable <code class="literal">text_rect</code> for the rectangle that holds our drawn string:</p><a id="pro_id00180"/><pre class="programlisting">text_rect = text.get_rect()</pre><p>The <code class="literal">get_rect()</code> command on our <code class="literal">text</code> surface will return the dimensions of the drawn string. Next we’ll center the text rectangle <code class="literal">text_rect</code> horizontally on the screen, using the <code class="literal">.centerx</code> attribute, and position the text rectangle <code class="literal">10</code> pixels down from the top of the screen so it’s easy to see. Here are the two commands to set the position:</p><a id="pro_id00181"/><pre class="programlisting">text_rect.centerx = screen.get_rect().centerx
text_rect.y = 10</pre><p>It’s time to draw the <code class="literal">text_rect</code> image to the screen. We’ll do this using the <code class="literal">blit()</code> function like we did for our picture <code class="literal">pic</code>:</p><a id="pro_id00182"/><pre class="programlisting">screen.blit(text, text_rect)</pre><p>With those changes, our Smiley Pong game has become like the classic version of the game, but with our smiley face as the ball. Run the app, and you’ll see something like <a class="xref" href="ch10.html#smiley_pongcomma_version_1dot0comma_is_b" title="Figure 10-5. Smiley Pong, version 1.0, is becoming a real game!">Figure 10-5</a>. We’re on our way to an arcade-quality game!</p></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00029"/>Putting It All Together</h2></div></div></div><p>We’ve used many coding skills to make this game. Variables, loops, conditions, math, graphics, event handling—almost our full toolkit. Games are an adventure for both the coder and the player. Producing a game is challenging and rewarding; we get to build the gameplay we want, then share it with others. My sons loved version 1.0 of the Smiley Pong game, and they gave me great ideas for extending it to version 2.0.</p><p>Here’s the full version 1.0, <span class="emphasis"><em>SmileyPong1.py</em></span>:</p><div class="sect3" title="SmileyPong1.py"><div class="titlepage"><div><div><h3 class="title"><a id="smileypong1dotpy"/>SmileyPong1.py</h3></div></div></div><a id="pro_id00183"/><pre class="programlisting"><span class="orange">import</span> pygame       <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([800,600])
pygame.display.set_caption(<span class="green">"Smiley Pong"</span>)
keepGoing = <span class="orange">True</span>
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
colorkey = pic.get_at((0,0))
pic.set_colorkey(colorkey)
picx = 0
picy = 0
BLACK = (0,0,0)
WHITE = (255,255,255)
timer = pygame.time.Clock()
speedx = 5
speedy = 5
paddlew = 200
paddleh = 25
paddlex = 300
paddley = 550
picw = 100
pich = 100
points = 0
lives = 5
font = pygame.font.SysFont(<span class="green">"Times"</span>, 24)

<span class="orange">while</span> keepGoing:    <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keepGoing = <span class="orange">False</span>
    picx += speedx
    picy += speedy

    <span class="orange">if</span> picx &lt;= 0 <span class="orange">or</span> picx + pic.get_width() &gt;= 800:
        speedx = -speedx
    <span class="orange">if</span> picy &lt;= 0:
        speedy = -speedy
    <span class="orange">if</span> picy &gt;= 500:
        lives -= 1
        speedy = -speedy

    screen.fill(BLACK)
    screen.blit(pic, (picx, picy))

    <span class="red"># Draw paddle</span>
    paddlex = pygame.mouse.get_pos()[0]
    paddlex -= paddlew/2
    pygame.draw.rect(screen, WHITE, (paddlex, paddley, paddlew, paddleh))

    <span class="red"># Check for paddle bounce</span>
    <span class="orange">if</span> picy + pich &gt;= paddley <span class="orange">and</span> picy + pich &lt;= paddley + paddleh \
       <span class="orange">and</span> speedy &gt; 0:
        <span class="orange">if</span> picx + picw / 2 &gt;= paddlex <span class="orange">and</span> picx + picw / 2 &lt;= paddlex + \
           paddlew:
            points += 1
            speedy = -speedy

    <span class="red"># Draw text on screen</span>
    draw_string = <span class="green">"Lives: "</span> + <span class="violet">str</span>(lives) + <span class="green">" Points: "</span> + <span class="violet">str</span>(points)

    text = font.render(draw_string, <span class="orange">True</span>, WHITE)
    text_rect = text.get_rect()
    text_rect.centerx = screen.get_rect().centerx
    text_rect.y = 10
    screen.blit(text, text_rect)
    pygame.display.update()
    timer.tick(60)

pygame.quit()      <span class="red"># Exit</span></pre><p><a id="iddle1897" class="indexterm"/>Our gameplay is nearly complete: the ball bounces off the paddle, points are awarded, and players lose a life if they miss the ball and it hits the bottom edge of the screen. All the basic components are there to make this an arcade-style game. Now think about what improvements you would like to see, work out the logic, and try adding code to version 1.0 to make your game even more fun. In the next section, we’ll add three more features to create a fully interactive, video game–like experience that we can share with others.</p></div></div></div><div class="sect1" title="Adding Difficulty and Ending the Game: Smiley Pong, Version 2.0"><div class="titlepage"><div><div><h1 class="title"><a id="adding_difficulty_and_ending_the_game_sm"/>Adding Difficulty and Ending the Game: Smiley Pong, Version 2.0</h1></div></div></div><p>Version 1.0 of our Smiley Pong game is playable. Players can score points, lose lives, and see their progress on the screen. One thing we don’t have yet is an end to the game. Another is the sense of greater challenge as the game progresses. We’ll add the following features to Smiley Pong, version 1.0, to create a more complete game in version 2.0: a way to show that the game is over when the last life is lost, a way to play again or start a new game without closing the program, and a way to increase the difficulty as the game goes on. We’ll add these three features one at a time, winding up with a fun, challenging, arcade-style game! The final version is shown in <a class="xref" href="ch10.html#putting_it_all_together-id00030" title="Putting It All Together">Putting It All Together</a>.</p><div class="sect2" title="Game Over"><div class="titlepage"><div><div><h2 class="title"><a id="game_over"/>Game Over</h2></div></div></div><p><a id="iddle1297" class="indexterm"/><a id="iddle1370" class="indexterm"/><a id="iddle1372" class="indexterm"/><a id="iddle1492" class="indexterm"/><a id="iddle1494" class="indexterm"/>Version 1.0 never stopped playing because we didn’t add logic to handle the game being over. We know the condition to test for: the game is over when the player has no lives left. Now we need to figure out what to do when the player loses their last life.</p><p>The first thing we want to do is stop the game. We don’t want to close the program, but we do want to stop the ball. The second thing we want to do is change the text on the screen to tell the player that the game is over and give them their score. We can accomplish both tasks with an <code class="literal">if</code> statement right after the <code class="literal">draw_string</code> declaration for lives and points.</p><a id="pro_id00184"/><pre class="programlisting"><span class="orange">if</span> lives &lt; 1:
    speedx = speedy = 0
    draw_string = <span class="green">"Game Over. Your score was: "</span> + <span class="violet">str</span>(points)
    draw_string += <span class="green">". Press F1 to play again. "</span></pre><p>By changing <code class="literal">speedx</code> and <code class="literal">speedy</code> (the horizontal and vertical speed of the ball, respectively) to zero, we’ve stopped the ball from moving. The user can still move the paddle on the screen, but we’ve ended the gameplay visually to let the user know the game is over. The text makes this even clearer, plus it tells the user how well they did this round.</p><p>Right now, we’re telling the user to press F1 to play again, but pressing the key doesn’t do anything yet. We need logic to handle the keypress event and start the game over.</p></div><div class="sect2" title="Play Again"><div class="titlepage"><div><div><h2 class="title"><a id="play_again"/>Play Again</h2></div></div></div><p>We want to let the user play a new game when they’ve run out of lives. We’ve added text to the screen to tell the user to press the F1 key to play again, so let’s add code to detect that keypress and start the game over. First, we’ll check if a key was pressed and if that key was F1:</p><a id="pro_id00185"/><pre class="programlisting"><span class="orange">if</span> event.type == pygame.KEYDOWN:
    <span class="orange">if</span> event.key == pygame.K_F1: <span class="red"># F1 = New Game</span></pre><p>In the event handler <code class="literal">for</code> loop inside our game loop, we add an <code class="literal">if</code> statement to check if there was a <code class="literal">KEYDOWN</code> event. If so, we check the key pressed in that event (<code class="literal">event.key</code>) to see if it’s equal to the <a id="iddle1071" class="indexterm"/><a id="iddle1180" class="indexterm"/><a id="iddle1354" class="indexterm"/><a id="iddle1365" class="indexterm"/><a id="iddle1426" class="indexterm"/><a id="iddle1493" class="indexterm"/><a id="iddle1707" class="indexterm"/>F1 key (<code class="literal">pygame.K_F1</code>). The code that follows this second <code class="literal">if</code> statement will be our <span class="emphasis"><em>play again</em></span> or <span class="emphasis"><em>new game</em></span> code.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note01"/>Note</h3><p><span class="emphasis"><em>You can get a full list of the Pygame keycodes, such as <code class="literal">K_F1</code>, at</em></span> <a class="ulink" href="http://www.pygame.org/docs/ref/key.html">http://www.pygame.org/docs/ref/key.html</a><span class="emphasis"><em>.</em></span></p></div><p>“Play again” means that we want to start over from the beginning. For Smiley Pong, we started with 0 points, 5 lives, and the ball coming at us at 5 pixels per frame from the top-left corner of the screen, (0, 0). If we reset these variables, we should get the new game effect:</p><a id="pro_id00186"/><pre class="programlisting">points = 0
lives = 5
picx = 0
picy = 0
speedx = 5
speedy = 5</pre><p>Add these lines to the <code class="literal">if</code> statement for the F1 key <code class="literal">KEYDOWN</code> event, and you’ll be able to restart the game anytime. If you’d like to allow restarting only when the game is already over, you can include an additional condition that <code class="literal">lives == 0</code>, but we’ll leave the <code class="literal">if</code> statements as they currently are in our version 2.0 so that the user can restart anytime.</p></div><div class="sect2" title="Faster and Faster"><div class="titlepage"><div><div><h2 class="title"><a id="faster_and_faster"/>Faster and Faster</h2></div></div></div><p>Our game lacks one final element of game design: it doesn’t get more challenging the longer it’s played, so someone could play almost forever, paying less and less attention. Let’s add difficulty as the game progresses to engage the player and make the game more arcade-like.</p><div class="informalfigure"><a id="med_id00138a"/><div class="mediaobject"><a id="med_id00138"/><img src="httpatomoreillycomsourcenostarchimages2189047.png.jpg" alt="image with no caption"/></div></div><p>We want to increase the speed of the ball slightly as the game advances, but not too much, or the player might get frustrated. We want to make the game just a bit faster after each bounce. The natural place to do this is within the code that checks for bounces. Increasing the speed means making <code class="literal">speedx</code> and <code class="literal">speedy</code> greater so that the ball moves farther in each direction each frame. Try changing our <code class="literal">if</code> statements for collision detection (where we make the ball bounce back from each edge of the screen) to the following:</p><a id="pro_id00187"/><pre class="programlisting"><span class="orange">if</span> picx &lt;= 0 <span class="orange">or</span> picx &gt;= 700:
    speedx = -speedx * 1.1
<span class="orange">if</span> picy &lt;= 0:
    speedy = -speedy + 1</pre><p>In the first case, when the ball is bouncing off the left and right sides of the screen in the horizontal direction, we increase the horizontal speed, <code class="literal">speedx</code>, by multiplying it by <code class="literal">1.1</code> (and we still change the direction with our minus sign). This is a 10 percent increase in speed after each left and right bounce.</p><p>When the ball bounces off the top of the screen (<code class="literal">if picy &lt;= 0</code>), we know that the speed will become positive as it rebounds off the top and heads back down the screen in the positive <span class="emphasis"><em>y</em></span> direction, so we can add 1 to <code class="literal">speedy</code> after we change the direction with the minus sign. If the ball came toward the top at 5 pixels per frame in <code class="literal">speedy</code>, it will leave at 6 pixels per frame, then 7, and so on.</p><p>If you make those changes, you’ll see the ball get faster and faster. But once the ball starts going faster, it never slows back down. Soon the ball would be traveling so quickly that the player could lose all five lives in just a second.</p><p>We’ll make our game more playable (and fair) by resetting the speed every time the player loses a life. If the speed gets so high that the user can’t hit the ball with the paddle, it’s probably a good time to reset the speed to a slower value so the player can catch up.</p><p>Our code for bouncing off the bottom of the screen is where we take away one of the player’s lives, so let’s change the speed after we’ve subtracted a life:</p><a id="pro_id00188"/><pre class="programlisting"><span class="orange">if</span> picy &gt;= 500:
    lives -= 1
    speedy = -5
    speedx = 5</pre><p>This makes the game more reasonable, as the ball no longer gets out of control and stays that way; after the player loses a life, the ball slows down enough that the player can hit it a few more times before it speeds back up.</p><p>One problem, though, is that the ball could be traveling so fast that it could “get stuck” off the bottom edge of the screen; after playing a few games, the player will run into a case in which they lose <a id="iddle1898" class="indexterm"/>all of their remaining lives on a single bounce off the bottom edge. This is because the ball could move way below the bottom edge of the screen if it’s traveling really quickly, and when we reset the speed, we might not get the ball completely back on the screen by the next frame.</p><p>To solve this, let’s add one line to the end of that <code class="literal">if</code> statement:</p><a id="pro_id00189"/><pre class="programlisting">picy = 499</pre><p>We move the ball back onto the screen completely after a lost life by setting the <code class="literal">picy</code> to a value, like <code class="literal">499</code>, that places the ball completely above the bottom boundary of the screen. This will help our ball move safely back onto the screen no matter how fast it was traveling when it hit the bottom edge.</p><p>After these changes, version 2.0 looks like <a class="xref" href="ch10.html#version_2dot0_of_our_smiley_pong_game_fe" title="Figure 10-6. Version 2.0 of our Smiley Pong game features faster gameplay, game over, and play again functionality.">Figure 10-6</a>.</p><div class="figure"><a id="version_2dot0_of_our_smiley_pong_game_fe"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00139"/><img src="httpatomoreillycomsourcenostarchimages2189049.png.jpg" alt="Version 2.0 of our Smiley Pong game features faster gameplay, game over, and play again functionality."/></div></div><p class="title">Figure 10-6. Version 2.0 of our Smiley Pong game features faster gameplay, game over, and play again functionality.</p></div><p>Version 2.0 is like a real arcade game, complete with the game over/play again screen.</p></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00030"/>Putting It All Together</h2></div></div></div><p>Here’s our finished version 2.0, <span class="emphasis"><em>SmileyPong2.py</em></span>. At just under 80 lines of code, it’s a full arcade-style game that you can show off to friends and family. You can also build on it further to develop your coding skill.</p><div class="sect3" title="SmileyPong2.py"><div class="titlepage"><div><div><h3 class="title"><a id="smileypong2dotpy"/>SmileyPong2.py</h3></div></div></div><a id="pro_id00190"/><pre class="programlisting"><span class="orange">import</span> pygame       <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([800,600])
pygame.display.set_caption(<span class="green">"Smiley Pong"</span>)
keepGoing = <span class="orange">True</span>
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
colorkey = pic.get_at((0,0))
pic.set_colorkey(colorkey)
picx = 0
picy = 0
BLACK = (0,0,0)
WHITE = (255,255,255)
timer = pygame.time.Clock()
speedx = 5
speedy = 5
paddlew = 200
paddleh = 25
paddlex = 300
paddley = 550
picw = 100
pich = 100
points = 0
lives = 5
font = pygame.font.SysFont(<span class="green">"Times"</span>, 24)

<span class="orange">while</span> keepGoing:      <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keepGoing = <span class="orange">False</span>
        <span class="orange">if</span> event.type == pygame.KEYDOWN:
            <span class="orange">if</span> event.key == pygame.K_F1:     <span class="red"># F1 = New Game</span>
                points = 0
                lives = 5
                picx = 0
                picy = 0
                speedx = 5
                speedy = 5
    picx += speedx
    picy += speedy

    <span class="orange">if</span> picx &lt;= 0 <span class="orange">or</span> picx &gt;= 700:
        speedx = -speedx * 1.1
    <span class="orange">if</span> picy &lt;= 0:
        speedy = -speedy + 1
    <span class="orange">if</span> picy &gt;= 500:
        lives -= 1
        speedy = -5
        speedx = 5
        picy = 499

    screen.fill(BLACK)
    screen.blit(pic, (picx, picy))

    <span class="red"># Draw paddle</span>
    paddlex = pygame.mouse.get_pos()[0]
    paddlex -= paddlew/2
    pygame.draw.rect(screen, WHITE, (paddlex, paddley, paddlew, paddleh))

    <span class="red"># Check for paddle bounce</span>
    <span class="orange">if</span> picy + pich &gt;= paddley <span class="orange">and</span> picy + pich &lt;= paddley + paddleh \
       <span class="orange">and</span> speedy &gt; 0:
        <span class="orange">if</span> picx + picw/2 &gt;= paddlex <span class="orange">and</span> picx + picw/2 &lt;= paddlex + \
           paddlew:
            speedy = -speedy
            points += 1

    <span class="red"># Draw text on screen</span>
    draw_string = <span class="green">"Lives: "</span> + <span class="violet">str</span>(lives) + <span class="green">" Points: "</span> + <span class="violet">str</span>(points)
    <span class="red"># Check whether the game is over</span>
    <span class="orange">if</span> lives &lt; 1:
        speedx = speedy = 0
        draw_string = <span class="green">"Game Over. Your score was: "</span> + <span class="violet">str</span>(points)
        draw_string += <span class="green">". Press F1 to play again. "</span>

    text = font.render(draw_string, <span class="orange">True</span>, WHITE)
    text_rect = text.get_rect()
    text_rect.centerx = screen.get_rect().centerx
    text_rect.y = 10
    screen.blit(text, text_rect)
    pygame.display.update()
    timer.tick(60)

pygame.quit()       <span class="red"># Exit</span></pre><p><a id="iddle1373" class="indexterm"/><a id="iddle1479" class="indexterm"/><a id="iddle1683" class="indexterm"/><a id="iddle1710" class="indexterm"/><a id="iddle1903" class="indexterm"/><a id="iddle1908" class="indexterm"/>You can continue to build on the game elements in this example (see <a class="xref" href="ch10.html#programming_challenges-id00033" title="Programming Challenges">Programming Challenges</a>), or you can use these building blocks to develop something new. Most games, and even other apps, have features like the ones you added in this chapter, and we usually follow a process similar to the one we used to build Smiley Pong. First, map out the skeleton of the game, and then build a working <span class="emphasis"><em>prototype</em></span>, or a version 1.0. Once that’s working, add features until you get the final version you want. You’ll find <a class="firstterm" href="apd.html#gloss01_029"><em class="firstterm">iterative versioning</em></a>—adding features one at a time to create new versions—useful as you build more complex apps.</p></div></div></div><div class="sect1" title="Adding More Features: SmileyPop V2.0"><div class="titlepage"><div><div><h1 class="title"><a id="adding_more_features_smileypop_v2dot0"/>Adding More Features: SmileyPop V2.0</h1></div></div></div><p>We’ll follow our iterative versioning process one more time by adding features that my son Max and I wanted to see in the SmileyPop app in <a class="xref" href="ch09.html" title="Chapter 9. User Interaction: Get into the Game">Chapter 9</a>. First, he wanted a sound effect whenever a smiley face bubble (or balloon) was popped by a mouse click. Second, we both wanted some kind of feedback and display (maybe how many bubbles had been created and how many had been popped), and I wanted some sign of progress, like the percentage of bubbles we’d popped. The SmileyPop app was already fun, but these elements could make it even better.</p><p>Look back at <a class="xref" href="ch09.html#smileypopdotpy" title="SmileyPop.py">SmileyPop.py</a>; we’ll start with this version of the app, and we’ll build our second version (v2.0, short for version 2.0) by adding code. The final version, <span class="emphasis"><em>SmileyPop2.py</em></span>, is shown in <a class="xref" href="ch10.html#smileypop_app_is_more_like_a_game_now_th" title="Figure 10-7. The SmileyPop app is more like a game now that we’ve added sound and a progress/feedback display.">Figure 10-7</a>.</p><p>We’ll begin by adding Max’s request: the popping sound.</p><div class="sect2" title="Adding Sound with Pygame"><div class="titlepage"><div><div><h2 class="title"><a id="adding_sound_with_pygame"/>Adding Sound with Pygame</h2></div></div></div><p>At <span class="emphasis"><em><a class="ulink" href="http://www.pygame.org/docs/">http://www.pygame.org/docs/</a></em></span>, you’ll find modules, classes, and functions that can make your games more fun to play and easier to program. The module we need for sound effects is <code class="literal">pygame.mixer</code>. To use this mixer module to add sound to your game, you first need a sound file to use. For our popping sound effect, download the <span class="emphasis"><em>pop.wav</em></span> file from <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> under the source code and files for <a class="xref" href="ch10.html" title="Chapter 10. Game Programming: Coding for Fun">Chapter 10</a>.</p><p>We’ll add these two lines to the setup section of <span class="emphasis"><em>SmileyPop.py</em></span>, right below <code class="literal">sprite_list = pygame.sprite.Group()</code>:</p><a id="pro_id00191"/><pre class="programlisting">pygame.mixer.init()    <span class="red"># Add sounds</span>
pop = pygame.mixer.Sound(<span class="green">"pop.wav"</span>)</pre><p><a id="iddle1225" class="indexterm"/><a id="iddle1274" class="indexterm"/><a id="iddle1383" class="indexterm"/><a id="iddle1440" class="indexterm"/><a id="iddle1505" class="indexterm"/><a id="iddle1799" class="indexterm"/>We begin by initializing the mixer (just like we initialize Pygame with <code class="literal">pygame.init()</code>). Then we load our <span class="emphasis"><em>pop.wav</em></span> sound effect into a <code class="literal">Sound</code> object so we can play it in our program.</p><p>The second line loads <span class="emphasis"><em>pop.wav</em></span> as a <code class="literal">pygame.mixer.Sound</code> object and stores it in the variable <code class="literal">pop</code>, which we’ll use later when we want to hear a popping sound. As with image files, you’ll need <span class="emphasis"><em>pop.wav</em></span> saved in the same directory or folder as your <span class="emphasis"><em>SmileyPop.py</em></span> program for the code to be able to find the file and use it.</p><p>Next we’ll add logic to check whether a smiley was clicked and play our <code class="literal">pop</code> sound if a smiley was popped. We’ll do this in the event handler section of our game loop, in the same <code class="literal">elif</code> statement that processes right-mouse-button events (<code class="literal">elif pygame.mouse.get_pressed()[2]</code>). After the <code class="literal">sprite_list.remove(clicked_smileys)</code> that removes clicked smileys from the <code class="literal">sprite_list</code>, we could check to see if there were actually any smiley collisions, then play a sound.</p><div class="informalfigure"><a id="med_id00140a"/><div class="mediaobject"><a id="med_id00140"/><img src="httpatomoreillycomsourcenostarchimages2189051.png.jpg" alt="image with no caption"/></div></div><p>The user could right-click the mouse in an area of the screen with no smiley faces to pop, or they might miss a smiley when trying to click. We’ll check whether any smileys were actually clicked by seeing <code class="literal">if len(clicked_smileys) &gt; 0</code>. The <code class="literal">len()</code> function tells us the length of a list or collection, and if the length is greater than zero, there were clicked smileys. Remember, <code class="literal">clicked_smileys</code> was a list of the smiley sprites that collided with or were drawn overlapping the point where the user clicked.</p><p>If the <code class="literal">clicked_smileys</code> list has smiley sprites in it, then the user correctly right-clicked at least one smiley, so we play the popping sound:</p><a id="pro_id00192"/><pre class="programlisting"><span class="orange">if</span> <span class="violet">len</span>(clicked_smileys) &gt; 0:
    pop.play()</pre><p>Notice that both lines are indented to align correctly with the other code in our <code class="literal">elif</code> statement for handling right-clicks.</p><p>These four lines of added code are all it takes to play the popping sound when a user successfully right-clicks a smiley. To <a id="iddle1236" class="indexterm"/><a id="iddle1237" class="indexterm"/><a id="iddle1375" class="indexterm"/>make these changes and hear the result, make sure you’ve downloaded the <span class="emphasis"><em>pop.wav</em></span> sound file into the same folder as your revised <span class="emphasis"><em>SmileyPop.py</em></span>, turn your speakers to a reasonable volume, and pop away!</p></div><div class="sect2" title="Tracking and Displaying Player Progress"><div class="titlepage"><div><div><h2 class="title"><a id="tracking_and_displaying_player_progress"/>Tracking and Displaying Player Progress</h2></div></div></div><p>The next feature we want to add is some way to help the user feel like they’re making progress. The sound effects added one fun kind of feedback (the user hears a popping sound only if they actually clicked a smiley sprite), but let’s also track how many bubbles the user has created and popped and what percentage of the smileys they’ve popped.</p><p>To build the logic for keeping track of the number of smileys the user has created and the number they’ve popped, we’ll begin by adding a <code class="literal">font</code> variable and two counter variables, <code class="literal">count_smileys</code> and <code class="literal">count_popped</code>, to the setup section of our app:</p><a id="pro_id00193"/><pre class="programlisting">font = pygame.font.SysFont(<span class="green">"Arial"</span>, 24)
WHITE = (255,255,255)
count_smileys = 0
count_popped = 0</pre><p>We set our <code class="literal">font</code> variable to the Arial font face, at a size of 24 points. We want to draw text on the screen in white letters, so we add a color variable <code class="literal">WHITE</code> and set it to the RGB triplet for white, <code class="literal">(255,255,255)</code>. Our <code class="literal">count_smileys</code> and <code class="literal">count_popped</code> variables will store the number of created and popped smileys, which both start at zero when the app first loads.</p><div class="sect3" title="Smileys Created and Popped"><div class="titlepage"><div><div><h3 class="title"><a id="smileys_created_and_popped"/>Smileys Created and Popped</h3></div></div></div><p>First, let’s count smileys as they’re added to the <code class="literal">sprite_list</code>. To do that, we go almost to the bottom of our <span class="emphasis"><em>SmileyPop.py</em></span> code, where the <code class="literal">if mousedown</code> statement checks whether the mouse is being dragged with the mouse button pressed and adds smileys to our <code class="literal">sprite_list</code>. Add just the last line to that <code class="literal">if</code> statement:</p><a id="pro_id00194"/><pre class="programlisting"><span class="orange">if</span> mousedown:
    speedx = random.randint(-5, 5)
    speedy = random.randint(-5, 5)
    newSmiley = Smiley(pygame.mouse.get_pos(), speedx, speedy)
    sprite_list.add(newSmiley)
    count_smileys += 1</pre><p><a id="iddle1506" class="indexterm"/><a id="iddle1939" class="indexterm"/><a id="iddle2015" class="indexterm"/>Adding 1 to <code class="literal">count_smileys</code> every time a new smiley is added to the <code class="literal">sprite_list</code> will help us keep track of the total number of smileys drawn.</p><p>We’ll add similar logic to the <code class="literal">if</code> statement that plays our popping sound whenever one or more smileys have been clicked, but we won’t just add 1 to <code class="literal">count_popped</code>—we’ll add the real number of smileys that were clicked. Remember that our user could have clicked the screen over two or more smiley sprites that are overlapping the same point. In our event handler for the right-click event, we gathered all these colliding smileys as the list <code class="literal">clicked_smileys</code>. To find out how many points to add to <code class="literal">count_popped</code>, we just use the <code class="literal">len()</code> function again to get the correct number of smileys the user popped with this right-click. Add this line to the <code class="literal">if</code> statement you wrote for the popping sound:</p><a id="pro_id00195"/><pre class="programlisting"><span class="orange">if</span> <span class="violet">len</span>(clicked_smileys) &gt; 0:
    pop.play()
    count_popped += <span class="violet">len</span>(clicked_smileys)</pre><p>By adding <code class="literal">len(clicked_smileys)</code> to <code class="literal">count_popped</code>, we’ll always have the correct number of popped smileys at any point in time. Now, we just have to add the code to our game loop that will display the number of smileys created, the number popped, and the percentage popped to measure the user’s progress.</p><div class="informalfigure"><a id="med_id00141a"/><div class="mediaobject"><a id="med_id00141"/><img src="httpatomoreillycomsourcenostarchimages2189053.png.jpg" alt="image with no caption"/></div></div><p>Just like in our Smiley Pong display, we’ll create a string of text to draw on the screen, and we’ll show the numbers as strings with the <code class="literal">str()</code> function. Add these lines to your game loop right before <code class="literal">pygame.display.update()</code>:</p><a id="pro_id00196"/><pre class="programlisting">draw_string = <span class="green">"Bubbles created: "</span> + <span class="violet">str</span>(count_smileys)
draw_string += <span class="green">" - Bubbles popped: "</span> + <span class="violet">str</span>(count_popped)</pre><p><a id="iddle1110" class="indexterm"/><a id="iddle1833" class="indexterm"/>These lines will create our <code class="literal">draw_string</code> and show both the number of smiley bubbles created and the number popped.</p></div><div class="sect3" title="Percentage of Smileys Popped"><div class="titlepage"><div><div><h3 class="title"><a id="percentage_of_smileys_popped"/>Percentage of Smileys Popped</h3></div></div></div><p>Add these three lines, right after the two <code class="literal">draw_string</code> statements:</p><a id="pro_id00197"/><pre class="programlisting"><span class="orange">if</span> (count_smileys &gt; 0):
    draw_string += <span class="green">" - Percent: "</span>
    draw_string += <span class="violet">str</span>(<span class="violet">round</span>(count_popped/count_smileys*100, 1))
    draw_string += <span class="green">"%"</span></pre><p>To get the percentage of smileys popped out of all the smileys that have been created, we divide <code class="literal">count_popped</code> by <code class="literal">count_smileys</code> (<code class="literal">count_popped/count_smileys</code>), then multiply by 100 to get the percent value (<code class="literal">count_popped/count_smileys*100</code>). But we’ll have two problems if we try to show this number. First, when the program starts and both values are zero, our percentage calculation will produce a “division by zero” error. To fix this, we’ll show the percentage popped only if <code class="literal">count_smileys</code> is greater than zero.</p><p>Second, if the user has created three smileys and popped one of them—a ratio of one out of three, or 1/3—the percentage will be 33.33333333. . . . We don’t want the display to get really long every time there’s a repeating decimal in the percentage calculation, so let’s use the <code class="literal">round()</code> function to round the percentage to one decimal place.</p><p>The last step is to draw the string in white pixels, center those pixels on the screen near the top, and call <code class="literal">screen.blit()</code> to copy those pixels to the game window’s drawing screen:</p><a id="pro_id00198"/><pre class="programlisting">text = font.render(draw_string, <span class="orange">True</span>, WHITE)
text_rect = text.get_rect()
text_rect.centerx = screen.get_rect().centerx
text_rect.y = 10
screen.blit (text, text_rect)</pre><p>You can see the effect of these changes in <a class="xref" href="ch10.html#smileypop_app_is_more_like_a_game_now_th" title="Figure 10-7. The SmileyPop app is more like a game now that we’ve added sound and a progress/feedback display.">Figure 10-7</a>.</p><p>The smaller smileys are more difficult to catch and pop, especially when they’re moving fast, so it’s hard to pop more than 90 percent. That’s exactly what we want. We’ve used this feedback and challenge/achievement component to make the app feel more like a game we might play.</p><div class="figure"><a id="smileypop_app_is_more_like_a_game_now_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00142"/><img src="httpatomoreillycomsourcenostarchimages2189055.png.jpg" alt="The SmileyPop app is more like a game now that we’ve added sound and a progress/feedback display."/></div></div><p class="title">Figure 10-7. The SmileyPop app is more like a game now that we’ve added sound and a progress/feedback display.</p></div><p><a id="iddle1564" class="indexterm"/>The popping sound and progress display feedback have made SmileyPop feel like a mobile app. As you’re popping smiley faces by right-clicking, you can probably imagine tapping the smileys with your finger to pop them on a mobile device. (To learn how to build mobile apps, check out MIT’s App Inventor at <span class="emphasis"><em><a class="ulink" href="http://appinventor.mit.edu/">http://appinventor.mit.edu/</a></em></span>.)</p></div></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00031"/>Putting It All Together</h2></div></div></div><p>Here’s the complete code for SmileyPop, version 2.0. Remember to keep the <span class="emphasis"><em>.py</em></span> source code file, the <span class="emphasis"><em>CrazySmile.bmp</em></span> image file, and the <span class="emphasis"><em>pop.wav</em></span> sound file all in the same folder.</p><p>At almost 90 lines, this app might be a bit too long to type by hand. Go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> to download the code, along with the sound and picture files.</p><div class="sect3" title="SmileyPop2.py"><div class="titlepage"><div><div><h3 class="title"><a id="smileypop2dotpy"/>SmileyPop2.py</h3></div></div></div><a id="pro_id00199"/><pre class="programlisting"><span class="orange">import</span> pygame
<span class="orange">import</span> random

BLACK = (0,0,0)
WHITE = (255,255,255)
pygame.init()
screen = pygame.display.set_mode([800,600])
pygame.display.set_caption(<span class="green">"Pop a Smiley"</span>)
mousedown = <span class="orange">False</span>
keep_going = <span class="orange">True</span>
clock = pygame.time.Clock()
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
colorkey = pic.get_at((0,0))
pic.set_colorkey(colorkey)
sprite_list = pygame.sprite.Group()
pygame.mixer.init()    <span class="red"># Add sounds</span>
pop = pygame.mixer.Sound(<span class="green">"pop.wav"</span>)
font = pygame.font.SysFont(<span class="green">"Arial"</span>, 24)
count_smileys = 0
count_popped = 0

<span class="orange">class</span> <span class="blue">Smiley</span>(pygame.sprite.Sprite):
    pos = (0,0)
    xvel = 1
    yvel = 1
    scale = 100

    <span class="orange">def</span> <span class="blue">__init__</span>(self, pos, xvel, yvel):
        pygame.sprite.Sprite.__init__(self)
        self.image = pic
        self.scale = random.randrange(10,100)
        self.image = pygame.transform.scale(self.image,
                                            (self.scale,self.scale))
        self.rect = self.image.get_rect()
        self.pos = pos
        self.rect.x = pos[0] - self.scale/2
        self.rect.y = pos[1] - self.scale/2
        self.xvel = xvel
        self.yvel = yvel
    <span class="orange">def</span> <span class="blue">update</span>(self):
        self.rect.x += self.xvel
        self.rect.y += self.yvel
        <span class="orange">if</span> self.rect.x &lt;= 0 <span class="orange">or</span> self.rect.x &gt; screen.get_width() - self.scale:
            self.xvel = -self.xvel
        <span class="orange">if</span> self.rect.y &lt;= 0 <span class="orange">or</span> self.rect.y &gt; screen.get_height() - self.scale:
            self.yvel = -self.yvel

<span class="orange">while</span> keep_going:
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>
        <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
            <span class="orange">if</span> pygame.mouse.get_pressed()[0]: <span class="red"># Left mouse button, draw</span>
                mousedown = <span class="orange">True</span>
            <span class="orange">elif</span> pygame.mouse.get_pressed()[2]: <span class="red"># Right mouse button, pop</span>
                pos = pygame.mouse.get_pos()
                clicked_smileys = [s <span class="orange">for</span> s <span class="orange">in</span> sprite_list <span class="orange">if</span>
                                   s.rect.collidepoint(pos)]
                sprite_list.remove(clicked_smileys)
                <span class="orange">if</span> <span class="violet">len</span>(clicked_smileys) &gt; 0:
                    pop.play()
                    count_popped += <span class="violet">len</span>(clicked_smileys)
        <span class="orange">if</span> event.type == pygame.MOUSEBUTTONUP:
            mousedown = <span class="orange">False</span>
    screen.fill(BLACK)
    sprite_list.update()
    sprite_list.draw(screen)
    clock.tick(60)
    draw_string = <span class="green">"Bubbles created: "</span> + <span class="violet">str</span>(count_smileys)
    draw_string += <span class="green">" - Bubbles popped: "</span> + <span class="violet">str</span>(count_popped)
    <span class="orange">if</span> (count_smileys &gt; 0):
        draw_string += <span class="green">" - Percent: "</span>
        draw_string += <span class="violet">str</span>(<span class="violet">round</span>(count_popped/count_smileys*100, 1))
        draw_string += <span class="green">"%"</span>

    text = font.render(draw_string, <span class="orange">True</span>, WHITE)
    text_rect = text.get_rect()
    text_rect.centerx = screen.get_rect().centerx
    text_rect.y = 10
    screen.blit (text, text_rect)
    
    pygame.display.update()
    <span class="orange">if</span> mousedown:
        speedx = random.randint(-5, 5)
        speedy = random.randint(-5, 5)
        newSmiley = Smiley(pygame.mouse.get_pos(), speedx, speedy)
        sprite_list.add(newSmiley)
        count_smileys += 1

pygame.quit()</pre><p>The more programs you write, the better you’ll get at coding. You may start by coding games that you find interesting, writing an app that solves a problem you care about, or developing apps for other people. Keep coding, solve more problems, and get better and better at programming, and you’ll soon be able to help create products that benefit users around the world.</p><p>Whether you’re coding mobile games and apps; writing programs that control automobiles, robots, or drones; or building the next social media web application, coding is a skill that can change your life.</p><p>You have the skills. You have the ability. Keep practicing, keep coding, and go out there and make a difference—in your own life, in the lives of the people you care about, and in the world.</p></div></div></div><div class="sect1" title="What You Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_learned-id00032"/>What You Learned</h1></div></div></div><p>In this chapter, you learned about elements of game design, from goals and achievements to rules and mechanics. We built a single-player Smiley Pong game from scratch and turned our SmileyPop app into a game we could picture playing on a smartphone or tablet. We combined animation, user interaction, and game design to build two versions of the Smiley Pong game and a second version of SmileyPop, adding more features as we went.</p><p>In Smiley Pong, we drew our board and game pieces, added user interaction to move the paddle, and added collision detection and scoring. We displayed text on the screen to give the user information about their achievements and the state of the game. You learned how to detect keypress events in Pygame, added “game over” and “play again” logic, and finished version 2.0 by making the ball speed up as the game progressed. You now have the framework and parts to build more complex games.</p><p>In SmileyPop, we started with an app that was already fun to play with, added user feedback in the form of a popping sound using the <code class="literal">pygame.mixer</code> module, and then added logic and a display to keep track of the user’s progress as more bubbles are created and popped.</p><p>The apps you’ll create with your programming skills will also start with a simple version, a <span class="emphasis"><em>proof of concept</em></span>, that you can run and use as a foundation for new versions. You can begin with any program and add features one at a time, saving each new version along the way—a process called <span class="emphasis"><em>iterative versioning</em></span>. This process helps you debug each new feature until it works correctly, and it helps you keep the last good version of a file even when the new code breaks.</p><p>Sometimes a new feature will be a good fit, and you’ll keep it as the foundation of the next version. Sometimes your new code won’t work, or the feature won’t be as cool as you expected. Either way, you build your programming skills by trying new things and solving new problems.</p><p>Happy coding!</p><p><a id="iddle1899" class="indexterm"/>After mastering the concepts in this chapter, you should be able to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Recognize common game design elements in games and apps that you use.</p></li><li class="listitem"><p>Incorporate game design elements into apps that you code.</p></li><li class="listitem"><p>Build a skeleton of a game by drawing the board and playing pieces and adding user interaction.</p></li><li class="listitem"><p>Program collision detection between game pieces and keep score in an app or game.</p></li><li class="listitem"><p>Display text information on the screen using the <code class="literal">pygame.font</code> module.</p></li><li class="listitem"><p>Write game logic to determine when a game is over.</p></li><li class="listitem"><p>Detect and handle keypress events in Pygame.</p></li><li class="listitem"><p>Develop the code to start a new game or play again after a game ends.</p></li><li class="listitem"><p>Use math and logic to make games progressively more difficult</p></li><li class="listitem"><p>Add sounds to your apps with the <code class="literal">pygame.mixer</code> module.</p></li><li class="listitem"><p>Display percentages and rounded numbers to keep users informed of their progress in a game.</p></li><li class="listitem"><p>Understand the process of iterative versioning: adding features to an app one at a time and saving it as a new version (1.0, 2.0, and so on).</p></li></ul></div><div class="sidebar"><a id="programming_challenges-id00033"/><p class="title">Programming Challenges</p><p>For sample answers to these challenges, and to download the sound files for this chapter, go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>.</p><p><span class="strong"><strong>#1: SOUND EFFECTS</strong></span></p><p>One feature we could add to Smiley Pong, version 2.0, is sound effects. In the classic Pong console and arcade game, the ball made a “blip” noise when players scored a point and a “buzz” or “blap” noise when they missed. For one of your <a id="iddle1900" class="indexterm"/><a id="iddle1901" class="indexterm"/>final challenges, use the skills you learned in version 2.0 of the SmileyPop app to upgrade Smiley Pong v2.0 to v3.0 by adding sound effects to the point and miss bounces. Save this new file as <span class="emphasis"><em>SmileyPong3.py</em></span>.</p><p><span class="strong"><strong>#2: HITS AND MISSES</strong></span></p><p>To make the SmileyPop app even more game-like, add logic to keep track of the number of hits and misses out of the total number of clicks. If the user hits any smiley sprites when they right-click, add 1 to the number of <code class="literal">hits</code> (1 hit per click—we don’t want to duplicate <code class="literal">count_popped</code>). If the user right-clicks and doesn’t hit any smiley sprites, record that as a <code class="literal">miss</code>. You could program the logic to end the game after a certain number of misses, or you could give the user a certain number of total clicks to get the highest percentage they can. You might even add a timer and tell the player to create and pop as many smiley bubbles as they can in, say, 30 seconds. Save this new version as <span class="emphasis"><em>SmileyPopHitCounter.py</em></span>.</p><p><span class="strong"><strong>#3: CLEAR THE BUBBLES</strong></span></p><p>You might want to add a “clear” feature (or cheat button) to pop all the bubbles by hitting a function key, sort of like our “play again” feature in Smiley Pong. You could also make the bouncing smiley faces slow down over time by multiplying their speed by a number less than 1 (like 0.95) every time they bounce off an edge. The possibilities are endless.</p></div></div></div></body></html>