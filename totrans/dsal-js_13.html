<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label="177"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch10">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">10</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">LISTS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In the previous chapters we explored algorithms that perform several generic tasks, and in this chapter we’ll study data structures for specific objectives, beginning with the most basic one: a list of elements. Lists are quite simple, but the concepts behind lists appear in many other structures, as you’ll learn in the rest of the book. In fact, lists are at the center of the most antiquated language still widely in use: the acronym for LISP, created in 1959, stands for “list processing.”</p>&#13;
<p class="TX">What’s a <i>list</i>? A simple definition is that a list is a sequence of elements (or values, or nodes), which implies that there’s a first element and that every element (except the last) is followed by another element. Another definition, recursive in nature, is that a list is either empty (no elements) or formed by a specific element, called the head of the list, which is followed by the tail—which is another list.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label="178"/>We’ll start by defining the basic abstract data type (ADT) for lists and how to implement it in a couple of ways. (See <a href="chapter10.xhtml#tab10-1">Table 10-1</a> for all operations.) It happens, however, that the ADT has some more important variants, so we’ll also consider those, which will lead to implementing other structures like stacks, queues, deques, and more.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-1:</span></span> <span class="SANS_Futura_Std_Book_11">Basic Operations on Lists</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">L</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">L</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the list is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Size</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">L</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">number</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Count how many elements are in the list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">L × position x value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">L</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add a value to the list at a certain position.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">L × position</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">L</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove a value from the list at a certain position.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">At</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">L × position</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value | undefined</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a position, return the value at that position.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">L × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a value, find whether it exists in the list.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">For some types of lists, such as stacks, queues, or deques, we’ll substitute some of the functions in <a href="chapter10.xhtml#tab10-2">Table 10-2</a> (possibly with different names) for the add, remove, and at operations. We may also drop some other operations, but we’ll consider them case by case. For instance, instead of adding an element at any place in the list, we may want to restrict ourselves to adding new elements only at the front or at the back of the list.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-2:</span></span> <span class="SANS_Futura_Std_Book_11">Extra Operations on</span> <span class="SANS_Futura_Std_Book_11">Lists</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add at front</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">L × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">L</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add a new value at the front of the list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add at back</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">L × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">L</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add a new value at the back of the list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove from front</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">L</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value | undefined</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove a value from the front of the list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove from back</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">L</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value | undefined</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove a value from the back of the list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">At front</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">L</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value | undefined</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Get the value at the front of the list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">At back</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">L</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value | undefined</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Get the value at the back of the list.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Finally, we’ll also be able to use lists to represent other ADTs, such as sets or maps (see <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>).</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-47"/><span class="SANS_Futura_Std_Bold_B_11">Basic Lists</span></h3>&#13;
<p class="TNI1">Let’s start with the most basic implementation of a list, which may be good enough for many applications, and then move on to a dynamic memory version, which is able to deal with more complex situations and structures.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label="179"/>&#13;
<h4 class="H2"><span id="sec2"/><span id="h2-79"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Implementing Lists with Arrays</span></h4>&#13;
<p class="TNI1">Given that JavaScript implements <i>dynamic arrays</i>, which can grow larger or become smaller as needed, using arrays for lists seems logical, and for most applications that’s the case. However, expanding an array often requires moving the whole array to a new, larger space in memory, so operations may not be as instant. (The inner details of how JavaScript allocates space for arrays isn’t clear, but if you keep adding elements, at some point, JavaScript will run out of space and have to allocate more space somewhere else and move the array there.) Obviously, with small, short lists, you won’t be able to perceive the impact, but for large structures, it could become noticeable.</p>&#13;
<p class="TX">You can implement all the operations for the ADT in a minimum number of lines, taking advantage of available JavaScript methods as follows. <span class="SANS_TheSansMonoCd_W5Regular_11">create</span> was renamed <span class="SANS_TheSansMonoCd_W5Regular_11">newList</span> to make its function clearer, and <span class="SANS_TheSansMonoCd_W5Regular_11">Empty?</span> was renamed <span class="SANS_TheSansMonoCd_W5Regular_11">isEmpty</span> because of JavaScript naming rules.</p>&#13;
<pre id="pre-151"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newList = () =&gt; [];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const size = (list) =&gt; list.length;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const isEmpty = (list) =&gt; size(list) === 0;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> const add = (list, position, value) =&gt; {&#13;
  list.splice(list, position, value);&#13;
  return list;&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> const remove = (list, position) =&gt; {&#13;
  list.splice(list, position);&#13;
  return list;&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> const at = (list, position) =&gt; list[position];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> const find = (list, value) =&gt; list.includes(value);</code></pre>&#13;
<p class="TX">Creating a new list <span class="CodeAnnotation" aria-label="annotation1">❶</span> is just a matter of producing an empty array. The list size is the array’s length <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and to check whether a list is empty, test whether its size is 0 <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Adding an element at a given position <span class="CodeAnnotation" aria-label="annotation4">❹</span> is tailor-made for the <span class="SANS_TheSansMonoCd_W5Regular_11">splice(...)</span> standard method, which is also used to remove an element <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Finally, accessing the element at a given position <span class="CodeAnnotation" aria-label="annotation6">❻</span> is trivial. (The latest version of JavaScript provides an <span class="SANS_TheSansMonoCd_W5Regular_11">.at(...)</span> method, which is somewhat different from what is defined here because of the possibility of using negative indices; see <i><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at</a></i>.) Finally, use the <span class="SANS_TheSansMonoCd_W5Regular_11">.includes(...)</span> method to see whether a list includes the value <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#tab10-3">Table 10-3</a> shows the performance of these operations.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-3"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label="180"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-3:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Array-Based</span> <span class="SANS_Futura_Std_Book_11">Lists</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Size</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">At</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Creating a new list, checking whether it’s empty, getting its size, and accessing the element at a given position are all <i>O</i>(1) operations. As expected, finding a value is <i>O</i>(<i>n</i>), because the operation needs to go through the whole list. On the other hand, adding and removing elements are <i>O</i>(<i>n</i>) operations, because they basically move the whole array to a different place in memory. If you implement lists dynamically, these results will change.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-80"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Implementing Lists with Dynamic Memory</span></h4>&#13;
<p class="TNI1">Languages that support dynamic memory provide a different way to deal with varying-length lists: through pointers. You can include a reference to an object in another object along the lines of the following code:</p>&#13;
<pre id="pre-152"><code>const first = {&#13;
  name: "George",&#13;
  next: null,&#13;
};&#13;
&#13;
const second = {&#13;
  name: "John",&#13;
  next: null,&#13;
};&#13;
&#13;
const third = {&#13;
  name: "Thomas",&#13;
  next: null,&#13;
};&#13;
&#13;
first.next = second;&#13;
second.next = third;</code></pre>&#13;
<p class="TX">Given only the pointer to the <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> object, you can list the next object’s name with <span class="SANS_TheSansMonoCd_W5Regular_11">first.next.name</span>, for example; then <span class="SANS_TheSansMonoCd_W5Regular_11">first.next.next.name</span> would list the third object’s name. All of this is standard JavaScript notation. The last object has its <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> attribute with a null value, meaning there’s no next object in the list.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label="181"/><a href="chapter10.xhtml#fig10-1">Figure 10-1</a> represents pointers with arrows and a null pointer with a line ending in a circle. Of course, you’re not limited to having a single pointer in a node; you can have as many as you want. Let’s start with a simple case: an example of a list with six elements is shown in <a href="chapter10.xhtml#fig10-1">Figure 10-1</a>, where <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> points to the head.</p>&#13;
<figure class="IMG"><img class="img7" id="fig10-1" src="../images/Figure10-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-1: A simple list</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Adding a new element requires changing a pointer. For instance, <a href="chapter10.xhtml#fig10-2">Figure 10-2</a> shows adding an 80 after the 60.</p>&#13;
<figure class="IMG"><img class="img7" id="fig10-2" src="../images/Figure10-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-2: Adding a new element to the list requires changing only a single pointer in a node.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The same result occurs when removing an element; you need to change only a single pointer—usually the one from the previous element, or <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> itself if removing the head of the list. In the next example, let’s remove the 60 (see <a href="chapter10.xhtml#fig10-3">Figure 10-3</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig10-3" src="../images/Figure10-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-3: Removing an element from the list also requires just changing a single pointer.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Adding and removing elements by themselves are <i>O</i>(1) operations. (Of course, this assumes you already know where to effect the changes and also what other element points to the one you wanted to remove.) Let’s consider functioning code for all the possible operations.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label="182"/>&#13;
<h5 class="H3"><span id="sec4"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a List</span></h5>&#13;
<p class="TNI1">A list is just an object, which may have a link to another object, and so on. An empty list is a null pointer. With that in mind, creating a new, empty list is simple, and so is checking whether you have an empty list or calculating a list’s size:</p>&#13;
<pre id="pre-153"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newList = () =&gt; null;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const isEmpty = (list) =&gt; list === null;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const size = (list) =&gt; (isEmpty(list) ? 0 : 1 + size(list.next));  </code></pre>&#13;
<p class="TX">Creating a list produces a null pointer that eventually points to the list’s head <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Checking whether a list is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span> means seeing whether the pointer is null. Finally, calculating the list’s size is simple with recursion: an empty list has a size of 0, and a nonempty list has a size of 1 (for the list’s head) plus whatever the list’s tail size is <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3"><span id="sec5"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Value</span></h5>&#13;
<p class="TNI1">To figure the list’s nodes, use objects with a <span class="SANS_TheSansMonoCd_W5Regular_11">value</span> (a key or whatever you want to add to the list) and a pointer (<span class="SANS_TheSansMonoCd_W5Regular_11">ptr</span>) to the following element in the list:</p>&#13;
<pre id="pre-154"><code>const add = (list, position, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list) || position === 0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> list = {value, next: list};&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> list.next = add(list.next, position - 1, value);&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> return list;&#13;
};</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">add(...)</span> recursive function gets a pointer to a list and the <span class="SANS_TheSansMonoCd_W5Regular_11">position</span> in which to add the new <span class="SANS_TheSansMonoCd_W5Regular_11">value</span>. If the pointer is null or if the position is zero <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the new node goes at the beginning of the list <span class="CodeAnnotation" aria-label="annotation2">❷</span>, pointing to whatever was the first element of the list earlier. Otherwise, go down the list recursively to the next node <span class="CodeAnnotation" aria-label="annotation3">❸</span>. After the new value is added, return a pointer to the updated list <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3"><span id="sec6"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value</span></h5>&#13;
<p class="TNI1">To remove an element from a list, you have two options: remove the first element (in which case the pointer to the first element of the list must be changed) or remove another element in the list (and then modify the pointer in the previous node as mentioned earlier). The following code does all of it:</p>&#13;
<pre id="pre-155"><code>const remove = (list, position) =&gt; {&#13;
  if (isEmpty(list)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> return list;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label="183"/>  } else if (position === 0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return list.next;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> list.next = remove(list.next, position – 1);&#13;
    return list;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the list is null, just return it <span class="CodeAnnotation" aria-label="annotation1">❶</span>; you can’t do anything else. If it’s not null and you want to remove its head, the new list is the list’s tail <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, if the list isn’t null and you don’t want to remove its head, advance to the next place in the list to attempt the removal again <span class="CodeAnnotation" aria-label="annotation3">❸</span>, but now the position to remove is one less than before. In all cases return a pointer to the list after the removal.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3"><span id="sec7"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Getting the Value at a Position</span></h5>&#13;
<p class="TNI1">You can get the value at a given position in a naturally recursive way by considering several cases. If the list is null, it has no value to return, so you’ll return <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>. If the list isn’t empty and the position you asked for is 0, you want the first element of the list. If the list isn’t empty and you want some element further down the list, advance by one position and apply recursion. The following code does exactly that:</p>&#13;
<pre id="pre-156"><code>const at = (list, position) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list)) {&#13;
   return undefined;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (position === 0) {&#13;
   return list.value;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   return at(list.next, position - 1);&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">The logic closely follows the three cases: checking for an empty list <span class="CodeAnnotation" aria-label="annotation1">❶</span>, testing for the head of the list <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and using recursion to advance down the list <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3"><span id="sec8"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value</span></h5>&#13;
<p class="TNI1">Finally, you can search a list to see whether it includes a given value. This operation isn’t as common, but you’ll do it anyway to gain more experience with this structure. The general logic is similar to <span class="SANS_TheSansMonoCd_W5Regular_11">at(...)</span> in the example you just saw. Assume you have a <span class="SANS_TheSansMonoCd_W5Regular_11">ptr</span> pointer to an element of the list. If the pointer is null, the value isn’t in the list. Otherwise, if the object <span class="SANS_TheSansMonoCd_W5Regular_11">ptr</span> points to has the value you want, you’ve found it. If the value isn’t what you want, keep searching from the next node onward. Here’s the recursive logic:</p>&#13;
<pre id="pre-157"><code>const find = (list, value) =&gt; {&#13;
  if (isEmpty(list)) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label="184"/>  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> return false;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return list.value === value || find(list.next, value);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the list is empty, <span class="CodeAnnotation" aria-label="annotation1">❶</span> return <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>. Otherwise, if the head of the list is the value you want <span class="CodeAnnotation" aria-label="annotation2">❷</span>, return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. If it isn’t what you want, search the list’s tail. (Note that you’re grouping the two tests together by using JavaScript’s <span class="SANS_TheSansMonoCd_W5Regular_11">||</span> operator.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3"><span id="sec9"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Dynamic Memory Lists</span></h5>&#13;
<p class="TNI1">To wrap up this discussion of dynamic memory lists, let’s analyze their performance (see <a href="chapter10.xhtml#tab10-4">Table 10-4</a>).</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-4:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Dynamic Memory</span> <span class="SANS_Futura_Std_Book_11">Lists</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Size</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">At</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">As with the array-based implementation, creating a new list and checking whether it’s empty are both <i>O</i>(1) operations, but all other operations become <i>O</i>(<i>n</i>)! This difference suggests that simply implementing arrays with pointers, as was shown earlier, isn’t the best solution. However, some varieties of lists that have a more specific set of operations suited to their particular requirements achieve better performance.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1"><span id="sec10"/><span id="h1-48"/><span class="SANS_Futura_Std_Bold_B_11">Varieties of Lists</span></h3>&#13;
<p class="TNI1">For some tasks, a more specialized ADT is needed than the basic ADT and implementation for common lists that you explored in the previous section. Specifically, we’ll consider stacks, queues, deques, and circular lists, including their specific operations and applications.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-81"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Stacks</span></h4>&#13;
<p class="TNI1">A <i>stack</i> is a last-in, first-out (LIFO) data structure, similar to an actual physical stack of plates: imagine you can add a plate only to the top of the pile or remove only the top plate; adding or removing middle plates isn’t allowed. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label="185"/>Stacks behave in the same way. You’ll add and remove only at the top, and these operations are usually known as <i>push</i> and <i>pop</i>, respectively. You’ll also want to check whether a stack is empty (as with common lists) and learn the value at the top. (Sometimes the pop operation is defined to return the updated stack and also what the top value is. In that case you wouldn’t need an operation to get the top value of the stack, since you could just pop it, use it, and push it again.)</p>&#13;
<p class="TX"><a href="chapter10.xhtml#tab10-5">Table 10-5</a> sums up the operations you’ll need, and as mentioned previously, you’re dealing with a smaller, more specific set of operations here.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-5"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-5:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Stacks</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">S</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new stack.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">S</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the stack is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Push</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">S × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">S</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add a value at the top of the stack.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pop</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">S</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">S</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove the value at the top of the stack.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">S</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Get the value at the top of the stack.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Stacks are frequently used in applications. For example, to explore how to implement a recursive depth-first process in an iterative fashion by using a stack, check out question 13.3 in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>. One uncommon place where you’ll find a stack is in Hewlett-Packard calculators that provide reverse Polish notation (RPN): you push numbers into a stack, and then operations pop them, do whatever calculation you asked, and push the result back in.</p>&#13;
<p class="TX">Stacks are also used in programming languages like FORTH or WebAssembly (WASM), as well as page description languages like PostScript. Central processing units (CPUs) use stacks for subroutine calls and interruptions. If code is executing and an interruption comes in, the current status is pushed into a stack, and the interruption is processed; afterward, the normal execution resumes after popping the status from the stack. (Obviously, you could have a new interruption while processing an old one. In that case, the status for the first interruption is also pushed, then the second interruption is processed, and when finished, the status for the first interruption is popped to continue processing it.)</p>&#13;
<p class="TX">Finally, JavaScript itself implements a stack for calls. Whenever a function calls itself, it’s as if the current status and variables were pushed into a stack before starting the recursive call. When returning from a recursive call, the old status is popped from the stack and execution recommences from where it stopped.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3"><span id="sec12"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Data Structure</span></h5>&#13;
<p class="TNI1">Implementing a stack with an array is simple given that you can directly use <span class="SANS_TheSansMonoCd_W5Regular_11">.pop(...)</span> and .<span class="SANS_TheSansMonoCd_W5Regular_11">push(...)</span>(see question 10.5). Working with linked memory is also simple, and you’ll base the code on the functions you wrote for lists. In this structure you’ll have a pointer to the first element, the one at the top of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label="186"/>the stack, and each element will have a <span class="SANS_TheSansMonoCd_W5Regular_11">.next</span> pointer to the element “below” it. The “bottom” element will have a null pointer. <a href="chapter10.xhtml#fig10-4">Figure 10-4</a> shows how it works.</p>&#13;
<figure class="IMG"><img class="img4" id="fig10-4" src="../images/Figure10-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-4: A stack implemented with dynamic memory</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Pushing a new value onto a nonempty stack just requires adding a new object that points to the old top element and changing the top pointer (see <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig10-5" src="../images/Figure10-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-5: Pushing a new element on top of a stack</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Popping the top element is even simpler: adjust the top pointer to point to the next one, as shown in <a href="chapter10.xhtml#fig10-6">Figure 10-6</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label="187"/>&#13;
<figure class="IMG"><img class="img5" id="fig10-6" src="../images/Figure10-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-6: Popping the top element from a stack</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In both cases (pushing and popping), you need to make simple changes to the logic when dealing with an empty stack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3"><span id="sec13"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Implementation</span></h5>&#13;
<p class="TNI1">A stack is a list, so creating a stack is exactly the same as creating a generic list, as shown in the previous section; just change the name:</p>&#13;
<pre id="pre-158"><code>const newStack = () =&gt; null;&#13;
const isEmpty = (stack) =&gt; stack === null;</code></pre>&#13;
<p class="TX">Examining the top requires a single line of code (all other operations on stacks are also one-liners):</p>&#13;
<pre id="pre-159"><code>const top = (stack) =&gt; (isEmpty(stack) ? undefined : stack.value);</code></pre>&#13;
<p class="TX">For an empty stack, just return <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>; otherwise, <span class="SANS_TheSansMonoCd_W5Regular_11">stack</span> points to the top element, so <span class="SANS_TheSansMonoCd_W5Regular_11">stack.value</span> is what you want.</p>&#13;
<p class="TX">Pushing a value means you’ll have a new element on top, which points to the element that was previously at the top:</p>&#13;
<pre id="pre-160"><code>const push = (stack, value) =&gt; ({value, next: stack});</code></pre>&#13;
<p class="TX">This logic also works if the stack is empty. Can you see why?</p>&#13;
<p class="TX">Finally, popping the top of the stack is also quick:</p>&#13;
<pre id="pre-161"><code>const pop = (stack) =&gt; (isEmpty(stack) ? stack : stack.next);</code></pre>&#13;
<p class="TX">If the stack is empty, return it as is. You also could easily change the code, for example, to throw an error. For a nonempty stack, just return the tail of the stack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label="188"/>&#13;
<h5 class="H3"><span id="sec14"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Performance for Dynamic Memory–Based Stacks</span></h5>&#13;
<p class="TNI1">When considering how this stack implementation performs, the results are much better than with common lists (see <a href="chapter10.xhtml#tab10-6">Table 10-6</a>).</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-6"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-6:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Dynamic Memory–Based Stacks</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Push</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pop</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">All operations require constant time, and that’s optimal. Implementing stacks with arrays, the results would <i>almost</i> be the same with an exception: pushing a new value could require moving the array to a new, larger place in memory, and that would make pushing a value an <i>O</i>(<i>n</i>) operation. In comparison to implementing common lists, which brought higher costs for most operations, implementing stacks with dynamic memory is just as good, and in a single case, even better. Now consider other variations on lists that provide similar results.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2"><span id="sec15"/><span id="h2-82"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Queues</span></h4>&#13;
<p class="TNI1"><i>Queues</i> are another variant of lists, and they are a first-in, first-out (FIFO) data structure. Queues work the same as a line of people waiting for something. New people enter the queue at the back (nobody may cut in), and the person at the front will exit the queue next. These two operations are <i>enter</i> and <i>exit</i> (or <i>enqueue</i> and <i>dequeue</i>), and they mimic what happens in real queues. You’ll also want to check whether a queue is empty and be able to get the value of the front of the queue. <a href="chapter10.xhtml#tab10-7">Table 10-7</a> shows the operations you’ll need.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-7"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-7:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Queues</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">Q</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new queue.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Q</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the queue is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Enter</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Q × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">Q</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add a value at the back of the queue.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Exit</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Q</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">Q</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove the value at the front of the queue.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Front</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Q</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Get the value at the front of the queue.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label="189"/>An alternative that’s sometimes used is that the <i>exit</i> operation returns both the updated queue and the value that was removed from the queue, but that’s not needed given the <i>front</i> operation. You could also have a <i>rear</i> operation to access the value at the end of the queue, but that’s not common.</p>&#13;
<p class="TX">Queues are frequently used in situations where things don’t have to be (or cannot be) processed immediately and should be attended to in order such as printer queues or call center phone systems that keep you on hold until a representative is free.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3"><span id="sec16"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Data Structure</span></h5>&#13;
<p class="TNI1">Implementing a queue is quite simple using arrays. With linked memory, you need pointers to the first and the last nodes of the queue, so you’ll represent a queue with an object that has <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> links. Each element in the queue has a <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> pointer to the following element, as shown in <a href="chapter10.xhtml#fig10-7">Figure 10-7</a>. (The next element is actually in the previous place in the queue, so <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> could also be the name of the pointer.)</p>&#13;
<figure class="IMG"><img class="img7" id="fig10-7" src="../images/Figure10-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-7: A queue implemented with dynamic memory</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first element in the queue (the next to exit) is 22; the following is 9. The last place in the queue is a 56. Adding a new element at the back of the queue simply requires modifying the pointer to the last element and the pointer in the last element itself (see <a href="chapter10.xhtml#fig10-8">Figure 10-8</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig10-8" src="../images/Figure10-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-8: Adding an element at the back of a queue</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After adding 80, the previous last element, 56, now points to the 80, and so does the <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> pointer.</p>&#13;
<p class="TX">Removing the element from the front of the queue is exactly the same as with stacks, as shown in <a href="chapter10.xhtml#fig10-9">Figure 10-9</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label="190"/>&#13;
<figure class="IMG"><img class="img7" id="fig10-9" src="../images/Figure10-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-9: Removing an element from the front of a queue</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You just have to make the first point at whatever the previous first element pointed at. Now you’ll see how to implement all of this.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3"><span id="sec17"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Implementation</span></h5>&#13;
<p class="TNI1">Creating a new queue and checking whether it’s empty is simple:</p>&#13;
<pre id="pre-162"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newQueue = () =&gt; ({first: null, last: null});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const isEmpty = () =&gt; .first === null;</code></pre>&#13;
<p class="TX">The queue is represented by an object with two pointers <span class="CodeAnnotation" aria-label="annotation1">❶</span> that are initially null. You can tell that the queue is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span> if one of those pointers is null; in fact, either both or none will be null.</p>&#13;
<p class="TX">Getting the value at the front (first in line) is easy:</p>&#13;
<pre id="pre-163"><code>const front = (queue) =&gt; (isEmpty(queue) ? undefined : queue.first.value);</code></pre>&#13;
<p class="TX">If the queue is empty, return <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>; otherwise, <span class="SANS_TheSansMonoCd_W5Regular_11">queue.first</span> points at the first element of the queue, and you return its <span class="SANS_TheSansMonoCd_W5Regular_11">value</span>.</p>&#13;
<p class="TX">Entering a queue at the last place is a short function:</p>&#13;
<pre id="pre-164"><code>const enter = (queue, value) =&gt; {&#13;
  if (isEmpty(queue)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> queue.first = queue.last = {value, next: null};&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> queue.last.next = {value, next: null};&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> queue.last = queue.last.next;&#13;
  }&#13;
  return queue;&#13;
};</code></pre>&#13;
<p class="TX">If the queue was empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, make the first and last pointers point to a new object, with a null pointer to the next node in the queue. Otherwise, make the last element point to a new one <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and then make <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> point to it too <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Finally, exiting the queue is the same as with stacks, but with a special case when the queue becomes empty:</p>&#13;
<pre id="pre-165"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label="191"/>const exit = (queue) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(queue)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> queue.first = queue.first.next;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (queue.first === null) {&#13;
      queue.last === null;&#13;
    }&#13;
  }&#13;
  return queue;&#13;
};</code></pre>&#13;
<p class="TX">If the queue isn’t empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you just have to make the <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> pointer <span class="CodeAnnotation" aria-label="annotation2">❷</span> point to the next element in the queue, but if the queue was emptied <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you also have to fix the <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> pointer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3"><span id="sec18"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Performance for Dynamic Memory–Based Queues</span></h5>&#13;
<p class="TNI1">Given the similarity of queues and stacks (the only difference is that <span class="SANS_TheSansMonoCd_W5Regular_11">pop</span> removes the first element of the stack, but <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> removes the last element of the queue), it’s no surprise that performance is the same, as shown in <a href="chapter10.xhtml#tab10-8">Table 10-8</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-8"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-8:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Dynamic Memory–Based Queues</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Enter</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Exit</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Front</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Again, all operations require constant time; using an array wouldn’t be as good (see question 10.9).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2"><span id="sec19"/><span id="h2-83"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Deques</span></h4>&#13;
<p class="TNI1">The next variation on lists doesn’t really have very many applications (stacks and queues are far more common), but their implementation introduces the interesting concept of double (forward and backward) linking. Assume a queue where entering or exiting is allowed at both ends. (Think of a train with several cars; new cars can be added only at the ends, and cars can be removed only from the ends.) This type of list is called a <i>deque</i> (pronounced like “deck”), which stands for “double-ended queue.”</p>&#13;
<p class="TX"><a href="chapter10.xhtml#tab10-9">Table 10-9</a> shows operations necessary for deques.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-9"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label="192"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-9:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Deques</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new deque.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether deque is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Enter at front</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">D × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add a value at the front of the deque.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Enter at back</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add a value at the back of the deque.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Exit from front</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">D</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove the value at the front of the deque.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Exit from back</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove the value at the back of the deque.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Front</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">D</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Get the value at the front of the deque.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Back</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Get the value at the back of the deque.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Basically a deque is the same as a queue, except that you enter at or exit from both ends. Similarly, you also need operations to get the values at both extremes; for queues, you looked at only the first (front) item.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3"><span id="sec20"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Data</span> <span class="SANS_Futura_Std_Bold_Condensed_B_11">Structure</span></h5>&#13;
<p class="TNI1">Is it possible to implement deques with linked memory? Since you now have full symmetry for all operations, you need links that go in both directions. <a href="chapter10.xhtml#fig10-10">Figure 10-10</a> shows how it works: if you were to drop all left-pointing links (or all right-pointing links), you’d be left with a common queue. In this structure, you’ll again have <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> pointers to the extremes of the deque, and each node will have <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> (previous) pointers to the contiguous nodes.</p>&#13;
<figure class="IMG"><img class="img1" id="fig10-10" src="../images/Figure10-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-10: Implementing a deque requires two pointers at each node.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because of the symmetry, operations on one end are totally analogous to the same operation at the other end, so let’s just work at the end of the deque (see <a href="chapter10.xhtml#fig10-11">Figure 10-11</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig10-11" src="../images/Figure10-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-11: Adding an element at one extreme of a deque</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label="193"/>Adding a value at the end is the same as for a queue, with the addition that the newly added node must point to the node that was previously at the end of the deque. (Working at the other end is exactly the same, so we’ll skip it.)</p>&#13;
<p class="TX">Removing an element from the end of the deque is the same as shown in <a href="chapter10.xhtml#fig10-11">Figure 10-11</a>, but from the bottom up; see <a href="chapter10.xhtml#fig10-12">Figure 10-12</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig10-12" src="../images/Figure10-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-12: Removing an element from one extreme of a deque</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When removing a value from the back, modify the corresponding pointer (<span class="SANS_TheSansMonoCd_W5Regular_11">last</span>) and the <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> pointer of the new extreme of the deque; working at the other extreme entails modifying <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and a <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> pointer.</p>&#13;
<p class="TX">Deletions are simple in doubly linked lists. If you have a pointer to some element and want to remove it (say, the 60 in the list shown in <a href="chapter10.xhtml#fig10-13">Figure 10-13</a>), doing so is easy.</p>&#13;
<figure class="IMG"><img class="img1" id="fig10-13" src="../images/Figure10-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-13: Removing an element somewhere in a deque</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The key is that all nodes have pointers to both neighbors, so you have to do something along the lines of the following code, assuming that <span class="SANS_TheSansMonoCd_W5Regular_11">ptr</span> points to the node to be removed:</p>&#13;
<pre id="pre-166"><code>ptr.prev.next = ptr.next;&#13;
ptr.next.prev = ptr.prev;</code></pre>&#13;
<p class="TX">This kind of pointer work is common, but it can be jarring the first time you see it, so it merits careful study. The code works for elements in the middle of the deque. For elements at both ends, you need to make minor <span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label="194"/>changes, as well as adjust at least one of (and possibly both) the <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> elements. Even if you don’t ever use deques, the concept of double links and the ease of extracting any element from the middle is the key takeaway from this section. You’ll use this for circular lists later in this chapter and in future chapters as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3"><span id="sec21"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Implementation</span></h5>&#13;
<p class="TNI1">Creating a deque and checking whether it’s empty are exactly the same as with a queue, since you have the same <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> pointers:</p>&#13;
<pre id="pre-167"><code>const newDeque = () =&gt; ({first: null, last: null});&#13;
const isEmpty = (deque) =&gt; deque.first === null;</code></pre>&#13;
<p class="TX">Adding a new element to a deque is the same as entering a queue; the only difference is that you can add it at either extreme, subtly changing what pointers you modify:</p>&#13;
<pre id="pre-168"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newNode = (value, prev = null, next = null) =&gt; ({value, prev, next});&#13;
&#13;
const enterFront = (deque, value) =&gt; {&#13;
  if (deque.first === null) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> deque.first = deque.last = newNode(value, null, null);&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const newValue = newNode(value, deque.first, null);&#13;
    deque.first.next = newValue;&#13;
    deque.first = newValue;&#13;
  }&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> const enterBack = (deque, value) =&gt; {&#13;
  if (deque.last === null) {&#13;
    deque.first = deque.last = newNode(value, null, null);&#13;
  } else {&#13;
    const newValue = newNode(value, null, deque.last);&#13;
    deque.last.prev = newValue;&#13;
    deque.last = newValue;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">You use an auxiliary function to create a new node with its pair of pointers <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Entering at the front requires changing both <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> if the deque is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Otherwise, use the same kind of pointer work as for queues <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The code for entering a deque at the back is exactly the same, in symmetrical fashion: just change <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Similarly, removing an element from the front or back of a deque is the same as exiting from a queue; both algorithms are symmetrical:</p>&#13;
<pre id="pre-169"><code>const removeFront = (deque) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(deque)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> deque.first = deque.first.next;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label="195"/>  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (deque.first === null) {&#13;
      deque.last === null;&#13;
    }&#13;
  }&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> const removeBack = (deque) =&gt; {&#13;
  if (!isEmpty(deque)) {&#13;
    deque.last = deque.last.prev;&#13;
    if (deque.last === null) {&#13;
      deque.first === null;&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the deque is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, there’s nothing to do. Otherwise, to remove the front element, advance to the next element of the deque <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and if that element is null <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you also adjust the <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> element. A bit of symmetry produces exactly the same “remove last” operation <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3"><span id="sec22"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Performance for Dynamic Memory–Based Deques</span></h5>&#13;
<p class="TNI1">A deque is essentially a queue that goes both ways: half of its operations are exactly the same as for queues, and the rest are symmetrical, but with the same style of code, so the results are not unexpected (see <a href="chapter10.xhtml#tab10-10">Table 10-10</a>).</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-10"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-10:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Dynamic Memory–Based</span> <span class="SANS_Futura_Std_Book_11">Deques</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Enter at front (or at back)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Exit from front (or from back)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Front (or back)</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">All the operations of deques perform the same as those of queues. Everything is <i>O</i>(1).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2"><span id="sec23"/><span id="h2-84"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Circular Lists</span></h4>&#13;
<p class="TNI1">Circular lists are useful for “round-robin”–style processing. For example, PCs place apps in a list and cycle through them, and after the last completes, processing returns to the first. (You’ll see another example of this when looking at Fibonacci heaps in <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span>.) Instead of an open-ended list, a circular list joins the first and last elements together. This kind of ADT allows for continuous processing, with a “current” element and the possibility of advancing to the next, but cyclically. <a href="chapter10.xhtml#tab10-11">Table 10-11</a> shows the operations we’ll need.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-11"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label="196"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-11:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Circular</span> <span class="SANS_Futura_Std_Book_11">Lists</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">C</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new circular list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">C</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the circular list is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">C × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">C</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add a new value before the current one and make it current.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">C</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">C</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove the current value from the list and advance.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Current</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">C</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Get the current value from the circular list.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB"><span class="SANS_Futura_Std_Book_11">Advance</span></p></td>&#13;
<td class="TBL"><p class="TB"><span class="SANS_Futura_Std_Book_11">C</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">C</span></p></td>&#13;
<td class="TBL"><p class="TB"><span class="SANS_Futura_Std_Book_11">Advance to the next value in the list cyclically.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Some variations and changes are possible. You could require a “go back” (retreat) operation that performs in the opposite direction as an “advance.” You could also use an “add after current,” but you could achieve that by first advancing and then using the add operation. These changes aren’t significant, and the structure is useful as shown. The work you did with deques, however, will help in implementing it.</p>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h5 class="H3"><span id="sec24"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Data Structure</span></h5>&#13;
<p class="TNI1">Circular lists can be singly or doubly linked, but the latter is the most useful version. Basically, you just want a list that has no first or last element. Instead, the elements form a circle, and you’ll have a pointer to the element that’s being processed currently. <a href="chapter10.xhtml#fig10-14">Figure 10-14</a> shows such a list; the nodes have <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> pointers, as with deques.</p>&#13;
<figure class="IMG"><img class="img1" id="fig10-14" src="../images/Figure10-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-14: A circular list also needs two pointers at every node.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The “advance to the next” operation simply requires following the <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> link (see <a href="chapter10.xhtml#fig10-15">Figure 10-15</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/>&#13;
<figure class="IMG"><img class="img1" id="fig10-15" src="../images/Figure10-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-15: Moving along the list is possible in both directions.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Adding a new element before the current one is also a matter of dealing with several pointers (see <a href="chapter10.xhtml#fig10-16">Figure 10-16</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig10-16" src="../images/Figure10-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-16: Adding an element to a circular list is done by changing a few pointers.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Removing the current element requires some juggling with pointers, but as with deques, having links in both directions makes it easy (see <a href="chapter10.xhtml#fig10-17">Figure 10-17</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>&#13;
<figure class="IMG"><img class="img1" id="fig10-17" src="../images/Figure10-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-17: Removing an element from a circular list also requires just a few pointer changes.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Operations in a circular list require essentially the same kind of logic that you’ve already explored. Now consider an actual implementation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h5 class="H3"><span id="sec25"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Implementation</span></h5>&#13;
<p class="TNI1">Creating a circular list is the same as for common lists, and so is testing whether such a list is empty. The only difference is the naming:</p>&#13;
<pre id="pre-170"><code>const newCircularList = () =&gt; null; // current&#13;
const isEmpty = (circ) =&gt; circ === null;</code></pre>&#13;
<p class="TX">In a stack, you had a pointer to the top element. Here you have a pointer to some element in the list, the current one.</p>&#13;
<p class="TX">Adding a new node merely involves more work with pointers:</p>&#13;
<pre id="pre-171"><code>const add = (circ, valueToAdd) =&gt; {&#13;
  const newNode = {value: valueToAdd};&#13;
  if (isEmpty(circ)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> newNode.next = newNode;&#13;
    newNode.prev = newNode;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> newNode.next = circ;&#13;
    newNode.prev = circ.prev;&#13;
    circ.prev.next = newNode;&#13;
    circ.prev = newNode;&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return newNode;&#13;
};</code></pre>&#13;
<p class="TX">If the list is empty, it consists of a single node <span class="CodeAnnotation" aria-label="annotation1">❶</span> whose <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> links point to itself. Otherwise, the new node is between the nodes that <span class="SANS_TheSansMonoCd_W5Regular_11">circ</span> (the current node) and <span class="SANS_TheSansMonoCd_W5Regular_11">circ.prev</span> (the previous one) point to. Fix the four <span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/>involved pointers so that the new node lies in its correct place <span class="CodeAnnotation" aria-label="annotation2">❷</span>. At the end, return the new node <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Removing the current element is a tad shorter:</p>&#13;
<pre id="pre-172"><code>const remove = (circ) =&gt; {&#13;
  if (isEmpty(circ)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> return circ;&#13;
  } else if (circ.next === circ) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return newCircularList();&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> circ.prev.next = circ.next;&#13;
    circ.next.prev = circ.prev;&#13;
    return circ.next;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">You have three distinct cases to consider. If the circular list is empty, do nothing <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the list consists of a single element (and in that case both its <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> links point to itself), return a new, empty list <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, if the list isn’t empty, make the nodes at <span class="SANS_TheSansMonoCd_W5Regular_11">circ.prev</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">circ.next</span> (the ones that surround the current node) point to each other <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Finally, getting the current value and advancing to the next one are both one-liners:</p>&#13;
<pre id="pre-173"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const current = (circ) =&gt; (isEmpty(circ) ? undefined : circ.value);&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const advance = (circ) =&gt; (isEmpty(circ) ? circ : circ.next);</code></pre>&#13;
<p class="TX">The current element of an empty list is just undefined <span class="CodeAnnotation" aria-label="annotation1">❶</span>; otherwise, <span class="SANS_TheSansMonoCd_W5Regular_11">circ.value</span> gives its value. Advancing the current element to the next position, for a nonempty circular list, is just a matter of going to the <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> node <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h5 class="H3"><span id="sec26"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Performance for Circular Lists</span></h5>&#13;
<p class="TNI1">Checking all the implemented functions, none of them require loops or recursion, so as with other data structures in this chapter, the performance is constant (see <a href="chapter10.xhtml#tab10-12">Table 10-12</a>).</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab10-12"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 10-12:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Circular</span> <span class="SANS_Futura_Std_Book_11">Lists</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Current</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Advance</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label="200"/>You could use arrays, of course, but the performance for some operations, such as adding a new value, would suffer because of the possible need to move the whole array to a new place in memory: <i>O</i>(<i>n</i>).</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1"><span id="sec27"/><span id="h1-49"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter we examined several linear structures and a circular one that are based on linked memory, and you’ll have the opportunity to reuse them in later chapters. Linked memory is key for all the dynamic structures we’ll explore in this book, and in upcoming chapters, we’ll work with more complex structures to enable better performance for more complex operations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h3 class="H1"><span id="sec28"/><span id="h1-50"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>10.1  Iterating Through Lists</b></p>&#13;
<p class="ListPlainFirst">All the examples in the “<span class="listplain_Xref">Implementing Lists with Dynamic Memory</span>” <span class="listplain_Xref">section</span> on <span class="listplain_Xref"><a href="chapter10.xhtml#pg_180">page 180</a></span> were written using recursion, but they are often coded in iterative fashion. Can you rewrite them in that way?</p>&#13;
<p class="ListHead"><b>10.2  Going the Other Way</b></p>&#13;
<p class="ListPlainFirst">Implement a <span class="SANS_TheSansMonoCd_W5Regular_11">reverse(list)</span> algorithm that given a list will reverse it, meaning the first element becomes the last, the second element the next to last, and so on.</p>&#13;
<p class="ListHead"><b>10.3  Joining Forces</b></p>&#13;
<p class="ListPlainFirst">Implement an <span class="SANS_TheSansMonoCd_W5Regular_11">append(list1, list2)</span> function that given two lists will append the second one to the first one.</p>&#13;
<p class="ListHead"><b>10.4  Unloop the Loop</b></p>&#13;
<p class="ListPlainFirst">Imagine you are given a list that may or may not have a loop; in other words, instead of eventually finishing with a null pointer, there may be an element that points back to some previous element, so the list has a loop. Can you write a <span class="SANS_TheSansMonoCd_W5Regular_11">hasALoop(list)</span> function that given a <span class="SANS_TheSansMonoCd_W5Regular_11">list</span> will determine whether it has a loop? Your solution should use constant extra memory; don’t assume anything about the length of the list, because it may be incredibly long.</p>&#13;
<p class="ListHead"><b>10.5  Arrays for Stacks</b></p>&#13;
<p class="ListPlainFirst">Since JavaScript provides operations on arrays like <span class="SANS_TheSansMonoCd_W5Regular_11">.pop(...)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.push(...)</span>, implementing a stack with an array should be pretty straightforward. Can you write appropriate code?</p>&#13;
<p class="ListHead"><b>10.6  Stack Printing</b></p>&#13;
<p class="ListPlainFirst">Can you write code that prints out a stack’s contents in top-to-bottom order? Could you print it in reverse (bottom-to-top) order?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/><b>10.7  Height of a Stack</b></p>&#13;
<p class="ListPlainFirst">Suppose you need to know how many elements are in a stack. How could you implement this?</p>&#13;
<p class="ListHead"><b>10.8  Maximum Stack</b></p>&#13;
<p class="ListPlainFirst">Suppose that you need a stack for some process, but you also need to know, after each push or pop, the maximum value in the stack. How can you implement this efficiently without having to go through the whole stack every time?</p>&#13;
<p class="ListHead"><b>10.9  Queued Arrays</b></p>&#13;
<p class="ListPlainFirst">In a previous question, you saw that JavaScript provided operations that made it simple to emulate a stack with arrays. Is the same true for queues? How would you emulate queues with arrays? What would the performance of such an implementation be?</p>&#13;
<p class="ListHead"><b>10.10  Queue Length</b></p>&#13;
<p class="ListPlainFirst">Write a function that given a queue will count how many values are in it; in other words, find the queue’s length.</p>&#13;
<p class="ListHead"><b>10.11  Queueing for Sorting</b></p>&#13;
<p class="ListPlainFirst">In <span class="listplain_Xref"><a href="chapter6.xhtml">Chapter 6</a></span> you implemented radix sort with arrays, but using queues and linked memory is more efficient. Can you rewrite the algorithm accordingly?</p>&#13;
<p class="ListHead"><b>10.12  Stacked Queues</b></p>&#13;
<p class="ListPlainFirst">Imagine that you needed to use a queue for some program, but all you had was a library that implemented stacks. With some trickery, you can simulate a queue by using a pair of stacks; can you see how? (You’ll explore this strategy in <span class="listplain_Xref"><a href="chapter18.xhtml">Chapter 18</a></span>.)</p>&#13;
<p class="ListHead"><b>10.13  Palindrome Detection</b></p>&#13;
<p class="ListPlainFirst">How could you use a deque to decide whether a string is a palindrome? Palindromes are words that can be read the same way forward or backward, like “Hannah” or “radar,” or ignoring spaces and punctuation “Step on no pets” or “A man, a plan, a canal: Panama.”</p>&#13;
<p class="ListHead"><b>10.14  Circular Listing</b></p>&#13;
<p class="ListPlainFirst">Implement a function to list all the contents of a circular list; take care not to go into a loop.</p>&#13;
<p class="ListHead"><b>10.15  Joining Circles</b></p>&#13;
<p class="ListPlainFirst">Suppose you have two circular lists. How could you join them into a single, larger list? For simplicity, assume neither of the lists is empty.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>