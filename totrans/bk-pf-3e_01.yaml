- en: Chapter 1. Building the Network you Need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Building the Network you Need](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PF, the OpenBSD *Packet Filter subsystem*, is in my opinion the finest tool
    available for taking control of your network. Before diving into the specifics
    of how to make your network the fine-tuned machinery of your dreams, please read
    this chapter. It introduces basic networking terminology and concepts, provides
    some PF history, and gives you an overview of what you can expect to find in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Network: High Performance, Low Maintenance, and Secure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If this heading accurately describes your network, you’re most likely reading
    this book for pure entertainment, and I hope you’ll enjoy the rest of it. If,
    on the other hand, you’re still learning how to build networks or you’re not quite
    confident of your skills yet, a short recap of basic network security concepts
    can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Information technology (IT) security is a large, complex, and sometimes confusing
    subject. Even if we limit ourselves to thinking only in terms of network security,
    it may seem that we haven’t narrowed down the field much or eliminated enough
    of the inherently confusing terminology. Matters became significantly worse some
    years ago when personal computers started joining the networked world, equipped
    with system software and applications that clearly weren’t designed for a networked
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The result was predictable. Even before the small computers became networked,
    they’d become home to malicious software, such as *viruses* (semiautonomous software
    that is able to “infect” other files in order to deliver its payload and make
    further copies of itself) and *trojans* (originally *trojan horses*, software
    or documents with code embedded that, if activated, would cause the victim’s computer
    to perform actions the user didn’t intend). When the small computers became networked,
    they were introduced to yet another kind of malicious software called a *worm*,
    a class of software that uses the network to propagate its payload.^([[1](#ftn.ch01fn01)])
    Along the way, the networked versions of various kinds of frauds made it onto
    the network security horizon as well, and today a significant part of computer
    security activity (possibly the largest segment of the industry) centers on threat
    management, with emphasis on fighting and cataloging malicious software, or *malware*.
  prefs: []
  type: TYPE_NORMAL
- en: The futility of enumerating badness has been argued convincingly elsewhere (see
    [Appendix A](apa.html "Appendix A. Resources") for references, such as Marcus
    Ranum’s excellent essay “The Six Dumbest Ideas in Computer Security”). The OpenBSD
    approach is to design and code properly in the first place. However, even smart
    people make mistakes every now and then, producing bugs, so make sure to design
    the system to allow any such failure to have the least possible impact security-wise.
    Then, if you later discover mistakes and the bugs turn out to be exploitable,
    fix those bugs wherever similar code turns up in the tree, even if it could mean
    a radical overhaul of the design and, at worst, a loss of backward compatibility.^([[2](#ftn.ch01fn02)])
  prefs: []
  type: TYPE_NORMAL
- en: In PF, and by extension in this book, the focus is narrower, concentrated on
    network traffic at the network level. The introduction of divert(4) sockets in
    OpenBSD 4.7 made it incrementally easier to set up a system where PF contributes
    to *deep packet inspection*, much like some fiercely marketed products. However,
    the interface is not yet widely used in free software for that purpose, although
    exceptions exist. Therefore, we’ll instead focus on some techniques based on pure
    network-level behavior, which are most evident in the example configurations in
    [Chapter 6](ch06.html "Chapter 6. Turning the Tables for Proactive Defense").
    These techniques will help ease the load on content-inspecting products if you
    have them in place. As you’ll see in the following chapters, the network level
    offers a lot of fun and excitement, in addition to the blocking or passing packets.
  prefs: []
  type: TYPE_NORMAL
- en: Where the Packet Filter Fits In
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The packet filter’s main function is, as the name suggests, to filter network
    packets by matching the properties of individual packets and the network connections
    built from those packets against the filtering criteria defined in its configuration
    files. The packet filter is responsible for deciding what to do with those packets.
    This could mean passing them through or rejecting them, or it could mean triggering
    events that other parts of the operating system or external applications are set
    up to handle.
  prefs: []
  type: TYPE_NORMAL
- en: PF lets you write custom filtering criteria to control network traffic based
    on essentially any packet or connection property, including address family, source
    and destination address, interface, protocol, port, and direction. Based on these
    criteria, the packet filter performs the action you specify. One of the simplest
    and most common actions is to block traffic.
  prefs: []
  type: TYPE_NORMAL
- en: A packet filter can keep unwanted traffic out of your network. It can also help
    contain network traffic inside your own network. Both these functions are important
    to the *firewall* concept, but blocking is far from the only useful or interesting
    feature of a functional packet filter. As you’ll see in this book, you can use
    filtering criteria to direct certain kinds of network traffic to specific hosts,
    assign classes of traffic to queues, perform traffic shaping, and even hand off
    selected kinds of traffic to other software for special treatment.
  prefs: []
  type: TYPE_NORMAL
- en: All this processing happens at the network level, based on packet and connection
    properties. PF is part of the network stack, firmly embedded in the operating
    system kernel. While there have been examples of packet filtering implemented
    in user space, in most operating systems, the filtering functions are performed
    in the kernel because it’s faster to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The Rise of PF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a taste for history, you probably already know that OpenBSD and
    the other BSDs^([[3](#ftn.ch01fn03)]) are direct descendants of the BSD system
    (sometimes referred to as *BSD Unix*), the operating system that contained the
    original reference implementation of the TCP/IP Internet protocols in the early
    1980s.
  prefs: []
  type: TYPE_NORMAL
- en: As the research project behind BSD development started winding down in the early
    1990s, the code was liberated for further development by small groups of enthusiasts
    around the world. Some of these enthusiasts were responsible for keeping vital
    parts of the emerging Internet’s infrastructure running reliably, and BSD development
    continued along parallel lines in several groups. The OpenBSD group became known
    as the most security-oriented of the BSDs. For its packet-filtering needs, it
    used a subsystem called *IPFilter*, written mainly by Darren Reed. During these
    early years, OpenBSD quickly earned a positive reputation as “THE firewall OS,”
    and it’s still quite common for people to believe that OpenBSD was developed specifically
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: It shocked the OpenBSD community when Reed announced in early 2001 that IPFilter,
    which at that point was intimately integrated with OpenBSD, wasn’t covered under
    the BSD license. Instead, it used almost a word-for-word copy of the license,
    omitting only the right to make changes to the code and distribute the result.
    The problem was that the OpenBSD version of IPFilter contained several changes
    and customizations that, as it turned out, were not allowed under the license.
    As a result, IPFilter was deleted from the OpenBSD source tree on May 29, 2001,
    and for a few weeks, the development version of OpenBSD (-current) didn’t include
    any packet filter software.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, at this time, in Switzerland, Daniel Hartmeier had been performing
    some limited experiments involving kernel hacking in the networking code. He began
    by hooking a small function of his own into the networking stack and then making
    packets pass through it. Then, he began thinking about filtering. When the license
    crisis happened, PF was already under development on a small scale. The first
    commit of the PF code was on Sunday, June 24, 2001, at 19:48:58 UTC. A few months
    of intense activity by many developers followed, and the resulting version of
    PF was launched as a default part of the OpenBSD 3.0 base system in December of
    2001.^([[4](#ftn.ch01fn04)]) This version contained an implementation of packet
    filtering, including network address translation, with a configuration language
    that was similar enough to IPFilter’s that migrating to the new OpenBSD version
    did not pose major problems.^([[5](#ftn.ch01fn05)])
  prefs: []
  type: TYPE_NORMAL
- en: PF proved to be well-developed software. In 2002, Hartmeier presented a USENIX
    paper with performance tests showing that the OpenBSD 3.1 PF performed equally
    well or better under stress than either IPFilter on OpenBSD 3.1 or iptables on
    Linux. In addition, tests run on the original PF from OpenBSD 3.0 showed mainly
    that the code had gained in efficiency from version 3.0 to version 3.1.^([[6](#ftn.ch01fn06)])
  prefs: []
  type: TYPE_NORMAL
- en: The OpenBSD PF code, with a fresh packet-filtering engine written by experienced
    and security-oriented developers, naturally generated interest in the sister BSDs
    as well. The FreeBSD project gradually adopted PF, first as a package and then,
    from version 5.3 on, in the base system as one of three packet-filtering systems.
    PF has also been included in NetBSD and DragonFly BSD.^([[7](#ftn.ch01fn07)])
  prefs: []
  type: TYPE_NORMAL
- en: This book focuses on the PF version available in OpenBSD 5.5\. I’ll note significant
    differences between that version and the ones integrated in other systems as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re ready to dive into PF configuration, you can jump to [Chapter 2](ch02.html
    "Chapter 2. PF Configuration Basics") to get started. If you want to spend a little
    more time getting your bearings in unfamiliar BSD territory, continue reading
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Newer PF Releases Perform Better
  prefs: []
  type: TYPE_NORMAL
- en: Like the rest of the computing world, OpenBSD and PF have been affected by rapid
    changes in hardware and network conditions. I haven’t seen tests comparable to
    the ones in Daniel Hartmeier’s USENIX paper performed recently, but PF users have
    found that the filtering overhead is modest.
  prefs: []
  type: TYPE_NORMAL
- en: As an example (mainly to illustrate that even unexciting hardware configurations
    can be useful), the machine that gateways between one small office network in
    my care and the world is a Pentium III 450MHz with 384MB of RAM. When I’ve remembered
    to check, I’ve never seen the machine at less than 96 percent idle according to
    the output from the `top(1)` command.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that the current PF developers, mainly Henning Brauer
    and Ryan McBride, with contributions from several others, rewrote large portions
    of OpenBSD’s PF code with improved performance as a stated main goal during recent
    releases, making each release from 4.4 through 5.6 perform noticeably better than
    its predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: If You Came from Elsewhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re reading this because you’re considering moving your setup to PF from
    some other system, this section is for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use PF, you need to install and run a BSD system, such as OpenBSD,
    FreeBSD, NetBSD, or DragonFly BSD. These are all fine operating systems, but my
    personal favorite is OpenBSD, mainly because that’s the operating system where
    essentially all PF development happens. I also find the no-nonsense approach of
    the developers and the system refreshing.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, minor changes and bug fixes trickle back to the main PF code base
    from the PF implementations on other systems, but the newest, most up-to-date
    PF code is always to be found on OpenBSD. Some of the features described in this
    book are available only in the most recent versions of OpenBSD. The other BSDs
    have tended to port the latest released PF version from OpenBSD to their code
    bases in time for their next release, but synchronized updates are far from guaranteed,
    and the lag is sometimes considerable.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re planning to run PF on FreeBSD, NetBSD, DragonFly BSD, or another system,
    you should check your system’s release notes and other documentation for information
    about which version of PF is included.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers for Linux Users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The differences and similarities between Linux and BSD are potentially a large
    topic if you probe deeply, but if you have a reasonable command of the basics,
    it shouldn’t take too long for you to feel right at home with the BSD way of doing
    things. In the rest of this book, I’ll assume you can find your way around the
    basics of BSD network configuration. So, if you’re more familiar with configuring
    Linux or other systems than you are with BSD, it’s worth noting a few points about
    BSD configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux and BSD use different conventions for naming network interfaces. The Linux
    convention is to label all the network interfaces on a given machine in the sequence
    `eth0`, `eth1`, and so on (although with some Linux versions and driver combinations,
    you also see `wlan0`, `wlan1`, and so on for wireless interfaces).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the BSDs, interfaces are assigned names that equal the driver name plus a
    sequence number. For example, older 3Com cards using the ep driver appear as `ep0`,
    `ep1`, and so on; Intel Gigabit cards are likely to end up as `em0`, `em1`, and
    so on. Some SMC cards are listed as `sn0`, `sn1`, and so on. This system is quite
    logical and makes it easier to find the documentation for the specifics of that
    interface. If your kernel reports (at boot time or in `ifconfig` output) that
    you have an interface called `em0`, you need only type `man em` at a shell command-line
    prompt to find out what speeds it supports—whether there are any eccentricities
    to be aware of, whether any firmware download is needed, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should be aware that in BSDs, the configuration is */etc/rc.conf*-centric.
    In general, the BSDs are organized to read the configuration from the file */etc/rc.conf*,
    which is read by the */etc/rc* script at startup. OpenBSD recommends using */etc/rc.conf.local*
    for local customizations because *rc.conf* contains the default values. FreeBSD
    uses */etc/defaults/rc.conf* to store the default settings, making */etc/rc.conf*
    the correct place to make changes. In addition, OpenBSD uses per-interface configuration
    files called *hostname.<if>*, where *<if>* is replaced with the interface name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of learning PF, you’ll need to concentrate on an */etc/pf.conf*
    file, which will be largely your own creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a broader and more thorough introduction to your BSD of choice,
    look up the operating system’s documentation, including FAQs and guides, at the
    project’s website. You can also find some suggestions for further reading in [Appendix A](apa.html
    "Appendix A. Resources").
  prefs: []
  type: TYPE_NORMAL
- en: Frequently Answered Questions About PF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section is based on questions I’ve been asked via email or at meetings
    and conferences as well as some that have popped up in mailing lists and other
    discussion forums. Some of the more common questions are covered here in a FAQ-style^([[8](#ftn.ch01fn08)])
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Can I run PF on my Linux machine?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a word, no. Over the years, announcements have appeared on the PF mailing
    list from someone claiming to have started a Linux port of PF, but at the time
    of this writing, no one has yet claimed to have completed the task. The main reason
    for this is probably that PF is developed primarily as a deeply integrated part
    of the OpenBSD networking stack. Even after more than a decade of parallel development,
    the OpenBSD code still shares enough fundamentals with the other BSDs to make
    porting possible, but porting PF to a non-BSD system would require rewriting large
    chunks of PF itself as well as whatever integration is needed at the target side.
  prefs: []
  type: TYPE_NORMAL
- en: For some basic orientation tips for Linux users to find their way in BSD network
    configurations, see [Pointers for Linux Users](ch01.html#pointers_for_linux_users
    "Pointers for Linux Users").
  prefs: []
  type: TYPE_NORMAL
- en: Can you recommend a GUI tool for managing my PF rule set?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This book is mainly oriented toward users who edit their rule sets in their
    favorite text editor. The sample rule sets in this book are simple enough that
    you probably wouldn’t get a noticeable benefit from any of the visualization options
    the various GUI tools are known to offer.
  prefs: []
  type: TYPE_NORMAL
- en: A common claim is that the PF configuration files are generally readable enough
    that a graphic visualization tool isn’t really necessary. There are, however,
    several GUI tools available that can edit and/or generate PF configurations, including
    a complete, customized build of FreeBSD called *pfSense* (*[http://www.pfsense.org/](http://www.pfsense.org/)*),
    which includes a sophisticated GUI rule editor.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you work through the parts of this book that apply to your
    situation and then decide whether you need to use a GUI tool to feel comfortable
    running and maintaining the systems you build.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a tool I can use to convert my OtherProduct^® setup to a PF configuration?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best strategy when converting network setups, including firewall setups,
    from one product to another is to go back to the specifications or policies for
    your network or firewall configuration and then implement the policies using the
    new tool.
  prefs: []
  type: TYPE_NORMAL
- en: Other products will inevitably have a slightly different feature set, and the
    existing configuration you created for OtherProduct^® is likely to mirror slightly
    different approaches to specific problems, which do not map easily, or at all,
    to features in PF and related tools.
  prefs: []
  type: TYPE_NORMAL
- en: Having a documented policy, and taking care to update it as your needs change,
    will make your life easier. This documentation should contain a complete prose
    specification of what your setup is meant to achieve. (You might start out by
    putting comments in your configuration file to explain the purpose of your rules.)
    This makes it possible to verify whether the configuration you’re running actually
    implements the design goals. In some corporate settings, there may even be a formal
    requirement for a written policy.
  prefs: []
  type: TYPE_NORMAL
- en: The impulse to look for a way to automate your conversion is quite understandable
    and perhaps expected in a system administrator. I urge you to resist the impulse
    and to perform your conversion after reevaluating your business and technical
    needs and (preferably) after creating or updating a formal specification or policy
    in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the GUI tools that serve as administration frontends claim the ability
    to output configuration files for several firewall products and could conceivably
    be used as conversion tools. However, this has the effect of inserting another
    layer of abstraction between you and your rule set, and it puts you at the mercy
    of the tool author’s understanding of how PF rule sets work. I recommend working
    through at least the relevant parts of this book before spending serious time
    on considering an automated conversion.
  prefs: []
  type: TYPE_NORMAL
- en: I heard PF is based on IPFilter, which I know from working with Solaris. Can
    I just copy my IPFilter configuration across and have a working setup right away?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If people claim that PF is “based on” IPFilter, they are saying something that
    isn’t true. PF was written from scratch to be a replacement for the newly deleted
    IPFilter code. For that first version of PF, one of the design goals was to keep
    the syntax fairly compatible with the older software so the transition to OpenBSD
    3.0 would be as painless as possible and not break existing setups too badly or
    in unpredictable ways.
  prefs: []
  type: TYPE_NORMAL
- en: However, a version or two down the road, it was reasonable to believe that no
    OpenBSD users were still likely to upgrade from a version that contained IPFilter,
    so staying compatible with the older system fell off the list of priorities. Some
    syntax similarities remain, even after 25 OpenBSD releases and more than 12 years
    of active development. Trying to load one system’s configuration on the other—for
    example, copying across an IPFilter configuration to an OpenBSD system and trying
    to load it there or copying a modern PF configuration to a Solaris system and
    trying to load it as an IPFilter configuration—is guaranteed to fail in almost
    all cases, except for a few specially crafted but still quite trivial and, in
    fact, rather useless configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Why did the PF rule syntax change all of a sudden?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The world changed, and PF changed with it. More specifically, the OpenBSD developers
    have a very active and pragmatically critical relationship to their code, and
    like all parts of OpenBSD, the PF code is under constant review.
  prefs: []
  type: TYPE_NORMAL
- en: The lessons learned over more than a decade of PF development and use led to
    internal changes in the code that eventually made it clear to the developers that
    changing the syntax slightly would make sense. The changes would make the PF syntax
    more consistent and make life easier for users in the long run at the price of
    some light edits of configuration files. The result for you, the user, is that
    PF is now even easier to use and that it performs better than the earlier versions.
    If you’re upgrading your system to OpenBSD 4.7 or newer, you’re in for a real
    treat.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with OpenBSD 5.5, you’ll find another good reason to upgrade: the new queuing
    system for traffic shaping, which is intended to replace the venerable ALTQ system.
    ALTQ is still part of OpenBSD 5.5, although in slightly modified form, but it
    has already been removed from the OpenBSD kernel in time for the OpenBSD 5.6 release.
    [Chapter 7](ch07.html "Chapter 7. Traffic Shaping with Queues and Priorities")
    contains a section specifically about migrating to the new traffic-shaping system.'
  prefs: []
  type: TYPE_NORMAL
- en: Where can I find out more?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several good sources of information about PF and the systems on which
    it runs. You’ve already found one in this book. You can find references to a number
    of printed and online resources in [Appendix A](apa.html "Appendix A. Resources").
  prefs: []
  type: TYPE_NORMAL
- en: If you have a BSD system with PF installed, consult the online manual pages,
    or *man pages*, for information about your exact release of the software. Unless
    otherwise indicated, the information in this book refers to the world as it looks
    from the command line on an OpenBSD 5.5 system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Little Encouragement: A PF Haiku'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re not quite convinced yet, or even if you are, a little encouragement
    may be in order. Over the years, a good many people have said and written their
    bit about PF—sometimes odd, sometimes wonderful, and sometimes just downright
    strange.
  prefs: []
  type: TYPE_NORMAL
- en: The poem quoted here is a good indication of the level of feeling PF sometimes
    inspires in its users. This poem appeared on the PF mailing list, in a thread
    that started with a message with the subject “Things pf can’t do?” in May 2004\.
    The message was written by someone who didn’t have a lot of firewall experience
    and who consequently found it hard to get the desired setup.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, led to some discussion, with several participants saying that
    if PF was hard on a newbie, the alternatives weren’t any better. The thread ended
    in the following haiku of praise from Jason Dixon, dated May 20, 2004.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some of the concepts Dixon mentions here may sound a bit unfamiliar, but if
    you read on, it’ll all make sense soon.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#ch01fn01)]) The famous worms before the Windows era were the IBM Christmas
    Tree EXEC worm (1987) and the first Internet worm, the Morris worm (1988). A wealth
    of information about both is within easy reach of your favorite search engine.
    The Windows era of networked worms is considered to have started with the ILOVEYOU
    worm in May 2000.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[2](#ch01fn02)]) Several presentations on OpenBSD’s approach to security
    can be found via the collection at *[http://www.openbsd.org/papers/](http://www.openbsd.org/papers/)*.
    Some of my favorites are Theo de Raadt’s “Exploit Mitigation Techniques” (as well
    as the 2013 follow-up, “Security Mitigation Techniques: An Update After 10 Years”),
    Damien Miller’s “Security Measures in OpenSSH,” and Henning Brauer and Sven Dehmlow’s
    “Puffy at Work—Getting Code Right and Secure, the OpenBSD Way.”'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[3](#ch01fn03)]) If *BSD* doesn’t sound familiar, here is a short explanation:
    The acronym expands to *Berkeley Software Distribution* and originally referred
    to a collection of useful software developed for the Unix operating system by
    staff and students at the University of California, Berkeley. Over time, the collection
    expanded into a complete operating system, which in turn became the forerunner
    of a family of systems, including OpenBSD, FreeBSD, NetBSD, DragonFly BSD, and,
    by some definitions, even Apple’s Mac OS X. For a very readable explanation of
    what BSD is, see Greg Lehey’s “Explaining BSD” at *[http://www.freebsd.org/doc/en/articles/explaining-bsd/](http://www.freebsd.org/doc/en/articles/explaining-bsd/)*
    (and, of course, the projects’ websites).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#ch01fn04)]) The IPFilter copyright episode spurred the OpenBSD team
    to perform a license audit of the entire source tree in order to avoid similar
    situations in the future. Several potential problems were resolved over the months
    that followed, resulting in the removal of a number of potential license pitfalls
    for everyone involved in free software development. Theo de Raadt summed up the
    effort in a message to the *openbsd-misc* mailing list on February 20, 2003\.
    The initial drama of the license crisis had blown over, and the net gain was a
    new packet-filtering system under a free license, with the best code quality available,
    as well as better free licenses for a large body of code in OpenBSD itself and
    in other widely used free software.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#ch01fn05)]) Compatibility with IPFilter configurations was an early
    design goal for the PF developers, but it stopped being a priority once it could
    be safely assumed that all OpenBSD users had moved to PF (around the time OpenBSD
    3.2 was released, if not earlier). You shouldn’t assume that an existing IPFilter
    configuration will work without changes with any version of PF. With the syntax
    changes introduced in OpenBSD 4.7, even upgrades from earlier PF versions will
    involve some conversion work.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#ch01fn06)]) The article that provides the details of these tests is
    available from Daniel Hartmeier’s website. See *[http://www.benzedrine.cx/pf-paper.html](http://www.benzedrine.cx/pf-paper.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#ch01fn07)]) At one point, there even existed a personal firewall product
    running on Microsoft Windows, named *Core Force*, that was based on a port of
    PF. By early 2010, Core Security, the company that developed Core Force (*[http://force.coresecurity.com/](http://force.coresecurity.com/)*),
    seemed to have shifted focus to other security areas, such as penetration testing,
    but the product was still available for download.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#ch01fn08)]) The three-letter abbreviation FAQ expands to either *frequently
    asked questions* or *frequently answered questions*—both equally valid.
  prefs: []
  type: TYPE_NORMAL
