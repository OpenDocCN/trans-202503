- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SEARCHING FOR ANSWERS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For all the problems we have encountered so far, there was a direct method to
    compute the solution. But this is not always the case. For many problems, we have
    to search for the solution using some type of algorithm, such as when solving
    a Sudoku puzzle or the *n*-queens problem. In these cases, the process involves
    trying a series of steps until either we find the solution or we have to back
    up to a previous step to try an alternative route. In this chapter we’ll explore
    a number of algorithms that allow us to efficiently select a path that leads to
    a solution. Such an approach is known as a *heuristic*. In general, a heuristic
    isn’t guaranteed to find a solution, but the algorithms we explore here (thankfully)
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s often the case that a problem we’re trying to solve can be modeled with
    a *graph*. Intuitively, a graph is just a set of points (or nodes) and connecting
    lines, as illustrated in [Figure 7-1](ch07.xhtml#ch7fig1). Each node represents
    some state of the problem-solving process, and the lines extending from one node
    to other nodes represent possible alternative steps. We’ll first give some basic
    graph definitions as background before delving into the actual problem-solving
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Formally, a graph is a finite set *V* of *vertices* (or nodes) and a set *E*
    of *edges* joining different pairs of distinct vertices (see [Figure 7-1](ch07.xhtml#ch7fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Graph*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-1](ch07.xhtml#ch7fig1) above, *V* = {*a, b, c, d, e*} are the vertices
    and *E* = {(*a*, *b*), (*a*, *c*), (*b*, *c*), (*c*, *d*), (*b*, *e*), (*e*, *d*)}
    are the edges.
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of graph vertices (*v*[1], *v*[2], …, *v*[*n*]), such that there’s
    an edge connecting *v*[*i*] and *v*[*i*+1], is called a *walk*. If all the vertices
    are distinct, a walk is called a *path*. A walk where all the vertices are distinct
    except that *v*[1] = *v*[*n*] is called a *cycle* or *circuit*. In [Figure 7-1](ch07.xhtml#ch7fig1),
    the sequence (*a*, *b*, *c*, *b*) is a walk, the sequence (*a*, *b*, *c*, *d*)
    is a path, and the sequence (*a*, *b*, *c*, *a*) is a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: A graph with a path from each vertex to every other vertex is said to be *connected*.
    A connected graph without any cycles is called a *tree*. In a tree, any path is
    assumed to flow from upper nodes to lower nodes. Such a structure (where there
    are no cycles and there is only one way to get from one node to another) is known
    as a *directed acyclic graph (DAG)*. It’s possible to convert the graph above
    to a tree by removing some of its edges, as shown in [Figure 7-2](ch07.xhtml#ch7fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Tree*'
  prefs: []
  type: TYPE_NORMAL
- en: If nodes *x* and *y* are connected in such a way that it’s possible to go from
    *x* to *y*, then *y* is said to be a *child node* of *x*. Nodes without child
    nodes (such as *a*, *c*, and *d*) are known as *terminal* (or *leaf*) nodes. Problems
    that have solutions modeled by a tree structure lend themselves to simpler search
    strategies since a tree doesn’t have circuits. Searching a graph with circuits
    requires keeping track of nodes already visited so that the same nodes aren’t
    re-explored.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to label each edge of the graph with a numerical value called
    a *weight*, as shown in [Figure 7-3](ch07.xhtml#ch7fig3). This type of graph is
    called a *weighted graph*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Weighted graph*'
  prefs: []
  type: TYPE_NORMAL
- en: If *e* is an edge, the weight of the edge is designated by *w*(*e*). Weights
    can be used to represent any number of measurements such as time, cost, or distance,
    which may affect the choice of edge when searching a graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of interesting questions arise when exploring the properties of graphs.
    One such question is this: “Given any two nodes, what’s the shortest path between
    them?” Another is the famous traveling salesman problem: “Given a list of cities
    and the distances between them, what’s the shortest possible route that visits
    each city exactly once and returns to the original city?” This last question,
    where each node is visited exactly once and returns to the original node, involves
    what is called a *Hamiltonian circuit*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Graph Search***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two broad categories of strategies for searching graphs: *breadth-first
    search (BFS)* and *depth-first search (DFS)*. To illustrate these concepts, we’ll
    use the tree in [Figure 7-2](ch07.xhtml#ch7fig2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadth-First Search**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Breadth-first search involves searching a graph by fully exploring each level
    (or depth) before moving on to the next level. In the tree diagram (shown in [Figure
    7-2](ch07.xhtml#ch7fig2)), the *e* (root) node is on the first level, nodes *b*
    and *d* are on the next level, and nodes *a* and *c* are on the third level. This
    typically involves using a queue to stage the nodes to be examined. The process
    begins by pushing the root node onto the queue, as shown in [Figure 7-4](ch07.xhtml#ch7fig4):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: A queue containing the root node*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then pop the first node in the queue (*e*) and test it to see if it’s a
    goal node; if not, we push its child nodes onto the queue, as shown in [Figure
    7-5](ch07.xhtml#ch7fig5):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: The queue after node e was explored*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again we pop the first node in the queue (this time *b*) and test it to see
    if it’s a goal node; if not, we push its child nodes onto the queue, as shown
    in [Figure 7-6](ch07.xhtml#ch7fig6):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The queue after node b was explored*'
  prefs: []
  type: TYPE_NORMAL
- en: We continue in this fashion until a goal node has been found, or the queue is
    empty, in which case there’s no solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Depth-First Search**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Depth-first search works by continuing to walk down a branch of the tree until
    a goal node is found or a terminal node is reached. For example, starting at the
    root node of the tree, nodes *e*, *b*, and *a* would be examined in order. If
    none of those node are goal nodes, we back up to node *b* and examine its next
    child node, *c*. If *c* is also not a goal node, we back all the way up to *e*
    and examine its next child node, *d*. The *n*-queens problem in the next section
    provides a simple example of using depth-first search.
  prefs: []
  type: TYPE_NORMAL
- en: The *N*-Queens Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *n*-queens problem is a classic problem often used to illustrate depth-first
    search. The problem goes like this: position *n* queens on an *n*-by-*n* chess-board
    such that no queen is attacked by any other queen. In case you aren’t familiar
    with chess, a queen can attack any square on the same row, column, or diagonal
    that the queen lies on, as illustrated in [Figure 7-7](ch07.xhtml#ch7fig7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: A queen’s possible moves*'
  prefs: []
  type: TYPE_NORMAL
- en: The smallest value of *n* for which a solution exists is 4\. The two possible
    solutions are shown in [Figure 7-8](ch07.xhtml#ch7fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Solutions to the 4-queens problem*'
  prefs: []
  type: TYPE_NORMAL
- en: One reason for the popularity of this problem is that the search graph is a
    tree, meaning that with a depth-first search, there’s no possibility that a state
    previously seen will be reached again (that is, once a queen is placed, it’s not
    possible to get to a state with fewer queens in subsequent steps). This avoids
    the annoying need to keep track of previous states to ensure they aren’t explored
    again.
  prefs: []
  type: TYPE_NORMAL
- en: A simple approach to this problem is to go column by column, testing each square
    in a column and continuing until a solution has been reached (backtracking as
    required). For example, if we begin with [Figure 7-9](ch07.xhtml#ch7fig9), we
    can’t place a queen at b1 or b2, because it would be attacked by the queen at
    a1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: First queen at a1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next available square that’s not attacked is b3, resulting in [Figure 7-10](ch07.xhtml#ch7fig10):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Second queen at b3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But now when we get to column c, we’re stuck since every square in that column
    is attacked by one of the other queens. So we backtrack and move the queen in
    column b to b4 in [Figure 7-11](ch07.xhtml#ch7fig11):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Second queen at b4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can place a queen on c2 in [Figure 7-12](ch07.xhtml#ch7fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Third queen at c2*'
  prefs: []
  type: TYPE_NORMAL
- en: Alas, now there’s no spot for a queen on column d. So we backtrack all the way
    to column a and start over in [Figure 7-13](ch07.xhtml#ch7fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Backtrack to first queen at a2*'
  prefs: []
  type: TYPE_NORMAL
- en: The process continues in this manner until a solution is found.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Racket Solution***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define the chessboard as an *n*-by-*n* array constructed from a mutable
    vector with *n* elements, each of which is also an *n*-element vector, where each
    element is either a 1 or a 0 (0 means the square is unoccupied; 1 means the square
    has a queen):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To allow accessing elements of the chessboard `cb` by a row (`r`) and column
    (`c`) number, we define the following accessor forms, where `v` is the value being
    set or retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since we’re using a mutable data structure for the chessboard, we’ll need a
    mechanism to copy the board whenever a solution is found, to preserve the state
    of the board.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll of course need to be able to see the solutions, so we provide a print
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The actual code to solve the problem, `dfs`, is a straightforward depth-first
    search. As solutions are found, they’re compiled into a list called `sols`, which
    is the return value of the function. In the code below, recall that in the `let
    loop` form, we’re employing a named `let` (which we described in [Chapter 3](ch03.xhtml))
    where we’re defining a function (`loop`) that we’ll call recursively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code first tests each position to see whether the current cell is being
    attacked by any of the queens that have already been placed on the board ➊ (the
    code for `attacked` will be described shortly); if not, then that cell is marked
    as `valid`, and a queen (the number 1) is placed on that square ➋. Next we test
    whether the current square is in the final column of the board ➌; if it is, we’ve
    found a solution, so a copy of the board is placed in `sols` ➍. If we’re not on
    the last column, we then nest down to the next level (that is, the next column)
    ➎. Finally, the valid square is cleared ➏ so that additional rows in the column
    can be tested ➐. Once all the solutions have been found, they’re returned ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Where the DFS backtracking occurs in this process is a bit subtle. Suppose we’re
    at a position that is under attack by the previously placed queens, so `valid`
    ➊ is false and execution falls through ➐. Now suppose we’re also on the last row.
    In that case, the test fails ➐, so no further looping occurs and the recursive
    call returns. Either there are no following statements, in which case the entire
    loops exits, or there there additional statements to execute after returning from
    the recursive call. This can only occur where the current position is cleared
    and we’re at a previous location ➏. This is the backtrack point. Execution then
    resumes at the last `when` statement ➐.
  prefs: []
  type: TYPE_NORMAL
- en: The following function tests whether a square is under attack by any of the
    previously placed queens. It only checks the columns prior to the current column
    since the other columns of the chessboard haven’t yet been populated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To output the solutions, we define a simple routine to iterate through and print
    each solution returned by `dfs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here are a couple of test runs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Dijkstra’s Shortest Path Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given a graph with a node designated as the start node, Edsger Dijkstra’s algorithm
    finds the shortest path to any other node. The algorithm works by first assigning
    all the nodes (except the start node, which has distance zero) an infinite distance.
    As the algorithm progresses, the node distances are refined until their true distance
    can be determined.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the weighted graph introduced in [Figure 7-3](ch07.xhtml#ch7fig3)
    earlier to illustrate Dijkstra’s algorithm (where *S* is the starting node). The
    algorithm we describe will employ something called a priority queue. A *priority
    queue* is similar to a regular queue, but in a priority queue, each item has an
    associated value, called its priority, that controls its order in the queue. Instead
    of following a first-in, first-out sequence, items with a higher priority are
    ordered ahead of other items. Since we’re interested in finding the shortest path,
    shorter distances will be given a higher priority than longer ones.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram in [Figure 7-14](ch07.xhtml#ch7fig14) illustrates the
    starting conditions of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Starting conditions for finding the shortest paths from S*'
  prefs: []
  type: TYPE_NORMAL
- en: Node distances from the start node are given just outside the node circle. Nodes
    that haven’t been visited are assigned a tentative distance value of infinity
    (except for the start node, which has a value of zero). The queue shows the nodes
    with distance values indicated by exponents.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to pop the first node in the queue (which will always have
    a known distance) and color it with a light background as shown here in [Figure
    7-15](ch07.xhtml#ch7fig15). Set this node as the current node, *u* (in this case
    *u* = *S* with a distance value of zero).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Step 1 of Dijkstra’s algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The neighbors of *u* are given in a darker color. We then perform the following
    tentative distance calculation, *t*, for each neighbor (designated *v*) of *u*
    that’s still in the queue, where *d*(*u*) is the known distance from the start
    node to *u*, and *l*(*u*, *v*) is the distance value of the edge from *u* to *v*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If *t* is less than the prior distance value (initially *∞*), the queue is updated
    with the new node distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the queue updated, we repeat the process, this time popping *c* off the
    queue, making it the current node (in other words, *u* = *c*), and updating the
    queue and neighbor distances as before. The state of the graph is then as follows
    in [Figure 7-16](ch07.xhtml#ch7fig16):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: Step 2 of Dijkstra’s algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: We show the path from *S* to *c* in a thicker gray line to indicate a known
    shortest path in [Figure 7-16](ch07.xhtml#ch7fig16). The sequence of diagrams
    in [Figure 7-17](ch07.xhtml#ch7fig17) illustrates the remainder of the process.
    Notice that in [Figure 7-17](ch07.xhtml#ch7fig17)a the original distance of node
    *a* has been updated from 12 to 9 based on the path now being from *S* through
    *b* to *a*. The thick lines in 7-17d, the final graph, form a tree structure reflecting
    all the shortest paths originating from node *S* to the remaining nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: The rest of Dijkstra’s algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re usually interested in how efficiently an algorithm performs. This is generally
    specified by a *complexity* value. There are a number of ways this can be done,
    but a popular formulation is called *Big O notation* (the O stands for “order
    of"). This notation aims to give a gross approximation of how efficiently an algorithm
    performs (in terms of running time or memory usage) based on the size of its inputs.
    Dijkstra’s algorithm has a running time complexity of *O*(*N*²), where *N* is
    the number of nodes in the graph. This means the running time increases as the
    square of the number of inputs. In other words, if we double the number of nodes,
    the algorithm will take about four times as long to run. This is taken to be an
    upper-bound or worst-case scenario, and depending on the nature of the graph,
    the runtime could be less.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Priority Queue***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we’ve seen in the analysis above, a priority queue plays a key role in Dijkstra’s
    algorithm. Priority queues can be implemented in a number of ways, but one popular
    approach is to use something called a binary heap. A *binary heap* is a binary
    tree structure (meaning each node has a maximum of two children) where each node’s
    value is greater than or equal to its child nodes. This type of heap is called
    a *max-heap*. It’s also possible for each parent node to be less than or equal
    to its child nodes. This type of heap is called a *min-heap*. An example of such
    a heap is shown in [Figure 7-18](ch07.xhtml#ch7fig18). The top or root node is
    always the first to be removed since it’s considered to have the highest priority.
    After nodes are added to or removed from the heap, the remaining nodes are rearranged
    to maintain the proper priority order. While it’s not terribly difficult to build
    a binary heap object, Racket already has one available in the *data/heap* library.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: Min-heap*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our heap entries won’t be just numbers: we’ll need to track the node and its
    current distance value (which determines its priority). So each heap entry will
    consist of a pair where the first element is the node and the second element is
    the current distance. When a Racket heap is constructed, it must be supplied with
    a function that will do the proper comparison when given two node entries. We
    accomplish this with the following code. The `comp` function only compares the
    second element of each pair since that’s what determines the priority.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To save a bit of typing, we create a few simple helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `update-priority` procedure takes a symbol and a new priority to update
    the queue. It does this by removing (dequeuing) the old value and adding (enqueuing)
    a new value. The `heap-remove!` function performs very efficiently, but it needs
    the exact value (pair with symbol and priority) to work. Unfortunately, without
    knowing the priority, we have to resort to a linear search through the entire
    queue to find the symbol via the `in-heap` sequence. This can be optimized by
    storing (in another data structure like a hash table) the symbol and current priority.
    We leave it to the reader to perform this added step if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples of the priority queue in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of the order the values were added to the queue, they’re stored and
    removed in priority order.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Implementation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define our graph as a list of edges. Each edge in the list consists of the
    end nodes along with the distance between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we progress through the algorithm, we want to to keep track of the current
    parent of each node so that when the algorithm completes, we’ll be able to reproduce
    the shortest path to each node. A hash table will be used to maintain this information.
    The key is a node name and the value is the name of the parent node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We need to take care in our coding to be mindful of the fact that our graph
    is bi-directional, and an edge defined by (*a*, *b*) is equivalent to one defined
    by (*b*, *a*). We’ll account for this by supplementing the original edge list
    with a list consisting of the nodes reversed. We’ll also use a hash table (`lengths`)
    to maintain the lengths of each edge and an additional hash table (`dist`) to
    record the shortest distance to each node as it’s discovered. To pull all this
    together, we define `init-graph`, which takes an edge list and returns the original
    list appended with the swapped node list. It will also be used to initialize the
    priority queue and the various hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the code, `dijkstra`, that actually computes the shortest paths for each
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dijkstra` code takes the starting node symbol and edge list as arguments.
    It then defines `graph`, which is the original list of edges appended with a list
    of the edges with the nodes swapped. As mentioned, the `init-graph` procedure
    also initializes all the other data structures required for the algorithm to work.
    A local `neighbors` function is defined ➊ that takes a node and returns the list
    of nodes that are adjacent to the node and still in the queue. The main loop starts
    ➋ and the first step is to pop the first node in the queue and assign its symbol
    to `u`. Next, each of its neighbors (`v`) is processed ➌. For each neighbor, we
    compute *t* = *d*(*u*) + *l*(*u*, *v*) ➍ (recall that *d*(*u*) is the most current
    distance estimate from the start symbol to *u*, and *l*(*u*, *v*) is the length
    of the edge from *u* to *v*). We then test whether *t* < *d*(*v*) ➎, and if it
    passes the test, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign *d*(*v*) = *t* ➏.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign *u* as the parent of *v* ➐.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the queue with *t* as the new priority of *v* ➑.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we test whether any values remain on the heap, and if so, repeat the
    process ➒. Once the algorithm completes, `parent` will contain the parent of each
    node. All that remains is to chase the chain of parents to the start symbol to
    determine the shortest path to the node. This is done by the following `get-path`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `show-paths` procedure will print out paths for all the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For convenience we define `solve`, which takes a starting symbol and edge list,
    calls `dijkstra` to compute the shortest paths, and prints out the shortest path
    to each node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Given our original graph where we defined the edges in `edge-list` above, and
    starting symbol `S`, we generate the solutions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try this slightly more ambitious example in [Figure 7-19](ch07.xhtml#ch7fig19)
    (see [**4**]).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: Another graph to test Dijkstra’s algorithm on*'
  prefs: []
  type: TYPE_NORMAL
- en: The edge list for this graph is . . .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, solving for the shortest path, we have . . .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’ve highlighted the tree of shortest paths in the resulting graph (see [Figure
    7-20](ch07.xhtml#ch7fig20)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-20: Shortest paths found*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve thoroughly examined Dijkstra’s shortest-path algorithm, we’ll
    next take a look at the A* algorithm via Sam Loyd’s (in)famous 14–15 puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: The 15 Puzzle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 15 puzzle consists of 15 sequentially numbered sliding tiles in a square
    frame that are randomly scrambled, with the goal of getting them back into their
    proper numerical sequence. In the late 1800’s Sam Loyd created a bit of buzz over
    this puzzle by offering a $1,000 prize for anyone who could demonstrate a way
    to start with a puzzle with all the tiles in order, except with the 14 and 15
    tiles reversed (as shown in [Figure 7-21](ch07.xhtml#ch7fig21), Loyd called this
    arrangement the “14-15 Puzzle”), and get them back in their proper order (without
    removing the tiles from the case, of course). As we’ll see shortly, this is mathematically
    impossible, so Loyd knew his money was safe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-21: Sam Loyd’s 14–15 puzzle illustration*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Swapping Just Two Tiles Is Impossible**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To get an idea of why Loyd’s money was safe (that is, why it’s not possible
    to exchange two and only two tiles), consider the puzzle in its solved state as
    shown in [Figure 7-22](ch07.xhtml#ch7fig22).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-22: Solved 15 puzzle*'
  prefs: []
  type: TYPE_NORMAL
- en: Any sequence of moves that would reverse the 14 and 15 tiles would produce the
    arrangement in Loyd’s puzzle. Simply reproducing this sequence would get the tiles
    back in order. We’ll see that this is impossible. Now consider the arrangement
    in [Figure 7-23](ch07.xhtml#ch7fig23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-23: 15 puzzle with inversions*'
  prefs: []
  type: TYPE_NORMAL
- en: If we arrange these tiles linearly, we have 2, 3, 1, 4, 5, 6, . . . In particular,
    the values of tile-2 and tile-3 are larger than tile-1, which follows them. Each
    such situation, where the value of a tile is larger than one that follows it,
    is called an *inversion* (two inversions in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Related to the idea of inversion is that of *transposition*. A transposition
    is simply the exchange of two values in a sequence. A given arrangement can be
    arrived at by any number of transpositions. For example, one way to get to the
    sequence 2, 3, 1, 4, 5, 6, . . . would be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting arrangement: 1, 2, 3, 4, 5, 6, . . .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Transpose 1 and 3: 3, 2, 1, 4, 5, 6, . . .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Transpose 2 and 3: 2, 3, 1, 4, 5, 6, . . .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key idea is that an arrangement consisting of an even number of inversions
    will always be generated by an even number of transpositions, and an arrangement
    with an odd number of inversions will always be generated by an odd number of
    transpositions. For reference purposes, the empty slot will be treated as a tile
    and designated with the number 16\. Any single movement by tile-16 is a transposition.
    If tile-16 leaves from the lower right corner and arrives at a particular spot
    using an odd number of transpositions, it will require an odd number of transpositions
    to get back to the starting location, or a net even number of transpositions.
    This leaves the puzzle with an even number of inversions.
  prefs: []
  type: TYPE_NORMAL
- en: The arrangement Sam Loyd proposes is impossible to solve since it involves a
    single odd inversion. It’s also true, but trickier to prove, that any puzzle with
    an even number of inversions is solvable.
  prefs: []
  type: TYPE_NORMAL
- en: Having resolved this historical issue with Sam Loyd’s puzzle, we now turn our
    attention to finding solutions for puzzles that are in fact solvable. In this
    regard we’ll now explore the A* search algorithm (we mostly abbreviate this to
    simply the “A* algorithm” hereafter).
  prefs: []
  type: TYPE_NORMAL
- en: '***The A* Search Algorithm***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll of course assume that the computer is presented with a solvable puzzle
    (that is, it has an even number of inversions). The computer should provide a
    solution that’s as efficient as possible—that is, a solution that requires the
    smallest number of moves to get to the goal state. One method that generally provides
    good results is called the *A* search* algorithm. An advantage of the A* algorithm
    over a simple breadth-first or depth-first search is that it uses a *heuristic*^([1](footnote.xhtml#ch07foot_1))
    to reduce the search space. It does this by computing an *estimated* cost of taking
    any given branch in the search tree. It iteratively improves this estimate until
    it determines the best solution or it determines no solution can be found. Estimates
    are stored in a priority queue where the least cost state is at the head of the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin our analysis by looking at a smaller variant of the 15 puzzle, called
    the 8 puzzle. The 8 puzzle in its solved state is shown in [Figure 7-24](ch07.xhtml#ch7fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-24: Solved 8 puzzle*'
  prefs: []
  type: TYPE_NORMAL
- en: The search tree of the 8 puzzle can be modeled as shown in [Figure 7-25](ch07.xhtml#ch7fig25),
    where each node of the tree is a state of the puzzle, and the child nodes are
    the possible states that can arise from a valid move.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-25: Partial 8 puzzle game tree*'
  prefs: []
  type: TYPE_NORMAL
- en: 'At each iteration of the A* algorithm, it computes an estimate of the cost
    (that is, the number of moves) to get to the goal state. Formally, it attempts
    to minimize the following estimated cost function, where *n* is the node under
    consideration, *g*(*n*) is the cost of the path from the start node to *n*, and
    *h*(*n*) is a heuristic that estimates the cost of the cheapest path from *n*
    to the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f(n)* = *g(n)* + *h(n)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing a good heuristic function is something of an art. To get the best
    performance from the A* algorithm, an important characteristic of the heuristic
    is that it satisfies the following condition for every edge in the graph, where
    *h*^*(*n*) is the actual (but unknown) cost to reach the goal state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a heuristic meets this condition, it’s said to be *admissible*, and the A*
    algorithm is guaranteed to find the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: One possible heuristic for the 8 puzzle uses something called the *Manhattan
    distance* (as opposed to the familiar straight-line distance). For example, to
    get the tile-2 in [Figure 7-25](ch07.xhtml#ch7fig25) to its home location (the
    cell it would occupy in the solved state), the tile would have to move up two
    squares and one square to the left for a total of three moves—this is the Manhattan
    distance. The heuristic value for a puzzle state would be the sum of the Manhattan
    distances for each tile. [Table 7-1](ch07.xhtml#ch7tab1) shows the computation
    of this value for the root node of [Figure 7-25](ch07.xhtml#ch7fig25).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1**: Computing Manhattan Distance'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tile** | **Rows** | **Cols.** | **Total** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1 | 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 2 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Distance: | 15 |'
  prefs: []
  type: TYPE_TB
- en: The Manhattan distance will always be less than or equal to the actual number
    of moves, so it satisfies the admissibility condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly weaker heuristic is the *Hamming distance*, which is just the number
    of misplaced tiles. The Hamming distance for the puzzle shown in [Figure 7-25](ch07.xhtml#ch7fig25)
    is eight: none of the tiles are in their home location.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-26](ch07.xhtml#ch7fig26) we’ve annotated each node with three values.
    The first value is the depth of the game tree (this value is incremented by one
    for each level and constitutes the value of *g*(*n*) in the cost formula), the
    second value is the heuristic value, *h*(*n*), for the node (the Manhattan distance
    in this case), and the third value is the sum of the two giving the overall cost
    score for the node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-26: 8 puzzle with node costs*'
  prefs: []
  type: TYPE_NORMAL
- en: The A* algorithm uses a priority queue called *open*. This queue orders the
    puzzle states that have been examined but whose child nodes have not been expanded,
    according to the estimated cost to reach the goal. The algorithm also relies on
    a dictionary, called *closed*, that uses the puzzle state as a key and maintains
    the most recent cost value for the node. [Figure 7-27](ch07.xhtml#ch7fig27) reflects
    the current state of the analysis, where the first node in the open queue is the
    root node of [Figure 7-26](ch07.xhtml#ch7fig26).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-27: Closed and open*'
  prefs: []
  type: TYPE_NORMAL
- en: The values shown at the top of the closed nodes are the latest estimated costs.
    The values at the top of the open nodes are the same three cost values described
    above. With this introduction we walk through an iteration of how the A* algorithm
    processes the game tree.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to pop the lowest-priority value off the open queue. This
    node is then added to the closed dictionary. The next step is to compute the costs
    for the child nodes, which are shown on the second level of [Figure 7-26](ch07.xhtml#ch7fig26).
    If any of these nodes are not on the closed list, they are simply queued to open
    with no further analysis. Notice that the first child node *is* on the closed
    list. Since its current estimated cost is less than the cost on the closed list,
    it’s removed from the closed list and the node is added back to the queue with
    its new value. In the situation where a child node is on the closed list, but
    its estimated value is *larger* than the value on the closed list, no change is
    made, and it’s not added to the queue. Once this phase is complete, the open and
    closed structures will appear as shown in [Figure 7-28](ch07.xhtml#ch7fig28).
  prefs: []
  type: TYPE_NORMAL
- en: Since the first child node in [Figure 7-26](ch07.xhtml#ch7fig26) has a lower
    cost than the other nodes in the open queue, it moves to the head of the queue
    and becomes the next item to be popped off. Notice that its first child is already
    in the closed list, but its newly computed cost is higher than the cost in the
    closed list, so it’s ignored. The remaining child node would be processed as before.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-28: Closed and open, updated*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process continues until one of two things happens: either a node is popped
    off the open queue that’s in the solved state, in which case the algorithm completes
    and prints the answer (details on how this is accomplished are described in the
    next section), or the open queue becomes empty, which indicates that the puzzle
    was not solvable.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The 8-Puzzle in Racket***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll begin by implementing a solution to the smaller 3-by-3 version of the
    puzzle before we move on the full 4-by-4 version.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Dijkstra’s algorithm, we’ll use Racket’s heap object for the open priority
    queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A `SIZE` constant will specify the number of rows and columns in the puzzle.
    In addition we’ll define a number of utility functions to work with the puzzle
    structure. For efficiency, the puzzle state will be stored internally as a Racket
    vector of size `SIZE*SIZE+2`. The last two elements of the vector will contain
    the row and column of the empty cell. The empty cell will have the numerical value
    specified by `(define empty (sqr SIZE))`. To this end, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ref` function will take a puzzle along with and a row and column number
    as arguments. It returns the tile number at that location. The `empty-loc` function
    will return two values that give the row and column respectively of the empty
    cell.
  prefs: []
  type: TYPE_NORMAL
- en: The following functions are used to compute the Manhattan distance. The first
    creates a hash table used to look up the home location of a tile given the tile
    number. The second function computes the sum of the Manhattan distances for each
    tile in the puzzle. This will be used in the computation of the cost of a puzzle
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next functions are used to generate a new puzzle state given a move specifier.
    A move specifier is a number from zero to three that determines which of the four
    directions a tile can be moved into the empty space from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `move-offset` function takes a move specifier and returns two values specifying
    the row and column deltas needed to make the move. The `make-move` function takes
    a move specifier and returns a new vector representing the puzzle after the move
    has been made.
  prefs: []
  type: TYPE_NORMAL
- en: The following function will take a puzzle and return a list consisting of all
    the valid puzzle states that can be reached from a particular puzzle state. The
    local `legal` function determines whether a move specifier will result in a valid
    move for the current puzzle state by checking whether a move in a certain direction
    will extend beyond the boundaries of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It will of course be useful to actually see a visual representation of the puzzle.
    That functionality is provided by the following routine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next we define a helper function to process closed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We begin by placing the node, its parent, and its estimated cost in the `closed`
    table ➊. Next, we generate a list of the possible child puzzle states and loop
    through them. For each child node, we generate the new node depth ➋ and estimated
    score ➌. Then we compile the information that we’d need to push that node to the
    open queue ➍, which happens automatically ➐ if the node is not in the `closed`
    table. If the node is in the `closed` table, we extract its prior cost score ➎
    and compare with its current score ➏. If the current score is less than the prior
    score, we remove the node from the `closed` table and place it in the open queue.
  prefs: []
  type: TYPE_NORMAL
- en: We finally get to the algorithm proper.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First we define the `closed` hash table described above. The open queue is initialized
    ➊, and the scrambled puzzle provided to the `a-star` procedure is pushed onto
    the open queue ➋. The items in the queue consist of a Racket pair. The `cdr` of
    the pair is the estimated score, and the `car` consists of the puzzle state, the
    depth of the tree, and the parent puzzle state. After this initialization, the
    main loop starts ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The loop repeats until the `solved` variable is set to true. The first step
    of the loop is to pop the highest-priority item (lowest cost score) from the open
    queue and assign it to the `node-info` variable. A `match` form is used to parse
    the values contained in `node-info` ➎. The puzzle state (in `node`) is first tested
    to see if it’s in the solved state ➏, and if so, the function prints out the move
    sequence and terminates the process. Otherwise, the processing continues where
    we process the closed node by placing the node, its parent, and estimated cost
    in the `closed` table ➐.
  prefs: []
  type: TYPE_NORMAL
- en: Once each iteration completes, the queue is checked ➑ to see if it contains
    any nodes that needs processing. If it does, then the next iteration resumes ➍;
    otherwise, no solution exists and the process terminates ➒.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the print functions that show the solution. The `solution-list` procedure
    chases the parent nodes in `closed` to create a list of the puzzle states all
    the way back to the starting puzzle; `print-solution` takes the solution list
    and prints out the puzzle states it contains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a test run on the puzzle presented in [Figure 7-25](ch07.xhtml#ch7fig25)
    (to save space, the output puzzles are displayed horizontally).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '***Moving Up to the 15 Puzzle***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Having laid the groundwork with the 8 puzzle, the 15 puzzle requires this tricky
    modification: change the value of `SIZE` from 3 to 4\. Okay, maybe that’s not
    too tricky, but before you get too excited, it’s really not quite that simple
    either. Observe [Figure 7-29](ch07.xhtml#ch7fig29). The first two puzzles are
    from [9], and our test computer sailed through solving these. But the third puzzle
    was randomly generated and caused the test computer to fall to the floor, giggling
    to itself that we would attempt to have it solve such a problem—no solution was
    forthcoming.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-29: Some 15 puzzle examples*'
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that some puzzles may result in the A* algorithm having to explore
    too many paths, so the computer runs out of resources (or the user runs out of
    patience waiting for an answer). Our solution is to settle for a slightly less
    elegant approach by breaking the problem into three subproblems. We will trade
    off a fully optimized solution for a solution that we don’t have to wait forever
    to get.
  prefs: []
  type: TYPE_NORMAL
- en: To break the problem into subproblems, we’re going to divide the puzzle into
    three zones as shown below in [Figure 7-30](ch07.xhtml#ch7fig30). The zones are
    chosen to take advantage of the fact that the A* algorithm was pretty zippy with
    the 8 puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-30: 15 puzzle divided into zones*'
  prefs: []
  type: TYPE_NORMAL
- en: The medium gray section, which we designate zone 1, represents one subproblem,
    the white section (zone 2) will be the second subproblem, and the dark gray section
    (zone 3) represents another subproblem (which is equivalent to the 8 puzzle, which
    we know can be solved quickly). The idea is to provide different scoring functions
    to the `a-star` algorithm depending on which zone is being addressed. These functions
    will still use the Manhattan distance, but with certain restrictions applied.
    Once zone 1 and zone 2 have been solved, we can just call `manhattan` as before
    since the edge tiles in zones 1 and 2 will already be in place and the remaining
    tiles would be equivalent to an 8 puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone 1**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Before we dive into solving zone 1, we’re going to create a helper function
    that’s quite similar to the code we saw in the `manhattan` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference is that instead of embedding the test for the empty square
    directly in the `cost` function, we’ll pass in a function for the `guard` parameter
    that will do the test for us. Given this, we can redefine `manhattan` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll attack zone 1 in two phases: first we nudge tiles 1 through 4 into the
    first two rows of the puzzle; then we get them into the proper order in the first
    row.'
  prefs: []
  type: TYPE_NORMAL
- en: To get tiles 1 through 4 into the first two rows, we define `zone1a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we only update the distance for tiles 1 through 4, and we only
    update the distance if these tiles are not already in the first two rows.
  prefs: []
  type: TYPE_NORMAL
- en: The second phase is just slightly different. This time we always update the
    distance for tiles 1 through 4 to ensure they land in the proper locations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It might appear that this could have been done in a single function, but trying
    to position the tiles all at once would result in a large search space and the
    consequent increase needed in time and computer resources (like memory). Our first
    phase, where we just get the tiles into the proximity of their proper location,
    reduces the search space by half, without requiring an enormous amount of resources.
    The sorting in phase two will normally only have to deal with the tiles in the
    top half of the puzzles since the remaining tiles will have a score of zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone 2**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, we’ve reduced the search space by 25 percent. This modest reduction
    is sufficient to allow us to get tiles 5, 9, and 13 into zone 2 and in their proper
    order in a single procedure, which we provide here as `zone2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we no longer need to bother with row 1, as reflected in the code
    `>= r 1`. Aside from this, the code is nearly identical to the others, except
    that this time, we use the values defined in `zone2-tiles` for scoring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Putting It All Together**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once a zone has been solved, we won’t want to disturb the tiles that are already
    in place. To accomplish this, a slight tweak is made to the function (`next-states`)
    that generates the list of permissible states. Before, we simply checked to ensure
    we weren’t moving beyond the first row or column. Now we define global variables
    `min-r` and `min-c`, which are set to 0 or 1 depending on which zone we’re currently
    working in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The final solver will update the values of `min-r` and `min-c` once zones 1
    and 2 have been populated.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to make a few crucial modifications to the code for `a-star` and
    `process-closed`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The most significant change is that instead of always using `manhattan` for
    our scoring estimate, we now use the function `fscore` ➊, which is passed to `process-closed`
    as an additional parameter. This function will be different depending on which
    zone of the puzzle is being solved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we also include `fscore` as an additional parameter. Now, instead of immediately
    printing a solution once the goal state is reached, we return two values at the
    end ➌: the current goal, given in the first `set!` ➊ and the solution list, given
    in the second `set!` ➋. The remaining code should align closely with the original
    version.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of calling `a-star` directly as we did before, we now provide a `solve`
    function that steps through the process of providing `a-star` with the proper
    scoring function, which is either one of the zone-specific functions or `manhattan`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As the code executes, it stores the solution list for each step of the process
    and finally prints the entire solution in the last line of the code. The reason
    we take the `cdr` of the solution list at each step (except the first) is because
    the last item in the solution from the previous step is the goal of the next step;
    this state would be repeated if we left it in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we resolve a little cosmetic issue with the `print` routine caused
    by having two-digit numbers on the tiles. The revised code follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The following are some sample inputs with which to test the code. To save space,
    only the output (compressed) from the first example is shown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that depending on the puzzle and the power of your computer, it may
    take anywhere from a couple of seconds to a minute or so to generate a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Sudoku
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sudoku^([2](footnote.xhtml#ch07foot_2)) is a popular puzzle consisting of a
    9-by-9 grid of squares in which some squares are initially populated with digits
    from 1 through 9, as shown in [Figure 7-31](ch07.xhtml#ch7fig31)a. The objective
    is to fill in the blank squares such that each row, column, and 3-by-3 block of
    squares also consists of digits 1 through 9, as shown in [Figure 7-31](ch07.xhtml#ch7fig31)b.
    A well-formed Sudoku puzzle should only have one possible solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-31: The Sudoku puzzle*'
  prefs: []
  type: TYPE_NORMAL
- en: Our aim in this section is to produce a procedure that generates the solution
    to any given Sudoku puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic strategy is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Check each empty cell, to determine which numbers are available to be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a cell with the fewest available numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One at a time, enter one of the available numbers in the cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each available number, repeat the process until either the puzzle is solved,
    or there are no numbers available for an empty cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no available numbers, backtrack to step 3 and try a different number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process is another application of depth-first search.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-32](ch07.xhtml#ch7fig32) gives the coordinates used to reference
    locations in the puzzle: numbers across the top index columns, numbers on the
    left edge index rows, and numbers in the interior index blocks of 3-by-3 subgrids.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-32: Puzzle coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the available numbers for a given cell, we take the set intersection
    of the unused numbers in each row, column, and block. Using the cell in row 1,
    column 1 of [Figure 7-31](ch07.xhtml#ch7fig31)a as an example, in row 1 the set
    of numbers {2, 5, 8} are free, in column 1 all the numbers except for 5 are available,
    and in block 0, the set of numbers {2, 3, 7, 8, 9} are available. The intersection
    of these sets gives the set of possible values for this cell: {2, 8}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation will use a 9-by-9 array of numbers to represent the puzzle,
    where the number 0 will designate an empty square. The array will be constructed
    of a nine-element vector, each element being another nine-element integer vector.
    For easy access to elements of the array, we define two utility functions to set
    and retrieve values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Both of these functions require the array and row and column numbers to be provided
    as the initial arguments.
  prefs: []
  type: TYPE_NORMAL
- en: It will also be useful to derive the corresponding block index from the row
    and column numbers, as given by the `getBlk` function here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The puzzle will be input as a single string where each row of nine digits is
    broken by a new line as shown by the example below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We define the Sudoku puzzle object as a `sudoku%` Racket object for which we
    give a partial implementation here. This object will maintain the puzzle state.
    It will contain functions that allow us to manipulate the state by setting cell
    values and provides functions to list potential candidates (unused numbers in
    a row, column, or block) and other helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `init` form ➊ captures the input string value that defines the puzzle. We
    initialize the puzzle ➎ by calling `init-puzzle` ➐, which updates `grid` ➌ with
    the appropriate numerical values via the call to `init-grid` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: The `count` variable ➋ contains the number of cells that currently have a value.
    Once `count` reaches 81, the puzzle has been solved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `avail-row`, `avail-col`, and `avail-blk` variables are used to keep track
    of which numbers are currently unused in each row, column, and block respectively.
    The `make-markers` function, which is called to initialize each of these variables,
    creates a Boolean array that indicates which numbers are free for any given index
    (row, column, or block as applicable); `make-markers` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the number 0 (designating an empty cell) is automatically marked
    as unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: As numbers get added to the puzzle, `item-set!` is called ➍. This procedure
    is responsible for updating `grid` and `avail-row`, `avail-col`, and `avail-blk`
    when given the row, column, and number to be assigned to the puzzle. The functions
    `get-grid` and `item-ref` return `grid` or a cell in `grid` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code extracts, all function definitions that are indented should
    be included in the class definition for `sudoku%` and aren’t global defines.
  prefs: []
  type: TYPE_NORMAL
- en: The following `avail` function combines the values from `avail-row`, `avail-col`,
    and `avail-blk` to produce a vector indicating which numbers are available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this vector, we create a list of the free numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For efficiency, the following code finds all the cells that only have a single
    available number and updates the puzzle appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Performing this process once may result in other cells with only a single available
    number. The following code runs until no cells remain with only a single available
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: For puzzles that can be solved directly by logic alone (no guessing is required),
    the above process would be sufficient, but this isn’t always the case. To support
    backtracking, the following two functions are provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first function (`get-free`) goes cell by cell and creates a list of all
    the free values for each cell. Each element of the list contains another list
    that holds the row, column, number of free values, and a list of the free values.
    The second function (`get-min-free`) takes the list returned by `get-free` and
    returns the values for the cell with the fewest free numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few handy utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `print` member function provides a simple text printout of the puzzle. The
    `solved?` function indicates whether the puzzle is in the solved state by testing
    whether all 81 cells have been populated. The `clone` function provides a copy
    of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the code that’s defined within the body of the `sudoku%` class
    definition and brings us to the actual code used to solve the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating a copy of the puzzle to work with ➊. Next, we define a
    depth-first search procedure, `dfs` ➋, which we’ll explain shortly. The call to
    `set-all-singles` ➑ is occasionally sufficient to solve the puzzle, but the puzzle
    is handed off to `dfs` to ensure a complete solution is found. The remaining lines
    will return a solved puzzle if one exists; otherwise an error is signaled.
  prefs: []
  type: TYPE_NORMAL
- en: The depth-first search code, `dfs` ➋, immediately tests whether the puzzle is
    solved and if so, returns the solved puzzle. Otherwise, the cell with the fewest
    available numbers (if any) is explored ➌, where the `match` form extracts the
    cell row, column, number of free numbers, and the list of free numbers. The list
    of free numbers is iterated through starting on the next line. While the list
    isn’t empty, the first number in the list is extracted into `n` ➍ and the remaining
    numbers are stored in `t` ➎. Then a copy of the puzzle is created. Next, the puzzle
    copy is populated with the current available number ➏, and `set-all-singles` is
    called immediately following this. If this number doesn’t produce a solution (via
    the recursive call to `dfs` ➐), the loop repeats with the original puzzle and
    the next available number.
  prefs: []
  type: TYPE_NORMAL
- en: To aid testing various puzzles, we define a simple routine to take an input
    puzzle string, solve the puzzle, and print the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve laid this groundwork, here’s a trial run with our example puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: While this is certainly an adequate method to generate the output, it doesn’t
    take a lot of additional work to produce a more attractive output.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish our goal, we’ll need the Racket *draw* library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we’ll borrow our `draw-centered-text` procedure that we used in
    the 15 puzzle GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Given these preliminaries, we can now define our `draw-puzzle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There’s really nothing new here. The reason we’re passing it two puzzles is
    because the first puzzle is the original unsolved puzzle. It’s simply used to
    determine which color to use to draw the squares. If a square was blank in the
    original puzzle, it’ll be colored yellow in the output; otherwise it’ll be colored
    gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in hand, we can redefine `solve` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this new version yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the starting state in [Figure 7-33](ch07.xhtml#ch7fig33):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-33: Sudoku starting-state drawing*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the solved state in [Figure 7-34](ch07.xhtml#ch7fig34):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-34: Solved Sudoku drawing*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored a number of algorithms that are useful in the
    general context of problem-solving. In particular we’ve looked at breath-first
    search (BFS), depth-first search (DFS), the A* algorithm, and Dijkstra’s algorithm
    (and discovered priority queues along the way) to find the shortest path between
    graph nodes. We employed DFS in the solution of the *n*-queens problem and the
    15 puzzle (which also used the A* algorithm). Finally, we took a look at Sudoku,
    where sometimes logic alone is sufficient to solve, but failing this, DFS again
    comes to the rescue. While the algorithms we’ve explored are far from a comprehensive
    set, they form a useful toolset that’s effective in solving a wide range of problems
    over many domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far we’ve exercised a number of programming paradigms: imperative, functional,
    and object-oriented. In the next chapter, we’ll look at a new technique: programming
    in logic or logic programming.'
  prefs: []
  type: TYPE_NORMAL
