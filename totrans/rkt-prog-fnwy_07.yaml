- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: SEARCHING FOR ANSWERS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找答案
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/common01.jpg)'
- en: For all the problems we have encountered so far, there was a direct method to
    compute the solution. But this is not always the case. For many problems, we have
    to search for the solution using some type of algorithm, such as when solving
    a Sudoku puzzle or the *n*-queens problem. In these cases, the process involves
    trying a series of steps until either we find the solution or we have to back
    up to a previous step to try an alternative route. In this chapter we’ll explore
    a number of algorithms that allow us to efficiently select a path that leads to
    a solution. Such an approach is known as a *heuristic*. In general, a heuristic
    isn’t guaranteed to find a solution, but the algorithms we explore here (thankfully)
    are.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们到目前为止遇到的所有问题，都有一种直接的方法来计算解决方案。但情况并不总是如此。对于许多问题，我们必须使用某种算法来搜索解决方案，例如在解决数独谜题或*n*皇后问题时。在这些情况下，过程涉及尝试一系列步骤，直到我们找到解决方案，或者必须回退到上一步尝试另一条路径。本章中，我们将探索一些算法，帮助我们高效选择一条通向解决方案的路径。这种方法被称为*启发式*。通常，启发式算法不能保证找到解决方案，但我们在这里探索的算法（幸运的是）是可以的。
- en: Graph Theory
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图论
- en: It’s often the case that a problem we’re trying to solve can be modeled with
    a *graph*. Intuitively, a graph is just a set of points (or nodes) and connecting
    lines, as illustrated in [Figure 7-1](ch07.xhtml#ch7fig1). Each node represents
    some state of the problem-solving process, and the lines extending from one node
    to other nodes represent possible alternative steps. We’ll first give some basic
    graph definitions as background before delving into the actual problem-solving
    algorithms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图解决的问题往往可以用*图*来建模。直观地说，图只是一些点（或节点）和连接这些点的线条，如[图 7-1](ch07.xhtml#ch7fig1)所示。每个节点表示问题解决过程中的某个状态，从一个节点延伸到其他节点的线条表示可能的替代步骤。在深入实际问题解决算法之前，我们首先介绍一些基本的图的定义作为背景。
- en: '***The Basics***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Formally, a graph is a finite set *V* of *vertices* (or nodes) and a set *E*
    of *edges* joining different pairs of distinct vertices (see [Figure 7-1](ch07.xhtml#ch7fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从正式定义来看，图是一个有限集合 *V* 的*顶点*（或节点），以及一个集合 *E* 的*边*，连接不同的顶点对（见[图 7-1](ch07.xhtml#ch7fig1)）。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/07fig01.jpg)'
- en: '*Figure 7-1: Graph*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1: 图*'
- en: In [Figure 7-1](ch07.xhtml#ch7fig1) above, *V* = {*a, b, c, d, e*} are the vertices
    and *E* = {(*a*, *b*), (*a*, *c*), (*b*, *c*), (*c*, *d*), (*b*, *e*), (*e*, *d*)}
    are the edges.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的[图 7-1](ch07.xhtml#ch7fig1)中，*V* = {*a, b, c, d, e*} 是顶点，*E* = {(*a*, *b*),
    (*a*, *c*), (*b*, *c*), (*c*, *d*), (*b*, *e*), (*e*, *d*)} 是边。
- en: A sequence of graph vertices (*v*[1], *v*[2], …, *v*[*n*]), such that there’s
    an edge connecting *v*[*i*] and *v*[*i*+1], is called a *walk*. If all the vertices
    are distinct, a walk is called a *path*. A walk where all the vertices are distinct
    except that *v*[1] = *v*[*n*] is called a *cycle* or *circuit*. In [Figure 7-1](ch07.xhtml#ch7fig1),
    the sequence (*a*, *b*, *c*, *b*) is a walk, the sequence (*a*, *b*, *c*, *d*)
    is a path, and the sequence (*a*, *b*, *c*, *a*) is a cycle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列图的顶点（*v*[1], *v*[2], …, *v*[*n*]），使得存在一条边连接 *v*[*i*] 和 *v*[*i*+1]，称为*路径*。如果所有顶点都不相同，则路径称为*简单路径*。如果路径中所有顶点都不相同，除了
    *v*[1] = *v*[*n*] 外，则称为*循环*或*回路*。在[图 7-1](ch07.xhtml#ch7fig1)中，序列（*a*, *b*, *c*,
    *b*）是一个路径，序列（*a*, *b*, *c*, *d*）是一个简单路径，序列（*a*, *b*, *c*, *a*）是一个循环。
- en: A graph with a path from each vertex to every other vertex is said to be *connected*.
    A connected graph without any cycles is called a *tree*. In a tree, any path is
    assumed to flow from upper nodes to lower nodes. Such a structure (where there
    are no cycles and there is only one way to get from one node to another) is known
    as a *directed acyclic graph (DAG)*. It’s possible to convert the graph above
    to a tree by removing some of its edges, as shown in [Figure 7-2](ch07.xhtml#ch7fig2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图，如果从每个顶点到其他所有顶点都有路径，则称为*连通图*。一个没有循环的连通图称为*树*。在树中，任何路径都假定从上层节点流向下层节点。这样的结构（没有循环，并且从一个节点到另一个节点只有一条路径）称为*有向无环图（DAG）*。通过移除一些边，可以将上面的图转换为树，如[图
    7-2](ch07.xhtml#ch7fig2)所示。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/07fig02.jpg)'
- en: '*Figure 7-2: Tree*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: 树*'
- en: If nodes *x* and *y* are connected in such a way that it’s possible to go from
    *x* to *y*, then *y* is said to be a *child node* of *x*. Nodes without child
    nodes (such as *a*, *c*, and *d*) are known as *terminal* (or *leaf*) nodes. Problems
    that have solutions modeled by a tree structure lend themselves to simpler search
    strategies since a tree doesn’t have circuits. Searching a graph with circuits
    requires keeping track of nodes already visited so that the same nodes aren’t
    re-explored.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to label each edge of the graph with a numerical value called
    a *weight*, as shown in [Figure 7-3](ch07.xhtml#ch7fig3). This type of graph is
    called a *weighted graph*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Weighted graph*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: If *e* is an edge, the weight of the edge is designated by *w*(*e*). Weights
    can be used to represent any number of measurements such as time, cost, or distance,
    which may affect the choice of edge when searching a graph.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of interesting questions arise when exploring the properties of graphs.
    One such question is this: “Given any two nodes, what’s the shortest path between
    them?” Another is the famous traveling salesman problem: “Given a list of cities
    and the distances between them, what’s the shortest possible route that visits
    each city exactly once and returns to the original city?” This last question,
    where each node is visited exactly once and returns to the original node, involves
    what is called a *Hamiltonian circuit*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '***Graph Search***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two broad categories of strategies for searching graphs: *breadth-first
    search (BFS)* and *depth-first search (DFS)*. To illustrate these concepts, we’ll
    use the tree in [Figure 7-2](ch07.xhtml#ch7fig2).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadth-First Search**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Breadth-first search involves searching a graph by fully exploring each level
    (or depth) before moving on to the next level. In the tree diagram (shown in [Figure
    7-2](ch07.xhtml#ch7fig2)), the *e* (root) node is on the first level, nodes *b*
    and *d* are on the next level, and nodes *a* and *c* are on the third level. This
    typically involves using a queue to stage the nodes to be examined. The process
    begins by pushing the root node onto the queue, as shown in [Figure 7-4](ch07.xhtml#ch7fig4):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: A queue containing the root node*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'We then pop the first node in the queue (*e*) and test it to see if it’s a
    goal node; if not, we push its child nodes onto the queue, as shown in [Figure
    7-5](ch07.xhtml#ch7fig5):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: The queue after node e was explored*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Again we pop the first node in the queue (this time *b*) and test it to see
    if it’s a goal node; if not, we push its child nodes onto the queue, as shown
    in [Figure 7-6](ch07.xhtml#ch7fig6):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig06.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The queue after node b was explored*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: We continue in this fashion until a goal node has been found, or the queue is
    empty, in which case there’s no solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Depth-First Search**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Depth-first search works by continuing to walk down a branch of the tree until
    a goal node is found or a terminal node is reached. For example, starting at the
    root node of the tree, nodes *e*, *b*, and *a* would be examined in order. If
    none of those node are goal nodes, we back up to node *b* and examine its next
    child node, *c*. If *c* is also not a goal node, we back all the way up to *e*
    and examine its next child node, *d*. The *n*-queens problem in the next section
    provides a simple example of using depth-first search.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The *N*-Queens Problem
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *n*-queens problem is a classic problem often used to illustrate depth-first
    search. The problem goes like this: position *n* queens on an *n*-by-*n* chess-board
    such that no queen is attacked by any other queen. In case you aren’t familiar
    with chess, a queen can attack any square on the same row, column, or diagonal
    that the queen lies on, as illustrated in [Figure 7-7](ch07.xhtml#ch7fig7).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig07.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: A queen’s possible moves*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The smallest value of *n* for which a solution exists is 4\. The two possible
    solutions are shown in [Figure 7-8](ch07.xhtml#ch7fig8).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig08.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Solutions to the 4-queens problem*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: One reason for the popularity of this problem is that the search graph is a
    tree, meaning that with a depth-first search, there’s no possibility that a state
    previously seen will be reached again (that is, once a queen is placed, it’s not
    possible to get to a state with fewer queens in subsequent steps). This avoids
    the annoying need to keep track of previous states to ensure they aren’t explored
    again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: A simple approach to this problem is to go column by column, testing each square
    in a column and continuing until a solution has been reached (backtracking as
    required). For example, if we begin with [Figure 7-9](ch07.xhtml#ch7fig9), we
    can’t place a queen at b1 or b2, because it would be attacked by the queen at
    a1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig09.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: First queen at a1*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The next available square that’s not attacked is b3, resulting in [Figure 7-10](ch07.xhtml#ch7fig10):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig10.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Second queen at b3*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'But now when we get to column c, we’re stuck since every square in that column
    is attacked by one of the other queens. So we backtrack and move the queen in
    column b to b4 in [Figure 7-11](ch07.xhtml#ch7fig11):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig11.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Second queen at b4*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can place a queen on c2 in [Figure 7-12](ch07.xhtml#ch7fig12):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig12.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Third queen at c2*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Alas, now there’s no spot for a queen on column d. So we backtrack all the way
    to column a and start over in [Figure 7-13](ch07.xhtml#ch7fig13).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig13.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Backtrack to first queen at a2*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The process continues in this manner until a solution is found.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '***A Racket Solution***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define the chessboard as an *n*-by-*n* array constructed from a mutable
    vector with *n* elements, each of which is also an *n*-element vector, where each
    element is either a 1 or a 0 (0 means the square is unoccupied; 1 means the square
    has a queen):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To allow accessing elements of the chessboard `cb` by a row (`r`) and column
    (`c`) number, we define the following accessor forms, where `v` is the value being
    set or retrieved.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we’re using a mutable data structure for the chessboard, we’ll need a
    mechanism to copy the board whenever a solution is found, to preserve the state
    of the board.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ll of course need to be able to see the solutions, so we provide a print
    procedure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The actual code to solve the problem, `dfs`, is a straightforward depth-first
    search. As solutions are found, they’re compiled into a list called `sols`, which
    is the return value of the function. In the code below, recall that in the `let
    loop` form, we’re employing a named `let` (which we described in [Chapter 3](ch03.xhtml))
    where we’re defining a function (`loop`) that we’ll call recursively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code first tests each position to see whether the current cell is being
    attacked by any of the queens that have already been placed on the board ➊ (the
    code for `attacked` will be described shortly); if not, then that cell is marked
    as `valid`, and a queen (the number 1) is placed on that square ➋. Next we test
    whether the current square is in the final column of the board ➌; if it is, we’ve
    found a solution, so a copy of the board is placed in `sols` ➍. If we’re not on
    the last column, we then nest down to the next level (that is, the next column)
    ➎. Finally, the valid square is cleared ➏ so that additional rows in the column
    can be tested ➐. Once all the solutions have been found, they’re returned ➑.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Where the DFS backtracking occurs in this process is a bit subtle. Suppose we’re
    at a position that is under attack by the previously placed queens, so `valid`
    ➊ is false and execution falls through ➐. Now suppose we’re also on the last row.
    In that case, the test fails ➐, so no further looping occurs and the recursive
    call returns. Either there are no following statements, in which case the entire
    loops exits, or there there additional statements to execute after returning from
    the recursive call. This can only occur where the current position is cleared
    and we’re at a previous location ➏. This is the backtrack point. Execution then
    resumes at the last `when` statement ➐.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The following function tests whether a square is under attack by any of the
    previously placed queens. It only checks the columns prior to the current column
    since the other columns of the chessboard haven’t yet been populated.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To output the solutions, we define a simple routine to iterate through and print
    each solution returned by `dfs`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here are a couple of test runs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dijkstra’s Shortest Path Algorithm
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given a graph with a node designated as the start node, Edsger Dijkstra’s algorithm
    finds the shortest path to any other node. The algorithm works by first assigning
    all the nodes (except the start node, which has distance zero) an infinite distance.
    As the algorithm progresses, the node distances are refined until their true distance
    can be determined.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the weighted graph introduced in [Figure 7-3](ch07.xhtml#ch7fig3)
    earlier to illustrate Dijkstra’s algorithm (where *S* is the starting node). The
    algorithm we describe will employ something called a priority queue. A *priority
    queue* is similar to a regular queue, but in a priority queue, each item has an
    associated value, called its priority, that controls its order in the queue. Instead
    of following a first-in, first-out sequence, items with a higher priority are
    ordered ahead of other items. Since we’re interested in finding the shortest path,
    shorter distances will be given a higher priority than longer ones.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram in [Figure 7-14](ch07.xhtml#ch7fig14) illustrates the
    starting conditions of the algorithm.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig14.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Starting conditions for finding the shortest paths from S*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Node distances from the start node are given just outside the node circle. Nodes
    that haven’t been visited are assigned a tentative distance value of infinity
    (except for the start node, which has a value of zero). The queue shows the nodes
    with distance values indicated by exponents.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to pop the first node in the queue (which will always have
    a known distance) and color it with a light background as shown here in [Figure
    7-15](ch07.xhtml#ch7fig15). Set this node as the current node, *u* (in this case
    *u* = *S* with a distance value of zero).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig15.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Step 1 of Dijkstra’s algorithm*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The neighbors of *u* are given in a darker color. We then perform the following
    tentative distance calculation, *t*, for each neighbor (designated *v*) of *u*
    that’s still in the queue, where *d*(*u*) is the known distance from the start
    node to *u*, and *l*(*u*, *v*) is the distance value of the edge from *u* to *v*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: If *t* is less than the prior distance value (initially *∞*), the queue is updated
    with the new node distance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'With the queue updated, we repeat the process, this time popping *c* off the
    queue, making it the current node (in other words, *u* = *c*), and updating the
    queue and neighbor distances as before. The state of the graph is then as follows
    in [Figure 7-16](ch07.xhtml#ch7fig16):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig16.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: Step 2 of Dijkstra’s algorithm*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We show the path from *S* to *c* in a thicker gray line to indicate a known
    shortest path in [Figure 7-16](ch07.xhtml#ch7fig16). The sequence of diagrams
    in [Figure 7-17](ch07.xhtml#ch7fig17) illustrates the remainder of the process.
    Notice that in [Figure 7-17](ch07.xhtml#ch7fig17)a the original distance of node
    *a* has been updated from 12 to 9 based on the path now being from *S* through
    *b* to *a*. The thick lines in 7-17d, the final graph, form a tree structure reflecting
    all the shortest paths originating from node *S* to the remaining nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一条较粗的灰线显示从 *S* 到 *c* 的路径，以表示在[图 7-16](ch07.xhtml#ch7fig16)中已知的最短路径。[图 7-17](ch07.xhtml#ch7fig17)中的一系列图示展示了其余的过程。请注意，在[图
    7-17](ch07.xhtml#ch7fig17)a中，节点 *a* 的原始距离已从 12 更新为 9，原因是当前路径是从 *S* 通过 *b* 到 *a*。在
    7-17d 中，最终图中粗线条所形成的树形结构反映了所有从节点 *S* 出发到其余节点的最短路径。
- en: '![Image](../images/07fig17.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig17.jpg)'
- en: '*Figure 7-17: The rest of Dijkstra’s algorithm*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：Dijkstra 算法的其余部分*'
- en: We’re usually interested in how efficiently an algorithm performs. This is generally
    specified by a *complexity* value. There are a number of ways this can be done,
    but a popular formulation is called *Big O notation* (the O stands for “order
    of"). This notation aims to give a gross approximation of how efficiently an algorithm
    performs (in terms of running time or memory usage) based on the size of its inputs.
    Dijkstra’s algorithm has a running time complexity of *O*(*N*²), where *N* is
    the number of nodes in the graph. This means the running time increases as the
    square of the number of inputs. In other words, if we double the number of nodes,
    the algorithm will take about four times as long to run. This is taken to be an
    upper-bound or worst-case scenario, and depending on the nature of the graph,
    the runtime could be less.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常关心的是算法的执行效率。这通常通过一个*复杂度*值来指定。有很多种方式可以做到这一点，但一种常见的表述方式叫做*大 O 符号*（O 代表“阶”（Order））。这种符号旨在给出算法执行效率的粗略估算（在运行时间或内存使用方面），并且基于输入的规模。Dijkstra
    算法的运行时间复杂度是 *O*(*N*²)，其中 *N* 是图中节点的数量。这意味着运行时间随着输入数量的平方增长。换句话说，如果我们将节点数加倍，算法的运行时间大约会变为原来的四倍。这被视为一个上界或最坏情况，并且根据图的性质，运行时间可能会更少。
- en: '***The Priority Queue***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***优先队列***'
- en: As we’ve seen in the analysis above, a priority queue plays a key role in Dijkstra’s
    algorithm. Priority queues can be implemented in a number of ways, but one popular
    approach is to use something called a binary heap. A *binary heap* is a binary
    tree structure (meaning each node has a maximum of two children) where each node’s
    value is greater than or equal to its child nodes. This type of heap is called
    a *max-heap*. It’s also possible for each parent node to be less than or equal
    to its child nodes. This type of heap is called a *min-heap*. An example of such
    a heap is shown in [Figure 7-18](ch07.xhtml#ch7fig18). The top or root node is
    always the first to be removed since it’s considered to have the highest priority.
    After nodes are added to or removed from the heap, the remaining nodes are rearranged
    to maintain the proper priority order. While it’s not terribly difficult to build
    a binary heap object, Racket already has one available in the *data/heap* library.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上面的分析中所看到的，优先队列在 Dijkstra 算法中起着关键作用。优先队列可以通过多种方式实现，但一种流行的方法是使用称为二叉堆的结构。*二叉堆*是一种二叉树结构（意味着每个节点最多有两个子节点），其中每个节点的值大于或等于其子节点的值。这种类型的堆叫做*最大堆*。也可以让每个父节点小于或等于其子节点的值，这种类型的堆叫做*最小堆*。这种堆的示例如[图
    7-18](ch07.xhtml#ch7fig18)所示。根节点或顶部节点总是第一个被移除，因为它被认为具有最高优先级。在向堆中添加或移除节点后，剩余的节点会重新排列以维持正确的优先顺序。虽然构建二叉堆对象并不是特别困难，但
    Racket 中已经有一个可用的二叉堆，它在 *data/heap* 库中。
- en: '![Image](../images/07fig18.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig18.jpg)'
- en: '*Figure 7-18: Min-heap*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：最小堆*'
- en: 'Our heap entries won’t be just numbers: we’ll need to track the node and its
    current distance value (which determines its priority). So each heap entry will
    consist of a pair where the first element is the node and the second element is
    the current distance. When a Racket heap is constructed, it must be supplied with
    a function that will do the proper comparison when given two node entries. We
    accomplish this with the following code. The `comp` function only compares the
    second element of each pair since that’s what determines the priority.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To save a bit of typing, we create a few simple helper functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `update-priority` procedure takes a symbol and a new priority to update
    the queue. It does this by removing (dequeuing) the old value and adding (enqueuing)
    a new value. The `heap-remove!` function performs very efficiently, but it needs
    the exact value (pair with symbol and priority) to work. Unfortunately, without
    knowing the priority, we have to resort to a linear search through the entire
    queue to find the symbol via the `in-heap` sequence. This can be optimized by
    storing (in another data structure like a hash table) the symbol and current priority.
    We leave it to the reader to perform this added step if desired.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples of the priority queue in action.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Regardless of the order the values were added to the queue, they’re stored and
    removed in priority order.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '***The Implementation***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define our graph as a list of edges. Each edge in the list consists of the
    end nodes along with the distance between nodes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we progress through the algorithm, we want to to keep track of the current
    parent of each node so that when the algorithm completes, we’ll be able to reproduce
    the shortest path to each node. A hash table will be used to maintain this information.
    The key is a node name and the value is the name of the parent node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need to take care in our coding to be mindful of the fact that our graph
    is bi-directional, and an edge defined by (*a*, *b*) is equivalent to one defined
    by (*b*, *a*). We’ll account for this by supplementing the original edge list
    with a list consisting of the nodes reversed. We’ll also use a hash table (`lengths`)
    to maintain the lengths of each edge and an additional hash table (`dist`) to
    record the shortest distance to each node as it’s discovered. To pull all this
    together, we define `init-graph`, which takes an edge list and returns the original
    list appended with the swapped node list. It will also be used to initialize the
    priority queue and the various hash tables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here’s the code, `dijkstra`, that actually computes the shortest paths for each
    node.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `dijkstra` code takes the starting node symbol and edge list as arguments.
    It then defines `graph`, which is the original list of edges appended with a list
    of the edges with the nodes swapped. As mentioned, the `init-graph` procedure
    also initializes all the other data structures required for the algorithm to work.
    A local `neighbors` function is defined ➊ that takes a node and returns the list
    of nodes that are adjacent to the node and still in the queue. The main loop starts
    ➋ and the first step is to pop the first node in the queue and assign its symbol
    to `u`. Next, each of its neighbors (`v`) is processed ➌. For each neighbor, we
    compute *t* = *d*(*u*) + *l*(*u*, *v*) ➍ (recall that *d*(*u*) is the most current
    distance estimate from the start symbol to *u*, and *l*(*u*, *v*) is the length
    of the edge from *u* to *v*). We then test whether *t* < *d*(*v*) ➎, and if it
    passes the test, we do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Assign *d*(*v*) = *t* ➏.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign *u* as the parent of *v* ➐.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the queue with *t* as the new priority of *v* ➑.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we test whether any values remain on the heap, and if so, repeat the
    process ➒. Once the algorithm completes, `parent` will contain the parent of each
    node. All that remains is to chase the chain of parents to the start symbol to
    determine the shortest path to the node. This is done by the following `get-path`
    function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `show-paths` procedure will print out paths for all the nodes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For convenience we define `solve`, which takes a starting symbol and edge list,
    calls `dijkstra` to compute the shortest paths, and prints out the shortest path
    to each node.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Given our original graph where we defined the edges in `edge-list` above, and
    starting symbol `S`, we generate the solutions as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s try this slightly more ambitious example in [Figure 7-19](ch07.xhtml#ch7fig19)
    (see [**4**]).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig19.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: Another graph to test Dijkstra’s algorithm on*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The edge list for this graph is . . .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, solving for the shortest path, we have . . .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve highlighted the tree of shortest paths in the resulting graph (see [Figure
    7-20](ch07.xhtml#ch7fig20)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig20.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-20: Shortest paths found*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve thoroughly examined Dijkstra’s shortest-path algorithm, we’ll
    next take a look at the A* algorithm via Sam Loyd’s (in)famous 14–15 puzzle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The 15 Puzzle
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 15 puzzle consists of 15 sequentially numbered sliding tiles in a square
    frame that are randomly scrambled, with the goal of getting them back into their
    proper numerical sequence. In the late 1800’s Sam Loyd created a bit of buzz over
    this puzzle by offering a $1,000 prize for anyone who could demonstrate a way
    to start with a puzzle with all the tiles in order, except with the 14 and 15
    tiles reversed (as shown in [Figure 7-21](ch07.xhtml#ch7fig21), Loyd called this
    arrangement the “14-15 Puzzle”), and get them back in their proper order (without
    removing the tiles from the case, of course). As we’ll see shortly, this is mathematically
    impossible, so Loyd knew his money was safe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig21.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-21: Sam Loyd’s 14–15 puzzle illustration*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Swapping Just Two Tiles Is Impossible**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To get an idea of why Loyd’s money was safe (that is, why it’s not possible
    to exchange two and only two tiles), consider the puzzle in its solved state as
    shown in [Figure 7-22](ch07.xhtml#ch7fig22).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig22.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-22: Solved 15 puzzle*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Any sequence of moves that would reverse the 14 and 15 tiles would produce the
    arrangement in Loyd’s puzzle. Simply reproducing this sequence would get the tiles
    back in order. We’ll see that this is impossible. Now consider the arrangement
    in [Figure 7-23](ch07.xhtml#ch7fig23).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig23.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-23: 15 puzzle with inversions*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: If we arrange these tiles linearly, we have 2, 3, 1, 4, 5, 6, . . . In particular,
    the values of tile-2 and tile-3 are larger than tile-1, which follows them. Each
    such situation, where the value of a tile is larger than one that follows it,
    is called an *inversion* (two inversions in this case).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Related to the idea of inversion is that of *transposition*. A transposition
    is simply the exchange of two values in a sequence. A given arrangement can be
    arrived at by any number of transpositions. For example, one way to get to the
    sequence 2, 3, 1, 4, 5, 6, . . . would be as follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting arrangement: 1, 2, 3, 4, 5, 6, . . .'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Transpose 1 and 3: 3, 2, 1, 4, 5, 6, . . .'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Transpose 2 and 3: 2, 3, 1, 4, 5, 6, . . .'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key idea is that an arrangement consisting of an even number of inversions
    will always be generated by an even number of transpositions, and an arrangement
    with an odd number of inversions will always be generated by an odd number of
    transpositions. For reference purposes, the empty slot will be treated as a tile
    and designated with the number 16\. Any single movement by tile-16 is a transposition.
    If tile-16 leaves from the lower right corner and arrives at a particular spot
    using an odd number of transpositions, it will require an odd number of transpositions
    to get back to the starting location, or a net even number of transpositions.
    This leaves the puzzle with an even number of inversions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The arrangement Sam Loyd proposes is impossible to solve since it involves a
    single odd inversion. It’s also true, but trickier to prove, that any puzzle with
    an even number of inversions is solvable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Having resolved this historical issue with Sam Loyd’s puzzle, we now turn our
    attention to finding solutions for puzzles that are in fact solvable. In this
    regard we’ll now explore the A* search algorithm (we mostly abbreviate this to
    simply the “A* algorithm” hereafter).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '***The A* Search Algorithm***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll of course assume that the computer is presented with a solvable puzzle
    (that is, it has an even number of inversions). The computer should provide a
    solution that’s as efficient as possible—that is, a solution that requires the
    smallest number of moves to get to the goal state. One method that generally provides
    good results is called the *A* search* algorithm. An advantage of the A* algorithm
    over a simple breadth-first or depth-first search is that it uses a *heuristic*^([1](footnote.xhtml#ch07foot_1))
    to reduce the search space. It does this by computing an *estimated* cost of taking
    any given branch in the search tree. It iteratively improves this estimate until
    it determines the best solution or it determines no solution can be found. Estimates
    are stored in a priority queue where the least cost state is at the head of the
    list.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin our analysis by looking at a smaller variant of the 15 puzzle, called
    the 8 puzzle. The 8 puzzle in its solved state is shown in [Figure 7-24](ch07.xhtml#ch7fig24).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig24.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-24: Solved 8 puzzle*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The search tree of the 8 puzzle can be modeled as shown in [Figure 7-25](ch07.xhtml#ch7fig25),
    where each node of the tree is a state of the puzzle, and the child nodes are
    the possible states that can arise from a valid move.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig25.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-25: Partial 8 puzzle game tree*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'At each iteration of the A* algorithm, it computes an estimate of the cost
    (that is, the number of moves) to get to the goal state. Formally, it attempts
    to minimize the following estimated cost function, where *n* is the node under
    consideration, *g*(*n*) is the cost of the path from the start node to *n*, and
    *h*(*n*) is a heuristic that estimates the cost of the cheapest path from *n*
    to the goal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*f(n)* = *g(n)* + *h(n)*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing a good heuristic function is something of an art. To get the best
    performance from the A* algorithm, an important characteristic of the heuristic
    is that it satisfies the following condition for every edge in the graph, where
    *h*^*(*n*) is the actual (but unknown) cost to reach the goal state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa02.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: If a heuristic meets this condition, it’s said to be *admissible*, and the A*
    algorithm is guaranteed to find the optimal solution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: One possible heuristic for the 8 puzzle uses something called the *Manhattan
    distance* (as opposed to the familiar straight-line distance). For example, to
    get the tile-2 in [Figure 7-25](ch07.xhtml#ch7fig25) to its home location (the
    cell it would occupy in the solved state), the tile would have to move up two
    squares and one square to the left for a total of three moves—this is the Manhattan
    distance. The heuristic value for a puzzle state would be the sum of the Manhattan
    distances for each tile. [Table 7-1](ch07.xhtml#ch7tab1) shows the computation
    of this value for the root node of [Figure 7-25](ch07.xhtml#ch7fig25).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1**: Computing Manhattan Distance'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tile** | **Rows** | **Cols.** | **Total** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 1 | 3 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 1 | 2 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | 0 | 1 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0 | 1 | 1 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 | 0 | 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1 | 2 | 3 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| 8 | 2 | 1 | 3 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| Distance: | 15 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: The Manhattan distance will always be less than or equal to the actual number
    of moves, so it satisfies the admissibility condition.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly weaker heuristic is the *Hamming distance*, which is just the number
    of misplaced tiles. The Hamming distance for the puzzle shown in [Figure 7-25](ch07.xhtml#ch7fig25)
    is eight: none of the tiles are in their home location.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-26](ch07.xhtml#ch7fig26) we’ve annotated each node with three values.
    The first value is the depth of the game tree (this value is incremented by one
    for each level and constitutes the value of *g*(*n*) in the cost formula), the
    second value is the heuristic value, *h*(*n*), for the node (the Manhattan distance
    in this case), and the third value is the sum of the two giving the overall cost
    score for the node.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig26.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-26: 8 puzzle with node costs*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The A* algorithm uses a priority queue called *open*. This queue orders the
    puzzle states that have been examined but whose child nodes have not been expanded,
    according to the estimated cost to reach the goal. The algorithm also relies on
    a dictionary, called *closed*, that uses the puzzle state as a key and maintains
    the most recent cost value for the node. [Figure 7-27](ch07.xhtml#ch7fig27) reflects
    the current state of the analysis, where the first node in the open queue is the
    root node of [Figure 7-26](ch07.xhtml#ch7fig26).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig27.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-27: Closed and open*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The values shown at the top of the closed nodes are the latest estimated costs.
    The values at the top of the open nodes are the same three cost values described
    above. With this introduction we walk through an iteration of how the A* algorithm
    processes the game tree.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to pop the lowest-priority value off the open queue. This
    node is then added to the closed dictionary. The next step is to compute the costs
    for the child nodes, which are shown on the second level of [Figure 7-26](ch07.xhtml#ch7fig26).
    If any of these nodes are not on the closed list, they are simply queued to open
    with no further analysis. Notice that the first child node *is* on the closed
    list. Since its current estimated cost is less than the cost on the closed list,
    it’s removed from the closed list and the node is added back to the queue with
    its new value. In the situation where a child node is on the closed list, but
    its estimated value is *larger* than the value on the closed list, no change is
    made, and it’s not added to the queue. Once this phase is complete, the open and
    closed structures will appear as shown in [Figure 7-28](ch07.xhtml#ch7fig28).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Since the first child node in [Figure 7-26](ch07.xhtml#ch7fig26) has a lower
    cost than the other nodes in the open queue, it moves to the head of the queue
    and becomes the next item to be popped off. Notice that its first child is already
    in the closed list, but its newly computed cost is higher than the cost in the
    closed list, so it’s ignored. The remaining child node would be processed as before.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig28.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-28: Closed and open, updated*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The process continues until one of two things happens: either a node is popped
    off the open queue that’s in the solved state, in which case the algorithm completes
    and prints the answer (details on how this is accomplished are described in the
    next section), or the open queue becomes empty, which indicates that the puzzle
    was not solvable.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '***The 8-Puzzle in Racket***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll begin by implementing a solution to the smaller 3-by-3 version of the
    puzzle before we move on the full 4-by-4 version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Dijkstra’s algorithm, we’ll use Racket’s heap object for the open priority
    queue:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A `SIZE` constant will specify the number of rows and columns in the puzzle.
    In addition we’ll define a number of utility functions to work with the puzzle
    structure. For efficiency, the puzzle state will be stored internally as a Racket
    vector of size `SIZE*SIZE+2`. The last two elements of the vector will contain
    the row and column of the empty cell. The empty cell will have the numerical value
    specified by `(define empty (sqr SIZE))`. To this end, we have the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ref` function will take a puzzle along with and a row and column number
    as arguments. It returns the tile number at that location. The `empty-loc` function
    will return two values that give the row and column respectively of the empty
    cell.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The following functions are used to compute the Manhattan distance. The first
    creates a hash table used to look up the home location of a tile given the tile
    number. The second function computes the sum of the Manhattan distances for each
    tile in the puzzle. This will be used in the computation of the cost of a puzzle
    node.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next functions are used to generate a new puzzle state given a move specifier.
    A move specifier is a number from zero to three that determines which of the four
    directions a tile can be moved into the empty space from.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `move-offset` function takes a move specifier and returns two values specifying
    the row and column deltas needed to make the move. The `make-move` function takes
    a move specifier and returns a new vector representing the puzzle after the move
    has been made.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The following function will take a puzzle and return a list consisting of all
    the valid puzzle states that can be reached from a particular puzzle state. The
    local `legal` function determines whether a move specifier will result in a valid
    move for the current puzzle state by checking whether a move in a certain direction
    will extend beyond the boundaries of the puzzle.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It will of course be useful to actually see a visual representation of the puzzle.
    That functionality is provided by the following routine.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next we define a helper function to process closed nodes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We begin by placing the node, its parent, and its estimated cost in the `closed`
    table ➊. Next, we generate a list of the possible child puzzle states and loop
    through them. For each child node, we generate the new node depth ➋ and estimated
    score ➌. Then we compile the information that we’d need to push that node to the
    open queue ➍, which happens automatically ➐ if the node is not in the `closed`
    table. If the node is in the `closed` table, we extract its prior cost score ➎
    and compare with its current score ➏. If the current score is less than the prior
    score, we remove the node from the `closed` table and place it in the open queue.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We finally get to the algorithm proper.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First we define the `closed` hash table described above. The open queue is initialized
    ➊, and the scrambled puzzle provided to the `a-star` procedure is pushed onto
    the open queue ➋. The items in the queue consist of a Racket pair. The `cdr` of
    the pair is the estimated score, and the `car` consists of the puzzle state, the
    depth of the tree, and the parent puzzle state. After this initialization, the
    main loop starts ➌.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The loop repeats until the `solved` variable is set to true. The first step
    of the loop is to pop the highest-priority item (lowest cost score) from the open
    queue and assign it to the `node-info` variable. A `match` form is used to parse
    the values contained in `node-info` ➎. The puzzle state (in `node`) is first tested
    to see if it’s in the solved state ➏, and if so, the function prints out the move
    sequence and terminates the process. Otherwise, the processing continues where
    we process the closed node by placing the node, its parent, and estimated cost
    in the `closed` table ➐.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Once each iteration completes, the queue is checked ➑ to see if it contains
    any nodes that needs processing. If it does, then the next iteration resumes ➍;
    otherwise, no solution exists and the process terminates ➒.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Here are the print functions that show the solution. The `solution-list` procedure
    chases the parent nodes in `closed` to create a list of the puzzle states all
    the way back to the starting puzzle; `print-solution` takes the solution list
    and prints out the puzzle states it contains.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here’s a test run on the puzzle presented in [Figure 7-25](ch07.xhtml#ch7fig25)
    (to save space, the output puzzles are displayed horizontally).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***Moving Up to the 15 Puzzle***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Having laid the groundwork with the 8 puzzle, the 15 puzzle requires this tricky
    modification: change the value of `SIZE` from 3 to 4\. Okay, maybe that’s not
    too tricky, but before you get too excited, it’s really not quite that simple
    either. Observe [Figure 7-29](ch07.xhtml#ch7fig29). The first two puzzles are
    from [9], and our test computer sailed through solving these. But the third puzzle
    was randomly generated and caused the test computer to fall to the floor, giggling
    to itself that we would attempt to have it solve such a problem—no solution was
    forthcoming.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig29.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-29: Some 15 puzzle examples*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that some puzzles may result in the A* algorithm having to explore
    too many paths, so the computer runs out of resources (or the user runs out of
    patience waiting for an answer). Our solution is to settle for a slightly less
    elegant approach by breaking the problem into three subproblems. We will trade
    off a fully optimized solution for a solution that we don’t have to wait forever
    to get.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: To break the problem into subproblems, we’re going to divide the puzzle into
    three zones as shown below in [Figure 7-30](ch07.xhtml#ch7fig30). The zones are
    chosen to take advantage of the fact that the A* algorithm was pretty zippy with
    the 8 puzzle.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig30.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-30: 15 puzzle divided into zones*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The medium gray section, which we designate zone 1, represents one subproblem,
    the white section (zone 2) will be the second subproblem, and the dark gray section
    (zone 3) represents another subproblem (which is equivalent to the 8 puzzle, which
    we know can be solved quickly). The idea is to provide different scoring functions
    to the `a-star` algorithm depending on which zone is being addressed. These functions
    will still use the Manhattan distance, but with certain restrictions applied.
    Once zone 1 and zone 2 have been solved, we can just call `manhattan` as before
    since the edge tiles in zones 1 and 2 will already be in place and the remaining
    tiles would be equivalent to an 8 puzzle.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone 1**'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Before we dive into solving zone 1, we’re going to create a helper function
    that’s quite similar to the code we saw in the `manhattan` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The main difference is that instead of embedding the test for the empty square
    directly in the `cost` function, we’ll pass in a function for the `guard` parameter
    that will do the test for us. Given this, we can redefine `manhattan` as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ll attack zone 1 in two phases: first we nudge tiles 1 through 4 into the
    first two rows of the puzzle; then we get them into the proper order in the first
    row.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: To get tiles 1 through 4 into the first two rows, we define `zone1a`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, we only update the distance for tiles 1 through 4, and we only
    update the distance if these tiles are not already in the first two rows.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The second phase is just slightly different. This time we always update the
    distance for tiles 1 through 4 to ensure they land in the proper locations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It might appear that this could have been done in a single function, but trying
    to position the tiles all at once would result in a large search space and the
    consequent increase needed in time and computer resources (like memory). Our first
    phase, where we just get the tiles into the proximity of their proper location,
    reduces the search space by half, without requiring an enormous amount of resources.
    The sorting in phase two will normally only have to deal with the tiles in the
    top half of the puzzles since the remaining tiles will have a score of zero.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone 2**'
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, we’ve reduced the search space by 25 percent. This modest reduction
    is sufficient to allow us to get tiles 5, 9, and 13 into zone 2 and in their proper
    order in a single procedure, which we provide here as `zone2`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, we no longer need to bother with row 1, as reflected in the code
    `>= r 1`. Aside from this, the code is nearly identical to the others, except
    that this time, we use the values defined in `zone2-tiles` for scoring.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**Putting It All Together**'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once a zone has been solved, we won’t want to disturb the tiles that are already
    in place. To accomplish this, a slight tweak is made to the function (`next-states`)
    that generates the list of permissible states. Before, we simply checked to ensure
    we weren’t moving beyond the first row or column. Now we define global variables
    `min-r` and `min-c`, which are set to 0 or 1 depending on which zone we’re currently
    working in.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The final solver will update the values of `min-r` and `min-c` once zones 1
    and 2 have been populated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We now need to make a few crucial modifications to the code for `a-star` and
    `process-closed`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The most significant change is that instead of always using `manhattan` for
    our scoring estimate, we now use the function `fscore` ➊, which is passed to `process-closed`
    as an additional parameter. This function will be different depending on which
    zone of the puzzle is being solved.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here we also include `fscore` as an additional parameter. Now, instead of immediately
    printing a solution once the goal state is reached, we return two values at the
    end ➌: the current goal, given in the first `set!` ➊ and the solution list, given
    in the second `set!` ➋. The remaining code should align closely with the original
    version.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Instead of calling `a-star` directly as we did before, we now provide a `solve`
    function that steps through the process of providing `a-star` with the proper
    scoring function, which is either one of the zone-specific functions or `manhattan`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As the code executes, it stores the solution list for each step of the process
    and finally prints the entire solution in the last line of the code. The reason
    we take the `cdr` of the solution list at each step (except the first) is because
    the last item in the solution from the previous step is the goal of the next step;
    this state would be repeated if we left it in the list.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we resolve a little cosmetic issue with the `print` routine caused
    by having two-digit numbers on the tiles. The revised code follows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The following are some sample inputs with which to test the code. To save space,
    only the output (compressed) from the first example is shown.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Be aware that depending on the puzzle and the power of your computer, it may
    take anywhere from a couple of seconds to a minute or so to generate a solution.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Sudoku
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sudoku^([2](footnote.xhtml#ch07foot_2)) is a popular puzzle consisting of a
    9-by-9 grid of squares in which some squares are initially populated with digits
    from 1 through 9, as shown in [Figure 7-31](ch07.xhtml#ch7fig31)a. The objective
    is to fill in the blank squares such that each row, column, and 3-by-3 block of
    squares also consists of digits 1 through 9, as shown in [Figure 7-31](ch07.xhtml#ch7fig31)b.
    A well-formed Sudoku puzzle should only have one possible solution.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig31.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-31: The Sudoku puzzle*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Our aim in this section is to produce a procedure that generates the solution
    to any given Sudoku puzzle.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic strategy is this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Check each empty cell, to determine which numbers are available to be used.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a cell with the fewest available numbers.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One at a time, enter one of the available numbers in the cell.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each available number, repeat the process until either the puzzle is solved,
    or there are no numbers available for an empty cell.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no available numbers, backtrack to step 3 and try a different number.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process is another application of depth-first search.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-32](ch07.xhtml#ch7fig32) gives the coordinates used to reference
    locations in the puzzle: numbers across the top index columns, numbers on the
    left edge index rows, and numbers in the interior index blocks of 3-by-3 subgrids.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig32.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-32: Puzzle coordinates*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the available numbers for a given cell, we take the set intersection
    of the unused numbers in each row, column, and block. Using the cell in row 1,
    column 1 of [Figure 7-31](ch07.xhtml#ch7fig31)a as an example, in row 1 the set
    of numbers {2, 5, 8} are free, in column 1 all the numbers except for 5 are available,
    and in block 0, the set of numbers {2, 3, 7, 8, 9} are available. The intersection
    of these sets gives the set of possible values for this cell: {2, 8}.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation will use a 9-by-9 array of numbers to represent the puzzle,
    where the number 0 will designate an empty square. The array will be constructed
    of a nine-element vector, each element being another nine-element integer vector.
    For easy access to elements of the array, we define two utility functions to set
    and retrieve values:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both of these functions require the array and row and column numbers to be provided
    as the initial arguments.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: It will also be useful to derive the corresponding block index from the row
    and column numbers, as given by the `getBlk` function here.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The puzzle will be input as a single string where each row of nine digits is
    broken by a new line as shown by the example below.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We define the Sudoku puzzle object as a `sudoku%` Racket object for which we
    give a partial implementation here. This object will maintain the puzzle state.
    It will contain functions that allow us to manipulate the state by setting cell
    values and provides functions to list potential candidates (unused numbers in
    a row, column, or block) and other helper functions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `init` form ➊ captures the input string value that defines the puzzle. We
    initialize the puzzle ➎ by calling `init-puzzle` ➐, which updates `grid` ➌ with
    the appropriate numerical values via the call to `init-grid` ➏.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The `count` variable ➋ contains the number of cells that currently have a value.
    Once `count` reaches 81, the puzzle has been solved.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'The `avail-row`, `avail-col`, and `avail-blk` variables are used to keep track
    of which numbers are currently unused in each row, column, and block respectively.
    The `make-markers` function, which is called to initialize each of these variables,
    creates a Boolean array that indicates which numbers are free for any given index
    (row, column, or block as applicable); `make-markers` is defined as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice that the number 0 (designating an empty cell) is automatically marked
    as unavailable.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: As numbers get added to the puzzle, `item-set!` is called ➍. This procedure
    is responsible for updating `grid` and `avail-row`, `avail-col`, and `avail-blk`
    when given the row, column, and number to be assigned to the puzzle. The functions
    `get-grid` and `item-ref` return `grid` or a cell in `grid` respectively.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In the following code extracts, all function definitions that are indented should
    be included in the class definition for `sudoku%` and aren’t global defines.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The following `avail` function combines the values from `avail-row`, `avail-col`,
    and `avail-blk` to produce a vector indicating which numbers are available.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Given this vector, we create a list of the free numbers as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For efficiency, the following code finds all the cells that only have a single
    available number and updates the puzzle appropriately.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Performing this process once may result in other cells with only a single available
    number. The following code runs until no cells remain with only a single available
    number.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For puzzles that can be solved directly by logic alone (no guessing is required),
    the above process would be sufficient, but this isn’t always the case. To support
    backtracking, the following two functions are provided.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first function (`get-free`) goes cell by cell and creates a list of all
    the free values for each cell. Each element of the list contains another list
    that holds the row, column, number of free values, and a list of the free values.
    The second function (`get-min-free`) takes the list returned by `get-free` and
    returns the values for the cell with the fewest free numbers.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few handy utility functions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `print` member function provides a simple text printout of the puzzle. The
    `solved?` function indicates whether the puzzle is in the solved state by testing
    whether all 81 cells have been populated. The `clone` function provides a copy
    of the puzzle.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the code that’s defined within the body of the `sudoku%` class
    definition and brings us to the actual code used to solve the puzzle.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We begin by creating a copy of the puzzle to work with ➊. Next, we define a
    depth-first search procedure, `dfs` ➋, which we’ll explain shortly. The call to
    `set-all-singles` ➑ is occasionally sufficient to solve the puzzle, but the puzzle
    is handed off to `dfs` to ensure a complete solution is found. The remaining lines
    will return a solved puzzle if one exists; otherwise an error is signaled.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The depth-first search code, `dfs` ➋, immediately tests whether the puzzle is
    solved and if so, returns the solved puzzle. Otherwise, the cell with the fewest
    available numbers (if any) is explored ➌, where the `match` form extracts the
    cell row, column, number of free numbers, and the list of free numbers. The list
    of free numbers is iterated through starting on the next line. While the list
    isn’t empty, the first number in the list is extracted into `n` ➍ and the remaining
    numbers are stored in `t` ➎. Then a copy of the puzzle is created. Next, the puzzle
    copy is populated with the current available number ➏, and `set-all-singles` is
    called immediately following this. If this number doesn’t produce a solution (via
    the recursive call to `dfs` ➐), the loop repeats with the original puzzle and
    the next available number.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: To aid testing various puzzles, we define a simple routine to take an input
    puzzle string, solve the puzzle, and print the solution.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that we’ve laid this groundwork, here’s a trial run with our example puzzle.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: While this is certainly an adequate method to generate the output, it doesn’t
    take a lot of additional work to produce a more attractive output.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish our goal, we’ll need the Racket *draw* library.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Furthermore, we’ll borrow our `draw-centered-text` procedure that we used in
    the 15 puzzle GUI:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Given these preliminaries, we can now define our `draw-puzzle` function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There’s really nothing new here. The reason we’re passing it two puzzles is
    because the first puzzle is the original unsolved puzzle. It’s simply used to
    determine which color to use to draw the squares. If a square was blank in the
    original puzzle, it’ll be colored yellow in the output; otherwise it’ll be colored
    gray.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in hand, we can redefine `solve` as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using this new version yields the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It gives the starting state in [Figure 7-33](ch07.xhtml#ch7fig33):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig33.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-33: Sudoku starting-state drawing*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'And the solved state in [Figure 7-34](ch07.xhtml#ch7fig34):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig34.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-34: Solved Sudoku drawing*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored a number of algorithms that are useful in the
    general context of problem-solving. In particular we’ve looked at breath-first
    search (BFS), depth-first search (DFS), the A* algorithm, and Dijkstra’s algorithm
    (and discovered priority queues along the way) to find the shortest path between
    graph nodes. We employed DFS in the solution of the *n*-queens problem and the
    15 puzzle (which also used the A* algorithm). Finally, we took a look at Sudoku,
    where sometimes logic alone is sufficient to solve, but failing this, DFS again
    comes to the rescue. While the algorithms we’ve explored are far from a comprehensive
    set, they form a useful toolset that’s effective in solving a wide range of problems
    over many domains.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far we’ve exercised a number of programming paradigms: imperative, functional,
    and object-oriented. In the next chapter, we’ll look at a new technique: programming
    in logic or logic programming.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
