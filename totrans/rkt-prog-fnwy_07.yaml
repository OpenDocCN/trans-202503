- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: SEARCHING FOR ANSWERS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找答案
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/common01.jpg)'
- en: For all the problems we have encountered so far, there was a direct method to
    compute the solution. But this is not always the case. For many problems, we have
    to search for the solution using some type of algorithm, such as when solving
    a Sudoku puzzle or the *n*-queens problem. In these cases, the process involves
    trying a series of steps until either we find the solution or we have to back
    up to a previous step to try an alternative route. In this chapter we’ll explore
    a number of algorithms that allow us to efficiently select a path that leads to
    a solution. Such an approach is known as a *heuristic*. In general, a heuristic
    isn’t guaranteed to find a solution, but the algorithms we explore here (thankfully)
    are.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们到目前为止遇到的所有问题，都有一种直接的方法来计算解决方案。但情况并不总是如此。对于许多问题，我们必须使用某种算法来搜索解决方案，例如在解决数独谜题或*n*皇后问题时。在这些情况下，过程涉及尝试一系列步骤，直到我们找到解决方案，或者必须回退到上一步尝试另一条路径。本章中，我们将探索一些算法，帮助我们高效选择一条通向解决方案的路径。这种方法被称为*启发式*。通常，启发式算法不能保证找到解决方案，但我们在这里探索的算法（幸运的是）是可以的。
- en: Graph Theory
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图论
- en: It’s often the case that a problem we’re trying to solve can be modeled with
    a *graph*. Intuitively, a graph is just a set of points (or nodes) and connecting
    lines, as illustrated in [Figure 7-1](ch07.xhtml#ch7fig1). Each node represents
    some state of the problem-solving process, and the lines extending from one node
    to other nodes represent possible alternative steps. We’ll first give some basic
    graph definitions as background before delving into the actual problem-solving
    algorithms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图解决的问题往往可以用*图*来建模。直观地说，图只是一些点（或节点）和连接这些点的线条，如[图 7-1](ch07.xhtml#ch7fig1)所示。每个节点表示问题解决过程中的某个状态，从一个节点延伸到其他节点的线条表示可能的替代步骤。在深入实际问题解决算法之前，我们首先介绍一些基本的图的定义作为背景。
- en: '***The Basics***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Formally, a graph is a finite set *V* of *vertices* (or nodes) and a set *E*
    of *edges* joining different pairs of distinct vertices (see [Figure 7-1](ch07.xhtml#ch7fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从正式定义来看，图是一个有限集合 *V* 的*顶点*（或节点），以及一个集合 *E* 的*边*，连接不同的顶点对（见[图 7-1](ch07.xhtml#ch7fig1)）。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/07fig01.jpg)'
- en: '*Figure 7-1: Graph*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1: 图*'
- en: In [Figure 7-1](ch07.xhtml#ch7fig1) above, *V* = {*a, b, c, d, e*} are the vertices
    and *E* = {(*a*, *b*), (*a*, *c*), (*b*, *c*), (*c*, *d*), (*b*, *e*), (*e*, *d*)}
    are the edges.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的[图 7-1](ch07.xhtml#ch7fig1)中，*V* = {*a, b, c, d, e*} 是顶点，*E* = {(*a*, *b*),
    (*a*, *c*), (*b*, *c*), (*c*, *d*), (*b*, *e*), (*e*, *d*)} 是边。
- en: A sequence of graph vertices (*v*[1], *v*[2], …, *v*[*n*]), such that there’s
    an edge connecting *v*[*i*] and *v*[*i*+1], is called a *walk*. If all the vertices
    are distinct, a walk is called a *path*. A walk where all the vertices are distinct
    except that *v*[1] = *v*[*n*] is called a *cycle* or *circuit*. In [Figure 7-1](ch07.xhtml#ch7fig1),
    the sequence (*a*, *b*, *c*, *b*) is a walk, the sequence (*a*, *b*, *c*, *d*)
    is a path, and the sequence (*a*, *b*, *c*, *a*) is a cycle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列图的顶点（*v*[1], *v*[2], …, *v*[*n*]），使得存在一条边连接 *v*[*i*] 和 *v*[*i*+1]，称为*路径*。如果所有顶点都不相同，则路径称为*简单路径*。如果路径中所有顶点都不相同，除了
    *v*[1] = *v*[*n*] 外，则称为*循环*或*回路*。在[图 7-1](ch07.xhtml#ch7fig1)中，序列（*a*, *b*, *c*,
    *b*）是一个路径，序列（*a*, *b*, *c*, *d*）是一个简单路径，序列（*a*, *b*, *c*, *a*）是一个循环。
- en: A graph with a path from each vertex to every other vertex is said to be *connected*.
    A connected graph without any cycles is called a *tree*. In a tree, any path is
    assumed to flow from upper nodes to lower nodes. Such a structure (where there
    are no cycles and there is only one way to get from one node to another) is known
    as a *directed acyclic graph (DAG)*. It’s possible to convert the graph above
    to a tree by removing some of its edges, as shown in [Figure 7-2](ch07.xhtml#ch7fig2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图，如果从每个顶点到其他所有顶点都有路径，则称为*连通图*。一个没有循环的连通图称为*树*。在树中，任何路径都假定从上层节点流向下层节点。这样的结构（没有循环，并且从一个节点到另一个节点只有一条路径）称为*有向无环图（DAG）*。通过移除一些边，可以将上面的图转换为树，如[图
    7-2](ch07.xhtml#ch7fig2)所示。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/07fig02.jpg)'
- en: '*Figure 7-2: Tree*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: 树*'
- en: If nodes *x* and *y* are connected in such a way that it’s possible to go from
    *x* to *y*, then *y* is said to be a *child node* of *x*. Nodes without child
    nodes (such as *a*, *c*, and *d*) are known as *terminal* (or *leaf*) nodes. Problems
    that have solutions modeled by a tree structure lend themselves to simpler search
    strategies since a tree doesn’t have circuits. Searching a graph with circuits
    requires keeping track of nodes already visited so that the same nodes aren’t
    re-explored.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点*x*和*y*以某种方式连接，使得从*x*到*y*是可能的，那么*y*被称为*x*的*子节点*。没有子节点的节点（如*a*、*c*和*d*）被称为*终端*（或*叶子*）节点。通过树结构建模并能得到解的问题通常采用更简单的搜索策略，因为树没有回路。搜索有回路的图需要跟踪已经访问过的节点，以避免重新探索相同的节点。
- en: It’s possible to label each edge of the graph with a numerical value called
    a *weight*, as shown in [Figure 7-3](ch07.xhtml#ch7fig3). This type of graph is
    called a *weighted graph*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为图的每一条边标记一个叫做*权重*的数值，如[图7-3](ch07.xhtml#ch7fig3)所示。这种类型的图叫做*加权图*。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Weighted graph*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：加权图*'
- en: If *e* is an edge, the weight of the edge is designated by *w*(*e*). Weights
    can be used to represent any number of measurements such as time, cost, or distance,
    which may affect the choice of edge when searching a graph.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*e*是一个边，那么该边的权重由*w*(*e*)表示。权重可以用来表示许多测量值，如时间、成本或距离，这些因素可能在搜索图时影响边的选择。
- en: 'A number of interesting questions arise when exploring the properties of graphs.
    One such question is this: “Given any two nodes, what’s the shortest path between
    them?” Another is the famous traveling salesman problem: “Given a list of cities
    and the distances between them, what’s the shortest possible route that visits
    each city exactly once and returns to the original city?” This last question,
    where each node is visited exactly once and returns to the original node, involves
    what is called a *Hamiltonian circuit*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索图的属性时，会提出许多有趣的问题。一个这样的问题是：“给定任意两个节点，如何找到它们之间的最短路径？”另一个问题是著名的旅行商问题：“给定一系列城市及其之间的距离，如何找到一条最短路径，能够访问每个城市一次，并返回到原始城市？”最后一个问题，其中每个节点被访问一次并返回到原始节点，涉及到所谓的*哈密顿回路*。
- en: '***Graph Search***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***图搜索***'
- en: 'There are two broad categories of strategies for searching graphs: *breadth-first
    search (BFS)* and *depth-first search (DFS)*. To illustrate these concepts, we’ll
    use the tree in [Figure 7-2](ch07.xhtml#ch7fig2).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索图的策略大致分为两类：*广度优先搜索（BFS）*和*深度优先搜索（DFS）*。为了说明这些概念，我们将使用[图7-2](ch07.xhtml#ch7fig2)中的树。
- en: '**Breadth-First Search**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**广度优先搜索**'
- en: 'Breadth-first search involves searching a graph by fully exploring each level
    (or depth) before moving on to the next level. In the tree diagram (shown in [Figure
    7-2](ch07.xhtml#ch7fig2)), the *e* (root) node is on the first level, nodes *b*
    and *d* are on the next level, and nodes *a* and *c* are on the third level. This
    typically involves using a queue to stage the nodes to be examined. The process
    begins by pushing the root node onto the queue, as shown in [Figure 7-4](ch07.xhtml#ch7fig4):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索涉及通过完全探索每个层级（或深度）后再进入下一个层级的方式来搜索图。在树状图中（如[图7-2](ch07.xhtml#ch7fig2)所示），*e*（根）节点位于第一层，节点*b*和*d*位于下一层，节点*a*和*c*位于第三层。这通常涉及使用队列来暂存待检查的节点。过程从将根节点推送到队列开始，如[图7-4](ch07.xhtml#ch7fig4)所示：
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig04.jpg)'
- en: '*Figure 7-4: A queue containing the root node*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：包含根节点的队列*'
- en: 'We then pop the first node in the queue (*e*) and test it to see if it’s a
    goal node; if not, we push its child nodes onto the queue, as shown in [Figure
    7-5](ch07.xhtml#ch7fig5):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们弹出队列中的第一个节点（*e*），并检查它是否是目标节点；如果不是，我们将其子节点推送到队列中，如[图7-5](ch07.xhtml#ch7fig5)所示：
- en: '![Image](../images/07fig05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig05.jpg)'
- en: '*Figure 7-5: The queue after node e was explored*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：节点e被探索后的队列*'
- en: 'Again we pop the first node in the queue (this time *b*) and test it to see
    if it’s a goal node; if not, we push its child nodes onto the queue, as shown
    in [Figure 7-6](ch07.xhtml#ch7fig6):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从队列中弹出第一个节点（这次是*b*），并检查它是否是目标节点；如果不是，我们将其子节点推送到队列中，如[图7-6](ch07.xhtml#ch7fig6)所示：
- en: '![Image](../images/07fig06.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig06.jpg)'
- en: '*Figure 7-6: The queue after node b was explored*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：节点b被探索后的队列*'
- en: We continue in this fashion until a goal node has been found, or the queue is
    empty, in which case there’s no solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续以这种方式进行，直到找到目标节点，或者队列为空，在这种情况下说明没有解。
- en: '**Depth-First Search**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**深度优先搜索**'
- en: Depth-first search works by continuing to walk down a branch of the tree until
    a goal node is found or a terminal node is reached. For example, starting at the
    root node of the tree, nodes *e*, *b*, and *a* would be examined in order. If
    none of those node are goal nodes, we back up to node *b* and examine its next
    child node, *c*. If *c* is also not a goal node, we back all the way up to *e*
    and examine its next child node, *d*. The *n*-queens problem in the next section
    provides a simple example of using depth-first search.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索通过不断沿树的一个分支走下去，直到找到目标节点或到达终端节点。例如，从树的根节点开始，依次检查节点*e*、*b*和*a*。如果这些节点都不是目标节点，我们回溯到节点*b*，并检查它的下一个子节点*c*。如果*c*也不是目标节点，我们回溯到节点*e*，并检查它的下一个子节点*d*。下一节的*n*-皇后问题提供了一个使用深度优先搜索的简单例子。
- en: The *N*-Queens Problem
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*N*皇后问题'
- en: 'The *n*-queens problem is a classic problem often used to illustrate depth-first
    search. The problem goes like this: position *n* queens on an *n*-by-*n* chess-board
    such that no queen is attacked by any other queen. In case you aren’t familiar
    with chess, a queen can attack any square on the same row, column, or diagonal
    that the queen lies on, as illustrated in [Figure 7-7](ch07.xhtml#ch7fig7).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*-皇后问题是一个经典问题，经常用来说明深度优先搜索。问题是这样的：在一个*n*乘*n*的棋盘上放置*n*个皇后，使得没有一个皇后会被其他皇后攻击。如果你不熟悉国际象棋，皇后可以攻击位于同一行、同一列或对角线上的任意格子，如[图
    7-7](ch07.xhtml#ch7fig7)所示。'
- en: '![Image](../images/07fig07.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig07.jpg)'
- en: '*Figure 7-7: A queen’s possible moves*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：皇后的可能移动*'
- en: The smallest value of *n* for which a solution exists is 4\. The two possible
    solutions are shown in [Figure 7-8](ch07.xhtml#ch7fig8).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存在解的最小*n*值是4。两个可能的解法如[图 7-8](ch07.xhtml#ch7fig8)所示。
- en: '![Image](../images/07fig08.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig08.jpg)'
- en: '*Figure 7-8: Solutions to the 4-queens problem*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：4皇后问题的解法*'
- en: One reason for the popularity of this problem is that the search graph is a
    tree, meaning that with a depth-first search, there’s no possibility that a state
    previously seen will be reached again (that is, once a queen is placed, it’s not
    possible to get to a state with fewer queens in subsequent steps). This avoids
    the annoying need to keep track of previous states to ensure they aren’t explored
    again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题受欢迎的一个原因是它的搜索图是树形的，这意味着通过深度优先搜索，不会再次到达之前已经见过的状态（也就是说，一旦皇后被放置，就无法在后续步骤中回到一个皇后更少的状态）。这避免了需要跟踪之前的状态，确保它们不会被重复探索的麻烦。
- en: A simple approach to this problem is to go column by column, testing each square
    in a column and continuing until a solution has been reached (backtracking as
    required). For example, if we begin with [Figure 7-9](ch07.xhtml#ch7fig9), we
    can’t place a queen at b1 or b2, because it would be attacked by the queen at
    a1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个简单方法是逐列检查，每次测试一列中的每个格子，直到找到解决方案（需要时进行回溯）。例如，如果我们从[图 7-9](ch07.xhtml#ch7fig9)开始，无法将皇后放置在b1或b2，因为它们会被a1位置的皇后攻击。
- en: '![Image](../images/07fig09.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig09.jpg)'
- en: '*Figure 7-9: First queen at a1*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：第一个皇后放置在a1*'
- en: 'The next available square that’s not attacked is b3, resulting in [Figure 7-10](ch07.xhtml#ch7fig10):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个未被攻击的格子是b3，结果如[图 7-10](ch07.xhtml#ch7fig10)所示：
- en: '![Image](../images/07fig10.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig10.jpg)'
- en: '*Figure 7-10: Second queen at b3*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：第二个皇后放置在b3*'
- en: 'But now when we get to column c, we’re stuck since every square in that column
    is attacked by one of the other queens. So we backtrack and move the queen in
    column b to b4 in [Figure 7-11](ch07.xhtml#ch7fig11):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在当我们到达c列时，卡住了，因为该列的每个格子都被其他皇后攻击了。所以我们回溯并将b列的皇后移到b4，见[图 7-11](ch07.xhtml#ch7fig11)：
- en: '![Image](../images/07fig11.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig11.jpg)'
- en: '*Figure 7-11: Second queen at b4*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：第二个皇后放置在b4*'
- en: 'So now we can place a queen on c2 in [Figure 7-12](ch07.xhtml#ch7fig12):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们可以在[图 7-12](ch07.xhtml#ch7fig12)中将皇后放置在c2：
- en: '![Image](../images/07fig12.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig12.jpg)'
- en: '*Figure 7-12: Third queen at c2*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：第三个皇后放置在c2*'
- en: Alas, now there’s no spot for a queen on column d. So we backtrack all the way
    to column a and start over in [Figure 7-13](ch07.xhtml#ch7fig13).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 唉，现在d列没有位置可以放置皇后了。所以我们回溯到a列，重新开始，如[图 7-13](ch07.xhtml#ch7fig13)所示。
- en: '![Image](../images/07fig13.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig13.jpg)'
- en: '*Figure 7-13: Backtrack to first queen at a2*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：回溯到第一个皇后位置a2*'
- en: The process continues in this manner until a solution is found.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程继续进行，直到找到解决方案。
- en: '***A Racket Solution***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个Racket解决方案***'
- en: 'We define the chessboard as an *n*-by-*n* array constructed from a mutable
    vector with *n* elements, each of which is also an *n*-element vector, where each
    element is either a 1 or a 0 (0 means the square is unoccupied; 1 means the square
    has a queen):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将棋盘定义为一个*n*乘*n*的数组，由一个包含*n*个元素的可变向量构成，每个元素也是一个包含*n*个元素的向量，其中每个元素是1或0（0表示该位置未被占据；1表示该位置有一个皇后）：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To allow accessing elements of the chessboard `cb` by a row (`r`) and column
    (`c`) number, we define the following accessor forms, where `v` is the value being
    set or retrieved.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过行（`r`）和列（`c`）编号访问棋盘`cb`的元素，我们定义了以下访问器形式，其中`v`是要设置或检索的值。
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we’re using a mutable data structure for the chessboard, we’ll need a
    mechanism to copy the board whenever a solution is found, to preserve the state
    of the board.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是一个可变的数据结构来表示棋盘，因此每当找到一个解时，我们需要一种机制来复制棋盘，以保持棋盘的状态。
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ll of course need to be able to see the solutions, so we provide a print
    procedure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要能够查看解，因此我们提供了一个打印过程：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The actual code to solve the problem, `dfs`, is a straightforward depth-first
    search. As solutions are found, they’re compiled into a list called `sols`, which
    is the return value of the function. In the code below, recall that in the `let
    loop` form, we’re employing a named `let` (which we described in [Chapter 3](ch03.xhtml))
    where we’re defining a function (`loop`) that we’ll call recursively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的实际代码`dfs`是一个简单的深度优先搜索。当解被找到时，它们会被编译成一个名为`sols`的列表，这是函数的返回值。在下面的代码中，回想一下，在`let
    loop`形式中，我们使用了一个命名的`let`（我们在[第3章](ch03.xhtml)中描述过），我们在其中定义了一个函数（`loop`），我们将递归调用它。
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code first tests each position to see whether the current cell is being
    attacked by any of the queens that have already been placed on the board ➊ (the
    code for `attacked` will be described shortly); if not, then that cell is marked
    as `valid`, and a queen (the number 1) is placed on that square ➋. Next we test
    whether the current square is in the final column of the board ➌; if it is, we’ve
    found a solution, so a copy of the board is placed in `sols` ➍. If we’re not on
    the last column, we then nest down to the next level (that is, the next column)
    ➎. Finally, the valid square is cleared ➏ so that additional rows in the column
    can be tested ➐. Once all the solutions have been found, they’re returned ➑.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先测试每个位置，看看当前单元格是否被已经放置的任何皇后攻击➊（`attacked`的代码稍后会描述）；如果没有，那么该单元格标记为`valid`，并在该位置放置一个皇后（数字1）➋。接下来，我们测试当前单元格是否位于棋盘的最后一列➌；如果是，那么我们找到了解，复制棋盘并将其放入`sols`
    ➍。如果我们不在最后一列，我们就继续进入下一层（即下一列）➎。最后，清除有效的单元格➏，以便可以测试列中的其他行➐。一旦所有解都被找到，它们会被返回➑。
- en: Where the DFS backtracking occurs in this process is a bit subtle. Suppose we’re
    at a position that is under attack by the previously placed queens, so `valid`
    ➊ is false and execution falls through ➐. Now suppose we’re also on the last row.
    In that case, the test fails ➐, so no further looping occurs and the recursive
    call returns. Either there are no following statements, in which case the entire
    loops exits, or there there additional statements to execute after returning from
    the recursive call. This can only occur where the current position is cleared
    and we’re at a previous location ➏. This is the backtrack point. Execution then
    resumes at the last `when` statement ➐.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，DFS回溯发生的位置有些微妙。假设我们处于一个被之前放置的皇后攻击的位置，因此`valid` ➊为假，执行会跳到➐。现在假设我们还在最后一行。在这种情况下，测试失败➐，因此不会再进行循环，递归调用返回。要么没有后续语句，在这种情况下整个循环退出，要么在从递归调用返回后有额外的语句需要执行。这只能在当前位置被清除且我们回到先前的位置➏时发生。这就是回溯点。然后，执行会在最后的`when`语句➐处恢复。
- en: The following function tests whether a square is under attack by any of the
    previously placed queens. It only checks the columns prior to the current column
    since the other columns of the chessboard haven’t yet been populated.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数测试一个位置是否受到任何已经放置的皇后的攻击。它仅检查当前列之前的列，因为棋盘的其他列尚未填充。
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To output the solutions, we define a simple routine to iterate through and print
    each solution returned by `dfs`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了输出解，我们定义了一个简单的例程来迭代并打印`dfs`返回的每一个解。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here are a couple of test runs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是几个测试运行。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dijkstra’s Shortest Path Algorithm
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dijkstra的最短路径算法
- en: Given a graph with a node designated as the start node, Edsger Dijkstra’s algorithm
    finds the shortest path to any other node. The algorithm works by first assigning
    all the nodes (except the start node, which has distance zero) an infinite distance.
    As the algorithm progresses, the node distances are refined until their true distance
    can be determined.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图，其中一个节点被指定为起始节点，Edsger Dijkstra 的算法用于找到到其他任何节点的最短路径。该算法首先将所有节点（除了起始节点，它的距离为零）赋予无穷大的距离值。随着算法的进行，节点的距离会逐步调整，直到能够确定其真实距离。
- en: We’ll use the weighted graph introduced in [Figure 7-3](ch07.xhtml#ch7fig3)
    earlier to illustrate Dijkstra’s algorithm (where *S* is the starting node). The
    algorithm we describe will employ something called a priority queue. A *priority
    queue* is similar to a regular queue, but in a priority queue, each item has an
    associated value, called its priority, that controls its order in the queue. Instead
    of following a first-in, first-out sequence, items with a higher priority are
    ordered ahead of other items. Since we’re interested in finding the shortest path,
    shorter distances will be given a higher priority than longer ones.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[图 7-3](ch07.xhtml#ch7fig3)中介绍的加权图来说明 Dijkstra 算法（其中 *S* 是起始节点）。我们描述的算法将使用一种名为优先队列的数据结构。*优先队列*类似于常规队列，但在优先队列中，每个项都有一个关联值，称为优先级，这决定了它在队列中的顺序。与普通队列的先进先出顺序不同，优先级较高的项将排在其他项之前。由于我们关心的是找到最短路径，因此较短的距离将被赋予比较长的距离更高的优先级。
- en: The following diagram in [Figure 7-14](ch07.xhtml#ch7fig14) illustrates the
    starting conditions of the algorithm.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-14](ch07.xhtml#ch7fig14)中的下图展示了算法的起始条件。'
- en: '![Image](../images/07fig14.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig14.jpg)'
- en: '*Figure 7-14: Starting conditions for finding the shortest paths from S*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：从 S 找到最短路径的起始条件*'
- en: Node distances from the start node are given just outside the node circle. Nodes
    that haven’t been visited are assigned a tentative distance value of infinity
    (except for the start node, which has a value of zero). The queue shows the nodes
    with distance values indicated by exponents.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从起始节点到各节点的距离值显示在节点圆圈外面。尚未访问的节点被赋予无穷大的暂定距离值（起始节点的距离值为零）。队列中显示的是带有距离值的节点，距离值由指数表示。
- en: The first step is to pop the first node in the queue (which will always have
    a known distance) and color it with a light background as shown here in [Figure
    7-15](ch07.xhtml#ch7fig15). Set this node as the current node, *u* (in this case
    *u* = *S* with a distance value of zero).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从队列中弹出第一个节点（该节点将始终具有已知的距离），并将其以浅色背景标记，如[图 7-15](ch07.xhtml#ch7fig15)所示。将此节点设置为当前节点，*u*（在这种情况下，*u*
    = *S*，距离值为零）。
- en: '![Image](../images/07fig15.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig15.jpg)'
- en: '*Figure 7-15: Step 1 of Dijkstra’s algorithm*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：Dijkstra 算法的步骤 1*'
- en: 'The neighbors of *u* are given in a darker color. We then perform the following
    tentative distance calculation, *t*, for each neighbor (designated *v*) of *u*
    that’s still in the queue, where *d*(*u*) is the known distance from the start
    node to *u*, and *l*(*u*, *v*) is the distance value of the edge from *u* to *v*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*u* 的邻居节点用更深的颜色标记。然后，我们对队列中仍然存在的每个 *u* 的邻居（标记为 *v*）执行以下的暂定距离计算 *t*，其中 *d*(*u*)
    是从起始节点到 *u* 的已知距离，*l*(*u*, *v*) 是从 *u* 到 *v* 的边的距离值：'
- en: '![Image](../images/07eqa01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa01.jpg)'
- en: If *t* is less than the prior distance value (initially *∞*), the queue is updated
    with the new node distance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *t* 小于先前的距离值（最初为 *∞*），则队列会更新为新的节点距离。
- en: 'With the queue updated, we repeat the process, this time popping *c* off the
    queue, making it the current node (in other words, *u* = *c*), and updating the
    queue and neighbor distances as before. The state of the graph is then as follows
    in [Figure 7-16](ch07.xhtml#ch7fig16):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列更新后，我们重复这个过程，这次将 *c* 从队列中弹出，使其成为当前节点（换句话说，*u* = *c*），并像之前一样更新队列和邻居节点的距离。此时图的状态如[图
    7-16](ch07.xhtml#ch7fig16)所示：
- en: '![Image](../images/07fig16.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig16.jpg)'
- en: '*Figure 7-16: Step 2 of Dijkstra’s algorithm*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-16：Dijkstra 算法的步骤 2*'
- en: We show the path from *S* to *c* in a thicker gray line to indicate a known
    shortest path in [Figure 7-16](ch07.xhtml#ch7fig16). The sequence of diagrams
    in [Figure 7-17](ch07.xhtml#ch7fig17) illustrates the remainder of the process.
    Notice that in [Figure 7-17](ch07.xhtml#ch7fig17)a the original distance of node
    *a* has been updated from 12 to 9 based on the path now being from *S* through
    *b* to *a*. The thick lines in 7-17d, the final graph, form a tree structure reflecting
    all the shortest paths originating from node *S* to the remaining nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一条较粗的灰线显示从 *S* 到 *c* 的路径，以表示在[图 7-16](ch07.xhtml#ch7fig16)中已知的最短路径。[图 7-17](ch07.xhtml#ch7fig17)中的一系列图示展示了其余的过程。请注意，在[图
    7-17](ch07.xhtml#ch7fig17)a中，节点 *a* 的原始距离已从 12 更新为 9，原因是当前路径是从 *S* 通过 *b* 到 *a*。在
    7-17d 中，最终图中粗线条所形成的树形结构反映了所有从节点 *S* 出发到其余节点的最短路径。
- en: '![Image](../images/07fig17.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig17.jpg)'
- en: '*Figure 7-17: The rest of Dijkstra’s algorithm*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：Dijkstra 算法的其余部分*'
- en: We’re usually interested in how efficiently an algorithm performs. This is generally
    specified by a *complexity* value. There are a number of ways this can be done,
    but a popular formulation is called *Big O notation* (the O stands for “order
    of"). This notation aims to give a gross approximation of how efficiently an algorithm
    performs (in terms of running time or memory usage) based on the size of its inputs.
    Dijkstra’s algorithm has a running time complexity of *O*(*N*²), where *N* is
    the number of nodes in the graph. This means the running time increases as the
    square of the number of inputs. In other words, if we double the number of nodes,
    the algorithm will take about four times as long to run. This is taken to be an
    upper-bound or worst-case scenario, and depending on the nature of the graph,
    the runtime could be less.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常关心的是算法的执行效率。这通常通过一个*复杂度*值来指定。有很多种方式可以做到这一点，但一种常见的表述方式叫做*大 O 符号*（O 代表“阶”（Order））。这种符号旨在给出算法执行效率的粗略估算（在运行时间或内存使用方面），并且基于输入的规模。Dijkstra
    算法的运行时间复杂度是 *O*(*N*²)，其中 *N* 是图中节点的数量。这意味着运行时间随着输入数量的平方增长。换句话说，如果我们将节点数加倍，算法的运行时间大约会变为原来的四倍。这被视为一个上界或最坏情况，并且根据图的性质，运行时间可能会更少。
- en: '***The Priority Queue***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***优先队列***'
- en: As we’ve seen in the analysis above, a priority queue plays a key role in Dijkstra’s
    algorithm. Priority queues can be implemented in a number of ways, but one popular
    approach is to use something called a binary heap. A *binary heap* is a binary
    tree structure (meaning each node has a maximum of two children) where each node’s
    value is greater than or equal to its child nodes. This type of heap is called
    a *max-heap*. It’s also possible for each parent node to be less than or equal
    to its child nodes. This type of heap is called a *min-heap*. An example of such
    a heap is shown in [Figure 7-18](ch07.xhtml#ch7fig18). The top or root node is
    always the first to be removed since it’s considered to have the highest priority.
    After nodes are added to or removed from the heap, the remaining nodes are rearranged
    to maintain the proper priority order. While it’s not terribly difficult to build
    a binary heap object, Racket already has one available in the *data/heap* library.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上面的分析中所看到的，优先队列在 Dijkstra 算法中起着关键作用。优先队列可以通过多种方式实现，但一种流行的方法是使用称为二叉堆的结构。*二叉堆*是一种二叉树结构（意味着每个节点最多有两个子节点），其中每个节点的值大于或等于其子节点的值。这种类型的堆叫做*最大堆*。也可以让每个父节点小于或等于其子节点的值，这种类型的堆叫做*最小堆*。这种堆的示例如[图
    7-18](ch07.xhtml#ch7fig18)所示。根节点或顶部节点总是第一个被移除，因为它被认为具有最高优先级。在向堆中添加或移除节点后，剩余的节点会重新排列以维持正确的优先顺序。虽然构建二叉堆对象并不是特别困难，但
    Racket 中已经有一个可用的二叉堆，它在 *data/heap* 库中。
- en: '![Image](../images/07fig18.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig18.jpg)'
- en: '*Figure 7-18: Min-heap*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：最小堆*'
- en: 'Our heap entries won’t be just numbers: we’ll need to track the node and its
    current distance value (which determines its priority). So each heap entry will
    consist of a pair where the first element is the node and the second element is
    the current distance. When a Racket heap is constructed, it must be supplied with
    a function that will do the proper comparison when given two node entries. We
    accomplish this with the following code. The `comp` function only compares the
    second element of each pair since that’s what determines the priority.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的堆条目不仅仅是数字：我们需要跟踪节点及其当前的距离值（这决定了它的优先级）。因此，每个堆条目将由一对元素组成，其中第一个元素是节点，第二个元素是当前距离。当构建一个Racket堆时，必须提供一个函数，用来在给定两个节点条目时执行正确的比较。我们通过以下代码来实现这一点。`comp`函数只比较每对中的第二个元素，因为那才是决定优先级的关键。
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To save a bit of typing, we create a few simple helper functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少一些输入工作，我们创建了几个简单的辅助函数。
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `update-priority` procedure takes a symbol and a new priority to update
    the queue. It does this by removing (dequeuing) the old value and adding (enqueuing)
    a new value. The `heap-remove!` function performs very efficiently, but it needs
    the exact value (pair with symbol and priority) to work. Unfortunately, without
    knowing the priority, we have to resort to a linear search through the entire
    queue to find the symbol via the `in-heap` sequence. This can be optimized by
    storing (in another data structure like a hash table) the symbol and current priority.
    We leave it to the reader to perform this added step if desired.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`update-priority`过程接受一个符号和一个新的优先级来更新队列。它通过删除（出队）旧值并添加（入队）新值来完成此操作。`heap-remove!`函数的执行非常高效，但它需要确切的值（符号和优先级的配对）才能工作。不幸的是，在不知道优先级的情况下，我们必须通过`in-heap`序列进行线性搜索，查找符号。这可以通过将符号和当前优先级存储在另一种数据结构中（如哈希表）来优化。如果读者愿意，可以进行这个附加步骤。'
- en: Here are some examples of the priority queue in action.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优先队列实际操作的一些示例。
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Regardless of the order the values were added to the queue, they’re stored and
    removed in priority order.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无论值添加到队列的顺序如何，它们都会按优先级顺序存储和移除。
- en: '***The Implementation***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现***'
- en: We define our graph as a list of edges. Each edge in the list consists of the
    end nodes along with the distance between nodes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图定义为一个边的列表。列表中的每条边由端节点和节点之间的距离组成。
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we progress through the algorithm, we want to to keep track of the current
    parent of each node so that when the algorithm completes, we’ll be able to reproduce
    the shortest path to each node. A hash table will be used to maintain this information.
    The key is a node name and the value is the name of the parent node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 随着算法的推进，我们希望跟踪每个节点的当前父节点，以便算法完成后，我们能够重现到达每个节点的最短路径。一个哈希表将用于维护这些信息。键是节点名，值是父节点的名称。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need to take care in our coding to be mindful of the fact that our graph
    is bi-directional, and an edge defined by (*a*, *b*) is equivalent to one defined
    by (*b*, *a*). We’ll account for this by supplementing the original edge list
    with a list consisting of the nodes reversed. We’ll also use a hash table (`lengths`)
    to maintain the lengths of each edge and an additional hash table (`dist`) to
    record the shortest distance to each node as it’s discovered. To pull all this
    together, we define `init-graph`, which takes an edge list and returns the original
    list appended with the swapped node list. It will also be used to initialize the
    priority queue and the various hash tables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编码时需要小心，牢记我们的图是双向的，一个由(*a*, *b*)定义的边与由(*b*, *a*)定义的边是等价的。我们通过补充原始边列表，加入一个由反向节点构成的列表来考虑这一点。我们还将使用一个哈希表（`lengths`）来维护每条边的长度，并使用另一个哈希表（`dist`）来记录到达每个节点的最短距离，一旦发现该节点。为了整合这些内容，我们定义了`init-graph`，它接受一个边列表并返回一个附加了反向节点列表的原始列表。它还将用于初始化优先队列和各个哈希表。
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here’s the code, `dijkstra`, that actually computes the shortest paths for each
    node.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际计算每个节点最短路径的代码，`dijkstra`。
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `dijkstra` code takes the starting node symbol and edge list as arguments.
    It then defines `graph`, which is the original list of edges appended with a list
    of the edges with the nodes swapped. As mentioned, the `init-graph` procedure
    also initializes all the other data structures required for the algorithm to work.
    A local `neighbors` function is defined ➊ that takes a node and returns the list
    of nodes that are adjacent to the node and still in the queue. The main loop starts
    ➋ and the first step is to pop the first node in the queue and assign its symbol
    to `u`. Next, each of its neighbors (`v`) is processed ➌. For each neighbor, we
    compute *t* = *d*(*u*) + *l*(*u*, *v*) ➍ (recall that *d*(*u*) is the most current
    distance estimate from the start symbol to *u*, and *l*(*u*, *v*) is the length
    of the edge from *u* to *v*). We then test whether *t* < *d*(*v*) ➎, and if it
    passes the test, we do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`dijkstra` 代码将起始节点符号和边列表作为参数。接着，它定义了 `graph`，这是原始的边列表，并附加了一个节点交换后的边列表。如前所述，`init-graph`
    程序还初始化了算法所需的所有其他数据结构。定义了一个局部的 `neighbors` 函数 ➊，它接受一个节点并返回与该节点相邻且仍在队列中的节点列表。主循环开始
    ➋，第一步是弹出队列中的第一个节点，并将其符号赋值给 `u`。接着，处理它的每一个邻居（`v`） ➌。对于每个邻居，我们计算 *t* = *d*(*u*)
    + *l*(*u*, *v*) ➍（回想一下，*d*(*u*) 是从起始符号到 *u* 的当前最短距离估计，*l*(*u*, *v*) 是从 *u* 到 *v*
    的边长）。然后我们测试是否 *t* < *d*(*v*) ➎，如果通过测试，我们执行以下操作：'
- en: Assign *d*(*v*) = *t* ➏.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *d*(*v*) = *t* ➏。
- en: Assign *u* as the parent of *v* ➐.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *u* 作为 *v* 的父节点 ➐。
- en: Update the queue with *t* as the new priority of *v* ➑.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新队列，将 *t* 作为 *v* 的新优先级 ➑。
- en: 'Finally, we test whether any values remain on the heap, and if so, repeat the
    process ➒. Once the algorithm completes, `parent` will contain the parent of each
    node. All that remains is to chase the chain of parents to the start symbol to
    determine the shortest path to the node. This is done by the following `get-path`
    function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试堆中是否还剩值，如果有，则重复该过程 ➒。当算法完成时，`parent` 将包含每个节点的父节点。剩下的就是追踪父节点链到起始符号，以确定到该节点的最短路径。这是通过以下的
    `get-path` 函数完成的：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `show-paths` procedure will print out paths for all the nodes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`show-paths` 程序将打印出所有节点的路径。'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For convenience we define `solve`, which takes a starting symbol and edge list,
    calls `dijkstra` to compute the shortest paths, and prints out the shortest path
    to each node.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们定义了 `solve`，它接收一个起始符号和边列表，调用 `dijkstra` 计算最短路径，并打印出到每个节点的最短路径。
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Given our original graph where we defined the edges in `edge-list` above, and
    starting symbol `S`, we generate the solutions as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们在 `edge-list` 中定义的原始图以及起始符号 `S`，我们生成解决方案如下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s try this slightly more ambitious example in [Figure 7-19](ch07.xhtml#ch7fig19)
    (see [**4**]).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在[图 7-19](ch07.xhtml#ch7fig19)中展示的这个稍微更有挑战性的示例（参见 [**4**]）。
- en: '![Image](../images/07fig19.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig19.jpg)'
- en: '*Figure 7-19: Another graph to test Dijkstra’s algorithm on*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-19: 测试 Dijkstra 算法的另一个图*'
- en: The edge list for this graph is . . .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图的边列表是 . . .
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, solving for the shortest path, we have . . .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，求解最短路径时，我们得到了 . . .
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve highlighted the tree of shortest paths in the resulting graph (see [Figure
    7-20](ch07.xhtml#ch7fig20)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在结果图中突出显示了最短路径树（参见 [图 7-20](ch07.xhtml#ch7fig20)）。
- en: '![Image](../images/07fig20.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig20.jpg)'
- en: '*Figure 7-20: Shortest paths found*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-20: 找到的最短路径*'
- en: Now that we’ve thoroughly examined Dijkstra’s shortest-path algorithm, we’ll
    next take a look at the A* algorithm via Sam Loyd’s (in)famous 14–15 puzzle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经彻底研究了 Dijkstra 最短路径算法，接下来我们将通过 Sam Loyd 的（不）著名的 14–15 拼图来看看 A* 算法。
- en: The 15 Puzzle
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15拼图
- en: The 15 puzzle consists of 15 sequentially numbered sliding tiles in a square
    frame that are randomly scrambled, with the goal of getting them back into their
    proper numerical sequence. In the late 1800’s Sam Loyd created a bit of buzz over
    this puzzle by offering a $1,000 prize for anyone who could demonstrate a way
    to start with a puzzle with all the tiles in order, except with the 14 and 15
    tiles reversed (as shown in [Figure 7-21](ch07.xhtml#ch7fig21), Loyd called this
    arrangement the “14-15 Puzzle”), and get them back in their proper order (without
    removing the tiles from the case, of course). As we’ll see shortly, this is mathematically
    impossible, so Loyd knew his money was safe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 15拼图由15个按顺序编号的滑动拼图块组成，这些拼图块随机打乱，目标是将它们恢复到正确的数字顺序。在19世纪末，Sam Loyd通过提供1000美元奖金，引起了人们对这个拼图的关注，奖金将奖励任何能够展示从一个已按顺序排列的拼图开始，只是14和15拼图块反转（如[图7-21](ch07.xhtml#ch7fig21)所示，Loyd将这种排列称为“14-15拼图”），并能将其恢复到正确顺序的人（当然不允许将拼图块从框架中取出）。正如我们将很快看到的那样，这是数学上不可能的，因此Loyd知道他的赌注是安全的。
- en: '![Image](../images/07fig21.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig21.jpg)'
- en: '*Figure 7-21: Sam Loyd’s 14–15 puzzle illustration*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-21：Sam Loyd的14-15拼图插图*'
- en: '**Why Swapping Just Two Tiles Is Impossible**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为什么只交换两个拼图块是不可能的**'
- en: To get an idea of why Loyd’s money was safe (that is, why it’s not possible
    to exchange two and only two tiles), consider the puzzle in its solved state as
    shown in [Figure 7-22](ch07.xhtml#ch7fig22).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么Loyd的钱是安全的（即为什么不可能只交换两个且仅仅交换两个拼图块），可以考虑[图7-22](ch07.xhtml#ch7fig22)所示的已解状态下的拼图。
- en: '![Image](../images/07fig22.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig22.jpg)'
- en: '*Figure 7-22: Solved 15 puzzle*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-22：已解的15拼图*'
- en: Any sequence of moves that would reverse the 14 and 15 tiles would produce the
    arrangement in Loyd’s puzzle. Simply reproducing this sequence would get the tiles
    back in order. We’ll see that this is impossible. Now consider the arrangement
    in [Figure 7-23](ch07.xhtml#ch7fig23).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 任何能够交换14和15拼图块的移动序列都会得到Loyd拼图中的排列。仅仅重复这个序列就能将拼图块恢复到正确顺序。我们将看到这实际上是不可能的。现在考虑[图7-23](ch07.xhtml#ch7fig23)中的排列。
- en: '![Image](../images/07fig23.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig23.jpg)'
- en: '*Figure 7-23: 15 puzzle with inversions*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-23：带有逆序的15拼图*'
- en: If we arrange these tiles linearly, we have 2, 3, 1, 4, 5, 6, . . . In particular,
    the values of tile-2 and tile-3 are larger than tile-1, which follows them. Each
    such situation, where the value of a tile is larger than one that follows it,
    is called an *inversion* (two inversions in this case).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些拼图块按顺序排列，得到2, 3, 1, 4, 5, 6，……特别地，拼图块2和拼图块3的值大于其后面的拼图块1。每当一个拼图块的值大于紧随其后的拼图块时，这种情况称为*逆序*（此情况下有两个逆序）。
- en: Related to the idea of inversion is that of *transposition*. A transposition
    is simply the exchange of two values in a sequence. A given arrangement can be
    arrived at by any number of transpositions. For example, one way to get to the
    sequence 2, 3, 1, 4, 5, 6, . . . would be as follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与逆序的概念相关的是*换位*的概念。换位只是序列中两个值的交换。通过任意次数的换位，可以得到某一排列。例如，得到序列2, 3, 1, 4, 5, 6，……的一种方式如下：
- en: 'Starting arrangement: 1, 2, 3, 4, 5, 6, . . .'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始排列：1, 2, 3, 4, 5, 6，……
- en: 'Transpose 1 and 3: 3, 2, 1, 4, 5, 6, . . .'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 换位1和3：3, 2, 1, 4, 5, 6，……
- en: 'Transpose 2 and 3: 2, 3, 1, 4, 5, 6, . . .'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 换位2和3：2, 3, 1, 4, 5, 6，……
- en: The key idea is that an arrangement consisting of an even number of inversions
    will always be generated by an even number of transpositions, and an arrangement
    with an odd number of inversions will always be generated by an odd number of
    transpositions. For reference purposes, the empty slot will be treated as a tile
    and designated with the number 16\. Any single movement by tile-16 is a transposition.
    If tile-16 leaves from the lower right corner and arrives at a particular spot
    using an odd number of transpositions, it will require an odd number of transpositions
    to get back to the starting location, or a net even number of transpositions.
    This leaves the puzzle with an even number of inversions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的思想是，包含偶数个逆序的排列总是通过偶数次换位产生的，而包含奇数个逆序的排列总是通过奇数次换位产生的。为了参考，空白位置将视为一个拼图块，并用数字16标示。任何拼图块16的单次移动都是一次换位。如果拼图块16从右下角离开并经过奇数次换位到达某个位置，则需要奇数次换位才能回到起始位置，或者净换位次数为偶数次。这样，拼图就会有偶数个逆序。
- en: The arrangement Sam Loyd proposes is impossible to solve since it involves a
    single odd inversion. It’s also true, but trickier to prove, that any puzzle with
    an even number of inversions is solvable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 萨姆·洛伊德提出的排列是无法解决的，因为它涉及一个单一的奇数逆序。虽然证明起来更为复杂，但也可以证明，任何具有偶数逆序的谜题都是可以解决的。
- en: Having resolved this historical issue with Sam Loyd’s puzzle, we now turn our
    attention to finding solutions for puzzles that are in fact solvable. In this
    regard we’ll now explore the A* search algorithm (we mostly abbreviate this to
    simply the “A* algorithm” hereafter).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个历史性问题——萨姆·洛伊德的难题后，我们现在将注意力转向那些实际上可以解决的谜题。在这方面，我们将探索 A* 搜索算法（我们以后通常简称为“A*算法”）。
- en: '***The A* Search Algorithm***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***A* 搜索算法***'
- en: We’ll of course assume that the computer is presented with a solvable puzzle
    (that is, it has an even number of inversions). The computer should provide a
    solution that’s as efficient as possible—that is, a solution that requires the
    smallest number of moves to get to the goal state. One method that generally provides
    good results is called the *A* search* algorithm. An advantage of the A* algorithm
    over a simple breadth-first or depth-first search is that it uses a *heuristic*^([1](footnote.xhtml#ch07foot_1))
    to reduce the search space. It does this by computing an *estimated* cost of taking
    any given branch in the search tree. It iteratively improves this estimate until
    it determines the best solution or it determines no solution can be found. Estimates
    are stored in a priority queue where the least cost state is at the head of the
    list.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然假设计算机提供的是一个可解的谜题（即它有偶数个逆序对）。计算机应提供一个尽可能高效的解决方案——也就是说，提供一个达到目标状态所需最少步数的解决方案。一种通常能提供良好结果的方法被称为
    *A* 搜索算法。与简单的广度优先或深度优先搜索相比，A*算法的一个优势是，它使用一个 *启发式*^([1](footnote.xhtml#ch07foot_1))
    来减少搜索空间。它通过计算搜索树中任意给定分支的 *估算* 成本来实现这一点。它反复改进这一估算，直到确定最佳解决方案或确定无法找到解决方案为止。估算值存储在一个优先队列中，其中最小成本状态位于队列的头部。
- en: We’ll begin our analysis by looking at a smaller variant of the 15 puzzle, called
    the 8 puzzle. The 8 puzzle in its solved state is shown in [Figure 7-24](ch07.xhtml#ch7fig24).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看 15 数字拼图的一个较小变体——8 数字拼图来开始我们的分析。8 数字拼图在其已解决状态下如 [图 7-24](ch07.xhtml#ch7fig24)
    所示。
- en: '![Image](../images/07fig24.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig24.jpg)'
- en: '*Figure 7-24: Solved 8 puzzle*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-24：已解决的 8 数字拼图*'
- en: The search tree of the 8 puzzle can be modeled as shown in [Figure 7-25](ch07.xhtml#ch7fig25),
    where each node of the tree is a state of the puzzle, and the child nodes are
    the possible states that can arise from a valid move.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 8 数字拼图的搜索树可以如 [图 7-25](ch07.xhtml#ch7fig25) 所示进行建模，其中树的每个节点代表拼图的一个状态，而子节点则是由有效移动产生的可能状态。
- en: '![Image](../images/07fig25.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig25.jpg)'
- en: '*Figure 7-25: Partial 8 puzzle game tree*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-25：部分 8 数字拼图游戏树*'
- en: 'At each iteration of the A* algorithm, it computes an estimate of the cost
    (that is, the number of moves) to get to the goal state. Formally, it attempts
    to minimize the following estimated cost function, where *n* is the node under
    consideration, *g*(*n*) is the cost of the path from the start node to *n*, and
    *h*(*n*) is a heuristic that estimates the cost of the cheapest path from *n*
    to the goal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次 A* 算法迭代中，它都会计算从当前状态到目标状态的成本估算（即所需步数）。形式上，它试图最小化以下估算成本函数，其中 *n* 是正在考虑的节点，*g*(*n*)
    是从起始节点到 *n* 的路径成本，*h*(*n*) 是估算从 *n* 到目标的最便宜路径的启发式：
- en: '*f(n)* = *g(n)* + *h(n)*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(n)* = *g(n)* + *h(n)*'
- en: 'Designing a good heuristic function is something of an art. To get the best
    performance from the A* algorithm, an important characteristic of the heuristic
    is that it satisfies the following condition for every edge in the graph, where
    *h*^*(*n*) is the actual (but unknown) cost to reach the goal state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个好的启发式函数有些像是一门艺术。为了从 A* 算法中获得最佳性能，启发式的一个重要特性是，它满足图中每条边的以下条件，其中 *h*^*(*n*)
    是到达目标状态的实际（但未知的）成本：
- en: '![Image](../images/07eqa02.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa02.jpg)'
- en: If a heuristic meets this condition, it’s said to be *admissible*, and the A*
    algorithm is guaranteed to find the optimal solution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个启发式满足此条件，则称其为 *可接纳的*，并且 A* 算法可以保证找到最优解。
- en: One possible heuristic for the 8 puzzle uses something called the *Manhattan
    distance* (as opposed to the familiar straight-line distance). For example, to
    get the tile-2 in [Figure 7-25](ch07.xhtml#ch7fig25) to its home location (the
    cell it would occupy in the solved state), the tile would have to move up two
    squares and one square to the left for a total of three moves—this is the Manhattan
    distance. The heuristic value for a puzzle state would be the sum of the Manhattan
    distances for each tile. [Table 7-1](ch07.xhtml#ch7tab1) shows the computation
    of this value for the root node of [Figure 7-25](ch07.xhtml#ch7fig25).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的启发式方法是使用名为*曼哈顿距离*的计算方法（与常见的直线距离不同）。例如，要将[图 7-25](ch07.xhtml#ch7fig25)中的瓦片-2移到它的目标位置（即它在已解决状态中应占据的单元格），该瓦片需要先上移两格，再左移一格，总共需要三次移动——这就是曼哈顿距离。拼图状态的启发式值将是每个瓦片的曼哈顿距离之和。[表
    7-1](ch07.xhtml#ch7tab1)展示了[图 7-25](ch07.xhtml#ch7fig25)根节点的这一值的计算。
- en: '**Table 7-1**: Computing Manhattan Distance'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1**：计算曼哈顿距离'
- en: '| **Tile** | **Rows** | **Cols.** | **Total** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **瓦片** | **行** | **列** | **总计** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 0 | 1 | 1 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 |'
- en: '| 2 | 2 | 1 | 3 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 1 | 3 |'
- en: '| 3 | 1 | 1 | 2 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 1 | 2 |'
- en: '| 4 | 1 | 0 | 1 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 | 0 | 1 |'
- en: '| 5 | 0 | 1 | 1 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0 | 1 | 1 |'
- en: '| 6 | 1 | 0 | 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1 | 0 | 1 |'
- en: '| 7 | 1 | 2 | 3 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1 | 2 | 3 |'
- en: '| 8 | 2 | 1 | 3 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2 | 1 | 3 |'
- en: '| Distance: | 15 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 距离： | 15 |'
- en: The Manhattan distance will always be less than or equal to the actual number
    of moves, so it satisfies the admissibility condition.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离始终小于或等于实际的移动次数，因此它满足可接受性条件。
- en: 'A slightly weaker heuristic is the *Hamming distance*, which is just the number
    of misplaced tiles. The Hamming distance for the puzzle shown in [Figure 7-25](ch07.xhtml#ch7fig25)
    is eight: none of the tiles are in their home location.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍弱的启发式是*汉明距离*，即错位瓦片的数量。[图 7-25](ch07.xhtml#ch7fig25)中显示的拼图的汉明距离是八：所有瓦片都没有放在它们的目标位置。
- en: In [Figure 7-26](ch07.xhtml#ch7fig26) we’ve annotated each node with three values.
    The first value is the depth of the game tree (this value is incremented by one
    for each level and constitutes the value of *g*(*n*) in the cost formula), the
    second value is the heuristic value, *h*(*n*), for the node (the Manhattan distance
    in this case), and the third value is the sum of the two giving the overall cost
    score for the node.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-26](ch07.xhtml#ch7fig26)中，我们为每个节点标注了三个值。第一个值是游戏树的深度（该值每经过一层递增1，并构成成本公式中*g*(*n*)的值），第二个值是启发式值，*h*(*n*)，即节点的启发式值（在此案例中为曼哈顿距离），第三个值是前两个值之和，表示节点的整体成本分数。
- en: '![Image](../images/07fig26.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig26.jpg)'
- en: '*Figure 7-26: 8 puzzle with node costs*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-26：带有节点成本的8拼图*'
- en: The A* algorithm uses a priority queue called *open*. This queue orders the
    puzzle states that have been examined but whose child nodes have not been expanded,
    according to the estimated cost to reach the goal. The algorithm also relies on
    a dictionary, called *closed*, that uses the puzzle state as a key and maintains
    the most recent cost value for the node. [Figure 7-27](ch07.xhtml#ch7fig27) reflects
    the current state of the analysis, where the first node in the open queue is the
    root node of [Figure 7-26](ch07.xhtml#ch7fig26).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法使用一个名为*open*的优先队列。这个队列根据估计的到达目标的成本，对已检查但其子节点尚未扩展的拼图状态进行排序。该算法还依赖于一个名为*closed*的字典，该字典将拼图状态作为键，并维护该节点的最新成本值。[图
    7-27](ch07.xhtml#ch7fig27)反映了当前分析的状态，其中open队列中的第一个节点是[图 7-26](ch07.xhtml#ch7fig26)的根节点。
- en: '![Image](../images/07fig27.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig27.jpg)'
- en: '*Figure 7-27: Closed and open*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-27：已关闭和打开的节点*'
- en: The values shown at the top of the closed nodes are the latest estimated costs.
    The values at the top of the open nodes are the same three cost values described
    above. With this introduction we walk through an iteration of how the A* algorithm
    processes the game tree.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 已关闭节点顶部显示的值是最新的估计成本。打开节点顶部显示的值是上面描述的三个成本值。通过这一介绍，我们将一步步演示A*算法如何处理游戏树。
- en: The first step is to pop the lowest-priority value off the open queue. This
    node is then added to the closed dictionary. The next step is to compute the costs
    for the child nodes, which are shown on the second level of [Figure 7-26](ch07.xhtml#ch7fig26).
    If any of these nodes are not on the closed list, they are simply queued to open
    with no further analysis. Notice that the first child node *is* on the closed
    list. Since its current estimated cost is less than the cost on the closed list,
    it’s removed from the closed list and the node is added back to the queue with
    its new value. In the situation where a child node is on the closed list, but
    its estimated value is *larger* than the value on the closed list, no change is
    made, and it’s not added to the queue. Once this phase is complete, the open and
    closed structures will appear as shown in [Figure 7-28](ch07.xhtml#ch7fig28).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从开放队列中弹出优先级最低的值。然后，该节点被添加到闭合字典中。下一步是计算子节点的成本，这些节点显示在[图 7-26](ch07.xhtml#ch7fig26)的第二层。如果这些节点中有任何一个不在闭合列表中，它们将直接加入到开放队列中，不需要进一步分析。注意，第一个子节点*已经*在闭合列表中。由于其当前的估计成本低于闭合列表中的成本，它被从闭合列表中移除，并以新的值重新加入队列。如果子节点已经在闭合列表中，但其估计值*大于*闭合列表中的值，则不做任何更改，也不将其添加到队列中。完成此阶段后，开放和闭合结构将如[图
    7-28](ch07.xhtml#ch7fig28)所示。
- en: Since the first child node in [Figure 7-26](ch07.xhtml#ch7fig26) has a lower
    cost than the other nodes in the open queue, it moves to the head of the queue
    and becomes the next item to be popped off. Notice that its first child is already
    in the closed list, but its newly computed cost is higher than the cost in the
    closed list, so it’s ignored. The remaining child node would be processed as before.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[图 7-26](ch07.xhtml#ch7fig26)中的第一个子节点的成本低于开放队列中其他节点的成本，它被移到队列的头部，并成为下一个被弹出的项目。注意，它的第一个子节点已经在闭合列表中，但其新计算的成本高于闭合列表中的成本，因此被忽略。剩下的子节点将像以前一样进行处理。
- en: '![Image](../images/07fig28.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig28.jpg)'
- en: '*Figure 7-28: Closed and open, updated*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-28：闭合与开放，更新版*'
- en: 'The process continues until one of two things happens: either a node is popped
    off the open queue that’s in the solved state, in which case the algorithm completes
    and prints the answer (details on how this is accomplished are described in the
    next section), or the open queue becomes empty, which indicates that the puzzle
    was not solvable.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程将持续进行，直到发生以下两种情况之一：要么从开放队列中弹出的节点处于已解状态，在这种情况下算法完成并打印答案（有关如何完成此操作的详细信息将在下一节中描述）；要么开放队列变为空，表示拼图无法解决。
- en: '***The 8-Puzzle in Racket***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Racket 中的 8-拼图***'
- en: We’ll begin by implementing a solution to the smaller 3-by-3 version of the
    puzzle before we move on the full 4-by-4 version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将先实现一个针对较小的 3x3 版本的拼图的解决方案，然后再继续解决完整的 4x4 版本。
- en: 'As with Dijkstra’s algorithm, we’ll use Racket’s heap object for the open priority
    queue:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Dijkstra 算法类似，我们将使用 Racket 的堆对象来处理开放优先队列：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A `SIZE` constant will specify the number of rows and columns in the puzzle.
    In addition we’ll define a number of utility functions to work with the puzzle
    structure. For efficiency, the puzzle state will be stored internally as a Racket
    vector of size `SIZE*SIZE+2`. The last two elements of the vector will contain
    the row and column of the empty cell. The empty cell will have the numerical value
    specified by `(define empty (sqr SIZE))`. To this end, we have the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`SIZE`常量将指定拼图的行列数。此外，我们还将定义一些实用函数来处理拼图结构。为了提高效率，拼图的状态将内部存储为一个大小为`SIZE*SIZE+2`的
    Racket 向量。向量的最后两个元素将包含空白格的行和列。空白格将具有由`(define empty (sqr SIZE))`指定的数值。为此，我们有以下内容：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ref` function will take a puzzle along with and a row and column number
    as arguments. It returns the tile number at that location. The `empty-loc` function
    will return two values that give the row and column respectively of the empty
    cell.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`函数将接受拼图以及行和列号作为参数。它返回该位置上的拼图块编号。`empty-loc`函数将返回两个值，分别表示空白格的行和列。'
- en: The following functions are used to compute the Manhattan distance. The first
    creates a hash table used to look up the home location of a tile given the tile
    number. The second function computes the sum of the Manhattan distances for each
    tile in the puzzle. This will be used in the computation of the cost of a puzzle
    node.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于计算曼哈顿距离。第一个函数创建一个哈希表，用于根据拼图块的编号查找其家居位置。第二个函数计算拼图中每个块的曼哈顿距离之和。这将用于计算拼图节点的成本。
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next functions are used to generate a new puzzle state given a move specifier.
    A move specifier is a number from zero to three that determines which of the four
    directions a tile can be moved into the empty space from.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于根据移动说明生成新的谜题状态。移动说明是一个从零到三的数字，用于确定哪一个方向的方块可以移动到空白位置。
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `move-offset` function takes a move specifier and returns two values specifying
    the row and column deltas needed to make the move. The `make-move` function takes
    a move specifier and returns a new vector representing the puzzle after the move
    has been made.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`move-offset` 函数接受一个移动说明，并返回两个值，指定执行该移动所需的行和列增量。`make-move` 函数接受一个移动说明，并返回一个新的向量，表示执行该移动后的谜题状态。'
- en: The following function will take a puzzle and return a list consisting of all
    the valid puzzle states that can be reached from a particular puzzle state. The
    local `legal` function determines whether a move specifier will result in a valid
    move for the current puzzle state by checking whether a move in a certain direction
    will extend beyond the boundaries of the puzzle.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将接受一个谜题并返回一个列表，包含所有可以从特定谜题状态到达的有效谜题状态。局部的 `legal` 函数通过检查某个方向的移动是否会超出谜题的边界，来判断一个移动说明是否会导致当前谜题状态的有效移动。
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It will of course be useful to actually see a visual representation of the puzzle.
    That functionality is provided by the following routine.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，实际看到谜题的可视化表示会非常有用。以下程序提供了这个功能。
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next we define a helper function to process closed nodes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个辅助函数来处理关闭节点。
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We begin by placing the node, its parent, and its estimated cost in the `closed`
    table ➊. Next, we generate a list of the possible child puzzle states and loop
    through them. For each child node, we generate the new node depth ➋ and estimated
    score ➌. Then we compile the information that we’d need to push that node to the
    open queue ➍, which happens automatically ➐ if the node is not in the `closed`
    table. If the node is in the `closed` table, we extract its prior cost score ➎
    and compare with its current score ➏. If the current score is less than the prior
    score, we remove the node from the `closed` table and place it in the open queue.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将节点、其父节点及其估算成本放入 `closed` 表 ➊。接下来，我们生成可能的子谜题状态列表，并对其进行循环。对于每个子节点，我们生成新的节点深度
    ➋ 和估算得分 ➌。然后我们汇总需要的信息，以便将该节点推入打开队列 ➍，如果该节点不在 `closed` 表中，推送操作会自动进行 ➐。如果该节点已经在
    `closed` 表中，我们会提取其之前的成本得分 ➎ 并与当前得分 ➏ 进行比较。如果当前得分小于之前的得分，我们会将该节点从 `closed` 表中移除，并将其放入打开队列中。
- en: We finally get to the algorithm proper.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入真正的算法部分。
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First we define the `closed` hash table described above. The open queue is initialized
    ➊, and the scrambled puzzle provided to the `a-star` procedure is pushed onto
    the open queue ➋. The items in the queue consist of a Racket pair. The `cdr` of
    the pair is the estimated score, and the `car` consists of the puzzle state, the
    depth of the tree, and the parent puzzle state. After this initialization, the
    main loop starts ➌.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义上述的 `closed` 哈希表。打开队列被初始化 ➊，并且提供给 `a-star` 程序的打乱谜题被推送到打开队列中 ➋。队列中的项由一个
    Racket 对组成。对的 `cdr` 部分是估算的得分，而 `car` 部分由谜题状态、树的深度和父节点的谜题状态组成。初始化完成后，主循环开始 ➌。
- en: The loop repeats until the `solved` variable is set to true. The first step
    of the loop is to pop the highest-priority item (lowest cost score) from the open
    queue and assign it to the `node-info` variable. A `match` form is used to parse
    the values contained in `node-info` ➎. The puzzle state (in `node`) is first tested
    to see if it’s in the solved state ➏, and if so, the function prints out the move
    sequence and terminates the process. Otherwise, the processing continues where
    we process the closed node by placing the node, its parent, and estimated cost
    in the `closed` table ➐.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会一直重复，直到 `solved` 变量被设为 true。循环的第一步是从打开队列中弹出优先级最高（成本得分最低）的项，并将其分配给 `node-info`
    变量。使用 `match` 形式解析 `node-info` 中包含的值 ➎。首先测试谜题状态（在 `node` 中）是否已达到解决状态 ➏，如果是，函数会输出移动序列并终止过程。否则，处理继续，我们通过将节点、其父节点和估算成本放入
    `closed` 表来处理关闭节点 ➐。
- en: Once each iteration completes, the queue is checked ➑ to see if it contains
    any nodes that needs processing. If it does, then the next iteration resumes ➍;
    otherwise, no solution exists and the process terminates ➒.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代完成后，会检查队列 ➑ 是否包含任何需要处理的节点。如果有，则下一次迭代继续进行 ➍；否则，表示没有解决方案，过程终止 ➒。
- en: Here are the print functions that show the solution. The `solution-list` procedure
    chases the parent nodes in `closed` to create a list of the puzzle states all
    the way back to the starting puzzle; `print-solution` takes the solution list
    and prints out the puzzle states it contains.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示解法的打印函数。`solution-list`过程通过追溯`closed`中的父节点，生成一个从起始拼图到最终拼图的所有状态列表；`print-solution`则接受该解法列表并打印其中包含的拼图状态。
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here’s a test run on the puzzle presented in [Figure 7-25](ch07.xhtml#ch7fig25)
    (to save space, the output puzzles are displayed horizontally).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对[图7-25](ch07.xhtml#ch7fig25)中展示的谜题进行的测试运行（为了节省空间，输出谜题横向显示）。
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***Moving Up to the 15 Puzzle***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***上升到15拼图***'
- en: 'Having laid the groundwork with the 8 puzzle, the 15 puzzle requires this tricky
    modification: change the value of `SIZE` from 3 to 4\. Okay, maybe that’s not
    too tricky, but before you get too excited, it’s really not quite that simple
    either. Observe [Figure 7-29](ch07.xhtml#ch7fig29). The first two puzzles are
    from [9], and our test computer sailed through solving these. But the third puzzle
    was randomly generated and caused the test computer to fall to the floor, giggling
    to itself that we would attempt to have it solve such a problem—no solution was
    forthcoming.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在8拼图的基础上，15拼图需要进行这个棘手的修改：将`SIZE`的值从3更改为4。好吧，也许这并不算太棘手，但在你太兴奋之前，实际上这也并没有那么简单。观察[图7-29](ch07.xhtml#ch7fig29)。前两个拼图来自[9]，我们的测试计算机轻松解决了这些问题。但第三个拼图是随机生成的，导致测试计算机崩溃，它自己在地板上咯咯笑，认为我们竟然让它解决如此复杂的问题——没有解答能够成功输出。
- en: '![Image](../images/07fig29.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig29.jpg)'
- en: '*Figure 7-29: Some 15 puzzle examples*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-29：一些15拼图示例*'
- en: The issue is that some puzzles may result in the A* algorithm having to explore
    too many paths, so the computer runs out of resources (or the user runs out of
    patience waiting for an answer). Our solution is to settle for a slightly less
    elegant approach by breaking the problem into three subproblems. We will trade
    off a fully optimized solution for a solution that we don’t have to wait forever
    to get.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，某些谜题可能导致A*算法需要探索过多的路径，从而使计算机资源耗尽（或者用户在等待答案时耐心耗尽）。我们的解决方案是通过将问题分解成三个子问题，采取稍微不那么优雅的方法。我们将以牺牲完全优化的解法为代价，换取一个不需要等太久就能得到的解法。
- en: To break the problem into subproblems, we’re going to divide the puzzle into
    three zones as shown below in [Figure 7-30](ch07.xhtml#ch7fig30). The zones are
    chosen to take advantage of the fact that the A* algorithm was pretty zippy with
    the 8 puzzle.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将问题分解成子问题，我们将如[图7-30](ch07.xhtml#ch7fig30)所示将谜题划分为三个区域。这些区域的选择是为了利用A*算法在8拼图上的高效性。
- en: '![Image](../images/07fig30.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig30.jpg)'
- en: '*Figure 7-30: 15 puzzle divided into zones*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-30：15拼图分区*'
- en: The medium gray section, which we designate zone 1, represents one subproblem,
    the white section (zone 2) will be the second subproblem, and the dark gray section
    (zone 3) represents another subproblem (which is equivalent to the 8 puzzle, which
    we know can be solved quickly). The idea is to provide different scoring functions
    to the `a-star` algorithm depending on which zone is being addressed. These functions
    will still use the Manhattan distance, but with certain restrictions applied.
    Once zone 1 and zone 2 have been solved, we can just call `manhattan` as before
    since the edge tiles in zones 1 and 2 will already be in place and the remaining
    tiles would be equivalent to an 8 puzzle.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 中灰色区域，我们指定为区域1，表示一个子问题，白色区域（区域2）将是第二个子问题，深灰色区域（区域3）代表另一个子问题（相当于8拼图，我们知道它可以快速解决）。这个思路是为`a-star`算法提供不同的评分函数，具体取决于当前正在处理的区域。这些函数仍然会使用曼哈顿距离，但会应用一定的限制。一旦区域1和区域2被解决，我们就可以像以前一样调用`manhattan`，因为区域1和区域2中的边缘瓷砖已经到位，剩下的瓷砖将相当于一个8拼图。
- en: '**Zone 1**'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**区域1**'
- en: 'Before we dive into solving zone 1, we’re going to create a helper function
    that’s quite similar to the code we saw in the `manhattan` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解决区域1之前，我们将创建一个帮助函数，该函数与我们在`manhattan`函数中看到的代码非常相似：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The main difference is that instead of embedding the test for the empty square
    directly in the `cost` function, we’ll pass in a function for the `guard` parameter
    that will do the test for us. Given this, we can redefine `manhattan` as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于，替代直接在`cost`函数中嵌入空格测试，我们将传递一个用于`guard`参数的函数来为我们执行该测试。基于此，我们可以重新定义`manhattan`如下：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ll attack zone 1 in two phases: first we nudge tiles 1 through 4 into the
    first two rows of the puzzle; then we get them into the proper order in the first
    row.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两阶段攻击区域1：首先，我们将第1到第4个瓦片推入拼图的前两行；然后，我们将它们按照正确的顺序排列到第一行。
- en: To get tiles 1 through 4 into the first two rows, we define `zone1a`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将瓦片1到4移入前两行，我们定义了`zone1a`。
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, we only update the distance for tiles 1 through 4, and we only
    update the distance if these tiles are not already in the first two rows.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只更新第1到第4个瓦片的距离，并且只有在这些瓦片尚未位于前两行时，我们才更新其距离。
- en: The second phase is just slightly different. This time we always update the
    distance for tiles 1 through 4 to ensure they land in the proper locations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段稍有不同。这次我们始终更新第1到第4个瓦片的距离，以确保它们落到正确的位置。
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It might appear that this could have been done in a single function, but trying
    to position the tiles all at once would result in a large search space and the
    consequent increase needed in time and computer resources (like memory). Our first
    phase, where we just get the tiles into the proximity of their proper location,
    reduces the search space by half, without requiring an enormous amount of resources.
    The sorting in phase two will normally only have to deal with the tiles in the
    top half of the puzzles since the remaining tiles will have a score of zero.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来这一切可以在一个函数中完成，但如果试图一次性将所有瓦片定位，则会导致一个巨大的搜索空间，并需要更多的时间和计算资源（例如内存）。我们的第一阶段，只是将瓦片放置到接近其正确位置的地方，就减少了搜索空间的一半，且不需要大量资源。第二阶段的排序通常只需要处理拼图上半部分的瓦片，因为剩余的瓦片得分为零。
- en: '**Zone 2**'
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**区域2**'
- en: 'At this point, we’ve reduced the search space by 25 percent. This modest reduction
    is sufficient to allow us to get tiles 5, 9, and 13 into zone 2 and in their proper
    order in a single procedure, which we provide here as `zone2`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已将搜索空间缩小了25%。这种适度的减少足以让我们在一个过程中将瓦片5、9和13移入区域2，并按正确顺序排列，我们在这里提供的过程就是`zone2`：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, we no longer need to bother with row 1, as reflected in the code
    `>= r 1`. Aside from this, the code is nearly identical to the others, except
    that this time, we use the values defined in `zone2-tiles` for scoring.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们不再需要关注第1行，正如代码中`>= r 1`所示。除此之外，代码几乎与其他代码相同，唯一不同的是这次我们使用在`zone2-tiles`中定义的值来进行评分。
- en: '**Putting It All Together**'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将所有内容整合在一起**'
- en: Once a zone has been solved, we won’t want to disturb the tiles that are already
    in place. To accomplish this, a slight tweak is made to the function (`next-states`)
    that generates the list of permissible states. Before, we simply checked to ensure
    we weren’t moving beyond the first row or column. Now we define global variables
    `min-r` and `min-c`, which are set to 0 or 1 depending on which zone we’re currently
    working in.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个区域被解决，我们就不希望干扰已经放置好的瓦片。为此，我们对生成可行状态列表的函数（`next-states`）做了一个轻微调整。之前，我们只是简单地检查是否没有超出第一行或列。现在，我们定义了全局变量`min-r`和`min-c`，它们会根据当前正在处理的区域设置为0或1。
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The final solver will update the values of `min-r` and `min-c` once zones 1
    and 2 have been populated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的求解器将在区域1和区域2填充完成后更新`min-r`和`min-c`的值。
- en: We now need to make a few crucial modifications to the code for `a-star` and
    `process-closed`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对`a-star`和`process-closed`的代码进行一些关键的修改。
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The most significant change is that instead of always using `manhattan` for
    our scoring estimate, we now use the function `fscore` ➊, which is passed to `process-closed`
    as an additional parameter. This function will be different depending on which
    zone of the puzzle is being solved.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的变化是，之前我们一直使用`manhattan`来进行评分估计，而现在我们使用函数`fscore` ➊，它作为额外参数传递给`process-closed`。这个函数会根据正在解决的拼图区域的不同而有所不同。
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here we also include `fscore` as an additional parameter. Now, instead of immediately
    printing a solution once the goal state is reached, we return two values at the
    end ➌: the current goal, given in the first `set!` ➊ and the solution list, given
    in the second `set!` ➋. The remaining code should align closely with the original
    version.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还包括了`fscore`作为一个额外的参数。现在，当目标状态达到时，我们不再立即打印出解决方案，而是返回两个值：第一个`set!` ➊中的当前目标和第二个`set!`
    ➋中的解决方案列表。剩余的代码应与原始版本保持一致。
- en: Instead of calling `a-star` directly as we did before, we now provide a `solve`
    function that steps through the process of providing `a-star` with the proper
    scoring function, which is either one of the zone-specific functions or `manhattan`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再像以前那样直接调用`a-star`，而是提供了一个`solve`函数，逐步执行并为`a-star`提供适当的评分函数，该函数可以是区域特定的函数之一，或是`manhattan`。
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As the code executes, it stores the solution list for each step of the process
    and finally prints the entire solution in the last line of the code. The reason
    we take the `cdr` of the solution list at each step (except the first) is because
    the last item in the solution from the previous step is the goal of the next step;
    this state would be repeated if we left it in the list.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码执行时，它会在每个步骤存储解决方案列表，并最终在代码的最后一行打印出完整的解决方案。我们在每个步骤（除了第一步）都取解决方案列表的`cdr`，这是因为前一步骤的最后一项是下一步的目标；如果我们把它保留在列表中，这个状态就会被重复。
- en: Finally, we resolve a little cosmetic issue with the `print` routine caused
    by having two-digit numbers on the tiles. The revised code follows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解决了`print`例程中由于瓷砖上的双位数字导致的小问题。修改后的代码如下。
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The following are some sample inputs with which to test the code. To save space,
    only the output (compressed) from the first example is shown.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于测试代码的示例输入。为了节省空间，仅显示第一个示例的输出（压缩格式）。
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Be aware that depending on the puzzle and the power of your computer, it may
    take anywhere from a couple of seconds to a minute or so to generate a solution.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据谜题的复杂性和计算机的性能，生成解决方案可能需要从几秒钟到一分钟不等的时间。
- en: Sudoku
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数独
- en: Sudoku^([2](footnote.xhtml#ch07foot_2)) is a popular puzzle consisting of a
    9-by-9 grid of squares in which some squares are initially populated with digits
    from 1 through 9, as shown in [Figure 7-31](ch07.xhtml#ch7fig31)a. The objective
    is to fill in the blank squares such that each row, column, and 3-by-3 block of
    squares also consists of digits 1 through 9, as shown in [Figure 7-31](ch07.xhtml#ch7fig31)b.
    A well-formed Sudoku puzzle should only have one possible solution.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 数独^([2](footnote.xhtml#ch07foot_2))是一种流行的谜题，由一个9x9的方格组成，初始时有一些方格被填入了从1到9的数字，如[图
    7-31](ch07.xhtml#ch7fig31)a所示。目标是填充空白方格，使得每一行、每一列和每一个3x3的方格块也包含数字1到9，如[图 7-31](ch07.xhtml#ch7fig31)b所示。一个完整的数独谜题应只有一个可能的解。
- en: '![Image](../images/07fig31.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig31.jpg)'
- en: '*Figure 7-31: The Sudoku puzzle*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-31：数独谜题*'
- en: Our aim in this section is to produce a procedure that generates the solution
    to any given Sudoku puzzle.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是编写一个过程，生成任何给定数独谜题的解决方案。
- en: 'The basic strategy is this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 基本策略如下：
- en: Check each empty cell, to determine which numbers are available to be used.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查每个空单元格，确定可用的数字。
- en: Select a cell with the fewest available numbers.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个可用数字最少的单元格。
- en: One at a time, enter one of the available numbers in the cell.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一次填写单元格中的一个可用数字。
- en: For each available number, repeat the process until either the puzzle is solved,
    or there are no numbers available for an empty cell.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个可用数字，重复该过程，直到谜题被解决，或没有可用数字填入空单元格。
- en: If there are no available numbers, backtrack to step 3 and try a different number.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有可用的数字，请回溯到步骤3，尝试其他数字。
- en: The process is another application of depth-first search.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程是深度优先搜索的另一种应用。
- en: '[Figure 7-32](ch07.xhtml#ch7fig32) gives the coordinates used to reference
    locations in the puzzle: numbers across the top index columns, numbers on the
    left edge index rows, and numbers in the interior index blocks of 3-by-3 subgrids.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-32](ch07.xhtml#ch7fig32)给出了在谜题中参考位置的坐标：数字索引列位于顶部，数字索引行位于左边缘，数字索引块位于3x3子网格的内部。'
- en: '![Image](../images/07fig32.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig32.jpg)'
- en: '*Figure 7-32: Puzzle coordinates*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-32：谜题坐标*'
- en: 'To determine the available numbers for a given cell, we take the set intersection
    of the unused numbers in each row, column, and block. Using the cell in row 1,
    column 1 of [Figure 7-31](ch07.xhtml#ch7fig31)a as an example, in row 1 the set
    of numbers {2, 5, 8} are free, in column 1 all the numbers except for 5 are available,
    and in block 0, the set of numbers {2, 3, 7, 8, 9} are available. The intersection
    of these sets gives the set of possible values for this cell: {2, 8}.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定某个单元格的可用数字，我们需要对每行、每列和每个区块中未使用的数字进行集合交集操作。以[图 7-31](ch07.xhtml#ch7fig31)a中第一行第一列的单元格为例，第一行的可用数字集合为{2,
    5, 8}，第一列的所有数字中除了5外的其他数字均可用，在区块0中，可用的数字集合为{2, 3, 7, 8, 9}。这些集合的交集给出了该单元格的可选值集合：{2,
    8}。
- en: 'Our implementation will use a 9-by-9 array of numbers to represent the puzzle,
    where the number 0 will designate an empty square. The array will be constructed
    of a nine-element vector, each element being another nine-element integer vector.
    For easy access to elements of the array, we define two utility functions to set
    and retrieve values:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将使用一个 9x9 的数字数组来表示谜题，其中数字 0 表示一个空白格。该数组将由九个元素的向量构成，每个元素是另一个九个元素的整数向量。为了方便访问数组的元素，我们定义了两个实用函数来设置和获取值：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both of these functions require the array and row and column numbers to be provided
    as the initial arguments.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都需要将数组以及行列号作为初始参数提供。
- en: It will also be useful to derive the corresponding block index from the row
    and column numbers, as given by the `getBlk` function here.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从行和列号推导相应的块索引也将是有用的，正如 `getBlk` 函数所示。
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The puzzle will be input as a single string where each row of nine digits is
    broken by a new line as shown by the example below.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 谜题将作为一个单一字符串输入，其中每行九个数字由换行符分隔，如下面的示例所示。
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We define the Sudoku puzzle object as a `sudoku%` Racket object for which we
    give a partial implementation here. This object will maintain the puzzle state.
    It will contain functions that allow us to manipulate the state by setting cell
    values and provides functions to list potential candidates (unused numbers in
    a row, column, or block) and other helper functions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数独谜题对象定义为 `sudoku%` Racket 对象，以下是该对象的部分实现。该对象将维护谜题的状态，并包含可以通过设置单元格值来操作状态的函数，同时提供列出潜在候选数字（在某行、某列或某块中未使用的数字）及其他辅助函数。
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `init` form ➊ captures the input string value that defines the puzzle. We
    initialize the puzzle ➎ by calling `init-puzzle` ➐, which updates `grid` ➌ with
    the appropriate numerical values via the call to `init-grid` ➏.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 表单 ➊ 捕获定义谜题的输入字符串值。我们通过调用 `init-puzzle` ➐ 来初始化谜题 ➎，该函数通过调用 `init-grid`
    ➏ 使用适当的数值更新 `grid` ➌。'
- en: The `count` variable ➋ contains the number of cells that currently have a value.
    Once `count` reaches 81, the puzzle has been solved.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 变量 ➋ 包含当前已赋值的单元格数量。一旦 `count` 达到 81，谜题即已解答。'
- en: 'The `avail-row`, `avail-col`, and `avail-blk` variables are used to keep track
    of which numbers are currently unused in each row, column, and block respectively.
    The `make-markers` function, which is called to initialize each of these variables,
    creates a Boolean array that indicates which numbers are free for any given index
    (row, column, or block as applicable); `make-markers` is defined as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`avail-row`、`avail-col` 和 `avail-blk` 变量用于跟踪每行、每列和每个块中当前未使用的数字。`make-markers`
    函数用于初始化这些变量，它创建一个布尔数组，表示在给定索引（行、列或块）中哪些数字是可用的；`make-markers` 定义如下：'
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice that the number 0 (designating an empty cell) is automatically marked
    as unavailable.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数字 0（表示空单元格）自动标记为不可用。
- en: As numbers get added to the puzzle, `item-set!` is called ➍. This procedure
    is responsible for updating `grid` and `avail-row`, `avail-col`, and `avail-blk`
    when given the row, column, and number to be assigned to the puzzle. The functions
    `get-grid` and `item-ref` return `grid` or a cell in `grid` respectively.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字被添加到谜题中，`item-set!` 会被调用 ➍。该过程负责在给定要分配给谜题的行、列和数字时更新 `grid`、`avail-row`、`avail-col`
    和 `avail-blk`。`get-grid` 和 `item-ref` 函数分别返回 `grid` 或 `grid` 中的某个单元格。
- en: In the following code extracts, all function definitions that are indented should
    be included in the class definition for `sudoku%` and aren’t global defines.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，所有缩进的函数定义应包含在 `sudoku%` 类定义中，而不是全局定义。
- en: The following `avail` function combines the values from `avail-row`, `avail-col`,
    and `avail-blk` to produce a vector indicating which numbers are available.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `avail` 函数将 `avail-row`、`avail-col` 和 `avail-blk` 的值结合起来，生成一个指示哪些数字可用的向量。
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Given this vector, we create a list of the free numbers as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个向量，我们按照以下方式创建一个自由数字的列表：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For efficiency, the following code finds all the cells that only have a single
    available number and updates the puzzle appropriately.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，以下代码查找所有只有一个可用数字的单元格，并相应地更新谜题。
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Performing this process once may result in other cells with only a single available
    number. The following code runs until no cells remain with only a single available
    number.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此过程一次可能会导致其他单元格只有一个可用的数字。以下代码会持续运行，直到没有单元格只剩下一个可用数字。
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For puzzles that can be solved directly by logic alone (no guessing is required),
    the above process would be sufficient, but this isn’t always the case. To support
    backtracking, the following two functions are provided.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些仅凭逻辑即可直接解决的谜题（无需猜测），上述过程就足够了，但情况并不总是如此。为了支持回溯，提供了以下两个函数。
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first function (`get-free`) goes cell by cell and creates a list of all
    the free values for each cell. Each element of the list contains another list
    that holds the row, column, number of free values, and a list of the free values.
    The second function (`get-min-free`) takes the list returned by `get-free` and
    returns the values for the cell with the fewest free numbers.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数（`get-free`）逐个单元格地创建每个单元格的所有自由值的列表。列表的每个元素都包含一个列表，保存行、列、自由值的数量以及自由值的列表。第二个函数（`get-min-free`）接受`get-free`返回的列表，并返回自由数字最少的单元格的值。
- en: Here are a few handy utility functions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些实用的工具函数。
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `print` member function provides a simple text printout of the puzzle. The
    `solved?` function indicates whether the puzzle is in the solved state by testing
    whether all 81 cells have been populated. The `clone` function provides a copy
    of the puzzle.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`成员函数提供谜题的简单文本打印输出。`solved?`函数通过测试所有81个单元格是否都已填充来判断谜题是否已解。`clone`函数提供谜题的副本。'
- en: This concludes the code that’s defined within the body of the `sudoku%` class
    definition and brings us to the actual code used to solve the puzzle.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`sudoku%`类定义体内定义的代码，接下来是实际用于解决谜题的代码。
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We begin by creating a copy of the puzzle to work with ➊. Next, we define a
    depth-first search procedure, `dfs` ➋, which we’ll explain shortly. The call to
    `set-all-singles` ➑ is occasionally sufficient to solve the puzzle, but the puzzle
    is handed off to `dfs` to ensure a complete solution is found. The remaining lines
    will return a solved puzzle if one exists; otherwise an error is signaled.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个谜题副本进行操作 ➊。接下来，我们定义一个深度优先搜索过程`dfs` ➋，稍后我们将解释。调用`set-all-singles` ➑偶尔足以解决谜题，但谜题会被交给`dfs`，以确保找到完整的解决方案。剩下的行将返回已解的谜题（如果存在）；否则会发出错误信号。
- en: The depth-first search code, `dfs` ➋, immediately tests whether the puzzle is
    solved and if so, returns the solved puzzle. Otherwise, the cell with the fewest
    available numbers (if any) is explored ➌, where the `match` form extracts the
    cell row, column, number of free numbers, and the list of free numbers. The list
    of free numbers is iterated through starting on the next line. While the list
    isn’t empty, the first number in the list is extracted into `n` ➍ and the remaining
    numbers are stored in `t` ➎. Then a copy of the puzzle is created. Next, the puzzle
    copy is populated with the current available number ➏, and `set-all-singles` is
    called immediately following this. If this number doesn’t produce a solution (via
    the recursive call to `dfs` ➐), the loop repeats with the original puzzle and
    the next available number.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索代码`dfs` ➋，立即测试谜题是否已解决，如果已解决，则返回已解的谜题。否则，探索具有最少可用数字的单元格（如果有的话） ➌，其中`match`表达式提取单元格的行、列、自由数字的数量以及自由数字的列表。然后，从下一行开始，迭代自由数字的列表。在列表不为空时，第一个数字被提取到`n`
    ➍，剩余的数字存储在`t` ➎中。接下来，创建谜题的副本。然后，使用当前可用的数字填充谜题副本 ➏，并紧接着调用`set-all-singles`。如果这个数字不能生成解决方案（通过递归调用`dfs`
    ➐），则循环将用原始谜题和下一个可用数字重新开始。
- en: To aid testing various puzzles, we define a simple routine to take an input
    puzzle string, solve the puzzle, and print the solution.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试各种谜题，我们定义了一个简单的例程，接受一个输入的谜题字符串，解决谜题，并打印解决方案。
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that we’ve laid this groundwork, here’s a trial run with our example puzzle.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打下了基础，接下来用我们的示例谜题进行试运行。
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: While this is certainly an adequate method to generate the output, it doesn’t
    take a lot of additional work to produce a more attractive output.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这无疑是生成输出的足够方法，但只需稍加额外工作，就可以产生更具吸引力的输出。
- en: To accomplish our goal, we’ll need the Racket *draw* library.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们需要Racket的*draw*库。
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Furthermore, we’ll borrow our `draw-centered-text` procedure that we used in
    the 15 puzzle GUI:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将借用在15拼图GUI中使用的`draw-centered-text`过程：
- en: '[PRE57]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Given these preliminaries, we can now define our `draw-puzzle` function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些前提条件后，我们现在可以定义我们的`draw-puzzle`函数：
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There’s really nothing new here. The reason we’re passing it two puzzles is
    because the first puzzle is the original unsolved puzzle. It’s simply used to
    determine which color to use to draw the squares. If a square was blank in the
    original puzzle, it’ll be colored yellow in the output; otherwise it’ll be colored
    gray.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里其实没有什么新鲜的内容。我们传递给它两个拼图的原因是，第一个拼图是原始的未解拼图。它仅用于确定绘制方格时使用的颜色。如果方格在原始拼图中是空白的，它将在输出中被涂成黄色；否则，它将被涂成灰色。
- en: 'With this in hand, we can redefine `solve` as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以重新定义`solve`如下：
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using this new version yields the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新版本得到如下结果：
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It gives the starting state in [Figure 7-33](ch07.xhtml#ch7fig33):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 它展示了[图 7-33](ch07.xhtml#ch7fig33)中的初始状态：
- en: '![Image](../images/07fig33.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig33.jpg)'
- en: '*Figure 7-33: Sudoku starting-state drawing*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-33：数独初始状态图示*'
- en: 'And the solved state in [Figure 7-34](ch07.xhtml#ch7fig34):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在[图 7-34](ch07.xhtml#ch7fig34)中的解题状态：
- en: '![Image](../images/07fig34.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig34.jpg)'
- en: '*Figure 7-34: Solved Sudoku drawing*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-34：已解数独图示*'
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve explored a number of algorithms that are useful in the
    general context of problem-solving. In particular we’ve looked at breath-first
    search (BFS), depth-first search (DFS), the A* algorithm, and Dijkstra’s algorithm
    (and discovered priority queues along the way) to find the shortest path between
    graph nodes. We employed DFS in the solution of the *n*-queens problem and the
    15 puzzle (which also used the A* algorithm). Finally, we took a look at Sudoku,
    where sometimes logic alone is sufficient to solve, but failing this, DFS again
    comes to the rescue. While the algorithms we’ve explored are far from a comprehensive
    set, they form a useful toolset that’s effective in solving a wide range of problems
    over many domains.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多种在解决问题时常用的算法。具体来说，我们讨论了广度优先搜索（BFS）、深度优先搜索（DFS）、A* 算法以及 Dijkstra 算法（并且在此过程中了解了优先队列），这些算法用于寻找图中节点之间的最短路径。我们在
    *n*-皇后问题和 15 拼图问题中使用了 DFS（后者还使用了 A* 算法）。最后，我们研究了数独，在某些情况下，逻辑就足以解决问题，但如果失败，DFS
    又会派上用场。虽然我们探讨的算法远非全面，但它们构成了一套有效的工具集，能在许多领域解决广泛的问题。
- en: 'Thus far we’ve exercised a number of programming paradigms: imperative, functional,
    and object-oriented. In the next chapter, we’ll look at a new technique: programming
    in logic or logic programming.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经运用了多种编程范式：命令式、函数式和面向对象。在下一章，我们将介绍一种新的技术：逻辑编程或逻辑程序设计。
