["```\nsomeCharPtrVar = \"Hello World\";\n```", "```\n\n\t\t\t;       char *someCharPtrVar;\n   ;        someCharPtrVar = \"Hello World\";\n   ;\n@1:\n; \"offset\" means \"take the address of\" and \"s@\" is\n; the compiler-generated label where the string\n; \"Hello World\" can be found.\n\n    mov       eax,offset s@\n        .\n        .\n        .\n_DATA   segment dword public use32 'DATA'\n;       s@+0:\n        ; Zero-terminated sequence of characters\n        ; emitted for the literal string \"Hello World\":\n\ns@      label   byte\n        db      \"Hello World\",0\n\n        ;       s@+12:\n        db      \"%s\",0\n        align   4\n_DATA   ends\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\nint myStrlen( char *s )\n{\n    char *start;\n\n    start = s;\n    while( *s != 0 )\n    {\n        ++s;\n    }\n    return s - start;\n}\n\nint main( int argc, char **argv )\n{\n\n    printf( \"myStrlen = %d\", myStrlen( \"Hello World\" ));\n    return 0;\n}\n```", "```\n\n\t\t\tmyStrlen PROC                                           ; COMDAT\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 10                           // Pointer to string (s) is passed in RCX register.\n        cmp     BYTE PTR [rcx], 0   // Is *s = 0?\n        mov     rax, rcx            // Save ptr to start of string to compute length\n        je      SHORT $LN3@myStrlen // Bail if we hit the end of the string\n$LL2@myStrlen:\n; Line 12\n        inc     rcx                 // Move on to next char in string\n        cmp     BYTE PTR [rcx], 0   // Hit the 0 byte yet?\n        jne     SHORT $LL2@myStrlen // If not, repeat loop\n$LN3@myStrlen:\n; Line 14\n        sub     rcx, rax            // Compute length of string.\n        mov     eax, ecx            // Return function result in EAX.\n; Line 15\n        ret     0\nmyStrlen ENDP\n```", "```\n\n\t\t\tunit stringUnit;\n\n#include( \"strings.hhf\" );\n\n/*******************************************************************/\n/*                                                                 */\n/* zlen-                                                           */\n/*                                                                 */\n/* Returns the current length of the z-string passed as a parm.    */\n/*                                                                 */\n/*******************************************************************/\n\nprocedure zstr.len( zstr:zstring ); @noframe;\nconst\n    zstrp   :text := \"[esp+8]\";\n\nbegin len;\n\n    push( esi );\n    mov( zstrp, esi );\n\n    // We need to get ESI dword-aligned before proceeding.\n    // If the LO 2 bits of ESI contain 0s, then\n    // the address in ESI is a multiple of 4\\. If they\n    // are not both 0, then we need to check the 1,\n    // 2, or 3 bytes starting at ESI to see if they\n    // contain a zero-terminator byte.\n\n    test( 3, esi );\n    jz ESIisAligned;\n\n    cmp( (type char [esi]), #0 );\n    je SetESI;\n    inc( esi );\n    test( 3, esi );\n    jz ESIisAligned;\n\n    cmp( (type char [esi]), #0 );\n    je SetESI;\n    inc( esi );\n    test( 3, esi );\n    jz ESIisAligned;\n\n    cmp( (type char [esi]), #0 );\n    je SetESI;\n    inc( esi );                 // After this, ESI is aligned.\n\n    ESIisAligned:\n        sub( 32, esi );         // To counteract add immediately below.\n    ZeroLoop:\n        add( 32, esi );         // Skip chars this loop just processed.\n    ZeroLoop2:\n        mov( [esi], eax );      // Get next four chars into EAX.\n        and( $7f7f7f7f, eax );  // Clear HO bit (note:$80->$00!)\n        sub( $01010101, eax );  // $00 and $80->$FF, all others have pos val.\n        and( $80808080, eax );  // Test all HO bits.  If any are set, then\n        jnz MightBeZero0;       // we've got a $00 or $80 byte.\n\n        mov( [esi+4], eax );    // The following are all inline expansions\n        and( $7f7f7f7f, eax );  // of the above (we'll process 32 bytes on\n        sub( $01010101, eax );  // each iteration of this loop).\n        and( $80808080, eax );\n        jnz MightBeZero4;\n\n        mov( [esi+8], eax );\n        and( $7f7f7f7f, eax );\n        sub( $01010101, eax );\n        and( $80808080, eax );\n        jnz MightBeZero8;\n\n        mov( [esi+12], eax );\n        and( $7f7f7f7f, eax );\n        sub( $01010101, eax );\n        and( $80808080, eax );\n        jnz MightBeZero12;\n\n        mov( [esi+16], eax );\n        and( $7f7f7f7f, eax );\n        sub( $01010101, eax );\n        and( $80808080, eax );\n        jnz MightBeZero16;\n\n        mov( [esi+20], eax );\n        and( $7f7f7f7f, eax );\n        sub( $01010101, eax );\n        and( $80808080, eax );\n        jnz MightBeZero20;\n\n        mov( [esi+24], eax );\n        and( $7f7f7f7f, eax );\n        sub( $01010101, eax );\n        and( $80808080, eax );\n        jnz MightBeZero24;\n\n        mov( [esi+28], eax );\n        and( $7f7f7f7f, eax );\n        sub( $01010101, eax );\n        and( $80808080, eax );\n        jz ZeroLoop;\n\n    // The following code handles the case where we found a $80\n    // or a $00 byte. We need to determine whether it was a 0\n    // byte and the exact position of the 0 byte. If it was a\n    // $80 byte, then we've got to continue processing characters\n    // in the string.\n\n    // Okay, we've found a $00 or $80 byte in positions\n    // 28..31\\. Check for the location of the 0 byte, if any.\n\n        add( 28, esi );\n        jmp MightBeZero0;\n\n    // If we get to this point, we've found a 0 byte in\n    // positions 4..7:\n\n    MightBeZero4:\n        add( 4, esi );\n        jmp MightBeZero0;\n\n    // If we get to this point, we've found a 0 byte in\n    // positions 8..11:\n\n    MightBeZero8:\n        add( 8, esi );\n        jmp MightBeZero0;\n\n    // If we get to this point, we've found a 0 byte in\n    // positions 12..15:\n\n    MightBeZero12:\n        add( 12, esi );\n        jmp MightBeZero0;\n\n    // If we get to this point, we've found a 0 byte in\n    // positions 16..19:\n\n    MightBeZero16:\n        add( 16, esi );\n        jmp MightBeZero0;\n\n    // If we get to this point, we've found a 0 byte in\n    // positions 20..23:\n\n    MightBeZero20:\n        add( 20, esi );\n        jmp MightBeZero0;\n\n    // If we get to this point, we've found a 0 byte in\n    // positions 24..27:\n\n    MightBeZero24:\n        add( 24, esi );\n\n    // If we get to this point, we've found a 0 byte in\n    // positions 0..3 or we've branched here from one of the\n    // above conditions\n\n    MightBeZero0:\n        mov( [esi], eax );          // Get the original 4 bytes.\n        cmp( al, 0 );               // See if the first byte contained 0.\n        je SetESI;\n        cmp( ah, 0 );               // See if the second byte contained 0.\n        je SetESI1;\n        test( $FF_0000, eax );      // See if byte #2 contained a 0.\n        je SetESI2;\n        test( $FF00_0000, eax );    // See if the HO byte contained 0.\n        je SetESI3;\n\n    // Well, it must have been a $80 byte we encountered.\n    // (Fortunately, they are rare in ASCII strings, so all this\n    // extra computation rarely occurs). Jump back into the 0\n    // loop and continue processing.\n\n        add( 4, esi );              // Skip bytes we just processed.\n        jmp ZeroLoop2;              // Don't bother adding 32 in the ZeroLoop!\n\n    // The following computes the length of the string by subtracting\n    // the current ESI value from the original value and then adding\n    // 0, 1, 2, or 3, depending on where we branched out\n    // of the MightBeZero0 sequence above.\n\n    SetESI3:\n        sub( zstrp, esi );          // Compute length\n        lea( eax, [esi+3] );        // +3 since it was in the HO byte.\n        pop( esi );\n        ret(4);\n\n    SetESI2:\n        sub( zstrp, esi );          // Compute length\n        lea( eax, [esi+2] );        // +2 since zero was in byte #2\n        pop( esi );\n        ret(4);\n\n    SetESI1:\n        sub( zstrp, esi );          // Compute length\n        lea( eax, [esi+1] );        // +1 since zero was in byte #1\n        pop( esi );\n        ret(4);\n\n    SetESI:\n        mov( esi, eax );\n        sub( zstrp, eax );          // Compute length. No extra addition since\n        pop( esi );                 // 0 was in LO byte.\n        ret( _parms_ );\n\nend len;\nend stringUnit;\n```", "```\n\n\t\t\t#include <string.h>\n#include <stdio.h>\n\nint main( int argc, char **argv )\n{\n    char localStr[256];\n\n    strcpy( localStr, \"Hello World\" );\n    printf( localStr );\n    return 0;\n}\n```", "```\n\n\t\t\t; Storage for the literal string appearing in the\n; strcpy invocation:\n\n_DATA   SEGMENT\n$SG6874 DB  'Hello World', 00H\n_DATA   ENDS\n\n_TEXT   SEGMENT\nlocalStr$ = 32\n__$ArrayPad$ = 288\nargc$ = 320\nargv$ = 328\nmain    PROC\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 6\n$LN4:\n    sub rsp, 312                ; 00000138H\n    mov rax, QWORD PTR __security_cookie\n    xor rax, rsp\n    mov QWORD PTR __$ArrayPad$[rsp], rax\n; Line 9\n    movsd   xmm0, QWORD PTR $SG6874\n; Line 10\n    lea rcx, QWORD PTR localStr$[rsp]\n    mov eax, DWORD PTR $SG6874+8\n    movsd   QWORD PTR localStr$[rsp], xmm0\n    mov DWORD PTR localStr$[rsp+8], eax\n    call    printf\n; Line 11\n    xor eax, eax\n; Line 12\n    mov rcx, QWORD PTR __$ArrayPad$[rsp]\n    xor rcx, rsp\n    call    __security_check_cookie\n    add rsp, 312                ; 00000138H\n    ret 0\nmain    ENDP\n_TEXT   ENDS\n```", "```\n\n\t\t\tsize_t strcspn( char *source, char *cset );\n```", "```\n\n\t\t\tlen = strcspn( SomeString, \"a\" );\n```", "```\n\n\t\t\tlen = 0;\nwhile\n(\n        SomeString[ len ] != '\\0'\n    &&  SomeString[ len ] != 'a'\n){\n    ++len;\n}\n```", "```\n\n\t\t\tlen = 0;\nfor(;;) // Infinite loop\n{\n    ch = SomeString[ len ];\n    if( ch == '\\0' ) break;\n    for( i=0; i<strlen( cset ); ++i )\n    {\n        if( ch == cset[i] ) break;\n    }\n    if( ch == cset[i] ) break;\n    ++len;\n}\n```", "```\n\n\t\t\tfor( i=0; i<strlen( cset ); ++i )\n{\n    if( ch == cset[i] ) break;\n}\n```", "```\n\n\t\t\t; Line 10\n        mov     DWORD PTR i$1[rsp], 0 ;for(i = 0;...;...)\n        jmp     SHORT $LN4@main\n\n$LN2@main:\n        mov     eax, DWORD PTR i$1[rsp] ;for(...;...;++i)\n        inc     eax\n        mov     DWORD PTR i$1[rsp], eax\n\n$LN4@main: ;for(...; i < strlen(localStr);...)\n        movsxd  rax, DWORD PTR i$1[rsp]\n        mov     QWORD PTR tv65[rsp], rax\n        lea     rcx, QWORD PTR localStr$[rsp]\n        call    strlen\n        mov     rcx, QWORD PTR tv65[rsp]\n        cmp     rcx, rax\n        jae     SHORT $LN3@main\n; Line 12\n        movsx   eax, BYTE PTR ch$[rsp]\n        movsxd  rcx, DWORD PTR i$1[rsp]\n        movsx   ecx, BYTE PTR localStr$[rsp+rcx]\n        cmp     eax, ecx\n        jne     SHORT $LN5@main\n        jmp     SHORT $LN3@main\n$LN5@main:\n; Line 13\n        jmp     SHORT $LN2@main\n$LN3@main:\n```", "```\n\n\t\t\tslen = strlen( cset );\nlen = 0;\nfor(;;) // Infinite loop\n{\n    ch = SomeString[ len ];\n    if( ch == '\\0' ) break;\n    for( i=0; i<slen; ++i )\n    {\n        if( ch == cset[i] ) break;\n    }\n    if( ch == cset[i] ) break;\n    ++len;\n}\n```", "```\n\n\t\t\tchar *strdup( char *src )\n{\n    char *result;\n\n    result = malloc( strlen( src ) + 1 );\n    assert( result != NULL ); // Check malloc check\n    strcpy( result, src );\n    return result;\n}\n```", "```\n\n\t\t\tlen = strlen( someStr );\nif( len == 0 )\n{\n    newStr = NULL;\n}\nelse\n{\n    newStr = strdup( someStr );\n}\n```", "```\n\n\t\t\tchar *strduplen( char *src, size_t len)\n{\n    char *result;\n\n    // Allocate storage for new string:\n\n    result = malloc( len + 1 );\n    assert( result != NULL );\n\n    // Copy the source string and\n    // 0 byte to the new string:\n\n    memcpy( result, src, len+1 );\n    return result;\n}\n```", "```\n\n\t\t\t#macro sbs( s );\n\n    // Grab all but the last character of the string:\n\n    (@substr( s, 0, @length(s) - 1) +\n\n        // Concatenate the last character\n        // with its HO bit set:\n\n        char\n        (\n            uns8\n            (\n               char( @substr( s, @length(s) - 1, 1))\n            ) | $80\n        )\n    )\n#endmacro\n    .\n    .\n    .\nbyte sbs( \"Hello World\" );\n```", "```\n\n\t\t\tstatic\n    s :string := \"Hello World\";\n        .\n        .\n        .\n// Move the address of 'H' in\n// \"Hello World\" into esi.\n\nmov( s, esi );\n\n// Puts length of string\n// (11 for \"Hello World\") into ECX.\n\nmov( [esi-4], ecx );\n        .\n        .\n        .\nmov( s, esi );\n\n// See if value in ECX exceeds the\n// maximum string length.\n\ncmp( ecx, [esi-8] );\njae StringOverflow;\n```", "```\n\n\t\t\t// Get the source string pointer into ESI,\n// and the destination pointer into EDI.\n    mov( dest, edi );\n    mov( src, esi );\n\n    // Get the length of the source string\n    // and make sure that the source string\n    // will fit in the destination string.\n\n    mov( [esi-4], ecx );\n\n    // Save as the length of the destination string.\n\n    mov( ecx, [edi-4] );\n\n    // Add 1 byte to the length so we will\n    // copy the 0 byte. Also compute the\n    // number of dwords to copy (rather than bytes).\n    // Then copy the data.\n\n    add( 4, ecx );  // Adds one, after division by 4.\n    shr( 2, ecx );  // Divides length by 4\n    rep.movsd();    // Moves length/4 dwords\n```", "```\nsomeCFunc( hlaStringVar );\n```", "```\n\n\t\t\ttype\n    dString = record\n        curLength  :integer;\n        strData    :^char;\n    end;\n```", "```\n\n\t\t\t(* Pascal static string example *)\n\nvar\n    //Max length will always be 255 characters.\n\n    pascalString :string[255];\n```", "```\n\n\t\t\t// C/C++ static string example:\n\n//Max length will always be 255 characters (plus 0 byte).\n\nchar cString[256];\n```", "```\naLengthPrefixedString := 'Hello World';\n```", "```\n\n\t\t\t(* Copy the characters in the string *)\n\n    for i:= 1 to length( HelloWorldLiteralString ) do begin\n\n        aLengthPrefixedString[ i ] :=\n            HelloWorldLiteralString[ i ];\n\n    end;\n\n    (* Set the string's length *)\n\n    aLengthPrefixedString[0] :=\n        char( length( HelloWorldLiteralString ));\n```", "```\n\n\t\t\tchar *\nstrncpy( char* dest, char *src, int max )\n{\n    char *result = dest;\n    while( max > 0 )\n    {\n        *dest = *src++;\n        if( *dest++ == '\\0') break;\n        --max;\n    }\n    return result;\n}\n```", "```\n\n\t\t\tstrncpy( substring, fullString + start, length );\nsubstring[ length ] = '\\0';\n```", "```\n\n\t\t\t// Assumption: \".strData\" field is char*\n\n    substring.strData = fullString.strData + start;\n    substring.curLength = length;\n```", "```\n\n\t\t\timport Foundation\nlet charToPrintName  :String = \"A\"      // Print name of this character\n\nlet unicodeName =\n    String(charToPrintName).applyingTransform(\n        StringTransform(rawValue: \"Any-Name\"),\n        reverse: false\n    )! // Forced unwrapping is legit here because it always succeeds.\nprint( unicodeName )\n\nOutput from program:\n\\N{LATIN CAPITAL LETTER A}\n```", "```\n\n\t\t\timport Foundation\nlet eAccent  :String = \"e\\u{301}\"\nprint( eAccent )\nprint( \"eAccent.count=\\(eAccent.count)\" )\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\nprint( eAccent )\n```", "```\nprint( \"eAccent.count=\\(eAccent.count)\" )\n```", "```\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\n\n\t\t\timport Foundation\nlet eAccent  :String = \"e\\u{301}\\u{301}\"\nprint( eAccent )\nprint( \"eAccent.count=\\(eAccent.count)\" )\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\nprint( eAccent )\n```", "```\nprint( \"eAccent.count=\\(eAccent.count)\" )\n```", "```\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\n\n\t\t\timport Foundation\nlet eAccent  :String = \"\\u{E9}\"\nprint( eAccent )\nprint( \"eAccent.count=\\(eAccent.count)\" )\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\n\n\t\t\té\n1\n1\n```", "```\n\n\t\t\tlet eAccent1 :String = \"\\u{E9}\"\nlet eAccent2 :String = \"e\\u{301}\"\nlet eAccent3 :String = \"e\\u{301}\\u{301}\"\n```", "```\n\n\t\t\tlet chars: [Character] = [\n    \"\\u{1ECD}\\u{300}\",\n    \"\\u{F2}\\u{323}\",\n    \"\\u{6F}\\u{323}\\u{300}\",\n    \"\\u{6F}\\u{300}\\u{323}\"\n]\n```", "```\n\n\t\t\tprint(\"\\u{1ECD} + \\u{300} = \\u{1ECD}\\u{300}\")\nprint(\"\\u{F2} + \\u{323} = \\u{F2}\\u{323}\")\nprint(\"\\u{6F} + \\u{323} + \\u{300} = \\u{6F}\\u{323}\\u{300}\")\nprint(\"\\u{6F} + \\u{300} + \\u{323} = \\u{6F}\\u{300}\\u{323}\")\nprint( chars[0] == chars[1] ) // Outputs true\nprint( chars[0] == chars[2] ) // Outputs true\nprint( chars[0] == chars[3] ) // Outputs true\nprint( chars[1] == chars[2] ) // Outputs true\nprint( chars[1] == chars[3] ) // Outputs true\nprint( chars[2] == chars[3] ) // Outputs true\n```"]