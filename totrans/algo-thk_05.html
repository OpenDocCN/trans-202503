<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_151"/><span class="big">5</span><br/>GRAPHS AND BREADTH-FIRST SEARCH</h2>
<div class="image1"><img alt="Image" src="../images/common1.jpg"/></div>
<p class="noindenta">In this chapter, we’ll study three problems in which we’re asked to solve puzzles in the minimum number of moves. How quickly can a knight catch a pawn? How quickly can a student climb a rope in gym class? How cheaply can we translate a book written in one language to other target languages? Breadth-first search (BFS) is the unifying algorithm here. BFS dispatches these problems, and it applies more generally whenever we want to solve a puzzle with the minimum number of moves. Along the way, we’ll learn about graphs, a powerful way to model and solve problems that involve objects and connections between those objects.</p>
<h3 class="h3" id="lev32">Problem 1: Knight Chase</h3>
<p class="noindent">This is DMOJ problem <code>ccc99s4</code>.</p>
<h4 class="h4" id="sec65"><span epub:type="pagebreak" id="page_152"/><em>The Problem</em></h4>
<p class="noindent">This problem concerns two players, a pawn and a knight, playing a board game. (Don’t worry: you don’t need to know anything about chess.)</p>
<p class="indent">The board has <em>r</em> rows, with row 1 at the bottom and row <em>r</em> at the top. The board has <em>c</em> columns, with column 1 at the left and column <em>c</em> at the right.</p>
<p class="indent">The pawn and knight each start on their own square of the board. The pawn moves first, then the knight moves, then the pawn, then the knight, and so on, until the game ends. For each turn, a move must be made: remaining at the current square is not an option.</p>
<p class="indent">The pawn has no choice on what move to make: for each of its turns, it moves up one square.</p>
<p class="indent">The knight, by contrast, has up to eight choices for each move:</p>
<ul>
<li class="noindent">Up 1, right 2</li>
<li class="noindent">Up 1, left 2</li>
<li class="noindent">Down 1, right 2</li>
<li class="noindent">Down 1, left 2</li>
<li class="noindent">Up 2, right 1</li>
<li class="noindent">Up 2, left 1</li>
<li class="noindent">Down 2, right 1</li>
<li class="noindent">Down 2, left 1</li>
</ul>
<p class="indent">I say “up to eight choices,” not “exactly eight choices,” because moves that bring the knight outside of the board are not allowed. For example, if the board has 10 columns and the knight is in column 9, then no move that takes the knight two columns to the right is allowed.</p>
<p class="indent">The following diagram shows the knight’s available moves:</p>
<div class="bqparanc95">
<table class="allzz">
<colgroup>
<col style="width:14%"/>
<col style="width:14%"/>
<col style="width:14%"/>
<col style="width:14%"/>
<col style="width:14%"/>
<col style="width:15%"/>
<col style="width:15%"/>
</colgroup>
<tbody>
<tr>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
</tr>
<tr>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">f</td>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">e</td>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
</tr>
<tr>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">b</td>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">a</td>
<td class="barzz" style="vertical-align: top"/>
</tr>
<tr>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">K</td>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
</tr>
<tr>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">d</td>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">c</td>
<td class="barzz" style="vertical-align: top"/>
</tr>
<tr>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">h</td>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top">9</td>
<td class="barzz" style="vertical-align: top"/>
<td class="barzz" style="vertical-align: top"/>
</tr>
<tr>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
<td class="barzz" style="vertical-align: top"> </td>
</tr>
</tbody>
</table>
</div>
<p class="noindent">Here, the knight is represented as <code>K</code>, and each letter from <code>a</code> to <code>h</code> represents one of its possible moves.</p>
<p class="indent">The game ends when one of three things happens: the knight wins, the game is a stalemate (that is, a tie), or the knight loses.</p>
<p class="block"><strong>Win</strong>   The knight wins if the knight makes a move and lands on the same square as the pawn before the pawn reaches the top row. To win, the knight has to be the one to make the move; if the pawn makes a move and lands on the knight, this doesn’t count as the knight winning.</p>
<p class="block"><span epub:type="pagebreak" id="page_153"/><strong>Stalemate</strong>   The game is a stalemate if the knight makes a move and lands on the square above the pawn before the pawn reaches the top row. Again, the knight has to be the one to make this move; the only exception is that the game can start as a stalemate if the knight starts one square above the pawn.</p>
<p class="block"><strong>Loss</strong>   The knight loses if the pawn reaches the top row before the game otherwise ends. That is, if the pawn gets to the top row before the knight lands on the pawn or lands on the square above it, then the knight loses. Once the pawn reaches the top row, the knight is not allowed to move anymore.</p>
<p class="indent">The goal is to determine the best-case outcome for the knight and the number of knight moves required to produce that outcome.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The first line of input gives the number of test cases that will follow. Each test case consists of six lines:</p>
<ul>
<li class="noindent">The number of rows in the board, between 3 and 99</li>
<li class="noindent">The number of columns in the board, between 2 and 99</li>
<li class="noindent">The starting row of the pawn</li>
<li class="noindent">The starting column of the pawn</li>
<li class="noindent">The starting row of the knight</li>
<li class="noindent">The starting column of the knight</li>
</ul>
<p class="indent">It’s guaranteed that the pawn and knight will have different starting positions and that the knight starts at a position where it has at least one available move.</p>
<h5 class="h5">Output</h5>
<p class="noindent">For each test case, output a line with one of three messages:</p>
<ul>
<li class="noindent">If the knight can win, output <code>Win in <em>m</em> knight move(s).</code></li>
<li class="noindent">If the knight cannot win but can cause a stalemate, output <code>Stalemate in <em>m</em> knight move(s).</code></li>
<li class="noindent">If the knight cannot win or cause a stalemate, output <code>Loss in <em>m</em> knight move(s).</code></li>
</ul>
<p class="noindent">Here, <span class="codeitalic">m</span> is the minimum number of moves made by the knight.</p>
<p class="indent">The time limit for solving the test cases is one second.</p>
<h4 class="h4" id="sec66"><em>Moving Optimally</em></h4>
<p class="noindent">A true two-player game, such as tic-tac-toe or chess, gives each player a choice of what move to make next. However, here, only the knight has a choice. The pawn’s moves are all fixed, and we’ll know exactly where the pawn is at <span epub:type="pagebreak" id="page_154"/>all times. It’s a good thing, too, because this problem would be significantly more difficult if both players had choices.</p>
<p class="indent">There may be various ways for the knight to win or cause a stalemate. Suppose that the knight can win. Each way that the knight can win requires some number of moves; we want to identify the minimum number of moves.</p>
<h5 class="h5">Exploring the Board</h5>
<p class="noindent">Let’s explore a little through this input:</p>
<pre>1
7
7
1
1
4
6</pre>
<p class="noindent">The board for this test case has seven rows and seven columns. The pawn starts at row 1, column 1, and the knight starts at row 4, column 6.</p>
<p class="indent">Moving optimally, the knight can win here in three moves. The following diagram shows how the knight can do this:</p>
<div class="bqparanc95">
<table class="allczz">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>7</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>6</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">K2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">K1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">K3 P3</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">K</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">P2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">P1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">P</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"><strong>1</strong></td>
<td class="borderr" style="vertical-align: top"><strong>2</strong></td>
<td class="borderr" style="vertical-align: top"><strong>3</strong></td>
<td class="borderr" style="vertical-align: top"><strong>4</strong></td>
<td class="borderr" style="vertical-align: top"><strong>5</strong></td>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td style="vertical-align: top"><strong>7</strong></td>
</tr>
</tbody>
</table>
</div>
<p class="indent">Here, <code>K</code> is used for the knight’s starting position and <code>P</code> for the pawn’s starting position. <code>K1</code>, <code>K2</code>, and <code>K3</code> give the location of the knight after move 1, move 2, and move 3, respectively; <code>P1</code>, <code>P2</code>, and <code>P3</code> do likewise for the pawn.</p>
<p class="indent"><span epub:type="pagebreak" id="page_155"/>The coordinates (<em>x</em>, <em>y</em>) refer to row <em>x</em>, column <em>y</em>. As expected, the pawn simply marches up its column, from (1, 1), to (2, 1), to (3, 1), and finally to (4, 1). The knight, however, moves as follows:</p>
<ol>
<li class="noindent">Starting at (4, 6), it moves up one and left two to (5, 4). The pawn is at (2, 1).</li>
<li class="noindent">From (5, 4), it moves up one and left two to (6, 2). The pawn is at (3, 1).</li>
<li class="noindent">From (6, 2), it moves down two and left one to (4, 1). That’s where the pawn is!</li>
</ol>
<p class="indent">There are other ways for the knight to win. For example, here’s what can happen if the knight goofs off a little:</p>
<div class="bqparanc95">
<table class="allczz">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>7</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>6</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">K2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top">K4 P4</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">K1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">P3</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">K3</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">K</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">P2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">P1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">P</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"><strong>1</strong></td>
<td class="borderr" style="vertical-align: top"><strong>2</strong></td>
<td class="borderr" style="vertical-align: top"><strong>3</strong></td>
<td class="borderr" style="vertical-align: top"><strong>4</strong></td>
<td class="borderr" style="vertical-align: top"><strong>5</strong></td>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td style="vertical-align: top"><strong>7</strong></td>
</tr>
</tbody>
</table>
</div>
<p class="indent">The knight catches the pawn after four moves, not three. Though the knight still wins, this is <em>not</em> the fastest way that it can do so. We need to report a minimum of three moves here, not four.</p>
<p class="indent">Suppose that we had an algorithm to determine the minimum number of moves that the knight can take from its starting point to some destination. We could then determine the number of knight moves required to get to each pawn location; if the knight can get there at the same time as the pawn, then the knight wins. If the knight cannot win, then we could do similarly for stalemates. That is, we could determine the number of knight moves required to get to the square above each pawn location; if at any point the knight can land on the square above the pawn, we have a stalemate.</p>
<p class="indent">To design such an algorithm, we can explore the board from the knight’s starting point. There’s only one square on the board that is reachable in <span epub:type="pagebreak" id="page_156"/>zero moves: the knight’s starting point itself. From there, we can discover those squares that are reachable in one move. From those squares that are one move away, we can discover those squares that are reachable in two moves. We can use those squares reachable in two moves to find those reachable in three moves, and so on. We stop when we find the desired destination; at that point, we’ll know the minimum number of moves that it takes to get there.</p>
<p class="indent">Let’s demonstrate this procedure using the same test case as before: seven rows and seven columns, with the knight starting at (4, 6). (We’ll ignore the pawn for now.) To confirm our answer of three moves that we arrived at by hand, we’ll calculate the minimum number of moves for the knight to get from (4, 6) to (4, 1).</p>
<p class="indent">In the following diagrams, numbers in the squares indicate the minimum distance from the knight’s starting point. As mentioned above, the only square reachable in zero moves is the knight’s starting point itself, (4, 6). We’ll call this round 0 of the exploration:</p>
<div class="bqparanc95">
<table class="allczz">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>7</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>6</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"><strong>1</strong></td>
<td class="borderr" style="vertical-align: top"><strong>2</strong></td>
<td class="borderr" style="vertical-align: top"><strong>3</strong></td>
<td class="borderr" style="vertical-align: top"><strong>4</strong></td>
<td class="borderr" style="vertical-align: top"><strong>5</strong></td>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td style="vertical-align: top"><strong>7</strong></td>
</tr>
</tbody>
</table>
</div>
<p class="indent">From (4, 6), we try all eight possible moves to identify the squares reachable in one move. We can’t move up one and right two or down one and right two, because those would take us beyond the right edge of the board. That leaves six squares that are one move away. This is round 1:<span epub:type="pagebreak" id="page_157"/></p>
<div class="bqparanc95">
<table class="allczz">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>7</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>6</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"><strong>1</strong></td>
<td class="borderr" style="vertical-align: top"><strong>2</strong></td>
<td class="borderr" style="vertical-align: top"><strong>3</strong></td>
<td class="borderr" style="vertical-align: top"><strong>4</strong></td>
<td class="borderr" style="vertical-align: top"><strong>5</strong></td>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td style="vertical-align: top"><strong>7</strong></td>
</tr>
</tbody>
</table>
</div>
<p class="indent">We haven’t found (4, 1) yet, so we keep going. We explore from each of those six new squares that we discovered in round 1; that will yield the squares that are two moves away. For example, consider square (6, 5); the squares reachable from there are as follows:</p>
<ul>
<li class="noindent">Up 1, right 2: (7, 7)</li>
<li class="noindent">Up 1, left 2: (7, 3)</li>
<li class="noindent">Down 1, right 2: (5, 7)</li>
<li class="noindent">Down 1, left 2: (5, 3)</li>
<li class="noindent">Up 2, right 1: (which is not valid)</li>
<li class="noindent">Up 2, left 1: (which is not valid)</li>
<li class="noindent">Down 2, right 1: (4, 6)</li>
<li class="noindent">Down 2, left 1: (4, 4)</li>
</ul>
<p class="indent">These squares are two moves away from the starting point—except for (4, 6), whose value (0) we filled in before! Looking at all valid moves from all squares that are one move away brings us to round 2, the squares that are two moves away.<span epub:type="pagebreak" id="page_158"/></p>
<div class="bqparanc95">
<table class="allczz">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>7</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>6</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"><strong>1</strong></td>
<td class="borderr" style="vertical-align: top"><strong>2</strong></td>
<td class="borderr" style="vertical-align: top"><strong>3</strong></td>
<td class="borderr" style="vertical-align: top"><strong>4</strong></td>
<td class="borderr" style="vertical-align: top"><strong>5</strong></td>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td style="vertical-align: top"><strong>7</strong></td>
</tr>
</tbody>
</table>
</div>
<p class="indent">Notice that there cannot be any other squares that are two moves away. Every square that is two moves away must emanate from a square that is one move away, and we explored all possible moves from all possible squares that are one move away.</p>
<p class="indent">There is still no (4, 1), so we keep going. Exploring from all squares that are two moves away gives us round 3, the squares that are three moves away:</p>
<div class="bqparanc95">
<table class="allczz">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>7</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>6</strong></td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderbb" style="vertical-align: top">3</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderbb" style="vertical-align: top">2</td>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"><strong>1</strong></td>
<td class="borderr" style="vertical-align: top"><strong>2</strong></td>
<td class="borderr" style="vertical-align: top"><strong>3</strong></td>
<td class="borderr" style="vertical-align: top"><strong>4</strong></td>
<td class="borderr" style="vertical-align: top"><strong>5</strong></td>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td style="vertical-align: top"><strong>7</strong></td>
</tr>
</tbody>
</table>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_159"/>There we have it: square (4, 1) is filled in with a value of 3. It therefore takes a minimum of three moves to get from (4, 6) to (4, 1). Had we not found (4, 1) here, we’d continue: we could proceed to find squares that are four moves away, then five moves away, and so on.</p>
<p class="indent">This technique—finding all squares that are zero moves away, then one move away, then two moves away, and so on—is called <em>breadth-first search</em>, or BFS for short. The word <em>breadth</em> refers to a full range. BFS is so named because we explore the full range of what is reachable from each square before moving on to other squares. BFS is fast, memory efficient, and clean to implement. It’s an absolute power move to invoke BFS whenever you want the minimum distance from one location to another location. Let’s go for it!</p>
<h5 class="h5">Implementing Breadth-First Search</h5>
<p class="noindent">Let’s start with a couple of type definitions that clean up our code a little. First, each board position is composed of a row and a column, so let’s package those together using a struct:</p>
<pre>typedef struct position {
  int row, col;
} position;</pre>
<p class="indent">A board is a two-dimensional array, and we can make a type definition for that too. We’ll let it hold integers, which will correspond to numbers of moves. We have a maximum of 99 rows and 99 columns, but we allocate one extra row and column so we can start indexing rows and columns at <code>1</code>, not <code>0</code>:</p>
<pre>#define MAX_ROWS 99
#define MAX_COLS 99
 
typedef int board[MAX_ROWS + 1][MAX_COLS + 1];</pre>
<p class="indent">Finally, let’s make an array type for holding the positions that we discover during the BFS. We’ll make it big enough that it can hold every possible square on the board:</p>
<pre>typedef position positions[MAX_ROWS * MAX_COLS];</pre>
<p class="indent">Now we’re ready for the BFS itself. We need a function to determine the minimum number of knight moves to get from its starting point to some destination that we specify. (Recall that our plan is to find the minimum number of moves needed to catch the pawn at each pawn location.) Here’s the signature for the function we’ll implement:</p>
<pre>int find_distance(int knight_row, int knight_col,
                  int dest_row, int dest_col,
                  int num_rows, int num_cols)</pre>
<p class="indent">The parameters <code>knight_row</code> and <code>knight_col</code> give the starting location of the knight, and <code>dest_row</code> and <code>dest_col</code> give the desired destination. The parameters <code>num_rows</code> and <code>num_cols</code> give, respectively, the number of rows and <span epub:type="pagebreak" id="page_160"/>columns in the board; we’ll need those to determine whether a move is valid. The function returns the minimum number of moves for the knight to go from its starting location to the destination. If there’s no way for the knight to get to the destination, then we return <code>-1</code>.</p>
<p class="indent">There are two key arrays that drive the BFS:</p>
<p class="block"><span class="codestrong">cur_positions</span>   This array holds the positions discovered from the current round of BFS. For example, it might be all of the positions discovered in round 3.</p>
<p class="block"><span class="codestrong">new_positions</span>   This array holds the positions discovered in the next round of BFS. For example, if <code>cur_positions</code> holds the positions discovered in round 3, then <code>new_positions</code> will hold those positions discovered in round 4.</p>
<p class="indent">The code is given in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>.</p>
<pre>int find_distance(int knight_row, int knight_col,
                  int dest_row, int dest_col,
                  int num_rows, int num_cols) {
  positions cur_positions, new_positions;
  int num_cur_positions, num_new_positions;
  int i, j, from_row, from_col;
  board min_moves;
  for (i = 1; i &lt;= num_rows; i++)
    for (j = 1; j &lt;= num_cols; j++)
      min_moves[i][j] = -1;
<span class="ent">➊</span> min_moves[knight_row][knight_col] = 0;
<span class="ent">➋</span> cur_positions[0] = (position){knight_row, knight_col};
   num_cur_positions = 1;
 
<span class="ent">➌</span> while (num_cur_positions &gt; 0) {
     num_new_positions = 0;
     for (i = 0; i &lt; num_cur_positions; i++) {
       from_row = cur_positions[i].row;
       from_col = cur_positions[i].col;
     <span class="ent">➍</span> if (from_row == dest_row &amp;&amp; from_col == dest_col)
          return min_moves[dest_row][dest_col];
 
     <span class="ent">➎</span> add_position(from_row, from_col, from_row + 1, from_col + 2,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);
        add_position(from_row, from_col, from_row + 1, from_col - 2,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);
        add_position(from_row, from_col, from_row - 1, from_col + 2,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);<span epub:type="pagebreak" id="page_161"/>
        add_position(from_row, from_col, from_row - 1, from_col - 2,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);
        add_position(from_row, from_col, from_row + 2, from_col + 1,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);
        add_position(from_row, from_col, from_row + 2, from_col - 1,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);
        add_position(from_row, from_col, from_row - 2, from_col + 1,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);
        add_position(from_row, from_col, from_row - 2, from_col - 1,
                     num_rows, num_cols, new_positions,
                     &amp;num_new_positions, min_moves);
    }
 
  <span class="ent">➏</span> num_cur_positions = num_new_positions;
     for (i = 0; i &lt; num_cur_positions; i++)
       cur_positions[i] = new_positions[i];
  }
  return -1;
}</pre>
<p class="excap" id="ch05ex01"><em>Listing 5-1: The minimum number of knight moves using BFS</em></p>
<p class="indent">The first thing we do is clear out the <code>min_moves</code> array by setting all values to <code>-1</code>; this means that we have not yet computed the number of moves. The only square for which we know the minimum number of moves is the knight’s starting square, so we initialize that to <code>0</code> <span class="ent">➊</span>. That starting square is also the square that jump-starts the BFS <span class="ent">➋</span>. The <code>while</code> loop then runs as long as the most-recent round of BFS has discovered at least one new square <span class="ent">➌</span>. Inside the <code>while</code> loop, we look at each such square. If we discover the destination square <span class="ent">➍</span>, then we return its minimum number of moves. Otherwise, we keep exploring.</p>
<p class="indent">Exploring all eight moves from a given square is accomplished by eight calls to a helper function called <code>add_position</code>, which adds new squares to <code>new_positions</code> and updates <code>num_new_positions</code> accordingly. Focus on the first four arguments: those give the current row and column and the new row and column resulting from one of the eight moves. For example, the first call <span class="ent">➎</span> is for the move that goes up two and right one. We’ll look at the code for <code>add_position</code> shortly.</p>
<p class="indent">We’ve gone through each square in <code>cur_positions</code> and found new squares that are one more move away. That completes one round of BFS. To prepare for the next round, we keep track of the number of new squares <span class="ent">➏</span> and copy all of the new squares from <code>new_positions</code> to <code>cur_positions</code>. That way, the next iteration of the <code>while</code> loop uses those new squares and finds further new squares from there.</p>
<p class="indent"><span epub:type="pagebreak" id="page_162"/>If we reach the bottom of the code and haven’t found the destination square, then we return <code>-1</code>—that destination square is not reachable from the knight’s starting location.</p>
<p class="indent">Now for that <code>add_position</code> helper function; see <a href="ch05.xhtml#ch05ex02">Listing 5-2</a>.</p>
<pre>void add_position(int from_row, int from_col,
                  int to_row, int to_col,
                  int num_rows, int num_cols,
                  positions new_positions, int *num_new_positions,
                  board min_moves) {
  struct position new_position;
  if (to_row &gt;= 1 &amp;&amp; to_col &gt;= 1 &amp;&amp;
      to_row &lt;= num_rows &amp;&amp; to_col &lt;= num_cols &amp;&amp;
      min_moves[to_row][to_col] == -1) {
  <span class="ent">➊</span> min_moves[to_row][to_col] = 1 + min_moves[from_row][from_col];
     new_position = (position){to_row, to_col};
     new_positions[*num_new_positions] = new_position;
     (*num_new_positions)++;
  }
}</pre>
<p class="excap" id="ch05ex02"><em>Listing 5-2: Adding a position</em></p>
<p class="indent">The <code>if</code> statement has five conditions, all of which must be true for <code>to_row</code> and <code>to_col</code> to be a valid position: the row must be at least one, the column must be at least one, the row must be at most the number of rows, the column must be at most the number of columns, and . . . hmm, that last one, <code>min_moves[to_row][to_col] == -1</code>, what’s that doing?</p>
<p class="indent">That final condition is there to determine whether we’ve already seen this square. If we haven’t, then it will have a value of <code>-1</code> and we can go ahead and set its number of moves now. If it already has some other value, then it must have been discovered in an <em>earlier</em> round of BFS, and therefore it already has a smaller number of moves than what we could give it now. That is, a value other than <code>-1</code> means that the minimum number of moves is already set, and we shouldn’t mess with it.</p>
<p class="indent">If all five conditions pass, then we’ve discovered a new square. We discovered (<code>from_row</code>, <code>from_col</code>) in the previous round of BFS and <code>(to_row</code>, <code>to_col</code>) in the current round. Therefore, the minimum number of moves to (<code>to_row</code>, <code>to_col</code>) is one more than the minimum moves to (<code>from_row</code>, <code>from_col</code>) <span class="ent">➊</span>. By virtue of (<code>from_row</code>, <code>from_col</code>) coming from the previous round of BFS, we already have its value stored in <code>min_moves</code>, and so we can simply look up its value without recalculating it.</p>
<p class="indent">You may see shades of memoization and dynamic programming here. It’s true: BFS uses the same trick of looking stuff up rather than recomputing it. However, there’s not really a notion of maximizing or minimizing a solution based on subproblem solutions or combining smaller solutions to form a larger solution. Algorithm developers therefore generally don’t refer to BFS as a dynamic-programming algorithm, instead classifying it as a search or exploration algorithm.</p>
<h4 class="h4" id="sec67"><span epub:type="pagebreak" id="page_163"/><em>Best Knight Outcome</em></h4>
<p class="noindent">We’ve got BFS bottled up nicely as the <code>find_distance</code> function. Now let’s count the number of moves as the pawn marches up its column and use <code>find_distance</code> to determine whether the knight can ever land on the pawn. For example, if the pawn takes three moves to get somewhere, and the knight can take exactly three moves to get there too, then the knight wins in three moves. If the knight can’t win, then we can try a similar technique for stalemates: let the pawn march up its column again, this time checking whether the knight can cause a stalemate. If no stalemates are possible, well, then the knight loses. I’ve got this logic coded up in <a href="ch05.xhtml#ch05ex03">Listing 5-3</a>. The function <code>solve</code> takes six parameters: the starting row and column of the pawn, the starting row and column of the knight, and the numbers of rows and columns in the board. It prints one line of output corresponding to whether the knight wins, stalemates, or loses.</p>
<pre>// bugged!
void solve(int pawn_row, int pawn_col,
           int knight_row, int knight_col,
           int num_rows, int num_cols) {
   int cur_pawn_row, num_moves, knight_takes;
  
<span class="ent">➊</span> cur_pawn_row = pawn_row;
   num_moves = 0;
   while (cur_pawn_row &lt; num_rows) {
     knight_takes = find_distance(knight_row, knight_col,
                                  cur_pawn_row, pawn_col,
                                  num_rows, num_cols);
  <span class="ent">➋</span> if (knight_takes == num_moves) {
       printf("Win in %d knight move(s).\n", num_moves);
       return;
    }
    cur_pawn_row++;
    num_moves++;
  }
 
<span class="ent">➌</span> cur_pawn_row = pawn_row;
   num_moves = 0;
   while (cur_pawn_row &lt; num_rows) {
     knight_takes = find_distance(knight_row, knight_col,
                                  cur_pawn_row + 1, pawn_col,
                                  num_rows, num_cols);
     if (knight_takes == num_moves) {
       printf("Stalemate in %d knight move(s).\n", num_moves);
       return;
    }
    cur_pawn_row++;
    num_moves++;
<span epub:type="pagebreak" id="page_164"/>  }
 
<span class="ent">➍</span> printf("Loss in %d knight move(s).\n", num_rows - pawn_row - 1);
}</pre>
<p class="excap" id="ch05ex03"><em>Listing 5-3: The best outcome for the knight (bugged!)</em></p>
<p class="indent">Let’s get a grip on this code by studying it in three chunks.</p>
<p class="indent">The first chunk is the code that checks whether the knight can win. We begin by saving the pawn’s row in a new variable <span class="ent">➊</span>—we’ll mess with the pawn’s row to move the pawn up the board, so we need to remember the row in which it originally started. The <code>while</code> loop keeps going as long as the pawn hasn’t reached the top row. On each iteration, we calculate the number of moves that the knight needs to get to the same location as the pawn. If the knight can get there at the same time as the pawn <span class="ent">➋</span>, then the knight can win. If the knight can’t win, then the pawn will reach the top of the board and we’ll continue below the <code>while</code> loop.</p>
<p class="indent">That’s where the second chunk of code begins <span class="ent">➌</span>. Its task is to determine whether the knight can cause a stalemate. The code is the same as the first chunk, except that in the <code>while</code> loop it checks the number of moves required for the knight to land on the row above the pawn rather than the row of the pawn.</p>
<p class="indent">The third chunk is a single line <span class="ent">➍</span>, and it only executes if the knight cannot win or stalemate. This chunk simply outputs the loss message.</p>
<p class="indent">That’s how we process a single test case. To read and process all of the test cases, we need a little <code>main</code> function; it’s as simple as <a href="ch05.xhtml#ch05ex04">Listing 5-4</a>.</p>
<pre>int main(void) {
  int num_cases, i;
  int num_rows, num_cols, pawn_row, pawn_col, knight_row, knight_col;
  scanf("%d", &amp;num_cases);
  for (i = 0; i &lt; num_cases; i++) {
    scanf("%d%d", &amp;num_rows, &amp;num_cols);
    scanf("%d%d", &amp;pawn_row, &amp;pawn_col);
    scanf("%d%d", &amp;knight_row, &amp;knight_col);
    solve(pawn_row, pawn_col, knight_row, knight_col, num_rows, num_cols);
  }
  return 0;
}</pre>
<p class="excap" id="ch05ex04"><em>Listing 5-4: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">Feeling good? We’ve now got a complete solution. We’re using BFS to optimize the number of moves taken by the knight. We’re checking for knight wins, stalemates, and losses. Now submit this solution to the judge. Are you still feeling good?</p>
<h4 class="h4" id="sec68"><span epub:type="pagebreak" id="page_165"/><em>The Knight Flip-Flop</em></h4>
<p class="noindent">In earlier chapters, I hit you with some solutions that were correct but too slow to pass the test cases. In contrast, what I’ve provided here for the Knight Chase problem is <em>incorrect</em>: there are test cases for which we produce the wrong output. Our code happens to be unnecessarily slow, too.</p>
<p class="indent">Let’s fix it all!</p>
<h5 class="h5">Making Our Code Correct</h5>
<p class="noindent">Our code is incorrect because it does not consider that the knight can sometimes be too fast! That is, it can get to a pawn’s location before the pawn gets there. Testing for exactly the same number of pawn and knight moves is therefore too stringent.</p>
<p class="indent">A test case will clear this up:</p>
<pre>1
5
3
1
1
3
1</pre>
<p class="indent">This is a board with five rows and three columns; the pawn starts at row 1, column 1 and the knight starts at row 3, column 1. Here’s what our current code outputs for this test case:</p>
<pre>Loss in 3 knight move(s).</pre>
<p class="noindent">(The output is <code>3</code>, not <code>4</code>, because the knight is not allowed to move once the pawn reaches the top row.) This means that there is no win or stalemate location for which the minimum number of knight moves is the same as the number of pawn moves. That, at least, is true. However, it’s still possible for the knight to win here and to do so in two moves. Take some time to try to identify how the knight can do this!</p>
<p class="indent">There’s no way for the knight to win in one move if the pawn is at (2, 1). However, after two moves, the pawn is at (3, 1), and it’s possible for the knight to land on (3, 1) after two moves, too. Here’s what the knight can do:</p>
<ul>
<li class="noindent">Move 1: go from (3, 1) to (5, 2).</li>
<li class="noindent">Move 2: go from (5, 2) back to (3, 1).</li>
</ul>
<p class="indent">The minimum number of moves for the knight to get to (3, 1) is zero— it’s the knight’s starting point, after all. By going to some other square and returning, the knight can land on (3, 1) not only after zero moves but after two moves as well.</p>
<p class="indent">Here’s a self-check: change the knight’s starting point from (3, 1) to (5, 3). Can you figure out how the knight can win now in three moves?</p>
<p class="indent">Generalizing, we can say that if the knight can get to a square in a minimum of <em>m</em> moves, then it can also get to that square in <em>m</em> + 2 moves, or <em>m</em> + 4 <span epub:type="pagebreak" id="page_166"/>moves, and so on. All it has to do is keep going to some other square and returning.</p>
<p class="indent">What this means for our solution is that, at each step, there are two ways for the knight to win or stalemate: it can do so because its minimum number of moves matches the number of pawn moves or because its minimum number of moves is an even number larger than the number of pawn moves.</p>
<p class="indent">That is, instead of:</p>
<pre>if (knight_takes == num_moves) {</pre>
<p class="noindent">we need this:</p>
<pre>if (knight_takes &gt;= 0 &amp;&amp; num_moves &gt;= knight_takes &amp;&amp;
    (num_moves - knight_takes) % 2 == 0) {</pre>
<p class="indent">Here, we’re testing whether the difference between the number of pawn moves and the number of knight moves is a multiple of two.</p>
<p class="indent">There are two instances of the incorrect code in <a href="ch05.xhtml#ch05ex03">Listing 5-3</a>; changing both yields the (correct!) code in <a href="ch05.xhtml#ch05ex05">Listing 5-5</a>.</p>
<pre>void solve(int pawn_row, int pawn_col,
           int knight_row, int knight_col,
           int num_rows, int num_cols) {
  int cur_pawn_row, num_moves, knight_takes;
  
  cur_pawn_row = pawn_row;
  num_moves = 0;
  while (cur_pawn_row &lt; num_rows) {
    knight_takes = find_distance(knight_row, knight_col,
                                 cur_pawn_row, pawn_col,
                                 num_rows, num_cols);
  <span class="ent">➊</span> if (knight_takes &gt;= 0 &amp;&amp; num_moves &gt;= knight_takes &amp;&amp;
        (num_moves - knight_takes) % 2 == 0) {
      printf("Win in %d knight move(s).\n", num_moves);
      return;
    }
    cur_pawn_row++;
    num_moves++;
  }
 
  cur_pawn_row = pawn_row;
  num_moves = 0;
  while (cur_pawn_row &lt; num_rows) {
    knight_takes = find_distance(knight_row, knight_col,
                                 cur_pawn_row + 1, pawn_col,
                                 num_rows, num_cols);
  <span class="ent">➋</span> if (knight_takes &gt;= 0 &amp;&amp; num_moves &gt;= knight_takes &amp;&amp;
        (num_moves - knight_takes) % 2 == 0) {
      printf("Stalemate in %d knight move(s).\n", num_moves);
<span epub:type="pagebreak" id="page_167"/>      return;
    }
    cur_pawn_row++;
    num_moves++;
  }
 
  printf("Loss in %d knight move(s).\n", num_rows - pawn_row - 1);
}</pre>
<p class="excap" id="ch05ex05"><em>Listing 5-5: The best outcome for the knight</em></p>
<p class="indent">As promised, all we’ve done is change two conditions <span class="ent">➊ ➋</span>. Now the code passes the judge.</p>
<h5 class="h5">A Correctness Argument</h5>
<p class="noindent">If you’re suitably convinced of correctness, feel free to skip this section. Otherwise, I’d now like to address a possible concern that you may have at this point.</p>
<p class="indent">Suppose that the knight gets to a square an even number of moves ahead of the pawn and that this takes <em>m</em> moves. Also suppose that the knight leaves and revisits this square as many times as it likes, returning to this square after <em>m</em> + 2 moves, <em>m</em> + 4 moves, and so on, eventually catching the pawn here. It would be scary if the knight could use some other sequence of moves to catch the pawn in <em>m</em> + 1 moves, or <em>m</em> + 3 moves, and so on, because then adding an odd number of moves could provide us a better minimum than adding an even number of moves. Fortunately, that can’t happen.</p>
<p class="indent">Try this little experiment: choose a starting point and destination for the knight, and find the minimum number of moves that it takes for the knight to move from the starting point to the destination. That number of moves is <em>m</em>. Now try to find a way for the knight to get from that same starting point to that same destination using exactly one more move, or three more moves, and so on. For example, if the fastest way takes two moves, try to find a way to take three moves. You won’t be able to do so.</p>
<p class="indent">Each knight move changes the row or column number by two and the other by one. For example, it might change the row number from six to four and the column number from four to five. Changing a number by two does not change whether that number is even or odd, but changing a number by one <em>does</em> change that number from even to odd or vice versa. That is, in terms of being even or odd, each move leaves one of the two numbers (row or column) alone, and it changes the other one. When a number changes from even to odd or vice versa, we say that its <em>parity</em> changes.</p>
<p class="indent">Let <em>k</em> be an odd integer. Now we’re ready to see why the knight can’t take both <em>m</em> moves and <em>m</em> + <em>k</em> moves to get to the same destination. Suppose that the knight can take <em>m</em> moves to get to square <em>s</em>, that <em>m</em><sub>1</sub> of those moves change whether the row is even or odd, and that <em>m</em><sub>2</sub> of those moves change whether the column is even or odd.</p>
<p class="indent">Let’s say that <em>m</em><sub>1</sub> and <em>m</em><sub>2</sub> are both even. As such, the moves don’t change the parity of the row or column: if we start with some number and flip its <span epub:type="pagebreak" id="page_168"/>parity an even number of times, its parity doesn’t change. If we make some other sequence of moves, and it flips the parity of the row an odd number of times or flips the parity of the column an odd number of times, then that sequence cannot land at <em>s</em>, because it will land on a square with different row or column parity than <em>s</em>.</p>
<p class="indent">Now, <em>m</em>, the total number of moves <em>m</em><sub>1</sub> + <em>m</em><sub>2</sub>, is even: adding two even numbers gives an even number. But, <em>m</em> + <em>k</em> is odd, because it’s the sum of an even number and an odd number. And, since <em>m</em> + <em>k</em> is odd, it cannot be built from an even number of moves that change the row and an even number of moves that change the column; at least one of them must be odd and therefore change the parity of the row or column. This is why these <em>m</em> + <em>k</em> moves cannot result in the knight landing on <em>s</em>! (There are three other cases—<em>m</em><sub>1</sub> even and <em>m</em><sub>2</sub> odd, <em>m</em><sub>1</sub> odd and <em>m</em><sub>2</sub> even, and <em>m</em><sub>1</sub> odd and <em>m</em><sub>2</sub> odd—but I’ll skip those. Their analysis is similar.)</p>
<h4 class="h4" id="sec69"><em>A Time Optimization</em></h4>
<p class="noindent">Our current solution (<a href="ch05.xhtml#ch05ex05">Listing 5-5</a>) can make a lot of BFS calls. Each time the pawn moves up a row, we use BFS (by calling <code>find_distance</code>) to determine whether it can be caught there by the knight.</p>
<p class="indent">Suppose that the pawn starts at (1, 1). We run a BFS from the knight’s starting point to (1, 1), and that explores some of the squares. Suppose that the knight can’t catch the pawn here. We then have to run a BFS from the knight’s starting point to (2, 1). This explores some of the squares, too. However, (1, 1) and (2, 1) are very close together, to the point that the second BFS probably re-explores many of the squares whose shortest distances were discovered in the first BFS call. Unfortunately, each of our BFS calls is independent, so that second BFS call redoes a lot of the work that the first BFS call did. The third call then duplicates a lot of what the prior two BFS calls did, and on and on.</p>
<p class="indent">It’s true that BFS is fast, and I’ll give more details on why in the next section. Still, it pays to try to reduce the number of invocations of BFS.</p>
<p class="indent">I have good news: we can reduce the number of BFS calls to just . . . one! Recall our BFS code in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>. We had code <span class="ent">➍</span> to cut our BFS short if we found the target position. However, if this code is removed, then the BFS will explore the entire board, calculating the shortest distance to each square. Making that change means that we can make one call to BFS and then be done with it. From then on, we just look up what we need in the <code>min_moves</code> array.</p>
<p class="indent">Do it! Make the required changes to the code so that BFS is called only one time.</p>
<p class="indent">The code we worked through together takes 0.1 seconds when I submit to the judge. With the “only one invocation of BFS” optimization, the code takes only 0.02 seconds, a speedup of 500 percent. More importantly, this optimization shows that BFS can be used not only to find the shortest distance from a starting position to some other position, but also to find the distance from the starting position to <em>all</em> other positions. I’ll discuss BFS a <span epub:type="pagebreak" id="page_169"/>little more in the next section. And keep reading after that, because I think the flexibility of BFS is going to surprise you.</p>
<h3 class="h3" id="lev33">Graphs and BFS</h3>
<p class="noindent">BFS is a powerful search algorithm, as we saw in the solution to the Knight Chase problem. To run a BFS, we need what’s called a <em>graph</em>. We didn’t think about graphs when solving the Knight Chase problem—or perhaps didn’t know what they were!—but there was indeed a graph underlying the BFS.</p>
<h4 class="h4" id="sec70"><em>What Are Graphs?</em></h4>
<p class="noindent"><a href="ch05.xhtml#ch05fig01">Figure 5-1</a> is our first example of a graph.</p>
<div class="image"><img alt="Image" id="ch05fig01" src="../images/ch05fig01.jpg"/></div>
<p class="figcap"><em>Figure 5-1: A graph of knight moves</em></p>
<p class="indent">Like a tree, a graph consists of <em>nodes</em> (the boxes) and <em>edges</em> between nodes (the lines). In this graph, the edges represent valid knight moves. For example, from the (5, 1) node, the knight can move on an edge to (4, 3) or on an edge to (3, 2). There are no other edges involving (5, 1), so there are no other knight moves from there.</p>
<p class="indent">Now I can explain how we implicitly used a graph to solve the Knight Chase problem. Suppose that (5, 1) is the knight’s starting position. Our BFS tries all eight moves from there, but six of them lead to a position that is outside of the board; in graph terminology, six of them are not edges from (5, 1). The BFS discovers the two nodes that <em>are</em> reachable on an edge from (5, 1): (4, 3) and (3, 2). The exploration then continues with the nodes reachable from each of these two nodes, and so on.</p>
<p class="indent">I laid the graph out as a grid to reflect the underlying board, but the way that a graph is drawn carries no meaning. All that matters are the nodes and edges. I could have drawn the graph with the nodes chaotically spread <span epub:type="pagebreak" id="page_170"/>around, and it would have conveyed the same meaning. However, when the graph is rooted in some underlying geometry, it makes sense to display the graph in a corresponding way for easier interpretation.</p>
<p class="indent">To solve the Knight Chase problem, we didn’t need to explicitly represent the graph in code, because we figured out the available moves (edges) from each node as we explored the board. Sometimes, though, we do need to represent a graph explicitly in code, along the lines of our tree representations in <a href="ch02.xhtml">Chapter 2</a>. We’ll see how to do that in Problem 3.</p>
<h4 class="h4" id="sec71"><em>Graphs vs. Trees</em></h4>
<p class="noindent">Graphs and trees have a lot in common. They’re both used to represent relationships between nodes. In fact, every tree is a graph, but there are graphs that are not trees. Graphs are more general, and they can express more than what trees can express.</p>
<p class="indent">First, graphs (but not trees) allow cycles. We have a <em>cycle</em> in a graph if we can start from a node and get back to it without using any repeated edges or nodes. (The first and last nodes in the cycle are the only ones that repeat.) Look back at <a href="ch05.xhtml#ch05fig01">Figure 5-1</a>. Here’s a cycle in that graph: (5, 3) → (4, 5) → (3, 3) → (4, 1) → (5, 3).</p>
<p class="indent">Second, graphs (but not trees) can be <em>directed</em>. The trees and graph we’ve seen so far are <em>undirected</em>, meaning that if two nodes <em>a</em> and <em>b</em> are connected by an edge, then we can travel both from <em>a</em> to <em>b</em> and from <em>b</em> to <em>a</em>. The graph in <a href="ch05.xhtml#ch05fig01">Figure 5-1</a> is undirected; for example, we can move from (5, 3) on an edge to (4, 5) and use that same edge to move from (4, 5) to (5, 3). Sometimes, though, we want to allow travel in only one direction, not the other. A <em>directed</em> graph is a graph in which each edge indicates the allowed direction of travel. <a href="ch05.xhtml#ch05fig02">Figure 5-2</a> depicts a directed graph.</p>
<div class="image"><img alt="Image" id="ch05fig02" src="../images/ch05fig02.jpg"/></div>
<p class="figcap"><em>Figure 5-2: A directed graph</em></p>
<p class="indent">Note, in <a href="ch05.xhtml#ch05fig02">Figure 5-2</a>, how it’s possible to move from E to each of the other nodes, but it is not possible to move from any of those nodes to E. The edges are one-way edges.</p>
<p class="indent"><span epub:type="pagebreak" id="page_171"/>Directed graphs are useful whenever an undirected graph would lead to loss of information. In my Computer Science department, each course has one or more prerequisite courses. For example, we have a C Programming course, which requires that students have already taken our Software Design course. A directed edge Software Design → C Programming captures this relationship. Had we used an undirected edge, we’d still know that the courses were related, but we wouldn’t know the order in which the courses must be taken. <a href="ch05.xhtml#ch05fig03">Figure 5-3</a> shows a small prerequisite graph.</p>
<div class="image"><img alt="Image" id="ch05fig03" src="../images/ch05fig03.jpg"/></div>
<p class="figcap"><em>Figure 5-3: A graph of course prerequisites</em></p>
<p class="indent">The third thing that makes graphs more general than trees is that graphs can be <em>disconnected</em>. All trees and graphs we have seen to this point are <em>connected</em>, which means that you can get from any node to any other node. Now check out the disconnected graph in <a href="ch05.xhtml#ch05fig04">Figure 5-4</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_172"/><img alt="Image" id="ch05fig04" src="../images/ch05fig04.jpg"/></div>
<p class="figcap"><em>Figure 5-4: A graph of disconnected course prerequisites</em></p>
<p class="indent">It’s disconnected because, for example, you can’t follow a path from <em>Intro to Programming</em> to <em>World Prehistory</em>. Disconnected graphs are useful whenever a graph is naturally composed of separate pieces.</p>
<h4 class="h4" id="sec72"><em>BFS on Graphs</em></h4>
<p class="noindent">We can run BFS on an undirected graph (as we did for the Knight Chase problem) or a directed graph. The algorithm is the same: we go through the possible moves from the current node and explore them. BFS is known as a <em>shortest-path</em> algorithm: among all paths between a starting node and some other node, BFS gives us the shortest one in terms of the number of edges. As long as what we care about is minimizing the number of edges, it solves the <em>single-source shortest-paths</em> problem, since it finds shortest paths from a single source (or starting) node.</p>
<p class="indent">What we need to control to make BFS fast is not whether the graph is undirected or directed, but the number of times we invoke BFS and the number of edges in the graph. The runtime of a BFS call is proportional to the number of edges reachable from the starting node. That’s because BFS looks at each edge once to determine whether it leads to the discovery of a new node. We call BFS a linear-time algorithm, since it does work linear in the number of edges: if 5 edges takes 5 steps for BFS to explore it, then <span epub:type="pagebreak" id="page_173"/>10 edges will take 10 steps. We’ll use the number of edges to estimate the number of steps performed by BFS.</p>
<p class="indent">In the Knight Chase problem, we had a board with <em>r</em> rows and <em>c</em> columns. Each node has at most eight edges, so the board has at most 8<em>rc</em> edges in total. Therefore, running one BFS takes 8<em>rc</em> steps. For the biggest board, 99×99, this is fewer than 80,000 steps. If we call BFS on the order of <em>r</em> times, as can happen in <a href="ch05.xhtml#ch05ex05">Listing 5-5</a>, then we’re looking at 8<em>r</em><sup>2</sup><em>c</em> steps. Now the 99×99 board isn’t looking so good: it could take over 7 million steps. This is why it helps so much to reduce the number of calls of BFS!</p>
<p class="indent">Any time a problem involves a set of objects (board locations, courses, people, websites, and so on) and relationships between those objects, it’s a good bet that modeling the problem as a graph will help. Once you model a problem as a graph, you can take advantage of a huge number of fast algorithms on graphs. BFS is one of those algorithms.</p>
<h4 class="h4" id="sec73"><em>Graphs vs. Dynamic Programming</em></h4>
<p class="noindent">Sometimes it can be difficult to determine whether to use dynamic programming or a graph to solve a problem. The giveaway is often the presence of a cycle: if you have a cycle, then you need a graph.</p>
<p class="indent">None of the problems that we solved in <a href="ch03.xhtml">Chapter 3</a> or <a href="ch04.xhtml">Chapter 4</a> had a cycle. In Burger Fervor we recursed with fewer minutes. In Moneygrubbers we recursed with fewer needed apples. In Hockey Rivalry we recursed with fewer games. We always go down—there’s no way to loop back to a higher number of minutes or apples or games to cause a cycle.</p>
<p class="indent">It’s trickier to see that this is true for The Jumper in <a href="ch04.xhtml">Chapter 4</a>, but it is. Think back to our forward formulation. If we jump to the right, then we recurse with a bigger jump distance. If we jump to the left, then we recurse with the same jump distance but a smaller-numbered square. There’s no way to start at a given subproblem and get back to it using these jumps. You might try to do that by making some jumps to the left and then making a jump to the right—but your jump to the right will have increased the jump distance by one and there’s no way to decrease it by one ever again.</p>
<p class="indent">No cycle!</p>
<h3 class="h3" id="lev34">Problem 2: Rope Climb</h3>
<p class="noindent">In the Knight Chase problem, we were explicitly given a board on which a game takes place. Here, we won’t be given the board directly, so we’ll have to work it out. Again, the strategy will be to model valid moves using BFS.</p>
<p class="indent">This is DMOJ problem <code>wc18c1s3</code>.</p>
<h4 class="h4" id="sec74"><em>The Problem</em></h4>
<p class="noindent">Bob is asked to climb a rope in gym class. The rope is infinitely long, but Bob is being asked to get only to a height of at least <em>h</em> meters.</p>
<p class="indent"><span epub:type="pagebreak" id="page_174"/>Bob starts at a height of 0. He knows how to jump up by exactly <em>j</em> meters, but that’s the only jump he knows how to do—so if <em>j</em> is <code>5</code>, then he can’t jump up four or six meters or any other number of meters except five. In addition, Bob knows how to fall, and he can fall down any number of meters: one, two, three, and so on.</p>
<p class="indent">Each jump or fall counts as one move. For example, if Bob jumps up five meters, falls down two meters, jumps up five meters, and falls down eight meters, then Bob will have made four moves.</p>
<p class="indent">Now, here’s the fun part: Alice has spread itching powder on some segments of the rope. If such a segment goes from height <em>a</em> to height <em>b</em>, then the entire segment from <em>a</em> to <em>b</em>, including the endpoints <em>a</em> and <em>b</em>, has itching powder. The effect that the itching powder has on Bob’s moves is as follows:</p>
<ul>
<li class="noindent">Bob cannot jump up <em>j</em> meters if that would land him on itching powder.</li>
<li class="noindent">Bob cannot fall down a given number of meters if that would land him on itching powder.</li>
</ul>
<p class="indent">The goal is to determine the minimum number of moves needed for Bob to get to height <em>h</em> or higher.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing three integers: <em>h</em>, <em>j</em>, and <em>n</em>. <em>h</em> tells us the minimum height that Bob must reach, <em>j</em> is the distance that Bob can jump up, and <em>n</em> is the number of segments on which Alice has spread itching powder. Each integer is at most 1,000,000, and <em>j</em> is at most <em>h</em>.</li>
<li class="noindent"><em>n</em> lines, each of which contains two integers. The first integer gives the starting height for a segment of rope with itching powder; the second gives the ending height. Each integer is at most <em>h</em> – 1.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">Output the minimum number of moves needed for Bob to reach height <em>h</em> or higher. If there is no way for Bob to reach height <em>h</em> or higher, output <code>-1</code>.</p>
<p class="indent">The time limit for solving the test case is 1.8 seconds.</p>
<h4 class="h4" id="sec75"><em>Solution 1: Finding the Moves</em></h4>
<p class="noindent">Let’s start by making direct comparisons to the Knight Chase problem. Notice in both cases that our goal is to minimize the number of moves. Whether it’s a knight on a board or Bob on a rope, the goal is the same. It’s true that the knight was moving around a two-dimensional board and Bob is moving around a one-dimensional rope, but that just changes how we’ll refer to each position. BFS won’t otherwise care about the change from two dimensions to one. If anything, dropping one dimension simplifies things a little!</p>
<p class="indent">How about the number of possible moves from each position? The knight had at most eight of those. In contrast, the number of possible moves <span epub:type="pagebreak" id="page_175"/>Bob can make increases with his position. For example, if Bob is at a height of 4, and he can jump up by 5, then he has five possible moves: jump up by 5, fall down by 1, fall down by 2, fall down by 3, or fall down by 4. If Bob is at a height of 1,000, then he has 1,001 possible moves! So we’ll have to take Bob’s current position into account when determining the number of available moves.</p>
<p class="indent">What about the itching powder? Knight Chase doesn’t have anything resembling that. Let’s look at a test case to see what we’re up against here:</p>
<pre>10 4 1
8 9</pre>
<p class="indent">Bob has to get to a height of 10 or higher. He can jump up by four. So, if there were no itching powder, he’d be able to jump from a height of 0 to 4, then to 8, and then to 12. That’s three moves.</p>
<p class="indent">Bob can’t do that, though! He isn’t allowed to jump from 4 to 8, because there’s itching powder at a height of 8 (as the itching powder goes from 8 to 9). The solution, by factoring in the itching powder, is four moves. For example, Bob can jump from 0 to 4, then fall to 3, then jump to 7, and then jump to 11. That jump from 7 to 11 breezes right past the itching powder.</p>
<p class="indent">The move from 4 to 8 seems available based on Bob’s ability to jump up by four, but it is actually not available because of the itching powder. This isn’t so different than a knight move being unavailable because it would take the knight outside of the board. For those invalid knight moves, we detected them in the BFS and didn’t add them to the next round of positions. We’ll handle itching powder similarly: any move that would cause Bob to land on itching powder will be disallowed in our BFS code.</p>
<p class="indent">Speaking of those invalid knight moves that take the knight outside of the board, do we have to worry about that kind of thing here? The rope is infinitely long, so we won’t break any rules by letting Bob climb higher and higher. However, at some point we really do have to stop; otherwise, the BFS will forever be finding and exploring new positions. I’ll invoke the insight from Moneygrubbers in <a href="ch03.xhtml">Chapter 3</a> that helped us out of a very similar bind when buying apples. We said there that if we’re asked to buy 50 apples, then we should consider buying at most 149 apples, because each pricing scheme gives us at most 100 apples. Here, remember from the problem description that <em>j</em>, the distance that Bob jumps up, is at most <em>h</em>, the minimum target height. We shouldn’t let Bob get to height 2<em>h</em> or higher. Think about what it would mean the first time we got Bob to height 2<em>h</em> or higher. One move prior, Bob would have been at height 2<em>h</em> – <em>j</em> ≥ <em>h</em>, and that would have taken one move less than getting Bob to height 2<em>h</em>! Thus, getting Bob to height 2<em>h</em> or higher can’t be the fastest way to get him to at least height <em>h</em>.</p>
<h5 class="h5">Implementing Breadth-First Search</h5>
<p class="noindent">We’ll very closely follow what we did for the Knight Chase problem, making changes only when necessary. Back then, each knight position consisted of both a row and a column, so we created a struct to hold both of those pieces of information. Now, a position on a rope is just an integer, so we don’t <span epub:type="pagebreak" id="page_176"/>need a struct for that. We’ll make type definitions for the “board” and the positions discovered by BFS:</p>
<pre>#define SIZE 1000000
 
typedef int board[SIZE * 2];
typedef int positions[SIZE * 2];</pre>
<p class="indent">It may seem a little weird to call a rope a board, I suppose, but it serves the same purpose as the corresponding type definition in the Knight Chase problem, so let’s stick with it.</p>
<p class="indent">We’re eventually going to make a single call of BFS, and that call is going to calculate the minimum number of moves for Bob to get from a height of zero to each valid position. The code for the BFS is given in <a href="ch05.xhtml#ch05ex06">Listing 5-6</a>—compare this to the <code>find_distance</code> code in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>. (Especially, compare it to the code I hope you wrote after reading “A Time Optimization” on <a href="ch05.xhtml#sec69">page 168</a>.)</p>
<pre>void find_distances(int target_height, int jump_distance,
                    int itching[], board min_moves) {
  static positions cur_positions, new_positions;
  int num_cur_positions, num_new_positions;
  int i, j, from_height;
  for (i = 0; i &lt; target_height * 2; i++)
 <span class="ent">➊</span> min_moves[i] = -1;
  min_moves[0] = 0;
  cur_positions[0] = 0;
  num_cur_positions = 1;
 
  while (num_cur_positions &gt; 0) {
    num_new_positions = 0;
    for (i = 0; i &lt; num_cur_positions; i++) {
      from_height = cur_positions[i];
 
   <span class="ent">➋</span> add_position(from_height, from_height + jump_distance,
                   target_height * 2 - 1,
                   new_positions, &amp;num_new_positions,
                   itching, min_moves);
   <span class="ent">➌</span> for (j = 0; j &lt; from_height; j++)
        add_position(from_height, j,
                     target_height * 2 - 1,
                     new_positions, &amp;num_new_positions,
                     itching, min_moves);
    }
 
    num_cur_positions = num_new_positions;
    for (i = 0; i &lt; num_cur_positions; i++)
      cur_positions[i] = new_positions[i];
<span epub:type="pagebreak" id="page_177"/>  }
}</pre>
<p class="excap" id="ch05ex06"><em>Listing 5-6: Minimum number of moves for Bob using BFS</em></p>
<p class="indent">There are four parameters for this <code>find_distances</code> function:</p>
<p class="block"><span class="codestrong">target_height</span>   The minimum height that Bob must reach. It’s the <em>h</em> value from the test case.</p>
<p class="block"><span class="codestrong">jump_distance</span>   The distance that Bob can jump up. It’s the <em>j</em> value from the test case.</p>
<p class="block"><span class="codestrong">itching</span>   An array that indicates where itching powder is present. If <code>itching[i]</code>   is <code>0</code>, then there’s no itching powder at height <code>i</code>; otherwise, there is. (Looking ahead, we’ll have to build this array from the segments of itchy rope given in the test case. But we’ll be able to do that, and then we won’t have to worry about the particular segments themselves: we can just index this array.)</p>
<p class="block"><span class="codestrong">min_moves</span>   The board in which we’ll store the minimum number of moves to get to each position.</p>
<p class="indenta">As in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a> for Knight Chase, we initialize each position of the board to <code>-1</code> <span class="ent">➊</span>, which means that BFS hasn’t found this position yet. That initialization, as with any other manipulation of <code>board</code> here, indexes a one-dimensional (not two-dimensional!) array. Other than that, the structure is quite similar to the BFS code for Knight Chase.</p>
<p class="indent">There is, however, an interesting structural change to the code that adds positions. Bob has exactly one jump distance, so there’s only one jump move to consider <span class="ent">➋</span>: Bob starts at <code>from_height</code> and ends up, if it’s a valid position, at <code>from_height + jump_distance</code>. We can use <code>target_height * 2 - 1</code> to get the maximum height that Bob is allowed to reach. For falling down, we cannot hard-code Bob’s available moves; those moves depend on Bob’s current height. To handle that, we use a loop <span class="ent">➌</span> to consider all destination heights from 0 (the ground) up to but not including <code>from_height</code> (Bob’s current height). This loop is the only significant change from the Knight Chase BFS.</p>
<p class="indent">To wrap up our BFS code, we need to implement the <code>add_position</code> helper function. That code is given in <a href="ch05.xhtml#ch05ex07">Listing 5-7</a>.</p>
<pre>void add_position(int from_height, int to_height, int max_height,
                  positions new_positions, int *num_new_positions,
                  int itching[], board min_moves) {
  if (to_height &lt;= max_height &amp;&amp; itching[to_height] == 0 &amp;&amp;
      min_moves[to_height] == -1) {
    min_moves[to_height] = 1 + min_moves[from_height];
    new_positions[*num_new_positions] = to_height;
    (*num_new_positions)++;
  }
}</pre>
<p class="excap" id="ch05ex07"><em>Listing 5-7: Adding a position</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_178"/>Bob wants to move from <code>from_height</code> to <code>to_height</code>. This move is allowed if it passes three tests. First, Bob can’t be jumping above the maximum allowed height. Second, he can’t be jumping somewhere that has itching powder. Third, the <code>min_moves</code> board better not have already recorded a number of moves for <code>to_height</code>: if a value is already in there, then it has a faster way to get to <code>to_height</code>. If we passed these tests, then we’ve found a new, valid position; we set the number of moves to get there and then store this as a position for the next round of BFS.</p>
<h5 class="h5">Finding the Best Height</h5>
<p class="noindent">There are many possibilities for Bob’s final position. It could be the target height <em>h</em> from the test case. However, depending on <em>j</em> and the itching powder, it could be higher than that. We know for each position the minimum number of moves to get there. What we have to do now is check all of the candidate positions, choosing the one that minimizes the number of moves. That code is given in <a href="ch05.xhtml#ch05ex08">Listing 5-8</a>.</p>
<pre>void solve(int target_height, board min_moves) {
<span class="ent">➊</span> int best = -1;
   int i;
   for (i = target_height; i &lt; target_height * 2; i++)
  <span class="ent">➋</span> if (min_moves[i] != -1 &amp;&amp; (best == -1 || min_moves[i] &lt; best))
      best = min_moves[i];
   printf("%d\n", best);
}</pre>
<p class="excap" id="ch05ex08"><em>Listing 5-8: The minimum number of moves</em></p>
<p class="indent">It’s possible that Bob can’t get to his target height, so we start <code>best</code> off with a value of <code>-1</code> <span class="ent">➊</span>. For each candidate height, we then check whether it’s possible for Bob to land there. If he can, and doing so is faster than our current minimum number of moves <code>best</code> <span class="ent">➋</span>, then we update <code>best</code> accordingly.</p>
<p class="indent">We’ve now got all the code to process a test case and output the result. All that’s left is to read the input. The <code>main</code> function in <a href="ch05.xhtml#ch05ex09">Listing 5-9</a> does that.</p>
<pre>int main(void) {
  int target_height, jump_distance, num_itching_sections;
  static int itching[SIZE * 2] = {0};
  static board min_moves;
  int i, j, itch_start, itch_end;
  scanf("%d%d%d", &amp;target_height, &amp;jump_distance, &amp;num_itching_sections);
  for (i = 0; i &lt; num_itching_sections; i++) {
    scanf("%d%d", &amp;itch_start, &amp;itch_end);
 <span class="ent">➊</span> for (j = itch_start; j &lt;= itch_end; j++)
   <span class="ent">➋</span> itching[j] = 1;  
  }
  find_distances(target_height, jump_distance, itching, min_moves);
  solve(target_height, min_moves);
  <span epub:type="pagebreak" id="page_179"/>
  return 0;
}</pre>
<p class="excap" id="ch05ex09"><em>Listing 5-9: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">As is typical for large arrays, we have made <code>itching</code> and <code>min_moves</code> static. The elements of <code>itching</code> are initialized to <code>0</code>, which means that there is no itching powder yet on the rope. For each segment where there is itching powder on the rope, we loop through each integer in the range <span class="ent">➊</span> and set the corresponding element of <code>itching</code> to <code>1</code> <span class="ent">➋</span>. Once we’re done looping through the itchy segments, each index of <code>itching</code> tells us if the rope does (value <code>1</code>) or does not (value <code>0</code>) have itching powder there. We no longer care about the individual itchy segments themselves—we have all that we need in <code>itching</code>.</p>
<p class="indent">That’s it. We’ve got a solution that uses a single call of BFS. It’s time to submit to the judge. As some might say, Bob’s your uncle . . .</p>
<p class="indent">Or, hopefully he will be, but he’s not yet. Because you should receive a “Time-Limit Exceeded” error with this code.</p>
<h4 class="h4" id="sec76"><em>Solution 2: A Remodel</em></h4>
<p class="noindent">Let’s run test cases of increasing size to get a sense of how our runtime is growing. To simplify things, we won’t use any itching powder. Here’s the first test case:</p>
<pre>30000 5 0</pre>
<p class="indent">That’s a target height of at least 30,000, with a jump distance of 5. On my laptop, that takes about eight seconds. Now let’s double the target height:</p>
<pre>60000 5 0</pre>
<p class="indent">I’m looking at about 30 seconds here. That’s nearly four times longer than in the previous case. We’ve long blown past the 1.8-second time limit, but let’s do this one more time, doubling the target height again:</p>
<pre>120000 5 0</pre>
<p class="indent">That gives a glacially slow 130 seconds, approximately another fourfold increase from the previous test case. That is, it seems that doubling the input size leads to the runtime being multiplied by four. This isn’t as catastrophic as what we saw in “Solution 2: Memoization” when solving Burger Fervor in <a href="ch03.xhtml">Chapter 3</a>, but it’s clearly too slow.</p>
<h5 class="h5">Too Many Fall Edges</h5>
<p class="noindent">In “BFS on Graphs” on <a href="ch05.xhtml#sec72">page 172</a>, I warned that we need to keep two things in check when using BFS: the number of times we call BFS and the number of edges in the graph. We’re doing as well as possible with the number of BFS calls, as we only call BFS once. To further pursue a solution based on BFS, then, we need a way to reduce the number of edges in the graph.</p>
<p class="indent"><span epub:type="pagebreak" id="page_180"/>Let’s take a look at the graph for a small example shown in <a href="ch05.xhtml#ch05fig05">Figure 5-5</a>. We’ll then be able to extrapolate to larger examples and see why our code churrs and churrs.</p>
<div class="image"><img alt="Image" id="ch05fig05" src="../images/ch05fig05.jpg"/></div>
<p class="figcap"><em>Figure 5-5: A graph of Bob’s moves</em></p>
<p class="indent">The graph shows the available moves from a height of 0 to a height of 7, if we assume that Bob can jump up by 3. This is an example of a directed graph; notice, for example, that there is a move from 6 to 5 but not one from 5 to 6.</p>
<p class="indent">The graph contains jump edges that encode Bob’s possible jumps and fall edges that encode Bob’s possible falls. The jump edges go from the bottom to the top and the fall edges go from the top to the bottom. For example, the edge from a height of 0 to a height of 3 is a jump edge; the aforementioned edge from 6 to 5 is a fall edge.</p>
<p class="indent">The number of jump edges isn’t worrisome at all. We have at most one jump edge per node. If we have <em>n</em> nodes, then we have at most <em>n</em> jump edges. If we decide to model up to a height of 8 instead of 7, then we’d add only one new jump edge.</p>
<p class="indent">However, the fall edges proliferate at a much faster rate. Notice that there is one fall edge from a height of 1, two fall edges from 2, three fall edges from 3, and so on. That is, for a rope of height <em>h</em>, we have a total of 1 + 2 + 3 + . . . + <em>h</em> fall edges. If we want to know how many fall edges there are for a given rope height, we could add up the integers from 1 to that height. There is, however, a convenient formula that we can use instead to get the answer much faster. It’s <em>h</em>(<em>h</em> + 1)/2. For a rope height of 50, for example, we’d have 50(51)/2 = 1, 275 fall edges. For a rope height of two million, we’d have over two trillion fall edges.</p>
<p class="indent"><span epub:type="pagebreak" id="page_181"/>Back in <a href="ch01.xhtml">Chapter 1</a>, we saw a very similar formula in “Diagnosing the Problem” on <a href="ch01.xhtml#ch01lev1">page 9</a>, when we were counting pairs of snowflakes. Like that one, our formula here is quadratic, being <em>O</em>(<em>h</em><sup>2</sup>), and it’s this quadratic growth in fall edges that bests our algorithm.</p>
<h5 class="h5">Changing the Moves</h5>
<p class="noindent">If we’re going to reduce the number of edges in the graph, then we’re going to have to change the available moves that the graph encodes. We can’t change the rules of the actual game that Bob plays in gym class, but we <em>can</em> change the moves in our graph model of the game. Of course, we are only able to change the graph if a BFS on the new graph produces the same answer as a BFS on the old graph.</p>
<p class="indent">There’s an important lesson here. It’s tempting to map the available moves, one for one, from the real-world problem to the graph. We did that for Knight Chase and succeeded in solving the problem. While this might be tempting, it’s not a requirement. We can produce a different graph, one with a more desirable number of nodes or edges, as long as that graph can still give us the answer to the original problem.</p>
<p class="indent">Suppose that we want to fall some distance from a height of five meters. One possibility might be to fall four meters. Indeed, solving the problem as in Solution 1, there would be a fall edge from a height of 5 down to 1. However, another way to think of this fall is as four falls of one meter each. That is, we can think of Bob falling from 5 to 4, then falling to 3, then falling to 2, and then falling finally to 1. That is, I’m imagining that every fall edge would be exactly one meter long. No more fall edges like those from a height of 5 to 3, or 5 to 2, or 5 to 1, or 5 to 0. There would be just one fall edge from each node, bringing us one meter lower. This should drastically cut down on the number of fall edges!</p>
<p class="indent">We have to be careful, though. We can’t let each of these mini, one-meter falls count as a move. If Bob falls four meters, using four one-meter-fall edges, then we still have to count it as a single move, not four moves.</p>
<p class="indent">Imagine that we have two ropes (0 and 1), not one. Rope 0 is the rope that we’ve always had. Alice set it up. It might have itching powder. Rope 1 is new, devised by us, for the purposes of modeling. It has no itching powder. In addition, when Bob is on Rope 1, he’s not allowed to move upward.</p>
<p class="indent">When Bob wants to make a fall move, he will move from Rope 0 to Rope 1. He’ll stick with Rope 1, falling, for as long as he wants to fall. Then, at any point where there isn’t itching powder on Rope 0, he can end his fall by moving back to Rope 0. Specifically, we have the following moves now:</p>
<ul>
<li class="noindent">When Bob is on Rope 0, he has two possible moves: jump up by <em>j</em> meters or move over to Rope 1. Each costs one move.</li>
<li class="noindent">When Bob is on Rope 1, he has two possible moves: fall by one meter or move over to Rope 0. Each costs 0 moves. That’s right: these moves are free!</li>
</ul>
<p class="indent">Bob jumps up as before, using Rope 0. When he wants to fall, he moves to Rope 1 (that costs him one move), falls down Rope 1 as much as he likes <span epub:type="pagebreak" id="page_182"/>(that’s free), and then moves back to Rope 0 (that’s free, too). The whole fall, then, costs Bob just one move. Perfect—this is just as before! No one will know that we’re using two ropes instead of one.</p>
<p class="indent">Compare <a href="ch05.xhtml#ch05fig05">Figure 5-5</a>, with its mass of edges, to <a href="ch05.xhtml#ch05fig06">Figure 5-6</a>, which depicts the two-ropes maneuver.</p>
<div class="image"><img alt="Image" id="ch05fig06" src="../images/ch05fig06.jpg"/></div>
<p class="figcap"><em>Figure 5-6: A graph of Bob’s moves using two ropes</em></p>
<p class="indent">It’s true that we’ve doubled the number of nodes, but that’s okay: what we care about for BFS is not the number of nodes but the number of edges. On that front, we’re laughing. We have, at most, two edges leaving each node: on Rope 0, we have a jump edge and a move to Rope 1; on Rope 1, we have a fall edge and a move to Rope 0. That is, for height <em>h</em>, we have about 4<em>h</em> edges. That’s linear! We’ve avoided that messy quadratic <em>h</em><sup>2</sup> business.</p>
<p class="indent">I’ve annotated each edge here with whether it costs a move (1) or doesn’t (0). This is our first example of a <em>weighted</em> graph, where each edge is given a weight or cost.</p>
<h5 class="h5" id="ch05lev1z">Adding Positions</h5>
<p class="noindent">We’ve meandered our way back to a two-dimensional board. (Hello, Knight Chase!) We need one dimension for Bob’s height and the second for the rope that Bob is on. The standard terminology for that second dimension is a <em>state</em>. When Bob is on Rope 0, we’ll say he’s in state 0, and when Bob is on <span epub:type="pagebreak" id="page_183"/>Rope 1, we’ll say he’s in state 1. Let’s use “state” from now on instead of “rope.”</p>
<p class="indent">Here are the new <code>typedef</code>s:</p>
<pre>typedef struct position {
  int height, state;
} position;
 
typedef int board[SIZE * 2][2];
typedef position positions[SIZE * 4];</pre>
<p class="indent">Rather than start with <code>find_distances</code>, as we have been doing in this chapter, we’ll start with the <code>add_position</code> functions. Yes: functions, plural, because we’re going to encode each type of move as its own function. There are four types of moves: a jump up, a fall down, a move from State 0 to State 1, and a move from State 1 to State 0. Hence we’ll need four <code>add_position</code> functions.</p>
<h5 class="h5">Jumping Up</h5>
<p class="noindent">The code for following a jump edge is given in <a href="ch05.xhtml#ch05ex010">Listing 5-10</a>.</p>
<pre>void add_position_up(int from_height, int to_height, int max_height,
                     positions pos, int *num_pos,
                     int itching[], board min_moves) {
<span class="ent">➊</span> int distance = 1 + min_moves[from_height][0];
   if (to_height &lt;= max_height &amp;&amp; itching[to_height] == 0 &amp;&amp;
   <span class="ent">➋</span> (min_moves[to_height][0] == -1 ||
       min_moves[to_height][0] &gt; distance)) {
   min_moves[to_height][0] = distance;
   pos[*num_pos] = (position){to_height, 0};
   (*num_pos)++;
  }
}</pre>
<p class="excap" id="ch05ex010"><em>Listing 5-10: Adding a position: jumping up</em></p>
<p class="indent">This function involves jumping up from <code>from_height</code> to <code>to_height</code>. This kind of move is allowed only in state 0; whenever we index <code>min_moves</code>, we’ll therefore use <code>0</code> as the second index.</p>
<p class="indent">The code is similar to <a href="ch05.xhtml#ch05ex07">Listing 5-7</a>, but with a few important changes. First, I’ve changed the name of <code>new_positions</code> to <code>pos</code> and <code>num_new_positions</code> to <code>num_pos</code>. We’ll talk about the reason for this change to more generic parameter names after we’ve gone through the four functions.</p>
<p class="indent">Second, to facilitate comparison between the four functions, I’ve added a <code>distance</code> variable <span class="ent">➊</span> that indicates the number of moves it takes to get to <code>to_height</code> by using <code>from_height</code>. Here, it’s one more move than the minimum number of moves to <code>from_height</code>, because we pay one move for this jump.</p>
<p class="indent">Third and finally, I’ve changed the part of the if condition that checks whether we’ve found a new position <span class="ent">➋</span>. This is because a position might be discovered by an edge that counts as one move, but it could later be <span epub:type="pagebreak" id="page_184"/>rediscovered by an edge that doesn’t count as a move. We want to allow for the possibility that the minimum number of moves is updated and improved by one of those no-cost edges. (Jumping up is not a no-cost edge, so we don’t need this change here; but I’ve kept it in for consistency across the four functions.)</p>
<h5 class="h5">Falling Down</h5>
<p class="noindent">Let’s now take a look at the code for falling down given in <a href="ch05.xhtml#ch05ex011">Listing 5-11</a>.</p>
<pre>void add_position_down(int from_height, int to_height,
                       positions pos, int *num_pos,
                       board min_moves) {
<span class="ent">➊</span> int distance = min_moves[from_height][1];
   if (to_height &gt;= 0 &amp;&amp;
       (min_moves[to_height][1] == -1 ||
        min_moves[to_height][1] &gt; distance)) {
     min_moves[to_height][1] = distance;
     pos[*num_pos] = (position){to_height, 1};
     (*num_pos)++;
  }
}</pre>
<p class="excap" id="ch05ex011"><em>Listing 5-11: Adding a position: falling down</em></p>
<p class="indent">Falling down can only happen in state 1; that’s why the second index is <code>1</code> whenever we access <code>min_moves</code>. Also, there’s nothing to do with itching powder here. Bob can fall as much as he likes in State 1 and not have to worry about the itching powder. Finally, a crucial point about the calculated distance is that there’s no <code>+ 1</code> added <span class="ent">➊</span>!</p>
<p class="indent">Remember: this doesn’t count as a move.</p>
<h5 class="h5">Switching States</h5>
<p class="noindent">There are two more functions to go. First we have the function to move from State 0 to State 1 in <a href="ch05.xhtml#ch05ex012">Listing 5-12</a>.</p>
<pre>void add_position_01(int from_height,
                     positions pos, int *num_pos,
                     board min_moves) {
  int distance = 1 + min_moves[from_height][0];
  if (min_moves[from_height][1] == -1 ||
      min_moves[from_height][1] &gt; distance) {
    min_moves[from_height][1] = distance;
    pos[*num_pos] = (position){from_height, 1};
    (*num_pos)++;
  }
}</pre>
<p class="excap" id="ch05ex012"><em>Listing 5-12: Adding a position: moving from state 0 to state 1</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_185"/>Then we have the function to move from state 1 to state 0, shown in <a href="ch05.xhtml#ch05ex013">Listing 5-13</a>.</p>
<pre>void add_position_10(int from_height,
                     positions pos, int *num_pos,
                     int itching[], board min_moves) {
  int distance = min_moves[from_height][1];
  if (itching[from_height] == 0 &amp;&amp;
      (min_moves[from_height][0] == -1 ||
       min_moves[from_height][0] &gt; distance)) {
    min_moves[from_height][0] = distance;
    pos[*num_pos] = (position){from_height, 0};
    (*num_pos)++;
  }
}</pre>
<p class="excap" id="ch05ex013"><em>Listing 5-13: Adding a position: moving from state 1 to state 0</em></p>
<p class="indent">Moving from State 0 to State 1 costs one move, but moving from State 1 to State 0 does not. Also notice we’re only allowed to move from State 1 to State 0 if there’s no itching powder at that height. Without that check, we’d be allowed to stop a fall on a segment of the rope with itching powder, and that would be breaking the rules.</p>
<h5 class="h5">0-1 BFS</h5>
<p class="noindent">Now it’s time to incorporate the state into the <code>find_distances</code> code from <a href="ch05.xhtml#ch05ex06">Listing 5-6</a>. However, we had better be careful, lest we miscount the moves.</p>
<p class="indent">Here’s an example. I’ll use (<em>h</em>, <em>s</em>) to refer to Bob being at height <em>h</em> in state <em>s</em>. Suppose that Bob can jump up by three. Bob starts at (0, 0), and it takes zero moves to get there. Exploring from (0, 0), we will identify (0, 1) as a new position, and record that it takes one move to get there. It’ll be added to the positions for the next round of BFS. We’ll also find (3, 0) and similarly record that it takes one move to get there. That’s another position for the next round of BFS. That’s all standard BFS fare.</p>
<p class="indent">When exploring out of (3, 0), we’ll find the new positions (3, 1) and (6, 0). Both will be added to the next round of BFS, and both will be reachable in a minimum of two moves.</p>
<p class="indent">However, we need to be careful with position (3, 1). We know that (2, 1) is reachable from here, so it’s tempting to add it to the next round of BFS. If we did that, though, then we wouldn’t be doing BFS anymore. We are supposed to put positions in the next round of the BFS when they are exactly one move away from those in the current round. Is (2, 1) one more move away from (3, 1)? No! They are the same number of moves from (0, 0), because falling in State 1 is free.</p>
<p class="indent">That is, (2, 1) doesn’t go in the next round of BFS. It goes in the <em>current</em> round of BFS, right along with (3, 1) and everything else whose minimum moves is two.</p>
<p class="indent">In summary, whenever we move along an edge that costs us a move, we add the new position to the next round of BFS. That’s what we’ve always <span epub:type="pagebreak" id="page_186"/>done. However, when we move along an edge that is free, then we add it to the current round of BFS so that it can be processed along with the other positions whose distance is the same. This is why we moved away from <code>new_positions</code> and <code>num_new_positions</code> in the <code>add_position</code> functions in “Adding Positions” on <a href="ch05.xhtml#ch05lev1z">page 182</a>. Two of the functions will indeed add moves to the new positions, but the other two will add moves to the current positions.</p>
<p class="indent">This variant of BFS is called <em>0-1 BFS</em>, because it works on graphs whose edges cost zero moves or one move.</p>
<p class="indent">At last, it’s time for the BFS. Check it out in <a href="ch05.xhtml#ch05ex014">Listing 5-14</a>.</p>
<pre>void find_distances(int target_height, int jump_distance,
                    int itching[], board min_moves) {
  static positions cur_positions, new_positions;
  int num_cur_positions, num_new_positions;
  int i, j, from_height, from_state;
  for (i = 0; i &lt; target_height * 2; i++)
    for (j = 0; j &lt; 2; j++)
      min_moves[i][j] = -1;
  min_moves[0][0] = 0;
  cur_positions[0] = (position){0, 0};
  num_cur_positions = 1;
 
  while (num_cur_positions &gt; 0) {
    num_new_positions = 0;
    for (i = 0; i &lt; num_cur_positions; i++) {
      from_height = cur_positions[i].height;
      from_state = cur_positions[i].state;
 
    <span class="ent">➊</span> if (from_state == 0) {
         add_position_up(from_height, from_height + jump_distance,
                         target_height * 2 - 1,
                         new_positions, &amp;num_new_positions,
                         itching, min_moves);
         add_position_01(from_height, new_positions, &amp;num_new_positions,
                         min_moves);
       } else {
         add_position_down(from_height, from_height - 1,
                           cur_positions, &amp;num_cur_positions, min_moves);
         add_position_10(from_height,
                         cur_positions, &amp;num_cur_positions,
                         itching, min_moves);
       }
     }
 
     num_cur_positions = num_new_positions;
     for (i = 0; i &lt; num_cur_positions; i++)
       cur_positions[i] = new_positions[i];
  }
}</pre>
<p class="excap" id="ch05ex014"><span epub:type="pagebreak" id="page_187"/><em>Listing 5-14: The minimum number of moves for Bob using 0-1 BFS</em></p>
<p class="indent">The new code checks whether the current position is in State 0 or State 1 <span class="ent">➊</span>. In each case, there are two moves to consider. In State 0, the new positions (those for the next round of BFS) are used; in State 1, the current positions are used.</p>
<p class="indent">What about the <code>main</code> and <code>solve</code> functions? For <code>main</code>, we can use the same function from Solution 1. For <code>solve</code>, we just need to add State 0 whenever we index <code>min_moves</code>. If you make those changes and submit to the judge, you’ll see that we pass all tests with plenty of time to spare.</p>
<h3 class="h3" id="lev35">Problem 3: Book Translation</h3>
<p class="noindent">In the Knight Chase and Rope Climb problems, there was no explicit graph to read from the input; the BFS incrementally produced the graph as it explored. We’ll now see a problem where the graph is presented to us up front.</p>
<p class="indent">This is DMOJ problem <code>ecna16d</code>.</p>
<h4 class="h4" id="sec77"><em>The Problem</em></h4>
<p class="noindent">You have written a new book in English, and you want to get the book translated into <em>n</em> other target languages. You’ve found <em>m</em> translators. Each translator knows how to translate between exactly two languages and will do the translation at a given cost. For example, a translator may know how to translate between Spanish and Bengali at a cost of $1,800; this means that you could ask this translator to translate from Spanish to Bengali for $1,800 or Bengali to Spanish for $1,800.</p>
<p class="indent">To reach a given target language may require multiple translations. For example, you may want to translate your book from English to Bengali but have no translator between these two languages. You might instead have to translate from English to Spanish and then Spanish to Bengali.</p>
<p class="indent">To reduce the number of translation errors, you will minimize the number of translations needed to reach each target language. If there are multiple ways to achieve a minimum number of translations to a target language, then you will choose the cheapest one. Your goal is to minimize the number of translations to each target language; if there are multiple ways to do this, choose the one with minimum total cost.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing two integers <em>n</em> and <em>m</em>. <em>n</em> is the number of target languages; <em>m</em> is the number of translators. There are at most 100 target languages and at most 4,500 translators.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_188"/>
A line containing <em>n</em> strings, each naming a target language. <code>English</code> will not be a target language.</li>
<li class="noindent"><em>m</em> lines, each giving information for one translator. Each of these lines contains three space-separated tokens: a language, a second language, and the positive integer cost to translate between them. There is at most one translator per pair of languages.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">Output the minimum monetary cost to translate the book into all of the target languages, while minimizing the number of translations to each target language. If there is no way to translate the book into all of the target languages, output <code>Impossible</code>.</p>
<p class="indent">The time limit for solving the test case is 0.6 seconds.</p>
<h4 class="h4" id="sec78"><em>Reading the Language Names</em></h4>
<p class="noindent">Rather than use language names directly—English, Spanish, and so on—I’ll associate each language with an integer. English will be language 0, and each target language will be given a unique integer greater than 0. We can then work with integers from here on out, as we did for the other problems in this chapter.</p>
<p class="indent">There’s one annoyance here: the problem description does not tell us the maximum length of a language name. We therefore cannot hardcode some maximum language name length like 16 or even 100, because we have no control over the input. We therefore use a <code>read_word</code> helper function; see <a href="ch05.xhtml#ch05ex015">Listing 5-15</a>.</p>
<pre>/* based on https://stackoverflow.com/questions/16870485 */
char *read_word(int size) {
  char *str;
  int ch;
  int len = 0;
  str = malloc(size);
  if (str == NULL) {
    fprintf(stderr, "malloc error\n");
    exit(1);
  }  
<span class="ent">➊</span> while ((ch = getchar()) != EOF &amp;&amp; (ch != ' ') &amp;&amp; (ch != '\n')) {
     str[len++] = ch;
     if (len == size) {
       size = size * 2;
     <span class="ent">➋</span> str = realloc(str, size);
        if (str == NULL) {
          fprintf(stderr, "realloc error\n");
          exit(1);
      }
    }
<span epub:type="pagebreak" id="page_189"/>  }
<span class="ent">➌</span> str[len] = '\0';
   return str;
}</pre>
<p class="excap" id="ch05ex015"><em>Listing 5-15: Reading a word</em></p>
<p class="indent">The <code>read_word</code> function takes an initial size that we hope suffices for most or all of the language names. When we call the function, we will give an initial size of 16, because that covers most language names we’re likely to see. We can use <code>read_word</code> to read characters <span class="ent">➊</span> up until the array reaches its maximum length; if the array fills up and the language name still isn’t over, it then uses <code>realloc</code> to double the array’s length <span class="ent">➋</span>, thereby creating more space to read more characters. We’re careful to terminate <code>str</code> with a null character <span class="ent">➌</span>; otherwise, it wouldn’t be a valid string!</p>
<h4 class="h4" id="sec79"><em>Building the Graph</em></h4>
<p class="noindent">Now let’s turn to building a graph from the input. This will help us explore the allowable translations from each language.</p>
<p class="indent">Let’s work with a small test case:</p>
<pre>3 5
Spanish Bengali Italian
English Spanish 500
Spanish Bengali 1800
English Italian 1000
Spanish Italian 250
Bengali Italian 9000</pre>
<p class="indent">Can you construct the graph? What are the nodes and what are the edges? Is it undirected or directed? Is it unweighted or weighted?</p>
<p class="indent">As always, the edges encode the allowed moves; here, a move corresponds to a translation between two languages. The nodes, then, are the languages. An edge going from language <em>a</em> to language <em>b</em> means that there is a translator between these two languages. The translator can translate from <em>a</em> to <em>b</em> or vice versa—so the graph is undirected. It’s also weighted, because each edge (a translation) has a weight (the translation cost). The graph is shown in <a href="ch05.xhtml#ch05fig07">Figure 5-7</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_190"/><img alt="Image" id="ch05fig07" src="../images/ch05fig07.jpg"/></div>
<p class="figcap"><em>Figure 5-7: A graph of translations</em></p>
<p class="indent">The total translation cost for us to reach all of the target languages is $500 for English to Spanish, plus $1,000 for English to Italian, plus $1,800 for Spanish to Bengali. That’s $3,300 in all. Don’t be taken in by that alluring $250 Spanish–Italian translation: using that would result in a distance of two from English to Italian, but remember that we need the minimum distances, even when that leads to spending more money. Indeed, the reason we’ll be able to use BFS here is precisely because we care first about the minimum number of edges for each target language, not its minimum cost overall. For the latter, we’d need more powerful tools, and these will be introduced in <a href="ch06.xhtml">Chapter 6</a>.</p>
<p class="indent">To store the graph, I’ll use what’s called an <em>adjacency list</em>. (Node <em>b</em> is said to be <em>adjacent</em> to Node <em>a</em> if there is an edge from <em>a</em> to <em>b</em>; that’s where the name “adjacency list” comes from.) This is just an array with one index per node, where each index stores a linked list of the edges involving that node. We use linked lists of edges, rather than arrays of edges, because we don’t know in advance the number of edges that involve a given node.</p>
<p class="indent">Here are the constants and <code>typedef</code>s:</p>
<pre>#define MAX_LANGS 101
#define WORD_LENGTH 16
 
typedef struct edge {
  int to_lang, cost;
  struct edge *next;
} edge;
 
typedef int board[MAX_LANGS];
typedef int positions[MAX_LANGS];</pre>
<p class="indent">An <code>edge</code> has a <code>to_lang</code> and a <code>cost</code>—that makes sense. However, it doesn’t have a <code>from_lang</code>, and that’s because we’ll already know the <code>from_lang</code> based on which index of the adjacency list the edge is in.</p>
<p class="indent"><span epub:type="pagebreak" id="page_191"/>In <a href="ch02.xhtml">Chapter 2</a>, when storing trees, we used a <code>struct node</code> rather than a <code>struct edge</code>. The reason for the node-centric focus in <a href="ch02.xhtml">Chapter 2</a> is that the nodes are the entities associated with information, such as candy values and numbers of descendants. In the present problem, we have an edge-centric focus, with the <code>struct edge</code>, because it’s the edges (not the nodes) that are associated with information (the translation costs).</p>
<p class="indent">It’s easiest to add to a linked list at its beginning. One side effect of this choice is that the edges for a node end up in the linked list in the opposite order in which we read them. For example, if we read an edge from Node 1 to Node 2 and then read an edge from Node 1 to Node 3, then in our linked list we will find that the edge to Node 3 shows up <em>before</em> the edge to Node 2. Don’t let this catch you off guard when tracing through the code.</p>
<p class="indent">Now we’re ready to see how the graph is built. It’s in the <code>main</code> function given in <a href="ch05.xhtml#ch05ex016">Listing 5-16</a>.</p>
<pre>int main(void) {
  static edge *adj_list[MAX_LANGS] = {NULL};
  static char *lang_names[MAX_LANGS];
  int i, num_targets, num_translators, cost, from_index, to_index;
  char *from_lang, *to_lang;
  edge *e;
  static board min_costs;
  scanf("%d%d ", &amp;num_targets, &amp;num_translators);
<span class="ent">➊</span> lang_names[0] = "English";
 
  for (i = 1; i &lt;= num_targets; i++)
  <span class="ent">➋</span> lang_names[i] = read_word(WORD_LENGTH);
 
  for (i = 0; i &lt; num_translators; i++) {
    from_lang = read_word(WORD_LENGTH);
    to_lang = read_word(WORD_LENGTH);
    scanf("%d ", &amp;cost);
    from_index = find_lang(lang_names, from_lang);
    to_index = find_lang(lang_names, to_lang);
    e = malloc(sizeof(edge));
    if (e == NULL) {
      fprintf(stderr, "malloc error\n");
      exit(1);
    }
    e-&gt;to_lang = to_index;
    e-&gt;cost = cost;
    e-&gt;next = adj_list[from_index];
  <span class="ent">➌</span> adj_list[from_index] = e;
    e = malloc(sizeof(edge));
    if (e == NULL) {
      fprintf(stderr, "malloc error\n");
      exit(1);
    }
<span epub:type="pagebreak" id="page_192"/>    e-&gt;to_lang = from_index;
    e-&gt;cost = cost;
    e-&gt;next = adj_list[to_index];
 <span class="ent">➍</span> adj_list[to_index] = e;
  }
  find_distances(adj_list, num_targets + 1, min_costs);
  solve(num_targets + 1, min_costs);
  return 0;
}</pre>
<p class="excap" id="ch05ex016"><em>Listing 5-16: The</em> <span class="codeitalic1">main</span> <em>function for building the graph</em></p>
<p class="indent">The <code>lang_names</code> array maps integers (the array indices) to language names. We give <code>English</code> the number 0, as promised <span class="ent">➊</span>. We then map each integer 1, 2, . . . , to language names as we read them <span class="ent">➋</span>.</p>
<p class="indent">Remember that the graph is undirected: if we add an edge from <em>a</em> to <em>b</em>, then we had better add the edge from <em>b</em> to <em>a</em>, too. As such, for each translator, we add two edges to the graph: one from <code>from_index</code> to <code>to_index</code> <span class="ent">➌</span> and one from <code>to_index</code> to <code>from_index</code> <span class="ent">➍</span>. Those <code>from_index</code> and <code>to_index</code> indices are produced by <code>find_lang</code>, which searches for a language name; see <a href="ch05.xhtml#ch05ex017">Listing 5-17</a>.</p>
<p class="indent">In the calls to the helper functions at the bottom, we use <code>num_targets + 1</code> rather than <code>num_targets</code> because <code>num_targets</code> gives the number of target languages; the <code>+ 1</code> lets us include English in the count of total languages being processed.</p>
<pre>int find_lang(char *langs[], char *lang) {
  int i = 0;
    while (strcmp(langs[i], lang) != 0)
      i++;
  return i;
}</pre>
<p class="excap" id="ch05ex017"><em>Listing 5-17: Finding a language</em></p>
<h4 class="h4" id="sec80"><em>The BFS</em></h4>
<p class="noindent">The code for <code>add_position</code> in <a href="ch05.xhtml#ch05ex018">Listing 5-18</a> is similar to the other <code>add_position</code> functions we’ve studied earlier in this chapter.</p>
<pre>void add_position(int from_lang, int to_lang,
                  positions new_positions, int *num_new_positions,
                  board min_moves) {
  if (min_moves[to_lang] == -1) {
    min_moves[to_lang] = 1 + min_moves[from_lang];
    new_positions[*num_new_positions] = to_lang;
    <span epub:type="pagebreak" id="page_193"/>
    (*num_new_positions)++;
  }
}</pre>
<p class="excap" id="ch05ex018"><em>Listing 5-18: Adding a position</em></p>
<p class="indent">Now we’re ready for the BFS itself; see <a href="ch05.xhtml#ch05ex019">Listing 5-19</a>.</p>
<pre> void find_distances(edge *adj_list[], int num_langs, board min_costs) {
<span class="ent">➊</span> static board min_moves;
   static positions cur_positions, new_positions;
   int num_cur_positions, num_new_positions;
   int i, from_lang, added_lang, best;
   edge *e;
   for (i = 0; i &lt; num_langs; i++) {
     min_moves[i] = -1;
     min_costs[i] = -1;
   }
   min_moves[0] = 0;
   cur_positions[0] = 0;
   num_cur_positions = 1;
 
   while (num_cur_positions &gt; 0) {
     num_new_positions = 0;
     for (i = 0; i &lt; num_cur_positions; i++) {
       from_lang = cur_positions[i];
    <span class="ent">➋</span> e = adj_list[from_lang];
 
       while (e) {
         add_position(from_lang, e-&gt;to_lang,
                      new_positions, &amp;num_new_positions, min_moves);
         e = e-&gt;next;
      }
    }
 
  <span class="ent">➌</span> for (i = 0; i &lt; num_new_positions; i++) {
      added_lang = new_positions[i];
      e = adj_list[added_lang];
      best = -1;
      while (e) {
      <span class="ent">➍</span> if (min_moves[e-&gt;to_lang] + 1 == min_moves[added_lang] &amp;&amp;
            (best == -1 || e-&gt;cost &lt; best))
          best = e-&gt;cost;
        e = e-&gt;next;
      }
      min_costs[added_lang] = best;
    }
 
    num_cur_positions = num_new_positions;
<span epub:type="pagebreak" id="page_194"/>    for (i = 0; i &lt; num_cur_positions; i++)
      cur_positions[i] = new_positions[i];
  }
}</pre>
<p class="excap" id="ch05ex019"><em>Listing 5-19: Minimum cost of translations using BFS</em></p>
<p class="indent">For each language, we’ll use <code>min_costs</code> to store the minimum-cost edge that could have been used to discover that language. Referring back to <a href="ch05.xhtml#ch05fig07">Figure 5-7</a>, we’d store 500 for Spanish, 1,000 for Italian, and 1,800 for Bengali. In a different function, described soon, we’ll add up all of these numbers to get the total cost for all of the translations.</p>
<p class="indent">The minimum number of moves is of interest only to this function, not the outside world, so we declare it as a local variable <span class="ent">➊</span>. All the outside world cares about is <code>min_costs</code>.</p>
<p class="indent">Trying each possible move amounts to traversing the linked list of edges for the current node <span class="ent">➋</span>. That gives us all of the <code>new_positions</code>. Now we know which languages are discovered in the next round of the BFS, but we don’t yet know the cost of adding each of those languages. The thing is, there could be multiple edges from <code>cur_positions</code> that reach the same node in <code>new_positions</code>. Consult <a href="ch05.xhtml#ch05fig07">Figure 5-7</a> again. Bengali takes two translations, so it’s discovered in round 2 of the BFS—but the edge we need is the one from Spanish, not the one from Italian.</p>
<p class="indent">We therefore have a new <code>for</code> loop <span class="ent">➌</span>, one whose role we haven’t seen yet in this chapter. The variable <code>added_lang</code> tracks each of the new positions (that is, the positions for the next round of BFS). We find the cheapest edge between <code>added_lang</code> and any node discovered in the current round of BFS. Each such language will have a distance of one less than <code>added_lang</code>, which explains the first condition in the <code>if</code> statement <span class="ent">➍</span>.</p>
<h4 class="h4" id="sec81"><em>The Total Cost</em></h4>
<p class="noindent">Once we’ve got the costs stored, all we do is add them up to get the total cost of translating to all target languages. The code is given in <a href="ch05.xhtml#ch05ex020">Listing 5-20</a>.</p>
<pre>void solve(int num_langs, board min_costs) {
  int i, total = 0;
  for (i = 1; i &lt; num_langs; i++)
  <span class="ent">➊</span> if (min_costs[i] == -1) {
       printf("Impossible\n");
       return;
     } else {
       total = total + min_costs[i];
  }
<span class="ent">➋</span> printf("%d\n", total);
}</pre>
<p class="excap" id="ch05ex020"><em>Listing 5-20: The minimum total cost</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_195"/>The task is impossible if any of the target languages is not reachable <span class="ent">➊</span>. Otherwise, we print the total cost that we accumulated <span class="ent">➋</span>.</p>
<p class="indent">Now you’re ready to submit to the judge. Sabasa!</p>
<h3 class="h3" id="lev36">Summary</h3>
<p class="noindent">We wrote gobs of code in this chapter. Of course, I hope that the code offers you a starting point for solving your own graph problems. In the long term, though, what I hope you remember is the importance of modeling as an early step in the problem-solving process. Couching a problem in terms of BFS collapses the domains of knights and ropes and translations into the single domain of graphs. Searching Google for “how to climb a rope” will get you nowhere (except perhaps up a real rope). Searching for “breadth-first search” will instead offer as many code samples and explanations and examples as you’re willing to read. If you read comments left by programmers on the judges’ websites, you’ll see that they communicate on the level of algorithms, not on the level of problem-specific aspects. Often, they’ll just say “BFS Problem” to get their point across. You’re learning this language of modeling and how to go from the model to working code. There’s more graph-modeling coming up in the next chapter, where we tackle weighted graphs in their full generality.</p>
<h3 class="h3" id="lev37">Notes</h3>
<p class="noindent">Knight Chase is originally from the 1999 Canadian Computing Competition. Rope Climb is originally from the 2018 Woburn Challenge, Online Round 1, Senior Division. Book Translation is originally from the 2016 East Central North America Regional Programming Contest.</p>
<p class="indent">There’s a trick that we can use to cut down the code we have to write when considering multiple, similar moves in a BFS. Feel free to check out how that works in “Knight Chase: Encoding Moves” in <a href="app02.xhtml">Appendix B</a>.</p>
<p class="indent">We learned all about BFS in this chapter, but if you continue with graph algorithms you might like to study <em>depth-first search</em> (DFS) as well. I recommend <em>Algorithms Illuminated (Part 2): Graph Algorithms and Data Structures</em> by Tim Roughgarden (2018) for more on BFS, DFS, and other graph algorithms.<span epub:type="pagebreak" id="page_196"/></p>
</body></html>