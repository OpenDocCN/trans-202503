- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SIMPLE MACHINES**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0135-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In mechanical engineering, *simple machines* are a well-known set of standard
    designs including levers, axles, screws, and pulleys that each perform one function
    and can be put together to make larger machines. Analogously, computational simple
    machines are standard designs that are often used as subcomponents of computers.
    For example, the arithmetic logic unit in a modern CPU—exactly as in Babbage’s
    Analytical Engine—is made of many such simple machines that each perform one kind
    of arithmetic, such as addition, multiplication, or shifting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces a range of simple machines as the next architecture
    level above logic gates. Then, in the next chapter, we’ll make use of these simple
    machines as components of a CPU. The simple machines we’ll discuss come in two
    main groups: *combinatorial machines*, which can be written as Boolean expressions,
    and *sequential machines*, which require feedback and sequential logic, extending
    Boolean logic with a temporal element. Feedback and sequential logic are needed
    to create memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Combinatorial Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Combinatorial logic* refers to those digital logic networks that can be described
    by regular Boolean logic, without considering the role of time. In this section,
    we’ll see examples of several combinatorial simple machines, which we’ll later
    rely on as we build up CPU structures.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bitwise Logical Operations*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The individual logic gates of the previous chapter act on single bits of data:
    they usually take one or two single-bit inputs and yield a single-bit output.
    It’s simple to arrange multiple copies of a single gate, in parallel, thus creating
    an *array operator*, a simple machine that simultaneously performs the same operation
    on each bit of an input array to give an output array, as in [Figure 6-1](ch06.xhtml#ch06fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0136-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: Some bitwise logical operations*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the input arrays `x` and `y` (or just `x` in the case of the NOT operation)
    pass through an array of identical gates, producing `z` as the output. These array
    operations are well known to low-level C programmers, as the C language includes
    them and assigns symbols to them. C compilers will ultimately execute these instructions
    using exactly this simple machine, if it’s present in the target CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '*Multi-input Logical Operations*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can create multi-input versions of AND gates from hierarchies of their two-input
    versions, as in the eight-input AND gate shown in [Figure 6-2](ch06.xhtml#ch06fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0137-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: An eight-input AND gate made from two-input AND gates (left) and
    its symbol (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: This structure will output 1 if and only if all of its inputs are 1\. The same
    structure works to create multi-input OR gates, which will output 1 if one or
    more of its inputs are 1.
  prefs: []
  type: TYPE_NORMAL
- en: '*Shifters*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In base 10, there’s a fast trick for multiplying integers by 10: just append
    a zero to the end. We can also multiply by a higher natural power of 10, 10^(*^n*),
    by appending *n* zeros. Rather than thinking of it as appending a zero, think
    of it as shifting each digit one place to the left. Then the trick also works
    for multiplying non-integer numbers by powers of 10\. We can similarly do easy
    and fast divides by powers of 10 by shifting the digits to the right. These tricks
    remove the need for the usual slower work of human pen-and-paper multiplication
    involving repeated single-digital multiplications, additions, and carries.'
  prefs: []
  type: TYPE_NORMAL
- en: The same tricks work in binary for fast multiplication and division by integer
    powers of 2\. To multiply or divide a number by 2^(*n*), shift the number’s bits
    *n* places to the left or right.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-3](ch06.xhtml#ch06fig3) shows a simple machine that, when enabled,
    performs a left shift, thereby multiplying an input number by 2\. The machine
    is enabled by setting the *S* (shift) input switch to true. If the *S* input isn’t
    enabled, the machine outputs the original input unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0137-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: A left-shifter made from logic gates*'
  prefs: []
  type: TYPE_NORMAL
- en: The shifter design is based on a sub-machine consisting of two ANDs, one NOT,
    and one OR. Each column (digit) of the number has a copy of this sub-machine,
    which either allows the column’s own bit to pass through unchanged, or takes the
    bit from the column to its right.
  prefs: []
  type: TYPE_NORMAL
- en: When you do multiplication by powers of two with an operation like `x>>2` using
    a high-level language like C, your CPU may contain a dedicated shifter that gets
    activated rather than its usual multiplication digital logic. This makes the multiplication
    operation go faster than one that isn’t by a power of two. This is an example
    of how knowing architecture enables you to write fast programs. You’ll often see
    speed-critical code designed to exploit this trick, such as games and media codecs
    enforcing values to be powers of two.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Shifting by more than one place can be done in several ways. You could reuse
    the same shifter network several times, which would save on transistors but take
    longer to run. Or you could use more transistors to implement many different switches
    that request different kinds of shift, and implement them immediately. Deciding
    whether to trade off transistors for speed in this way is a common architectural
    dilemma.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Decoders and Encoders*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose you have a positive integer *x* represented as an *M*-bit binary number.
    Computers often need to convert this binary representation into an alternative
    1-of-*N* representation, which has *N* = 2*^M* bits, all 0 except for a 1 in the
    *x*th bit. For example, an *M* = 3 bit input such as 101 (coding the number 5[10])
    would be converted to 00000100, which has 2³ = 8 bits with only the fifth one
    high (counting the bits from left to right, starting from 0). A simple machine
    called a *decoder* can perform this conversion. [Figure 6-4](ch06.xhtml#ch06fig4)
    shows a digital logic circuit for a 3-bit decoder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0138-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: A 3-bit decoder*'
  prefs: []
  type: TYPE_NORMAL
- en: Each input is first copied and inverted. Then a set of AND gates are connected
    to either the uninverted or inverted versions of each input bit in connection
    patterns that model the patterns of binary number codings.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *encoder* performs the inverse operation: it takes a 1-of-*N* representation
    as an input and transforms it into a binary number encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Multiplexers and Demultiplexers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve seen that the Analytical Engine consisted of many subcomponents that were
    dynamically connected and disconnected as needed to perform computations. Making
    and breaking these connections in the Analytical Engine was done mechanically.
    For example, when we wanted to do some adding, the mechanisms physically brought
    the gears into contact between a register and the arithmetic logic unit (ALU).
    Or when we loaded data from RAM, a mechanism physically connected the desired
    RAM location to the bus. The digital logic version of this idea is multiplexing
    and demultiplexing.
  prefs: []
  type: TYPE_NORMAL
- en: A *multiplexer* enables us to select which one of multiple possible sources
    we wish to connect to a single output. For example, we might have eight registers
    and want to select one of them to connect to an ALU input. [Figure 6-5](ch06.xhtml#ch06fig5)
    shows an eight-source multiplexer. It consists of a decoder together with eight
    data inputs, D[0] through D[7], and additional AND and OR gates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0139-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: A multiplexer*'
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to connect a particular source, such as D[3], to the output wire,
    we place its code, 011[2] for 3[10], onto the decoder inputs C[0] to C[2]. The
    decoder sets the third line only to true, which is AND gated together with D[3]
    as a switch. The OR gates then copy D[3] onto the output wire, as all their other
    inputs are false.
  prefs: []
  type: TYPE_NORMAL
- en: A *demultiplexer* performs the opposite function to a multiplexer. It takes
    a single input wire and a code *n*, and sends a copy of the input signal to the
    *n*th of multiple output wires.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexers and demultiplexers are often used together, so we can choose which
    one of several possible sources to connect to which one of several possible destinations.
    In these cases, the shared wire is known as a *bus*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Adders*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You saw in [Chapter 2](ch02.xhtml) how to represent integers in binary. We can
    construct simple machines that use this representation to perform arithmetic operations,
    such as *adders* for performing addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of adding two binary numbers, 001100 and 011010:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0140-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can perform this addition by hand using the same algorithm as taught to
    children for decimal addition: starting from the rightmost column, compute the
    column sum by adding the digits from the input numbers for that column, writing
    the result underneath as the output sum for that column. If this creates a carry,
    for example from 1 + 1 = 10, write the lower-power column of the result (the 0
    of 10) as the sum and carry the higher-power column of the result (the 1 of 10)
    to the next column, where it needs to be added as a third input. In the example,
    the first three columns (counting from the right) don’t produce carries, but the
    fourth and fifth columns do. (The carries are shown below the final sum.)'
  prefs: []
  type: TYPE_NORMAL
- en: If you look back at the truth tables for AND and XOR in [Figures 5-1](ch05.xhtml#ch05fig1)
    and [5-4](ch05.xhtml#ch05fig4) and compare them to the work done during binary
    addition, you’ll see that as long as there’s no input carry (as is the case for
    the first four columns in the example), the results of XOR are identical to column-wise
    addition, while the results of AND are identical to the carry operation. We could
    thus use one XOR and one AND to form the simple machine known as a *half adder*,
    shown in [Figure 6-6](ch06.xhtml#ch06fig6), to compute the sums for columns when
    there’s no carry coming in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0140-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: A half adder*'
  prefs: []
  type: TYPE_NORMAL
- en: By itself, the half adder isn’t very useful, as we don’t usually know if an
    input carry will also be present. However, if we combine two half adders together
    with an OR gate, as in [Figure 6-7](ch06.xhtml#ch06fig7), we obtain a more useful
    network called a *full adder*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0141-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: A full adder made from two half adders and an OR gate*'
  prefs: []
  type: TYPE_NORMAL
- en: The truth table for a full adder is shown in [Table 6-1](ch06.xhtml#ch06tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** Full Adder Truth Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **X** | **Y** | **C[in]** | **Sum** | **C[out]** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'The full adder performs two single-bit additions in a row, the first for the
    main inputs (X and Y) and the second for the sum of the main inputs plus the incoming
    carry (C[in]). The net result is a single-column sum, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0141-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the full process needed to correctly find the binary digit sum for each
    column of binary addition. As well as adding the two binary digits from that column
    of the two input numbers, it also adds an incoming carried digit whenever it’s
    present. The full adder’s two outputs are the sum for the column (S) and the carry
    out for the column (C[out]).
  prefs: []
  type: TYPE_NORMAL
- en: The full adder network is often represented by the single symbol shown in [Figure
    6-8](ch06.xhtml#ch06fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0142-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: The adder symbol*'
  prefs: []
  type: TYPE_NORMAL
- en: A full adder performs addition of a single column, but to actually add integers
    together we need to add many columns. One way to do this is to create one full
    adder for each column and connect the carry out from each column to the carry
    in of the next. This is known as a *ripple-carry adder*. [Figure 6-9](ch06.xhtml#ch06fig9)
    shows a 3-bit example that calculates Z = X + Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0142-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: A ripple-carry adder computing the 3 bits of Z = X + Y*'
  prefs: []
  type: TYPE_NORMAL
- en: The subscripts say which power of 2 the column represents; for example, here
    X[0] is ones (as 2⁰ = 1), X[1] is twos (as 2¹ = 2), and X[2] is fours (as 2² =
    4). There’s an additional output from the final carry to indicate if an overflow
    has occurred. In some cases this would be interpreted as an error. In others it
    might be connected to further systems that together are able to handle larger
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The adder symbol of [Figure 6-8](ch06.xhtml#ch06fig8) can also be used to denote
    a multibit adder such as a ripple-carry adder, where the input and output lines
    are assumed to denote groups of wires rather than single wires.
  prefs: []
  type: TYPE_NORMAL
- en: '**RIPPLE-CARRY VS. CARRY-SAVE ADDERS**'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re taught to do addition at school, you’re taught a serial adding algorithm,
    starting at the right side and moving across, with carry digits moving to the
    next step. The ripple-carry adder is a straight base 2 translation of this idea
    into digital logic.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the efficiency of this process; assuming that both of the inputs
    are *n* digits long, we see that this method of addition will scale linearly with
    *n* as the length of digits increases the addition runs in roughly *O*(*n*) time.
  prefs: []
  type: TYPE_NORMAL
- en: But addition doesn’t have to be done or taught like this. Imagine that instead
    of teaching kids to add numbers together individually, they’re taught to work
    from the start as a team, each performing a smaller part of the addition. How
    would you get the numbers added together as quickly as possible in parallel? You’d
    probably give each kid one pair of column digits from the addition, have them
    each do their addition at the same time, then have them send their carry along
    to the person on their left. Then they each take the carry from their right and
    add it into their result to update it if needed, and sometimes update their carry
    output and pass it again to their left, until everyone is happy. This is called
    a *carry-save adder*.
  prefs: []
  type: TYPE_NORMAL
- en: Estimating the number of carry steps that need to be done in this kind of parallel
    addition is quite a challenge. Naively, around one-quarter of initial additions
    will produce a carry. But then you need to think about the probability of a second
    or third subsequent carry step as you later receive incoming carries.
  prefs: []
  type: TYPE_NORMAL
- en: To do this properly as a probabilistic estimate, you should take into account
    the distribution of digits involved in the addition. Most natural quantities have
    a lower probability of higher-value digits (5+ in decimal; 1 in binary) than low-value
    digits (up to 4 in decimal; 0 in binary). This is found both in physical and pure
    mathematics quantities (for example, digits of Planck’s constant, *π*, and *e*),
    though the reason why is quite complex.
  prefs: []
  type: TYPE_NORMAL
- en: Carry-save adders can do addition in *O*(log *n*) time. They’re still doing
    the same *O*(*n*) amount of total work as the ripple-carry adder, but performing
    more of the work in parallel, using more silicon. More silicon consumes more space
    and money, but in this case delivers faster performance. Again, trading silicon
    for time is a common architectural dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Carry-save adders are found in modern ALUs. They aren’t a new idea and in fact
    were featured in one of the Analytical Engine designs. This is one of the main
    reasons the machine was never built: Babbage kept going back to improve the efficiency
    of the carry mechanism, to the point of obsession. Had he stuck to one design,
    it may have been completed.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Negators and Subtractors*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we use two’s complement data representation for integers, then negating a
    number (that is, multiplying it by –1) can be performed by flipping its bits and
    then adding 1 to the result. A machine that performs this operation is called
    a *negator*. [Figure 6-10](ch06.xhtml#ch06fig10) shows a 3-bit negator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0144-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: A 3-bit negator*'
  prefs: []
  type: TYPE_NORMAL
- en: The thick wires in this figure are standard notation for bundles of multiple
    individual wires, in this case bundles of three wires. (Another common notation
    for bundles is to draw a diagonal slash through and write the number of wires
    next to it.) The switches in the bottom-left specify the input number, with the
    least significant bit first. The number 1 to add is encoded by power and ground
    inputs, again with the least significant bit first. The adder symbol here indicates
    not just a full adder but a 3-bit adder, such as a ripple-carry adder.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a negator, we can make a *subtractor*, a machine that subtracts
    one number from another. Single- and multi-bit subtractors are indicated with
    the symbol in [Figure 6-11](ch06.xhtml#ch06fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0144-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: The subtractor symbol*'
  prefs: []
  type: TYPE_NORMAL
- en: We could make a two’s complement subtractor to calculate *c* = *a* – *b* by
    passing *b* through a negator and then using an adder to add the result to *a*.
  prefs: []
  type: TYPE_NORMAL
- en: From Combinatorial to Sequential Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The combinatorial circuits we’ve seen so far may be viewed as computing instantly.
    Each circuit corresponds exactly to a Boolean logic expression, which has a definite,
    mathematical truth value that corresponds to the output of the circuit. This output
    depends only on the input values, and the input-output pairs can be listed in
    a truth table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen that Shannon’s combinatorial logic circuits can be used to build
    many simple machines, like multiplexers and adders. Shannon proposed his logic
    gate theory in 1936, the same year as Church’s and Turing’s definitions of computation,
    and you might want to view Shannon’s logic gates as an additional competing model
    of computation from this year, if you’re happy for a “program” to be a set of
    instructions for how to physically connect a bunch of logic gates, in a similar
    manner to programming the pre–virtual machine ENIAC.
  prefs: []
  type: TYPE_NORMAL
- en: However, Church computers need to be able to simulate any other machine (given
    enough memory), and we know that some other machines have *memory* for data storage.
    There’s no concept of memory in combinatorial logic circuits because memory means
    storage over time, and there’s no concept of time because these circuits can be
    viewed as acting instantly. Church computers need to have time and memory and
    be able to compute outputs that are functions not only of their current input
    but also of their state as derived from previous inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We can extend Shannon’s logic gates with these additional concepts if we allow
    logic gate networks whose outputs are fed back into their inputs. Such networks
    weren’t allowed in Shannon’s original combinatorial logic, as they would have
    resulted in paradoxical Boolean expressions. For example, the circuit in [Figure
    6-12](ch06.xhtml#ch06fig12) appears to instantiate the Boolean statement X = NOT
    X. This Boolean statement says that if X is true, then X is false, but if X is
    false then X is true. What do you think this circuit would do in practice if you
    connected it? Perhaps it would oscillate or explode?
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0145-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: A paradoxical circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In computer science, feedback is often thought of as evil or paradoxical, something
    to be avoided: many of the theorems in logic and computability theory are about
    how to destroy programs, proofs, and machines by feeding their output or descriptions
    of themselves into their inputs. But feedback is a big idea in computer science
    in general, and learning to control it and use it for good has been a major part
    of our success and our culture. Creating memory is one such positive and controlled
    use of feedback.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illustrate this idea using the example of a guitarist. Guitarists have
    a more practical worry about feedback, as their guitar strings can vibrate in
    sympathy with the sounds coming from their amplifiers. These vibrations, in turn,
    are amplified, and so on, leading to a terrible (or beautiful, depending on your
    musical point of view) single-frequency screeching sound. Consider exactly *when*
    this happens. It’s possible to put the same guitar in exactly the same place in
    front of the amp, and yet have the system remain completely silent if there’s
    no initial sound. The feedback emerges only if there’s some sound—even a small
    one—to make it begin. We could thus use this guitar-amp system to store 1 bit
    of information. We bring the guitar next to the amp very carefully so no sound
    is made and the system stays silent, representing a 0\. If we later want to store
    a 1, we stroke the strings to begin the feedback, which continues forever, representing
    the 1\. To change it back to 0, we could turn the amp off and on again.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit in [Figure 6-13](ch06.xhtml#ch06fig13) is an attempt to make a digital
    logic version of the same idea. If we try to map it to Boolean logic, it seems
    less paradoxical than the circuit from [Figure 6-12](ch06.xhtml#ch06fig12), appearing
    to instantiate the Boolean statement Q = G OR Q. (G is for *guitar*, and Q is
    a traditional symbol for *quiescence*, or system state.) You can just about convince
    yourself that this is stable for G = Q = 0 or for G = Q = 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0146-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: A guitar-like feedback circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: However, this still doesn’t give us the concepts of time or memory, because
    Boolean logic is inherently static. To fully capture these concepts, we need to
    go beyond Boolean logic and Shannon gates, and consider a new type of logic gate
    having different states at different *times*. We need to distinguish states at
    times using *sequential logic*, such as writing *Q*[*t*] ≠ Q[*t*-1] for states
    at time *t* and just before time *t*. This would be foreign to Boole and Shannon,
    and indeed it’s an extension of their theories. It can be used to give meaning
    to digital logic circuits that their theories can’t handle, such as mapping [Figure
    6-12](ch06.xhtml#ch06fig12) to *X*[*t*] = NOT X[*t*-1] and [Figure 6-13](ch06.xhtml#ch06fig13)
    to Q[*t*] = G OR Q[*t*-1]. The latter is now an exact analog of the guitar feedback
    memory, with Q able to sustain a value of 1 copied from G even if G is later lowered
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: This still isn’t a very useful memory, because once Q has been set high there’s
    no way to reset it to low again. We need to add the equivalent of the amplifier
    power switch, A, as in [Figure 6-14](ch06.xhtml#ch06fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0146-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: A guitar-and-amp-like feedback circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: The *SR flip-flop* of [Figure 6-15](ch06.xhtml#ch06fig15) is a variation on
    this idea made from two NAND gates, the most common universal gate.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0146-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: An SR flip-flop*'
  prefs: []
  type: TYPE_NORMAL
- en: S and R stand for *set* and *reset*. When S is high, it sets the output Q to
    1\. When R is high, it resets the output Q to 0\. (This also has the advantage
    of making NOT Q available on the Q^′ output as a free by-product, which is sometimes
    useful.)
  prefs: []
  type: TYPE_NORMAL
- en: Clocked Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sequential logic behavior can be unpredictable if we don’t have a clearly defined,
    discrete signal telling us when *t* has changed to *t* + 1\. This can be done
    with a clock signal, traditionally called *clk*, that steadily oscillates between
    0 and 1, as discussed in [Chapter 4](ch04.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: By tradition, the instant of the rising edge of clk is used as the instant that
    *t* increases by one; this is called a *tick*. We then design the temporal parts
    of our circuits to update their state at each tick. Copies of clk can be wired
    into many points across the system to make them all update simultaneously on each
    tick.
  prefs: []
  type: TYPE_NORMAL
- en: As with the combinatorial logic section, we’ll now walk through a series of
    clocked logic machines.
  prefs: []
  type: TYPE_NORMAL
- en: '*Clocked Flip-Flops*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most sequential simple machines can be converted to clocked form by adding gates
    that AND their inputs with a clock signal. [Figure 6-16](ch06.xhtml#ch06fig16)
    shows how to extend an SR flip-flop in this way.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0147-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: A clocked SR flip-flop*'
  prefs: []
  type: TYPE_NORMAL
- en: Only a single tick of high signal is needed in S or R to flip the state of the
    memory, which is then retained over time until a new S or R signal is received.
    Changes occur only during a clock tick, as the AND gates on the clock act to disable
    the S and R inputs at other times.
  prefs: []
  type: TYPE_NORMAL
- en: Clocked versions of simple machines are drawn with the clock input marked with
    a triangle, as in [Figure 6-17](ch06.xhtml#ch06fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0147-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: The symbol for a clocked SR flip-flop*'
  prefs: []
  type: TYPE_NORMAL
- en: SR is the simplest type of flip-flop to understand, and for that reason it’s
    generally used to introduce the concept, but SR flip-flops aren’t typically used
    in practice. This is because they have undesirable, undefined behavior in cases
    where both inputs are 1\. The *D-type flip-flop* has a modified design that fixes
    this issue; it’s widely used in practice. Unlike SR, it uses an inherently clock-based
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: A D-type flip-flop (D for *data*) has only one data input and a clock input.
    At one point of the clock cycle, such as the rising edge, it captures the data
    on the D input. For the rest of the clock cycle, it outputs that value on its
    output Q. This stores the data for only one clock cycle—if you want to keep it
    for longer, you need to arrange external connections so that D[*t* +1] = Q[*t*].
    One of many possible implementations of a D-type flip-flop is shown in [Figure
    6-18](ch06.xhtml#ch06fig18).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0148-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-18: A D-type flip-flop*'
  prefs: []
  type: TYPE_NORMAL
- en: The standard D-type flip-flop symbol is shown in [Figure 6-19](ch06.xhtml#ch06fig19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0148-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-19: The D-type flip-flop symbol*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the standard triangle symbol is used for the clock input, and the negated
    output is shown by a circle, as used in NAND and NOR gate symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '*Counters*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *counter* is a digital logic version of Pascal’s calculator. We use a D-type
    flip-flop to store the value in each column, and wire its output to both its own
    data input (to refresh the storage) and also to the clock input of the *next*
    column’s flip-flop as a carry. This is shown in [Figure 6-20](ch06.xhtml#ch06fig20).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0149-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-20: A 4-bit binary counter*'
  prefs: []
  type: TYPE_NORMAL
- en: If the input to the first column is a clock, then the counter will count the
    number of ticks that have taken place. If you take an output wire from one of
    the columns of the counter, you get a clock divider, which drops the clock frequency
    by a power of two. This is useful when you have a fast clock and want to create
    a slower clock from it, for example to use as a clock for slower pieces of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the input to the first column can be any arbitrary signal, such
    as a wire from a manual-controlled switch or some other event in a digital circuit,
    in which case the counter will count the number of these events that have taken
    place.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sequencers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *sequencer* is a device that triggers a bunch of other devices at particular
    times. For example, a traffic light sequencer will turn on and off the different
    colored lights in a particular, repeating order. A sequencer can be made from
    a counter and a decoder, as in [Figure 6-21](ch06.xhtml#ch06fig21), which simply
    uses the counter’s output as an input to the decoder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0149-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-21: An eight-state sequencer using a 3-bit counter and decoder*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Random-Access Memory*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Random-access memory (RAM)* is memory that consists of addresses, each containing
    a group of bits of data known as a *word*, and in which any address can be read
    and written at equal time cost. Babbage’s Analytical Engine features a mechanical
    RAM; let’s see how to build the same structure from digital logic as a simple
    machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic RAM has three groups of wires as its interface. First, *N* address wires
    carry a binary natural number representation specifying which of 2^(*N*) addresses
    is of interest. Each address stores a word of length *M* so, second, a group of
    *M* data wires carry copies of words to or from the specified address of the RAM.
    Finally, a single control wire, called *write*, carries a single bit that controls
    whether the specified address is to be read or written.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-22](ch06.xhtml#ch06fig22) shows a (toy-sized) RAM with *N* = 2 and
    *M* = 2\. The address wires are labeled A0 and A1, and the data wires D0 and D1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0150-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-22: A simple RAM, with addressed words implemented as flip-flops.
    This toy example has a 2-bit address space of 2-bit words.*'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the 2² = 4 addresses stores a 2-bit word. Each bit of each word is stored
    by a D-type flip-flop. The selection of address from the address wires is performed
    using a decoder.
  prefs: []
  type: TYPE_NORMAL
- en: '**HARDWARE DESCRIPTION LANGUAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: The tools used in this book are focused on LogiSim and simulation. Large-scale
    architecture is, however, usually done via a stack of text-based languages such
    as netlists, Verilog, and Chisel. Let’s take a brief look at these formats in
    case you max out LogiSim and want to explore larger and more complex designs in
    your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mask Files**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mask files* are the very lowest level of chip description, containing the
    physical locations, sizes, and shapes of components such as transistors and wires.
    These are used to produce the masks needed for fabrication.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Netlist Files**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Netlist files* contain descriptions of connectivity between physical components
    and wires, but as abstract connectivity rather than a physical layout. You use
    a layout engine program to *place and route* the connections—that is, to transform
    a netlist file into a mask file. (This is an NP-hard problem, so layout programs
    use complex heuristics that were until recently closely guarded commercial secrets.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verilog and VHDL Files**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Verilog* and *VHDL* are text-based hardware description languages for designing
    electronic systems. In their most basic forms, they have a similar function to
    LogiSim, allowing you to instantiate and connect various electronic components.
    But instead of using a GUI, they use text files with a syntax similar to software
    programming languages. Unlike a language like C, however, which is imperative,
    Verilog and VHDL fundamentally describe static objects and relationships between
    them. In this sense, their structure is more like XML or a database, containing
    lists of facts rather than instructions to *do* things. For example, here’s a
    Verilog module representing a full adder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you write a Verilog or VHDL description, a compiler turns it into a netlist.
    This compilation process is called *synthesis* because the logic expressed in
    the source code is synthesized from gates. Software simulators also exist that
    can be used to test Verilog or VHDL hardware designs without actually manufacturing
    the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: While some people still write Verilog or VHDL by hand to design digital logic,
    it’s becoming more common to use higher-level tools such as LogiSim or Chisel
    (discussed next) that compile into Verilog or VHDL. Verilog also adds higher-level
    language constructions that enable some C-like imperative programming and get
    compiled to digital logic structures. LogiSim Evolution is able to export your
    designs as Verilog or VHDL, which enables you to compile them to netlists and
    use them to make real chips.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chisel**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chisel* is a high-level hardware language that was developed for general architecture
    design use. Chisel describes classes of hardware with object orientation; for
    example, you could create a `FullAdder` class to represent the class of full adders,
    which could be abstracted and inherited in the usual high-level object-oriented
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Chisel classes may have parameters for numbers of input and output wires, for
    example, to enable loops to generate *N* full adders to make a ripple adder.
  prefs: []
  type: TYPE_NORMAL
- en: Chisel is a hardware language, but it’s based closely on the very high-level
    Scala software language. Scala, in turn, is influenced heavily by lambda calculus,
    functional programming, and Java; these kinds of languages are not usually associated
    with hardware design, so bringing them in has enabled Chisel to operate at much
    higher levels than the old days of having to do hardware design in Verilog. You
    may benefit from taking regular Scala tutorials before attempting to work with
    Chisel.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logic gates can be combined into networks to perform more complex functions.
    Simple machines are certain well-known types of networks that tend to appear again
    and again in architecture. Combinatorial logic machines—including shifters, encoders,
    multiplexers, and adders—use Shannon’s original theory, without relying on feedback
    or time. When feedback and clocks are also allowed, additional sequential and
    clocked logic simple machines can be created as well. These are able to retain
    data in memory over time. Flip-flops are simple machines storing 1 bit of memory.
    They can function as subcomponents of counters, sequencers, and RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a collection of simple machines, we can combine them in the
    next chapter to build a digital logic CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Building Simple Machines in LogiSim Evolution**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you work on the following exercises, keep in mind that you can create hierarchies
    of subcircuits in LogiSim. You might do this, for example, so that your shifter
    becomes available as a single component to use in higher-level networks. To create
    a subcircuit, click the **+** button. Then, to use the new component, go back
    to the main circuit and add it like any other component. Use pins for input and
    output inside the subcircuit if you want them to show in the external interface
    in the main circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Build the left-shifter ([Figure 6-3](ch06.xhtml#ch06fig3)), decoder ([Figure
    6-4](ch06.xhtml#ch06fig4)), and multiplexer ([Figure 6-5](ch06.xhtml#ch06fig5))
    shown earlier in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design and build a right-shifter, encoder, and demultiplexer. These perform
    the inverse functions of the left-shifter, decoder, and multiplexer, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and test an 8-bit ripple-carry adder. Use it to perform subtraction and
    addition, using two’s complement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and test unclocked and clocked SR flip-flops, and a D-type flip-flop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and test a counter, using a clock as its input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build a traffic light sequencer from a 2-bit counter and decoder. Use it to
    light red, amber, and green bulbs in the UK’s standard sequence, which goes: (1)
    red (stop); (2) red and amber together (get ready to go); (3) green (go); (4)
    amber (get ready to stop). This is roughly how the control unit of a CPU works.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prebuilt LogiSim Modules**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: LogiSim has prebuilt modules for many simple machines. For example, there’s
    a prebuilt RAM module found under Memory in the menu, as in [Figure 6-23](ch06.xhtml#ch06fig23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0153-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-23: An eight-address, 2-bit word RAM*'
  prefs: []
  type: TYPE_NORMAL
- en: This version has two control inputs, one for write enable and one for read enable.
    A NOT gate is used in the figure to create both from a single control line.
  prefs: []
  type: TYPE_NORMAL
- en: Explore LogiSim’s prebuilt modules that correspond to the machines you implemented
    in the previous exercises. Check that they give the same results as your own implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explore the RAM module shown in [Figure 6-23](ch06.xhtml#ch06fig23). Use the
    module options to specify the RAM’s word and address lengths. You can manually
    edit the RAM’s contents with a built-in hex editor by right-clicking and then
    clicking Edit Contents. A splitter, found in the Wiring menu, is used to bundle
    and unbundle groups of wires for data and address. A probe or LEDs can be used
    for output; constants, DIP switches, or pins can be used for input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design and build a natural number multiplier in LogiSim. This can be done by
    following the usual multiplication algorithm that you were taught at school, but
    in binary. You can use shifters to multiply one of the inputs by all the different
    powers of two, then adders to add together those powers that are present in the
    second number. Use AND gates to enable and disable the relevant powers. As is
    often the case in architecture, you can choose whether to use multiple silicon
    copies of the required structures, or use a single copy plus timing logic to run
    it many times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend your multiplier to work with negative integers, using two’s complement
    data representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design, build, and test an 8-bit carry-save adder in LogiSim. How much more
    efficient is it than a ripple-carry adder?
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For full details on how to use LogiSim, including advanced features, see George
    Self, *LogiSim Evolution Lab Manual* (July 2019), *[https://www.icochise.com/docs/logisim.pdf](https://www.icochise.com/docs/logisim.pdf)*.
  prefs: []
  type: TYPE_NORMAL
