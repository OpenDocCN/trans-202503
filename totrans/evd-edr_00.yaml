- en: <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Today, we accept that network compromises are inevitable. Our security landscape
    has turned its focus toward detecting adversary activities on compromised hosts
    as early as possible and with the precision needed to respond effectively. If
    you work in security, you’ve almost certainly come across some type of endpoint
    security product, whether it be legacy antivirus, data-loss prevention software,
    user-activity monitoring, or the subject of this book, endpoint detection and
    response (EDR). Each product serves a unique purpose, but none is more prevalent
    today than EDR.
  prefs: []
  type: TYPE_NORMAL
- en: An *EDR agent* is a collection of software components that create, ingest, process,
    and transmit data about system activity to a central node, whose job is to determine
    an actor’s intent (such as whether their behavior is malicious or benign). EDRs
    touch nearly all aspects of a modern security organization. Security operation
    center (SOC) analysts receive alerts from their EDR, which uses detection strategies
    created by detection engineers. Other engineers maintain and deploy these agents
    and servers. There are even entire companies that make their money managing their
    clients’ EDRs.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time we stop treating EDRs like magic black boxes that take in “stuff”
    and output alerts. Using this book, offensive and defensive security practitioners
    alike can gain a deeper understanding of how EDRs work under the hood so that
    they can identify coverage gaps in the products deployed in target environments,
    build more robust tooling, evaluate the risk of each action they take on a target,
    and better advise clients on how to cover the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Who This Book Is For</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book is for any reader interested in understanding endpoint detections.
    On the offensive side, it should guide researchers, capability developers, and
    red team operators, who can use the knowledge of EDR internals and evasion strategies
    discussed here to build their attack strategies. On the defensive side, the same
    information serves a different purpose. Understanding how your EDR works will
    help you make informed decisions when investigating alerts, building new detections,
    understanding blind spots, and purchasing products.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, if you’re looking for a step-by-step guide to evading the specific
    EDR deployed in your particular operating environment, this book isn’t for you.
    While we discuss evasions related to the broader technologies used by most endpoint
    security agents, we do so in a vendor-agnostic way. All EDR agents generally work
    with similar data because the operating system standardizes its collection techniques.
    This means we can focus our attention on this common core: the information used
    to build detections. Understanding it can clarify why a vendor makes certain design
    decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, this book exclusively targets the Windows operating system. While you’ll
    increasingly find EDRs developed specifically for Linux and macOS, they still
    don’t hold a candle to the market share held by Windows agents. Because we are
    far more likely to run into an EDR deployed on Windows when attacking or defending
    a network, we’ll focus our efforts on gaining a deep understanding of how these
    agents work.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Is in This Book</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each chapter covers a specific EDR sensor or group of components used to collect
    some type of data. We begin by walking through how developers commonly implement
    the component, then discuss the types of data it collects. Lastly, we survey the
    common techniques used to evade each component and why they work.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1](chapter1.xhtml): EDR-chitecture**   Provides an introduction
    to the design of EDR agents, their various components, and their general capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2](chapter2.xhtml): Function-Hooking DLLs**   Discusses how an EDR
    intercepts calls to user-mode functions so that it can watch for invocations that
    could indicate the presence of malware on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3](chapter3.xhtml): Process- and Thread-Creation Notifications**   Starts
    our journey into the kernel by covering the primary technique an EDR uses to monitor
    process-creation and thread-creation events on the system and the incredible amount
    of data the operating system can provide the agent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4](chapter4.xhtml): Object Notifications**   Continues our dive
    into kernel-mode drivers by discussing how an EDR can be notified when a handle
    to a process is requested.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5](chapter5.xhtml): Image-Load and Registry Notifications**   Wraps
    up the primary kernel-mode section with a walk-through of how an EDR monitors
    files, such as DLLs, being loaded into a process and how the driver can leverage
    these notifications to inject their function-hooking DLL into a new process. This
    chapter also discusses the telemetry generated when interacting with the registry
    and how it can be used to detect attacker activities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6](chapter6.xhtml): Filesystem Minifilter Drivers**   Provides insight
    into how an EDR can monitor filesystem operations, such as new files being created,
    and how it can use this information to detect malware trying to hide its presence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7](chapter7.xhtml): Network Filter Drivers**   Discusses how an
    EDR can use the Windows Filtering Platform (WFP) to monitor network traffic on
    a host and detect activities like command-and-control beaconing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8](chapter8.xhtml): Event Tracing for Windows**   Dives into an
    incredibly powerful user-mode logging technology native to Windows that EDRs can
    use to consume events from corners of the operating system that are otherwise
    difficult to reach.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9](chapter9.xhtml): Scanners**   Discusses the EDR component responsible
    for determining if some content contains malware, whether it be a file dropped
    to disk or a given range of virtual memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10](chapter10.xhtml): Antimalware Scan Interface**   Covers a scanning
    technology that Microsoft has integrated into many scripting and programming languages,
    as well as applications, to detect issues that legacy scanners can’t detect.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11](chapter11.xhtml): Early Launch Antimalware Drivers**   Discusses
    how an EDR can deploy a special type of driver to detect malware that runs early
    in the boot process, potentially before the EDR has a chance to start.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12](chapter12.xhtml): Microsoft-Windows-Threat-Intelligence**   Builds
    upon the preceding chapter by discussing what is arguably the most valuable reason
    for deploying an ELAM driver: gaining access to the Microsoft-Windows-Threat-Intelligence
    ETW provider, which can detect issues that other providers miss.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13](chapter13.xhtml): Case Study: A Detection-Aware Attack**   Puts
    the information gained in previous chapters into practice by walking through a
    simulated red team operation whose primary objective is to remain undetected.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Appendix](appendix.xhtml): Auxiliary Sources**   Discusses niche sensors
    that we don’t see deployed very frequently but that can still bring immense value
    to an EDR.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Prerequisite Knowledge</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a deeply technical book, and to get the most out of it, I strongly recommend
    that you familiarize yourself with the following concepts. First, knowledge of
    basic penetration testing techniques will help you better understand why an EDR
    may attempt to detect a specific action on a system. Many resources can teach
    you this information, but some free ones include Bad Sector Labs’s *Last Week
    in Security* blog series, Mantvydas Baranauskas’s blog *Red Team Notes*, and the
    SpecterOps blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll spend quite a bit of time deep in the weeds of the Windows operating
    system. Thus, you may find it worthwhile to understand the basics of Windows internals
    and the Win32 API. The best resources for exploring the concepts covered in this
    book are *Windows Internals: System Architecture, Processes, Threads, Memory Management,
    and More, Part 1*, 7th edition, by Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich,
    and David A. Solomon (Microsoft Press, 2017), and Microsoft’s Win32 API documentation,
    which you can find at [*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>/win32<wbr>/api*](https://learn.microsoft.com/en-us/windows/win32/api).'
  prefs: []
  type: TYPE_NORMAL
- en: Because we examine source code and debugger output in depth, you may also want
    to be familiar with the C programming language and x86 assembly. This isn’t a
    requirement, though, as we’ll walk through each code listing to highlight key
    points. If you’re interested in diving into either of these topics, you can find
    fantastic online and print resources, such as [*https://<wbr>www<wbr>.learn<wbr>-c<wbr>.org*](https://www.learn-c.org)
    and *The Art of 64-Bit Assembly Language*, Volume 1, by Randall Hyde (No Starch
    Press, 2021).
  prefs: []
  type: TYPE_NORMAL
- en: Experience with tools like *WinDbg*, the Windows debugger; *Ghidra*, the disassembler
    and decompiler; *PowerShell*, the scripting language; and the *SysInternals Suite*
    (specifically, the tools Process Monitor and Process Explorer) will aid you as
    well. Although we walk through the use of these tools in the book, they can be
    tricky at times. For a crash course, see Microsoft’s “Getting Started with Windows
    Debugging” series of articles, *The Ghidra Book* by Chris Eagle and Kara Nance
    (No Starch Press, 2020), Microsoft’s “Introduction to Scripting with PowerShell”
    course, and *Troubleshooting with the Windows Sysinternals Tools*, 2nd edition,
    by Mark E. Russinovich and Aaron Margosis (Microsoft Press, 2016).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’d like to test the techniques discussed in this book, you may want to
    configure a lab environment. I recommend the following setup consisting of two
    virtual machines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A virtual machine running Windows 10 or later with the following software installed:
    Visual Studio 2019 or later configured for desktop C++ development, the Windows
    Driver Kit (WDK), WinDbg (available in the Microsoft store), Ghidra, and the SysInternals
    Suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual machine running any operating system or distribution you’d like that
    can serve as a command-and-control server. You could use Cobalt Strike, Mythic,
    Covenant, or any other command-and-control framework, so long as it has the ability
    to generate agent shellcode and to execute tooling on the target system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, you should disable the antivirus and EDRs on both systems so that they
    don’t interfere with your testing. Additionally, if you plan to work with real
    malware samples, create a sandbox environment to reduce the likelihood of any
    ill effects occurring when the samples are run.
  prefs: []
  type: TYPE_NORMAL
