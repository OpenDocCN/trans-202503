- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LANGUAGE BASICS**
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning another language is not only learning different words for the same
    things, but learning another way to think about things.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*—*Flora Lewis'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes people new to programming ask why there are so many computer languages.
    They all have different syntaxes. Some use braces and semicolons, like C and JavaScript;
    some use whitespace, like Python; some are notorious for a proliferation of parentheses,
    like the Lisp family; and some use keywords, like Julia.
  prefs: []
  type: TYPE_NORMAL
- en: However, differences in syntax are not the real reason. With experience, variations
    in language punctuation become trivialities. It’s also true that some languages
    are faster than others, or have different demands on memory, although these are
    often properties of implementations rather than the languages themselves, but
    performance is not the real reason either.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental reason for the persistence of different languages and language
    families is that they are based on different ideas. Each language represents a
    unique conceptual framework in which to express computations. When we write a
    program, we are not simply telling a machine what to do. If that were the case,
    we would all write in the machine code into which our programs are ultimately
    translated. Instead, we are telling *people*, including ourselves, about a computation.
    Computer languages are human languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you begin your journey through Julia, it’s important to keep this in mind.
    You are not learning merely a collection of incantations for getting the computer
    to do what you want. You are learning a way of thinking: a set of concepts that
    you can use to organize computational ideas. If you master these ideas, your programs
    will do what you expect, will perform well, and will be clear to others and even
    to your future self.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, most of these overarching ideas will come out in the application
    chapters in [Part II](part2.xhtml). In this chapter, we cover the nitty-gritty:
    the bricks and stones out of which you will build your cathedrals.'
  prefs: []
  type: TYPE_NORMAL
- en: These elements are the blocks with which you structure your Julia programs—functions,
    loops, and decisions—and the data types they interact with, such as strings, various
    kinds of numbers, and collections. After you finish this chapter, you will know
    enough about Julia to write your first programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Syntax: Data Types, Expressions, and Blocks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section we’ll learn about the fundamentals of Julia syntax for creating
    the basic structures used in almost every Julia program. We’ll also be introduced
    to our first Julia data types.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter I’ll refer to the REPL, but these references apply equally
    well to any interactive environment for Julia, such as Pluto or VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Types of Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All values in Julia have a *type*, just as in almost all programming languages.
    One of the basic types is that of a number, but, just as in mathematics, there
    are different types of numbers. In math we have positive and negative numbers,
    integers and real numbers, and more exotic varieties such as complex numbers and
    quaternions. Positive integers, or counting numbers, have been with us since before
    recorded history, but somebody had to invent all the other kinds of numbers. In
    “User-Defined Types” on [page 234](ch08.xhtml#ch08lev3), you’ll learn how you
    can invent your own kinds of Julia numbers if you want to, but for now, let’s
    look at some of the built-in types.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Perhaps more than any other chapter in this book, it is important to read
    this one with the Julia REPL open and try things out as you read about them. Experiment
    with variations of the examples in the chapter until you feel comfortable with
    the syntax. You will use everything in this chapter repeatedly in all your programs,
    so making these details second nature now will be helpful.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you type a number without a decimal point into the REPL and press RETURN
    or ENTER, Julia will give you the same number back. A number by itself is an *expression*,
    which means something that returns a result. Since the result of evaluating a
    plain number is the number itself, that’s what you get. These whole numbers, by
    default, are given the type of `Int64`, which just means an integer that takes
    up 64 bits of storage. (I’m assuming a 64-bit system, which is a pretty safe assumption
    these days. If you are using a 32-bit system, replace `Int64` with `Int32` throughout
    this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: A number with a decimal point has the type `Float64`. The numbers 1 and 1.0
    may have the same values, but they are different to the computer. The first is
    an `Int64`, and the second is a `Float64`. This difference has various repercussions
    that will appear in our later work.
  prefs: []
  type: TYPE_NORMAL
- en: Since Julia is intended, among other things, for scientific calculation, naturally
    it can deal with complex numbers as well. The syntax for entering complex numbers
    uses `im` for the imaginary unit (the square root of –1). So to enter the number
    3 + 4*i*, you write `3 + 4im`. The type of that number is called `Complex{Int64}`,
    because the numerical parts happen to be integers. The type of `3.4 + 1.1im` is
    called `Complex{Float64}`. This notation means that it’s a `Complex` type that
    has `Float64` parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write very big or small numbers using the usual computer version of
    scientific notation: `6.02e23` means 6*.*02 × 10^(23). Numbers written in this
    way are `Float64`s, even if you write the mantissa as an integer. The exponent
    must be an integer, and if you prefer, you can use an uppercase E.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia will rewrite your entry in “proper” scientific notation. For example,
    if you enter `1234e19` in the REPL, it will repeat the value as `1.234e22`. And
    apparently, it prefers the lowercase `e`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other numerical types, such as the unsigned integer `UInt64`,
    but this is enough for now. We’ll go deeper into the type system in [Chapter 8](ch08.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '***Operations and Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Addition, subtraction, and multiplication work as you would expect on all these
    types of numbers. The order of operations is the same as in mathematics and is
    similarly overridden using parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Julia performs obvious *type promotion* when needed. The expression `1 + 1`
    involves only integers, and the result will be the integer `2`; there is no reason
    to return any other type. But the expression `1.0 + 1` involves a floating-point
    number, so it will return the `Float64` result `2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Try some arithmetic in the REPL involving operands of various types, including
    complex numbers, to make sure you understand how promotion works. Integers are
    promoted to floats, and both of those are promoted to complex numbers, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Division and Rational Numbers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Julia has *three* kinds of division. Every language has to decide what to do
    about expressions such as `1/2`. The problem is that both operands are integers,
    but the result is not. Some languages, such as Fortran and Python 2, evaluate
    that expression to be zero, because that is the result of taking the integer part
    before the decimal point in the answer. Other languages will promote the result
    into a float and return `0.5`; that’s what Julia does.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a form of division that behaves like Fortran, you can use the division
    symbol (`÷`): `1` ÷ `2` gives `0` and `4` ÷`3` gives `1`. To enter this operator
    in the REPL, enter \div followed by TAB (see “Unicode Characters” on [page 13](ch01.xhtml#ch01sec1sec7)).'
  prefs: []
  type: TYPE_NORMAL
- en: The third form of division uses the `//` operator to define `Rational` numbers,
    which are ratios of two integers. Using this data type, you can perform exact
    arithmetic on rationals without converting the results into floats. For example,
    the expression `1//2 + 1//3` evaluates to `5//6`. Julia reduces rational numbers
    to their simplest form, so if you enter `4//6` in the REPL, it will return the
    result `2//3`.
  prefs: []
  type: TYPE_NORMAL
- en: What do you think you get if you enter `1//2 + 1//2` in the REPL? If you tried
    it, you may have been surprised to find the result printed as `1//1` rather than
    simply `1`. The result of expressions involving only `Rational` numbers is a `Rational`
    number. If instead you evaluate `1//2 + 0.5`, you get the `Float64` number `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exponentiation and Infinities**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To raise a number to a power, use the `^` operator. Here are the results of
    exponentiation of various types of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All of those results should be as expected, but the last two infinite results
    merit some discussion. Division by zero, as in the next-to-last expression shown
    or the equivalent `1/0`, evaluates to `Inf`, which has the `Float64` data type.
    The `Rational` number `1//0` is also infinite, but it has the `Rational` data
    type. It behaves as an infinity should: since adding a finite number to infinity
    doesn’t change it, we have `1//0 + 1` yielding `1//0`. The type promotion rules
    still apply, so if, instead, we evaluate `1//0 + 1.0` we get `Inf`: still infinity,
    but the `Float64` infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dividing by infinity gets us zero, as it should. However, we get a `Rational`
    zero or a `Float64` zero, depending on the operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other sizes of floating-point numbers, just as there are integers.
    If we contrived to divide `a/b` where `a` had the value 1.0 of type `Float32`
    and `b` had the value 0.0 of the same data type, Julia would return yet another
    kind of infinity: `Inf32`. You’ll learn how to make variables contain types of
    your choosing in “User-Defined Types” on [page 234](ch08.xhtml#ch08lev3).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular Arithmetic**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another useful operator, `%`, returns the remainder when dividing its first
    operand by its second. For example, `5 % 2` returns `1`. As with the other arithmetic
    operators, integers yield an integer and floats yield a floating-point result.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chains of Expressions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ve briefly seen the use of the semicolon to separate expressions and, in
    the REPL, to suppress the printing of a result (see [page 11](ch01.xhtml#page_11)).
    If we have a list of expressions on a line, separated by semicolons, the result
    of the chain of expressions is the result of the last expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We assign values to variables in Julia using the `=` operator. Since the value
    of a chain of expressions is the last one, the assignment
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: results in `r` having the value 8\. If we had omitted the parentheses, `r` would
    have been assigned the value 1, because then the assignment `r = 1` would have
    been a separate expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coefficient Syntax**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In cases where it is not ambiguous, we can juxtapose a literal number with a
    variable (or function, as we’ll see later) to signify multiplication. If the juxtaposition
    creates an ambiguity, Julia will complain, and we must revert to using the `*`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplication written this way has one important difference from the use of
    `*`. It has a higher operation precedence than the other arithmetic operations,
    so it is an exception to the usual order of operations. A few examples should
    make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In an expression such as `1/2*w`, the `1/2` is calculated first and the result
    is multiplied by `2`. But since juxtaposition binds more tightly than explicit
    arithmetic operators, in the expression `1/2w`, the `2w` is calculated first.
  prefs: []
  type: TYPE_NORMAL
- en: This unusual syntax feature, along with the ability to use Greek letters and
    other Unicode symbols, helps to make math in code look more like math.
  prefs: []
  type: TYPE_NORMAL
- en: '**Expression Blocks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another way to group expressions together is with a `begin...end` block. This
    unit of code starts with the keyword `begin` and, as do all blocks in Julia, ends
    with the keyword `end`. You can enter blocks directly in the REPL. Julia sees
    that you are defining a block and will not print the prompt until the structure
    is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As with chains of expressions separated by semicolons, the result of this group
    of expressions is the final one. You can even assign the result of the block to
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The value of an expression is printed by default in the REPL and in other interactive
    environments such as Pluto. However, if you are running a program stored in a
    file, you need to use `print(expression)` to see the value on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '***Logic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Logical values are represented by `true` and `false`, which are of type `Bool`.
    The important logical operators are logical AND, which is represented by `&&`,
    and logical OR, which uses `||`. These operators are *short-circuiting*, which
    means that, going from left to right in an expression, once the final value of
    an expression can be determined to be `true` or `false`, Julia will stop and not
    evaluate the remainder. For example, in the expression `false && more stuff`,
    as soon as Julia hits the `&&` operator, it will stop and return `false`, and
    never try to evaluate the `more stuff`. It can do this because the result of this
    expression must be `false`, regardless of whether the `more stuff` is `true` or
    `false`. The programmer must be aware of this and not depend on all parts of a
    logical expression being evaluated. In an expression such as `false && (cc = 17)`,
    the part after the `&&` is never even looked at, and, therefore, the assignment
    never happens.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to ensure that all parts of a logical expression are evaluated,
    use the operators `&` and `|` instead. These are the bitwise AND and OR operators.
    They transform numbers, as we’ll see in later chapters, but act as logical operators
    when applied to `Bool`s.
  prefs: []
  type: TYPE_NORMAL
- en: '`Bool` values usually arise from the evaluation of comparisons, which use the
    operators `>`, `<`, `<=`, `>=`, `==`, and `===`. The negations of the equality
    tests are != and !==. The `<=` operator can also be spelled using the nicer-looking
    Unicode symbol `≤`, and `>=` is synonymous with `≥`. The expression `1 < 5` evaluates
    to `true`, `5 ≥ 5` is also `true`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that there are two equality comparisons. The first, `==`,
    compares two values, regardless of type. So `5 == 5.0` will give us `true`, even
    though one number is an integer and the other is a float. The other equality comparison
    tests whether two values are identical in all respects. It only returns `true`
    if no program could be written where it could possibly make a difference which
    value was used. Therefore, the expression `5 === 5.0` returns `false` because
    it is certainly possible for a program to distinguish between integers and floats.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons such as `>` don’t usually need associated negations, because the
    negation of `>` is `<=`. In fact, mathematicians sometimes pronounce that comparison
    as “not larger than.” If you need to express this as an explicit negation, you’ll
    have to negate a whole expression using the syntax `!(a > b)`, at least at the
    time of writing. Including negated comparisons in the language, which would be
    written as `!<`, for example, is under consideration.
  prefs: []
  type: TYPE_NORMAL
- en: '***Looping: while Blocks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far we’ve learned about one kind of block: the expression block using `begin`.
    A common way to write a *loop*, or piece of code that is to be repeated until
    some condition no longer holds, is with another kind of block: the `while` block.
    As with all blocks, it is terminated with the `end` keyword. The condition that
    terminates the block uses the comparisons that we learned about in the previous
    section. [Listing 2-1](ch02.xhtml#ch2lis1) is a simple example of a `while` block
    in action in the REPL.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: Looping in the REPL*'
  prefs: []
  type: TYPE_NORMAL
- en: The `println()` function prints its value on a separate line. But why did we
    have to use this at all, when expressions in the REPL are supposed to be printed
    automatically?
  prefs: []
  type: TYPE_NORMAL
- en: The `begin` blocks return a result, which is the last expression evaluated in
    the block. But `while` blocks do not return a result, so there is nothing to print.
    Whatever we want to see, we have to print explicitly. This is probably a good
    thing, as loops can evaluate many expressions and are likely to produce a mass
    of output that we don’t want.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also the initialization of the `j` variable before the start of the loop.
    In the REPL, this creates a *global* variable that is accessible and modifiable
    anywhere. After the `while` loop is finished, the value of `j` equals 5\. This
    is another behavior that differs between the REPL (and other interactive contexts
    such as Pluto) and programs in files. (I’ll explain this in more detail in “Scope”
    on [page 52](ch02.xhtml#ch02lev7).)
  prefs: []
  type: TYPE_NORMAL
- en: '****if Blocks****'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia has conventional conditional evaluation control flow using the logical
    comparison operators (see “Logic” on [page 31](ch02.xhtml#ch02lev1sec3)) and the
    keywords `if`, `elseif`, and `else`. You may nest your `if` blocks at will; each
    one is terminated with the `end` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a little program that we can run in the REPL to tell us if a number
    is even or odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If, before entering this block, you define `n` to be a number, it will give
    you the answer. If `n` is undefined or something besides a number, you’ll get
    an error message.
  prefs: []
  type: TYPE_NORMAL
- en: The `===` comparison between two integers makes the code refuse to handle any
    kinds of numbers other than integers. Try the code with, say, `n = 6` and then
    with `n = 6.0` to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `while` blocks, `if` blocks return a result, so an explicit `print()`
    statement isn’t needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve used indentation to clarify the structure of the code blocks in the examples
    through-out this book. Indentation has no syntactic meaning in Julia, but using
    it is a good habit that makes programs easier to read. You can indent code lines
    any way you please, or not at all, and it will not affect their execution. Spaces
    are needed to separate tokens, and newlines are equivalent to semicolons in their
    role as statement and expression separators. Otherwise, Julia doesn’t care about
    whitespace in general.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The various numbers that we’ve seen so far are all types that hold single values.
    Arrays are a class of Julia data types that hold *collections* of values. Scientific
    calculation typically involves operations over vectors, matrices, or higher-dimensional
    arrays, and Julia offers a convenient, concise syntax for manipulating these data
    structures, as well as excellent array performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try typing [1, 2, 3] in the REPL. This is the syntax for creating a one-dimensional
    array, also called a *vector*, of three elements. Its data type is called `Vector`.
    As before, the REPL will print the expression back, but this time in a different
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It also prints, before the value, a bit of information about the kind of value
    that it’s about to display. Julia routinely does this in the REPL when printing
    anything more complicated than a simple data type. The information is provided
    to help you interpret the display. This is useful because, when constructing arrays,
    Julia may change the types of some of the elements that you included under some
    circumstances, and it’s good to know about that. Also, the feedback about the
    shape of the array tells you whether your array operations did what you expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a case where Julia changes some numerical types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We give `a` a value entered as a literal array with three elements: an integer,
    a float, and another integer. The message from the REPL confirms that this is
    a `3-element Vector`, but the notation `Vector{Float64}` means that the elements
    of the `Vector` are all of type `Float64`. Julia has *promoted* the integers to
    floats. We can confirm this by looking at the numbers it prints, which are now
    all adorned with decimal points. When you initialize an array with a literal expression
    like the one just shown, Julia will always try to make the types of its elements
    uniform by promoting values as needed. This helps performance for later calculations
    using the array. The vertical arrangement of numbers is the way Julia prints vectors
    when possible. As we’ll see shortly, it has conventions for printing arrays of
    various shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s impossible to promote elements so that they all have the same
    type. The elements of an array can be anything, including other arrays, as shown
    in [Listing 2-2](ch02.xhtml#ch2lis2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-2: A heterogeneous array*'
  prefs: []
  type: TYPE_NORMAL
- en: Julia is still following the printing convention of arranging the elements in
    a column. The first and third elements are integers, and the second element is
    a vector. But notice how Julia promoted the integer `6` in that vector to a float
    so that all of *its* elements would have the same type. The message from the REPL
    tells us that the type of the complete vector is `Vector{Any}`, which means it’s
    a `Vector` that can hold a mixture of any types. This particular array has two
    elements of type `Int64` and one element of type `Vector{Float64}`.
  prefs: []
  type: TYPE_NORMAL
- en: We can get the value of, or assign a value to, an element of an array by *indexing*
    using square brackets. Array indices in Julia, as in Fortran and many other languages
    designed with scientific and mathematical work in mind, start at 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I’ve entered a few array indexing expressions into
    the REPL after performing the assignment in [Listing 2-2](ch02.xhtml#ch2lis2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the keyword `end` to point to the last element of an array;
    this is convenient when you don’t know its length. The second element of the array
    is another array; we can index into that array in one expression using a double
    index, as in the last expression. If you do need to find the length of an array,
    use the `length()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ranges**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia can construct ranges of numbers with a special notation. The syntax `1:5`
    represents a range of integers from `1` to `5` inclusive, counting by 1\. You
    can count by numbers other than 1 by using a version of the syntax with three
    numbers. For example, `1:3:12` represents a range with the numbers `1, 4, 7, 10`.
    The range can count down as well, using a negative step, as in `5:-1:2`. Finally,
    any of the numbers in the range specifier can be a float rather than an integer,
    in which case all the numbers in the range will be floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ranges are not arrays. They live in a kind of dimension of potentiality, ready
    to be brought to life by being used. In the meantime, they take up almost no space.
    One way to bring them to life is with the `collect()` function that turns them
    into a bona fide `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first example turns a range into a vector, while the second uses two `collect()`
    operations inside a literal vector, resulting in a vector of two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common use of ranges is in `for` loops, which is covered in “More
    Looping: for Blocks” on [page 46](ch02.xhtml#ch02lev5).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ranges are also useful in indexing expressions to extract more than one element
    from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These examples show how we can extract subsets of arrays and conveniently reverse
    the order of elements by using a decreasing range. We can extract noncontiguous
    elements by supplying the range with a step. For instance, `v[1:2:5]` yields `[0,
    10, 20]`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arrays: Beyond the First Dimension***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Vector`s we’ve seen up to now are `Array`s of one dimension. Even though
    the elements of a `Vector` may contain other collections, the `Vector` itself
    is still one-dimensional. Julia has arrays with any number of dimensions. Those
    with one dimension have their own type because they are a common special case,
    and optimizations can be applied to routines that calculate on them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrices**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Arrays with two dimensions also have a particular type, called a `Matrix`. Matrices
    arise in many contexts in mathematics and physics, and in all kinds of calculations.
    They represent linear transformations that rotate vectors, encode the coefficients
    of systems of linear equations, are used as simple data tables, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a matrix as a rectangular table of values. You can enter such tables
    directly to define them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When entering the definition of the matrix `m` into the REPL, I press ENTER
    after the number `6` to insert a line break. Julia’s REPL knows that the input
    is not complete because of the unclosed square bracket, so it doesn’t try to evaluate
    anything, but instead waits for more input. After I close the bracket and press
    ENTER, the REPL sees a complete expression, makes the assignment to the variable
    `m`, and returns the expression, preceded by a description of its shape (`2`×`2`),
    type (`Matrix`), and the type of the collection’s elements (`Int64`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take advantage of this behavior to break an expression between lines,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Without the opening parenthesis, the addition on the first line would have been
    performed immediately because it’s a complete expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrices vs. Vectors of Vectors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Make sure that you understand the difference between the `2`×`2 Matrix m` and
    this vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The latter is a one-dimensional array, whereas the former has two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some indexing should make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first element of the `Vector v` is itself a vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'A double index selects the second element of this first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we get the number `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A colon standing alone means to select everything—in this case, the entire
    second element, which is a `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example the stand-alone colon is unnecessary, as just `v[2]` would yield
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `m` is a `Matrix`, or a two-dimensional array, we select its elements
    using two indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this expression, the index `[1, 1]` means row 1, column 1, where the number
    `5` resides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a `Matrix`, the colon index is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here it’s selecting the entire second row.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalar Indexing**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The usual way to index an *n*-dimensional array is with *n* indices: one for
    a vector, two for a matrix, and so on, as in the examples just shown. If you use
    the wrong number of indices, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Julia is complaining that we tried to index a two-dimensional array as if it
    had three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you think we would get if we used just one index on `m`, as if it were
    a vector? Oddly enough, we don’t get an error, but it may not be obvious at first
    why we are getting these particular results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Apparently we can access the four elements of this matrix as if they were arranged
    as a one-dimensional array, and they seem to be arranged by column. This is indeed
    the case, and it reflects how the numbers in the matrix are arranged in memory.
    The numbers 5, 7, 6, and 8 are the contents of the matrix reading down by column,
    starting with the first column and then the second. This is called *column-major
    order*, and is the way the elements are stored in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts like “two-dimensional arrays” are abstractions that make it easier
    to think about calculations and write programs. In the machine, the elements of
    the array are stored in one long row. The numbers in a Julia `Vector`, `Matrix`,
    or other `Array` type are guaranteed to be stored contiguously. Using a single
    integer as an index is called *scalar indexing*.
  prefs: []
  type: TYPE_NORMAL
- en: The scalar index can go from 1 to the total size of the matrix. If we try `m[5]`,
    we get an error message because the matrix contains only four elements.
  prefs: []
  type: TYPE_NORMAL
- en: The Julia programmer doesn’t have to be overly concerned with the machine representation
    of data structures or think much about how they are arranged in memory, but this
    detail is important. A calculation that loops over the elements of a matrix should
    proceed in column-major order rather than row-major order because the former method
    accesses contiguous values in memory and will be more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing Arrays with Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to numbers and ranges, elements of an index expression can themselves
    be vectors. [Listing 2-3](ch02.xhtml#ch2lis3) sets up a slightly larger matrix
    so we have more room to play.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-3: Indexing with vectors*'
  prefs: []
  type: TYPE_NORMAL
- en: After defining a 3×4 `Matrix`, I extract the elements from the second and third
    columns of the second row by using a vector for the column part of the indexing
    expression ➊. Since the result is one-dimensional, Julia puts the elements into
    a `Vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Then I pull out the elements in the first two rows and the third and fourth
    columns. Since the result is two-dimensional, it becomes a (smaller) `Matrix`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen that when we access elements of a multidimensional array using a
    single index, Julia interprets that as an index into the one-dimensional array
    made by taking the elements in column-major order.
  prefs: []
  type: TYPE_NORMAL
- en: 'When indexing an array, you can refer to all of its dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this style, each of the expressions separated by commas must be a `Vector`
    or a number. (A number is treated as a `Vector` with one element, as evaluating
    `5[1]` shows.) The `Vector`s can be in the form of range expressions or simple
    colons, which are interpreted as the `Vector`s they represent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can index it as if it were a `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When using this second style, the `Array` in the index expression can have any
    shape. The result will have the shape of that `Array`. It can be larger than the
    original `Array` because you can repeat elements. The only limitation is that,
    if the original `Array` has *n* elements, you can use indices only in the range
    [1, *n*]. The same limitation applies to the first style, but to each individual
    indexing vector, where *n* means the length of the array along that dimension.
    In other words, you can’t index elements that don’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another look at the second indexing style with a couple of examples,
    using the `Array m` defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In both of these cases, the result has the same shape as the array used as an
    index. The `end` keyword picks out the last element in the source array. In the
    first style of indexing, it picks out the last element along the relevant dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concatenation Operators**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s not always convenient to use line breaks to signify the end of a row when
    defining matrices, so in Julia, you can use a semicolon instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The line break and the semicolon are both ways to spell the *vertical concatenation
    operator*. This has another name, `vcat`, so another way to construct the `m1`
    or `m2` matrix is with `vcat([6 7], [8 9])`. In this expression, `[6 7]` and `[8
    9]` are two *arguments* to the `vcat()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The space used to separate the numbers `6` and `7` in the definitions of `m1`
    and `m2` just shown is an operator, too, called the *horizontal concatenation
    operator*. It has its own explicit function as well, called `hcat()`. It’s important
    to understand the difference between `[6, 7]`, which is a `Vector` containing
    two elements, and `[6 7]`, which is a `1`×`2 Matrix` formed by horizontal concatenation
    invoked by a space. (Tabs can be used as well as spaces for this purpose.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few final examples to clarify the results of the two different
    directions of concatenation. Here’s one way to construct a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This construction combines vertical and horizontal concatenation in one expression.
    The spaces between the numbers concatenate them horizontally into arrays with
    a single row each. The semicolon vertically concatenates each of those matrices
    into a larger matrix with the first row on top of the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing the semicolon with a space produces a different shape, horizontally
    joining the two one-row matrices into a longer one-row matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the third example, we’ll ask for two *vectors* to be horizontally concatenated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The result in this example surprises some people new to the language. You may
    not immediately understand why we don’t get the same result as in the previous
    example. Horizontal concatenation really means, for a `Matrix`, joining along
    the second dimension. Since a `Vector` doesn’t have a second dimension, Julia
    first has to change each `Vector` into a `2`×`1 Matrix`, and then join them along
    the column dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is no such issue when we ask Julia to *vertically* concatenate the
    vectors because that means to join them along their first dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The result of this is a longer `Vector`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Tuples***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `Tuple` is similar to a `Vector`, with the important difference being that
    you cannot change it once it is created. Initialize a `Tuple` the same way you
    create a `Vector`, but use parentheses instead of square brackets or omit them
    entirely if that does not create an ambiguity, as shown in [Listing 2-4](ch02.xhtml#ch2lis4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-4: Some properties of tuples*'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows that the parentheses are optional, and that two tuples containing
    the same values (in the same order) are indistinguishable because they pass the
    `===` comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When a tuple contains only one element, it must be written with parentheses
    and a comma after the element—for example,* (3,)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: We can index tuples ➊ as if they were vectors, but we can neither *assign* values
    to element locations ➋ nor change the tuple in any way.
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of a vector-like collection that can’t be changed? Tuples can
    be used to store lists of values that we want to ensure can’t be altered accidentally.
    Their main use is supplying arguments to functions and collecting results, as
    we’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '***Membership***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia provides another logical operator that tests for membership in a collection.
    It’s the `in` operator, which can also take the form `∊`, entered in the REPL
    with `\in` followed by pressing TAB. In this case, the Unicode version is preferred
    because it comes with a negated form, meaning “not in,” that looks like `∉` and
    is entered in the REPL with `\notin` followed by TAB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Membership uses comparisons of values ➊, not object identity, which may not
    be what you were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: In ➋, we get `false` because the `Vector [2, 3]` is not one of the members of
    the `Vector [2, 3, 4]`. In the following example ➌ , we get a `true` result because
    the `Vector [2, 3]` *is* a member of `[[2, 3], 4]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings and Characters**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Julia is a bit unusual in that single and double quotation marks have different
    meanings: single quotes indicate characters and double quotes are for strings.
    `Char` and `String` are two distinct data types.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Characters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `Char` is entered with a pair of single quotes. Julia was created in the age
    of Unicode, so it was spared the painful transitions of older languages such as
    Python. Julia is fully Unicode aware. A `Char` can be any Unicode character, such
    as `'5'`, `'a'`, `'ñ'`, or `'∑'`. Under the hood, it’s a 32-bit value representing
    the character with its UTF-8 encoding. The value has some of the properties of
    a number, but it is not, in fact, a number.
  prefs: []
  type: TYPE_NORMAL
- en: Characters have an ordering, so you can ask `'a' < 'z'` and Julia will tell
    you `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In many languages, single and double quotes can be used interchangeably, and
    both signify strings or characters, with characters being strings with only one
    letter or other symbol. Like Elixir and SQL, Julia distinguishes between string
    and character data types:* "ab" *is a string, but* `''`*ab*`''` *is a syntax error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add an integer to a character, as in `''a'' + 1`, and Julia will give
    you the next character, `''b''`. Subtraction gives similar results. You can even
    subtract two characters to find the distance between them: `''c'' - ''a''` yields
    `2`, which means that `''a'' + 2` yields `''c''`. However, addition of characters
    is not allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `String` is entered with double quotes, like `"François"`. It is a type of
    collection, similar in some ways to a `Vector`, but with some complications. As
    it is a series of characters, you can make one by joining together single characters.
    The operator for this, unusually, is `*`. The designers of Julia decided not to
    employ the more usual `+` for several reasons, one of them being that addition
    is commutative, but the joining of characters certainly is not: `''a'' * ''b''`
    yields the string `"ab"`, but `''b'' * ''a''` yields a different string, `"ba"`.
    You can also build up a string by joining other strings: `"Fran" * "çois"` becomes
    `"François"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since strings are collections, you can use the membership operator with them,
    but only for testing the occurrence of characters: `''a'' in "abc"` yields `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test for the occurrence of a string, even one consisting of
    a single character, in another string, use the `occursin()` function: `occursin("a",
    "abc")` will give you a `true` result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the complications that arises when treating strings like vectors is
    when trying to index them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Everything was going fine until the last expression. Extracting single elements
    from the `String` gives us the `Char` that we expect. Why doesn’t `n[6]` just
    return the sixth character? Even stranger, if we try `n[8]`, we don’t get the
    last letter, but `'i'` instead. If we try `n[end]`, we *do* get the final letter.
  prefs: []
  type: TYPE_NORMAL
- en: The cause of these mysteries is that different Unicode characters take up different
    amounts of space. The index into a `String` counts the number of *bytes*, or 8-bit
    units, from the beginning of the `String`. Ordinary ASCII letters like “F” and
    “r” take up one byte each, but “ç” happens to take up two bytes. So it starts
    at position 5 when counting bytes, but the next character is at position 7, as
    the error message advises us. And we got the error because we are not allowed
    to index “inside” a character.
  prefs: []
  type: TYPE_NORMAL
- en: There are complicated ways to avoid this problem by finding out the legal indices
    for any `String`. Fortunately, you won’t have to learn these techniques, because
    one rarely needs to index strings directly. If you need to iterate over the elements
    of a `String` or any other collection, there is a far easier way to do so, which
    we’ll cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For very long strings, especially those that contain line breaks and may contain
    quote characters, there is a more convenient syntax. Delimit these strings using
    three double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, using `print()` displays strings somewhat differently from
    how they are returned as results.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Looping: for Blocks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve learned one way to iterate over a section of code, or loop, by
    using a `while` block in conjunction with a condition for stopping the iteration.
    This is appropriate for situations when we want to do something repeatedly until
    something changes—for example, when reading data from a network socket until the
    socket is closed or calculating a progressively more accurate solution to an equation
    until the error is smaller than some tolerance. In other situations, we simply
    want to iterate a fixed number of times or iterate over the members of a collection.
    This is where `for` loops come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To loop a fixed number of times, use a range expression. This loop repeats
    the calculation in [Listing 2-1](ch02.xhtml#ch2lis1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This version is simpler because we didn’t have to add 1 to `j` on each iteration.
    The variable takes on the sequence of values in the range expression, progressing
    to the next one each time through the loop. As with `while` loops, `for` loops
    do not return results, so we need an explicit `println()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use any kind of range expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re counting down by twos from 8 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may substitute* = *for the keyword* in *in any* for *block if you prefer.
    There is also a third, fancier option: you can use the membership symbol* `∈`*,
    which we first met in “**Membership**” on [page 43](ch02.xhtml#ch02lev1sec8)**.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may nest as many `for` blocks inside each other as required. In cases where
    you have a contiguous loop body, meaning you don’t have to do anything between
    the updates of any of the loop variables (such as the counters `i` and `j` in
    the following listing), Julia provides a concise syntax that avoids deeply nested
    structures on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: All the looping instructions are on one line, and we need only one `end` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same `for` block syntax lets us loop over vectors, matrices, or other containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `x` takes on the values in the `1`×`3 Matrix`, applying the
    absolute value function to each one.
  prefs: []
  type: TYPE_NORMAL
- en: The loop can be over `Vector` and `Tuple` data types as well, but a `Tuple`
    needs to be enclosed in parentheses if used in the `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can loop over arrays of any dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The elements are printed in column-major order, reflecting their layout in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since strings are containers, too, you can loop over them: François'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here we don’t have to worry about the varying lengths of Unicode characters
    as the `for` loop knows how to step from one character to the next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Projects in Julia are organized around sets of *functions*. These resemble functions
    in mathematics, in that they are maps of values to other values. In Julia the
    input and output values can be of any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to define a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `double()` function takes a number and returns twice the number. For now,
    don’t worry about the message that the REPL returns. You’ll find out what it means
    in “Functions and Methods: Multiple Dispatch” on [page 229](ch08.xhtml#ch08lev2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple functions like this one have an alternative syntax. You can shorten
    this function definition block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we don’t need a `print()` statement because a function returns the
    last expression that it evaluates. Try it by entering expressions like `double(-3.1)`
    in the REPL. Anything where `2x` makes sense will work, but if you supply an argument
    where it doesn’t, such as a string, Julia will respond with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: In the definition of the function, the `(x)` part is actually a `Tuple` with
    one element, `x`, which is `double()`’s single *argument*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can have any number of arguments. Here is one that gives the length
    of a vector from the origin if you supply the x-, y-, and z-coordinates of its
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `return` statement if you want the function to stop and return a value.
    We can use this to modify our `length3d()` function to accept only positive coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call `length3d()` with all positive arguments, all is well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'But a negative argument hits the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When you invoke the name of a function with parentheses and arguments, you
    are causing the function to execute using those arguments. This is called *calling*
    the function. If you supply the wrong number of arguments, such as trying to call
    `length3d(1, 1)`, you’ll get an error. When we want to *refer* to the function
    without calling it, we simply use its name without parentheses or arguments: for
    instance, `length3d`. We can assign functions to variables, pass them as arguments
    to other functions, and generally treat them as any other value.'
  prefs: []
  type: TYPE_NORMAL
- en: The function in [Listing 2-5](ch02.xhtml#ch2lis5) takes a value and another
    function as arguments and announces the result of applying the supplied function
    to the argument. It works with any function of one argument, as long as you supply
    an argument `x` that `f` can handle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-5: A function with a function as an argument*'
  prefs: []
  type: TYPE_NORMAL
- en: Now if we call `tellme(double, 3)` we will see the string `The result is 6`
    printed on the terminal. If we call `tellme(abs, -17)`, the function prints `The
    result is 17`.
  prefs: []
  type: TYPE_NORMAL
- en: These two examples use the `double()` function that we defined and the built-in
    absolute value function.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned previously that you don’t need to use `print()` statements to see
    the result a function returns, so you may wonder why there is one here. A function
    returns the last expression it evaluates or returns immediately if it reaches
    a `return` statement. If we had omitted the `print()` statement and had only the
    string in its place, the value of the string would be evaluated as itself, but
    not returned, because it would not be the last expression. Function execution
    would proceed to the next line and return the value `*f*(*x*)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` statement is not an expression, but a *statement*, meaning that
    it does not return a result; instead, it has the *side effect* of causing something
    to be written on the terminal. So the function produces that side effect and continues
    to the next (last) line, which is an expression, whose value it returns.
  prefs: []
  type: TYPE_NORMAL
- en: A side effect is anything that changes the state of the world, such as creating
    a file, printing to a terminal, or downloading something from the internet. A
    *pure function* is a function that has no side effects, but just returns a result.
    Writing pure functions when possible makes your code easier to debug and reason
    about, and it helps make your functions *composable*, which is the topic of the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Composing Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just as in math, *composing* functions means to supply the output of one function
    as the input of the next. Julia supplies three syntaxes for function composition.
    The first two are the same as common mathematical notations, but the third is
    a somewhat different idea. Here are all three methods, used for applying our `double()`
    function twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first way uses the syntax for applying a function to an argument, where
    the argument is the function applied to the number `3`. The number gets doubled
    and the result is itself doubled.
  prefs: []
  type: TYPE_NORMAL
- en: The second way uses a symbol that mathematicians sometimes use for composition
    and has a neater appearance, especially as we can compose as many functions as
    we want inside the first set of parentheses, something that, using the first method,
    leads to a proliferation of brackets. The series of functions are combined into
    a single composite function, applied to the argument list in the second set of
    parentheses. You can enter the little circle in the REPL using `\circ` followed
    by TAB.
  prefs: []
  type: TYPE_NORMAL
- en: The final option goes from left to right, whereas the previous two acted from
    right to left. It uses the *pipe operator* `|>` to create a *pipeline*. A value
    at the beginning, in this case 3, is fed to the first function in the pipeline,
    and the result of applying that function to the value is passed along to the second
    function, and so on. This method is a favorite of people who don’t like parentheses;
    it’s especially suited to expressing the processing of data through a series of
    transformations.
  prefs: []
  type: TYPE_NORMAL
- en: The three syntaxes for function composition are exactly equivalent. Which one
    to use is a matter of preference and convenience in a particular situation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Anonymous Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you need to define a function “on the fly,” without giving it a name.
    This happens when you want to supply a function as an argument to another function,
    but the one you supply needs to live only as long as the computation performed
    by the outer function. That is, it’s disposable.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for anonymous functions makes their operation as maps explicit, using
    the operator `->` to indicate the mapping. To define an anonymous doubling function,
    write `x -> 2x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the function has multiple variables, enclose them in parentheses: `(x, y)
    -> x/(1 + y)`.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make extensive use of anonymous functions in [Chapter 4](ch04.xhtml),
    where they’ll make it easy for us to plot mathematical functions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Broadcasting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most useful and innovative operators in Julia is the humble dot.
    With this single character you can turn any function into one that operates element
    by element on an array, a process called *broadcasting*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can transform your own functions into array functions simply by appending
    a dot to their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a doubling function and broadcast it to the elements of a vector.
    Naturally, broadcasting works with arrays of any shape.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to say about the central idea of functions in Julia. As with
    most topics in this chapter, this is just an introduction. You will meet other
    facets of functions in later chapters as we need them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *scope* of a variable refers to the region of code where it is visible and
    modifiable. When you define a variable outside any block, with a statement like
    `a = 1`, the variable `a` is *global* because you’ve defined it in the *global
    scope*.
  prefs: []
  type: TYPE_NORMAL
- en: The interactive style of computation in the REPL or Pluto leads to the routine
    use of global variables, as we improvise within an interactive workspace where
    it’s convenient to have everything immediately available. When writing permanent
    programs in files, however, it’s a good practice to limit your use of global variables.
    They are best confined to constants that need to be available to more than one
    function in your project.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use such global constants, declare them with the `const` keyword;
    for example, `const e = exp(1)`. This both ensures that you won’t accidently change
    their value later and helps the compiler to generate faster code.
  prefs: []
  type: TYPE_NORMAL
- en: This practice has several benefits. For one, it allows you to move a function
    from one file to another or reuse your functions without worrying about whether
    they depend on global quantities defined elsewhere. It keeps functions self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: Loops and functions have somewhat different scoping rules in non-interactive
    contexts. After we master them, we’ll learn about a slight modification to the
    rules that makes working in the REPL more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Not all blocks create local scopes. Expression blocks, beginning with the `begin`
    keyword (see “Expression Blocks” on [page 30](ch02.xhtml#ch02sec1sec6)), do not
    establish their own scopes. Their scope is the same as the scope of whatever they’re
    contained within. If the `begin` block is at the top level, it’s in the global
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same holds for `if` blocks: they’re simply part of their immediate environment
    as far as scope is concerned.'
  prefs: []
  type: TYPE_NORMAL
- en: The other blocks introduced in this chapter establish *local scopes*, but there
    are two different varieties. One type of scope applies to function definition
    blocks while a different type applies to `for` and `while` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scoping Rules for Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inside a function definition, all variables are local unless you decorate them
    with the `global` keyword. You can use this notation one time, anywhere within
    the function definition, because variables can be of only one variety in any one
    block.
  prefs: []
  type: TYPE_NORMAL
- en: If you assign to a variable that doesn’t already exist as a local variable,
    a new one is created. If it *does* already exist, because the function definition
    is inside another block where it’s defined, that preexisting variable is used.
  prefs: []
  type: TYPE_NORMAL
- en: None of this has to do with variables supplied as function arguments. Those
    are simply local; but see “Mutability” on [page 55](ch02.xhtml#ch02lev8).
  prefs: []
  type: TYPE_NORMAL
- en: 'A few examples should help to make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If you save this listing in a file and run it by entering `julia` `*filename*`,
    you’ll get an error message complaining that `s` is undefined. Although `s` is
    already defined to be 0 in the global scope, its assignment within the function
    definition creates a new local variable. However, this variable is undefined on
    the right-hand side of the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program file, however, runs without error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It prints out `0`. Since there is no *assignment* to `s` within the function
    body, no new local variable is created and the function uses the existing global
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: What if we really had intended, in the first example, to use that global `s`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This program prints out `1`. The declaration of `s` as `global` within the function
    means that the variable inside the function is the same as the one outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve looked at the relationship between variables defined inside a function
    and global variables. We also need to consider what happens if a variable inside
    the function block shares a name with a *local* variable outside the function.
    This can happen if everything is enclosed within another block—say, another function
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When this program is run, it prints `1`. The variable `s` is a local variable
    because it’s defined inside a function block ➊. Therefore, according to the scoping
    rules, when it’s assigned to inside the inner function `glos()` ➋, a new local
    variable is *not* created; rather, the existing one is used.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scoping Rules for Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both kinds of loops, `for` blocks and `while` blocks, create local scopes, but
    they have one small change in behavior from function blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you assign to a variable inside a loop, and a variable with the same name
    already exists in the global scope, two things happen: the variable is treated
    as local within the loop, with the value of its global version unaffected by whatever
    happens inside the loop, and Julia prints a warning about this on the terminal
    when you run the program from a file (but not from the REPL, as discussed in the
    next section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the warning is that *shadowing* a global variable inside a loop
    creates an ambiguity: Julia is not sure whether you mean to create a new local
    variable or use the global one. Rather than refusing to run your program, Julia
    picks one option, but warns you that you may have intended something different.
    Remove the ambiguity by using the `local` or `global` keyword to decorate the
    variable inside the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: An even better solution for program files is to put the loop and the variables
    it references inside a function. Then the variables will not be in the global
    scope and Julia will not issue a warning. In general, while we do many calculations
    in the REPL outside functions, it’s a good practice to place as much as possible
    inside functions when writing program files.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior, therefore, is exactly the same as in the case of function blocks,
    aside from the warning. Julia issues this warning in the case of loops, but not
    function definitions, because while functions generally use only the variables
    passed in as arguments and their private, local variables, it is common for loops
    to be initialized by variables set up outside the loops. When everything is local,
    as when the loop and its initialization are all inside a function, there is little
    chance that the programmer repeated the variable name inadvertently. However,
    when the variable external to the loop is global, there is the distinct possibility
    that this happened by accident. The loop could have been copied from another file
    that used the same variable names by chance, or the global variables could have
    been defined somewhere in the file thousands of lines away from the loop. To help
    keep you safe, Julia follows the scoping rules, but warns you about existing global
    variables shadowed in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '***Modification of Scoping Rules in Interactive Contexts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inside the REPL, Pluto, or other interactive contexts, different scoping rules
    for `while` and `for` loops apply. Function blocks use the same rules in both
    interactive and noninteractive contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In the REPL, if a variable is assigned within a loop, and the variable does
    not exist in the global REPL scope, a new local variable is established. If, however,
    a global variable with the same name already exists, that global variable is used
    and no warning is issued.
  prefs: []
  type: TYPE_NORMAL
- en: This modification to the scoping rules makes work in the REPL, with all of its
    global variables, more convenient. It also simplifies the process of debugging
    parts of functions inside the REPL. Imagine that a loop, along with its initialization,
    is copied from within a big function defined in a file and pasted into the REPL.
    In the file, the initialization variables are local, but when pasted into the
    REPL, they appear in the global scope. The REPL rule exceptions allow loops and
    their initializations to behave the same way they do in their natural habitat,
    nestled within function blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutability**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In several places in this chapter, the `===` operator appears as a test of
    strict equality: two values are only equal in the `===` sense, or identical, if
    they have the same types as well as the same values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know more, we can revisit the `===` comparison in other contexts.
    The following example might surprise you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Both sides of the comparison look the same: both are `Vector`s and both contain
    the same single value with the same `Int64` type. And, as you can check, `1 ===
    1` is `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the result in the listing just shown is that every time you create
    an array, you are creating a new object with its own location in memory. The two
    arrays on the two sides of the comparison are not identical because they reside
    at different memory addresses. It is possible to write a program that distinguishes
    between them, which is the formal criterion that forces the `===` comparison to
    yield `false`.
  prefs: []
  type: TYPE_NORMAL
- en: A number, in contrast, is just a number, with no particular location in memory.
    The integer `1` is always identical to itself.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes clearer if we assign these objects to variables. If we make the
    assignments `v1 = [1]` and `v2 = [1]`, the comparison `v1 === v2` will yield `false`,
    while `v1 == v2` gives us `true`. The two variables have the same *values*, but
    are different objects. They are not identical. Think of the variables as references,
    or pointers, to the memory addresses where the arrays begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are *mutable*. Here is one consequence of the mutability of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'First we define `a` to be a `Vector` with one element. Then we set `b` to be
    equal to `a`. We then change ➊ the first (and only) element of `b` to be `7`.
    After that, when we take a look at `a` ➋, we find that *it’s* changed, too. Its
    first element is now also `7`. The clue to why this happens is in the last line:
    `b` and `a` are not simply equal, they are *identical*. When we make the assignment
    `b = a` we make `b` point to the same memory address as `a`. The two variables
    are now pointers to, or names for, the same object. So if we change, or *mutate*,
    one, we see the same change in the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some objects in Julia are *immutable*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: After making the assignments to `a` and `b`, they become alternative names for
    the numbers `1` and `7`. A table keeps track of the names we’ve given to values,
    and it lives somewhere in memory, but the variables are names for values, not
    for memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: In the second line, we tell Julia to also use b as a name for the number `1`.
    After that, we change our mind and want `b` to mean `7`, but that does not change
    the assignment of `a` as a name for `1`. You can’t mutate the number `1`. It will
    always be `1`, and has always been `1`. But you can mutate an array by changing
    what it contains.
  prefs: []
  type: TYPE_NORMAL
- en: '***Functions That Mutate Their Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can mutate an array by assigning directly to one of its elements with an
    indexing expression. We can also mutate an array by adding an element to its end,
    making it larger. We can always do this with concatenation. For example, if `v`
    is a `Vector` of numbers, `v = [v; 7]` sticks the number 7 onto the end, increasing
    its length by one.
  prefs: []
  type: TYPE_NORMAL
- en: However, in calculations where we are going to be doing that many times, this
    is inefficient. If we get to a point where there is not enough room in memory
    to keep the elements of `v` contiguous, Julia will have to relocate it, perhaps
    repeatedly. A more efficient option is to use a built-in function made for this
    purpose. If we call `push! (v, 7)`, that mutates `v` just as in the concatenation
    version, but more efficiently. When `push!()` runs out of space, it moves the
    array and reserves memory for its later expansion. Every time it finds it needs
    to do this, it reserves a geometrically increasing amount of space. The function
    is designed to handle the common scenario of a loop in which an array is appended
    to in a time- and space-efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the exclamation point in the name `push!()` warns and reminds the
    user that this is a function that mutates its argument(s). It’s not part of the
    actual syntax, but a strongly held convention. Usually functions in Julia use
    their arguments as inputs to a calculation that returns a result: what we called
    “pure functions” earlier. Functions with `!` in the name change their arguments,
    and may or may not also return a result. The `push!()` function does return a
    result as well: the mutated array.'
  prefs: []
  type: TYPE_NORMAL
- en: As the use of the exclamation point is a convention rather than a rule enforced
    by the language, it’s possible for any function to mutate its mutable arguments,
    but the convention is valuable, and Julia programmers are careful in following
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of `push!()` is `pop!()`, which mutates its argument by removing
    its last element and returning that element as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '***Strings Are Immutable***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although the `String` type is a collection, like `Vector`, `Matrix`, and the
    other array types, it is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can index a string, but we can’t assign to its elements, because strings
    cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This shows that we can index the string just as we index a vector, but we’re
    not allowed to change any of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to make a new string, we have to define it literally or build it
    from parts of existing strings or from characters, using concatenation and indexing.
    Here is a little function that takes a string and returns a decorative version
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `end-5` in the last line of the function is there to omit the final bullet
    and the space before it—a bullet takes up four bytes.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the technique used here of building up a string by repeatedly redefining
    it is a good idea only for small strings and limited numbers of redefinitions.
    Because strings are immutable, each time through the loop creates a new object,
    which is wasteful of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to write a function that performs the same task without creating
    a bunch of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The built-in `join()` function takes an array of strings and joins them together
    into one longer string. It will convert other types to strings if there is a sensible
    way to do so, which means `join([5, "6", 'X'])` returns `"56X"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sort of opposite to `join()` is `split()`. This function takes a string and
    turns it into an array of shorter strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: It splits on whitespace of any length, unless you supply a second argument in
    the form of a character or string. In that case, it will use the second argument
    as a delimiter; the delimiters themselves are discarded.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments in Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An introduction to a language would not be complete without including the syntax
    for comments.
  prefs: []
  type: TYPE_NORMAL
- en: A single-line comment in Julia begins with a hash mark (`#`) and can appear
    on its own line or following a line of code. In other words, Julia ignores everything
    after a naked `#` character.
  prefs: []
  type: TYPE_NORMAL
- en: To include a multiline comment, begin it with `#=` and end it with `=#`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Congratulations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve mastered everything in this chapter, you are now able to write useful
    Julia programs to solve many types of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the programs you write will not be completely self-contained, however.
    Modern programmers build solutions by combining their own code with functions
    from existing libraries written by others and by themselves. The next chapter
    will introduce a system built into Julia that helps you manage these libraries
    and your own programs.
  prefs: []
  type: TYPE_NORMAL
