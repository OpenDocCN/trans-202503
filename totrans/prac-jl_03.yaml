- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: LANGUAGE BASICS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言基础**'
- en: '*Learning another language is not only learning different words for the same
    things, but learning another way to think about things.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*学习另一种语言不仅仅是学习用不同的词表达相同的事物，而是学习另一种思维方式。*'
- en: '*—*Flora Lewis'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*—*弗洛拉·路易斯'
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Sometimes people new to programming ask why there are so many computer languages.
    They all have different syntaxes. Some use braces and semicolons, like C and JavaScript;
    some use whitespace, like Python; some are notorious for a proliferation of parentheses,
    like the Lisp family; and some use keywords, like Julia.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时刚接触编程的人会问，为什么有这么多计算机语言。它们都有不同的语法。有些使用大括号和分号，比如C和JavaScript；有些使用空格，比如Python；有些因括号多而臭名昭著，比如Lisp家族；还有些使用关键词，比如Julia。
- en: However, differences in syntax are not the real reason. With experience, variations
    in language punctuation become trivialities. It’s also true that some languages
    are faster than others, or have different demands on memory, although these are
    often properties of implementations rather than the languages themselves, but
    performance is not the real reason either.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，语法差异并不是根本原因。有了经验，语言标点的差异变得微不足道。确实，一些语言比其他语言更快，或者在内存上有不同的要求，尽管这些通常是实现的属性，而非语言本身，但性能也不是根本原因。
- en: The fundamental reason for the persistence of different languages and language
    families is that they are based on different ideas. Each language represents a
    unique conceptual framework in which to express computations. When we write a
    program, we are not simply telling a machine what to do. If that were the case,
    we would all write in the machine code into which our programs are ultimately
    translated. Instead, we are telling *people*, including ourselves, about a computation.
    Computer languages are human languages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不同语言和语言家族持续存在的根本原因在于它们基于不同的思想。每种语言代表了一个独特的概念框架，用来表达计算。当我们编写程序时，我们不仅仅是在告诉机器该做什么。如果真是这样，我们都应该直接写入程序最终会翻译成的机器代码。相反，我们是在告诉*人类*，包括我们自己，关于一个计算。计算机语言是人类语言。
- en: 'As you begin your journey through Julia, it’s important to keep this in mind.
    You are not learning merely a collection of incantations for getting the computer
    to do what you want. You are learning a way of thinking: a set of concepts that
    you can use to organize computational ideas. If you master these ideas, your programs
    will do what you expect, will perform well, and will be clear to others and even
    to your future self.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始学习Julia时，重要的是要牢记这一点。你并不是在学习一系列让计算机按你想要的方式做事的咒语。你是在学习一种思维方式：一套你可以用来组织计算概念的思想。如果你掌握了这些思想，你的程序将如你所期望的那样运行，性能良好，并且对其他人甚至是未来的你自己都清晰易懂。
- en: 'That being said, most of these overarching ideas will come out in the application
    chapters in [Part II](part2.xhtml). In this chapter, we cover the nitty-gritty:
    the bricks and stones out of which you will build your cathedrals.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这些宏观的概念将在[第二部分](part2.xhtml)的应用章节中展现出来。在这一章中，我们将深入细节：你将用来构建“大教堂”的砖石。
- en: These elements are the blocks with which you structure your Julia programs—functions,
    loops, and decisions—and the data types they interact with, such as strings, various
    kinds of numbers, and collections. After you finish this chapter, you will know
    enough about Julia to write your first programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素是你构建Julia程序的模块——函数、循环和决策——以及它们与之交互的数据类型，如字符串、各种数字和集合。完成这一章后，你将掌握足够的Julia知识，能够编写你的第一个程序。
- en: '**The Syntax: Data Types, Expressions, and Blocks**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**语法：数据类型、表达式和代码块**'
- en: In this section we’ll learn about the fundamentals of Julia syntax for creating
    the basic structures used in almost every Julia program. We’ll also be introduced
    to our first Julia data types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习Julia语法的基础，了解在几乎每个Julia程序中都会使用的基本结构。我们还将介绍第一个Julia数据类型。
- en: Throughout this chapter I’ll refer to the REPL, but these references apply equally
    well to any interactive environment for Julia, such as Pluto or VS Code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将提到REPL，但这些引用同样适用于任何Julia的交互式环境，比如Pluto或VS Code。
- en: '***Types of Numbers***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字类型***'
- en: All values in Julia have a *type*, just as in almost all programming languages.
    One of the basic types is that of a number, but, just as in mathematics, there
    are different types of numbers. In math we have positive and negative numbers,
    integers and real numbers, and more exotic varieties such as complex numbers and
    quaternions. Positive integers, or counting numbers, have been with us since before
    recorded history, but somebody had to invent all the other kinds of numbers. In
    “User-Defined Types” on [page 234](ch08.xhtml#ch08lev3), you’ll learn how you
    can invent your own kinds of Julia numbers if you want to, but for now, let’s
    look at some of the built-in types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的所有值都有一个*类型*，就像几乎所有编程语言一样。基本类型之一是数字类型，但就像数学中一样，数字也有不同的类型。在数学中，我们有正数和负数，整数和实数，还有一些更为复杂的类型，如复数和四元数。正整数，或者说计数数，自古以来就存在，但其他类型的数字是由某些人发明出来的。在《用户自定义类型》一节中，[第
    234 页](ch08.xhtml#ch08lev3)，你将学习如何在 Julia 中发明自己的数字类型，但现在让我们先看看一些内建的类型。
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Perhaps more than any other chapter in this book, it is important to read
    this one with the Julia REPL open and try things out as you read about them. Experiment
    with variations of the examples in the chapter until you feel comfortable with
    the syntax. You will use everything in this chapter repeatedly in all your programs,
    so making these details second nature now will be helpful.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*也许比本书中的任何其他章节都更重要的是，在阅读本章时一定要打开 Julia REPL 并实践你所学的内容。你可以尝试本章中的示例变体，直到你对语法感到熟悉。你将在所有的程序中反复使用本章的内容，因此现在就将这些细节变成你的第二天性将对你有所帮助。*'
- en: If you type a number without a decimal point into the REPL and press RETURN
    or ENTER, Julia will give you the same number back. A number by itself is an *expression*,
    which means something that returns a result. Since the result of evaluating a
    plain number is the number itself, that’s what you get. These whole numbers, by
    default, are given the type of `Int64`, which just means an integer that takes
    up 64 bits of storage. (I’m assuming a 64-bit system, which is a pretty safe assumption
    these days. If you are using a 32-bit system, replace `Int64` with `Int32` throughout
    this chapter.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 REPL 中输入一个没有小数点的数字并按下 RETURN 或 ENTER，Julia 会返回相同的数字。单独的数字是一个*表达式*，意思是会返回一个结果的东西。由于计算一个普通数字的结果就是它本身，所以你会得到那个数字。这些整数默认被赋予
    `Int64` 类型，意思是占用 64 位存储空间的整数。（我假设是 64 位系统，现在这个假设很安全。如果你使用的是 32 位系统，可以在本章中将 `Int64`
    替换为 `Int32`。）
- en: A number with a decimal point has the type `Float64`. The numbers 1 and 1.0
    may have the same values, but they are different to the computer. The first is
    an `Int64`, and the second is a `Float64`. This difference has various repercussions
    that will appear in our later work.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 带有小数点的数字是 `Float64` 类型。数字 1 和 1.0 可能具有相同的值，但对计算机来说它们是不同的。第一个是 `Int64`，而第二个是
    `Float64`。这种区别会在我们后续的工作中产生各种影响。
- en: Since Julia is intended, among other things, for scientific calculation, naturally
    it can deal with complex numbers as well. The syntax for entering complex numbers
    uses `im` for the imaginary unit (the square root of –1). So to enter the number
    3 + 4*i*, you write `3 + 4im`. The type of that number is called `Complex{Int64}`,
    because the numerical parts happen to be integers. The type of `3.4 + 1.1im` is
    called `Complex{Float64}`. This notation means that it’s a `Complex` type that
    has `Float64` parts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Julia 的设计目的是进行科学计算，当然它也能处理复数。输入复数的语法使用 `im` 表示虚数单位（即 -1 的平方根）。因此，要输入数字 3
    + 4*i*，你可以写成 `3 + 4im`。这个数字的类型叫做 `Complex{Int64}`，因为数字部分恰好是整数。`3.4 + 1.1im` 的类型叫做
    `Complex{Float64}`。这个表示法意味着它是一个 `Complex` 类型，包含 `Float64` 类型的部分。
- en: 'You can write very big or small numbers using the usual computer version of
    scientific notation: `6.02e23` means 6*.*02 × 10^(23). Numbers written in this
    way are `Float64`s, even if you write the mantissa as an integer. The exponent
    must be an integer, and if you prefer, you can use an uppercase E.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用通常的计算机科学计数法表示非常大或非常小的数字：`6.02e23` 表示 6.02 × 10^(23)。以这种方式书写的数字是 `Float64`
    类型，即使你将尾数写成整数。指数必须是整数，如果你愿意，也可以使用大写字母 E。
- en: Julia will rewrite your entry in “proper” scientific notation. For example,
    if you enter `1234e19` in the REPL, it will repeat the value as `1.234e22`. And
    apparently, it prefers the lowercase `e`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 会将你的输入转换为“标准”的科学计数法。例如，如果你在 REPL 中输入 `1234e19`，它会以 `1.234e22` 的形式返回该值。而且显然，它更喜欢使用小写的
    `e`。
- en: There are a few other numerical types, such as the unsigned integer `UInt64`,
    but this is enough for now. We’ll go deeper into the type system in [Chapter 8](ch08.xhtml).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的数字类型，比如无符号整数 `UInt64`，但目前这些已经足够了。我们将在 [第8章](ch08.xhtml) 中深入了解类型系统。
- en: '***Operations and Expressions***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运算与表达式***'
- en: Addition, subtraction, and multiplication work as you would expect on all these
    types of numbers. The order of operations is the same as in mathematics and is
    similarly overridden using parentheses.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 加法、减法和乘法在所有这些数字类型上都按预期工作。运算顺序与数学中的顺序相同，并且可以通过括号覆盖。
- en: Julia performs obvious *type promotion* when needed. The expression `1 + 1`
    involves only integers, and the result will be the integer `2`; there is no reason
    to return any other type. But the expression `1.0 + 1` involves a floating-point
    number, so it will return the `Float64` result `2.0`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，Julia 会显式进行*类型提升*。表达式 `1 + 1` 仅涉及整数，结果将是整数 `2`；没有理由返回其他类型。但表达式 `1.0 + 1`
    涉及浮点数，因此它将返回 `Float64` 类型的结果 `2.0`。
- en: Try some arithmetic in the REPL involving operands of various types, including
    complex numbers, to make sure you understand how promotion works. Integers are
    promoted to floats, and both of those are promoted to complex numbers, as needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中尝试一些包含各种类型操作数的算术运算，包括复数，确保你理解类型提升是如何工作的。整数会提升为浮点数，而浮点数又会根据需要提升为复数。
- en: '**Division and Rational Numbers**'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**除法与有理数**'
- en: Julia has *three* kinds of division. Every language has to decide what to do
    about expressions such as `1/2`. The problem is that both operands are integers,
    but the result is not. Some languages, such as Fortran and Python 2, evaluate
    that expression to be zero, because that is the result of taking the integer part
    before the decimal point in the answer. Other languages will promote the result
    into a float and return `0.5`; that’s what Julia does.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 有*三种*除法。每种语言都必须决定如何处理类似 `1/2` 这样的表达式。问题是，两个操作数都是整数，但结果却不是。有些语言，比如 Fortran
    和 Python 2，会将这个表达式的结果计算为零，因为这表示截取答案的小数点前的整数部分。其他语言会将结果提升为浮点数并返回 `0.5`；这就是 Julia
    所做的。
- en: 'If you want a form of division that behaves like Fortran, you can use the division
    symbol (`÷`): `1` ÷ `2` gives `0` and `4` ÷`3` gives `1`. To enter this operator
    in the REPL, enter \div followed by TAB (see “Unicode Characters” on [page 13](ch01.xhtml#ch01sec1sec7)).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要类似于 Fortran 的除法方式，可以使用除法符号 (`÷`)：`1` ÷ `2` 给出 `0`，而 `4` ÷ `3` 给出 `1`。要在
    REPL 中输入此运算符，输入 \div 然后按 TAB（请参阅 [第13页](ch01.xhtml#ch01sec1sec7)的“Unicode字符”部分）。
- en: The third form of division uses the `//` operator to define `Rational` numbers,
    which are ratios of two integers. Using this data type, you can perform exact
    arithmetic on rationals without converting the results into floats. For example,
    the expression `1//2 + 1//3` evaluates to `5//6`. Julia reduces rational numbers
    to their simplest form, so if you enter `4//6` in the REPL, it will return the
    result `2//3`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种除法形式使用 `//` 运算符定义 `Rational` 数字，即两个整数的比值。使用这种数据类型，你可以对有理数进行精确的算术运算，而无需将结果转换为浮点数。例如，表达式
    `1//2 + 1//3` 计算结果为 `5//6`。Julia 会将有理数简化为最简形式，因此，如果你在 REPL 中输入 `4//6`，它将返回结果 `2//3`。
- en: What do you think you get if you enter `1//2 + 1//2` in the REPL? If you tried
    it, you may have been surprised to find the result printed as `1//1` rather than
    simply `1`. The result of expressions involving only `Rational` numbers is a `Rational`
    number. If instead you evaluate `1//2 + 0.5`, you get the `Float64` number `1.0`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 REPL 中输入 `1//2 + 1//2`，你认为会得到什么结果？如果你尝试了，可能会惊讶地发现结果打印为 `1//1`，而不是简单的 `1`。仅包含
    `Rational` 数字的表达式的结果是一个 `Rational` 数字。如果你改为计算 `1//2 + 0.5`，你将得到 `Float64` 类型的数字
    `1.0`。
- en: '**Exponentiation and Infinities**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指数运算与无穷大**'
- en: 'To raise a number to a power, use the `^` operator. Here are the results of
    exponentiation of various types of numbers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个数字提高到幂，使用 `^` 运算符。以下是对不同类型数字进行指数运算的结果：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All of those results should be as expected, but the last two infinite results
    merit some discussion. Division by zero, as in the next-to-last expression shown
    or the equivalent `1/0`, evaluates to `Inf`, which has the `Float64` data type.
    The `Rational` number `1//0` is also infinite, but it has the `Rational` data
    type. It behaves as an infinity should: since adding a finite number to infinity
    doesn’t change it, we have `1//0 + 1` yielding `1//0`. The type promotion rules
    still apply, so if, instead, we evaluate `1//0 + 1.0` we get `Inf`: still infinity,
    but the `Float64` infinity.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些结果应该都是预期的，但最后两个无限大结果值得讨论。除以零，如倒数第二个表达式所示或等同于 `1/0`，结果为 `Inf`，其数据类型是 `Float64`。而
    `Rational` 类型的 `1//0` 也是无限大的，但它的数据类型是 `Rational`。它的行为符合无限大的特性：由于向无限大加上一个有限数不会改变它，我们有
    `1//0 + 1` 结果仍然是 `1//0`。类型提升规则依然适用，因此如果我们评估 `1//0 + 1.0`，则会得到 `Inf`：依然是无限大，但它是
    `Float64` 类型的无限大。
- en: 'Dividing by infinity gets us zero, as it should. However, we get a `Rational`
    zero or a `Float64` zero, depending on the operands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除以无限大得到零，这是符合预期的。然而，得到的零是一个 `Rational` 零或 `Float64` 零，这取决于操作数的类型：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are other sizes of floating-point numbers, just as there are integers.
    If we contrived to divide `a/b` where `a` had the value 1.0 of type `Float32`
    and `b` had the value 0.0 of the same data type, Julia would return yet another
    kind of infinity: `Inf32`. You’ll learn how to make variables contain types of
    your choosing in “User-Defined Types” on [page 234](ch08.xhtml#ch08lev3).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数还有其他的大小，就像整数一样。如果我们设法计算 `a/b`，其中 `a` 的值为 `Float32` 类型的 1.0，而 `b` 的值为相同数据类型的
    0.0，Julia 会返回另一种类型的无限大：`Inf32`。你将在[第234页](ch08.xhtml#ch08lev3)的《用户自定义类型》章节中学习如何让变量包含你选择的类型。
- en: '**Modular Arithmetic**'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**模运算**'
- en: Another useful operator, `%`, returns the remainder when dividing its first
    operand by its second. For example, `5 % 2` returns `1`. As with the other arithmetic
    operators, integers yield an integer and floats yield a floating-point result.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的运算符 `%`，用于返回第一个操作数除以第二个操作数后的余数。例如，`5 % 2` 返回 `1`。与其他算术运算符类似，整数会返回整数，浮点数则返回浮点结果。
- en: '**Chains of Expressions**'
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**表达式链**'
- en: 'We’ve briefly seen the use of the semicolon to separate expressions and, in
    the REPL, to suppress the printing of a result (see [page 11](ch01.xhtml#page_11)).
    If we have a list of expressions on a line, separated by semicolons, the result
    of the chain of expressions is the result of the last expression:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地看了如何使用分号分隔表达式，并且在 REPL 中使用分号来抑制结果的打印（参见[第11页](ch01.xhtml#page_11)）。如果一行中有多个用分号分隔的表达式，那么一连串表达式的结果就是最后一个表达式的结果：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We assign values to variables in Julia using the `=` operator. Since the value
    of a chain of expressions is the last one, the assignment
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `=` 运算符在 Julia 中给变量赋值。由于表达式链的值是最后一个，因此赋值
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: results in `r` having the value 8\. If we had omitted the parentheses, `r` would
    have been assigned the value 1, because then the assignment `r = 1` would have
    been a separate expression.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `r` 的值为 8。如果我们省略了括号，`r` 的值将被赋为 1，因为此时赋值 `r = 1` 会成为一个独立的表达式。
- en: '**Coefficient Syntax**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**系数语法**'
- en: In cases where it is not ambiguous, we can juxtapose a literal number with a
    variable (or function, as we’ll see later) to signify multiplication. If the juxtaposition
    creates an ambiguity, Julia will complain, and we must revert to using the `*`
    operator.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有歧义的情况下，我们可以将一个字面量数与一个变量（或稍后我们将看到的函数）并排，以表示乘法。如果并排的组合造成歧义，Julia 会报错，我们必须改用
    `*` 运算符。
- en: 'Multiplication written this way has one important difference from the use of
    `*`. It has a higher operation precedence than the other arithmetic operations,
    so it is an exception to the usual order of operations. A few examples should
    make this clear:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种写法的乘法与使用 `*` 运算符的乘法有一个重要的区别。它的运算优先级高于其他算术运算符，因此它是运算优先级规则的例外。几个例子应该能让这一点更清楚：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In an expression such as `1/2*w`, the `1/2` is calculated first and the result
    is multiplied by `2`. But since juxtaposition binds more tightly than explicit
    arithmetic operators, in the expression `1/2w`, the `2w` is calculated first.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式 `1/2*w` 中，`1/2` 先计算，结果再与 `2` 相乘。但由于连接符的优先级高于显式的算术运算符，在表达式 `1/2w` 中，`2w`
    会先计算。
- en: This unusual syntax feature, along with the ability to use Greek letters and
    other Unicode symbols, helps to make math in code look more like math.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不寻常的语法特性，以及能够使用希腊字母和其他 Unicode 符号，使得代码中的数学表达更像数学公式。
- en: '**Expression Blocks**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**表达式块**'
- en: 'Another way to group expressions together is with a `begin...end` block. This
    unit of code starts with the keyword `begin` and, as do all blocks in Julia, ends
    with the keyword `end`. You can enter blocks directly in the REPL. Julia sees
    that you are defining a block and will not print the prompt until the structure
    is complete:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将表达式组合在一起的方式是使用`begin...end`块。这个代码单元从`begin`关键字开始，就像所有Julia中的块一样，最终用`end`关键字结束。你可以直接在REPL中输入这些块。Julia会识别你正在定义一个块，直到结构完成，才会停止提示符的输出：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As with chains of expressions separated by semicolons, the result of this group
    of expressions is the final one. You can even assign the result of the block to
    a variable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与由分号分隔的表达式链一样，这组表达式的结果是最后一个表达式的结果。你甚至可以将这个块的结果赋值给一个变量：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The value of an expression is printed by default in the REPL and in other interactive
    environments such as Pluto. However, if you are running a program stored in a
    file, you need to use `print(expression)` to see the value on the terminal.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL和其他交互式环境中（如Pluto），表达式的值会默认打印出来。然而，如果你在运行存储在文件中的程序，你需要使用`print(expression)`才能在终端上看到值。
- en: '***Logic***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逻辑***'
- en: Logical values are represented by `true` and `false`, which are of type `Bool`.
    The important logical operators are logical AND, which is represented by `&&`,
    and logical OR, which uses `||`. These operators are *short-circuiting*, which
    means that, going from left to right in an expression, once the final value of
    an expression can be determined to be `true` or `false`, Julia will stop and not
    evaluate the remainder. For example, in the expression `false && more stuff`,
    as soon as Julia hits the `&&` operator, it will stop and return `false`, and
    never try to evaluate the `more stuff`. It can do this because the result of this
    expression must be `false`, regardless of whether the `more stuff` is `true` or
    `false`. The programmer must be aware of this and not depend on all parts of a
    logical expression being evaluated. In an expression such as `false && (cc = 17)`,
    the part after the `&&` is never even looked at, and, therefore, the assignment
    never happens.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑值由`true`和`false`表示，它们的类型是`Bool`。重要的逻辑运算符包括逻辑与（AND），用`&&`表示，以及逻辑或（OR），用`||`表示。这些运算符是*短路*的，这意味着，在从左到右的表达式中，一旦可以确定表达式的最终值是`true`或`false`，Julia会停止计算并不会再评估剩余部分。例如，在表达式`false
    && more stuff`中，一旦Julia遇到`&&`运算符，它就会停止并返回`false`，而不会再尝试评估`more stuff`。它之所以能这么做，是因为这个表达式的结果必须是`false`，无论`more
    stuff`是`true`还是`false`。程序员需要意识到这一点，不要依赖逻辑表达式的所有部分都会被评估。在表达式如`false && (cc = 17)`中，`&&`后面的部分根本不会被查看，因此赋值操作也不会发生。
- en: If you need to ensure that all parts of a logical expression are evaluated,
    use the operators `&` and `|` instead. These are the bitwise AND and OR operators.
    They transform numbers, as we’ll see in later chapters, but act as logical operators
    when applied to `Bool`s.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要确保逻辑表达式的所有部分都被评估，使用`&`和`|`运算符代替它们。这些是按位与和按位或运算符。它们会转换数字，正如我们将在后面的章节中看到的那样，但在应用于`Bool`类型时，它们也作为逻辑运算符使用。
- en: '`Bool` values usually arise from the evaluation of comparisons, which use the
    operators `>`, `<`, `<=`, `>=`, `==`, and `===`. The negations of the equality
    tests are != and !==. The `<=` operator can also be spelled using the nicer-looking
    Unicode symbol `≤`, and `>=` is synonymous with `≥`. The expression `1 < 5` evaluates
    to `true`, `5 ≥ 5` is also `true`, and so on.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bool`值通常来源于比较的结果，这些比较使用运算符`>`、`<`、`<=`、`>=`、`==`和`===`。等式比较的否定形式是`!=`和`!==`。`<=`运算符也可以用更好看的Unicode符号`≤`来表示，`>=`与`≥`同义。表达式`1
    < 5`的结果是`true`，`5 ≥ 5`也是`true`，以此类推。'
- en: You may have noticed that there are two equality comparisons. The first, `==`,
    compares two values, regardless of type. So `5 == 5.0` will give us `true`, even
    though one number is an integer and the other is a float. The other equality comparison
    tests whether two values are identical in all respects. It only returns `true`
    if no program could be written where it could possibly make a difference which
    value was used. Therefore, the expression `5 === 5.0` returns `false` because
    it is certainly possible for a program to distinguish between integers and floats.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到有两个等式比较。第一个`==`比较两个值，而不考虑类型。因此，`5 == 5.0`会返回`true`，即使一个数字是整数，另一个是浮点数。另一个等式比较测试两个值在各方面是否相同。只有当没有程序可以写出它能区分这两个值时，才会返回`true`。因此，表达式`5
    === 5.0`返回`false`，因为程序确实可以区分整数和浮点数。
- en: Comparisons such as `>` don’t usually need associated negations, because the
    negation of `>` is `<=`. In fact, mathematicians sometimes pronounce that comparison
    as “not larger than.” If you need to express this as an explicit negation, you’ll
    have to negate a whole expression using the syntax `!(a > b)`, at least at the
    time of writing. Including negated comparisons in the language, which would be
    written as `!<`, for example, is under consideration.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 像`>`这样的比较运算符通常不需要配套的否定运算符，因为`>`的否定是`<=`。事实上，数学家有时会把这个比较说成“不是大于”。如果你需要将其表示为明确的否定，你必须使用语法`!(a
    > b)`来否定整个表达式，至少在写作时是这样。语言中是否包含否定的比较运算符（例如`!<`）正在考虑之中。
- en: '***Looping: while Blocks***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环：while块***'
- en: 'So far we’ve learned about one kind of block: the expression block using `begin`.
    A common way to write a *loop*, or piece of code that is to be repeated until
    some condition no longer holds, is with another kind of block: the `while` block.
    As with all blocks, it is terminated with the `end` keyword. The condition that
    terminates the block uses the comparisons that we learned about in the previous
    section. [Listing 2-1](ch02.xhtml#ch2lis1) is a simple example of a `while` block
    in action in the REPL.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习了一种代码块：使用`begin`的表达式块。写一个*循环*（即一段会根据某个条件持续重复的代码）的常见方式是使用另一种代码块：`while`块。像所有代码块一样，它以`end`关键字结束。终止该块的条件使用我们在上一节中学到的比较运算符。[清单2-1](ch02.xhtml#ch2lis1)展示了一个在REPL中执行的简单`while`块示例。
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-1: Looping in the REPL*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-1：在REPL中循环*'
- en: The `println()` function prints its value on a separate line. But why did we
    have to use this at all, when expressions in the REPL are supposed to be printed
    automatically?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`println()`函数会将其值打印在单独的一行上。但为什么我们需要使用它呢？因为REPL中的表达式应该自动打印。'
- en: The `begin` blocks return a result, which is the last expression evaluated in
    the block. But `while` blocks do not return a result, so there is nothing to print.
    Whatever we want to see, we have to print explicitly. This is probably a good
    thing, as loops can evaluate many expressions and are likely to produce a mass
    of output that we don’t want.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin`块会返回一个结果，即该块中最后一个被评估的表达式。而`while`块不会返回结果，因此没有任何内容会被自动打印。我们想看到的任何内容都必须显式地打印出来。这可能是件好事，因为循环可能会评估许多表达式，并产生大量我们不想要的输出。'
- en: Notice also the initialization of the `j` variable before the start of the loop.
    In the REPL, this creates a *global* variable that is accessible and modifiable
    anywhere. After the `while` loop is finished, the value of `j` equals 5\. This
    is another behavior that differs between the REPL (and other interactive contexts
    such as Pluto) and programs in files. (I’ll explain this in more detail in “Scope”
    on [page 52](ch02.xhtml#ch02lev7).)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在循环开始前对`j`变量的初始化。在REPL中，这会创建一个*全局*变量，任何地方都可以访问和修改它。循环结束后，`j`的值为5。这是REPL（以及其他交互式环境，如Pluto）与文件中的程序行为之间的另一个不同之处。（我将在“作用域”一节中详细解释这个问题，见[第52页](ch02.xhtml#ch02lev7)。）
- en: '****if Blocks****'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '****if块****'
- en: Julia has conventional conditional evaluation control flow using the logical
    comparison operators (see “Logic” on [page 31](ch02.xhtml#ch02lev1sec3)) and the
    keywords `if`, `elseif`, and `else`. You may nest your `if` blocks at will; each
    one is terminated with the `end` keyword.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Julia具有传统的条件评估控制流，使用逻辑比较运算符（参见“逻辑”一节，[第31页](ch02.xhtml#ch02lev1sec3)）以及关键字`if`、`elseif`和`else`。你可以根据需要嵌套`if`块；每个`if`块以`end`关键字结束。
- en: 'Here is a little program that we can run in the REPL to tell us if a number
    is even or odd:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小程序，我们可以在REPL中运行它，告诉我们一个数字是偶数还是奇数：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If, before entering this block, you define `n` to be a number, it will give
    you the answer. If `n` is undefined or something besides a number, you’ll get
    an error message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在进入这个代码块之前，你将`n`定义为一个数字，它将给你正确的答案。如果`n`未定义或不是数字，你将收到错误消息。
- en: The `===` comparison between two integers makes the code refuse to handle any
    kinds of numbers other than integers. Try the code with, say, `n = 6` and then
    with `n = 6.0` to see what happens.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`比较两个整数时，代码会拒绝处理任何非整数类型的数字。试试将`n = 6`和`n = 6.0`代入代码，看看会发生什么。'
- en: Unlike `while` blocks, `if` blocks return a result, so an explicit `print()`
    statement isn’t needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`块不同，`if`块会返回一个结果，因此不需要显式的`print()`语句。
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’ve used indentation to clarify the structure of the code blocks in the examples
    through-out this book. Indentation has no syntactic meaning in Julia, but using
    it is a good habit that makes programs easier to read. You can indent code lines
    any way you please, or not at all, and it will not affect their execution. Spaces
    are needed to separate tokens, and newlines are equivalent to semicolons in their
    role as statement and expression separators. Otherwise, Julia doesn’t care about
    whitespace in general.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在本书中通过缩进来明确代码块的结构。缩进在 Julia 中没有语法意义，但使用它是一个好习惯，可以让程序更容易阅读。你可以根据需要缩进代码行，或者根本不缩进，它不会影响代码的执行。空格用于分隔标记，换行符在作为语句和表达式分隔符的作用上等同于分号。除此之外，Julia
    一般不在意空白符。*'
- en: '**Arrays**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组**'
- en: The various numbers that we’ve seen so far are all types that hold single values.
    Arrays are a class of Julia data types that hold *collections* of values. Scientific
    calculation typically involves operations over vectors, matrices, or higher-dimensional
    arrays, and Julia offers a convenient, concise syntax for manipulating these data
    structures, as well as excellent array performance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的各种数字都是存储单一值的类型。数组是 Julia 数据类型的一类，用于存储*值的集合*。科学计算通常涉及对向量、矩阵或更高维度数组的操作，而
    Julia 提供了一个便捷、简洁的语法来操作这些数据结构，同时提供了优秀的数组性能。
- en: 'Try typing [1, 2, 3] in the REPL. This is the syntax for creating a one-dimensional
    array, also called a *vector*, of three elements. Its data type is called `Vector`.
    As before, the REPL will print the expression back, but this time in a different
    form:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 REPL 中输入 [1, 2, 3]。这是创建一个一维数组的语法，也叫做*向量*，包含三个元素。它的数据类型叫做 `Vector`。与之前一样，REPL
    会将表达式打印出来，但这次以不同的形式：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It also prints, before the value, a bit of information about the kind of value
    that it’s about to display. Julia routinely does this in the REPL when printing
    anything more complicated than a simple data type. The information is provided
    to help you interpret the display. This is useful because, when constructing arrays,
    Julia may change the types of some of the elements that you included under some
    circumstances, and it’s good to know about that. Also, the feedback about the
    shape of the array tells you whether your array operations did what you expected.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会在值之前打印出一些关于即将显示的值类型的信息。当在 REPL 中打印比简单数据类型更复杂的内容时，Julia 通常会这样做。提供这些信息是为了帮助你解读显示内容。这是有用的，因为在构造数组时，Julia
    可能会在某些情况下更改你包含的某些元素的类型，了解这一点是很有帮助的。此外，关于数组形状的反馈可以告诉你数组操作是否按预期执行。
- en: 'Here is a case where Julia changes some numerical types:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Julia 改变某些数字类型的例子：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We give `a` a value entered as a literal array with three elements: an integer,
    a float, and another integer. The message from the REPL confirms that this is
    a `3-element Vector`, but the notation `Vector{Float64}` means that the elements
    of the `Vector` are all of type `Float64`. Julia has *promoted* the integers to
    floats. We can confirm this by looking at the numbers it prints, which are now
    all adorned with decimal points. When you initialize an array with a literal expression
    like the one just shown, Julia will always try to make the types of its elements
    uniform by promoting values as needed. This helps performance for later calculations
    using the array. The vertical arrangement of numbers is the way Julia prints vectors
    when possible. As we’ll see shortly, it has conventions for printing arrays of
    various shapes.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 `a` 赋一个值，作为一个包含三个元素的字面量数组：一个整数、一个浮点数和另一个整数。REPL 返回的消息确认这是一个 `3-element Vector`，但
    `Vector{Float64}` 表示 `Vector` 的元素都是 `Float64` 类型。Julia 已经将整数提升为浮点数。我们可以通过查看它打印的数字来确认这一点，现在这些数字都带有小数点。当你用像刚才显示的那种字面量表达式初始化数组时，Julia
    总是会尝试通过提升值来使其元素类型统一。这有助于后续对数组的计算性能。数字的垂直排列是 Julia 在可能的情况下打印向量的方式。正如我们稍后将看到的，它有打印各种形状数组的惯例。
- en: Sometimes it’s impossible to promote elements so that they all have the same
    type. The elements of an array can be anything, including other arrays, as shown
    in [Listing 2-2](ch02.xhtml#ch2lis2).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，无法对元素进行提升，使它们都具有相同的类型。数组的元素可以是任何东西，包括其他数组，如[示例 2-2](ch02.xhtml#ch2lis2)所示。
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 2-2: A heterogeneous array*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-2：一个异质数组*'
- en: Julia is still following the printing convention of arranging the elements in
    a column. The first and third elements are integers, and the second element is
    a vector. But notice how Julia promoted the integer `6` in that vector to a float
    so that all of *its* elements would have the same type. The message from the REPL
    tells us that the type of the complete vector is `Vector{Any}`, which means it’s
    a `Vector` that can hold a mixture of any types. This particular array has two
    elements of type `Int64` and one element of type `Vector{Float64}`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Julia仍然遵循打印约定，将元素按列排列。第一个和第三个元素是整数，第二个元素是一个向量。但请注意，Julia如何将该向量中的整数`6`提升为浮点数，以确保*它*的所有元素类型一致。REPL中的信息告诉我们，这个完整向量的类型是`Vector{Any}`，这意味着它是一个可以容纳任意类型混合的`Vector`。这个特定的数组包含两个`Int64`类型元素和一个`Vector{Float64}`类型元素。
- en: We can get the value of, or assign a value to, an element of an array by *indexing*
    using square brackets. Array indices in Julia, as in Fortran and many other languages
    designed with scientific and mathematical work in mind, start at 1.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过*索引*使用方括号来获取或赋值数组元素。与Fortran及许多其他为科学和数学工作设计的语言一样，Julia中的数组索引是从1开始的。
- en: 'In the following example, I’ve entered a few array indexing expressions into
    the REPL after performing the assignment in [Listing 2-2](ch02.xhtml#ch2lis2):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我在进行[Listing 2-2](ch02.xhtml#ch2lis2)中的赋值后，将一些数组索引表达式输入到REPL中：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the use of the keyword `end` to point to the last element of an array;
    this is convenient when you don’t know its length. The second element of the array
    is another array; we can index into that array in one expression using a double
    index, as in the last expression. If you do need to find the length of an array,
    use the `length()` function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用关键字`end`来指向数组的最后一个元素；当你不知道数组长度时，这非常方便。数组的第二个元素是另一个数组；我们可以通过双重索引在一个表达式中索引该数组，如最后一个表达式所示。如果你确实需要找出数组的长度，可以使用`length()`函数。
- en: '**Ranges**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**范围**'
- en: Julia can construct ranges of numbers with a special notation. The syntax `1:5`
    represents a range of integers from `1` to `5` inclusive, counting by 1\. You
    can count by numbers other than 1 by using a version of the syntax with three
    numbers. For example, `1:3:12` represents a range with the numbers `1, 4, 7, 10`.
    The range can count down as well, using a negative step, as in `5:-1:2`. Finally,
    any of the numbers in the range specifier can be a float rather than an integer,
    in which case all the numbers in the range will be floats.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Julia可以通过一种特殊的表示法构造数字范围。语法`1:5`表示一个从`1`到`5`（包含5）的整数范围，步长为1。你可以通过使用包含三个数字的语法版本来按1以外的数字进行计数。例如，`1:3:12`表示一个包含数字`1,
    4, 7, 10`的范围。范围也可以倒序计数，使用负步长，例如`5:-1:2`。最后，范围中的任何数字都可以是浮点数而非整数，这种情况下范围中的所有数字都将是浮点数。
- en: 'Ranges are not arrays. They live in a kind of dimension of potentiality, ready
    to be brought to life by being used. In the meantime, they take up almost no space.
    One way to bring them to life is with the `collect()` function that turns them
    into a bona fide `Vector`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 范围不是数组。它们处于一种潜在的维度中，随时可以通过使用将其带入现实。与此同时，它们几乎不占用空间。将它们带入现实的一种方法是使用`collect()`函数，将其转化为真正的`Vector`：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first example turns a range into a vector, while the second uses two `collect()`
    operations inside a literal vector, resulting in a vector of two vectors.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例将范围转换为向量，而第二个示例在字面向量内部使用了两个`collect()`操作，从而得到了一个包含两个向量的向量。
- en: 'The most common use of ranges is in `for` loops, which is covered in “More
    Looping: for Blocks” on [page 46](ch02.xhtml#ch02lev5).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 范围最常用的方式是在`for`循环中，具体内容请见“更多循环：for块”章节，位于[第46页](ch02.xhtml#ch02lev5)。
- en: 'Ranges are also useful in indexing expressions to extract more than one element
    from an array:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 范围在索引表达式中也很有用，可以从数组中提取多个元素：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These examples show how we can extract subsets of arrays and conveniently reverse
    the order of elements by using a decreasing range. We can extract noncontiguous
    elements by supplying the range with a step. For instance, `v[1:2:5]` yields `[0,
    10, 20]`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了我们如何通过使用递减范围提取数组的子集并方便地反转元素顺序。我们可以通过提供带有步长的范围来提取不连续的元素。例如，`v[1:2:5]`将得到`[0,
    10, 20]`。
- en: '***Arrays: Beyond the First Dimension***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组：超越第一维***'
- en: The `Vector`s we’ve seen up to now are `Array`s of one dimension. Even though
    the elements of a `Vector` may contain other collections, the `Vector` itself
    is still one-dimensional. Julia has arrays with any number of dimensions. Those
    with one dimension have their own type because they are a common special case,
    and optimizations can be applied to routines that calculate on them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们看到的`Vector`（向量）是一个一维的`Array`（数组）。尽管`Vector`的元素可能包含其他集合，但`Vector`本身仍然是一维的。Julia有任意维度的数组。一维数组有自己的类型，因为它们是一个常见的特殊情况，并且可以对处理它们的程序进行优化。
- en: '**Matrices**'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**矩阵**'
- en: Arrays with two dimensions also have a particular type, called a `Matrix`. Matrices
    arise in many contexts in mathematics and physics, and in all kinds of calculations.
    They represent linear transformations that rotate vectors, encode the coefficients
    of systems of linear equations, are used as simple data tables, and much more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 具有两维的数组也有一种特定类型，称为`Matrix`（矩阵）。矩阵在数学和物理学的许多场合以及各种计算中都有应用。它们表示线性变换，能够旋转向量，编码线性方程组的系数，用作简单的数据表等等。
- en: 'Think of a matrix as a rectangular table of values. You can enter such tables
    directly to define them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把矩阵看作是一个矩形的值表。你可以直接输入这样的表来定义它们：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When entering the definition of the matrix `m` into the REPL, I press ENTER
    after the number `6` to insert a line break. Julia’s REPL knows that the input
    is not complete because of the unclosed square bracket, so it doesn’t try to evaluate
    anything, but instead waits for more input. After I close the bracket and press
    ENTER, the REPL sees a complete expression, makes the assignment to the variable
    `m`, and returns the expression, preceded by a description of its shape (`2`×`2`),
    type (`Matrix`), and the type of the collection’s elements (`Int64`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将矩阵`m`的定义输入REPL时，我在数字`6`后按下ENTER键以插入换行符。Julia的REPL知道由于方括号未关闭，输入还未完成，因此不会尝试计算任何内容，而是等待更多的输入。在我关闭括号并按下ENTER键后，REPL看到一个完整的表达式，将其赋值给变量`m`，并返回该表达式，前面附带了它的形状（`2`×`2`）、类型（`Matrix`）以及集合元素的类型（`Int64`）的描述。
- en: 'You can take advantage of this behavior to break an expression between lines,
    as in the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用这种行为将表达式分割到多行，如下例所示：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Without the opening parenthesis, the addition on the first line would have been
    performed immediately because it’s a complete expression.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有开括号，第一行的加法将会立即执行，因为它是一个完整的表达式。
- en: '**Matrices vs. Vectors of Vectors**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**矩阵与向量的向量**'
- en: 'Make sure that you understand the difference between the `2`×`2 Matrix m` and
    this vector:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你理解`2`×`2`矩阵`m`和这个向量之间的区别：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The latter is a one-dimensional array, whereas the former has two dimensions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是一个一维数组，而前者是一个二维数组。
- en: 'Some indexing should make this clear:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些索引操作应该能让这一点变得清晰：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the first element of the `Vector v` is itself a vector.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Vector v`的第一个元素本身就是一个向量。
- en: 'A double index selects the second element of this first element:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 双重索引选择第一个元素的第二个元素：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, we get the number `6`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们得到数字`6`。
- en: 'A colon standing alone means to select everything—in this case, the entire
    second element, which is a `Vector`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的冒号表示选择所有内容——在这种情况下，选择整个第二个元素，即一个`Vector`（向量）：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example the stand-alone colon is unnecessary, as just `v[2]` would yield
    the same result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，单独的冒号是不必要的，因为仅使用`v[2]`就能得到相同的结果。
- en: 'Since `m` is a `Matrix`, or a two-dimensional array, we select its elements
    using two indices:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`m`是一个`Matrix`（矩阵），即二维数组，我们使用两个索引来选择它的元素：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this expression, the index `[1, 1]` means row 1, column 1, where the number
    `5` resides.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，索引`[1, 1]`表示第一行第一列，其中数字`5`位于此处。
- en: 'In a `Matrix`, the colon index is useful:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Matrix`中，冒号索引非常有用：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here it’s selecting the entire second row.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择的是整个第二行。
- en: '**Scalar Indexing**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**标量索引**'
- en: 'The usual way to index an *n*-dimensional array is with *n* indices: one for
    a vector, two for a matrix, and so on, as in the examples just shown. If you use
    the wrong number of indices, you’ll get an error:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个*n*维数组，通常的索引方式是使用*n*个索引：一个用于向量，两个用于矩阵，依此类推，如上面所示的例子。如果使用错误数量的索引，会出现错误：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Julia is complaining that we tried to index a two-dimensional array as if it
    had three dimensions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Julia在抱怨我们试图将一个二维数组按三维数组的方式索引。
- en: 'What do you think we would get if we used just one index on `m`, as if it were
    a vector? Oddly enough, we don’t get an error, but it may not be obvious at first
    why we are getting these particular results:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅使用一个索引来访问`m`，就像它是一个向量一样，你认为会得到什么结果？奇怪的是，我们并不会得到错误，但一开始可能不容易理解为什么会得到这些特定的结果：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Apparently we can access the four elements of this matrix as if they were arranged
    as a one-dimensional array, and they seem to be arranged by column. This is indeed
    the case, and it reflects how the numbers in the matrix are arranged in memory.
    The numbers 5, 7, 6, and 8 are the contents of the matrix reading down by column,
    starting with the first column and then the second. This is called *column-major
    order*, and is the way the elements are stored in memory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以像访问一维数组一样访问这个矩阵的四个元素，它们似乎是按列排列的。确实如此，这反映了矩阵中的数字在内存中的排列方式。数字5、7、6和8是按列顺序读取矩阵内容的，从第一列开始，接着是第二列。这被称为*列主序*，是元素在内存中的存储方式。
- en: Concepts like “two-dimensional arrays” are abstractions that make it easier
    to think about calculations and write programs. In the machine, the elements of
    the array are stored in one long row. The numbers in a Julia `Vector`, `Matrix`,
    or other `Array` type are guaranteed to be stored contiguously. Using a single
    integer as an index is called *scalar indexing*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: “二维数组”这样的概念是为了简化计算和编程而提出的抽象。在计算机中，数组的元素是以一长行存储的。Julia中的`Vector`、`Matrix`或其他`Array`类型的数字保证是连续存储的。使用单一整数作为索引被称为*标量索引*。
- en: The scalar index can go from 1 to the total size of the matrix. If we try `m[5]`,
    we get an error message because the matrix contains only four elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 标量索引的范围可以从1到矩阵的总大小。如果我们尝试使用`m[5]`，会得到一个错误信息，因为该矩阵只有四个元素。
- en: The Julia programmer doesn’t have to be overly concerned with the machine representation
    of data structures or think much about how they are arranged in memory, but this
    detail is important. A calculation that loops over the elements of a matrix should
    proceed in column-major order rather than row-major order because the former method
    accesses contiguous values in memory and will be more efficient.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Julia程序员不必过于关注数据结构的机器表示，也不需要过多考虑它们在内存中的排列方式，但这个细节很重要。对矩阵元素进行循环的计算应该按照列主序进行，而不是行主序，因为前者会访问内存中连续的值，从而提高效率。
- en: '**Indexing Arrays with Arrays**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用数组索引数组**'
- en: In addition to numbers and ranges, elements of an index expression can themselves
    be vectors. [Listing 2-3](ch02.xhtml#ch2lis3) sets up a slightly larger matrix
    so we have more room to play.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字和范围外，索引表达式的元素本身也可以是向量。[列表 2-3](ch02.xhtml#ch2lis3)设置了一个稍大的矩阵，让我们有更多的空间来操作。
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 2-3: Indexing with vectors*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-3：使用向量进行索引*'
- en: After defining a 3×4 `Matrix`, I extract the elements from the second and third
    columns of the second row by using a vector for the column part of the indexing
    expression ➊. Since the result is one-dimensional, Julia puts the elements into
    a `Vector`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了一个3×4的`Matrix`之后，我通过使用向量来表示列部分的索引表达式 ➊，提取了第二行的第二和第三列的元素。由于结果是一维的，Julia会将这些元素放入一个`Vector`中。
- en: Then I pull out the elements in the first two rows and the third and fourth
    columns. Since the result is two-dimensional, it becomes a (smaller) `Matrix`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我提取了前两行和第三、第四列的元素。由于结果是二维的，因此它变成了一个（较小的）`Matrix`。
- en: We’ve seen that when we access elements of a multidimensional array using a
    single index, Julia interprets that as an index into the one-dimensional array
    made by taking the elements in column-major order.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当我们使用单一索引访问多维数组的元素时，Julia会将其解释为在按列主序排列的一个维数组中的索引。
- en: 'When indexing an array, you can refer to all of its dimensions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数组进行索引时，您可以引用它的所有维度：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this style, each of the expressions separated by commas must be a `Vector`
    or a number. (A number is treated as a `Vector` with one element, as evaluating
    `5[1]` shows.) The `Vector`s can be in the form of range expressions or simple
    colons, which are interpreted as the `Vector`s they represent.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种风格下，每个用逗号分隔的表达式必须是一个`Vector`或数字。（数字被当作一个元素的`Vector`，正如`5[1]`的结果所示。）这些`Vector`可以是范围表达式或简单的冒号，冒号会被解释为它们所代表的`Vector`。
- en: 'Alternatively, you can index it as if it were a `Vector`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将其当作`Vector`来索引：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When using this second style, the `Array` in the index expression can have any
    shape. The result will have the shape of that `Array`. It can be larger than the
    original `Array` because you can repeat elements. The only limitation is that,
    if the original `Array` has *n* elements, you can use indices only in the range
    [1, *n*]. The same limitation applies to the first style, but to each individual
    indexing vector, where *n* means the length of the array along that dimension.
    In other words, you can’t index elements that don’t exist.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二种风格时，索引表达式中的 `Array` 可以具有任何形状。结果将具有该 `Array` 的形状。它可能比原始的 `Array` 更大，因为可以重复元素。唯一的限制是，如果原始
    `Array` 有 *n* 个元素，你只能在范围 [1, *n*] 内使用索引。第一个风格也有相同的限制，但适用于每个单独的索引向量，其中 *n* 表示该维度上的数组长度。换句话说，你不能索引不存在的元素。
- en: 'Let’s take another look at the second indexing style with a couple of examples,
    using the `Array m` defined earlier:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看第二种索引风格，使用之前定义的 `Array m`，并通过几个示例来展示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In both of these cases, the result has the same shape as the array used as an
    index. The `end` keyword picks out the last element in the source array. In the
    first style of indexing, it picks out the last element along the relevant dimension.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，结果的形状与用作索引的数组相同。`end` 关键字选取源数组中的最后一个元素。在第一种索引风格中，它选取相关维度上的最后一个元素。
- en: '**Concatenation Operators**'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**连接操作符**'
- en: 'It’s not always convenient to use line breaks to signify the end of a row when
    defining matrices, so in Julia, you can use a semicolon instead:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义矩阵时，使用换行符表示一行的结束并不总是方便的，因此在 Julia 中，你可以改用分号：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The line break and the semicolon are both ways to spell the *vertical concatenation
    operator*. This has another name, `vcat`, so another way to construct the `m1`
    or `m2` matrix is with `vcat([6 7], [8 9])`. In this expression, `[6 7]` and `[8
    9]` are two *arguments* to the `vcat()` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符和分号都是表示 *垂直连接操作符* 的方式。这也有一个名字，叫做 `vcat`，因此构造 `m1` 或 `m2` 矩阵的另一种方式是使用 `vcat([6
    7], [8 9])`。在这个表达式中，`[6 7]` 和 `[8 9]` 是传递给 `vcat()` 函数的两个 *参数*。
- en: The space used to separate the numbers `6` and `7` in the definitions of `m1`
    and `m2` just shown is an operator, too, called the *horizontal concatenation
    operator*. It has its own explicit function as well, called `hcat()`. It’s important
    to understand the difference between `[6, 7]`, which is a `Vector` containing
    two elements, and `[6 7]`, which is a `1`×`2 Matrix` formed by horizontal concatenation
    invoked by a space. (Tabs can be used as well as spaces for this purpose.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `m1` 和 `m2` 定义中，数字 `6` 和 `7` 之间使用的空格也是一个操作符，叫做 *水平连接操作符*。它也有自己的显式函数，叫做
    `hcat()`。理解 `[6, 7]`（一个包含两个元素的 `Vector`）和 `[6 7]`（一个通过空格进行水平连接的 `1`×`2` 矩阵）之间的区别很重要。（标签也可以代替空格用于此目的。）
- en: 'The following are a few final examples to clarify the results of the two different
    directions of concatenation. Here’s one way to construct a matrix:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最终示例，用于阐明两种不同连接方式的结果。这里有一种构造矩阵的方式：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This construction combines vertical and horizontal concatenation in one expression.
    The spaces between the numbers concatenate them horizontally into arrays with
    a single row each. The semicolon vertically concatenates each of those matrices
    into a larger matrix with the first row on top of the second.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造将垂直和水平连接结合在一个表达式中。数字之间的空格将它们水平连接成每个有一行的数组。分号将这些矩阵垂直连接成一个更大的矩阵，第一行位于第二行之上。
- en: 'Replacing the semicolon with a space produces a different shape, horizontally
    joining the two one-row matrices into a longer one-row matrix:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 用空格替换分号会产生不同的形状，将两个一行的矩阵水平连接成一个更长的一行矩阵：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the third example, we’ll ask for two *vectors* to be horizontally concatenated:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，我们将请求将两个 *向量* 水平连接：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result in this example surprises some people new to the language. You may
    not immediately understand why we don’t get the same result as in the previous
    example. Horizontal concatenation really means, for a `Matrix`, joining along
    the second dimension. Since a `Vector` doesn’t have a second dimension, Julia
    first has to change each `Vector` into a `2`×`1 Matrix`, and then join them along
    the column dimension.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中的结果让一些刚接触该语言的人感到惊讶。你可能不会立即明白为什么我们没有得到与前一个示例相同的结果。水平连接实际上意味着，对于一个 `Matrix`，沿着第二维度连接。由于
    `Vector` 没有第二维度，Julia 必须先将每个 `Vector` 转换为 `2`×`1` 矩阵，然后沿着列维度将它们连接起来。
- en: 'But there is no such issue when we ask Julia to *vertically* concatenate the
    vectors because that means to join them along their first dimensions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们要求 Julia *垂直* 拼接向量时，不会遇到这种问题，因为这意味着沿着它们的第一个维度进行连接：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The result of this is a longer `Vector`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个更长的 `Vector`。
- en: '***Tuples***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***元组***'
- en: A `Tuple` is similar to a `Vector`, with the important difference being that
    you cannot change it once it is created. Initialize a `Tuple` the same way you
    create a `Vector`, but use parentheses instead of square brackets or omit them
    entirely if that does not create an ambiguity, as shown in [Listing 2-4](ch02.xhtml#ch2lis4).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tuple` 类似于 `Vector`，但重要的区别是，一旦创建，就不能再改变它。初始化 `Tuple` 的方式与创建 `Vector` 相同，只是使用圆括号而不是方括号，或者如果不造成歧义，可以完全省略圆括号，如
    [示例 2-4](ch02.xhtml#ch2lis4) 中所示。'
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 2-4: Some properties of tuples*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-4：元组的一些属性*'
- en: This example shows that the parentheses are optional, and that two tuples containing
    the same values (in the same order) are indistinguishable because they pass the
    `===` comparison.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了圆括号是可选的，并且两个包含相同值（顺序相同）的元组是不可区分的，因为它们通过了 `===` 比较。
- en: '**NOTE**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When a tuple contains only one element, it must be written with parentheses
    and a comma after the element—for example,* (3,)*.*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*当一个元组只包含一个元素时，它必须用圆括号括起来，并在元素后面加上逗号——例如，* (3,)*。*'
- en: We can index tuples ➊ as if they were vectors, but we can neither *assign* values
    to element locations ➋ nor change the tuple in any way.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理向量一样索引元组 ➊，但不能对元素位置 ➋ 进行 *赋值*，也不能以任何方式改变元组。
- en: What is the use of a vector-like collection that can’t be changed? Tuples can
    be used to store lists of values that we want to ensure can’t be altered accidentally.
    Their main use is supplying arguments to functions and collecting results, as
    we’ll see shortly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 无法改变的类似向量的集合有什么用处？元组可以用来存储我们希望确保不会被意外修改的值列表。它们的主要用途是作为函数的参数和收集结果，正如我们稍后将看到的那样。
- en: '***Membership***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***成员资格***'
- en: Julia provides another logical operator that tests for membership in a collection.
    It’s the `in` operator, which can also take the form `∊`, entered in the REPL
    with `\in` followed by pressing TAB. In this case, the Unicode version is preferred
    because it comes with a negated form, meaning “not in,” that looks like `∉` and
    is entered in the REPL with `\notin` followed by TAB.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了另一个逻辑运算符，用于测试某个元素是否属于某个集合。它是 `in` 运算符，也可以表示为 `∊`，可以在 REPL 中通过输入 `\in`
    然后按 TAB 键来实现。在这种情况下，建议使用 Unicode 版本，因为它有一个取反的形式，表示“not in”，看起来像 `∉`，可以在 REPL 中通过输入
    `\notin` 然后按 TAB 键来实现。
- en: 'Here are some examples:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Membership uses comparisons of values ➊, not object identity, which may not
    be what you were expecting.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 成员资格使用值的比较 ➊，而不是对象身份，这可能不是你所期望的。
- en: In ➋, we get `false` because the `Vector [2, 3]` is not one of the members of
    the `Vector [2, 3, 4]`. In the following example ➌ , we get a `true` result because
    the `Vector [2, 3]` *is* a member of `[[2, 3], 4]`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 中，我们得到 `false`，因为 `Vector [2, 3]` 不是 `Vector [2, 3, 4]` 的成员。在接下来的示例 ➌ 中，我们得到一个
    `true` 结果，因为 `Vector [2, 3]` *是* `[[2, 3], 4]` 的成员。
- en: '**Strings and Characters**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字符串和字符**'
- en: 'Julia is a bit unusual in that single and double quotation marks have different
    meanings: single quotes indicate characters and double quotes are for strings.
    `Char` and `String` are two distinct data types.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 有点不同，单引号和双引号有不同的含义：单引号表示字符，双引号表示字符串。`Char` 和 `String` 是两种不同的数据类型。
- en: '***Characters***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符***'
- en: A `Char` is entered with a pair of single quotes. Julia was created in the age
    of Unicode, so it was spared the painful transitions of older languages such as
    Python. Julia is fully Unicode aware. A `Char` can be any Unicode character, such
    as `'5'`, `'a'`, `'ñ'`, or `'∑'`. Under the hood, it’s a 32-bit value representing
    the character with its UTF-8 encoding. The value has some of the properties of
    a number, but it is not, in fact, a number.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Char` 是通过一对单引号输入的。Julia 是在 Unicode 时代诞生的，因此它免于像 Python 等旧语言的痛苦过渡。Julia 完全支持
    Unicode。一个 `Char` 可以是任何 Unicode 字符，例如 `''5''`、`''a''`、`''ñ''` 或 `''∑''`。在底层，它是一个
    32 位的值，代表该字符及其 UTF-8 编码。这个值具有一些数字的属性，但实际上并不是数字。'
- en: Characters have an ordering, so you can ask `'a' < 'z'` and Julia will tell
    you `true`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 字符是有序的，所以你可以询问 `'a' < 'z'`，Julia 会告诉你 `true`。
- en: '**NOTE**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In many languages, single and double quotes can be used interchangeably, and
    both signify strings or characters, with characters being strings with only one
    letter or other symbol. Like Elixir and SQL, Julia distinguishes between string
    and character data types:* "ab" *is a string, but* `''`*ab*`''` *is a syntax error.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*在许多编程语言中，单引号和双引号可以互换使用，它们都表示字符串或字符，而字符是只有一个字母或符号的字符串。像Elixir和SQL一样，Julia区分字符串和字符数据类型：*
    "ab" *是一个字符串，而* `''`*ab*`''` *则是一个语法错误。*'
- en: 'You can add an integer to a character, as in `''a'' + 1`, and Julia will give
    you the next character, `''b''`. Subtraction gives similar results. You can even
    subtract two characters to find the distance between them: `''c'' - ''a''` yields
    `2`, which means that `''a'' + 2` yields `''c''`. However, addition of characters
    is not allowed.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将整数加到字符上，比如`'a' + 1`，Julia会给你下一个字符`'b'`。减法也给出类似的结果。你甚至可以减去两个字符，找出它们之间的距离：`'c'
    - 'a'`等于`2`，这意味着`'a' + 2`等于`'c'`。然而，字符的加法是不允许的。
- en: '***Strings***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串***'
- en: 'A `String` is entered with double quotes, like `"François"`. It is a type of
    collection, similar in some ways to a `Vector`, but with some complications. As
    it is a series of characters, you can make one by joining together single characters.
    The operator for this, unusually, is `*`. The designers of Julia decided not to
    employ the more usual `+` for several reasons, one of them being that addition
    is commutative, but the joining of characters certainly is not: `''a'' * ''b''`
    yields the string `"ab"`, but `''b'' * ''a''` yields a different string, `"ba"`.
    You can also build up a string by joining other strings: `"Fran" * "çois"` becomes
    `"François"`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`用双引号表示，比如`"François"`。它是一种集合类型，在某些方面类似于`Vector`，但有一些复杂性。由于它是由字符组成的序列，你可以通过将单个字符连接起来创建一个字符串。用于此的操作符通常是`*`。Julia的设计者决定不使用更常见的`+`操作符，原因有几个，其中之一是加法是交换的，但字符的连接显然不是：`''a''
    * ''b''`产生字符串`"ab"`，但`''b'' * ''a''`则产生不同的字符串`"ba"`。你也可以通过连接其他字符串来构建一个字符串：`"Fran"
    * "çois"`变成了`"François"`。'
- en: 'Since strings are collections, you can use the membership operator with them,
    but only for testing the occurrence of characters: `''a'' in "abc"` yields `true`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是集合，你可以使用成员运算符来测试它们，但仅限于测试字符的出现情况：`'a' in "abc"`会返回`true`。
- en: 'If you want to test for the occurrence of a string, even one consisting of
    a single character, in another string, use the `occursin()` function: `occursin("a",
    "abc")` will give you a `true` result.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试一个字符串中是否存在另一个字符串，甚至是一个由单个字符组成的字符串，可以使用`occursin()`函数：`occursin("a", "abc")`会返回`true`。
- en: 'One of the complications that arises when treating strings like vectors is
    when trying to index them:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当像处理向量一样处理字符串时，会出现一个复杂的问题，即试图对它们进行索引时：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Everything was going fine until the last expression. Extracting single elements
    from the `String` gives us the `Char` that we expect. Why doesn’t `n[6]` just
    return the sixth character? Even stranger, if we try `n[8]`, we don’t get the
    last letter, but `'i'` instead. If we try `n[end]`, we *do* get the final letter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一切进展顺利，直到遇到最后一个表达式。从`String`中提取单个元素时，我们得到了预期的`Char`。为什么`n[6]`不能直接返回第六个字符呢？更奇怪的是，如果我们尝试`n[8]`，我们并没有得到最后一个字母，而是得到了`'i'`。如果我们尝试`n[end]`，我们*确实*得到了最后一个字母。
- en: The cause of these mysteries is that different Unicode characters take up different
    amounts of space. The index into a `String` counts the number of *bytes*, or 8-bit
    units, from the beginning of the `String`. Ordinary ASCII letters like “F” and
    “r” take up one byte each, but “ç” happens to take up two bytes. So it starts
    at position 5 when counting bytes, but the next character is at position 7, as
    the error message advises us. And we got the error because we are not allowed
    to index “inside” a character.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些谜团的原因在于，不同的Unicode字符占用的空间不同。`String`中的索引是通过从`String`的开头开始计算字节数，或者说8位单位数来确定的。像“F”和“r”这样的普通ASCII字母每个占用一个字节，但“ç”恰好占用两个字节。因此，当按字节计数时，它从位置5开始，但下一个字符位于位置7，正如错误信息所告知的那样。我们之所以收到错误，是因为不允许“内部”索引一个字符。
- en: There are complicated ways to avoid this problem by finding out the legal indices
    for any `String`. Fortunately, you won’t have to learn these techniques, because
    one rarely needs to index strings directly. If you need to iterate over the elements
    of a `String` or any other collection, there is a far easier way to do so, which
    we’ll cover in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些复杂的方法可以避免这个问题，通过查找任何`String`的合法索引。幸运的是，你不必学习这些技巧，因为通常不需要直接索引字符串。如果你需要遍历`String`或任何其他集合的元素，有一种更简单的方法，我们将在下一节中介绍。
- en: 'For very long strings, especially those that contain line breaks and may contain
    quote characters, there is a more convenient syntax. Delimit these strings using
    three double quotes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常长的字符串，尤其是那些包含换行符并且可能包含引号字符的字符串，有一种更方便的语法。使用三个双引号来界定这些字符串：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, using `print()` displays strings somewhat differently from
    how they are returned as results.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`print()`显示字符串与它们作为结果返回时有所不同。
- en: '**More Looping: for Blocks**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更多循环：for块**'
- en: So far, we’ve learned one way to iterate over a section of code, or loop, by
    using a `while` block in conjunction with a condition for stopping the iteration.
    This is appropriate for situations when we want to do something repeatedly until
    something changes—for example, when reading data from a network socket until the
    socket is closed or calculating a progressively more accurate solution to an equation
    until the error is smaller than some tolerance. In other situations, we simply
    want to iterate a fixed number of times or iterate over the members of a collection.
    This is where `for` loops come in.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了通过使用`while`块并结合停止迭代的条件来迭代代码段或循环。这适用于我们想要重复执行某个操作直到某个条件变化的情况——例如，当从网络套接字读取数据直到套接字关闭，或者计算一个逐渐更精确的方程解直到误差小于某个容忍度。在其他情况下，我们只是希望循环固定次数或遍历集合的成员。此时，`for`循环就派上用场了。
- en: 'To loop a fixed number of times, use a range expression. This loop repeats
    the calculation in [Listing 2-1](ch02.xhtml#ch2lis1):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要循环固定次数，可以使用范围表达式。这个循环重复计算[清单 2-1](ch02.xhtml#ch2lis1)中的内容：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This version is simpler because we didn’t have to add 1 to `j` on each iteration.
    The variable takes on the sequence of values in the range expression, progressing
    to the next one each time through the loop. As with `while` loops, `for` loops
    do not return results, so we need an explicit `println()` statement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更简单，因为我们不需要在每次迭代时给`j`加 1。变量会依次取范围表达式中的值，每次循环时进展到下一个值。与`while`循环一样，`for`循环不返回结果，因此我们需要显式的`println()`语句。
- en: 'We can use any kind of range expression:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何类型的范围表达式：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we’re counting down by twos from 8 to 1.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从 8 递减到 1，每次递减 2。
- en: '**NOTE**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may substitute* = *for the keyword* in *in any* for *block if you prefer.
    There is also a third, fancier option: you can use the membership symbol* `∈`*,
    which we first met in “**Membership**” on [page 43](ch02.xhtml#ch02lev1sec8)**.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以将* = *替换为关键字* in *，在任何* block中使用*，如果你更喜欢这样。还有一个更复杂的选项：你可以使用成员符号* `∈`*，我们第一次在“**成员**”中遇到它，见[第43页](ch02.xhtml#ch02lev1sec8)**。*'
- en: 'You may nest as many `for` blocks inside each other as required. In cases where
    you have a contiguous loop body, meaning you don’t have to do anything between
    the updates of any of the loop variables (such as the counters `i` and `j` in
    the following listing), Julia provides a concise syntax that avoids deeply nested
    structures on the page:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要嵌套任意数量的`for`块。如果你有一个连续的循环体，意味着在任何循环变量（例如以下清单中的计数器`i`和`j`）的更新之间不需要执行任何操作，Julia提供了一种简洁的语法，避免了页面上深度嵌套的结构：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All the looping instructions are on one line, and we need only one `end` statement.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有循环指令都在一行中，我们只需要一个`end`语句。
- en: 'The same `for` block syntax lets us loop over vectors, matrices, or other containers:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的`for`块语法允许我们遍历向量、矩阵或其他容器：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, `x` takes on the values in the `1`×`3 Matrix`, applying the
    absolute value function to each one.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`x`取`1`×`3 矩阵`中的值，并对每个值应用绝对值函数。
- en: The loop can be over `Vector` and `Tuple` data types as well, but a `Tuple`
    needs to be enclosed in parentheses if used in the `for` statement.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 循环也可以用于`Vector`和`Tuple`数据类型，但是如果在`for`语句中使用`Tuple`，则需要将其括在圆括号内。
- en: 'You can loop over arrays of any dimension:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遍历任何维度的数组：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The elements are printed in column-major order, reflecting their layout in memory.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 元素以列主序打印，反映了它们在内存中的布局。
- en: 'Since strings are containers, too, you can loop over them: François'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串也是容器，你可以对它们进行循环：François
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here we don’t have to worry about the varying lengths of Unicode characters
    as the `for` loop knows how to step from one character to the next.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不必担心 Unicode 字符的不同长度，因为`for`循环知道如何从一个字符步进到下一个字符。
- en: '**Functions**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数**'
- en: Projects in Julia are organized around sets of *functions*. These resemble functions
    in mathematics, in that they are maps of values to other values. In Julia the
    input and output values can be of any type.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的项目是围绕一组*函数*组织的。这些函数类似于数学中的函数，因为它们是值到其他值的映射。在Julia中，输入和输出的值可以是任何类型。
- en: 'Here is how to define a function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义函数的方法：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `double()` function takes a number and returns twice the number. For now,
    don’t worry about the message that the REPL returns. You’ll find out what it means
    in “Functions and Methods: Multiple Dispatch” on [page 229](ch08.xhtml#ch08lev2).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`double()`函数接受一个数字并返回该数字的两倍。暂时不用担心REPL返回的信息，你会在“函数与方法：多重派发”一节中了解它的含义，详见[第229页](ch08.xhtml#ch08lev2)。'
- en: 'Simple functions like this one have an alternative syntax. You can shorten
    this function definition block as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的简单函数有一种替代语法。你可以将这个函数定义块简化为如下形式：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that we don’t need a `print()` statement because a function returns the
    last expression that it evaluates. Try it by entering expressions like `double(-3.1)`
    in the REPL. Anything where `2x` makes sense will work, but if you supply an argument
    where it doesn’t, such as a string, Julia will respond with an error message.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要`print()`语句，因为函数会返回它评估的最后一个表达式。通过在REPL中输入像`double(-3.1)`这样的表达式来试试吧。任何`2x`合理的地方都能正常工作，但如果你提供了一个不合适的参数，比如字符串，Julia会返回一个错误信息。
- en: In the definition of the function, the `(x)` part is actually a `Tuple` with
    one element, `x`, which is `double()`’s single *argument*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的定义中，`(x)`部分实际上是一个包含一个元素`x`的`Tuple`，它是`double()`的唯一*参数*。
- en: 'Functions can have any number of arguments. Here is one that gives the length
    of a vector from the origin if you supply the x-, y-, and z-coordinates of its
    end:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有任意数量的参数。这里有一个函数，如果你提供它的终点的x、y和z坐标，它会返回从原点到该向量的长度：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Use the `return` statement if you want the function to stop and return a value.
    We can use this to modify our `length3d()` function to accept only positive coordinates:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望函数停止并返回一个值，使用`return`语句。我们可以用它来修改我们的`length3d()`函数，只接受正坐标：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we call `length3d()` with all positive arguments, all is well:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用所有正数的参数调用`length3d()`，一切正常：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'But a negative argument hits the `return` statement:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一个负数参数会触发`return`语句：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When you invoke the name of a function with parentheses and arguments, you
    are causing the function to execute using those arguments. This is called *calling*
    the function. If you supply the wrong number of arguments, such as trying to call
    `length3d(1, 1)`, you’ll get an error. When we want to *refer* to the function
    without calling it, we simply use its name without parentheses or arguments: for
    instance, `length3d`. We can assign functions to variables, pass them as arguments
    to other functions, and generally treat them as any other value.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用括号和参数调用函数的名字时，你是在用这些参数执行该函数。这被称为*调用*函数。如果你提供了错误的参数个数，比如尝试调用`length3d(1, 1)`，你会收到一个错误。当我们想要*引用*函数而不调用它时，我们只需使用它的名字，不加括号或参数：例如，`length3d`。我们可以将函数赋值给变量，将它们作为参数传递给其他函数，并像对待其他任何值一样处理它们。
- en: The function in [Listing 2-5](ch02.xhtml#ch2lis5) takes a value and another
    function as arguments and announces the result of applying the supplied function
    to the argument. It works with any function of one argument, as long as you supply
    an argument `x` that `f` can handle.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单2-5](ch02.xhtml#ch2lis5)中的函数接受一个值和另一个函数作为参数，并宣布应用提供的函数到该参数的结果。它适用于任何一个参数的函数，只要你提供一个`f`能够处理的参数`x`。'
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 2-5: A function with a function as an argument*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-5：一个函数接受另一个函数作为参数*'
- en: Now if we call `tellme(double, 3)` we will see the string `The result is 6`
    printed on the terminal. If we call `tellme(abs, -17)`, the function prints `The
    result is 17`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`tellme(double, 3)`，我们将在终端看到字符串`The result is 6`。如果我们调用`tellme(abs,
    -17)`，函数会打印`The result is 17`。
- en: These two examples use the `double()` function that we defined and the built-in
    absolute value function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子使用了我们定义的`double()`函数和内置的绝对值函数。
- en: I mentioned previously that you don’t need to use `print()` statements to see
    the result a function returns, so you may wonder why there is one here. A function
    returns the last expression it evaluates or returns immediately if it reaches
    a `return` statement. If we had omitted the `print()` statement and had only the
    string in its place, the value of the string would be evaluated as itself, but
    not returned, because it would not be the last expression. Function execution
    would proceed to the next line and return the value `*f*(*x*)`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，你不需要使用`print()`语句来查看函数返回的结果，所以你可能会好奇这里为什么会有一个。一个函数返回它最后计算的表达式的值，或者如果遇到`return`语句会立即返回。如果我们省略了`print()`语句，仅保留字符串，它的值会被计算出来，但不会被返回，因为它不是最后的表达式。函数的执行会继续到下一行，并返回值`*f*(*x*)`。
- en: The `print()` statement is not an expression, but a *statement*, meaning that
    it does not return a result; instead, it has the *side effect* of causing something
    to be written on the terminal. So the function produces that side effect and continues
    to the next (last) line, which is an expression, whose value it returns.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`语句不是一个表达式，而是一个*语句*，意味着它不会返回结果；相反，它具有在终端上输出内容的*副作用*。因此，这个函数产生了副作用，然后继续执行下一行（最后一行），那是一个表达式，函数返回它的值。'
- en: A side effect is anything that changes the state of the world, such as creating
    a file, printing to a terminal, or downloading something from the internet. A
    *pure function* is a function that has no side effects, but just returns a result.
    Writing pure functions when possible makes your code easier to debug and reason
    about, and it helps make your functions *composable*, which is the topic of the
    next section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是指任何改变世界状态的操作，比如创建文件、打印到终端，或者从互联网下载某些内容。*纯函数*是没有副作用的函数，它只返回结果。尽可能编写纯函数可以使你的代码更容易调试和推理，并且帮助函数变得*可组合*，这是下一节的主题。
- en: '***Composing Functions***'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数组合***'
- en: 'Just as in math, *composing* functions means to supply the output of one function
    as the input of the next. Julia supplies three syntaxes for function composition.
    The first two are the same as common mathematical notations, but the third is
    a somewhat different idea. Here are all three methods, used for applying our `double()`
    function twice:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在数学中一样，*组合*函数意味着将一个函数的输出作为下一个函数的输入。Julia提供了三种函数组合的语法。前两种与常见的数学符号相同，而第三种则是一个稍微不同的概念。下面是所有三种方法，用于将我们的`double()`函数应用两次：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first way uses the syntax for applying a function to an argument, where
    the argument is the function applied to the number `3`. The number gets doubled
    and the result is itself doubled.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法使用了应用函数到参数的语法，其中参数是应用于数字`3`的函数。数字被加倍，结果也被加倍。
- en: The second way uses a symbol that mathematicians sometimes use for composition
    and has a neater appearance, especially as we can compose as many functions as
    we want inside the first set of parentheses, something that, using the first method,
    leads to a proliferation of brackets. The series of functions are combined into
    a single composite function, applied to the argument list in the second set of
    parentheses. You can enter the little circle in the REPL using `\circ` followed
    by TAB.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法使用了数学家们有时用来表示组合的符号，外观更加整洁，特别是我们可以在第一个括号内组合任意多的函数，而使用第一种方法时会导致括号的不断增加。所有的函数被组合成一个单一的复合函数，应用到第二组括号中的参数列表上。你可以在REPL中输入小圆圈符号，通过`
    \circ `然后按TAB键。
- en: The final option goes from left to right, whereas the previous two acted from
    right to left. It uses the *pipe operator* `|>` to create a *pipeline*. A value
    at the beginning, in this case 3, is fed to the first function in the pipeline,
    and the result of applying that function to the value is passed along to the second
    function, and so on. This method is a favorite of people who don’t like parentheses;
    it’s especially suited to expressing the processing of data through a series of
    transformations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种选择是从左到右执行，而前两种从右到左执行。它使用*管道操作符*`|>`来创建一个*管道*。管道中的第一个函数接受开头的值（此处为3），并将该值应用到该函数上，结果会传递到下一个函数，依此类推。这个方法是那些不喜欢括号的人特别钟爱的，它特别适用于表示数据通过一系列转换的处理过程。
- en: The three syntaxes for function composition are exactly equivalent. Which one
    to use is a matter of preference and convenience in a particular situation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 三种函数组合的语法是完全等价的。选择使用哪一种语法取决于个人偏好以及特定情况中的便利性。
- en: '***Creating Anonymous Functions***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建匿名函数***'
- en: Sometimes you need to define a function “on the fly,” without giving it a name.
    This happens when you want to supply a function as an argument to another function,
    but the one you supply needs to live only as long as the computation performed
    by the outer function. That is, it’s disposable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要在“临时”情况下定义一个函数，而不赋予它一个名称。这通常发生在你想将一个函数作为参数传递给另一个函数时，但你传递的函数只需要在外部函数执行的计算期间存在。也就是说，它是一次性的。
- en: The syntax for anonymous functions makes their operation as maps explicit, using
    the operator `->` to indicate the mapping. To define an anonymous doubling function,
    write `x -> 2x`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数的语法使它们作为映射操作的作用变得明确，使用运算符`->`来表示映射。要定义一个匿名的倍增函数，可以写作 `x -> 2x`。
- en: 'If the function has multiple variables, enclose them in parentheses: `(x, y)
    -> x/(1 + y)`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数有多个变量，请将它们用括号括起来：`(x, y) -> x/(1 + y)`。
- en: We’ll make extensive use of anonymous functions in [Chapter 4](ch04.xhtml),
    where they’ll make it easy for us to plot mathematical functions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](ch04.xhtml)中广泛使用匿名函数，届时它们将使我们能够轻松地绘制数学函数。
- en: '***Broadcasting***'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***广播***'
- en: One of the most useful and innovative operators in Julia is the humble dot.
    With this single character you can turn any function into one that operates element
    by element on an array, a process called *broadcasting*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中最有用和最具创新性的运算符之一就是不起眼的点号。通过这个单一字符，你可以将任何函数转变为对数组逐元素操作的函数，这个过程称为*广播*。
- en: 'You can transform your own functions into array functions simply by appending
    a dot to their names:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地在函数名称后加一个点号来将自己的函数转变为数组函数：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here we define a doubling function and broadcast it to the elements of a vector.
    Naturally, broadcasting works with arrays of any shape.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个倍增函数并将其广播到一个向量的元素上。当然，广播适用于任何形状的数组。
- en: There is much more to say about the central idea of functions in Julia. As with
    most topics in this chapter, this is just an introduction. You will meet other
    facets of functions in later chapters as we need them.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Julia 中函数的核心思想还有很多要说的。和本章中的大多数话题一样，这只是一个简介。你将在后续章节中遇到函数的其他方面，随着需求的变化我们会进一步学习。
- en: '**Scope**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**作用域**'
- en: The *scope* of a variable refers to the region of code where it is visible and
    modifiable. When you define a variable outside any block, with a statement like
    `a = 1`, the variable `a` is *global* because you’ve defined it in the *global
    scope*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的*作用域*指的是代码中它可见且可修改的区域。当你在任何代码块之外定义一个变量，如 `a = 1`，变量 `a` 就是*全局的*，因为它是在*全局作用域*中定义的。
- en: The interactive style of computation in the REPL or Pluto leads to the routine
    use of global variables, as we improvise within an interactive workspace where
    it’s convenient to have everything immediately available. When writing permanent
    programs in files, however, it’s a good practice to limit your use of global variables.
    They are best confined to constants that need to be available to more than one
    function in your project.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 或 Pluto 中的交互式计算风格导致了全局变量的常规使用，因为我们在一个交互式的工作空间中进行即兴创作，方便让所有内容都能立即使用。然而，在编写文件中的永久程序时，最好限制对全局变量的使用。它们最好限制为需要在项目中多个函数之间共享的常量。
- en: If you need to use such global constants, declare them with the `const` keyword;
    for example, `const e = exp(1)`. This both ensures that you won’t accidently change
    their value later and helps the compiler to generate faster code.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用这种全局常量，可以使用 `const` 关键字声明它们；例如，`const e = exp(1)`。这不仅确保你不会意外地更改它们的值，还能帮助编译器生成更快的代码。
- en: This practice has several benefits. For one, it allows you to move a function
    from one file to another or reuse your functions without worrying about whether
    they depend on global quantities defined elsewhere. It keeps functions self-contained.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法有几个好处。首先，它允许你将一个函数从一个文件移动到另一个文件，或者在不担心它们是否依赖于其他地方定义的全局变量的情况下重用你的函数。它保持函数的自包含性。
- en: Loops and functions have somewhat different scoping rules in non-interactive
    contexts. After we master them, we’ll learn about a slight modification to the
    rules that makes working in the REPL more convenient.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在非交互式环境中，循环和函数的作用域规则有所不同。掌握它们之后，我们将学习一种规则的轻微修改，使得在 REPL 中工作更加方便。
- en: Not all blocks create local scopes. Expression blocks, beginning with the `begin`
    keyword (see “Expression Blocks” on [page 30](ch02.xhtml#ch02sec1sec6)), do not
    establish their own scopes. Their scope is the same as the scope of whatever they’re
    contained within. If the `begin` block is at the top level, it’s in the global
    scope.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的块都会创建局部作用域。以`begin`关键字开头的表达式块（参见《表达式块》在[第30页](ch02.xhtml#ch02sec1sec6)）不会创建自己的作用域。它们的作用域与它们所包含的块相同。如果`begin`块位于顶层，那么它就在全局作用域中。
- en: 'The same holds for `if` blocks: they’re simply part of their immediate environment
    as far as scope is concerned.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`if`块也是如此：就作用域而言，它们只是其直接环境的一部分。
- en: The other blocks introduced in this chapter establish *local scopes*, but there
    are two different varieties. One type of scope applies to function definition
    blocks while a different type applies to `for` and `while` blocks.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 本章引入的其他块建立了*局部作用域*，但有两种不同的类型。一个作用域适用于函数定义块，而另一个作用于`for`和`while`块。
- en: '***Scoping Rules for Functions***'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数的作用域规则***'
- en: Inside a function definition, all variables are local unless you decorate them
    with the `global` keyword. You can use this notation one time, anywhere within
    the function definition, because variables can be of only one variety in any one
    block.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义内，所有变量默认为局部变量，除非你使用`global`关键字修饰它们。你可以在函数定义的任何地方使用这种符号一次，因为在同一个块内，变量只能属于一种类型。
- en: If you assign to a variable that doesn’t already exist as a local variable,
    a new one is created. If it *does* already exist, because the function definition
    is inside another block where it’s defined, that preexisting variable is used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个尚不存在的变量赋值给一个变量，则会创建一个新变量。如果它*已经*存在，由于函数定义位于另一个块内，并且它已经在该块中定义，那么会使用那个预先存在的变量。
- en: None of this has to do with variables supplied as function arguments. Those
    are simply local; but see “Mutability” on [page 55](ch02.xhtml#ch02lev8).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都与作为函数参数传递的变量无关。那些只是局部变量；但请参见《可变性》一节，见[第55页](ch02.xhtml#ch02lev8)。
- en: 'A few examples should help to make this clear:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子应该有助于澄清这一点：
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you save this listing in a file and run it by entering `julia` `*filename*`,
    you’ll get an error message complaining that `s` is undefined. Although `s` is
    already defined to be 0 in the global scope, its assignment within the function
    definition creates a new local variable. However, this variable is undefined on
    the right-hand side of the statement.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个列表保存到文件中，并通过输入`julia` `*filename*`来运行它，你会收到一个错误消息，提示`s`未定义。尽管`s`在全局作用域中已被定义为0，但在函数定义内的赋值操作会创建一个新的局部变量。然而，在语句的右侧，这个变量是未定义的。
- en: 'This program file, however, runs without error:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个程序文件在运行时没有错误：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It prints out `0`. Since there is no *assignment* to `s` within the function
    body, no new local variable is created and the function uses the existing global
    variable.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出`0`。由于在函数体内没有对`s`进行*赋值*，因此没有创建新的局部变量，函数使用的是现有的全局变量。
- en: What if we really had intended, in the first example, to use that global `s`?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实在第一个例子中打算使用那个全局的`s`呢？
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This program prints out `1`. The declaration of `s` as `global` within the function
    means that the variable inside the function is the same as the one outside.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序输出`1`。在函数内声明`s`为`global`意味着函数内部的变量与外部的变量是相同的。
- en: 'We’ve looked at the relationship between variables defined inside a function
    and global variables. We also need to consider what happens if a variable inside
    the function block shares a name with a *local* variable outside the function.
    This can happen if everything is enclosed within another block—say, another function
    definition:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了函数内定义的变量与全局变量之间的关系。我们还需要考虑，如果函数块内的变量与函数外的*局部*变量同名会发生什么。这种情况可能发生在一切都被包含在另一个块内——比如另一个函数定义中：
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When this program is run, it prints `1`. The variable `s` is a local variable
    because it’s defined inside a function block ➊. Therefore, according to the scoping
    rules, when it’s assigned to inside the inner function `glos()` ➋, a new local
    variable is *not* created; rather, the existing one is used.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序运行时，它输出`1`。变量`s`是一个局部变量，因为它在函数块内定义 ➊。因此，根据作用域规则，当它在内部函数`glos()` ➋内被赋值时，并不会创建一个新的局部变量；相反，会使用现有的变量。
- en: '***Scoping Rules for Loops***'
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环的作用域规则***'
- en: Both kinds of loops, `for` blocks and `while` blocks, create local scopes, but
    they have one small change in behavior from function blocks.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`块和`while`块都创建局部作用域，但它们与函数块的行为有一个小的不同之处。'
- en: 'If you assign to a variable inside a loop, and a variable with the same name
    already exists in the global scope, two things happen: the variable is treated
    as local within the loop, with the value of its global version unaffected by whatever
    happens inside the loop, and Julia prints a warning about this on the terminal
    when you run the program from a file (but not from the REPL, as discussed in the
    next section).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在循环内给一个变量赋值，且全局作用域中已存在同名变量，两个事情会发生：变量在循环内被视为局部变量，循环内发生的任何操作都不会影响全局版本的值，Julia
    会在你从文件运行程序时在终端显示警告（但在 REPL 中不会，如下一节所述）。
- en: 'The reason for the warning is that *shadowing* a global variable inside a loop
    creates an ambiguity: Julia is not sure whether you mean to create a new local
    variable or use the global one. Rather than refusing to run your program, Julia
    picks one option, but warns you that you may have intended something different.
    Remove the ambiguity by using the `local` or `global` keyword to decorate the
    variable inside the loop.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 发出警告的原因是，*遮蔽*全局变量在循环内部会产生歧义：Julia 无法确定你是想创建一个新的局部变量还是使用全局变量。Julia 并不会拒绝运行你的程序，而是选择了一个选项，并警告你可能有不同的意图。通过在循环内使用`local`或`global`关键字来修饰变量，可以消除歧义。
- en: An even better solution for program files is to put the loop and the variables
    it references inside a function. Then the variables will not be in the global
    scope and Julia will not issue a warning. In general, while we do many calculations
    in the REPL outside functions, it’s a good practice to place as much as possible
    inside functions when writing program files.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序文件，一个更好的解决方案是将循环和它引用的变量放入一个函数中。这样这些变量就不会在全局作用域中，Julia 也不会发出警告。通常，虽然我们在 REPL
    中进行许多计算而不在函数内，但在编写程序文件时，将尽可能多的内容放在函数内部是一个好习惯。
- en: The behavior, therefore, is exactly the same as in the case of function blocks,
    aside from the warning. Julia issues this warning in the case of loops, but not
    function definitions, because while functions generally use only the variables
    passed in as arguments and their private, local variables, it is common for loops
    to be initialized by variables set up outside the loops. When everything is local,
    as when the loop and its initialization are all inside a function, there is little
    chance that the programmer repeated the variable name inadvertently. However,
    when the variable external to the loop is global, there is the distinct possibility
    that this happened by accident. The loop could have been copied from another file
    that used the same variable names by chance, or the global variables could have
    been defined somewhere in the file thousands of lines away from the loop. To help
    keep you safe, Julia follows the scoping rules, but warns you about existing global
    variables shadowed in the loop.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，行为与函数块的情况完全相同，唯一的区别是警告。Julia 在循环中会发出这个警告，但在函数定义中不会，因为虽然函数通常只使用作为参数传入的变量和它们的私有局部变量，但循环通常会使用在循环外部设置的变量。当所有内容都在局部作用域内时，比如循环及其初始化都在函数内部时，程序员重复变量名的可能性很小。然而，当循环外部的变量是全局变量时，意外重复的可能性就大了。这个循环可能是从另一个文件中复制过来的，而那个文件恰巧使用了相同的变量名，或者全局变量可能在距离循环几千行之外的地方定义。为了帮助你避免这种情况，Julia
    遵循作用域规则，并警告你关于在循环中被遮蔽的全局变量。
- en: '***Modification of Scoping Rules in Interactive Contexts***'
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***交互式上下文中的作用域规则修改***'
- en: Inside the REPL, Pluto, or other interactive contexts, different scoping rules
    for `while` and `for` loops apply. Function blocks use the same rules in both
    interactive and noninteractive contexts.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL、Pluto 或其他交互式上下文中，`while`和`for`循环的作用域规则与函数块不同，后者在交互式和非交互式上下文中使用相同的规则。
- en: In the REPL, if a variable is assigned within a loop, and the variable does
    not exist in the global REPL scope, a new local variable is established. If, however,
    a global variable with the same name already exists, that global variable is used
    and no warning is issued.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中，如果在循环内给一个变量赋值，且该变量在全局 REPL 作用域中不存在，则会创建一个新的局部变量。然而，如果已经存在同名的全局变量，那么将使用这个全局变量，并且不会发出警告。
- en: This modification to the scoping rules makes work in the REPL, with all of its
    global variables, more convenient. It also simplifies the process of debugging
    parts of functions inside the REPL. Imagine that a loop, along with its initialization,
    is copied from within a big function defined in a file and pasted into the REPL.
    In the file, the initialization variables are local, but when pasted into the
    REPL, they appear in the global scope. The REPL rule exceptions allow loops and
    their initializations to behave the same way they do in their natural habitat,
    nestled within function blocks.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对作用域规则的修改使得在 REPL 中的工作更加便捷，尤其是在处理所有全局变量时。它还简化了调试 REPL 内部函数部分的过程。想象一下，某个循环及其初始化从一个大函数中复制出来，并粘贴到
    REPL 中。在文件中，初始化变量是局部的，但当粘贴到 REPL 中时，它们就变成了全局作用域。REPL 中的规则例外使得循环及其初始化在 REPL 中的行为与它们在原始环境中（函数块内）一致。
- en: '**Mutability**'
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**可变性**'
- en: 'In several places in this chapter, the `===` operator appears as a test of
    strict equality: two values are only equal in the `===` sense, or identical, if
    they have the same types as well as the same values.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的多个地方，`===`操作符作为严格相等的测试出现：只有当两个值具有相同的类型和相同的值时，它们在`===`意义上才相等，或者说相同。
- en: 'Now that we know more, we can revisit the `===` comparison in other contexts.
    The following example might surprise you:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解得更多了，可以在其他上下文中重新审视`===`的比较。以下的例子可能会让你感到惊讶：
- en: '[PRE57]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Both sides of the comparison look the same: both are `Vector`s and both contain
    the same single value with the same `Int64` type. And, as you can check, `1 ===
    1` is `true`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 比较的两边看起来一样：它们都是`Vector`，并且都包含相同的单一值，且都是`Int64`类型。而且，正如你所检查的，`1 === 1`为`true`。
- en: The reason for the result in the listing just shown is that every time you create
    an array, you are creating a new object with its own location in memory. The two
    arrays on the two sides of the comparison are not identical because they reside
    at different memory addresses. It is possible to write a program that distinguishes
    between them, which is the formal criterion that forces the `===` comparison to
    yield `false`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子中结果的原因是，每次你创建一个数组时，你都在创建一个新的对象，并且该对象在内存中有自己的位置。比较两边的两个数组并不相同，因为它们位于不同的内存地址。你可以编写一个程序来区分它们，这就是强制`===`比较返回`false`的正式标准。
- en: A number, in contrast, is just a number, with no particular location in memory.
    The integer `1` is always identical to itself.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 数字则不同，它只是一个数字，在内存中没有特定的位置。整数`1`始终与自身相同。
- en: This becomes clearer if we assign these objects to variables. If we make the
    assignments `v1 = [1]` and `v2 = [1]`, the comparison `v1 === v2` will yield `false`,
    while `v1 == v2` gives us `true`. The two variables have the same *values*, but
    are different objects. They are not identical. Think of the variables as references,
    or pointers, to the memory addresses where the arrays begin.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些对象赋值给变量，就能更加清楚地理解。如果我们进行赋值`v1 = [1]`和`v2 = [1]`，那么比较`v1 === v2`会返回`false`，而`v1
    == v2`则返回`true`。这两个变量有相同的*值*，但它们是不同的对象。它们并不相同。可以把这些变量看作是对数组起始位置的引用，或者是指向内存地址的指针。
- en: 'Arrays are *mutable*. Here is one consequence of the mutability of arrays:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是*可变*的。以下是数组可变性的一个结果：
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'First we define `a` to be a `Vector` with one element. Then we set `b` to be
    equal to `a`. We then change ➊ the first (and only) element of `b` to be `7`.
    After that, when we take a look at `a` ➋, we find that *it’s* changed, too. Its
    first element is now also `7`. The clue to why this happens is in the last line:
    `b` and `a` are not simply equal, they are *identical*. When we make the assignment
    `b = a` we make `b` point to the same memory address as `a`. The two variables
    are now pointers to, or names for, the same object. So if we change, or *mutate*,
    one, we see the same change in the other.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义`a`为一个包含一个元素的`Vector`。然后我们将`b`设置为等于`a`。接着，我们将`b`的第一个（也是唯一一个）元素改为`7`。之后，当我们查看`a`时，我们发现*它*也发生了变化。它的第一个元素现在也变成了`7`。为什么会发生这种情况的线索就在最后一句：`b`和`a`不仅仅是相等，它们是*相同*的。当我们执行赋值`b
    = a`时，我们让`b`指向与`a`相同的内存地址。现在这两个变量都是指向同一对象的指针或名称。所以，如果我们更改或*修改*其中一个，另一个也会发生相同的变化。
- en: 'Some objects in Julia are *immutable*:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，有些对象是*不可变*的：
- en: '[PRE59]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: After making the assignments to `a` and `b`, they become alternative names for
    the numbers `1` and `7`. A table keeps track of the names we’ve given to values,
    and it lives somewhere in memory, but the variables are names for values, not
    for memory addresses.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`a`和`b`进行赋值后，它们成为数字`1`和`7`的替代名称。一个表格跟踪我们为值所取的名称，并存储在内存中的某个地方，但变量是值的名称，而不是内存地址的名称。
- en: In the second line, we tell Julia to also use b as a name for the number `1`.
    After that, we change our mind and want `b` to mean `7`, but that does not change
    the assignment of `a` as a name for `1`. You can’t mutate the number `1`. It will
    always be `1`, and has always been `1`. But you can mutate an array by changing
    what it contains.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们告诉Julia将b也作为数字`1`的名称。之后，我们改变主意，希望`b`代表`7`，但这并不会改变`a`作为数字`1`的名称。你不能修改数字`1`。它永远是`1`，也一直是`1`。但是，你可以通过改变一个数组的内容来修改它。
- en: '***Functions That Mutate Their Arguments***'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改其参数的函数***'
- en: We can mutate an array by assigning directly to one of its elements with an
    indexing expression. We can also mutate an array by adding an element to its end,
    making it larger. We can always do this with concatenation. For example, if `v`
    is a `Vector` of numbers, `v = [v; 7]` sticks the number 7 onto the end, increasing
    its length by one.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接为其元素分配一个值来修改数组。我们也可以通过将一个元素添加到数组的末尾来修改数组，从而使它变大。我们始终可以通过连接来做到这一点。例如，如果`v`是一个数字的`Vector`，`v
    = [v; 7]`会将数字7附加到末尾，使其长度增加1。
- en: However, in calculations where we are going to be doing that many times, this
    is inefficient. If we get to a point where there is not enough room in memory
    to keep the elements of `v` contiguous, Julia will have to relocate it, perhaps
    repeatedly. A more efficient option is to use a built-in function made for this
    purpose. If we call `push! (v, 7)`, that mutates `v` just as in the concatenation
    version, but more efficiently. When `push!()` runs out of space, it moves the
    array and reserves memory for its later expansion. Every time it finds it needs
    to do this, it reserves a geometrically increasing amount of space. The function
    is designed to handle the common scenario of a loop in which an array is appended
    to in a time- and space-efficient manner.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们需要多次进行此类计算的情况下，这样做效率不高。如果我们到达一个内存空间不足以让`v`的元素连续存放的地步，Julia将不得不移动它，可能是多次移动。更高效的选择是使用为此目的而设计的内置函数。如果我们调用`push!
    (v, 7)`，它就像连接版本一样修改`v`，但效率更高。当`push!()`没有足够的空间时，它会移动数组并为将来的扩展预留内存。每次它发现需要这样做时，它会预留一个几何增长的空间量。这个函数旨在处理常见场景：一个数组在时间和空间上都高效地被附加到一个循环中的情形。
- en: 'The use of the exclamation point in the name `push!()` warns and reminds the
    user that this is a function that mutates its argument(s). It’s not part of the
    actual syntax, but a strongly held convention. Usually functions in Julia use
    their arguments as inputs to a calculation that returns a result: what we called
    “pure functions” earlier. Functions with `!` in the name change their arguments,
    and may or may not also return a result. The `push!()` function does return a
    result as well: the mutated array.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`push!()`名称中的感叹号提醒用户这是一个会修改其参数的函数。它不是语法的一部分，而是一个强烈的约定。通常，Julia中的函数将它们的参数作为输入用于计算并返回结果：我们之前称之为“纯函数”。带有`!`的函数会改变它们的参数，可能会或不会返回结果。`push!()`函数也会返回结果：被修改后的数组。'
- en: As the use of the exclamation point is a convention rather than a rule enforced
    by the language, it’s possible for any function to mutate its mutable arguments,
    but the convention is valuable, and Julia programmers are careful in following
    it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 由于感叹号的使用是一个约定，而不是由语言强制执行的规则，因此任何函数都可以修改其可变的参数，但这个约定非常有价值，Julia程序员在遵循它时非常小心。
- en: The opposite of `push!()` is `pop!()`, which mutates its argument by removing
    its last element and returning that element as a result.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`push!()`的反义操作是`pop!()`，它通过移除参数的最后一个元素并将该元素作为结果返回，来修改其参数。'
- en: '***Strings Are Immutable***'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串是不可变的***'
- en: Although the `String` type is a collection, like `Vector`, `Matrix`, and the
    other array types, it is immutable.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`String`类型是一个集合，像`Vector`、`Matrix`和其他数组类型一样，但它是不可变的。
- en: 'We can index a string, but we can’t assign to its elements, because strings
    cannot be changed:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以索引字符串，但不能为其元素赋值，因为字符串是不可变的：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This shows that we can index the string just as we index a vector, but we’re
    not allowed to change any of its elements.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以像索引一个向量一样索引字符串，但我们不能更改它的任何元素。
- en: 'If we want to make a new string, we have to define it literally or build it
    from parts of existing strings or from characters, using concatenation and indexing.
    Here is a little function that takes a string and returns a decorative version
    of it:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个新字符串，就必须字面定义它，或者通过拼接和索引，从现有字符串的部分或字符中构建它。这里有一个小函数，它接受一个字符串并返回一个装饰版的字符串：
- en: '[PRE61]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `end-5` in the last line of the function is there to omit the final bullet
    and the space before it—a bullet takes up four bytes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最后一行的`end-5`用于省略最后的符号和它前面的空格——一个符号占用四个字节。
- en: In general, the technique used here of building up a string by repeatedly redefining
    it is a good idea only for small strings and limited numbers of redefinitions.
    Because strings are immutable, each time through the loop creates a new object,
    which is wasteful of memory.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这里使用的通过反复重新定义字符串来构建字符串的技巧，仅适用于小字符串和有限次数的重新定义。因为字符串是不可变的，每次进入循环都会创建一个新对象，这样会浪费内存。
- en: 'Here’s how to write a function that performs the same task without creating
    a bunch of strings:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何编写一个函数来执行相同任务，而不创建一堆字符串：
- en: '[PRE62]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The built-in `join()` function takes an array of strings and joins them together
    into one longer string. It will convert other types to strings if there is a sensible
    way to do so, which means `join([5, "6", 'X'])` returns `"56X"`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`join()`函数接受一个字符串数组，并将它们连接成一个更长的字符串。如果有合适的方法，它会将其他类型转换为字符串，这意味着`join([5,
    "6", 'X'])`会返回`"56X"`。
- en: 'A sort of opposite to `join()` is `split()`. This function takes a string and
    turns it into an array of shorter strings:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`的对立函数是`split()`。这个函数将一个字符串拆分成一个由较短字符串组成的数组：'
- en: '[PRE63]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It splits on whitespace of any length, unless you supply a second argument in
    the form of a character or string. In that case, it will use the second argument
    as a delimiter; the delimiters themselves are discarded.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 它会根据空白字符进行拆分，除非你提供一个第二个参数作为字符或字符串。在这种情况下，它将使用第二个参数作为分隔符；分隔符本身会被丢弃。
- en: '**Comments in Code**'
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码中的注释**'
- en: An introduction to a language would not be complete without including the syntax
    for comments.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 语言介绍如果不包括注释的语法，就不算完整。
- en: A single-line comment in Julia begins with a hash mark (`#`) and can appear
    on its own line or following a line of code. In other words, Julia ignores everything
    after a naked `#` character.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的单行注释以井号（`#`）开头，可以单独占一行，也可以跟在一行代码后面。换句话说，Julia会忽略井号后面的所有内容。
- en: To include a multiline comment, begin it with `#=` and end it with `=#`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含多行注释，需要以`#=`开头，以`=#`结尾。
- en: '**Congratulations**'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恭喜**'
- en: If you’ve mastered everything in this chapter, you are now able to write useful
    Julia programs to solve many types of problems.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经掌握了本章的所有内容，那么你现在可以编写有用的Julia程序来解决多种问题。
- en: Most of the programs you write will not be completely self-contained, however.
    Modern programmers build solutions by combining their own code with functions
    from existing libraries written by others and by themselves. The next chapter
    will introduce a system built into Julia that helps you manage these libraries
    and your own programs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你编写的大多数程序不会是完全自包含的。现代程序员通过将自己的代码与别人和自己编写的现有库中的函数结合，来构建解决方案。下一章将介绍Julia内置的一个系统，帮助你管理这些库和你自己的程序。
