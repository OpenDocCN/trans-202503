["```\n// Compute 3 factorial.\n\n #include <stdio.h>\n #include \"factorial.h\"\n\n int main(void)\n {\n     unsigned int x = 3;\n     unsigned int y;\n\n     y = factorial(x);\n     printf(\"%u! = %u\\n\", x, y);\n\n     return 0;\n }\n```", "```\n// Return n factorial.\n\n #ifndef FACTORIAL_H\n #define FACTORIAL_H\n unsigned int factorial(unsigned int n);\n #endif\n```", "```\n// Return n factorial.\n\n #include \"factorial.h\"\n\n unsigned int factorial(unsigned int n)\n {\n     unsigned int current = 1;   // Assume base case\n\n  ➊ if (n != 0) {\n      ➋ current = n * factorial(n - 1);\n     }\n     return current;\n }\n```", "```\n         .arch armv8-a\n         .file   \"factorial.c\"\n         .text\n         .align  2\n         .global factorial\n         .type   factorial, %function\n factorial:\n         stp     x29, x30, [sp, -48]!\n         mov     x29, sp\n      ➊ str     w0, [sp, 28]\n         mov     w0, 1\n         str     w0, [sp, 44]\n         ldr     w0, [sp, 28]\n      ➋ cmp     w0, 0             /// Check for base case\n         beq     .L2\n         ldr     w0, [sp, 28]\n         sub     w0, w0, #1        /// n - 1\n      ➌ bl      factorial         /// Recursive call\n         mov     w1, w0\n         ldr     w0, [sp, 28]\n      ➍ mul     w0, w0, w1        /// n * (n - 1)!\n         str     w0, [sp, 44]\n .L2:\n         ldr     w0, [sp, 44]\n         ldp     x29, x30, [sp], 48\n         ret\n         .size   factorial, .-factorial\n         .ident  \"GCC: Debian 12.2.0-14) 12.2.0\"\n         .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Compute n factorial.\n// Calling sequence:\n//    w0 <- n\n//    Returns n!\n        .arch armv8-a\n// Stack frame\n        .equ    n, 16\n     ➊ .equ    FRAME, 32\n// Code\n        .text\n        .align  2\n        .global factorial\n        .type   factorial, %function\nfactorial:\n        stp     fp, lr, [sp, -FRAME]! // Create stack frame\n        mov     fp, sp                // Set our frame pointer\n\n        str     w0, [sp, n]           // Save n\n        mov     w1, w0                //   and make a copy\n        mov     w0, 1                 // Assume base case, 0! = 1\n     ➋ cbz     w1, base_case         // Check for base case\n        sub     w0, w1, 1             // No,\n        bl      factorial             //   compute (n - 1)!\n        ldr     w1, [sp, n]           // Get n\n     ➌ mul     w0, w0, w1            // n * (n - 1)!\nbase_case:\n        ldp     fp, lr, [sp], FRAME   // Delete stack frame\n        ret                           // Back to caller\n```", "```\n(gdb) l factorial\n   11              .text\n   12              .align  2\n   13              .global factorial\n   14              .type   factorial, %function\n   15      factorial:\n   16              stp     fp, lr, [sp, -FRAME]! // Create stack frame\n   17              mov     fp, sp                // Set our frame pointer\n   18\n   19              str     w0, [sp, n]           // Save n\n   20              mov     w1, w0                //   and make a copy\n   (gdb) \n   21              mov     w0, 1                 // Assume base case, 0! = 1\n   22              cbz     w1, base_case         // Check for base case\n   23              sub     w0, w1, 1             // No,\n➊ 24              bl      factorial             //   compute (n - 1)!\n   25              ldr     w1, [sp, n]           // Get n\n   26              mul     w0, w0, w1            // n * (n - 1)!\n➋ 27      base_case:\n   28              ldp     fp, lr, [sp], FRAME   // Delete stack frame\n   29              ret                           // Back to caller\n   (gdb) b 24\n   Breakpoint 1 at 0x7cc: file factorial.s, line 24.\n   (gdb) b 27\n   Breakpoint 2 at 0x7d8: file factorial.s, line 28.\n```", "```\n(gdb) r\nStarting program: /home/bob/chapter_15/factorial_asm/three_factorial \n\nBreakpoint 1, factorial () at factorial.s:24\n24              bl      factorial             //    Compute (n - 1)!\n(gdb) i r x0 x1 sp pc\nx0             0x2                 2\nx1             0x3                 3\nsp             0x7fffffef40        0x7fffffef40\npc             0x55555507cc        0x55555507cc <factorial+28>\n(gdb) x/4gx 0x7fffffef40\n0x7fffffef40:   0x0000007fffffef60   ➊ 0x000000555555078c\n0x7fffffef50:➋ 0x0000005500000003      0x0000000000000000\n```", "```\n(gdb) c\nContinuing.\n\nBreakpoint 1, factorial () at factorial.s:24\n24              bl      factorial             //    Compute (n - 1)!\n(gdb) i r x0 x1 sp pc\nx0             0x1                 1\nx1             0x2                 2\nsp          ➊ 0x7fffffef20        0x7fffffef20\npc             0x55555507cc        0x55555507cc <factorial+28>\n(gdb) x/8gx 0x7fffffef20\n0x7fffffef20:   0x0000007fffffef40   ➋ 0x00000055555507d0\n0x7fffffef30:➌ 0x0000007f00000002      0x000000555555081c\n0x7fffffef40:   0x0000007fffffef60      0x000000555555078c\n0x7fffffef50:   0x0000005500000003      0x0000000000000000\n```", "```\n(gdb) c\nContinuing.\n\nBreakpoint 2, base_case () at factorial.s:28\n28              ldp     fp, lr, [sp], FRAME   // Delete stack frame\n(gdb) i r x0 x1 sp pc\nx0             0x1                 1\nx1             0x0                 0\nsp             0x7fffffeee0        0x7fffffeee0\npc             0x55555507d8        0x55555507d8 <base_case>\n(gdb) x/16gx 0x7fffffeee0 (@\\label{pg:recurse}@)\n0x7fffffeee0:   0x0000007fffffef00      0x00000055555507d0\n0x7fffffeef0:➊ 0x0000000000000000      0x0000000000000000\n0x7fffffef00:   0x0000007fffffef20      0x00000055555507d0\n0x7fffffef10:   0x0000007f00000001      0x0000000000000000\n0x7fffffef20:   0x0000007fffffef40      0x00000055555507d0\n0x7fffffef30:   0x0000007f00000002      0x000000555555081c\n0x7fffffef40:   0x0000007fffffef60      0x000000555555078c\n0x7fffffef50:   0x0000005500000003      0x0000000000000000\n```", "```\n(gdb) c\nContinuing.\n\nBreakpoint 2, base_case () at factorial.s:28\n28              ldp     fp, lr, [sp], FRAME   // Delete stack frame\n(gdb) i r x0 x1 sp pc\nx0             0x1                 1\nx1             0x1                 1\nsp             0x7fffffef00        0x7fffffef00\npc             0x55555507d8        0x55555507d8 <base_case>\n(gdb) x/12gx 0x7fffffef00\n0x7fffffef00:   0x0000007fffffef20      0x00000055555507d0\n0x7fffffef10:   0x0000007f00000001      0x0000000000000000\n0x7fffffef20:   0x0000007fffffef40      0x00000055555507d0\n0x7fffffef30:   0x0000007f00000002      0x000000555555081c\n0x7fffffef40:   0x0000007fffffef60      0x000000555555078c\n0x7fffffef50:   0x0000005500000003      0x0000000000000000\n```", "```\n(gdb) c\nContinuing.\n\nBreakpoint 2, base_case () at factorial.s:28\n28              ldp     fp, lr, [sp], FRAME   // Delete stack frame\n```", "```\n(gdb) c\nContinuing.\n\nBreakpoint 2, base_case () at factorial.s:28\n28              ldp     fp, lr, [sp], FRAME   // Delete stack frame\n(gdb) i r x0 x1 sp pc\nx0             0x6                 6\nx1             0x3                 3\nsp             0x7fffffef40        0x7fffffef40\npc             0x55555507d8        0x55555507d8 <base_case>\n(gdb) x/4gx 0x7fffffef40\n0x7fffffef40:   0x0000007fffffef60   ➊ 0x000000555555078c\n0x7fffffef50:   0x0000005500000003      0x0000000000000000\n```", "```\n(gdb) c\nContinuing.\n3! = 6\n[Inferior 1 (process 2310) exited normally]\n(gdb)\n```", "```\n// Add two integers and show if there is overflow.\n\n#include <stdio.h>\n#include \"add_two.h\"\n\nint main(void)\n{\n    int x, y, z, overflow;\n\n    printf(\"Enter an integer: \");\n    scanf(\"%i\", &x);\n    printf(\"Enter an integer: \");\n    scanf(\"%i\", &y);\n    overflow = add_two(&z, x, y);\n    printf(\"%i + %i = %i\\n\", x, y, z);\n    if (overflow)\n        printf(\"** Overflow occurred **\\n\");\n\n    return 0;\n}\n```", "```\n// Add two integers and return 1 for overflow, 0 for no overflow.\n\n#ifndef ADD_TWO_H\n#define ADD_TWO_H\nint add_two(int *a, int b, int c);\n#endif\n```", "```\n// Add two integers and return 1 for overflow, 0 for no overflow.\n\n#include \"add_two.h\"\n\nint add_two(int *a, int b, int c)\n{\n    int sum;\n    int overflow = 0;   // Assume no overflow\n\n    sum = b + c;\n ➊ if (((b > 0) && (c > 0) && (sum < 0)) ||\n            ((b < 0) && (c < 0) && (sum > 0))) {\n        overflow = 1;\n    }\n    *a = sum;\n\n    return overflow;\n}\n```", "```\n        .arch armv8-a\n        .file   \"add_two.c\"\n        .text\n        .align  2\n        .global add_two\n        .type   add_two, %function\nadd_two:\n        sub     sp, sp, #32\n        str     x0, [sp, 12]    /// a\n        str     w1, [sp, 8]     /// b\n        str     w2, [sp]        /// c\n        str     wzr, [sp, 28]   /// overflow = 0;\n        ldr     w1, [sp, 12]\n        ldr     w0, [sp, 8]\n        add     w0, w1, w0\n        str     w0, [sp, 24]\n     ➊ ldr     w0, [sp, 12]    /// Start overflow check\n        cmp     w0, 0\n        ble     .L2\n        ldr     w0, [sp, 8]\n        cmp     w0, 0\n        ble     .L2\n        ldr     w0, [sp, 24]\n        cmp     w0, 0\n        blt     .L3\n.L2:\n        ldr     w0, [sp, 12]\n        cmp     w0, 0\n        bge     .L4\n        ldr     w0, [sp, 8]\n        cmp     w0, 0\n        bge     .L4\n        ldr     w0, [sp, 24]\n        cmp     w0, 0\n        ble     .L4\n.L3:\n        mov     w0, 1\n        str     w0, [sp, 28]    /// overflow = 1;\n.L4:\n        ldr     x0, [sp]\n        ldr     w1, [sp, 24]\n        str     w1, [x0]\n        ldr     w0, [sp, 28]\n        add     sp, sp, 32\n        ret\n        .size   addTwo, .-addTwo\n        .ident  \"GCC: Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Add two integers and output the sum; return overflow T or F.\n// Calling sequence:\n//    x0 <- address a, for output\n//    w1 <- integer b\n//    w2 <- integer c\n//    Returns 1 for overflow, 0 for no overflow\n        .arch armv8-a\n// Code\n        .text\n        .align  2\n        .global add_two\n        .type   add_two, %function\nadd_two:\n        adds    w1, w1, w2            // Add and set condition flags\n        str     w1, [x0]              // Store output\n     ➊ cinc    w0, wzr, vs           // Overflow flag\n        ret                           // Back to caller\n```", "```\nasm asm-qualifiers (assembly language statements \n               : output operands\n               : input operands\n               : clobbers);\n```", "```\n// Add two integers and show if there is overflow.\n\n#include <stdio.h>\n\nint main(void)\n{\n    int x, y, z, overflow;\n\n    printf(\"Enter an integer: \");\n    scanf(\"%i\", &x);\n    printf(\"Enter an integer: \");\n    scanf(\"%i\", &y);\n\n ➊ asm (\"adds %w0, %w2, %w3\\n\"\n        \"cinc %w1, wzr, vs\"\n     ➋ : \"=r\" (z), \"=r\" (overflow)\n     ➌ : \"r\" (x), \"r\" (y));\n\n    printf(\"%i + %i = %i\\n\", x, y, z);\n    if (overflow)\n        printf(\"** Overflow occurred **\\n\");\n\n    return 0;\n}\n```", "```\n\"constraint \" (C variable name )\n```", "```\n        .arch armv8-a\n        .file   \"sum_ints.c\"\n        .text\n        .section        .rodata\n        .align  3\n.LC0:\n        .string \"Enter an integer: \"\n        .align  3\n.LC1:\n        .string \"%i\"\n        .align  3\n.LC2:\n        .string \"%i + %i = %i\\n\"\n        .align  3\n.LC3:\n        .string \"** Overflow occurred **\"\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     x29, x30, [sp, -32]!\n        mov     x29, sp\n        adrp    x0, .LC0\n        add     x0, x0, :lo12:.LC0\n        bl      printf\n        add     x0, sp, 20\n        mov     x1, x0\n        adrp    x0, .LC1\n        add     x0, x0, :lo12:.LC1\n        bl      __isoc99_scanf\n        adrp    x0, .LC0\n        add     x0, x0, :lo12:.LC0\n        bl      printf\n        add     x0, sp, 16\n        mov     x1, x0\n        adrp    x0, .LC1\n        add     x0, x0, :lo12:.LC1\n        bl      __isoc99_scanf\n     ➊ ldr     w0, [sp, 20]    /// w0 <- x\n        ldr     w1, [sp, 16]    /// w1 <- y\n#APP\n// 14 \"sumInts.c\" 1\n        adds w1, w0, w1\ncsinc w0, wzr, wzr, vc\n// 0 \"\" 2\n#NO_APP\n     ➋ str     w1, [sp, 28]    /// z <- result of addition\n        str     w0, [sp, 24]    /// overflow <- overflow flag\n        ldr     w0, [sp, 20]\n        ldr     w1, [sp, 16]\n        ldr     w3, [sp, 28]\n        mov     w2, w1\n        mov     w1, w0\n        adrp    x0, .LC2\n        add     x0, x0, :lo12:.LC2\n        bl      printf\n        ldr     w0, [sp, 24]\n        cmp     w0, 0\n        beq     .L2\n        adrp    x0, .LC3\n        add     x0, x0, :lo12:.LC3\n        bl      puts\n.L2:\n        mov     w0, 0\n        ldp     x29, x30, [sp], 32\n        ret\n        .size   main, .-main\n        .ident  \"GCC: Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\nunsigned int x = 0, y = 0, z;\n```", "```\nscanf(\"%u\", &x);\n```"]