- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Debugging
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: While the passive dynamic analysis tools covered in the last chapter can often
    provide insight into a malicious sample, they allow you to observe the sample’s
    actions only indirectly and may not fully reveal its internal workings. In certain
    cases, you’ll need something more comprehensive.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一章介绍的被动动态分析工具通常可以提供恶意样本的见解，但它们只是间接观察样本的行为，可能无法完全揭示其内部工作原理。在某些情况下，你需要更全面的工具。
- en: 'The ultimate dynamic analysis tool is the debugger. A *debugger* is a program
    that allows you to execute another program instruction by instruction. At any
    time, you can examine or modify its registers and memory contents, manipulate
    control flow, and much more. In this chapter, I’ll introduce various debugging
    concepts by means of the de facto debugger for macOS: LLDB. Then we’ll walk through
    a case study, applying these concepts to uncover surreptitious cryptocurrency
    mining logic in an application that was found in Apple’s official App Store.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的动态分析工具是调试器。*调试器*是一个程序，它允许你逐条执行另一个程序的指令。在任何时候，你都可以检查或修改它的寄存器和内存内容，操控控制流等等。在这一章中，我将通过
    macOS 的事实标准调试器 LLDB 来介绍各种调试概念。接下来，我们将通过一个案例研究，应用这些概念来揭示在苹果官方应用商店中发现的一款应用程序中的隐秘加密货币挖掘逻辑。
- en: Why You Need a Debugger
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么你需要调试器
- en: 'The following example should clearly illustrate the power of the debugger.
    Take a look at this snippet of disassembled code from malware known as Mami (and
    named by yours truly). In this snippet, we find a large chunk of embedded, encrypted
    data that is passed to a method named `setDefaultConfiguration` ([Listing 8-1](#listing8-1)):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例应该清楚地说明调试器的强大功能。看看这段来自恶意软件Mami（由我亲自命名）反汇编的代码片段。在这段代码中，我们发现了一大块嵌入的加密数据，它被传递给名为
    `setDefaultConfiguration` 的方法（[清单 8-1](#listing8-1)）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Encrypted data (Mami)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1：加密数据（Mami）
- en: If a malicious sample includes encrypted data, the malware author is generally
    attempting to conceal something, either from detection tools or a malware analyst.
    Therefore, when we encounter such data, we should be motivated to decrypt it in
    order to uncover its secrets. Based on the Mami method’s name, we can reasonably
    assume that this embedded data determines some initial configuration. It may contain
    information valuable to malware analysts, such as the addresses of command and
    control servers, insights into the malware’s capabilities, and more.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个恶意样本包含加密数据，那么恶意软件作者通常试图隐瞒某些信息，无论是对检测工具还是对恶意软件分析师。因此，当我们遇到这样的数据时，我们应该有动力将其解密，以揭示其秘密。根据
    Mami 方法的名称，我们可以合理地推测，这些嵌入的数据决定了一些初始配置。它可能包含对恶意软件分析师有价值的信息，比如命令与控制服务器的地址、恶意软件的能力洞察等等。
- en: So how do we decrypt it? Static analysis approaches are generally inefficient,
    as they require us to both understand the cryptographic algorithm used and recover
    the decryption key. File or process monitors are also of little use in this case,
    because Mami’s encrypted configuration information is not written to disk, nor
    passed to any other processes. In other words, it exists decrypted solely in the
    Mami process memory space.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何解密它呢？静态分析方法通常效率低下，因为它们要求我们既要理解所使用的加密算法，又要恢复解密密钥。文件或进程监视器在这种情况下也几乎没有用处，因为Mami的加密配置数据既没有写入磁盘，也没有传递给其他进程。换句话说，它仅在Mami进程的内存空间中以解密状态存在。
- en: 'Using a debugger, we can easily extract this information. First, we can instruct
    the malware to execute until it reaches the `setDefaultConfiguration:` method.
    Then, by *stepping through*, or executing each instruction one at a time, we can
    allow the malware to continue execution in a controlled manner, pausing when it
    has completed the decryption of its configuration information. As a debugger can
    directly inspect the memory of the process it is debugging, we can then *dump*,
    or print, the now-decrypted configuration information ([Listing 8-2](#listing8-2)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器，我们可以轻松提取这些信息。首先，我们可以指示恶意软件执行，直到它到达 `setDefaultConfiguration:` 方法。然后，通过*单步执行*，即逐条执行每一条指令，我们可以让恶意软件继续执行，控制其进程，在完成配置数据的解密时暂停。由于调试器可以直接检查它正在调试的进程的内存，因此我们可以随后*转储*，或者打印出现在已解密的配置数据（[清单
    8-2](#listing8-2)）：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: Decrypted configuration data (Mami)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：解密后的配置数据（Mami）
- en: 'Various decrypted key/value pairs, such as `"product_name" = dnsChanger` and
    the `setup_dns` array, provide insight into the malware’s goal: hijacking infected
    systems’ DNS settings and then forcing domain name resolutions to be routed through
    attacker-controlled servers. Incidentally, from the decrypted configuration we
    now know that these servers are found at `82.163.143.135` and `82.163.142.137`.
    Perhaps the most noteworthy aspect of this analysis is that we barely lifted a
    finger. Nor did we have to spend any time understanding how exactly this data
    was encrypted!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 各种解密的键/值对，例如`"product_name" = dnsChanger`和`setup_dns`数组，提供了对恶意软件目标的洞察：劫持感染系统的DNS设置，然后强制将域名解析通过攻击者控制的服务器进行路由。顺便提一下，从解密的配置中我们现在知道，这些服务器位于`82.163.143.135`和`82.163.142.137`。也许这个分析中最值得注意的方面是，我们几乎没有动手，也不需要花时间去理解这些数据是如何被加密的！
- en: This is but one example of a debugger’s power. In general, you should use a
    debugger to fully understand a code sample, as well as to dynamically modify it
    on the fly, such as to bypass anti-analysis logic (discussed in Chapter 9). Of
    course, some challenges temper these benefits. A debugger is a complex tool requiring
    specific, low-level knowledge; thus, completing an analysis can require a significant
    amount of time. However, once you understand debugger concepts and the techniques
    for debugging efficiently, a debugger will become your best malware analysis friend.
    Often it proves to be both the most efficient and comprehensive way to analyze
    any sample.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是调试器强大功能的一个例子。通常，你应该使用调试器来全面理解一个代码样本，并动态修改它，例如绕过反分析逻辑（在第9章中讨论）。当然，一些挑战会影响这些好处。调试器是一个复杂的工具，需要特定的低级知识；因此，完成分析可能需要相当长的时间。然而，一旦你理解了调试器的概念和高效调试的技巧，调试器将成为你最好的恶意软件分析助手。通常，它被证明是分析任何样本时最有效且最全面的方法。
- en: However, one word of caution that is worth reiterating. Dynamic analysis of
    a sample (which includes analysis within a debugger) involves executing the (potentially)
    malicious code, so it should always be performed on an isolated analysis system
    or virtual machine. The latter affords the benefit of snapshots, which allow you
    to easily revert if a debugging session of a malicious sample goes awry.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一点警告值得重申。动态分析样本（包括调试器中的分析）涉及执行（潜在的）恶意代码，因此应始终在隔离的分析系统或虚拟机上进行。后者具有快照的优势，可以让你轻松地在恶意样本的调试会话出现问题时恢复。
- en: The LLDB Debugger
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLDB调试器
- en: In this chapter we’ll focus on using *LLDB*, the de facto tool for debugging
    programs, including malware, on macOS. Although other applications, such as Hopper,
    have built user-friendly interfaces on top of it, you’ll probably discover that
    directly interacting with LLDB’s command line interface is the most efficient
    approach. If you already have Apple’s Xcode installed, you’ll find LLDB installed
    alongside at */usr/bin/lldb*. If not, you can install LLDB as a standalone program
    by entering `lldb` in the terminal and agreeing to the installation prompt.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将重点介绍如何使用*LLDB*，这是调试程序（包括恶意软件）在macOS上的事实标准工具。虽然像Hopper这样的其他应用程序在其上构建了用户友好的界面，但你可能会发现，直接与LLDB的命令行界面交互是最有效的方法。如果你已经安装了Apple的Xcode，你会发现LLDB与之一起安装在*/usr/bin/lldb*。如果没有，你可以通过在终端中输入`lldb`并同意安装提示来安装LLDB作为独立程序。
- en: In this section we’ll look at various debugging concepts such as breakpoints
    and manipulating control flow, and I’ll illustrate how these can be applied via
    LLDB to facilitate the analysis of malicious software. It should be noted that
    the LLDB website provides a wealth of detailed knowledge, such as an in-depth
    tutorial.^([1](#c08-endnote-1)) Moreover, while debugging, you can always consult
    the LLDB `help` command for inline information about any command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍各种调试概念，例如断点和控制流操作，我将演示如何通过LLDB应用这些概念，以促进恶意软件的分析。需要注意的是，LLDB网站提供了丰富的详细知识，例如深入的教程。^([1](#c08-endnote-1))
    此外，在调试过程中，你始终可以使用LLDB的`help`命令查看有关任何命令的内联信息。
- en: 'At a high level, a debugging session generally flows in the following manner:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，调试会话通常按照以下方式进行：
- en: You initialize a debugger session by loading an item, such as a malicious sample,
    into the debugger.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你通过将一个项目（例如恶意样本）加载到调试器中来初始化调试会话。
- en: You set breakpoints at various locations in the sample’s code, such as at its
    main entry point or at method calls of interest. The sample is started and runs
    uninhibited until a breakpoint is encountered, at which point execution is halted.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在示例代码的不同位置设置断点，例如在其主入口点或感兴趣的函数调用处。示例被启动并运行，直到遇到断点，此时执行将被暂停。
- en: Once the debugger has halted execution, you are free to poke around, examining
    memory and register values, manipulating control flow, setting other breakpoints,
    and more.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调试器暂停执行，您就可以自由地四处探索，检查内存和寄存器值，操控控制流，设置其他断点，等等。
- en: You can either resume execution until another breakpoint is hit or execute individual
    instructions one at a time.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以继续执行，直到遇到下一个断点，或一次执行一条指令。
- en: Remember that when a malicious sample is debugged, it is being allowed to execute.
    As such, always perform debugging in a virtual machine or a standalone analysis
    system. This ensures that no persistent damage occurs, and if you are debugging
    in a virtual machine, you can always revert it to a previous state. This is often
    quite useful during debugging sessions. For example, you might accidentally miss
    a breakpoint and run the malware in its entirety.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当调试恶意样本时，它被允许执行。因此，始终在虚拟机或独立分析系统中进行调试。这可以确保不会发生持久性损害，并且如果您在虚拟机中进行调试，始终可以将其恢复到先前的状态。在调试会话中，这通常非常有用。例如，您可能会不小心错过一个断点，导致恶意软件完全运行。
- en: Starting a Debugger Session
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动调试器会话
- en: 'There are several ways to start a debugging session in LLDB. The simplest is
    to execute LLDB from the terminal, passing it the path of a binary to analyze,
    followed by any additional arguments ([Listing 8-3](#listing8-3)):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以在 LLDB 中启动调试会话。最简单的方法是从终端执行 LLDB，传入要分析的二进制文件路径，然后是任何其他附加参数（[清单 8-3](#listing8-3)）：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Starting a debugging session'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-3：启动调试会话
- en: As you can see, the debugger will display a target creation message, make note
    of the executable set to be debugged, and identify its architecture. Although
    LLDB has created the debugging session, it has not yet executed any of the program’s
    instructions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调试器将显示目标创建消息，记录下要调试的可执行文件，并识别其架构。尽管 LLDB 已经创建了调试会话，但尚未执行程序的任何指令。
- en: 'You can also attach LLDB to an instance of a running process as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 LLDB 附加到正在运行的进程实例，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the debugger has attached to the process, a debugging session can commence.
    However, we rarely use this approach to analyze malware, because once the malware
    is already running, its core logic, which we are generally seeking to understand,
    may have already executed. Moreover, this logic could include anti-debugger code
    that prevents the debugger from attaching.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调试器附加到进程，调试会话就可以开始。然而，我们很少使用这种方法分析恶意软件，因为一旦恶意软件已经运行，其核心逻辑（我们通常希望理解的部分）可能已经执行。此外，这些逻辑可能包含反调试代码，阻止调试器附加。
- en: A third way of starting a debugging session is to run the `process attach` command
    with a process name and the `--waitfor` flag from the LLDB shell, as shown in
    [Listing 8-4](#listing8-4). This instructs the debugger to wait for a process
    that matches this name and then attach as the process is starting.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 启动调试会话的第三种方式是通过 LLDB shell 运行 `process attach` 命令，指定进程名称并添加 `--waitfor` 标志，如[清单
    8-4](#listing8-4)所示。这会指示调试器等待与该名称匹配的进程，并在进程启动时附加。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-4: Waiting to attach to a process (named malware)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-4：等待附加到进程（命名为恶意软件）
- en: 'After attaching to the process, the debugger will pause execution. The output
    will look similar to [Listing 8-5](#listing8-5):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到进程后，调试器将暂停执行。输出将类似于[清单 8-5](#listing8-5)：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-5: Process attachment, triggered by the `--``waitfor` flag'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-5：进程附加，通过 `--waitfor` 标志触发
- en: The `--waitfor` flag is particularly useful when malware spawns other malicious
    processes that you’d like to debug as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`--waitfor` 标志在恶意软件生成其他恶意进程时尤其有用，您可能还希望调试这些进程。'
- en: Controlling Execution
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制执行
- en: One of the most powerful aspects of a debugger is its ability to precisely control
    the execution of the process it is debugging. For example, you could instruct
    a process to execute a single instruction and then halt. [Table 8-1](#table8-1)
    describes several LLDB commands related to execution control.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器最强大的功能之一是能够精确控制其正在调试的进程的执行。例如，您可以指示进程执行一条指令，然后暂停。[表 8-1](#table8-1)描述了几个与执行控制相关的
    LLDB 命令。
- en: 'Table 8-1: LLDB Commands for Controlling Execution'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '表 8-1: 控制执行的 LLDB 命令'
- en: '| **LLDB command** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **LLDB 命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `run` (`r`) | Run the debugged process. Starts the execution, which will
    continue unabated until a breakpoint is hit, an exception is encountered, or the
    process terminates. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `run` (`r`) | 运行调试的进程。启动执行，直到命中断点、遇到异常或进程终止，执行才会中止。 |'
- en: '| `continue` (`c`) | Continue execution of the debugged process. Similar to
    the `run` command, it will continue execution until it reaches a breakpoint, an
    exception, or process termination. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `continue` (`c`) | 继续执行调试中的进程。与`run`命令类似，执行会持续，直到遇到断点、异常或进程终止。 |'
- en: '| `nexti` (`n`) | Execute the next instruction, as pointed to by the program
    counter register, and then halt. This command will skip over function calls and
    repeated instructions. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `nexti` (`n`) | 执行程序计数器寄存器指向的下一条指令，然后停止。此命令将跳过函数调用和重复的指令。 |'
- en: '| `stepi` (`s`) | Execute the next instruction, as pointed to by the program
    counter register, and halt. Unlike the `nexti` command, this command will step
    into function calls, allowing analysis of the called function. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `stepi` (`s`) | 执行程序计数器寄存器指向的下一条指令，然后停止。与`nexti`命令不同，此命令将进入函数调用，允许分析被调用的函数。
    |'
- en: '| `finish` (`f`) | Execute the rest of the instructions in the current function
    (called a *frame*), return, and halt. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `finish` (`f`) | 执行当前函数（称为*帧*）中的其余指令，返回并停止。 |'
- en: '| ctrl-c | Pause execution. If the process has been run (`r`) or continued
    (`c`), this will cause the process to halt wherever it is currently executing.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-c | 暂停执行。如果进程已经运行过（`r`）或继续执行过（`c`），则此操作会使进程在当前执行的位置暂停。 |'
- en: Notice that you can shorten the majority of LLDB commands to single or double
    letters. For example, you can enter `s` for the `stepi` command. Also note that
    LLDB includes several names for its commands in order to maintain backward compatibility
    with the GNU Project Debugger (GDB), a well-known predecessor to LLDB.^([3](#c08-endnote-3))
    For example, to perform a single step, LLDB supports both `thread step-inst` and
    `step`, which matches GDB. For the sake of simplicity, this chapter describes
    the LLDB command names that are compatible with GDB.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以将大多数LLDB命令缩写为单个字母或双字母。例如，你可以输入`s`来代替`stepi`命令。还要注意，LLDB为其命令提供了多个名称，以保持与GNU项目调试器（GDB）的向后兼容性，GDB是LLDB的前身之一。^([3](#c08-endnote-3))
    例如，为了执行单步操作，LLDB支持`thread step-inst`和`step`，这与GDB兼容。为了简便起见，本章描述了与GDB兼容的LLDB命令名称。
- en: While you could step through each of the binary’s executable instructions one
    at a time, doing so is tedious. On the other hand, instructing the debugger to
    run the malware uninhibited defeats the purpose of debugging in the first place.
    The solution is to use breakpoints.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以逐步执行二进制文件中的每一条可执行指令，但这样做非常繁琐。另一方面，指示调试器不受限制地运行恶意软件将完全违背调试的目的。解决方法是使用断点。
- en: Using Breakpoints
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用断点
- en: A *breakpoint* is a command that instructs the debugger to halt execution at
    a specified location. You’ll often set breakpoints at the entry point of the binary,
    at method or function calls, or on the addresses of instructions of interest.
    You may have to first triage a binary via static analysis tools such as a disassembler
    in order to know exactly where to set such breakpoints. Once a breakpoint has
    been hit and the debugger has halted execution, you’ll be able to inspect the
    current state of the process, including its memory, the CPU register contents,
    call stacks, and more.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*断点*是指令调试器在指定位置暂停执行的命令。通常你会在二进制文件的入口点、方法或函数调用处，或者在感兴趣的指令地址处设置断点。你可能需要先通过静态分析工具（如反汇编器）对二进制文件进行初步分析，以确定断点的具体位置。一旦命中断点并且调试器暂停执行，你将能够检查进程的当前状态，包括内存、CPU寄存器内容、调用栈等。'
- en: You can use the `breakpoint` command (or `b` for short) to set a breakpoint
    at a named location, such as a function or method name, or at an address. Behind
    the scenes, the debugger will transparently modify the process memory space to
    overwrite the byte at the specified location with a breakpoint instruction. On
    Intel x86_64 systems, this is the interrupt 3 instruction, whose value is `0xCC`.
    Once set, whenever the memory address containing the breakpoint is executed, the
    interrupt 3 will cause the CPU to return control to the debugger, which halts
    execution. Of course, if execution is continued, the debugger will first execute
    the original instruction (which was transparently overridden to set the breakpoint),
    such that normal program functionality is maintained.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`breakpoint`命令（简写为`b`）在命名位置设置断点，例如函数或方法名称，或在某个地址上设置断点。在后台，调试器会透明地修改进程内存空间，将指定位置的字节覆盖为断点指令。在Intel
    x86_64系统上，这就是中断 3 指令，值为`0xCC`。一旦设置，当包含断点的内存地址被执行时，中断 3 将导致CPU将控制权交还给调试器，从而暂停执行。当然，如果继续执行，调试器会首先执行原始指令（该指令已透明地被覆盖以设置断点），以保持程序的正常功能。
- en: Suppose we wanted to debug a malicious sample called *malware* and halt execution
    at its `main` function ([Listing 8-6](#listing8-6)). If the malware’s symbols
    were not stripped (that is, compiled with debugging symbols), we could start a
    debugging session and then enter the following to set a breakpoint by name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想调试一个名为*malware*的恶意样本，并在其`main`函数（见[列表 8-6](#listing8-6)）处暂停执行。如果恶意软件的符号没有被剥离（即编译时包含了调试符号），我们可以开始一个调试会话，然后输入以下命令按名称设置断点。
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-6: Setting a breakpoint on a program’s `main` function'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-6：在程序的`main`函数上设置断点
- en: 'With this breakpoint set, we can use the `run` command to instruct the debugger
    to run the debugged process. Execution will commence and then halt when it reaches
    the instruction at the start of the `main` function ([Listing 8-7](#listing8-7)):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了这个断点后，我们可以使用`run`命令指示调试器运行被调试的进程。执行将开始，然后在到达`main`函数起始指令时（见[列表 8-7](#listing8-7)）暂停。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-7: Breakpoint hit; execution halted'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-7：断点命中；执行暂停
- en: Often, though, the names of functions are not available in a compiled binary,
    so we must set breakpoints by specifying an address. You might also want to set
    a breakpoint at some address, say, within a function of interest. To set a breakpoint
    on an address, specify the hex address preceded by `0x`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，编译后的二进制文件中没有函数名称，因此我们必须通过指定地址来设置断点。你也可能希望在某个地址上设置断点，比如在感兴趣的函数内。要在地址上设置断点，指定以`0x`为前缀的十六进制地址即可。
- en: 'In the previous example, if the `main` function (found at `0x100004bd9`) had
    not been named, we could still set a breakpoint at its start as follows ([Listing
    8-8](#listing8-8)):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果`main`函数（位于`0x100004bd9`）没有命名，我们仍然可以按以下方式在其起始位置设置断点（见[列表 8-8](#listing8-8)）：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-8: Setting a breakpoint by address'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-8：通过地址设置断点
- en: Luckily, a large percentage of Mac malware is written in Objective-C, meaning
    that, even in its compiled form, it will contain both class and method names.
    As such, we can also set breakpoints on these method names, or any Apple API it
    invokes, by passing the class and full method name to the `breakpoint` (`b`) command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大部分Mac恶意软件都是用Objective-C编写的，这意味着即使是编译后的版本，它也会包含类和方法名称。因此，我们也可以通过将类和完整的方法名称传递给`breakpoint`（`b`）命令，在这些方法名称或它调用的任何Apple
    API上设置断点。
- en: Setting Breakpoints on Method Names
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在方法名称上设置断点
- en: Recall that in Chapter 5 we leveraged the `class-dump` *tool to extract Objective-C
    class and method names. If you spot methods of interest, you can then set breakpoints
    upon them to take a closer look. For example, by running `class-dump` on the installer
    for malware known as FinFisher, we’ll find a method named `installPayload` in
    a class named `appAppDelegate`. Specifying the class and method name will allow
    us to set a breakpoint so that we can dynamically analyze how the malware persistently
    installs itself ([Listing 8-9](#listing8-9)):*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在第5章中我们使用`class-dump`*工具提取了Objective-C的类和方法名称。如果你发现了感兴趣的方法，可以在这些方法上设置断点进行更深入的分析。例如，通过在FinFisher恶意软件的安装程序上运行`class-dump`，我们会发现一个名为`installPayload`的方法，它属于一个名为`appAppDelegate`的类。指定类和方法名称后，我们就可以设置断点，以便动态分析恶意软件如何持续地安装自己（见[列表
    8-9](#listing8-9)）：*
- en: '*[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE9]*'
- en: 'Listing 8-9: Setting a breakpoint on an `installPayload` method (FinFisher)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-9：在`installPayload`方法（FinFisher）上设置断点
- en: 'Note that setting breakpoints on Apple Objective-C methods can be somewhat
    nuanced due to various opaque compiler optimizations and abstractions. For example,
    imagine that, in a disassembler, you notice a malicious sample is invoking the
    Apple class `NSTask`’s launch method. You’d like to set a debugger breakpoint
    on this method so that the malware is halted when it attempts to launch an external
    command or program. However, at runtime, the launch method call will actually
    be handled not by the `NSTask` class but rather its subclass, `NSConcreteTask`.
    Thus, you actually have to set the breakpoint in the following manner:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置 Apple Objective-C 方法的断点可能有些微妙，因为存在各种不透明的编译器优化和抽象。例如，假设在反汇编器中，你注意到一个恶意样本正在调用
    Apple 类 `NSTask` 的 launch 方法。你希望在此方法上设置调试器断点，以便当恶意软件尝试启动外部命令或程序时暂停。然而，在运行时，launch
    方法的调用实际上并不是由 `NSTask` 类处理，而是由其子类 `NSConcreteTask` 处理。因此，你实际上需要以以下方式设置断点：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This might raise the following valid question: How do you know what class or
    subclass will actually handle a method? One approach is to track invocations of
    the `objc_msgSend` function (and its variants). As Objective-C calls are routed
    through this function at runtime, it is possible to uncover all classes and the
    methods they invoke. Shortly I’ll illustrate exactly how to do this via an LLDB
    debugger script. For an in-depth discussion of debugging Objective-C code, including
    more information on setting breakpoints, see Ari Grant’s excellent write-up “Dancing
    in the Debugger—A Waltz with LLDB.”^([4](#c08-endnote-4))'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能引发以下一个合理的问题：你怎么知道哪个类或子类实际上会处理一个方法？一种方法是跟踪 `objc_msgSend` 函数（及其变体）的调用。由于 Objective-C
    调用会在运行时通过此函数路由，因此可以揭示所有类及其调用的方法。稍后我将通过 LLDB 调试器脚本演示如何做到这一点。有关调试 Objective-C 代码的深入讨论，包括设置断点的更多信息，请参见
    Ari Grant 的精彩文章《在调试器中跳舞——与 LLDB 共舞》^([4](#c08-endnote-4))。
- en: Conditionally Triggering a Breakpoint
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件触发断点
- en: Often you’ll want a breakpoint to always trigger. Other times, it may be more
    efficient for them to trigger and halt the process only under certain conditions.
    Luckily, LLDB supports the notion of applying conditions to breakpoints. These
    conditions must evaluate to true for the breakpoint to trigger and halt the process.
    To add a condition to a breakpoint, use the `-c` flag and then specify the condition.
    For example, imagine that a malicious sample is sending encrypted data to a remote
    command and control server. In a debugger, we could set a breakpoint on the function
    responsible for encrypting the data prior to transmission in order to view its
    plaintext contents. Unfortunately, if the malware also sends small “heartbeat”
    messages at regular intervals, this will continually trigger our breakpoint. We
    most likely want to ignore such messages, as they contain no meaningful data and
    will slow down our analysis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会希望断点始终触发。其他时候，为了提高效率，可能希望只有在满足特定条件时，断点才会触发并暂停进程。幸运的是，LLDB 支持为断点应用条件。只有当条件评估为真时，断点才会触发并暂停进程。要为断点添加条件，可以使用
    `-c` 标志，然后指定条件。例如，假设一个恶意样本正在向远程命令与控制服务器发送加密数据。在调试器中，我们可以在负责加密数据的函数上设置断点，以便在数据传输之前查看其明文内容。不幸的是，如果恶意软件还会定期发送小的“心跳”消息，这将不断触发我们的断点。我们很可能希望忽略这样的消息，因为它们不包含有意义的数据，而且会拖慢我们的分析进度。
- en: 'The solution? Adding a condition to the breakpoint! Specifically, we’ll instruct
    the breakpoint to only trigger if the size of the data being encrypted and exfiltrated
    is larger than the heartbeat message. For the sake of the example, let’s assume
    the message-encryption function takes, as its second argument, the size of the
    message (which can be found in the `$rsi` register) and that heartbeat messages
    are at most 128 bytes. To add this condition to breakpoint number 1, we would
    execute the commands in [Listing 8-10](#listing8-10):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是什么？给断点添加一个条件！具体来说，我们会指示断点仅在加密和泄露的数据大小大于心跳消息时才触发。为了举例说明，假设消息加密函数的第二个参数是消息的大小（可以在
    `$rsi` 寄存器中找到），且心跳消息的大小最大为 128 字节。要为断点 1 添加此条件，我们将执行 [列表 8-10](#listing8-10) 中的命令：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-10: Setting a conditional breakpoint'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-10：设置条件断点
- en: With such a conditional added to the breakpoint, the debugger will only halt
    when messages with data larger than 128 bytes are passed into the encryption and
    exfiltration function. Perfect!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 加上这样的条件后，调试器只会在传入加密和泄露函数的数据大小大于 128 字节时才会暂停。完美！
- en: Adding Commands to Breakpoints
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向断点添加命令
- en: 'Usually we set a breakpoint and perform a deterministic action once it is hit.
    In the previous example, we’ll likely always want to print out unencrypted data
    to see what the malware is about to exfiltrate. While we could perform this action
    manually each time the breakpoint is hit, it may be more efficient to add what
    is known as a *command* to the breakpoint. This command, which consists of one
    or more debugger commands, will be automatically executed each time the breakpoint
    is hit. To add one to a breakpoint, use `breakpoint command add` and specify the
    breakpoint by number. Following this, specify the commands to be executed, and
    then enter `DONE`. Keeping with the previous example, let’s assume the message-encryption
    function takes as its first argument the plaintext contents of the message (which
    can be found in the `RDI` register). To add a breakpoint action to print this
    out, we’ll use the `print object` (`po`) command (discussed later in this chapter).
    We’ll also tell the debugger to then simply continue ([Listing 8-11](#listing8-11)):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会设置一个断点，并在触发时执行一个确定性的操作。在前面的示例中，我们可能总是希望打印出未加密的数据，以查看恶意软件即将泄露的内容。虽然我们可以每次断点触发时手动执行此操作，但将一个称为*命令*的内容添加到断点中可能会更高效。这个命令由一个或多个调试器命令组成，并将在每次触发断点时自动执行。要将命令添加到断点中，请使用`breakpoint
    command add`并通过编号指定断点。然后，指定要执行的命令，再输入`DONE`。沿用之前的示例，假设消息加密函数的第一个参数是消息的明文内容（可以在`RDI`寄存器中找到）。为了添加一个断点操作来打印这个内容，我们将使用`print
    object`（`po`）命令（将在本章后面讨论）。我们还会告诉调试器继续执行（[列表 8-11](#listing8-11)）：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-11: Adding breakpoint commands'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-11: 添加断点命令'
- en: Now, whenever this breakpoint is hit, the debugger will print out the plaintext
    message passed to the function and then merrily continue on its way. We can simply
    sit back and watch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当触发这个断点时，调试器会打印出传递给函数的明文消息，然后继续执行。我们可以轻松地坐下来观察。
- en: Managing Breakpoints
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理断点
- en: The LLDB debugger also supports various commands to manage breakpoints. Breakpoints
    can be set, modified, deleted, enabled, disabled, or listed using the commands
    described in [Table 8-2](#table8-2).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB调试器还支持多种命令来管理断点。可以使用[表 8-2](#table8-2)中描述的命令来设置、修改、删除、启用、禁用或列出断点。
- en: 'Table 8-2: LLDB Commands for Managing Breakpoints'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '表 8-2: 管理断点的LLDB命令'
- en: '| **LLDB command** | **Description** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **LLDB命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `breakpoint` (`b`) `<function/method name>` | Set a breakpoint on a specified
    function or method name. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `breakpoint` (`b`) `<function/method name>` | 在指定的函数或方法名处设置断点。 |'
- en: '| `breakpoint` (`b`) 0x`<address>` | Set a breakpoint on an instruction at
    a specified memory address. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `breakpoint` (`b`) 0x`<address>` | 在指定的内存地址上的指令处设置一个断点。 |'
- en: '| `breakpoint list` (`br l`) | Display all current breakpoints, including their
    numbers. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `breakpoint list` (`br l`) | 显示所有当前的断点，包括它们的编号。 |'
- en: '| `breakpoint enable`/`disable` `<number>` (`br e/dis`) | Enable or disable
    a breakpoint (specified by number). |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `breakpoint enable`/`disable` `<number>` (`br e/dis`) | 启用或禁用一个断点（通过编号指定）。
    |'
- en: '| `breakpoint modify` `<modifications>` `<number>` `(br mod)` | Modify the
    options on a breakpoint (specified by number). |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `breakpoint modify` `<modifications>` `<number>` `(br mod)` | 修改断点的选项（通过编号指定）。
    |'
- en: '| `breakpoint delete` `<number>` (`br del`) | Delete a breakpoint (specified
    by number). |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `breakpoint delete` `<number>` (`br del`) | 删除一个断点（通过编号指定）。 |'
- en: Running the `help` command with the `breakpoint` parameter provides a comprehensive
    list of breakpoint-related commands, including those mentioned in [Table 8-2](#table8-2).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有`breakpoint`参数的`help`命令可以提供与断点相关的命令的完整列表，包括[表 8-2](#table8-2)中提到的那些命令。
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For more information on the breakpoint commands supported by LLDB, see the tool’s
    documentation on the topic.^([5](#c08-endnote-5))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多有关LLDB支持的断点命令的信息，请参见该工具的相关文档。[^(5)](#c08-endnote-5)
- en: Examining All the Things
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查所有内容
- en: Once you’ve halted execution, you can instruct the debugger to display many
    things, including the values of CPU registers, the contents of the process memory,
    or other process state information such as the current call stack. This powerful
    capability allows you to examine runtime information that often isn’t directly
    available during static analysis. For example, in the case study at the beginning
    of this chapter, we were able to view the malware’s decrypted in-memory configuration
    information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你暂停了程序的执行，你可以指示调试器显示许多内容，包括 CPU 寄存器的值、进程内存的内容或其他进程状态信息，如当前调用栈。这个强大的功能使你能够检查运行时信息，这些信息通常在静态分析时无法直接获得。例如，在本章开头的案例分析中，我们能够查看恶意软件解密后的内存配置数据。
- en: 'To dump the contents of the CPU registers, use the `register read` command
    (or the shortened `reg r`). To view the value of a specific register, pass in
    the register name as the final parameter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要转储 CPU 寄存器的内容，请使用`register read`命令（或简化的`reg r`）。要查看特定寄存器的值，请将寄存器名称作为最后一个参数传入：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Often we’re also interested in what the registers point to. That is to say,
    we’d like to examine the contents of actual memory addresses. The `memory read`
    or GDB-compatible `x` command can be used to read the contents of memory. Note
    that these instructions both require register names to be prefixed with `$`; for
    example, `$rax`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常也对寄存器指向的内容感兴趣。也就是说，我们想要查看实际内存地址的内容。`memory read`命令或与 GDB 兼容的`x`命令可以用来读取内存内容。请注意，这些指令都要求寄存器名称以`$`作为前缀；例如，`$rax`。
- en: But unless we explicitly specify a format for the data, LLDB will print out
    the raw hex bytes. [Table 8-3](#table8-3) lists a variety of format specifiers
    that instruct LLDB to treat the memory address as a string, instructions, or byte.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除非我们明确指定数据格式，否则 LLDB 将打印出原始十六进制字节。[表 8-3](#table8-3)列出了多种格式说明符，用于指示 LLDB
    将内存地址视为字符串、指令或字节。
- en: 'Table 8-3: LLDB Commands for Displaying Memory Contents'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3：用于显示内存内容的 LLDB 命令
- en: '| **LLDB command** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **LLDB 命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x/s` `<register or memory address>` | Display the memory as a null-terminated
    string. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `x/s` `<寄存器或内存地址>` | 将内存显示为以空字符终止的字符串。 |'
- en: '| `x/i` `<register or memory address>` | Display the memory as an assembly
    instruction. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `x/i` `<寄存器或内存地址>` | 将内存显示为汇编指令。 |'
- en: '| `x/b` `<register or memory address>` | Display the memory as a byte. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `x/b` `<寄存器或内存地址>` | 将内存显示为字节。 |'
- en: You can also specify the number of items to display by adding a numerical value
    after the `/`. For example, to disassemble 10 instructions, starting at the current
    location of the instruction pointer (`RIP`), enter `x/10i $rip`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在`/`后面添加数字值来指定要显示的项目数量。例如，要从当前指令指针（`RIP`）位置开始反汇编 10 条指令，可以输入`x/10i $rip`。
- en: The LLDB debugger also supports the `print` command. When executed with a register
    or memory address, it will display the contents at the specified location. You
    can also specify a typecast to instruct the `print` command to format the data.
    For example, if the `RSI` register points to a null-terminated string, you can
    display this by typing `print (char*)$rsi`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB 调试器还支持`print`命令。当与寄存器或内存地址一起执行时，它将显示指定位置的内容。你还可以指定类型转换，以指示`print`命令格式化数据。例如，如果`RSI`寄存器指向一个以空字符终止的字符串，你可以通过输入`print
    (char*)$rsi`来显示它。
- en: 'The `print` command can also be executed with the `object` specifier. This
    can be used to print out the contents (or *description*, in Objective-C parlance)
    of any Objective-C object. For instance, consider the example presented at the
    start of the chapter. Within the `setDefaultConfiguration` method, the Mami malware
    decrypts its configuration information into an Objective-C object referenced by
    the `RAX` register. Thus, using the `print object` command, we can print the verbose
    description of the object, including all of its key/value pairs ([Listing 8-12](#listing8-12)):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`命令也可以使用`object`说明符来执行。此命令可用于打印任何 Objective-C 对象的内容（或在 Objective-C 术语中称为*描述*）。例如，考虑本章开头展示的示例。在`setDefaultConfiguration`方法中，Mami
    恶意软件将其配置数据解密为一个由`RAX`寄存器引用的 Objective-C 对象。因此，使用`print object`命令，我们可以打印出该对象的详细描述，包括其所有键/值对（[清单
    8-12](#listing8-12)）：'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-12: Printing a dictionary object (Mami)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-12：打印字典对象（Mami）
- en: You might be wondering how, given an arbitrary value or address, you can decide
    which display command to use. That is to say, how do you know if the address is
    a pointer to an Objective-C object, a string, or a sequence of instructions? If
    the value to display is a parameter or return value from a documented API, its
    type will be noted in its documentation. For example, most of Apple’s Objective-C
    APIs or methods return objects, which should be displayed using the `print object`
    command. However, if no context is available, the disassembly of the binary may
    provide some insight, or trial and error could suffice. For example, if the `print
    object` command doesn’t produce meaningful output, perhaps try `x/b` to dump the
    contents of the specified data as raw hex bytes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，给定一个任意的值或地址，如何决定使用哪种显示命令。也就是说，如何判断该地址是指向一个 Objective-C 对象、一个字符串，还是一系列指令？如果要显示的值是来自已记录
    API 的参数或返回值，它的类型会在文档中注明。例如，苹果的大多数 Objective-C API 或方法返回对象，这些对象应使用 `print object`
    命令来显示。然而，如果没有上下文可用，二进制文件的反汇编可能提供一些线索，或者通过试错方法也能解决问题。例如，如果 `print object` 命令没有产生有意义的输出，可以尝试使用
    `x/b` 命令将指定数据的内容作为原始十六进制字节输出。
- en: The `backtrace` (or `bt`) debugger command, which prints a sequence of stack
    frames, is another useful debugging command for examining the process. When a
    breakpoint is hit, we’re often interested in determining the program flow up to
    that point. For example, imagine we’ve set a breakpoint on a malware’s string-decryption
    function, which may have been invoked in multiple places in the malicious code
    to decrypt embedded strings. When the breakpoint triggers, we’d like to know the
    location of the caller, that is, the address of the code responsible for invoking
    the function. This can be accomplished via `backtrace`. Whenever a function is
    called, a stack frame will be created on the call stack—this contains the address
    that the process will return to once the function is done, among other things.
    As the return address is the address of the instruction immediately following
    the call, we can check it to accurately determine the address of the caller. Moreover,
    as the backtrace contains previous stack frames as well, the entire function call
    hierarchy can be reconstructed. If you’re interested in learning more about backtraces
    and call stacks, see Apple’s write-up “Examining the Call Stack.”^([6](#c08-endnote-6))
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`backtrace`（或 `bt`）调试命令可以打印一系列堆栈帧，这是另一个有用的调试命令，用于检查进程。当触发断点时，我们通常需要确定程序的执行流程，直到那个时刻为止。例如，假设我们在恶意软件的字符串解密函数上设置了断点，这个函数可能在恶意代码的多个地方被调用，用于解密嵌入的字符串。当断点触发时，我们希望知道调用者的位置，即负责调用该函数的代码的地址。这可以通过
    `backtrace` 实现。每当一个函数被调用时，调用堆栈中都会创建一个堆栈帧——它包含了进程执行完函数后将返回的地址等信息。由于返回地址是紧接在调用指令之后的地址，我们可以检查它来准确确定调用者的地址。此外，由于
    `backtrace` 还包含前面的堆栈帧，因此可以重建整个函数调用层级。如果你有兴趣了解更多关于回溯和调用栈的内容，可以参考苹果的写作《Examining
    the Call Stack》。^([6](#c08-endnote-6))'
- en: Modifying Process State
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改进程状态
- en: Normally, a debugging session is rather passive once you’ve set your breakpoints
    to halt execution. However, you can interact with a process by directly modifying
    its state or even its control flow. This is especially useful when analyzing a
    malicious specimen that implements anti-debugging logic, a topic discussed in
    the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦你设置了断点并暂停了执行，调试会话是相当被动的。然而，你可以通过直接修改进程的状态或甚至控制流来与进程进行交互。这在分析实现了反调试逻辑的恶意样本时尤为有用，相关话题将在下一章讨论。
- en: Once you’ve located anti-analysis logic, one option is to instruct the debugger
    to simply skip over the code by modifying the instruction pointer. In some cases,
    you can also overcome such anti-analysis code by simply changing the value of
    a register. For example, modifying the `RAX` register can subvert the value returned
    by a function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定位到反调试逻辑，一个选择是通过修改指令指针，指示调试器跳过这段代码。在某些情况下，你也可以通过简单地改变寄存器的值来绕过这种反调试代码。例如，修改
    `RAX` 寄存器的值可以破坏一个函数返回的值。
- en: The most common way to modify the state of the binary is to change either CPU
    register values or the contents of memory. The `register write` command can be
    used to change values of the former, while the `memory write` command modifies
    the latter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 修改二进制状态最常见的方法是更改 CPU 寄存器值或内存内容。`register write` 命令可以用来修改前者的值，而 `memory write`
    命令则用于修改后者的内容。
- en: 'The `register write` (or `reg write`) command takes two parameters: the target
    register and its new value. Let’s see exactly how we can leverage this to wholly
    bypass the anti-analysis logic found in a widespread adware installer. In [Listing
    8-13](#listing8-13), we first use the `x` command with the `2i` and the program
    counter register (`RIP`) to display the next two instructions to be executed.
    The call instruction at `0x100035cbe` will trigger anti-debugging logic. (The
    details of this logic are not pertinent for this example.)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`register write`（或 `reg write`）命令有两个参数：目标寄存器和其新值。我们来看一下如何利用这个命令完全绕过在广泛传播的广告软件安装程序中发现的反分析逻辑。在[清单
    8-13](#listing8-13)中，我们首先使用 `x` 命令配合 `2i` 和程序计数器寄存器（`RIP`）来显示将要执行的下一条指令。位于 `0x100035cbe`
    的调用指令会触发反调试逻辑。（这个逻辑的细节在本示例中不重要。）'
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-13: Modifying the instruction pointer'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-13：修改指令指针
- en: In order to bypass the call to the anti-debugging logic, we use LLDB’s `register
    write` command to modify the instruction pointer (`RIP`) to point to the next
    instruction (at `0x100035cc0`). Redisplaying the value of the instruction pointer
    confirms it has been successfully updated. After this modification, the problematic
    call at address `0x100035cbe` is never invoked; thus, the malware’s anti-debugger
    logic is never executed, and our debugging session can continue unimpeded. Moreover,
    the malware is generally none the wiser.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过反调试逻辑的调用，我们使用 LLDB 的 `register write` 命令修改指令指针（`RIP`），使其指向下一条指令（位于 `0x100035cc0`）。重新显示指令指针的值确认它已经成功更新。经过这次修改后，位于
    `0x100035cbe` 地址的有问题的调用指令将永远不会被执行，因此，恶意软件的反调试逻辑也永远不会被触发，我们的调试会话可以顺利继续。此外，恶意软件通常不会察觉这一点。
- en: 'There are other reasons to modify CPU register values to influence the debugged
    process. For example, imagine a piece of malware that attempts to connect to a
    remote command and control server before persistently installing itself. If the
    server is offline but we want the malware to continue to execute so we can observe
    how it installs itself, we may have to modify a register that contains the result
    of this connection check. As the return value from a function call is stored in
    the `RAX` register, this may involve setting the value of `RAX` to `1` (true),
    causing the malware to believe the connection check succeeded ([Listing 8-14](#listing8-14)):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 CPU 寄存器值以影响被调试进程的原因还有其他。例如，假设某个恶意软件在自持久化安装之前，尝试连接到一个远程命令与控制服务器。如果该服务器离线，但我们仍希望恶意软件继续执行，以便观察它是如何安装自己的，我们可能需要修改一个寄存器，这个寄存器存储了该连接检查的结果。由于函数调用的返回值保存在
    `RAX` 寄存器中，这可能涉及将 `RAX` 的值设置为 `1`（即 `true`），让恶意软件认为连接检查已成功（[清单 8-14](#listing8-14)）：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-14: Modifying a register'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-14：修改寄存器
- en: Easy peasy!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！
- en: We can change the contents of any writable memory with the `memory write` command.
    During malware analysis, this command could be useful to change the default values
    of an encrypted configuration file that are only decrypted in memory. Such a configuration
    may include a trigger date, which instructs the malware to remain dormant until
    the date is encountered. To coerce immediate activity so you can observe the malware’s
    full behavior, you could directly modify the trigger date in memory to the current
    time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `memory write` 命令修改任何可写的内存内容。在恶意软件分析过程中，这个命令可以用于修改加密配置文件的默认值，这些配置文件只在内存中解密。这样的配置可能包含一个触发日期，指示恶意软件在遇到该日期之前保持休眠。为了强制恶意软件立即激活，便于观察它的完整行为，你可以直接在内存中修改触发日期为当前时间。
- en: 'As another example, the `memory write` command could be used to modify the
    memory that holds the address of a malicious sample’s remote command and control
    server. This provides a simple and non-destructive way for an analyst to specify
    an alternate server, such as one under their control. Being able to modify the
    address of a malware’s command and control server or specify an alternate server
    has its perks. In a research paper titled “Offensive Malware Analysis: Dissecting
    OSX/FruitFly.b Via a Custom C&C Server,” I illustrated how malware connecting
    to an alternate server under an analyst’s control could be tasked to reveal its
    capabilities.^([7](#c08-endnote-7))'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个示例，`memory write` 命令可以用来修改保存恶意样本远程命令和控制服务器地址的内存。这为分析人员提供了一种简单且不破坏性的方式来指定一个备用服务器，例如一个在其控制下的服务器。能够修改恶意软件的命令和控制服务器的地址或指定一个备用服务器，具有一定的优势。在一篇名为《进攻性恶意软件分析：通过自定义
    C&C 服务器解剖 OSX/FruitFly.b》的研究论文中，我展示了如何将恶意软件连接到一个由分析人员控制的备用服务器，并指示它揭示其功能。^([7](#c08-endnote-7))
- en: 'The format of the `memory write` command is described by LLDB’s `help` command.
    The simplest way to leverage `memory write` is with:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory write` 命令的格式由 LLDB 的 `help` 命令描述。利用 `memory write` 最简单的方式是：'
- en: The memory address to modify
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要修改的内存地址
- en: The `-s` flag and optionally a number (to specify the number of bytes to modify
    if the default of 1 byte does not suffice)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s` 标志，并可以选择指定一个数字（如果默认的 1 字节不足以修改，则指定修改的字节数）'
- en: The value of the bytes to write to memory
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要写入内存的字节值
- en: 'For example, to change the memory at address `0x100100000` to `0x41414141`,
    you would run the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将地址 `0x100100000` 处的内存更改为 `0x41414141`，可以运行以下命令：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The modification can then be confirmed with the `memory read` command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用 `memory read` 命令确认修改：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: LLDB Scripting
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLDB 脚本
- en: One of the more powerful features of LLDB is its support for debugging scripts,
    which allow you to extend the capabilities of the debugger or simply automate
    repetitive tasks. Let’s walk through an example of building a simple debugger
    script to illustrate important concepts and show how such a script can improve
    your dynamic malware analysis.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB 最强大的功能之一是它对调试脚本的支持，允许你扩展调试器的功能或简单地自动化重复性任务。让我们通过一个示例来演示如何构建一个简单的调试器脚本，以说明重要的概念，并展示这样的脚本如何改善你的动态恶意软件分析。
- en: Earlier in this chapter, I mentioned how tracking invocations of the `objc_msgSend`
    function can reveal the majority of the Objective-C calls made by the process.
    When analyzing malware, this can provide valuable insight into the functionality
    of a specimen, as well as drive subsequent analysis. One naive approach to monitoring
    calls to the `objc_msgSend` function is simply setting a breakpoint on the function.
    Yes, this will halt the process and allow you to examine the function’s arguments,
    which include both class and method names. However, as you’ll quickly see, this
    approach is very inefficient, and the many, many calls to the `objc_msgSend` function
    will become overwhelming.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我提到过，跟踪 `objc_msgSend` 函数的调用可以揭示进程所做的大部分 Objective-C 调用。在分析恶意软件时，这可以为样本的功能提供宝贵的洞察，并推动后续的分析。一种天真的方法是通过在该函数上设置断点来监控对
    `objc_msgSend` 函数的调用。是的，这样会暂停进程并允许你检查该函数的参数，其中包括类名和方法名。然而，正如你很快会看到的，这种方法效率非常低，而且对
    `objc_msgSend` 函数的频繁调用会变得难以应付。
- en: 'A more efficient approach is to create a debugger script that will automatically
    set a breakpoint, attach a command to print out the Objective-C class and method
    names, and then allow the process to continue. Debugger scripts for LLDB are written
    in Python and loaded via the debugger command `command script import` `<path to
    script>`. These scripts should import the LLDB module so that the LLDB API can
    be accessed by the rest of the Python code. For more information on this API,
    see the official LLDB documentation: “Python Reference.”^([8](#c08-endnote-8))'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 更高效的方法是创建一个调试器脚本，自动设置一个断点，附加一个命令来打印出 Objective-C 的类名和方法名，然后允许进程继续。LLDB 的调试器脚本使用
    Python 编写，并通过调试器命令 `command script import` `<脚本路径>` 导入。这些脚本应该导入 LLDB 模块，以便其余的
    Python 代码可以访问 LLDB API。有关此 API 的更多信息，请参阅官方 LLDB 文档： “Python 参考。”^([8](#c08-endnote-8))
- en: 'More often than not, you’ll want your script to automatically perform an action
    once it’s loaded (such as setting a breakpoint). To facilitate this, LLDB provides
    the `__lldb_init_module` convenience function, which if it’s implemented in your
    debugger script will be automatically invoked whenever the script is loaded. In
    our debugger script, we’ll use this function to set a breakpoint and breakpoint
    callback ([Listing 8-15](#listing8-15)):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是，你可能希望脚本在加载后自动执行某个操作（例如设置断点）。为此，LLDB 提供了 `__lldb_init_module` 这个便利函数，如果在你的调试器脚本中实现了该函数，它将在每次脚本加载时自动被调用。在我们的调试器脚本中，我们将使用这个函数来设置断点和断点回调（[列表
    8-15](#listing8-15)）：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 8-15: Setting a breakpoint via a debugger script'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-15：通过调试器脚本设置断点
- en: First, our code gets a reference to the process that is running within the debugger.
    With this reference, we can then invoke the `BreakpointCreateByName` function
    to set a breakpoint on the `objc_msgSend` function. Finally, we attach our callback
    function with a call to the `SetScriptCallbackFunction` function. Note that the
    parameter to this function is your module or script’s name, followed by a period
    and the name of the callback (for example, `objc.msgSendCallback`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的代码获取运行在调试器中的进程的引用。通过这个引用，我们可以调用 `BreakpointCreateByName` 函数，在 `objc_msgSend`
    函数上设置一个断点。最后，我们通过调用 `SetScriptCallbackFunction` 函数来附加回调函数。请注意，这个函数的参数是你的模块或脚本的名称，后跟一个点和回调函数的名称（例如，`objc.msgSendCallback`）。
- en: 'Now, whenever the `objc_msgSend` function is invoked, our callback, `msgSendCallback`,
    will be invoked. In this callback, we simply want to print out the Objective-C
    class and method name that is being invoked, before allowing the debugged process
    to continue. Recall that, in previous discussions of the `objc_msgSend` function,
    we noted that its first parameter is the Objective-C class name, while the second
    is the method name. We also know that on Intel x86_64 platforms, the first two
    parameters will be passed in the `RDI` and `RSI` registers, respectively. This
    means we can implement our callback in the following manner ([Listing 8-16](#listing8-16)):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当调用 `objc_msgSend` 函数时，我们的回调函数 `msgSendCallback` 将会被触发。在这个回调函数中，我们只需打印出正在被调用的
    Objective-C 类名和方法名，然后让调试的进程继续执行。回顾之前对 `objc_msgSend` 函数的讨论，我们提到它的第一个参数是 Objective-C
    类名，第二个参数是方法名。我们还知道，在 Intel x86_64 平台上，前两个参数将分别通过 `RDI` 和 `RSI` 寄存器传递。这意味着我们可以按以下方式实现回调函数（[列表
    8-16](#listing8-16)）：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 8-16: Implementing a breakpoint action via a debugger script'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-16：通过调试器脚本实现断点操作
- en: In order to execute built-in debugger commands, we can use the `HandleCommand`
    API. First, we print out the name of the Objective-C class that can be found within
    the `RDI` register. We make use of the `po` (`print object`) command, because
    the class name we want to display is an Objective-C string object. Following this,
    we print out the method’s name stored in the `RSI` register. As it is a null-terminated
    C string, the `x/s` command suffices for this purpose. Then we instruct the debugger
    to continue, so the debugged process can resume.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行内置的调试器命令，我们可以使用 `HandleCommand` API。首先，我们打印出可以在 `RDI` 寄存器中找到的 Objective-C
    类的名称。我们使用 `po`（`print object`）命令，因为我们想显示的类名是一个 Objective-C 字符串对象。接下来，我们打印出存储在
    `RSI` 寄存器中的方法名。由于它是一个以 null 结尾的 C 字符串，`x/s` 命令就足够了。然后，我们指示调试器继续执行，这样被调试的进程就能恢复运行。
- en: 'We can save the code in Listings 8-15 and 8-16 (for example, to *~/objc.py*),
    load it into a debugger, and then execute a malicious sample we’re interested
    in further analyzing ([Listing 8-17](#listing8-17)):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将列表 8-15 和 8-16 中的代码保存起来（例如，保存到 *~/objc.py*），然后加载到调试器中，再执行我们感兴趣的恶意样本以便进一步分析（[列表
    8-17](#listing8-17)）：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 8-17: Our debugger script in action'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-17：我们的调试器脚本正在运行
- en: From the output of our script, we see that the malware is leveraging the `NSTask`
    class. Behind the scenes, we see that a `NSConcreteTask` is initialized, a launch
    path is set, and then the task is launched. To investigate further, we can now
    manually set a breakpoint on the `NSConcreteTask`’s `launch` method to see exactly
    what the malware is executing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的脚本输出中，我们看到恶意软件正在利用 `NSTask` 类。在幕后，我们看到一个 `NSConcreteTask` 被初始化，设置了启动路径，然后任务被启动。为了进一步调查，我们现在可以手动在
    `NSConcreteTask` 的 `launch` 方法上设置断点，查看恶意软件到底执行了什么。
- en: LLDB debugger scripts are a powerful way to extend the debugger and provide
    an invaluable capability, especially when analyzing more sophisticated malware
    samples. Here we’ve only scratched the surface of what they can do through a trivial,
    albeit useful, example. To learn more, consult online examples, such as Taha Karim’s
    script to automatically dump the Bundlore malware’s payload.^([9](#c08-endnote-9))
    These examples highlight more advanced use cases while also providing valuable
    insight into LLDB’s scripting API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB 调试器脚本是一种强大的方式，可以扩展调试器并提供无价的能力，尤其在分析更复杂的恶意软件样本时。在这里，我们仅通过一个简单但有用的示例触及了它们的表面。要了解更多内容，可以查阅在线示例，例如
    Taha Karim 的脚本，它可以自动转储 Bundlore 恶意软件的有效载荷。^([9](#c08-endnote-9)) 这些示例展示了更高级的使用案例，同时也提供了对
    LLDB 脚本 API 的宝贵洞察。
- en: 'A Sample Debugging Session: Uncovering Hidden Cryptocurrency Mining Logic in
    an App Store Application'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例调试会话：揭示应用商店应用程序中的隐藏加密货币挖矿逻辑
- en: In early 2018, a popular application called Calendar 2, found in Apple’s official
    Mac App Store, was discovered to contain logic that surreptitiously mined cryptocurrency
    on users’ computers ([Figure 8-1](#figure8-1)). Though it isn’t exactly malware
    per se, this application provides an illustrative case study of how a debugger
    can help us understand a binary’s hidden or subversive capabilities. Moreover,
    due to the rise of malicious crytocurrency miners targeting macOS, this example
    is particularly relevant.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 2018 年初，一款名为 Calendar 2 的流行应用程序在苹果官方 Mac App Store 中被发现包含了隐蔽的加密货币挖矿逻辑，能够在用户计算机上悄悄进行加密货币挖矿（[图
    8-1](#figure8-1)）。虽然它本身不算恶意软件，但这个应用程序提供了一个很好的案例，展示了调试器如何帮助我们理解一个二进制文件中隐藏或颠覆性的功能。而且，由于恶意加密货币挖矿程序在
    macOS 上的泛滥，这个例子尤其具有现实意义。
- en: '![Calendar 2 is on the Mac App Store. It’s by Qbix, Inc., has 2/5 stars and
    29 ratings, and is stated as “Free” but “Offers In-App Purchases.”](image_fi/501942c08/f08001.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Calendar 2 在 Mac App Store 上架。由 Qbix, Inc. 开发，评分为 2/5 星，有 29 个评价，标注为“免费”，但“提供应用内购买”。](image_fi/501942c08/f08001.png)'
- en: 'Figure 8-1: A surreptitious cryptocurrency miner in Apple’s official Mac App
    Store'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：苹果官方 Mac App Store 中的隐蔽加密货币挖矿程序
- en: During my initial static analysis triage, I uncovered various methods whose
    names referenced cryptocurrency mining ([Listing 8-18](#listing8-18)). This was
    odd, as the application claimed to simply be a calendar application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我进行初步的静态分析筛查时，我发现了多个方法，这些方法的名称与加密货币挖矿相关（[示例 8-18](#listing8-18)）。这一点很奇怪，因为该应用程序声称只是一个日历应用程序。
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 8-18: Cryptocurrency mining logic within an App Store application?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-18：应用商店应用中的加密货币挖矿逻辑？
- en: In this listing, we can see a method named `runMining` that contains code that
    invokes methods in a framework named `Coinstash_XMRSTAK`. As the framework is
    written in Swift, the method names are slightly mangled, though still mostly readable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以看到一个名为 `runMining` 的方法，里面包含调用名为 `Coinstash_XMRSTAK` 框架中方法的代码。由于该框架是用
    Swift 编写的，因此方法名称略有混淆，但仍然大部分可以读取。
- en: One of the goals of the subsequent dynamic analysis was to uncover information
    about the cryptocurrency account, where any mined coins were to be sent. Based
    on the method names (such as `startMiningWithPort`, `:password:` and so on), I
    reasoned that, in a debugging session, setting a breakpoint on either of the methods
    would reveal this information.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的动态分析目标之一是揭示有关加密货币账户的信息，以便了解任何挖掘的硬币将被发送到哪里。根据方法名称（如 `startMiningWithPort`、`:password:`
    等），我推测，在调试会话中，在这些方法中的任意一个上设置断点将揭示这一信息。
- en: 'After firing up LLDB and loading the application, we can set a breakpoint on
    the `runMining` method by name, as shown in [Listing 8-19](#listing8-19):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 LLDB 并加载应用程序后，我们可以通过名称在 `runMining` 方法上设置一个断点，如[示例 8-19](#listing8-19)所示：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 8-19: Initializing a debugging session and setting an initial breakpoint'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-19：初始化调试会话并设置初始断点
- en: 'Once the breakpoint is set, we instruct the debugger to run the application.
    As expected, it halts at the breakpoint we set ([Listing 8-20](#listing8-20)):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了断点，我们指示调试器运行应用程序。正如预期的那样，它会在我们设置的断点处暂停（[示例 8-20](#listing8-20)）：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8-20: Breakpoint hit; execution halted'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-20：断点命中，执行暂停
- en: Let’s step through the instructions until we reach the call to the Coinstash
    `startMiningWithPort:...` method. As its name suggests, it begins the actual mining.
    Because we want to step over the other method calls prior to reaching it, we use
    the `nexti` (or `n`) command ([Listing 8-21](#listing8-21)). This allows the calls
    to execute but avoids us having to step through them, instruction by instruction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步执行指令，直到我们到达调用Coinstash的`startMiningWithPort:...`方法。顾名思义，它开始了实际的挖矿。由于我们想在到达它之前跳过其他方法调用，我们使用`nexti`（或`n`）命令（见[清单
    8-21](#listing8-21)）。这使得方法调用得以执行，但我们无需逐条指令地执行它们。
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 8-21: Stepping through instructions and over method calls'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-21：逐步执行指令并跳过方法调用
- en: 'Eventually we approach the invocation of the method of interest. Recall that,
    in assembly, Objective-C calls are routed through the `objc_msgSend` function.
    In the debugger, we first see this function’s address being moved into the `R13`
    register. Though we could just set a breakpoint on the call to the `objc_msgSend`
    function (at address `0x100078067`) that invokes the `startMiningWithPort:...`
    method, we’ll take a more exhaustive approach and continue stepping, instruction
    by instruction, until the call has been reached ([Listing 8-22](#listing8-22)):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们接近了感兴趣方法的调用。回想一下，在汇编中，Objective-C 的调用是通过`objc_msgSend`函数进行路由的。在调试器中，我们首先看到该函数的地址被移动到`R13`寄存器中。虽然我们可以直接在调用`objc_msgSend`函数（地址为`0x100078067`）时设置一个断点，以调用`startMiningWithPort:...`方法，但我们会采取更全面的方法，逐步执行每一条指令，直到达到该调用（见[清单
    8-22](#listing8-22)）：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 8-22: Stepping through instructions until the call of interest is reached'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-22：逐步执行指令直到达到感兴趣的调用
- en: Note that, via the `reg read` command, we confirmed that the `R13` register
    indeed contains the `objc_msgSend` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过`reg read`命令，我们确认`R13`寄存器确实包含了`objc_msgSend`函数。
- en: 'Recall from Chapter 6 that, at the time of a call to the `objc_msgSend` function,
    certain registers hold specific argument values by convention.For example, the
    function’s first argument (held in the `RDI` register) is the class or object
    upon which the method is being invoked. During the static analysis triage, this
    was identified as a class named `Coinstash_XMRSTAK.Coinstash`. Using the `print
    object` (`po`) command, we can dynamically see that this is indeed correct:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第六章，当调用`objc_msgSend`函数时，某些寄存器按照约定保存了特定的参数值。例如，函数的第一个参数（保存在`RDI`寄存器中）是调用方法的类或对象。在静态分析筛选过程中，我们识别出这是一个名为`Coinstash_XMRSTAK.Coinstash`的类。通过使用`print
    object`（`po`）命令，我们可以动态地确认这一点：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second argument (held in the `RSI` register) will be a null-terminated
    string that names the method to be invoked. Let’s confirm this is the case, and
    that its value is the `startMiningWithPort:...` method. To print out a null-terminated
    string, we use the `x` command with the `s` format specifier:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数（保存在`RSI`寄存器中）将是一个以空字符终止的字符串，表示要调用的方法名。让我们确认一下这是正确的，并且它的值是`startMiningWithPort:...`方法。为了打印出一个以空字符终止的字符串，我们使用`x`命令，并配合`s`格式说明符：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Following the class and method name are the method’s arguments. From the method’s
    name, we can gather it takes five arguments that include a port, password, and
    currency. We couldn’t easily figure out the values of these arguments using static
    analysis methods, such as a disassembler, because they didn’t readily appear.
    With the debugger, it’s a breeze.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟着类和方法名的是方法的参数。从方法名中我们可以推测，它接受五个参数，包括端口、密码和货币。我们无法通过静态分析方法（如反汇编器）轻松找到这些参数的值，因为它们并未直接显示出来。通过调试器，这一切变得非常简单。
- en: 'We know that the next arguments are stored in the `RDX`, `RCX`, `R8`, and `R9`
    registers, as specified in the application binary interface. As this method takes
    more than four arguments, the last argument will be found on the stack (`RSP`).
    Let’s have a peek ([Listing 8-23](#listing8-23)):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，接下来的参数存储在`RDX`、`RCX`、`R8`和`R9`寄存器中，这是按照应用程序二进制接口（ABI）规定的。由于该方法有超过四个参数，最后一个参数会存储在栈上（`RSP`）。让我们来查看一下（见[清单
    8-23](#listing8-23)）：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 8-23: Displaying the `startMiningWithPort:``...` method’s parameters'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-23：显示`startMiningWithPort:...`方法的参数
- en: Note that for the arguments that are objects, we use the `po` command to display
    their contents. For those that aren’t, we use the other appropriate display commands,
    such as `reg read $r8`to view the contents of a register and `x/s` to display
    a NULL-terminated string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于对象类型的参数，我们使用`po`命令来显示其内容。对于非对象类型的参数，我们使用其他合适的显示命令，例如`reg read $r8`来查看寄存器的内容，`x/s`来显示以NULL结尾的字符串。
- en: 'By examining the arguments, we’ve uncovered the port (`7777`), the account
    password (`qbix:greg@qbix.com`), cryptocurrency (`graft`), and more! Moreover,
    if we continue our debugging session, we’ll encounter additional data, for example,
    within a `NSURLRequest` object (which in this debugging session is found in memory
    at 0x1018f04e0). In the debugger, in conjunction with the `po` command, we can
    invoke the `NSURLRequest`’s `HTTPBody` method on the object 1 to display the contents
    (specifically the body), of this network request. This reveals detailed account
    information and cryptomining statistics ([Listing 8-24](#listing8-24)):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查参数，我们揭示了端口（`7777`）、账户密码（`qbix:greg@qbix.com`）、加密货币（`graft`）等信息！而且，如果我们继续调试，还会遇到更多数据，例如，在一个`NSURLRequest`对象中（在本次调试会话中，它位于内存地址0x1018f04e0）。在调试器中，结合`po`命令，我们可以调用`NSURLRequest`对象的`HTTPBody`方法来显示该网络请求的内容（特别是请求体）。这将揭示详细的账户信息和加密挖矿统计数据（[列表
    8-24](#listing8-24)）：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 8-24: Displaying a network object containing cryptocurrency miner account
    information and statistics'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-24：显示包含加密货币挖矿账号信息和统计数据的网络对象
- en: It is also worth noting that, as this information is securely transmitted over
    the network (encrypted), it would have been rather involved to recover it via
    a simple network monitor. Via the debugger, it was relatively straightforward.
    If you’re interested in the full analysis of this application, including more
    details on the use of a debugger to uncover and understand its cryptomining logic,
    see my write-up “A Surreptitious Cryptocurrency Miner in the Mac App Store?”^([10](#c08-endnote-10))
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，由于这些信息通过网络安全地传输（加密），因此通过简单的网络监控工具恢复这些信息会相当复杂。然而，通过调试器，这一过程相对简单。如果你对这个应用程序的完整分析感兴趣，包括使用调试器揭示和理解其加密挖矿逻辑的更多细节，请参见我的文章《Mac应用商店中的隐秘加密货币挖矿者？》^([10](#c08-endnote-10))
- en: Up Next
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来
- en: In this chapter I introduced the debugger, the most thorough tool for analyzing
    even complex malware threats. Specifically, I showed how to debug a binary via
    breakpoints, instruction by instruction, while examining or modifying registers
    and memory contents, skipping functions you don’t want to execute, and much more.
    Now that you’re armed with this analysis capability, malware doesn’t stand a chance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了调试器，这是一种最彻底的工具，能够分析甚至是复杂的恶意软件威胁。具体来说，我展示了如何通过断点逐步调试二进制文件，同时检查或修改寄存器和内存内容，跳过不需要执行的函数等等。现在，拥有了这种分析能力，恶意软件根本没有机会。
- en: Of course, malware authors are less than stoked that their malicious creations
    can be deconstructed so easily. In the next chapter, we’ll dive into the kinds
    of anti-analysis logic employed by malware authors to thwart (or at least complicate)
    both static and dynamic analysis efforts.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，恶意软件作者并不高兴他们的恶意创作可以如此轻松地被拆解。在下一章中，我们将深入探讨恶意软件作者为阻止（或至少复杂化）静态和动态分析工作而使用的各种反分析逻辑。
- en: Endnotes*
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释*
