- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nevertheless, We Persisted
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While we’re waiting for our shell to phone home, there is one small task that
    needs our immediate attention: AWS persistence. One might argue that Jenkins’s
    access keys provide all the persistence we need, since access keys are often difficult
    to rotate and require reviewing hundreds of jobs for potential hardcoded credentials.
    It is such a critical piece of any DevOps infrastructure that it ironically succumbs
    to the same fallacies DevOps is so arrogantly belligerent against—the most recent
    proof being that the credentials we retrieved from Chef were still very much in
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we have some time to kill while waiting for our shell on a GP
    machine, so let’s strengthen our grip on MXR Ads.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS Sentries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backdooring an AWS account can be a delicate procedure involving navigating
    a treacherous sea of monitoring tools and sensitive alerts. AWS has made considerable
    efforts to spoon-feed its customers all sorts of indicators of suspicious activity
    and what it considers to be insecure configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two AWS features in particular that one should be aware of before
    blindly attacking or backdooring an account: IAM Access Analyzer and CloudTrail
    Insights.'
  prefs: []
  type: TYPE_NORMAL
- en: 'IAM Access Analyzer flags every policy document that grants read/write permissions
    to foreign entities. It most notably covers S3 buckets, KMS keys, Lambda functions,
    and IAM roles. When introduced, this feature killed one very stealthy persistence
    strategy: creating an admin role in the victim’s account and granting assume-role
    privileges to a foreign (our own) AWS account.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly check whether there are any Access Analyzer reports produced
    in the `eu-west-1` region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: MXR Ads does not yet take advantage of this feature, but we cannot bet our persistence
    strategy on the company’s ignorance of a feature that could expose our backdoor
    with a single click.
  prefs: []
  type: TYPE_NORMAL
- en: 'CloudTrail is an AWS service that logs almost every AWS API call in JSON format
    and optionally stores it on S3 and/or forwards it to another service like CloudWatch
    to configure metrics and alerts. [Listing 11-1](#listing11-1) is a sample event
    of an IAM call that created an access key for the admin user. The event is ripe
    with information essential to any threat analyst: source IP address, identity
    of the caller, source of the event, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: CloudTrail `CreateAccessKey` event'
  prefs: []
  type: TYPE_NORMAL
- en: You have got to hand it to AWS for making logging events so intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: MXR Ads has a global and comprehensive logging strategy covering all regions,
    as displayed in [Listing 11-2](#listing11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: Configuration of a trail on CloudTrail that forwards logs to
    CloudWatch and S3'
  prefs: []
  type: TYPE_NORMAL
- en: Logs are forwarded to the S3 bucket `mxrads-cloudtrail-all` 2.
  prefs: []
  type: TYPE_NORMAL
- en: We see from the flag `HasInsightSelectors` 1 that MXR Ads is experimenting with
    a CloudTrail feature called *Insights*, which detects a spike in API calls and
    flags it as a suspicious event. As of this moment, it only reports write API calls,
    like `RunInstance`, `CreateUser`, `CreateRole`, and so on. We can still go nuts
    with read-only and reconnaissance calls, but as soon as we start automating user
    account creation, for instance, we must be careful not to hit the dynamic threshold
    set by CloudTrail Insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two features (CloudTrail Insights and IAM Access Analyzer) complement
    other existing services, like GuardDuty, that watch for suspicious events, such
    as disabling security features (CloudTrail) and communicating with known-bad domains.
    We can check if GuardDuty is enabled in a given region with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even if MXR Ads neglected to implement all these novelty features, CloudTrail
    is such a basic component that almost every company has it enabled by default.
    We could empty the S3 bucket storing the CloudTrail data, but the logs would still
    be available in CloudTrail itself for at least 90 days.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever logs are so easily available and useful, caution would advise us to
    assume the worst: monitoring dashboards tracking API calls, IP addresses, types
    of services called, unusual queries to highly privileged services, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the cherry on top: Terraform. We know that MXR Ads relies on Terraform
    to maintain its infrastructure. If we were to manually change the wrong resource,
    it would stand out like a sore thumb on the next `terraform plan` command. An
    email bearing the subject “You’ve Been Hacked” might have a better chance of going
    unnoticed.'
  prefs: []
  type: TYPE_NORMAL
- en: These are some of the main pitfalls to keep in mind when interacting with an
    AWS account. They truly are landmines that can blow up at the slightest misstep.
    It almost makes you miss the old days of backdooring a Windows Active Directory,
    when aggregating and parsing event logs from a single machine was a two-day job.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you’re in a situation where your target has very poor security and you
    feel you can get away with manually creating a couple of access keys, adding a
    few believable IAM users, and giving them admin privileges, please be my guest.
    In that case there is no need to overengineer the backdoor strategy, especially
    knowing that Jenkins’s access keys are pretty stable.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the company looks overly paranoid—tight access controls, strict
    and limited privileges, a clean list of active users, and properly configured
    CloudTrail, CloudWatch, and other monitoring tools—you may need a more robust
    and stealthier backup strategy.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of argument, let’s give MXR Ads the benefit of the doubt and assume
    the worst. How can we maintain persistent access while flying under the radar?
  prefs: []
  type: TYPE_NORMAL
- en: Persisting in the Utmost Secrecy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our backdoor strategy will follow the hippest design architectures and be fully
    serverless and event-driven. We’ll configure a watchdog to fire upon specific
    events and trigger a job that will re-establish our access when those events are
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: Translated into AWS jargon, the watchdog would consist of a Lambda function
    triggered by an event of our choosing. We can opt for a CloudWatch event that
    fires every day at 10 AM, for instance, or a load balancer that receives a predefined
    request. We choose to go with an event fired when an S3 bucket receives new objects.
    Both MXR Ads and GP use this same trigger, so we have a higher chance of blending
    in. Once executed, the Lambda will dump its attached role credentials and send
    them to our own S3 bucket. The credentials we receive will be valid for one hour
    but will hold enough privileges to permanently restore durable access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review our detection checklist: the Lambda function will be triggered
    by some frequently occurring internal event (in this case, when an object is uploaded
    to MXR Ads’ S3 bucket) and will, in response, perform a rather boring put-object
    call to deposit a file containing its credentials in a remote bucket. IAM Access
    Analyzer will hardly blink.'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform will not scream blue murder at the setup phase, as most of the resources
    will be created, not altered. Even if the source bucket is already declared in
    the state, technically we will be adding an `aws_s3_bucket_notification` resource,
    which is a completely separate entity in Terraform. All we have to do is choose
    a bucket with no Terraformed notification setup, and we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: As for CloudTrail, the only event it will log is the trusted service *lambda.amazonaws.com*
    impersonating a role to execute the Lambda. This is a trivial event inherent to
    any Lambda execution that will go unnoticed by both Insights and GuardDuty.
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks green!
  prefs: []
  type: TYPE_NORMAL
- en: The Program to Execute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s get to the implementation phase. The program that the Lambda will run
    is a straightforward Go binary that follows the key steps just described. The
    full implementation is available in this book’s repo ([http://bit.ly/2Oan7I7](http://bit.ly/2Oan7I7)),
    so here is a brief overview of the main logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Go program destined to run in a Lambda environment starts off with the
    same boilerplate `main` function that registers the Lambda’s entry point (`HandleRequest`
    in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a classic setup to build an HTTP client and create the remote
    S3 URL to submit our response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We dump the Lambda’s role credentials from environment variables and send them
    to our remote bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `uploadToS3` method is a simple PUT request to the previously defined URL,
    so its implementation should be pretty obvious from reading the source code, which
    all in all is about 44 lines long.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compile the code and then zip the binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we turn our attention to setting up the Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Lambda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Lambda needs an execution role with heavy IAM and CloudTrail permissions
    to help us maintain stealthy long-term access (more on that later).
  prefs: []
  type: TYPE_NORMAL
- en: 'We look for promising candidates we can impersonate with the Lambda AWS service.
    Remember that in order to impersonate a role, two conditions must be met: the
    user must be able to issue `sts assume-role` calls and the role must accept impersonation
    from said user. We list the roles available within MXR Ads’ AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We check each role’s IAM policy until we find a role with the set of permissions
    we need—ideally, full IAM and CloudTrail access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `dynamo-ssh-mgmt` role might do the trick, as it has an `IAMFullAccess`
    policy. Cheeky. If we had been creating our own role from scratch in MXR Ads’
    AWS account, we would not have dared to attach such an obvious policy. However,
    since they’re already using it, we might as well take advantage of it. Plus, this
    role lacks CloudWatch write permissions, so the Lambda will silently discard its
    execution logs upon termination rather than passing them to CloudWatch. Perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we try hiding in plain sight by sticking to existing naming conventions.
    We look up existing Lambda functions in the `eu-west-1` region for inspiration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll settle on the name `support-metrics-calc` and call the `create-function`
    API to register our backdoored Lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now to the trigger event itself.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Trigger Event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, we want to target an S3 bucket that’s regularly updated by MXR Ads,
    but not so often that it would trigger our Lambda 1,000 times a day.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about s4d.mxrads.com, the bucket storing all creatives that we looked at
    in Chapter 8? A quick `list-objects-v2` API call shows that the update pace is
    relatively low, between 50 and 100 files a day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can reduce the trigger rate by sampling the objects firing the notification
    event. We’ll make it so only objects with a key name beginning with `"2"` will
    trigger our Lambda, giving us a 1/16 sample rate (assuming a hexadecimal key space,
    evenly distributed). This roughly translates to three to six invocations a day.
  prefs: []
  type: TYPE_NORMAL
- en: Sold.
  prefs: []
  type: TYPE_NORMAL
- en: 'We explicitly allow the S3 service to call our Lambda function. The `statement-id`
    parameter is an arbitrary, unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set up the bucket rule that only triggers events upon creating objects
    starting with the `"2"` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Brilliant. We have a solid persistence strategy that bypasses old and new detection
    features alike.
  prefs: []
  type: TYPE_NORMAL
- en: Now assume our Jenkins access gets revoked somehow and we would like to use
    our Lambda credentials to re-establish permanent access. Should we just spawn
    a new IAM user with unlimited privileges and carry on with our lives? Not the
    wisest approach. Any monitoring solution based on CloudTrail could pick up this
    odd request in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The current CloudTrail configuration, as we saw earlier, aggregates logs from
    all regions into the one `eu-west-1` region. The logs are then pushed into S3
    and CloudWatch where they can be consumed by monitoring devices. This event-forwarding
    feature is called a *trail*.
  prefs: []
  type: TYPE_NORMAL
- en: Before calling any IAM operation, we need to disrupt this trail.
  prefs: []
  type: TYPE_NORMAL
- en: Covering Our Tracks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how our intention is not to disable logging but to disrupt the trail
    itself. Indeed, it is currently impossible to completely disable CloudTrail or
    make it skip events. No matter what we do, our API calls will still be visible
    in the CloudTrail event dashboard for the next 90 days.
  prefs: []
  type: TYPE_NORMAL
- en: The trail, however, can be reconfigured to omit forwarding certain events. It
    can even black out entire regions while we carry out our nefarious tasks.
  prefs: []
  type: TYPE_NORMAL
- en: No trail means no logs on S3, no GuardDuty, no CloudTrail Insights, no CloudWatch
    metrics, and no custom security dashboards. Just like dominos, all monitoring
    tools inside and outside AWS will fall one after the other in a deafening silence.
    We could add 100 IAM users or start 1,000 instances in São Paulo and nobody would
    notice a thing, except perhaps for the accounting department.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick example showing how we can reconfigure the trail to exclude
    global (IAM, STS, and so on) and multiregion events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Starting from this instant, we have *carte blanche* to create users and access
    keys, and do all sorts of tomfoolery. Someone manually going through the CloudTrail
    dashboard might pick up on our API calls if we are extremely careless, but all
    automated solutions and tools will be in the dark.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering Access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have disabled CloudTrail, we can move on to creating a more permanent
    set of AWS credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users and groups affiliated with the default admin policy are easy prey. IAM
    users are limited to two access keys, so we find a user with one or zero access
    keys and proceed to inject them with an additional key that we will secretly own.
    First, we list the users and groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we list their currently defined access keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, *b.daniella* only has one key. With our target identified, we create
    an access key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And we are back in business. We’ve regained permanent credentials.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot re-enable multiregion logging just yet, though. We need to wait at
    least half an hour after our last API call. This waiting period is critical, because
    it can take up to 20 minutes for the event to get to CloudTrail. If we reactivate
    global event logging too early, some of our actions might slip into the trail,
    and therefore into S3, Insights, CloudWatch, and other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative (Worse) Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering why we don’t simply use the Lambda itself to automate subsequent
    IAM/CloudTrail actions. A Lambda function can only last a maximum of 15 minutes,
    so there is a reasonable chance it would re-enable global event logs too soon.
    We could hook another Lambda on our side to avoid this race condition, but that’s
    too much pipeline work for something so trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could opt for running a reverse shell directly in the Lambda
    environment, but that’s far from convenient. The function runs in a minimal container
    where the filesystem is mounted as read-only, except for the */tmp* folder, which
    lacks the executable flag. We would need to manually load the reverse shell in
    memory as an independent process, so it does not get terminated by the Lambda
    handler. All for what? A barren land lacking the most basic utilities that will
    be recycled by AWS in 60 minutes? Not worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More information on IAM Access Analyzer: [https://aws.amazon.com/iam/features/analyze-access/](https://aws.amazon.com/iam/features/analyze-access/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on CloudTrail Insights: [https://amzn.to/38ROX6E](https://amzn.to/38ROX6E).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of AWS S3 notification events: [https://amzn.to/2MTqg1o](https://amzn.to/2MTqg1o).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about centralizing logs: [https://www.loggly.com/ultimate-guide/centralizing-windows-logs/](https://www.loggly.com/ultimate-guide/centralizing-windows-logs/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about querying Windows logs: [https://evotec.xyz/powershell-everything-you-wanted-to-know-about-event-logs/](https://evotec.xyz/powershell-everything-you-wanted-to-know-about-event-logs/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
