<html><head></head><body>
		<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_503"/><strong><span class="big">14</span></strong><br/><strong>ITERATIVE CONTROL STRUCTURES</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">Most programs spend the majority of their time executing machine instructions within a loop. Therefore, if you want to improve your applications’ execution speed, first you should see if you can improve the performance of the loops in your code. This chapter will describe the following varieties of loops:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent"><span class="literal">while</span> loops</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><span class="literal">repeat..until/do..while</span> loops</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><span class="literal">forever</span> (infinite) loops</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><span class="literal">for</span> (definite) loops</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h3 class="h3" id="ch00lev1sec115"><span epub:type="pagebreak" id="page_504"/><strong>14.1 The while Loop</strong></h3>&#13;
		<p class="noindent">The <span class="literal">while</span> loop is perhaps the most general-purpose iterative statement that HLLs provide, so compilers generally work hard at emitting optimal code for it. The <span class="literal">while</span> loop tests a Boolean expression at the top of the loop body and, if the expression evaluates to <span class="literal">true</span>, executes the loop body. When the loop body completes execution, control transfers back to the test and the process repeats. When the Boolean control expression evaluates to <span class="literal">false</span>, the program transfers control to the first statement beyond the loop’s body. This means that if the Boolean expression evaluates to <span class="literal">false</span> when the program first encounters the <span class="literal">while</span> statement, the program immediately skips over all statements in the loop body without executing any of them. The following example demonstrates a Pascal <span class="literal">while</span> loop:</p>&#13;
		<pre class="programs">&#13;
			while( a &lt; b ) do begin<br/><br/>  &lt;&lt; Statements to execute if a is less than b.<br/>     Presumably, these statements modify the value<br/>     of either a or b so that this loop ultimately<br/>     terminates. &gt;&gt;<br/><br/>end; (* while *)<br/>&lt;&lt; statements that execute when a is not less than b &gt;&gt;</pre>&#13;
		<p class="indent">You can easily simulate a <span class="literal">while</span> loop in an HLL by using an <span class="literal">if</span> statement and a <span class="literal">goto</span> statement. Consider the following C/C++ <span class="literal">while</span> loop and the semantically equivalent code using an <span class="literal">if</span> and a <span class="literal">goto</span>:</p>&#13;
		<pre class="programs">&#13;
			// while loop:<br/><br/>while( x &lt; y )<br/>{<br/>  arr[x] = y;<br/>  ++x;<br/>}<br/><br/>// Conversion to an if and a goto:<br/><br/>whlLabel:<br/>if( x &lt; y )<br/>{<br/>  arr[x] = y;<br/>  ++x;<br/>  goto whlLabel;<br/>}</pre>&#13;
		<p class="indent">Assume for the sake of this example that <span class="literal">x</span> is less than <span class="literal">y</span> when the <span class="literal">if</span>/<span class="literal">goto</span> combination first executes. This being <span class="literal">true</span>, the body of the loop (the <span class="literal">then</span> portion of the <span class="literal">if</span> statement) executes. At the bottom of the loop body, the <span class="literal">goto</span> statement transfers control back to just before the <span class="literal">if</span> statement. This means that the code will test the expression again, just as the <span class="literal">while</span> <span epub:type="pagebreak" id="page_505"/>loop does. Whenever the <span class="literal">if</span> expression evaluates to <span class="literal">false</span>, control will transfer to the first statement after the <span class="literal">if</span> (which transfers control beyond the <span class="literal">goto</span> statement in this code).</p>&#13;
		<p class="indent">Although the <span class="literal">if</span>/<span class="literal">goto</span> arrangement is semantically identical to the <span class="literal">while</span> loop, that’s not to suggest that the <span class="literal">if</span>/<span class="literal">goto</span> scheme presented here is more efficient than what a typical compiler would generate. It’s not. The following assembly code shows what you’d get from a mediocre compiler for the previous <span class="literal">while</span> loop:</p>&#13;
		<pre class="programs">&#13;
			  // while( x &lt; y )<br/><br/>whlLabel:<br/>    mov( x, eax );<br/>    cmp( eax, y );<br/>    jnl exitWhile;  // jump to exitWhile label if<br/>                    // x is not less than y<br/><br/>    mov( y, edx );<br/>    mov( edx, arr[ eax*4 ] );<br/>    inc( x );<br/>    jmp whlLabel;<br/>exitWhile:</pre>&#13;
		<p class="indent">A decent compiler will improve upon this slightly by using a technique known as <em>code movement</em> (or <em>expression rotation</em>). Consider this slightly more efficient implementation of the previous <span class="literal">while</span> loop:</p>&#13;
		<pre class="programs">&#13;
			// while( x &lt; y )<br/><br/>    // Skip over the while loop's body.<br/><br/>    jmp testExpr;<br/><br/>whlLabel:<br/>    // This is the body of the while loop (same as<br/>    // before, except moved up a few instructions).<br/><br/>    mov( y, edx );<br/>    mov( edx, arr[ eax*4 ] );<br/>    inc( x );<br/><br/>// Here is where we test the expression to<br/>// determine if we should repeat the loop body.<br/><br/>testExpr:<br/>    mov( x, eax );<br/>    cmp( eax, y );<br/>    jl whlLabel;    // Transfer control to loop body if x &lt; y.</pre>&#13;
		<p class="indent">This example has exactly the same number of machine instructions as the previous example, but the test for loop termination has been moved to the bottom of the loop. To preserve the semantics of a <span class="literal">while</span> loop (so that <span epub:type="pagebreak" id="page_506"/>we don’t execute the loop body if the expression evaluates to <span class="literal">false</span> upon first encountering the loop), the first statement in this sequence is a <span class="literal">jmp</span> statement that transfers control down to the code that tests the loop termination expression. If that test evaluates to <span class="literal">true</span>, the program transfers control to the body of the <span class="literal">while</span> loop (immediately after <span class="literal">whlLabel</span>).</p>&#13;
		<p class="indent">Although this code has the same number of statements as the previous example, there’s a subtle difference between the two implementations. In this latter example, the initial <span class="literal">jmp</span> instruction executes only once—the very first time the loop executes. For each iteration thereafter, the code skips the execution of this statement. In the original example, the corresponding <span class="literal">jmp</span> statement is at the bottom of the loop’s body, and it executes on each iteration of the loop. Therefore, if the loop body executes more than once, the second version runs faster (on the other hand, if the <span class="literal">while</span> loop rarely executes the loop body even once, then the first version is slightly more efficient). If your compiler does not generate the best code for a <span class="literal">while</span> statement, consider getting a different compiler. As <a href="ch13.xhtml#ch13">Chapter 13</a> discussed, attempting to write optimal code in an HLL by using <span class="literal">if</span> and <span class="literal">goto</span> statements will produce difficult-to-read spaghetti code and, more often than not, <span class="literal">goto</span> statements in your code will actually impair the compiler’s ability to produce decent output.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>When this chapter discusses the <span class="codeitalic">repeat..until</span>/<span class="codeitalic">do..while</span> loop, you’ll see an alternative to the <span class="codeitalic">if..goto</span> scheme that will produce more structured code that the compiler may be able to handle. Still, if your compiler cannot make a simple transformation like this one, chances are the efficiency of the compiled <span class="codeitalic">while</span> loops is among the least of your problems.</em></p>&#13;
		</div>&#13;
		<p class="indent">Compilers that do a decent job of optimizing <span class="literal">while</span> loops typically make certain assumptions about the loop, the biggest one being that the loop has exactly one entry point and one exit point. Many languages provide statements allowing the premature exit of a loop (for example, <span class="literal">break</span>, as discussed in “Restricted Forms of the <span class="literal">goto</span> Statement” on <a href="ch13.xhtml#page_459">page 459</a>). Of course, many languages provide some form of the <span class="literal">goto</span> statement that will allow you to enter or exit the loop at an arbitrary point. However, keep in mind that using such statements, while probably legal, may severely affect the compiler’s ability to optimize the code. So use them with caution.<sup><a id="ch14fn_1"/><a href="footnotes.xhtml#ch14fn1">1</a></sup> The <span class="literal">while</span> loop is one area where you should let the compiler do its job rather than trying to optimize the code yourself (actually, this applies for all loops, as compilers generally do a good job of optimizing loops).</p>&#13;
		<h4 class="h4" id="ch00lev2sec176"><strong>14.1.1 Forcing Complete Boolean Evaluation in a while Loop</strong></h4>&#13;
		<p class="noindent">The execution of a <span class="literal">while</span> statement depends upon the semantics of Boolean expression evaluation. As with the <span class="literal">if</span> statement, sometimes the correct execution of a <span class="literal">while</span> loop depends upon whether the Boolean expression <span epub:type="pagebreak" id="page_507"/>uses complete evaluation or short-circuit evaluation. This section describes ways to force a <span class="literal">while</span> loop to use full Boolean evaluation, and the following section will demonstrate ways to force short-circuit evaluation.</p>&#13;
		<p class="indent">At first blush, you might guess that forcing complete Boolean evaluation in a <span class="literal">while</span> loop is done the same way as in an <span class="literal">if</span> statement. However, if you look back at the solutions given for the <span class="literal">if</span> statement (see “Forcing Complete Boolean Evaluation in an <span class="literal">if</span> Statement” on <a href="ch13.xhtml#page_465">page 465</a>), you’ll realize that the approaches we used for the <span class="literal">if</span> statement (nesting <span class="literal">if</span>s and temporary calculations) won’t work for a <span class="literal">while</span> statement. We need a different approach.</p>&#13;
		<h5 class="h5" id="ch00lev3sec79"><strong>14.1.1.1 Using Functions the Easy but Inefficient Way</strong></h5>&#13;
		<p class="noindent">One easy way to force complete Boolean evaluation is to write a function that computes the result of the Boolean expression and use complete Boolean evaluation within that function. The following C code implements this idea:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>/*<br/>** Complete Boolean evaluation<br/>** for the expression:<br/>** i &lt; g(y) || k &gt; f(x)<br/>*/<br/><br/>int func( void )<br/>{<br/>    int temp;<br/>    int temp2;<br/><br/>    temp = i &lt; g(y);<br/>    temp2 = k &gt; f(x);<br/>    return temp || temp2;<br/>}<br/><br/>int main( void )<br/>{<br/>    /*<br/>    ** The following while loop<br/>    ** uses complete Boolean evaluation<br/>    */<br/><br/>    while( func() )<br/>    {<br/><span epub:type="pagebreak" id="page_508"/>      IntoIF:<br/><br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the code that GCC (x86) emits for this C code (with a little cleanup to remove superfluous lines):</p>&#13;
		<pre class="programs">&#13;
			func:<br/>.LFB0:<br/>        pushq   %rbp<br/>        movq    %rsp, %rbp<br/>        subq    $16, %rsp<br/>        movl    y(%rip), %eax<br/>        movl    %eax, %edi<br/>        call    g<br/>        movl    %eax, %edx<br/>        movl    i(%rip), %eax<br/>        cmpl    %eax, %edx<br/>        setg    %al<br/>        movzbl  %al, %eax<br/>        movl    %eax, -8(%rbp)<br/>        movl    x(%rip), %eax<br/>        movl    %eax, %edi<br/>        call    f<br/>        movl    %eax, %edx<br/>        movl    k(%rip), %eax<br/>        cmpl    %eax, %edx<br/>        setl    %al<br/>        movzbl  %al, %eax<br/>        movl    %eax, -4(%rbp)<br/>        cmpl    $0, -8(%rbp)<br/>        jne     .L2<br/>        cmpl    $0, -4(%rbp)<br/>        je      .L3<br/>.L2:<br/>        movl    $1, %eax<br/>        jmp     .L4<br/>.L3:<br/>        movl    $0, %eax<br/>.L4:<br/>        leave<br/>        ret<br/>.LFE0:<br/>        .size   func, .-func<br/>        .section        .rodata<br/>.LC0:<br/>        .string "Hello"<br/>        .text<br/>        .globl  main<br/>        .type   main, @function<br/><span epub:type="pagebreak" id="page_509"/>main:<br/>.LFB1:<br/>        pushq   %rbp<br/>        movq    %rsp, %rbp<br/>        jmp     .L7<br/>.L8:<br/>        movl    $.LC0, %edi<br/>        movl    $0, %eax<br/>        call    printf<br/>.L7:<br/>        call    func<br/>        testl   %eax, %eax<br/>        jne     .L8<br/>        movl    $0, %eax<br/>        popq    %rbp<br/>        ret</pre>&#13;
		<p class="indent">As the assembly code demonstrates, the problem with this approach is that this code must make a function call and return (both of which are slow operations) in order to compute the value of the expression. For many expressions, the overhead of the call and return is more expensive than the actual computation of the expression’s value.</p>&#13;
		<h5 class="h5" id="ch00lev3sec80"><strong>14.1.1.2 Using Inline Functions</strong></h5>&#13;
		<p class="noindent">The previous approach definitely doesn’t yield the greatest code you could obtain, in terms of either space or speed. If your compiler supports inline functions, you can produce a much better result by inlining <span class="literal">func()</span> in this example:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>inline int func( void )<br/>{<br/>    int temp;<br/>    int temp2;<br/><br/>    temp = i &lt; g(y);<br/>    temp2 = k &gt; f(x);<br/>    return temp || temp2;<br/>}<br/><br/>int main( void )<br/>{<br/><span epub:type="pagebreak" id="page_510"/>    while( func() )<br/>    {<br/>      IntoIF:<br/><br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the conversion to (32-bit) x86 Gas assembly by the GCC compiler:</p>&#13;
		<pre class="programs">&#13;
			main:<br/>        pushl   %ebp<br/>        movl    %esp, %ebp<br/>        pushl   %ebx<br/>        pushl   %ecx<br/>        andl    $-16, %esp<br/>        .p2align 2,,3<br/>.L2:<br/>        subl    $12, %esp<br/><br/>; while( i &lt; g(y) || k &gt; f(x) )<br/>;<br/>; Compute g(y) into %EAX:<br/><br/>        pushl   y<br/>        call    g<br/>        popl    %edx<br/>        xorl    %ebx, %ebx<br/>        pushl   x<br/><br/>; See if i &lt; g(y) and leave Boolean result<br/>; in %EBX:<br/><br/>        cmpl    %eax, i<br/>        setl    %bl<br/><br/>; Compute f(x) and leave result in %EAX:<br/><br/>        call    f                ; Note that we call f, even if the<br/>        addl    $16, %esp        ; above evaluates to true<br/><br/>; Compute k &gt; f(x), leaving the result in %EAX.<br/><br/>        cmpl    %eax, k<br/>        setg    %al<br/><br/>; Compute the logical OR of the above two expressions.<br/><br/>        xorl    %edx, %edx<br/>        testl   %ebx, %ebx<br/>        movzbl  %al, %eax<br/>        jne     .L6<br/><span epub:type="pagebreak" id="page_511"/>        testl   %eax, %eax<br/>        je      .L7<br/>.L6:<br/>        movl    $1, %edx<br/>.L7:<br/>        testl   %edx, %edx<br/>        je      .L10<br/>.L8:<br/><br/>; Loop body:<br/><br/>        subl    $12, %esp<br/>        pushl   $.LC0<br/>        call    printf<br/>        addl    $16, %esp<br/>        jmp     .L2<br/>.L10:<br/>        xorl    %eax, %eax<br/>        movl    -4(%ebp), %ebx<br/>        leave<br/>        ret</pre>&#13;
		<p class="indent">As this example demonstrates, GCC compiles the function directly into the <span class="literal">while</span> loop’s test, sparing this program the overhead associated with the function call and return.</p>&#13;
		<h5 class="h5" id="ch00lev3sec81"><strong>14.1.1.3 Using Bitwise Logical Operations</strong></h5>&#13;
		<p class="noindent">In the C programming language, which supports Boolean operations on bits (also known as <em>bitwise logical operations</em>), you can use the same trick employed for the <span class="literal">if</span> statement to force complete Boolean evaluation—just use the bitwise operators. In the special case where the left and right operands of the <span class="literal">&amp;&amp;</span> or <em>||</em> operators are always <span class="literal">0</span> or <span class="literal">1</span>, you can use code like the following to force complete Boolean evaluation:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    // Use "|" rather than "||"<br/>    // to force complete Boolean<br/>    // evaluation here.<br/><br/>    while( i &lt; g(y) | k &gt; f(x) )<br/>    {<br/><span epub:type="pagebreak" id="page_512"/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the assembly code that Borland C++ generates for this C source code:</p>&#13;
		<pre class="programs">&#13;
			_main   proc    near<br/>?live1@0:<br/>   ;<br/>   ;    int main( void )<br/>   ;<br/>@1:<br/>        push      ebx<br/>        jmp       short @3 ; Skip to expr test.<br/>   ;<br/>   ;    {<br/>   ;            while( i &lt; g(y) | k &gt; f(x) )<br/>   ;            {<br/>   ;                    printf( "Hello" );<br/>   ;<br/>@2:<br/>        ; Loop body.<br/><br/>        push      offset s@<br/>        call      _printf<br/>        pop       ecx<br/><br/>; Here's where the test of the expression<br/>; begins:<br/><br/>@3:<br/>        ; Compute "i &lt; g(y)" into ebx:<br/><br/>        mov       eax,dword ptr [_y]<br/>        push      eax<br/>        call      _g<br/>        pop       ecx<br/>        cmp       eax,dword ptr [_i]<br/>        setg      bl<br/>        and       ebx,1<br/><br/>        ;  Compute "k &gt; f(x)" into EDX:<br/><br/>        mov       eax,dword ptr [_x]<br/>        push      eax<br/>        call      _f<br/>        pop       ecx<br/>        cmp       eax,dword ptr [_k]<br/>        setl      dl<br/>        and       edx,1<br/><span epub:type="pagebreak" id="page_513"/>        ; Compute the logical OR of<br/>        ; the two results above:<br/><br/>        or        ebx,edx<br/><br/>        ; Repeat loop body if true:<br/><br/>        jne       short @2<br/>   ;<br/>   ;            }<br/>   ;<br/>   ;            return( 0 );<br/>   ;<br/>        xor       eax,eax<br/>   ;<br/>   ;    }<br/>   ;<br/>@5:<br/>@4:<br/>        pop       ebx<br/>        ret<br/>_main   endp</pre>&#13;
		<p class="indent">As you can see in this 80x86 output, the compiler generates semantically equivalent code when using the bitwise logical operators. Just keep in mind that this code is valid only if you use <span class="literal">0</span> and <span class="literal">1</span> for the Boolean values <span class="literal">false</span> and <span class="literal">true</span>, respectively.</p>&#13;
		<h5 class="h5" id="ch00lev3sec82"><strong>14.1.1.4 Using Unstructured Code</strong></h5>&#13;
		<p class="noindent">If you don’t have inline function capability or if bitwise logical operators aren’t available, you can use unstructured code to force complete Boolean evaluation as a last resort. The basic idea is to create an infinite loop and then write code to explicitly exit the loop if the condition fails. Generally, you’d use a <span class="literal">goto</span> statement (or a limited form of the <span class="literal">goto</span> statement like C’s <span class="literal">break</span> or <span class="literal">continue</span> statements) to control loop termination. Consider the following example in C:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    int temp;<br/>    int temp2;<br/><span epub:type="pagebreak" id="page_514"/><br/>    for( ;; )                 //Infinite loop in C/C++<br/>    {<br/>        temp = i &lt; g(y);<br/>        temp2 = k &gt; f(x);<br/>        if( !temp &amp;&amp; !temp2 ) break;<br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">By using an infinite loop with an explicit break, we were able to compute the two components of the Boolean expression using separate C statements (hence, forcing the compiler to execute both subexpressions). Here’s the code that the MSVC++ compiler produces:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 16<br/>$LN9:<br/>        sub     rsp, 56                                 ; 00000038H<br/><br/>; Infinite loop jumps here:<br/><br/>$LN2@main:<br/>; Line 21<br/>;<br/>; temp = i &lt; g(y);<br/>;<br/>        mov     ecx, DWORD PTR ?y@@3HA                  ; y<br/>        call    ?g@@YAHH@Z                              ; g<br/><br/>; compute i &lt; g(y) and leave result in eax:<br/><br/>        cmp     DWORD PTR ?i@@3HA, eax<br/>        jge     SHORT $LN5@main<br/>        mov     DWORD PTR tv67[rsp], 1<br/>        jmp     SHORT $LN6@main<br/>$LN5@main:<br/>        mov     DWORD PTR tv67[rsp], 0<br/><br/>$LN6@main:<br/><br/>; temp2 = k &gt; f(x);<br/><br/>        mov     ecx, DWORD PTR ?x@@3HA                  ; x<br/>        call    ?f@@YAHH@Z                              ; f<br/><br/>; compute k &gt; f(x) and leave result in eax:<br/><br/>        cmp     DWORD PTR ?k@@3HA, eax<br/>        jle     SHORT $LN7@main<br/><span epub:type="pagebreak" id="page_515"/>        mov     DWORD PTR tv71[rsp], 1<br/>        jmp     SHORT $LN8@main<br/>$LN7@main:<br/>        mov     DWORD PTR tv71[rsp], 0<br/>$LN8@main:<br/><br/>; if( !temp &amp;&amp; !temp2 ) break;<br/><br/>        or      ecx, eax<br/>        mov     eax, ecx<br/>        test    eax, eax<br/>        je      SHORT $LN3@main<br/>; Line 23<br/>        lea     rcx, OFFSET FLAT:$SG6924<br/>        call    printf<br/><br/>; Jump back to beginning of for(;;) loop.<br/>;<br/>; Line 24<br/>        jmp     SHORT $LN2@main<br/><br/>$LN3@main:<br/>; Line 26<br/>        xor     eax, eax<br/>; Line 27<br/>        add     rsp, 56                                 ; 00000038H<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">As you can see, this program always evaluates both parts of the original Boolean expression (that is, you get complete Boolean evaluation).</p>&#13;
		<p class="indent">You should be careful using unstructured code in this way. Not only is the result harder to read, but it’s difficult to coerce the compiler into producing the code you want. Furthermore, code sequences that produce good code on one compiler won’t produce comparable code on other compilers.</p>&#13;
		<p class="indent">If your particular language doesn’t support a statement like <span class="literal">break</span>, you can always use a <span class="literal">goto</span> statement to break out of the loop and achieve the same result. Although injecting <span class="literal">goto</span>s into your code isn’t a great idea, in some cases it’s your only option.</p>&#13;
		<h4 class="h4" id="ch00lev2sec177"><strong>14.1.2 Forcing Short-Circuit Boolean Evaluation in a while Loop</strong></h4>&#13;
		<p class="noindent">Sometimes you need to guarantee short-circuit evaluation of the Boolean expression in a <span class="literal">while</span> statement even if the language (such as BASIC or Pascal) doesn’t implement that scheme. For the <span class="literal">if</span> statement, you can force short-circuit evaluation by rearranging the way you compute the loop-control expression in your program. Unlike in the <span class="literal">if</span> statement, you can’t use nested <span class="literal">while</span> statements or preface your <span class="literal">while</span> loop with other statements to force short-circuit evaluation, but it’s still possible to do in most programming languages.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_516"/>Consider the following C code fragment:</p>&#13;
		<pre class="programs">&#13;
			while( ptr != NULL &amp;&amp; ptr-&gt;data != 0 )<br/>{<br/>    &lt;&lt; loop body &gt;&gt;<br/>    ptr = ptr-&gt;Next; // Step through a linked list.<br/>}</pre>&#13;
		<p class="indent">This code could fail if C didn’t guarantee short-circuit evaluation of the Boolean expression.</p>&#13;
		<p class="indent">As with forcing complete Boolean evaluation, the easiest approach in a language like Pascal is to write a function that computes and returns the Boolean result using short-circuit Boolean evaluation. However, this scheme is relatively slow because of the high overhead of a function call. Consider the following Pascal example:<sup><a id="ch14fn_2"/><a href="footnotes.xhtml#ch14fn2">2</a></sup></p>&#13;
		<pre class="programs">&#13;
			program shortcircuit;<br/>{$APPTYPE CONSOLE}<br/>uses SysUtils;<br/>var<br/>    ptr     :Pchar;<br/><br/>    function shortCir( thePtr:Pchar ):boolean;<br/>    begin<br/><br/>        shortCir := false;<br/>        if( thePtr &lt;&gt; NIL ) then begin<br/><br/>            shortCir := thePtr^ &lt;&gt; #0;<br/><br/>        end; //if<br/><br/>    end;  // shortCircuit<br/><br/>begin<br/><br/>    ptr := 'Hello world';<br/>    while( shortCir( ptr )) do begin<br/><br/>        write( ptr^ );<br/>        inc( ptr );<br/><br/>    end; // while<br/>    writeln;<br/><br/>end.</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_517"/>And now consider this 80x86 assembly code produced by Borland’s Delphi compiler (and disassembled with IDAPro):</p>&#13;
		<pre class="programs">&#13;
			; function shortCir( thePtr:Pchar ):boolean<br/>;<br/>; Note: thePtr is passed into this function in<br/>; the EAX register.<br/><br/>sub_408570  proc near<br/><br/>            ; EDX holds function return<br/>            ; result (assume false).<br/>            ;<br/>            ; shortCir := false;<br/><br/>            xor     edx, edx<br/><br/>            ; if( thePtr &lt;&gt; NIL ) then begin<br/><br/>            test    eax, eax<br/>            jz      short loc_40857C    ; branch if NIL<br/><br/>            ; shortCir := thePtr^ &lt;&gt; #0;<br/><br/>            cmp     byte ptr [eax], 0<br/>            setnz   dl  ; DL = 1 if not #0<br/><br/>loc_40857C:<br/><br/>            ; Return result in EAX:<br/><br/>            mov     eax, edx<br/>            retn<br/>sub_408570  endp<br/><br/><br/><br/>; Main program (pertinent section):<br/>;<br/>; Load EBX with the address of the global "ptr" variable and<br/>; then enter the "while" loop (Delphi moves the test for the<br/>; while loop to the physical end of the loop's body):<br/><br/>                mov     ebx, offset loc_408628<br/>                jmp     short loc_408617<br/>; --------------------------------------------------------<br/><br/>loc_408600:<br/>                ; Print the current character whose address<br/>                ; "ptr" contains:<br/><br/>                mov     eax, ds:off_4092EC  ; ptr pointer<br/>                mov     dl, [ebx]           ; fetch char<br/>                call    sub_404523          ; print char<br/><span epub:type="pagebreak" id="page_518"/>                call    sub_404391<br/>                call    sub_402600<br/><br/>                inc     ebx                 ; inc( ptr )<br/><br/>; while( shortCir( ptr )) do ...<br/><br/>loc_408617:<br/>                mov     eax, ebx         ; Pass ptr in EAX<br/>                call    sub_408570       ; shortCir<br/>                test    al, al           ; Returns true/false<br/>                jnz     short loc_408600 ; branch if true</pre>&#13;
		<p class="indent">The <span class="literal">sub_408570</span> procedure contains the function that will compute the short-circuit Boolean evaluation of an expression similar to the one appearing in the earlier C code. As you can see, the code that dereferences <span class="literal">thePtr</span> never executes if <span class="literal">thePtr</span> contains NIL (<span class="literal">0</span>).</p>&#13;
		<p class="indent">If a function call is out of the question, then about the only reasonable solution is to use an unstructured approach. The following is a Pascal version of the <span class="literal">while</span> loop in the earlier C code that forces short-circuit Boolean evaluation:</p>&#13;
		<pre class="programs">&#13;
			    while( true ) do begin<br/><br/>        if( ptr = NIL ) then goto 2;<br/>        if( ptr^.data = 0 ) then goto 2;<br/>        &lt;&lt; loop body &gt;&gt;<br/>        ptr := ptr^.Next;<br/><br/>    end;<br/>2:</pre>&#13;
		<p class="indent">Again, producing unstructured code, like the code in this example, is something you should do only as a last resort. But if the language (or compiler) you’re using doesn’t guarantee short-circuit evaluation and you need those semantics, unstructured code or inefficient code (using a function call) might be the only solution.</p>&#13;
		<h3 class="h3" id="ch00lev1sec116"><strong>14.2 The repeat..until (do..until/do..while) Loop</strong></h3>&#13;
		<p class="noindent">Another common loop that appears in most modern programming languages is <span class="literal">repeat..until</span>. This loop tests for its terminating condition at the bottom of the loop. This means that the loop’s body always executes at least once, even if the Boolean control expression evaluates to <span class="literal">false</span> on the first iteration of the loop. Although the <span class="literal">repeat..until</span> loop is a little less broadly applicable than the <span class="literal">while</span> loop, and you won’t use it anywhere near as often, there are many situations where the <span class="literal">repeat..until</span> loop is the best choice of control structure for the job. Perhaps the classic example is reading input <span epub:type="pagebreak" id="page_519"/>from the user until the user inputs a certain value. The following Pascal code fragment is very typical:</p>&#13;
		<pre class="programs">&#13;
			repeat<br/><br/>      write( 'Enter a value (negative quits): ');<br/>      readln( i );<br/>      // do something with i's value<br/><br/>until( i &lt; 0 );</pre>&#13;
		<p class="indent">This loop always executes the body once. This, of course, is necessary because you must execute the loop’s body to read the user-entered value, which the program checks to determine when loop execution is complete.</p>&#13;
		<p class="indent">The <span class="literal">repeat..until</span> loop terminates when its Boolean control expression evaluates to <span class="literal">true</span> (rather than <span class="literal">false</span>, as for the <span class="literal">while</span> loop), as implied by the word <em>until</em>. Note, however, that this is a minor syntactical issue; the C/C++/Java/Swift languages (and many languages that share a C heritage) provide a <span class="literal">do..while</span> loop that repeats execution of the loop’s body as long as the loop condition evaluates to <span class="literal">true</span>. From an efficiency point of view, there’s absolutely no difference between these two loops, and you can easily convert one loop termination condition to the other by using your language’s logical NOT operator. The following examples demonstrate the syntax of the Pascal, HLA, and C/C++ <span class="literal">repeat..until</span> and <span class="literal">do..while</span> loops. Here’s the Pascal <span class="literal">repeat..until</span> loop example:</p>&#13;
		<pre class="programs">&#13;
			repeat<br/><br/>    (* Read a raw character from the "input" file, which in this case is the keyboard *)<br/><br/>    ch := rawInput( input );<br/><br/>    (* Save the character away. *)<br/><br/>    inputArray[ i ] := ch;<br/>    i := i + 1;<br/><br/>    (* Repeat until the user hits the enter key *)<br/><br/>until( ch = chr( 13 ));</pre>&#13;
		<p class="indent">Now here’s the C/C++ <span class="literal">do..while</span> version of the same loop:</p>&#13;
		<pre class="programs">&#13;
			do<br/>{<br/>    /* Read a raw character from the "input" file, which in this case is the keyboard */<br/><br/>    ch = getKbd();<br/><br/>    /* Save the character away. */<br/><span epub:type="pagebreak" id="page_520"/><br/>    inputArray[ i++ ] = ch;<br/><br/>    /* Repeat until the user hits the enter key */<br/>}<br/>while( ch != '\r' );</pre>&#13;
		<p class="indent">And here is the HLA <span class="literal">repeat..until</span> loop:</p>&#13;
		<pre class="programs">&#13;
			repeat<br/><br/>    // Read a character from the standard input device.<br/><br/>    stdin.getc();<br/><br/>    // Save the character away.<br/><br/>    mov( al, inputArray[ ebx ] );<br/>    inc( ebx );<br/><br/>    // Repeat until the user hits the enter key.<br/><br/>until( al = stdio.cr );</pre>&#13;
		<p class="indent">Converting the <span class="literal">repeat..until</span> (or <span class="literal">do..while</span>) loop into assembly language is relatively easy and straightforward. All the compiler needs to do is substitute code for the Boolean loop control expression and branch back to the beginning of the loop’s body if the expression evaluates affirmative (<span class="literal">false</span> for <span class="literal">repeat..until</span> or <span class="literal">true</span> for <span class="literal">do..while</span>). Here’s the straightforward pure assembly implementation of the earlier HLA <span class="literal">repeat..until</span> loop (compilers for C/C++ and Pascal would generate nearly identical code for the other examples):</p>&#13;
		<pre class="programs">&#13;
			rptLoop:<br/><br/>    // Read a character from the standard input.<br/><br/>    call stdin.getc;<br/><br/>    // Store away the character.<br/><br/>    mov( al, inputArray[ ebx ] );<br/>    inc( ebx );<br/><br/>    // Repeat the loop if the user did not hit<br/>    // the enter key.<br/><br/>    cmp( al, stdio.cr );<br/>    jne rptLoop;</pre>&#13;
		<p class="indent">As you can see, the code that a typical compiler generates for a <span class="literal">repeat..until</span> (or <span class="literal">do..while</span>) loop is usually a bit more efficient than the code you’ll get for a regular <span class="literal">while</span> loop. Thus, you should consider using <span epub:type="pagebreak" id="page_521"/>the <span class="literal">repeat..until</span>/<span class="literal">do..while</span> form if semantically possible. In many programs, the Boolean control expression always evaluates to <span class="literal">true</span> on the first iteration of some loop constructs. For example, it’s not that uncommon to find a loop like the following in an application:</p>&#13;
		<pre class="programs">&#13;
			i = 0;<br/>while( i &lt; 100 )<br/>{<br/>      printf( "i: %d\n", i );<br/>      i = i * 2 + 1;<br/>      if( i &lt; 50 )<br/>      {<br/>            i += j;<br/>      }<br/>}</pre>&#13;
		<p class="indent">This <span class="literal">while</span> loop is easily converted to a <span class="literal">do..while</span> loop as follows:</p>&#13;
		<pre class="programs">&#13;
			i = 0;<br/>do<br/>{<br/>      printf( "i: %d\n", i );<br/>      i = i * 2 + 1;<br/>      if( i &lt; 50 )<br/>      {<br/>            i += j;<br/>      }<br/>} while( i &lt; 100 );</pre>&#13;
		<p class="indent">This conversion is possible because we know that <span class="literal">i</span>’s initial value (<span class="literal">0</span>) is less than <span class="literal">100</span>, so the loop’s body always executes at least once.</p>&#13;
		<p class="indent">As you’ve seen, you can help the compiler generate better code by using the more appropriate <span class="literal">repeat..until</span>/<span class="literal">do..while</span> loop rather than a regular <span class="literal">while</span> loop. Keep in mind, however, that the efficiency gain is small, so make sure you’re not sacrificing readability or maintainability by doing so. Always use the most logically appropriate loop construct. If the body of the loop always executes at least once, you should use a <span class="literal">repeat..until</span>/<span class="literal">do..while</span> loop, even if a <span class="literal">while</span> loop would work equally well.</p>&#13;
		<h4 class="h4" id="ch00lev2sec178"><strong>14.2.1 Forcing Complete Boolean Evaluation in a repeat..until Loop</strong></h4>&#13;
		<p class="noindent">Because the test for loop termination occurs at the bottom of the loop on a <span class="literal">repeat..until</span> (or <span class="literal">do..while</span>) loop, you force complete Boolean evaluation for it, similarly to how you do for an <span class="literal">if</span> statement. Consider the following C/C++ code:</p>&#13;
		<pre class="programs">&#13;
			extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/>extern int a;<br/><span epub:type="pagebreak" id="page_522"/>extern int b;<br/>int main( void )<br/>{<br/><br/>    do<br/>        {<br/>            ++a;<br/>            --b;<br/>        }while( a &lt; f(x) &amp;&amp; b &gt; g(y));<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the GCC output for the PowerPC (using short-circuit evaluation, which is standard for C) for the <span class="literal">do..while</span> loop:</p>&#13;
		<pre class="programs">&#13;
			L2:<br/>        // ++a<br/>        // --b<br/><br/>        lwz r9,0(r30)  ; get a<br/>        lwz r11,0(r29) ; get b<br/>        addi r9,r9,-1  ; --a<br/>        lwz r3,0(r27)  ; Set up x parm for f<br/>        stw r9,0(r30)  ; store back into a<br/>        addi r11,r11,1 ; ++b<br/>        stw r11,0(r29) ; store back into b<br/><br/>        ; compute f(x)<br/><br/>        bl L_f$stub    ; call f, result to R3<br/><br/>        ; is a &gt;= f(x)? If so, quit loop<br/><br/>        lwz r0,0(r29)  ; get a<br/>        cmpw cr0,r0,r3 ; Compare a with f's value<br/>        bge- cr0,L3<br/><br/>        lwz r3,0(r28)  ; Set up y parm for g<br/>        bl L_g$stub    ; call g<br/><br/>        lwz r0,0(r30)  ; get b<br/>        cmpw cr0,r0,r3 ; Compare b with g's value<br/>        bgt+ cr0,L2    ; Repeat if b &gt; g's value<br/>L3:</pre>&#13;
		<p class="indent">This program skips over the test for <span class="literal">b &gt; g(y)</span> to label <span class="literal">L3</span> if the expression <span class="literal">a &lt; f(x)</span> is <span class="literal">false</span> (that is, if <span class="literal">a &gt;= f(x)</span>).</p>&#13;
		<p class="indent">To force complete Boolean evaluation in this situation, our C source code needs to compute the subcomponents of the Boolean expression just <span epub:type="pagebreak" id="page_523"/>prior to the <span class="literal">while</span> clause (keeping the results of the subexpressions in temporary variables) and then test only the results in the <span class="literal">while</span> clause:</p>&#13;
		<pre class="programs">&#13;
			static int a;<br/>static int b;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    int temp1;<br/>    int temp2;<br/><br/>    do<br/>        {<br/>            ++a;<br/>            --b;<br/>            temp1 = a &lt; f(x);<br/>            temp2 = b &gt; g(y);<br/>        }while( temp1 &amp;&amp; temp2 );<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the conversion to PowerPC code by GCC:</p>&#13;
		<pre class="programs">&#13;
			L2:<br/>        lwz r9,0(r30)    ; r9 = b<br/>        li r28,1         ; temp1 = true<br/>        lwz r11,0(r29)   ; r11 = a<br/>        addi r9,r9,-1    ; --b<br/>        lwz r3,0(r26)    ; r3 = x (set up f's parm)<br/>        stw r9,0(r30)    ; Save b<br/>        addi r11,r11,1   ; ++a<br/>        stw r11,0(r29)   ; Save a<br/>        bl L_f$stub      ; Call f<br/>        lwz r0,0(r29)    ; Fetch a<br/>        cmpw cr0,r0,r3   ; Compute temp1 = a &lt; f(x)<br/>        blt- cr0,L5      ; Leave temp1 true if a &lt; f(x)<br/>        li r28,0         ; temp1 = false<br/>L5:<br/>        lwz r3,0(r27)    ; r3 = y, set up g's parm<br/>        bl L_g$stub      ; Call g<br/>        li r9,1          ; temp2 = true<br/>        lwz r0,0(r30)    ; Fetch b<br/>        cmpw cr0,r0,r3   ; Compute b &gt; g(y)<br/>        bgt- cr0,L4      ; Leave temp2 true if b &gt; g(y)<br/>        li r9,0          ; Else set temp2 false<br/>L4:<br/><span epub:type="pagebreak" id="page_524"/>        ; Here's the actual termination test in<br/>        ; the while clause:<br/><br/>        cmpwi cr0,r28,0<br/>        beq- cr0,L3<br/>        cmpwi cr0,r9,0<br/>        bne+ cr0,L2<br/>L3:</pre>&#13;
		<p class="indent">Of course, the actual Boolean expression (<span class="literal">temp1 &amp;&amp; temp2</span>) still uses short-circuit evaluation, but only for the temporary variables created. The loop computes both of the original subexpressions regardless of the result of the first one.</p>&#13;
		<h4 class="h4" id="ch00lev2sec179"><strong>14.2.2 Forcing Short-Circuit Boolean Evaluation in a repeat..until Loop</strong></h4>&#13;
		<p class="noindent">If your programming language provides a facility to break out of a <span class="literal">repeat..until</span> loop, such as C’s <span class="literal">break</span> statement, then forcing short-circuit evaluation is fairly easy. Consider the C <span class="literal">do..while</span> loop from the previous section that forces complete Boolean evaluation:</p>&#13;
		<pre class="programs">&#13;
			do<br/>{<br/>    ++a;<br/>    --b;<br/>    temp1 = a &lt; f(x);<br/>    temp2 = b &gt; g(y);<br/><br/>}while( temp1 &amp;&amp; temp2 );</pre>&#13;
		<p class="indent">The following shows one way to convert this code so that it evaluates the termination expression using short-circuit Boolean evaluation:</p>&#13;
		<pre class="programs">&#13;
			static int a;<br/>static int b;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    do<br/>    {<br/>        ++a;<br/>        --b;<br/><br/>        if( !( a &lt; f(x) )) break;<br/>    } while( b &gt; g(y) );<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_525"/>Here’s the code that GCC emits for the PowerPC for the <span class="literal">do..while</span> loop in this code sequence:</p>&#13;
		<pre class="programs">&#13;
			L2:<br/>        lwz r9,0(r30)   ; r9 = b<br/>        lwz r11,0(r29)  ; r11 = a<br/>        addi r9,r9,-1   ; --b<br/>        lwz r3,0(r27)   ; Set up f(x) parm<br/>        stw r9,0(r30)   ; Save b<br/>        addi r11,r11,1  ; ++a<br/>        stw r11,0(r29)  ; Save a<br/>        bl L_f$stub     ; Call f<br/><br/>        ; break if !(a &lt; f(x)):<br/><br/>        lwz r0,0(r29)<br/>        cmpw cr0,r0,r3<br/>        bge- cr0,L3<br/><br/>        ; while( b &gt; g(y) ):<br/><br/>        lwz r3,0(r28)   ; Set up y parm<br/>        bl L_g$stub     ; Call g<br/>        lwz r0,0(r30)   ; Compute b &gt; g(y)<br/>        cmpw cr0,r0,r3<br/>        bgt+ cr0,L2     ; Branch if true<br/>L3:</pre>&#13;
		<p class="indent">If <span class="literal">a</span> is greater than or equal to the value that <span class="literal">f(x)</span> returns, this code immediately breaks out of the loop (at label <span class="literal">L3</span>) without testing to see if <span class="literal">b</span> is greater than the value <span class="literal">g(y)</span> returns. Hence, this code simulates short-circuit Boolean evaluation of the C/C++ expression <span class="literal">a &lt; f(x) &amp;&amp; b &gt; g(y)</span>.</p>&#13;
		<p class="indent">If the compiler you’re using doesn’t support a statement equivalent to C/C++’s <span class="literal">break</span> statement, you’ll have to use slightly more sophisticated logic. Here’s one way to do that:</p>&#13;
		<pre class="programs">&#13;
			static int a;<br/>static int b;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    int temp;<br/><br/>    do<br/>    {<br/>        ++a;<br/>        --b;<br/><span epub:type="pagebreak" id="page_526"/>        temp = a &lt; f(x);<br/>        if( temp )<br/>        {<br/>            temp = b &gt; g(y);<br/>        };<br/>    }while( temp );<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">And here’s the PowerPC code that GCC produces for this example:</p>&#13;
		<pre class="programs">&#13;
			L2:<br/>        lwz r9,0(r30)   ; r9 = b<br/>        lwz r11,0(r29)  ; r11 = a<br/>        addi r9,r9,-1   ; --b<br/>        lwz r3,0(r27)   ; Set up f(x) parm<br/>        stw r9,0(r30)   ; Save b<br/>        addi r11,r11,1  ; ++a<br/>        stw r11,0(r29)  ; Save a<br/>        bl L_f$stub     ; Call f<br/>        li r9,1         ; Assume temp is true<br/>        lwz r0,0(r29)   ; Set temp false if<br/>        cmpw cr0,r0,r3  ; a &lt; f(x)<br/>        blt- cr0,L5<br/>        li r9,0<br/>L5:<br/>        cmpwi cr0,r9,0  ; If !(a &lt; f(x)) then bail<br/>        beq- cr0,L10    ; on the do..while loop<br/>        lwz r3,0(r28)   ; Compute temp = b &gt; f(y)<br/>        bl L_g$stub     ; using a code sequence<br/>        li r9,1         ; that is comparable to<br/>        lwz r0,0(r30)   ; the above.<br/>        cmpw cr0,r0,r3<br/>        bgt- cr0,L9<br/>        li r9,0<br/>L9:<br/>        ; Test the while termination expression:<br/><br/>        cmpwi cr0,r9,0<br/>        bne+ cr0,L2<br/>L10:</pre>&#13;
		<p class="indent">Although these examples have been using the conjunction operation (logical AND), using the disjunction operator (logical OR) is just as easy. To close off this section, consider this Pascal sequence and its conversion:</p>&#13;
		<pre class="programs">&#13;
			repeat<br/><br/>      a := a + 1;<br/>      b := b - 1;<br/><br/>until( (a &lt; f(x)) OR (b &gt; g(y)) );</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_527"/>Here’s the conversion to force complete Boolean evaluation:</p>&#13;
		<pre class="programs">&#13;
			repeat<br/><br/>      a := a + 1;<br/>      b := b - 1;<br/>      temp := a &lt; f(x);<br/>      if( not temp ) then begin<br/><br/>            temp := b &gt; g(y);<br/><br/>    end;<br/>until( temp );</pre>&#13;
		<p class="indent">Here’s the code that Borland’s Delphi produces for the two loops (assuming you select <em>complete Boolean evaluation</em> in the compiler’s options):</p>&#13;
		<pre class="programs">&#13;
			;    repeat<br/>;<br/>;        a := a + 1;<br/>;        b := b - 1;<br/>;<br/>;    until( (a &lt; f(x)) or (b &gt; g(y)));<br/><br/>loc_4085F8:<br/>                inc     ebx                  ; a := a + 1;<br/>                dec     esi                  ; b := b - 1;<br/>                mov     eax, [edi]           ; EDI points at x<br/>                call    locret_408570<br/>                cmp     ebx, eax             ; Set AL to 1 if<br/>                setl    al                   ; a &lt; f(x)<br/>                push    eax                  ; Save Boolean result.<br/><br/>                mov     eax, ds:dword_409288 ; y<br/>                call    locret_408574        ; g(6)<br/><br/>                cmp     esi, eax             ; Set AL to 1 if<br/>                setnle  al                   ; b &gt; g(y)<br/>                pop     edx                  ; Retrieve last value.<br/>                or      dl, al               ; Compute their OR<br/>                jz      short loc_4085F8     ; Repeat if false.<br/><br/>;    repeat<br/>;<br/>;        a := a + 1;<br/>;        b := b - 1;<br/>;        temp := a &lt; f(x);<br/>;        if( not temp ) then begin<br/>;<br/>;            temp := b &gt; g(y);<br/>;<br/>;        end;<br/>;<br/>;    until( temp );<br/><span epub:type="pagebreak" id="page_528"/>loc_40861B:<br/>                inc     ebx                  ; a := a + 1;<br/>                dec     esi                  ; b := b - 1;<br/>                mov     eax, [edi]           ; Fetch x<br/>                call    locret_408570        ; call f<br/>                cmp     ebx, eax             ; is a &lt; f(x)?<br/>                setl    al                   ; Set AL to 1 if so.<br/><br/>            ; If the result of the above calculation is<br/>            ; true, then don't bother with the second<br/>            ; test (that is, short-circuit evaluation)<br/><br/>                test    al, al<br/>                jnz     short loc_40863C<br/><br/>            ; Now check to see if b &gt; g(y)<br/><br/>                mov     eax, ds:dword_409288<br/>                call    locret_408574<br/><br/>            ; Set AL = 1 if b &gt; g(y):<br/><br/>                cmp     esi, eax<br/>                setnle  al<br/><br/>; Repeat loop if both conditions were false:<br/><br/>loc_40863C:<br/>                test    al, al<br/>                jz      short loc_40861B</pre>&#13;
		<p class="indent">The code that the Delphi compiler generates for this forced short-circuit evaluation is nowhere near as good as the code it would generate if you allowed it to do this job for you. Here’s the Delphi code with the <em>complete Boolean evaluation</em> option unselected (that is, instructing Delphi to use short-circuit evaluation):</p>&#13;
		<pre class="programs">&#13;
			loc_4085F8:<br/>                inc     ebx<br/>                dec     esi<br/>                mov     eax, [edi]<br/>                call    nullsub_1 ;f<br/>                cmp     ebx, eax<br/>                jl      short loc_408613<br/>                mov     eax, ds:dword_409288<br/>                call    nullsub_2 ;g<br/>                cmp     esi, eax<br/>                jle     short loc_4085F8</pre>&#13;
		<p class="indent">While this trick is useful for forcing short-circuit evaluation when the compiler does not support it, this latter Delphi example reiterates that you should use the compiler’s facilities if at all possible—you’ll generally get better machine code.</p>&#13;
		<h3 class="h3" id="ch00lev1sec117"><span epub:type="pagebreak" id="page_529"/><strong>14.3 The forever..endfor Loop</strong></h3>&#13;
		<p class="noindent">The <span class="literal">while</span> loop tests for loop termination at the beginning (top) of the loop. The <span class="literal">repeat..until</span> loop tests for loop termination at the end (bottom) of the loop. The only place left to test for loop termination is somewhere in the middle of the loop’s body. The <span class="literal">forever..endfor</span> loop, along with some special loop termination statements, handles this case.</p>&#13;
		<p class="indent">Most modern programming languages provide a <span class="literal">while</span> loop and a <span class="literal">repeat..until</span> loop (or their equivalents). Interestingly enough, only a few modern imperative programming languages provide an explicit <span class="literal">forever..endfor</span> loop.<sup><a id="ch14fn_3"/><a href="footnotes.xhtml#ch14fn3">3</a></sup> This is especially surprising because the <span class="literal">forever..endfor</span> loop (along with a loop termination test) is actually the most general of the three forms. You can easily synthesize a <span class="literal">while</span> loop or a <span class="literal">repeat..until</span> loop from a single <span class="literal">forever..endfor</span> loop.</p>&#13;
		<p class="indent">Fortunately, it’s easy to create a simple <span class="literal">forever..endfor</span> loop in any language that provides a <span class="literal">while</span> loop or a <span class="literal">repeat..until</span>/<span class="literal">do..while</span> loop. All you need do is supply a Boolean control expression that always evaluates to <span class="literal">false</span> for <span class="literal">repeat..until</span> or <span class="literal">true</span> for <span class="literal">do..while</span>. In Pascal, for example, you could use code such as the following:</p>&#13;
		<pre class="programs">&#13;
			const<br/>    forever = true;<br/>        .<br/>        .<br/>        .<br/>    while( forever ) do begin<br/><br/>        &lt;&lt; code to execute in an infinite loop &gt;&gt;<br/><br/>    end;</pre>&#13;
		<p class="indent">The big problem with standard Pascal is that it doesn’t provide a mechanism (other than a generic <span class="literal">goto</span> statement) for explicitly breaking out of a loop. Fortunately, many modern Pascals, like Delphi and Free Pascal, provide a statement like <span class="literal">break</span> to immediately exit the current loop.</p>&#13;
		<p class="indent">Although the C/C++ language does not provide an explicit statement that creates a <span class="literal">forever</span> loop, the syntactically bizarre <span class="literal">for(;;)</span> statement has served this purpose since the very first C compiler was written. Therefore, C/C++ programmers can create a <span class="literal">forever..endfor</span> loop as follows:</p>&#13;
		<pre class="programs">&#13;
			for(;;)<br/>{<br/>    &lt;&lt; code to execute in an infinite loop &gt;&gt;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_530"/>C/C++ programmers can use C’s <span class="literal">break</span> statement (along with an <span class="literal">if</span> statement) to place a loop termination condition in the middle of a loop, like so:</p>&#13;
		<pre class="programs">&#13;
			for(;;)<br/>{<br/>    &lt;&lt; Code to execute (at least once)<br/>       prior to the termination test &gt;&gt;<br/><br/>    if( <span class="codeitalic1">termination_expression</span> ) break;<br/><br/>    &lt;&lt; Code to execute after the loop termination test &gt;&gt;<br/>}</pre>&#13;
		<p class="indent">The HLA language provides an explicit (high-level) <span class="literal">forever..endfor</span> statement (along with a <span class="literal">break</span> and a <span class="literal">breakif</span> statement) that lets you terminate the loop somewhere in the middle. This HLA <span class="literal">forever..endfor</span> loop tests for loop termination in the middle of the loop:</p>&#13;
		<pre class="programs">&#13;
			forever<br/><br/>    &lt;&lt; Code to execute (at least once) prior to<br/>       the termination test &gt;&gt;<br/><br/>    breakif( termination_expression );<br/><br/>    &lt;&lt; Code to execute after the loop termination test &gt;&gt;<br/><br/>endfor;</pre>&#13;
		<p class="indent">Converting a <span class="literal">forever..endfor</span> loop into pure assembly language is trivial—all you need is a single <span class="literal">jmp</span> instruction that can transfer control from the bottom of the loop back to the top of the loop. The implementation of the <span class="literal">break</span> statement is just as simple: it’s just a jump (or conditional jump) to the first statement following the loop. The following two code fragments demonstrate an HLA <span class="literal">forever..endfor</span> loop (along with a <span class="literal">breakif</span>) and the corresponding “pure” assembly code:</p>&#13;
		<pre class="programs">&#13;
			// High-level forever statement in HLA:<br/><br/>forever<br/><br/>    stdout.put<br/>    (<br/>     "Enter an unsigned integer less than five:"<br/>    );<br/>    stdin.get( u );<br/>    breakif( u &lt; 5);<br/>    stdout.put<br/>    (<br/>      "Error: the value must be between zero and five" nl<br/>    );<br/><span epub:type="pagebreak" id="page_531"/>endfor;<br/><br/>// Low-level coding of the forever loop in HLA:<br/><br/>foreverLabel:<br/>    stdout.put<br/>    (<br/>      "Enter an unsigned integer less than five:"<br/>    );<br/>    stdin.get( u );<br/>    cmp( u, 5 );<br/>    jbe endForeverLabel;<br/>    stdout.put<br/>    (<br/>      "Error: the value must be between zero and five" nl<br/>    );<br/>    jmp foreverLabel;<br/><br/>endForeverLabel:</pre>&#13;
		<p class="indent">Of course, you can also rotate this code to create a slightly more efficient version:</p>&#13;
		<pre class="programs">&#13;
			// Low-level coding of the forever loop in HLA<br/>// using code rotation:<br/><br/>jmp foreverEnter;<br/>foreverLabel:<br/>        stdout.put<br/>        (<br/>          "Error: the value must be between zero and five"<br/>          nl<br/>        );<br/>    foreverEnter:<br/>        stdout.put<br/>        (<br/>          "Enter an unsigned integer less "<br/>          "than five:"<br/>        );<br/>        stdin.get( u );<br/>        cmp( u, 5 );<br/>        ja foreverLabel;</pre>&#13;
		<p class="indent">If the language you’re using doesn’t support a <span class="literal">forever..endfor</span> loop, any decent compiler will convert a <span class="literal">while(true)</span> statement into a single jump instruction. If your compiler doesn’t do so, then it does a poor job of optimization, and any attempts to manually optimize the code are a lost cause. For reasons you’ll soon see, you shouldn’t try to create the <span class="literal">forever..endfor</span> loop using a <span class="literal">goto</span> statement.</p>&#13;
		<h4 class="h4" id="ch00lev2sec180"><span epub:type="pagebreak" id="page_532"/><strong>14.3.1 Forcing Complete Boolean Evaluation in a forever Loop</strong></h4>&#13;
		<p class="noindent">Because you exit from a <span class="literal">forever</span> loop using an <span class="literal">if</span> statement, the techniques for forcing complete Boolean evaluation when exiting a <span class="literal">forever</span> loop are the same as for an <span class="literal">if</span> statement. See “Forcing Complete Boolean Evaluation in an <span class="literal">if</span> Statement” on <a href="ch13.xhtml#page_465">page 465</a> for details.</p>&#13;
		<h4 class="h4" id="ch00lev2sec181"><strong>14.3.2 Forcing Short-Circuit Boolean Evaluation in a forever Loop</strong></h4>&#13;
		<p class="noindent">Likewise, because you exit from a <span class="literal">forever</span> loop using an <span class="literal">if</span> statement, the techniques for forcing short-circuit Boolean evaluation when exiting a <span class="literal">forever</span> loop are the same as for a <span class="literal">repeat..until</span> statement. See “Forcing Short-Circuit Boolean Evaluation in a <span class="literal">repeat..until</span> Loop” on <a href="ch14.xhtml#page_524">page 524</a> for details.</p>&#13;
		<h3 class="h3" id="ch00lev1sec118"><strong>14.4 The Definite Loop (for Loops)</strong></h3>&#13;
		<p class="noindent">The <span class="literal">forever..endfor</span> loop is an <em>infinite</em> loop (assuming you don’t break out of it via a <span class="literal">break</span> statement). The <span class="literal">while</span> and <span class="literal">repeat..until</span> loops are examples of <em>indefinite</em> loops because, in general, the program cannot determine how many iterations they will execute when it first encounters them. For a <em>definite</em> loop, on the other hand, the program can determine exactly how many iterations the loop will repeat prior to executing the first statement of the loop’s body. A good example of a definite loop in a traditional HLL is Pascal’s <span class="literal">for</span> loop, which uses the following syntax:</p>&#13;
		<pre class="programs">&#13;
			for <span class="codeitalic1">variable</span> := <span class="codeitalic1">expr1</span> to <span class="codeitalic1">expr2</span> do<br/>        <span class="codeitalic1">statement</span></pre>&#13;
		<p class="noindent">which iterates over the range <span class="literal"><span class="codeitalic1">expr1..expr2</span></span> if <span class="codeitalic">expr1</span> is less than or equal to <span class="codeitalic">expr2</span>, or</p>&#13;
		<pre class="programs">&#13;
			for <span class="codeitalic1">variable</span> := <span class="codeitalic1">expr1</span> downto <span class="codeitalic1">expr2</span> do<br/>        <span class="codeitalic1">statement</span></pre>&#13;
		<p class="noindent">which iterates over the range <span class="literal"><span class="codeitalic1">expr1..expr2</span></span> if <span class="codeitalic">expr1</span> is greater than or equal to <span class="codeitalic">expr2</span>. Here’s a typical example of a Pascal <span class="literal">for</span> loop:</p>&#13;
		<pre class="programs">&#13;
			for i := 1 to 10 do<br/>    writeln( 'hello world');</pre>&#13;
		<p class="indent">This loop always executes exactly 10 times; hence, it’s a definite loop. However, this doesn’t imply that a compiler has to be able to determine the number of loop iterations at compile time. Definite loops also allow the use of expressions that force the program to determine the number of iterations at runtime. For example:</p>&#13;
		<pre class="programs">&#13;
			write( 'Enter an integer:');<br/>readln( cnt );<br/>for i := 1 to cnt do<br/>    writeln( 'Hello World');</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_533"/>The Pascal compiler cannot determine the number of iterations this loop will execute. In fact, because the number of iterations is dependent upon user input, it could vary each time this loop executes in a single execution of the enclosing program. However, the program can determine exactly how many iterations the loop will execute, indicated by the value in the <span class="literal">cnt</span> variable, whenever it encounters this loop. Note that Pascal (like most languages that support definite loops) expressly forbids code such as the following:</p>&#13;
		<pre class="programs">&#13;
			for i := 1 to j do begin<br/><br/>    &lt;&lt; some statements &gt;&gt;<br/>    i := &lt;&lt;some value&gt;&gt;;<br/>    &lt;&lt; some other statements &gt;&gt;<br/><br/>end;</pre>&#13;
		<p class="indent">You are not allowed to change the value of the loop control variable during the execution of the loop’s body. In this example, should you try to change the <span class="literal">for</span> loop’s control variable, a high-quality Pascal compiler will detect that attempt and report an error. Also, a definite loop computes the starting and ending values only once. Therefore, if the <span class="literal">for</span> loop modifies a variable that appears as the second expression, it does not reevaluate the expression on each iteration of the loop. For example, if the body of the <span class="literal">for</span> loop in the previous example modifies the value of <span class="literal">j</span>, this will not affect the number of loop iterations.<sup><a id="ch14fn_4"/><a href="footnotes.xhtml#ch14fn4">4</a></sup></p>&#13;
		<p class="indent">Definite loops have certain special properties that allow a (good) compiler to generate better machine code. In particular, because the compiler can determine how many iterations the loop will execute prior to executing the first statement of the loop’s body, the compiler can often dispense with complex tests for loop termination and simply decrement a register down to <span class="literal">0</span> to control the number of loop iterations. The compiler can also use induction to optimize access to the loop control variable in a definite loop (see the description of induction in “Optimization of Arithmetic Statements” on <a href="ch12.xhtml#page_397">page 397</a>).</p>&#13;
		<p class="indent">C/C++/Java users should note that the <span class="literal">for</span> loop in these languages is not a true definite loop; rather, it is a special case of the indefinite <span class="literal">while</span> loop. Most good C/C++ compilers will attempt to determine if a <span class="literal">for</span> loop is a definite loop and, if so, they’ll generate decent code. You can help your compiler by following these guidelines:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Your C/C++ <span class="literal">for</span> loops should use the same semantics as the definite (<span class="literal">for</span>) loops in languages such as Pascal. That is, the <span class="literal">for</span> loop should initialize a single loop control variable, test for loop termination when that value is less than or greater than some ending value, and increment or decrement the loop control variable by 1.</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_534"/>&#13;
			<p class="noindent">Your C/C++ <span class="literal">for</span> loops should not modify the value of the loop control variable within the loop.</p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">The test for loop termination remains static over the execution of the loop’s body. That is, the loop body should not be able to change the termination condition (which, by definition, would make the loop an indefinite loop). For example, if the loop termination condition is <span class="literal">i &lt; j</span>, the loop body should not modify the value of <span class="literal">i</span> or <span class="literal">j</span>.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The loop body does not pass the loop control variable or any variable appearing in the loop termination condition by reference to a function if that function modifies the actual parameter.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h3 class="h3" id="ch00lev1sec119"><strong>14.5 For More Information</strong></h3>&#13;
		<p class="noindent">“For More Information” on <a href="ch13.xhtml#page_501">page 501</a> applies to this chapter as well. Please see that section for more details.</p>&#13;
	</body></html>