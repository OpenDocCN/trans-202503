["```\n$ `./non_reentrant abc def`\n*Repeatedly type Control-C to generate* SIGINT\nMismatch on call 109871 (mismatch=1 handled=1)\nMismatch on call 128061 (mismatch=2 handled=2)\n*Many lines of output removed*\nMismatch on call 727935 (mismatch=149 handled=156)\nMismatch on call 729547 (mismatch=150 handled=157)\n*Type Control-\\ to generate* SIGQUIT\nQuit (core dumped)\n```", "```\n`signals/nonreentrant.c`\n#define _XOPEN_SOURCE 600\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include \"tlpi_hdr.h\"\n\nstatic char *str2;              /* Set from argv[2] */\nstatic int handled = 0;         /* Counts number of calls to handler */\n\nstatic void\nhandler(int sig)\n{\n\n    crypt(str2, \"xx\");\n    handled++;\n}\nint\nmain(int argc, char *argv[])\n{\n    char *cr1;\n    int callNum, mismatch;\n    struct sigaction sa;\n\n    if (argc != 3)\n        usageErr(\"%s str1 str2\\n\", argv[0]);\n\n    str2 = argv[2];                      /* Make argv[2] available to handler */\n    cr1 = strdup(crypt(argv[1], \"xx\"));  /* Copy statically allocated string\n                                            to another buffer */\n    if (cr1 == NULL)\n        errExit(\"strdup\");\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sa.sa_handler = handler;\n    if (sigaction(SIGINT, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    /* Repeatedly call crypt() using argv[1]. If interrupted by a\n       signal handler, then the static storage returned by crypt()\n       will be overwritten by the results of encrypting argv[2], and\n       strcmp() will detect a mismatch with the value in 'cr1'. */\n\n    for (callNum = 1, mismatch = 0; ; callNum++) {\n        if (strcmp(crypt(argv[1], \"xx\"), cr1) != 0) {\n            mismatch++;\n            printf(\"Mismatch on call %d (mismatch=%d handled=%d)\\n\",\n                    callNum, mismatch, handled);\n        }\n    }\n}\n     `signals/nonreentrant.c`\n```", "```\nvoid\nhandler(int sig)\n{\n    int savedErrno;\n\n    savedErrno = errno;\n\n    /* Now we can execute a function that might modify errno */\n\n    errno = savedErrno;\n}\n```", "```\nprintf(\"Some message\\n\");           /* UNSAFE */\n```", "```\nvolatile sig_atomic_t flag;\n```", "```\n#include <setjmp.h>\n\nint `sigsetjmp`(sigjmp_buf *env*, int *savesigs*);\n```", "```\nvoid `siglongjmp`(sigjmp_buf *env*, int *val*);\n```", "```\n$ `make -s sigmask_longjmp`         *Default compilation causes*\n *setjmp()* *to be used*\n$ `./sigmask_longjmp`\nSignal mask at startup:\n                <empty signal set>\nCalling setjmp()\n*Type Control-C to generate* SIGINT\nReceived signal 2 (Interrupt), signal mask is:\n                2 (Interrupt)\nAfter jump from handler, signal mask is:\n                2 (Interrupt)\n*(At this point, typing Control-C again has no effect, since* SIGINT *is blocked)*\n*Type Control-\\ to kill the program*\nQuit\n```", "```\n$ `make -s sigmask_siglongjmp`      *Compiles using* *cc -DUSE_SIGSETJMP*\n$ `./sigmask_siglongjmp`\nSignal mask at startup:\n                <empty signal set>\nCalling sigsetjmp()\n*Type Control-C*\nReceived signal 2 (Interrupt), signal mask is:\n                2 (Interrupt)\nAfter jump from handler, signal mask is:\n                <empty signal set>\n```", "```\n*Type Control-C*\nReceived signal 2 (Interrupt), signal mask is:\n                2 (Interrupt)\nAfter jump from handler, signal mask is:\n                <empty signal set>\n*Type Control-\\ to kill the program*\nQuit\n```", "```\nif (useSiglongjmp)\n    s = sigsetjmp(senv, 1);\nelse\n    s = setjmp(env);\nif (s == 0)\n    ...\n```", "```\n`signals/sigmask_longjmp.c`\n#define _GNU_SOURCE     /* Get strsignal() declaration from <string.h> */\n#include <string.h>\n#include <setjmp.h>\n#include <signal.h>\n#include \"signal_functions.h\"           /* Declaration of printSigMask() */\n#include \"tlpi_hdr.h\"\n\nstatic volatile sig_atomic_t canJump = 0;\n                        /* Set to 1 once \"env\" buffer has been\n                           initialized by [sig]setjmp() */\n#ifdef USE_SIGSETJMP\nstatic sigjmp_buf senv;\n#else\nstatic jmp_buf env;\n#endif\n\nstatic void\nhandler(int sig)\n{\n    /* UNSAFE: This handler uses non-async-signal-safe functions\n       (printf(), strsignal(), printSigMask(); see Section 21.1.2) */\n\n    printf(\"Received signal %d (%s), signal mask is:\\n\", sig,\n            strsignal(sig));\n    printSigMask(stdout, NULL);\n\n    if (!canJump) {\n        printf(\"'env' buffer not yet set, doing a simple return\\n\");\n        return;\n    }\n\n#ifdef USE_SIGSETJMP\n    siglongjmp(senv, 1);\n#else\n    longjmp(env, 1);\n#endif\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct sigaction sa;\n\n    printSigMask(stdout, \"Signal mask at startup:\\n\");\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sa.sa_handler = handler;\n    if (sigaction(SIGINT, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n#ifdef USE_SIGSETJMP\n    printf(\"Calling sigsetjmp()\\n\");\n    if (sigsetjmp(senv, 1) == 0)\n#else\n    printf(\"Calling setjmp()\\n\");\n    if (setjmp(env) == 0)\n#endif\n        canJump = 1;                    /* Executed after [sig]setjmp() */\n\n    else                                /* Executed after [sig]longjmp() */\n        printSigMask(stdout, \"After jump from handler, signal mask is:\\n\" );\n\n    for (;;)                            /* Wait for signals until killed */\n        pause();\n}\n      `signals/sigmask_longjmp.c`\n```", "```\n#include <stdlib.h>\n\nvoid `abort`(void);\n```", "```\n#include <signal.h>\n\nint `sigaltstack`(const stack_t **sigstack*, stack_t **old_sigstack*);\n```", "```\ntypedef struct {\n    void  *ss_sp;         /* Starting address of alternate stack */\n    int    ss_flags;      /* Flags: SS_ONSTACK, SS_DISABLE */\n    size_t ss_size;       /* Size of alternate stack */\n} stack_t;\n```", "```\n$ `ulimit -s unlimited`\n$ `./t_sigaltstack`\nTop of standard stack is near 0xbffff6b8\nAlternate stack is at          0x804a948-0x804cfff\nCall    1 - top of stack near 0xbff0b3ac\nCall    2 - top of stack near 0xbfe1714c\n*Many intervening lines of output removed*\nCall 2144 - top of stack near 0x4034120c\nCall 2145 - top of stack near 0x4024cfac\nCaught signal 11 (Segmentation fault)\nTop of handler stack near      0x804c860\n```", "```\n`signals/t_sigaltstack.c`\n#define _GNU_SOURCE          /* Get strsignal() declaration from <string.h> */\n#include <string.h>\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nsigsegvHandler(int sig)\n{\n    int x;\n\n    /* UNSAFE: This handler uses non-async-signal-safe functions\n       (printf(), strsignal(), fflush(); see Section 21.1.2) */\n\n    printf(\"Caught signal %d (%s)\\n\", sig, strsignal(sig));\n    printf(\"Top of handler stack near     %10p\\n\", (void *) &x);\n    fflush(NULL);\n\n    _exit(EXIT_FAILURE);                /* Can't return after SIGSEGV */\n}\n\nstatic void             /* A recursive function that overflows the stack */\noverflowStack(int callNum)\n{\n    char a[100000];                     /* Make this stack frame large */\n\n    printf(\"Call %4d - top of stack near %10p\\n\", callNum, &a[0]);\n    overflowStack(callNum+1);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    stack_t sigstack;\n    struct sigaction sa;\n    int j;\n\n    printf(\"Top of standard stack is near %10p\\n\", (void *) &j);\n\n    /* Allocate alternate stack and inform kernel of its existence */\n\n    sigstack.ss_sp = malloc(SIGSTKSZ);\n    if (sigstack.ss_sp == NULL)\n        errExit(\"malloc\");\n\n    sigstack.ss_size = SIGSTKSZ;\n    sigstack.ss_flags = 0;\n    if (sigaltstack(&sigstack, NULL) == -1)\n        errExit(\"sigaltstack\");\n    printf(\"Alternate stack is at         %10p-%p\\n\",\n            sigstack.ss_sp, (char *) sbrk(0) - 1);\n\n    sa.sa_handler = sigsegvHandler;     /* Establish handler for SIGSEGV */\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_ONSTACK;           /* Handler uses alternate stack */\n    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    overflowStack(1);\n}\n      `signals/t_sigaltstack.c`\n```", "```\nvoid handler(int sig, siginfo_t *siginfo, void *ucontext);\n```", "```\nstruct sigaction {\n    union {\n        void (*sa_handler)(int);\n        void (*sa_sigaction)(int, siginfo_t *, void *);\n    } __sigaction_handler;\n    sigset_t   sa_mask;\n    int        sa_flags;\n    void     (*sa_restorer)(void);\n};\n/* Following defines make the union fields look like simple fields\n   in the parent structure */\n#define sa_handler __sigaction_handler.sa_handler\n#define sa_sigaction __sigaction_handler.sa_sigaction\n```", "```\nstruct sigaction act;\n\nsigemptyset(&act.sa_mask);\nact.sa_sigaction = handler;\nact.sa_flags = SA_SIGINFO;\n\nif (sigaction(SIGINT, &act, NULL) == -1)\n    errExit(\"sigaction\");\n```", "```\ntypedef struct {\n    int     si_signo;         /* Signal number */\n    int     si_code;          /* Signal code */\n    int     si_trapno;        /* Trap number for hardware-generated signal\n                                 (unused on most architectures) */\n    union sigval si_value;    /* Accompanying data from sigqueue() */\n    pid_t   si_pid;           /* Process ID of sending process */\n    uid_t   si_uid;           /* Real user ID of sender */\n    int     si_errno;         /* Error number (generally unused) */\n    void   *si_addr;          /* Address that generated signal\n\n                                 (hardware-generated signals only) */\n\n    int     si_overrun;       /* Overrun count (Linux 2.6, POSIX timers) */\n    int     si_timerid;       /* (Kernel-internal) Timer ID\n                                 (Linux 2.6, POSIX timers) */\n    long    si_band;          /* Band event (SIGPOLL/SIGIO) */\n    int     si_fd;            /* File descriptor (SIGPOLL/SIGIO) */\n    int     si_status;        /* Exit status or signal (SIGCHLD) */\n    clock_t si_utime;         /* User CPU time (SIGCHLD) */\n    clock_t si_stime;         /* System CPU time (SIGCHLD) */\n} siginfo_t;\n```", "```\nwhile ((cnt = read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)\n    continue;                 /* Do nothing loop body */\n\nif (cnt == -1)                /* read() failed with other than EINTR */\n    errExit(\"read\");\n```", "```\n#define NO_EINTR(stmt) while ((stmt) == -1 && errno == EINTR);\n```", "```\nNO_EINTR(cnt = read(fd, buf, BUF_SIZE));\n\nif (cnt == -1)                /* read() failed with other than EINTR */\n    errExit(\"read\");\n```", "```\n#include <signal.h>\n\nint `siginterrupt`(int *sig*, int *flag*);\n```"]