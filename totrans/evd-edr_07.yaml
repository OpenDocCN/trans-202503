- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NETWORK
    FILTER DRIVERS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">网络过滤驱动程序</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Sometimes an EDR must implement its own sensor to capture the telemetry data
    generated by certain system components. Filesystem minifilters are one example
    of this. In Windows, the network stack is no different.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，EDR（端点检测与响应）必须实现自己的传感器，以捕获由某些系统组件生成的遥测数据。文件系统迷你过滤器就是其中的一个例子。在 Windows 中，网络堆栈也是如此。
- en: A host-based security agent might wish to capture network telemetry for many
    reasons. Network traffic is tied to the most common way for an attacker to gain
    initial access to a system (for example, when a user visits a malicious website).
    It’s also one of the key artifacts created when they perform lateral movement
    to jump from one host to another. If an endpoint security product wishes to capture
    and perform inspection on network packets, it’ll most likely implement some type
    of network filter driver.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主机的安全代理可能希望捕获网络遥测数据，原因有很多。网络流量与攻击者获得系统初始访问权限的最常见方式密切相关（例如，当用户访问恶意网站时）。它也是攻击者进行横向移动、从一台主机跳到另一台主机时产生的关键证据之一。如果端点安全产品希望捕获并检查网络数据包，它很可能会实现某种类型的网络过滤驱动程序。
- en: 'This chapter covers one of the most common driver frameworks used to capture
    network telemetry: Windows Filtering Platform (WFP). The Windows network stack
    and driver ecosystem can be a little overwhelming for newcomers, so to reduce
    the likelihood of headaches, we’ll briefly introduce core concepts and then focus
    only on the elements relevant to an EDR’s sensor.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种用于捕获网络遥测数据的常见驱动程序框架：Windows 过滤平台（WFP）。Windows 网络堆栈和驱动程序生态系统对于新手来说可能有些复杂，因此为了减少头痛的可能性，我们将简要介绍核心概念，然后仅关注与
    EDR 传感器相关的部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Network-Based vs. Endpoint-Based Monitoring</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">基于网络与基于端点的监控</samp>
- en: You might assume that the best way to detect malicious traffic is to use a network-based
    security appliance, but this isn’t always the case. The efficacy of these network
    appliances depends on their position in the network. For example, a network intrusion
    detection system (NIDS) would need to sit between host A and host B in order to
    detect lateral movement between the two.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为，检测恶意流量的最佳方式是使用基于网络的安全设备，但事实并非总是如此。这些网络设备的有效性取决于它们在网络中的位置。例如，网络入侵检测系统（NIDS）需要位于主机
    A 和主机 B 之间，才能检测到它们之间的横向移动。
- en: Imagine that the adversary must cross core network boundaries (for example,
    to move from the VPN subnet into the data center subnet). In those situations,
    the security engineers can strategically deploy the appliance at a logical choke
    point through which all that traffic must flow. This boundary-oriented architecture
    would look similar to the one shown in [Figure 7-1](#fig7-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设攻击者必须跨越核心网络边界（例如，从 VPN 子网移动到数据中心子网）。在这种情况下，安全工程师可以通过战略性地在所有流量必须经过的逻辑瓶颈点部署设备。这种面向边界的架构看起来类似于[图
    7-1](#fig7-1)所示的架构。
- en: '![](../images/Figure7-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A NIDS between
    two networks</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-1：两个网络之间的 NIDS</samp>
- en: But what about intra-subnet lateral movement, such as movement from workstation
    to workstation? It wouldn’t be cost-effective to deploy a network-monitoring appliance
    between every node on the local network, but security teams still need that telemetry
    to detect adversarial activities in their networks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何处理子网内的横向移动，比如工作站之间的移动呢？在本地网络的每个节点之间部署一个网络监控设备并不具有成本效益，但安全团队仍然需要这些遥测数据来检测网络中的敌对活动。
- en: This is where an endpoint-based traffic-monitoring sensor comes into play. By
    deploying a monitoring sensor on every client, a security team can solve the problem
    of where in the network to insert their appliance. After all, if the sensor is
    monitoring traffic on a client, as shown in [Figure 7-2](#fig7-2), it effectively
    has a man-in-the-middle relationship between the client and all other systems
    the client may communicate with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，基于端点的流量监控传感器发挥了作用。通过在每个客户端上部署监控传感器，安全团队可以解决在网络中何处插入设备的问题。毕竟，如果传感器在客户端监控流量，如[图
    7-2](#fig7-2)所示，它实际上在客户端与客户端可能通信的所有其他系统之间建立了中间人关系。
- en: '![](../images/Figure7-2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Endpoint network
    monitoring</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-2：端点网络监控</samp>
- en: 'Using endpoint-based monitoring offers another valuable advantage over network-based
    solutions: context. Because the agent running on the endpoint can collect additional
    host-based information, it can paint a more complete picture of how and why the
    network traffic was created. For example, it could determine that a child process
    of *outlook.exe* with a certain PID is communicating with a content distribution
    network endpoint once every 60 seconds; this might be command-and-control beaconing
    from a process tied to initial access.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于端点的监控比基于网络的解决方案提供了另一个宝贵的优势：上下文。因为运行在端点上的代理程序可以收集额外的基于主机的信息，它可以描绘出网络流量生成的更完整图景，帮助解释其原因和方式。例如，它可以判断一个具有特定PID的*outlook.exe*的子进程每60秒与一个内容分发网络的端点进行一次通信；这可能是与初始访问相关的命令与控制信标。
- en: The host-based sensor can get data related to the originating process, user
    context, and activities that occurred before the connection happened. By contrast,
    an appliance deployed on the network would be able to see only the metrics about
    the connection, such as its source and destination, packet frequency, and protocol.
    While this can provide valuable data to responders, it misses key pieces of information
    that would aid their investigation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主机的传感器可以获取与源进程、用户上下文以及连接发生前的活动相关的数据。相比之下，部署在网络上的设备只能看到与连接相关的度量信息，如源和目的地、数据包频率以及协议。虽然这可以为响应者提供有价值的数据，但它缺少一些关键的资讯，这些资讯将有助于他们的调查。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Legacy Network Driver Interface Specification
    Drivers</samp>
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">传统网络驱动接口规范驱动程序</samp>
- en: 'There are many types of network drivers, most of which are backed by the Network
    Driver Interface Specification (NDIS). NDIS is a library that abstracts a device’s
    network hardware. It also defines a standard interface between *layered* network
    drivers (those operating at different network layers and levels of the operating
    system) and maintains state information. NDIS supports four types of drivers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的网络驱动程序，其中大多数由网络驱动接口规范（NDIS）支持。NDIS是一个抽象设备网络硬件的库。它还定义了一个标准接口，用于连接*分层*网络驱动程序（即操作系统不同网络层和级别上的驱动程序）并保持状态信息。NDIS支持四种类型的驱动程序：
- en: '**Miniport**   Manages a network interface card, such as by sending and receiving
    data. This is the lowest level of NDIS drivers.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**迷你端口**   管理网络接口卡，例如发送和接收数据。这是NDIS驱动程序的最低层级。'
- en: '**Protocol**   Implements a transport protocol stack, such as TCP/IP. This
    is the highest level of NDIS drivers.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**   实现传输协议栈，如TCP/IP。这是NDIS驱动程序的最高层级。'
- en: '**Filter**   Sits between miniport and protocol drivers to monitor and modify
    the interactions between the two subtypes.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤**   位于迷你端口和协议驱动程序之间，用于监控和修改两者之间的交互。'
- en: '**Intermediate**   Sits between miniport and protocol drivers to expose both
    drivers’ entry points for communicating requests. These drivers expose a virtual
    adapter to which the protocol driver sends its packets. The intermediate driver
    then ships these packets to the appropriate miniport. After the miniport completes
    its operation, the intermediate driver passes the information back to the protocol
    driver. These drivers are commonly used for load-balancing traffic across more
    than one network interface card.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间**   位于迷你端口和协议驱动程序之间，暴露两者的入口点以进行通信请求。这些驱动程序暴露一个虚拟适配器，协议驱动程序将数据包发送到该适配器。然后，中间驱动程序将数据包发送到相应的迷你端口。迷你端口完成操作后，中间驱动程序将信息返回给协议驱动程序。这些驱动程序通常用于在多个网络接口卡之间进行负载均衡流量。'
- en: The interactions of these drivers with NDIS can be seen in the (grossly oversimplified)
    diagram in [Figure 7-3](#fig7-3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序与NDIS的交互可以在[图 7-3](#fig7-3)中的（极其简化的）图示中看到。
- en: For the purposes of security monitoring, filter drivers work best, as they can
    catch network traffic at the lowest levels of the network stack, just before it
    is passed to the miniport and associated network interface card. However, these
    drivers pose some challenges, such as significant code complexity, limited support
    for the network and transport layers, and a difficult installation process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全监控的角度来看，过滤驱动程序最为有效，因为它们可以在网络栈的最低层捕获网络流量，正当流量被传递到迷你端口和相关的网络接口卡之前。然而，这些驱动程序也带来一些挑战，如代码复杂度较高、对网络和传输层的支持有限以及安装过程困难。
- en: '![](../images/Figure7-3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: NDIS driver relationships</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-3：NDIS 驱动关系</samp>
- en: 'But perhaps the biggest issue with filter drivers when it comes to security
    monitoring is their lack of context. While they can capture the traffic being
    processed, they aren’t aware of the caller context (the process that initiated
    the request) and lack the metadata needed to provide valuable telemetry to the
    EDR agent. For this reason, EDRs nearly always use another framework: the Windows
    Filtering Platform (WFP).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，谈到安全监控时，过滤驱动程序的最大问题可能是它们缺乏上下文。虽然它们可以捕获正在处理的流量，但它们并不了解调用者的上下文（发起请求的进程），并且缺少为
    EDR 代理提供有价值遥测数据所需的元数据。因此，EDR 几乎总是使用另一个框架：Windows 过滤平台（WFP）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows Filtering Platform</samp>
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Windows 过滤平台</samp>
- en: WFP is a set of APIs and services for creating network-filtering applications,
    and it includes both user-mode and kernel-mode components. It was designed to
    replace legacy filtering technologies, including the NDIS filters, starting in
    Windows Vista and Server 2008\. While WFP has some downsides when it comes to
    network performance, it is generally considered the best option for creating filter
    drivers. Even the Windows firewall itself is built on WFP.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WFP 是一组用于创建网络过滤应用程序的 API 和服务，包含了用户模式和内核模式的组件。它的设计目的是取代包括 NDIS 过滤器在内的传统过滤技术，最早从
    Windows Vista 和 Server 2008 开始使用。虽然 WFP 在网络性能方面有一些缺点，但它通常被认为是创建过滤驱动程序的最佳选择。甚至
    Windows 防火墙本身也是基于 WFP 构建的。
- en: The platform offers numerous benefits. It allows EDRs to filter traffic related
    to specific applications, users, connections, network interface cards, and ports.
    It supports both IPv4 and IPv6, provides boot-time security until the base filtering
    engine has started, and lets drivers filter, modify, and reinject traffic. It
    can also process pre- and post-decryption IPsec packets and integrates hardware
    offloading, allowing filter drivers to use hardware for packet inspection.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台提供了许多优点。它允许 EDR（端点检测与响应）过滤与特定应用程序、用户、连接、网络接口卡和端口相关的流量。它支持 IPv4 和 IPv6，提供引导时的安全性，直到基础过滤引擎启动，并允许驱动程序过滤、修改并重新注入流量。它还可以处理解密前后的
    IPsec 数据包，并集成硬件卸载，允许过滤驱动程序使用硬件进行数据包检查。
- en: WFP’s implementation can be tricky to understand, as it has a complex architecture
    and uses unique names for its core components, which are distributed across both
    user mode and kernel mode. The WFP architecture looks something like what is shown
    in [Figure 7-4](#fig7-4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: WFP 的实现可能比较难以理解，因为它有一个复杂的架构，并且使用了独特的名称来表示其核心组件，这些组件分布在用户模式和内核模式中。WFP 的架构大致如下所示，在[图
    7-4](#fig7-4)中可以看到。
- en: To make sense of all this, let’s follow part of a TCP stream coming from a client
    connected to a server on the internet. The client begins by calling a function
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!send()</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!WSASend()</samp> to send
    data over a connected socket. These functions eventually pass the packet down
    to the network stack provided by *tcpip.sys* for IPv4 and *tcpip6.sys* for IPv6.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一切，我们可以跟踪来自连接到互联网服务器的客户端的 TCP 流。客户端首先调用一个函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!send()</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!WSASend()</samp> 来通过已连接的套接字发送数据。这些函数最终将数据包传递给由
    *tcpip.sys*（用于 IPv4）和 *tcpip6.sys*（用于 IPv6）提供的网络栈。
- en: As the packet traverses the network stack, it is passed to a shim associated
    with the relevant layer of the stack, such as the stream layer. *Shims* are kernel
    components that have a few critical jobs. One of their first responsibilities
    is to extract data and properties from the packet and pass them to the filter
    engine to start the process of applying filters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包穿越网络栈时，它会被传递到与栈的相关层（如流层）关联的 shim。*Shim* 是内核组件，具有几个关键功能。它们的首要任务之一是从数据包中提取数据和属性，并将它们传递给过滤引擎，以启动过滤过程。
- en: '![](../images/Figure7-4.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: The WFP architecture</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-4：WFP 架构</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Filter Engine</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">过滤引擎</samp>
- en: The filter engine, sometimes called the *generic filter engine* to avoid confusion
    with the user-mode *base filtering engine*, performs filtering at the network
    and transport layers. It contains layers of its own, which are containers used
    to organize filters into sets. Each of these layers, defined as GUIDs under the
    hood, has a schema that says what types of filters may be added to it. Layers
    may be further divided into sublayers that manage filtering conflicts. (For example,
    imagine that the rules “open port 1028” and “block all ports greater than 1024”
    were configured on the same host.) All layers inherit default sublayers, and developers
    can add their own.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器引擎，有时为了避免与用户模式的*基本过滤引擎*混淆，称为*通用过滤引擎*，在网络层和传输层执行过滤。它有自己的层次结构，这些层是用来组织过滤器集合的容器。每一层都被定义为GUID，底层有一个模式说明可以添加哪些类型的过滤器。层次结构还可以进一步细分为子层，用于管理过滤冲突。（例如，假设在同一主机上配置了“打开端口1028”和“阻止所有大于1024的端口”这两条规则。）所有层次都继承了默认的子层，开发人员也可以添加自己的子层。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter Arbitration</samp>
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">过滤器仲裁</samp>
- en: You might be wondering how the filter engine knows the order in which to evaluate
    sublayers and filters. If rules were applied to traffic in a random order, this
    could cause huge problems. For example, say the first rule was a default-deny
    that dropped all traffic. To address this problem, both sublayers and filters
    can be assigned a priority value, called a *weight*, that dictates the order in
    which they should be processed by the filter manager. This ordering logic is called
    *filter arbitration*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇，过滤器引擎是如何知道评估子层和过滤器的顺序的。如果规则是随机应用到流量上的，这可能会引发严重问题。例如，假设第一个规则是默认拒绝，丢弃所有流量。为了解决这个问题，子层和过滤器可以被分配一个优先级值，叫做*权重*，它决定了过滤器管理器应该按什么顺序处理它们。这个排序逻辑被称为*过滤器仲裁*。
- en: 'During filter arbitration, filters evaluate the data parsed from the packet
    from highest to lowest priority to determine what to do with the packet. Each
    filter contains conditions and an action, just like common firewall rules (for
    example, “if the destination port is 4444, block the packet” or “if the application
    is *edge.exe*, allow the packet”). The basic actions a filter can return are *Block*
    and *Permit*, but three other supported actions pass packet details to callout
    drivers: <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_TERMINATING</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_UNKNOWN</samp>.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤器仲裁过程中，过滤器会按照优先级从高到低评估从数据包中解析出来的数据，以确定如何处理该数据包。每个过滤器都包含条件和动作，类似于常见的防火墙规则（例如，“如果目标端口是4444，阻止该数据包”或“如果应用程序是*edge.exe*，允许该数据包”）。过滤器可以返回的基本动作有*阻止*和*允许*，但还有三种支持的其他动作，将数据包的详细信息传递给调用驱动程序：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_TERMINATING</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_UNKNOWN</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Callout Drivers</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">调用驱动程序</samp>
- en: Callout drivers are third-party drivers that extend WFP’s filtering functionality
    beyond that of the base filters. These drivers provide advanced features such
    as deep-packet inspection, parental controls, and data logging. When an EDR vendor
    is interested in capturing network traffic, it typically deploys a callout driver
    to monitor the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 调用驱动程序是第三方驱动程序，它扩展了WFP的过滤功能，超出了基本过滤器的范围。这些驱动程序提供了深度包检查、家长控制和数据日志记录等高级功能。当EDR供应商有意捕获网络流量时，通常会部署调用驱动程序来监控系统。
- en: Like basic filters, callout drivers can select the types of traffic that they’re
    interested in. When the callout drivers associated with a particular operation
    are invoked, they can suggest action be taken on the packet based on their unique
    internal processing logic. A callout driver can permit some traffic, block it,
    continue it (meaning pass it to other callout drivers), defer it, drop it, or
    do nothing. These actions are only suggestions, and the driver might override
    them during the filter arbitration process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 和基本过滤器一样，调用驱动程序可以选择它们感兴趣的流量类型。当与特定操作关联的调用驱动程序被调用时，它们可以根据其独特的内部处理逻辑建议对数据包采取某种动作。调用驱动程序可以允许某些流量、阻止它、继续处理它（即传递给其他调用驱动程序）、延迟处理、丢弃它或不做任何处理。这些动作只是建议，驱动程序可能会在过滤器仲裁过程中覆盖这些建议。
- en: When filter arbitration ends, the result is returned to the shim, which acts
    on the final filtering decision (for example, permitting the packet to leave the
    host).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当过滤仲裁结束时，结果将返回给shim，它将根据最终的过滤决策采取行动（例如，允许数据包离开主机）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Implementing a WFP Callout Driver</samp>
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实现WFP Callout驱动程序</samp>
- en: When an EDR product wants to intercept and process network traffic on a host,
    it most likely uses a WFP callout driver. These drivers must follow a somewhat
    complex workflow to set up their callout function, but the flow should make sense
    to you when you consider how packets traverse the network stack and filter manager.
    These drivers are also substantially easier to work with than their legacy NDIS
    counterparts, and Microsoft’s documentation should be very helpful for EDR developers
    looking to add this capability to their sensor lineup.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当EDR产品希望拦截并处理主机上的网络流量时，它最有可能使用WFP Callout驱动程序。这些驱动程序必须遵循一个相对复杂的工作流程来设置其callout函数，但考虑到数据包在网络栈和过滤管理器中的传递方式，这个流程应该是可以理解的。这些驱动程序也比它们的传统NDIS对应物要容易处理得多，微软的文档对于希望将此功能添加到其传感器阵列中的EDR开发人员非常有帮助。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening a Filter
    Engine Session</samp>
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">打开过滤引擎会话</samp>
- en: Like other types of drivers, WFP callout drivers begin their initialization
    inside their internal <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp>
    function. One of the first things the callout driver will do, an activity unique
    to WFP, is open a session with the filter engine. To do this, the driver calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmEngineOpen()</samp>,
    defined in [Listing 7-1](#list7-1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他类型的驱动程序一样，WFP Callout驱动程序的初始化从其内部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp>
    函数开始。Callout驱动程序将执行的第一项操作是，WFP特有的行为——与过滤引擎打开会话。为此，驱动程序调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmEngineOpen()</samp>，该函数的定义见[清单7-1](#list7-1)。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpmEngineOpen()</samp>
    function definition'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-1：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpmEngineOpen()</samp>
    函数定义
- en: The most notable argument passed to this function as input is <samp class="SANS_TheSansMonoCd_W5Regular_11">authnService</samp>,
    which determines the authentication service to use. This can be either <samp class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_WINNT</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_DEFAULT</samp>, both
    of which essentially just tell the driver to use NTLM authentication. When this
    function completes successfully, a handle to the filter engine is returned through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">engineHandle</samp> parameter
    and typically preserved in a global variable, as the driver will need it during
    its unloading process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此函数的最显著的输入参数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">authnService</samp>，它决定使用的身份验证服务。它可以是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_WINNT</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_DEFAULT</samp>，两者本质上都只是告诉驱动程序使用NTLM身份验证。当该函数成功完成时，过滤引擎的句柄将通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">engineHandle</samp> 参数返回，并通常保存在全局变量中，因为驱动程序在卸载过程中需要该句柄。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering Callouts</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注册Callouts</samp>
- en: Next, the driver registers its callouts. This is done through a call to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmCalloutRegister()</samp>
    API. Systems running Windows 8 or later will convert this function to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpsCalloutRegister2()</samp>,
    the definition of which is included in [Listing 7-2](#list7-2).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，驱动程序注册其callouts。此操作通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmCalloutRegister()</samp>
    API 完成。在运行Windows 8或更高版本的系统中，这个函数会被转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpsCalloutRegister2()</samp>，其定义包含在[清单7-2](#list7-2)中。
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpsCalloutRegister2()</samp>
    function definition'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-2：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpsCalloutRegister2()</samp>
    函数定义
- en: The pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_CALLOUT2</samp>
    structure passed as input to this function (via its <samp class="SANS_TheSansMonoCd_W5Regular_11">callout</samp>
    parameter) contains details about the functions internal to the callout driver
    that will handle the filtering of packets. It is defined in [Listing 7-3](#list7-3).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此函数的指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_CALLOUT2</samp>
    结构的指针（通过其 <samp class="SANS_TheSansMonoCd_W5Regular_11">callout</samp> 参数）包含有关回调驱动程序内部处理数据包过滤的函数的详细信息。该结构定义见
    [列表 7-3](#list7-3)。
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_CALLOUT2</samp>
    structure definition'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_CALLOUT2</samp>
    结构定义
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">notifyFn</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">flowDeleteFn</samp> members are callout
    functions used to notify the driver when there is information to be passed related
    to the callout itself or when the data that the callout is processing has been
    terminated, respectively. Because these callout functions aren’t particularly
    relevant to detection efforts, we won’t cover them in further detail. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">classifyFn</samp> member, however, is
    a pointer to the function invoked whenever there is a packet to be processed,
    and it contains the bulk of the logic used for inspection. We’ll cover these callouts
    in “Detecting Adversary Tradecraft with Network Filters” on [page 135](#sec14).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">notifyFn</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">flowDeleteFn</samp>
    成员是回调函数，用于在有信息需要传递与回调本身相关或回调处理的数据已经终止时，通知驱动程序。由于这些回调函数与检测工作无关，因此我们不会进一步详细介绍它们。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">classifyFn</samp> 成员是一个指针，指向每当有数据包需要处理时被调用的函数，它包含了用于检查的大部分逻辑。我们将在“通过网络过滤器检测对手手段”一节中详细介绍这些回调函数，详见
    [第135页](#sec14)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Callout
    Function to the Filter Engine</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将回调函数添加到过滤引擎</samp>
- en: After we’ve defined the callout function, we can add it to the filter engine
    by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmCalloutAdd()</samp>,
    passing the engine handle obtained earlier and a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_CALLOUT</samp>
    structure, shown in [Listing 7-4](#list7-4), as input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了回调函数之后，我们可以通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmCalloutAdd()</samp>，传入之前获取的引擎句柄和指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_CALLOUT</samp> 结构的指针（该结构显示在
    [列表 7-4](#list7-4) 中）来将回调函数添加到过滤引擎中。
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_CALLOUT</samp>
    structure definition'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-4：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_CALLOUT</samp>
    结构定义
- en: This structure contains data about the callout, such as its optional friendly
    name and description in its <samp class="SANS_TheSansMonoCd_W5Regular_11">displayData</samp>
    member, as well as the layers to which the callout should be assigned (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_STREAM_V4</samp> for
    IPv4 streams). Microsoft documents dozens of filter layer identifiers, each of
    which usually has IPv4 and IPv6 variants. When the function used by the driver
    to add its callout completes, it returns a runtime identifier for the callout
    that is preserved for use during unloading.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构包含有关回调的数据，例如其可选的友好名称和描述，这些信息存储在其 <samp class="SANS_TheSansMonoCd_W5Regular_11">displayData</samp>
    成员中，以及回调应分配到的层（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_STREAM_V4</samp>
    用于 IPv4 流）。微软文档中列出了数十个过滤器层标识符，每个标识符通常都有 IPv4 和 IPv6 版本。当驱动程序用于添加回调的函数完成时，它返回一个回调的运行时标识符，该标识符将在卸载时继续使用。
- en: Unlike filter layers, a developer may add their own sublayers to the system.
    In those cases, the driver will call <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmSublayerAdd()</samp>,
    which receives the engine handle, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER</samp>
    structure, and an optional security descriptor. The structure passed as input
    includes the sublayer key, a <samp class="SANS_TheSansMonoCd_W5Regular_11">GUID</samp>
    to uniquely identify the sublayer, an optional friendly name and description,
    an optional flag to ensure that the sublayer persists between reboots, the sublayer
    weight, and other members that contain the state associated with a sublayer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与过滤器层不同，开发人员可以向系统添加自己的子层。在这些情况下，驱动程序将调用<samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmSublayerAdd()</samp>，该函数接收引擎句柄、指向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER</samp>结构的指针，以及一个可选的安全描述符。作为输入传递的结构包括子层键、一个用于唯一标识子层的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GUID</samp>、一个可选的友好名称和描述、一个可选的标志，确保子层在重启后仍然存在、子层的权重，以及其他包含与子层关联状态的成员。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a New Filter
    Object</samp>
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加新过滤器对象</samp>
- en: The last action a callout driver performs is adding a new filter object to the
    system. This filter object is the rule that the driver will evaluate when processing
    the connection. To create one, the driver calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>,
    passing in the engine handle, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp>
    structure shown in [Listing 7-5](#list7-5), and an optional pointer to a security
    descriptor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序执行的最后一个操作是向系统添加一个新的过滤器对象。这个过滤器对象是驱动程序在处理连接时评估的规则。要创建一个，驱动程序调用<samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>，传入引擎句柄、指向[sListing
    7-5](#list7-5)中所示的<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp>结构的指针，以及一个可选的指向安全描述符的指针。
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER</samp>
    structure definition'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-5：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER</samp>结构定义
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure
    contains a few key members worth highlighting. The <samp class="SANS_TheSansMonoCd_W5Regular_11">flags</samp>
    member contains several flags that describe attributes of the filter, such as
    whether the filter should persist through system reboots (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_PERSISTENT</samp>)
    or if it is a boot-time filter (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_BOOTTIME</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp> member defines
    the priority value of the filter in relation to other filters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">numFilterConditions</samp>
    is the number of filtering conditions specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>
    member, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_CONDITION</samp>
    structures that describe all the filtering conditions. For the callout functions
    to process the event, all conditions must be true. Lastly, <samp class="SANS_TheSansMonoCd_W5Regular_11">action</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_TYPE</samp> value
    indicating what action to perform if all filtering conditions return true. These
    actions include permitting, blocking, or passing the request to a callout function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp>结构包含一些值得注意的关键成员。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">flags</samp>成员包含描述过滤器属性的多个标志，例如过滤器是否应在系统重启后保持存在（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_PERSISTENT</samp>）或它是否为启动时过滤器（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_BOOTTIME</samp>）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>成员定义过滤器相对于其他过滤器的优先级值。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">numFilterConditions</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>成员中指定的过滤条件的数量，该成员是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_CONDITION</samp>结构的数组，描述了所有过滤条件。为了让调用函数处理事件，所有条件必须为真。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">action</samp>是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_TYPE</samp>值，指示如果所有过滤条件都为真，应该执行什么操作。这些操作包括允许、阻止或将请求传递给调用函数。
- en: Of these members, <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>
    is the most important, as each filter condition in the array represents a discrete
    “rule” against which the connections will be evaluated. Each rule is itself made
    up of a condition value and match type. The definition for this structure is shown
    in [Listing 7-6](#list7-6).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些成员中，<samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>
    是最重要的，因为数组中的每个过滤条件都代表一个独立的“规则”，连接将根据该规则进行评估。每个规则本身由条件值和匹配类型组成。此结构体的定义请参见[列表 7-6](#list7-6)。
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-6: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER_CONDITION</samp>
    structure definition'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-6：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER_CONDITION</samp>
    结构体定义  '
- en: The first member, <samp class="SANS_TheSansMonoCd_W5Regular_11">fieldKey</samp>,
    indicates the attribute to evaluate. Each filtering layer has its own attributes,
    identified by GUIDs. For example, a filter inserted in the stream layer can work
    with local and remote IP addresses and ports, traffic direction (whether inbound
    or outbound), and flags (for example, if the connection is using a proxy).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个成员，<samp class="SANS_TheSansMonoCd_W5Regular_11">fieldKey</samp>，表示要评估的属性。每个过滤层都有其特定的属性，通过
    GUID 识别。例如，插入流层的过滤器可以与本地和远程 IP 地址、端口、流量方向（入站或出站）和标志（例如，连接是否使用代理）一起工作。  '
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">matchType</samp> member specifies
    the type of match to be performed. These comparison types are defined in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWP_MATCH_TYPE</samp> enumeration shown
    in [Listing 7-7](#list7-7) and can match strings, integers, ranges, and other
    data types.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">matchType</samp> 成员指定要执行的匹配类型。这些比较类型在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_MATCH_TYPE</samp> 枚举中定义，如[列表
    7-7](#list7-7)所示，可以匹配字符串、整数、范围和其他数据类型。  '
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-7: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_MATCH_TYPE</samp>
    enumeration'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-7：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_MATCH_TYPE</samp>
    枚举类型  '
- en: The last member of the structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">conditionValue</samp>,
    is the condition against which the connection should be matched. The filter condition
    value is composed of two parts, the data type and a condition value, housed together
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_CONDITION_VALUE</samp>
    structure, shown in [Listing 7-8](#list7-8).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '结构体的最后一个成员，<samp class="SANS_TheSansMonoCd_W5Regular_11">conditionValue</samp>，是用于匹配连接的条件。过滤条件值由两部分组成，数据类型和条件值，它们共同存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_CONDITION_VALUE</samp> 结构体中，如[列表
    7-8](#list7-8)所示。  '
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_CONDITION_VALUE</samp>
    structure definition'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-8：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_CONDITION_VALUE</samp>
    结构体定义  '
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_DATA_TYPE</samp> value
    indicates what union member the driver should use to evaluate the data. For instance,
    if the type member is <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_V4_ADDR_MASK</samp>,
    which maps to an IPv4 address, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">v4AddrMask</samp>
    member would be accessed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_DATA_TYPE</samp> 值表示驱动程序应使用哪个联合成员来评估数据。例如，如果类型成员是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_V4_ADDR_MASK</samp>，表示一个 IPv4
    地址，那么将访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">v4AddrMask</samp> 成员。  '
- en: The match type and condition value members form a discrete filtering requirement
    when combined. For example, this requirement could be “if the destination IP address
    is 1.1.1.1” or “if the TCP port is greater than 1024.” What should happen when
    the condition evaluates as true? To determine this, we use the action member of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure.
    In callout drivers that perform firewalling activities, we could choose to permit
    or block traffic based on certain attributes. In the context of security monitoring,
    however, most developers forward the request to the callout functions by specifying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp>
    flag, which passes the request to the callout without expecting the callout to
    make a permit/deny decision regarding the connection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配类型和条件值成员结合时，它们形成一个离散的过滤要求。例如，这个要求可能是“如果目标 IP 地址是 1.1.1.1”或“如果 TCP 端口大于 1024”。当条件评估为真时应该发生什么？为了确定这一点，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> 结构体的 action 成员。在执行防火墙活动的调用驱动程序中，我们可以根据某些属性选择允许或阻止流量。然而，在安全监控的上下文中，大多数开发人员通过指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp>
    标志将请求转发到调用函数，而不期望调用函数对连接做出允许/拒绝的决策。
- en: If we combine all three components of the <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>
    member, we could represent a filtering condition as a complete sentence, such
    as the one shown in [Figure 7-5](#fig7-5).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp> 成员的三个组成部分结合起来，我们可以将过滤条件表示为一个完整的句子，例如
    [图 7-5](#fig7-5) 中所示的那样。
- en: '![](../images/Figure7-5.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Filtering conditions</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-5：过滤条件</samp>
- en: At this point, we have our rule’s basic “if this, do that” logic, but we have
    yet to deal with some other conditions related to filter arbitration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经有了规则的基本“如果这样，做那样”的逻辑，但我们还没有处理与过滤仲裁相关的其他条件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Weights
    and Sublayers</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分配权重和子层</samp>
- en: What if our driver has filters to, say, both permit traffic on TCP port 1080
    and block outbound connections on TCP ports greater than 1024? To handle these
    conflicts, we must assign each filter a weight. The greater the weight, the higher
    the priority of the condition, and the earlier it should be evaluated. For instance,
    the filter allowing traffic on port 1080 should be evaluated before the one blocking
    all traffic using ports higher than 1024 to permit software using port 1080 to
    function. In code, a weight is just an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">UINT8</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT64</samp>)
    assigned in the weight member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp>
    structure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的驱动程序有过滤器，例如同时允许 TCP 端口 1080 上的流量并阻止大于 1024 的 TCP 端口的出站连接，该怎么办？为了处理这些冲突，我们必须为每个过滤器分配一个权重。权重越大，条件的优先级越高，应该越早被评估。例如，允许在端口
    1080 上的流量的过滤器应该在阻止所有使用大于 1024 端口的流量的过滤器之前进行评估，以便允许使用端口 1080 的软件正常工作。在代码中，权重只是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp>（<samp class="SANS_TheSansMonoCd_W5Regular_11">UINT8</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT64</samp>），它被分配在 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp>
    结构体的权重成员中。
- en: In addition to assigning the weight, we need to assign the filter to a sublayer
    so that it is evaluated at the correct time. We do this by specifying a GUID in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">layerKey</samp> member of the
    structure. If we created our own sublayer, we would specify its GUID here. Otherwise,
    we’d use one of the default sublayer GUIDs listed in [Table 7-1](#tab7-1).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分配权重，我们还需要将过滤器分配到子层，以便它在正确的时间被评估。我们通过在结构体的 <samp class="SANS_TheSansMonoCd_W5Regular_11">layerKey</samp>
    成员中指定一个 GUID 来实现。如果我们创建了自己的子层，我们将在此处指定其 GUID。否则，我们将使用 [表 7-1](#tab7-1) 中列出的默认子层
    GUID 之一。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Default
    Sublayer GUIDs</samp>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-1：</samp> <samp class="SANS_Futura_Std_Book_11">默认子层
    GUID</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Filter sublayer identifier</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Filter type</samp> |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">过滤器子层标识符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">过滤器类型</samp>
    |'
- en: '| --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_EDGE_TRAVERSAL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(BA69DC66-5176-4979-9C89-26A7B46A8327)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Edge traversal</samp> |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_EDGE_TRAVERSAL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(BA69DC66-5176-4979-9C89-26A7B46A8327)</samp>
    | <samp class="SANS_Futura_Std_Book_11">边缘穿透</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_INSPECTION</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(877519E1-E6A9-41A5-81B4-8C4F118E4A60)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Inspection</samp> |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_INSPECTION</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(877519E1-E6A9-41A5-81B4-8C4F118E4A60)</samp>
    | <samp class="SANS_Futura_Std_Book_11">检查</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_DOSP</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(E076D572-5D3D-48EF-802B-909EDDB098BD)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec denial-of-service (DoS) protection</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_DOSP</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(E076D572-5D3D-48EF-802B-909EDDB098BD)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec 拒绝服务 (DoS) 保护</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">_TUNNEL</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(A5082E73-8F71-4559-8A9A-101CEA04EF87)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec forward outbound tunnel</samp> |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">_TUNNEL</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(A5082E73-8F71-4559-8A9A-101CEA04EF87)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec 转发出站隧道</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_TUNNEL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(83F299ED-9FF4-4967-AFF4-C309F4DAB827)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec tunnel</samp> |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_TUNNEL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(83F299ED-9FF4-4967-AFF4-C309F4DAB827)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec 隧道</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_LIPS</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1B75C0CE-FF60-4711-A70F-B4958CC3B2D0)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Legacy IPsec filters</samp> |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_LIPS</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1B75C0CE-FF60-4711-A70F-B4958CC3B2D0)</samp>
    | <samp class="SANS_Futura_Std_Book_11">传统 IPsec 过滤器</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_RPC_AUDIT</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(758C84F4-FB48-4DE9-9AEB-3ED9551AB1FD)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Remote procedure call (RPC) audit</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_RPC_AUDIT</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(758C84F4-FB48-4DE9-9AEB-3ED9551AB1FD)</samp>
    | <samp class="SANS_Futura_Std_Book_11">远程过程调用 (RPC) 审计</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_SECURE_SOCKET</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(15A66E17-3F3C-4F7B-AA6C-812AA613DD82)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Secure socket</samp> |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_SECURE_SOCKET</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(15A66E17-3F3C-4F7B-AA6C-812AA613DD82)</samp>
    | <samp class="SANS_Futura_Std_Book_11">安全套接字</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(337608B9-B7D5-4D5F-82F9-3618618BC058)</samp>
    | <samp class="SANS_Futura_Std_Book_11">TCP Chimney Offload</samp> |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(337608B9-B7D5-4D5F-82F9-3618618BC058)</samp>
    | <samp class="SANS_Futura_Std_Book_11">TCP Chimney 卸载</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_TEMPLATES</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(24421DCF-0AC5-4CAA-9E14-50F6E3636AF0)</samp>
    | <samp class="SANS_Futura_Std_Book_11">TCP template</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_TEMPLATES</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(24421DCF-0AC5-4CAA-9E14-50F6E3636AF0)</samp>
    | <samp class="SANS_Futura_Std_Book_11">TCP 模板</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_UNIVERSAL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(EEBECC03-CED4-4380-819A-2734397B2B74)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Those not assigned to any other sublayers</samp>
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_UNIVERSAL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(EEBECC03-CED4-4380-819A-2734397B2B74)</samp>
    | <samp class="SANS_Futura_Std_Book_11">未分配到任何其他子层的项</samp> |'
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_SECURITY_REALM</samp>
    sublayer identifier is defined in the *fwpmu.h* header but is undocumented.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_SECURITY_REALM</samp>
    子层标识符定义在 *fwpmu.h* 头文件中，但未文档化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a Security
    Descriptor</samp>
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加安全描述符</samp>
- en: The last parameter we can pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>
    is a security descriptor. While optional, it allows the developer to explicitly
    set the access control list for their filter. Otherwise, the function will apply
    a default value to the filter. This default security descriptor grants <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    rights to members of the Local Administrators group, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>
    rights to members of the Network Configuration Operators group, as well as the
    diagnostic service host (*WdiServiceHost*), IPsec policy agent (*PolicyAgent*),
    network list service (*NetProfm*), remote procedure call (*RpcSs*), and Windows
    firewall (*MpsSvc*) services. Lastly, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_OPEN</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_CLASSIFY</samp> are
    granted to the Everyone group.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>
    的最后一个参数是安全描述符。虽然它是可选的，但它允许开发人员显式设置其过滤器的访问控制列表。否则，该函数将为过滤器应用默认值。此默认安全描述符授予本地管理员组成员
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> 权限，以及网络配置操作员组成员
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp> 权限，以及诊断服务主机
    (*WdiServiceHost*)、IPsec 策略代理 (*PolicyAgent*)、网络列表服务 (*NetProfm*)、远程过程调用 (*RpcSs*)
    和 Windows 防火墙 (*MpsSvc*) 服务的权限。最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_OPEN</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_CLASSIFY</samp> 权限被授予
    Everyone 组。
- en: After the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>
    completes, the callout driver has been initialized, and it will process events
    until the driver is ready to be unloaded. The unloading process is outside the
    scope of this chapter, as it is largely irrelevant to security monitoring, but
    it closes all the previously opened handles, deletes created sublayers and filters,
    and safely removes the driver.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>
    完成后，回调驱动程序已初始化，并将处理事件，直到驱动程序准备好卸载。卸载过程超出了本章的范围，因为它与安全监控关系不大，但它会关闭之前打开的所有句柄，删除创建的子层和过滤器，并安全地移除驱动程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Adversary Tradecraft with
    Network Filters</samp>
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用网络过滤器检测对手的作战技巧</samp>
- en: The bulk of the telemetry that a WFP filter driver collects comes from its callouts.
    These are most often *classify* callouts, which receive information about the
    connection as input. From this data, developers can extract telemetry useful for
    detecting malicious activity. Let’s explore these functions further, starting
    with their definition in [Listing 7-9](#list7-9).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: WFP 过滤器驱动程序收集的大部分遥测数据来自其回调。这些回调通常是 *分类* 回调，接收有关连接的信息作为输入。从这些数据中，开发人员可以提取有助于检测恶意活动的遥测信息。让我们进一步探索这些函数，首先从它们在[示例
    7-9](#list7-9)中的定义开始。
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-9: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FwpsCalloutClassifyFn</samp>
    definition'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-9：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FwpsCalloutClassifyFn</samp>
    的定义
- en: On invocation, the callout receives pointers to a few structures containing
    interesting details about the data being processed. These details include the
    basic network information you’d expect to receive from any packet-capturing application
    (the remote IP address, for example) and metadata that provides additional context,
    including the requesting process’s PID, image path, and token.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用时，回调会接收指向几个包含有关正在处理的数据的有趣细节的结构的指针。这些细节包括你期望从任何数据包捕获应用程序中接收的基本网络信息（例如远程 IP
    地址）以及提供附加上下文的元数据，包括请求进程的 PID、镜像路径和令牌。
- en: In return, the callout function will set the action for the stream-layer shim
    to take (assuming the packet being processed is in the stream layer), as well
    as an action for the filter engine to take, such as to block or allow the packet.
    It might also defer the decision-making to the next registered callout function.
    We describe this process in greater detail in the following sections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报，回调函数将设置流层 shim 应采取的操作（假设正在处理的数据包位于流层），以及过滤引擎应采取的操作，例如阻止或允许该数据包。它也可能将决策过程推迟到下一个注册的回调函数。我们将在后续章节中更详细地描述这一过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Basic Network
    Data</samp>
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基本网络数据</samp>
- en: The first parameter, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_VALUES</samp>
    structure, is defined in [Listing 7-10](#list7-10) and contains information about
    the connection that has been passed from the filter engine to the callout.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_VALUES</samp>
    结构的指针，该结构在 [Listing 7-10](#list7-10) 中定义，包含了从过滤引擎传递给回调函数的连接信息。
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-10: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_VALUES</samp>
    structure'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-10: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_VALUES</samp>
    结构'
- en: The first member of this structure contains the identifier of the filter layer
    at which the data was obtained. Microsoft defines these values (for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_INBOUND_IPPACKET_V4</samp>).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的第一个成员包含了数据获取时所处的过滤层标识符。微软定义了这些值（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_INBOUND_IPPACKET_V4</samp>）。
- en: The second member contains the number of entries in the array pointed to by
    the third parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">incomingValue</samp>.
    This is an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS _INCOMING_VALUE</samp>
    structures containing the data that the filter engine passes to the callout. Each
    structure in the array has only an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp>
    structure, shown in [Listing 7-11](#list7-11), that describes the type and value
    of the data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个成员包含了由第三个参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">incomingValue</samp>
    指向的数组中的条目数。这个数组由 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_VALUE</samp>
    结构组成，包含过滤引擎传递给回调函数的数据。数组中的每个结构只包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp>
    结构，定义见 [Listing 7-11](#list7-11)，该结构描述了数据的类型和值。
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_VALUE</samp>
    structure definition'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-11: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_VALUE</samp>
    结构定义'
- en: To access the data inside the array, the driver needs to know the index at which
    the data resides. This index varies based on the layer identifier being processed.
    For instance, if the layer is <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_LAYER_OUTBOUND_IPPACKET_V4</samp>,
    the driver would access fields based on their index in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp>
    enumeration, defined in [Listing 7-12](#list7-12).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问数组中的数据，驱动程序需要知道数据所在的索引。这个索引根据正在处理的层标识符不同而变化。例如，如果层是 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_LAYER_OUTBOUND_IPPACKET_V4</samp>，则驱动程序会根据它在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp>
    枚举中的索引访问字段，具体定义见 [Listing 7-12](#list7-12)。
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-12: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp>
    enumeration'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-12: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp>
    枚举'
- en: For example, if an EDR’s driver wanted to inspect the remote IP address, it
    could access this value using the code in [Listing 7-13](#list7-13).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 EDR 的驱动程序想要检查远程 IP 地址，它可以使用 [Listing 7-13](#list7-13) 中的代码来访问该值。
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-13: Accessing the remote IP address in the incoming values'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-13: 访问传入值中的远程 IP 地址'
- en: In this example, the EDR driver extracts the IP address by referencing the unsigned
    32-bit integer (<samp class="SANS_TheSansMonoCd_W5Regular_11">uint32</samp>) value
    at the index <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS</samp>
    in the incoming values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，EDR 驱动程序通过引用索引 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS</samp>
    处的无符号 32 位整数（<samp class="SANS_TheSansMonoCd_W5Regular_11">uint32</samp>）值来提取
    IP 地址。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Metadata</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">元数据</samp>
- en: The next parameter that the callout function receives is a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_METADATA_VALUES0</samp>
    structure, which provides incredibly valuable metadata to an EDR, beyond the information
    you’d expect to get from a packet-capture application such as Wireshark. You can
    see this metadata in [Listing 7-14](#list7-14).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 调用注释函数接收到的下一个参数是指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_METADATA_VALUES0</samp>
    结构的指针，该结构为 EDR 提供了极其有价值的元数据，超出了你从像 Wireshark 这样的数据包捕获应用程序中预期得到的信息。你可以在 [清单 7-14](#list7-14)
    中查看这些元数据。
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_METADATA_VALUES0</samp>
    structure definition'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-14：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_METADATA_VALUES0</samp>
    结构定义
- en: We mentioned that one of the main benefits to monitoring network traffic on
    each endpoint is the context that this approach provides to the EDR. We can see
    this in the <samp class="SANS_TheSansMonoCd_W5Regular_11">processPath</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">processId</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">token</samp>
    members, which give us information about the endpoint process and the associated
    principal.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，在每个端点上监视网络流量的主要好处之一是这种方法为 EDR 提供的上下文。我们可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">processPath</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">processId</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">token</samp>
    成员中看到这一点，它们提供了关于端点进程和相关主体的信息。
- en: Note that not all values in this structure will be populated. To see which values
    are present, the callout function checks the <samp class="SANS_TheSansMonoCd_W5Regular_11">currentMetadataValues</samp>
    member, which is a bitwise-OR of a combination of metadata filter identifiers.
    Microsoft nicely provided us with a macro, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_IS_METADATA_FIELD_PRESENT()</samp>,
    that will return true if the value we’re interested in is present.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非该结构中的所有值都会被填充。要查看哪些值存在，调用注释函数会检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">currentMetadataValues</samp>
    成员，该成员是多个元数据过滤器标识符的按位或操作。微软非常友好地为我们提供了一个宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_IS_METADATA_FIELD_PRESENT()</samp>，如果我们感兴趣的值存在，它将返回
    true。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Layer Data</samp>
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">层数据</samp>
- en: After the metadata, the classify function receives information about the layer
    being filtered and the conditions under which the callout is invoked. For example,
    if the data originates from the stream layer, the parameter will point to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_CALLOUT_IO_PACKET0</samp>
    structure. This layer data contains a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_DATA0</samp>
    structure, which contains flags that encode the characteristics of the stream
    (for example, whether it is inbound or outbound, whether it is high priority,
    and whether the network stack will pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">FIN</samp>
    flag in the final packet). It will also contain the offset to the stream, the
    size of its data in the stream, and a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp>
    that describes the current portion of the stream.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在元数据之后，分类函数接收关于正在被过滤的层的信息以及调用注释被触发的条件。例如，如果数据来源于流层，则参数将指向一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_CALLOUT_IO_PACKET0</samp>
    结构。该层数据包含指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_DATA0</samp>
    结构的指针，该结构包含用于编码流特征的标志（例如，是否为入站或出站，是否为高优先级，以及网络堆栈是否将在最终数据包中传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">FIN</samp>
    标志）。它还将包含流的偏移量、流中数据的大小，以及指向描述当前流部分的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp>
    的指针。
- en: This buffer list is a linked list of <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER</samp>
    structures. Each structure in the list contains a chain of memory descriptor lists
    used to hold the data sent or received over the network. Note that if the request
    didn’t originate from the stream layer, the <samp class="SANS_TheSansMonoCd_W5Regular_11">layerData</samp>
    parameter will point only to a <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp>,
    assuming it is not null.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该缓冲区列表是一个由 <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER</samp> 结构组成的链表。列表中的每个结构都包含一系列内存描述符列表，用于存储通过网络发送或接收的数据。请注意，如果请求不是来自流层，则
    <samp class="SANS_TheSansMonoCd_W5Regular_11">layerData</samp> 参数将仅指向一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp>，假设它不为空。
- en: 'The layer data structure also contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp>
    member, which is an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_TYPE</samp>
    value describing an action that the callout recommends the stream-layer shim take.
    These include:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 层数据结构还包含一个<samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp>成员，它是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_TYPE</samp>值，描述了回调函数建议流层shim采取的动作。包括以下几种：
- en: Doing nothing (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NONE</samp>).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不做任何操作（<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NONE</samp>）。
- en: Allowing all future data segments in the flow to continue without inspection
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_ALLOW_CONNECTION</samp>).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许流中的所有未来数据段继续传输而不进行检查（<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_ALLOW_CONNECTION</samp>）。
- en: Requesting more data. If this is set, the callout must populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">countBytesRequired</samp>
    member with the number of bytes of stream data required (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NEED_MORE_DATA</samp>).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求更多数据。如果设置了此项，回调函数必须将<samp class="SANS_TheSansMonoCd_W5Regular_11">countBytesRequired</samp>成员填充为所需的流数据字节数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NEED_MORE_DATA</samp>）。
- en: Dropping the connection (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DROP_CONNECTION</samp>).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃连接（<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DROP_CONNECTION</samp>）。
- en: Deferring processing until <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpkclnt!FwpsStreamContinue0()</samp>
    is called. This is used for flow control, to slow down the rate of incoming data
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DEFER</samp>).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推迟处理，直到调用<samp class="SANS_TheSansMonoCd_W5Regular_11">fwpkclnt!FwpsStreamContinue0()</samp>。这用于流控制，减缓传入数据的速度（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DEFER</samp>）。
- en: Don’t confuse this <samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp>
    member with the <samp class="SANS_TheSansMonoCd_W5Regular_11">classifyOut</samp>
    parameter passed to the classify function to indicate the result of the filtering
    operation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这个<samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp>成员与传递给分类函数的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">classifyOut</samp>参数混淆，后者用于指示过滤操作的结果。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Network Filters</samp>
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避网络过滤器</samp>
- en: You’re probably interested in evading network filters primarily because you’d
    like to get your command-and-control traffic to the internet, but other types
    of traffic are subject to filtering too, such as lateral movement and network
    reconnaissance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能主要是对规避网络过滤器感兴趣，因为你希望将指挥控制流量发送到互联网，但其他类型的流量也会受到过滤，比如横向移动和网络侦察。
- en: However, when it comes to evading WFP callout drivers, there aren’t many options
    (at least not compared to those available for other sensor components). In a lot
    of ways, evading network filters is very similar to performing a standard firewall
    rule assessment. Some filters may opt to explicitly permit or deny traffic, or
    they may send the contents off for inspection by a callout.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在规避WFP回调驱动程序时，选项并不多（至少与其他传感器组件相比，选择较少）。在许多方面，规避网络过滤器非常类似于执行标准的防火墙规则评估。一些过滤器可能会明确允许或拒绝流量，或者它们可能会将内容发送给回调函数进行检查。
- en: As with any other type of rule-coverage analysis, the bulk of the work comes
    down to enumerating the various filters on the system, their configurations, and
    their rulesets. Thankfully, many available tools can make this process relatively
    painless. The built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">netsh</samp>
    command allows you to export the currently registered filters as an XML document,
    an example of which is shown in [Listing 7-15](#list7-15).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他类型的规则覆盖分析一样，主要的工作是列举系统上各种过滤器、它们的配置以及它们的规则集。幸运的是，许多可用的工具可以使这个过程相对简单。内置的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">netsh</samp>命令允许你将当前注册的过滤器导出为XML文档，示例见[列表
    7-15](#list7-15)。
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-15: Enumerating registered filters with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">netsh</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-15：使用<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">netsh</samp>列举已注册的过滤器
- en: Because parsing XML can cause some headaches, you might prefer to use an alternative
    tool, NtObjectManager. It includes cmdlets for collecting information related
    to WFP components, including sublayer identifiers and filters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解析 XML 可能会带来一些麻烦，您可能更愿意使用一个替代工具——NtObjectManager。它包含用于收集与 WFP 组件相关的信息的 cmdlet，包括子层标识符和过滤器。
- en: One of the first actions you should perform to get an idea of what drivers are
    inspecting traffic on the system is to list all the non-default sublayers. You
    can do this using the commands shown in [Listing 7-16](#list7-16).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解系统上哪些驱动程序在检查流量，您应该首先执行的操作是列出所有非默认的子层。您可以使用[清单 7-16](#list7-16)中显示的命令来完成此操作。
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7-16: Enumerating WFP sublayers using NtObjectManager'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-16：使用 NtObjectManager 枚举 WFP 子层
- en: The weights indicate the order in which the sublayers will be evaluated during
    filter arbitration. Look for interesting sublayers worth exploring further, such
    as those associated with applications that provide security monitoring. Then,
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwFilter</samp> cmdlet,
    return filters associated with the specified sublayer, as shown in [Listing 7-17](#list7-17).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 权重表示子层在过滤器仲裁过程中被评估的顺序。寻找一些有趣的子层，值得进一步探索，比如那些与提供安全监控的应用程序相关的子层。然后，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwFilter</samp>
    cmdlet，返回与指定子层相关的过滤器，如[清单 7-17](#list7-17)所示。
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 7-17: Enumerating filters associated with a subfilter layer'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-17：枚举与子过滤层相关的过滤器
- en: For our purposes, the most interesting filter in this layer is <samp class="SANS_TheSansMonoCd_W5Regular_11">CalloutInspection</samp>,
    as it sends the contents of the network connection to the driver, which will determine
    whether to terminate the connection. You can inspect callouts by passing their
    key names to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwCallout</samp>
    cmdlet. [Listing 7-18](#list7-18) shows the process of investigating one of Windows
    Defender’s filters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，这一层中最有趣的过滤器是 <samp class="SANS_TheSansMonoCd_W5Regular_11">CalloutInspection</samp>，因为它将网络连接的内容发送到驱动程序，驱动程序会决定是否终止连接。您可以通过将回调的键名传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwCallout</samp> cmdlet 来检查回调。[清单
    7-18](#list7-18) 显示了调查 Windows Defender 过滤器的过程。
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-18: Using NtObjectManager to inspect WFP filters'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-18：使用 NtObjectManager 检查 WFP 过滤器
- en: This information helps us determine the type of traffic being inspected, as
    it includes the layer for which the callout is registered; a description that
    could make understanding the purpose of the callout more easily identifiable;
    and the security descriptor, which can be audited to find any potential misconfigurations
    that would grant excessive control over it. But it still doesn’t tell us exactly
    what the driver is looking for. No two EDR vendors will inspect the same attributes
    in the same way, so the only way to know what a driver is examining is to reverse
    engineer its callout routines.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息帮助我们确定正在检查的流量类型，因为它包括回调注册的层级；一个可以帮助更容易识别回调目的的描述；以及安全描述符，它可以被审计以发现任何可能授予过度控制的潜在配置错误。但它仍然不能告诉我们驱动程序到底在寻找什么。没有两个
    EDR 供应商会以相同的方式检查相同的属性，因此，了解驱动程序正在检查什么的唯一方法是逆向工程它的回调例程。
- en: We can, however, assess WFP filters by looking for configuration gaps like those
    found in standard firewalls. After all, why bother reverse-engineering a driver
    when we could just look for rules to abuse? One of my favorite ways of evading
    detection is to find gaps that allow the traffic to slip through. For example,
    if a callout only monitors IPv4 traffic, traffic sent using IPv6 won’t be inspected.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过查找类似标准防火墙中发现的配置漏洞来评估 WFP 过滤器。毕竟，为什么要逆向工程一个驱动程序，而我们可以直接寻找可被滥用的规则呢？我最喜欢的规避检测的方法之一就是找到那些允许流量穿透的漏洞。例如，如果某个回调只监控
    IPv4 流量，那么使用 IPv6 发送的流量就不会被检查。
- en: Because bypasses vary between vendors and environments, try looking for rules
    that explicitly allow traffic to a certain destination. In my experience, these
    are usually implemented for the particular environment in which the EDR is deployed
    rather than being part of the EDR’s default configuration. Some might even be
    outdated. Say you discover an old rule allowing all outbound traffic on TCP port
    443 to a certain domain. If the domain has expired, you may be able to purchase
    it and use it as an HTTPS command-and-control channel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为绕过技术因供应商和环境的不同而有所不同，尝试查找那些明确允许流量到达特定目标的规则。根据我的经验，这些通常是针对特定环境部署EDR时实施的，而不是EDR的默认配置。有些规则甚至可能是过时的。比如你发现一条旧规则，允许所有到达某个域的TCP
    443端口的出站流量。如果该域已经过期，你可能可以购买该域并将其用作HTTPS命令与控制通道。
- en: Also look for specific filter configurations that you can take advantage of.
    For instance, a filter might clear the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_CLEAR_ACTION_RIGHT</samp>.
    As a result, lower-priority filters won’t be able to override this filter’s decisions.
    Now say that an EDR explicitly allows traffic to egress to a domain and clears
    the aforementioned flag. Even if a lower-priority filter issues a block, the traffic
    will still be allowed out.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还要寻找一些可以利用的特定过滤器配置。例如，一个过滤器可能会清除<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_CLEAR_ACTION_RIGHT</samp>。结果是，低优先级的过滤器将无法覆盖这个过滤器的决策。假设一个EDR明确允许流量访问某个域并清除了上述标志，即使低优先级的过滤器发出阻止命令，流量仍然会被允许离开。
- en: '(Of course, as with all things WFP, it’s not exactly that simple. There exists
    a flag, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_RIGHT_ACTION_WRITE</samp>,
    that vetoes this decision if reset prior to the evaluation of the filter. This
    is called a *filter conflict*, and it causes a few things to happen: the traffic
    is blocked, an audit event is generated, and applications subscribed to notifications
    will receive one, allowing them to become aware of the misconfiguration.)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，像所有WFP的内容一样，这并不完全那么简单。如果在评估过滤器之前重置了一个标志，<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_RIGHT_ACTION_WRITE</samp>，它将否决这一决策。这被称为*过滤器冲突*，它会导致几件事情发生：流量被阻塞，生成审计事件，订阅通知的应用程序将收到通知，从而使它们意识到配置错误。）
- en: 'In summary, evading WFP filters is a lot like evading traditional firewalls:
    we can look for gaps in the rulesets, configurations, and inspection logic implemented
    by an EDR’s network filter driver to find ways of getting our traffic out. Evaluate
    the viability of each technique in the context of the environment and each EDR’s
    particular filters. In some cases, this can be as simple as reviewing the filtering
    rules. In others, this may mean a deep dive into the driver’s inspection logic
    to determine what is being filtered and how.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，绕过WFP过滤器就像绕过传统防火墙：我们可以寻找EDR网络过滤驱动程序中规则集、配置和检查逻辑的漏洞，寻找将流量送出的方式。在特定环境和每个EDR的过滤器背景下评估每种技术的可行性。有些情况下，这可能仅仅是审查过滤规则，而在其他情况下，这可能意味着深入分析驱动程序的检查逻辑，以确定正在过滤什么内容以及如何过滤。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: Network filter drivers have the capability to allow, deny, or inspect network
    traffic on the host. Most relevant to EDR is the inspection function facilitated
    by these drivers’ callouts. When an attacker activity involves the network stack,
    such as command-and-control agent beaconing and lateral movement, a network filter
    driver sitting inline of the traffic can pick out indicators of it. Evading these
    callouts requires understanding the types of traffic they wish to inspect and
    then identifying gaps in coverage, not dissimilar to a standard firewall rule
    audit.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 网络过滤驱动程序具有允许、拒绝或检查主机上网络流量的能力。对于EDR来说，最相关的是这些驱动程序通过调用实现的检查功能。当攻击者的活动涉及网络堆栈时，比如命令和控制代理信标或横向移动，位于流量中的网络过滤驱动程序可以识别出其指示符。绕过这些调用要求理解它们希望检查的流量类型，并识别覆盖中的漏洞，这与标准防火墙规则审计并无太大区别。
