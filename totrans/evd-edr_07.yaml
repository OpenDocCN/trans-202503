- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NETWORK
    FILTER DRIVERS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes an EDR must implement its own sensor to capture the telemetry data
    generated by certain system components. Filesystem minifilters are one example
    of this. In Windows, the network stack is no different.
  prefs: []
  type: TYPE_NORMAL
- en: A host-based security agent might wish to capture network telemetry for many
    reasons. Network traffic is tied to the most common way for an attacker to gain
    initial access to a system (for example, when a user visits a malicious website).
    It’s also one of the key artifacts created when they perform lateral movement
    to jump from one host to another. If an endpoint security product wishes to capture
    and perform inspection on network packets, it’ll most likely implement some type
    of network filter driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers one of the most common driver frameworks used to capture
    network telemetry: Windows Filtering Platform (WFP). The Windows network stack
    and driver ecosystem can be a little overwhelming for newcomers, so to reduce
    the likelihood of headaches, we’ll briefly introduce core concepts and then focus
    only on the elements relevant to an EDR’s sensor.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Network-Based vs. Endpoint-Based Monitoring</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might assume that the best way to detect malicious traffic is to use a network-based
    security appliance, but this isn’t always the case. The efficacy of these network
    appliances depends on their position in the network. For example, a network intrusion
    detection system (NIDS) would need to sit between host A and host B in order to
    detect lateral movement between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the adversary must cross core network boundaries (for example,
    to move from the VPN subnet into the data center subnet). In those situations,
    the security engineers can strategically deploy the appliance at a logical choke
    point through which all that traffic must flow. This boundary-oriented architecture
    would look similar to the one shown in [Figure 7-1](#fig7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A NIDS between
    two networks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: But what about intra-subnet lateral movement, such as movement from workstation
    to workstation? It wouldn’t be cost-effective to deploy a network-monitoring appliance
    between every node on the local network, but security teams still need that telemetry
    to detect adversarial activities in their networks.
  prefs: []
  type: TYPE_NORMAL
- en: This is where an endpoint-based traffic-monitoring sensor comes into play. By
    deploying a monitoring sensor on every client, a security team can solve the problem
    of where in the network to insert their appliance. After all, if the sensor is
    monitoring traffic on a client, as shown in [Figure 7-2](#fig7-2), it effectively
    has a man-in-the-middle relationship between the client and all other systems
    the client may communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Endpoint network
    monitoring</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using endpoint-based monitoring offers another valuable advantage over network-based
    solutions: context. Because the agent running on the endpoint can collect additional
    host-based information, it can paint a more complete picture of how and why the
    network traffic was created. For example, it could determine that a child process
    of *outlook.exe* with a certain PID is communicating with a content distribution
    network endpoint once every 60 seconds; this might be command-and-control beaconing
    from a process tied to initial access.'
  prefs: []
  type: TYPE_NORMAL
- en: The host-based sensor can get data related to the originating process, user
    context, and activities that occurred before the connection happened. By contrast,
    an appliance deployed on the network would be able to see only the metrics about
    the connection, such as its source and destination, packet frequency, and protocol.
    While this can provide valuable data to responders, it misses key pieces of information
    that would aid their investigation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Legacy Network Driver Interface Specification
    Drivers</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many types of network drivers, most of which are backed by the Network
    Driver Interface Specification (NDIS). NDIS is a library that abstracts a device’s
    network hardware. It also defines a standard interface between *layered* network
    drivers (those operating at different network layers and levels of the operating
    system) and maintains state information. NDIS supports four types of drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Miniport**   Manages a network interface card, such as by sending and receiving
    data. This is the lowest level of NDIS drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol**   Implements a transport protocol stack, such as TCP/IP. This
    is the highest level of NDIS drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter**   Sits between miniport and protocol drivers to monitor and modify
    the interactions between the two subtypes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intermediate**   Sits between miniport and protocol drivers to expose both
    drivers’ entry points for communicating requests. These drivers expose a virtual
    adapter to which the protocol driver sends its packets. The intermediate driver
    then ships these packets to the appropriate miniport. After the miniport completes
    its operation, the intermediate driver passes the information back to the protocol
    driver. These drivers are commonly used for load-balancing traffic across more
    than one network interface card.'
  prefs: []
  type: TYPE_NORMAL
- en: The interactions of these drivers with NDIS can be seen in the (grossly oversimplified)
    diagram in [Figure 7-3](#fig7-3).
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of security monitoring, filter drivers work best, as they can
    catch network traffic at the lowest levels of the network stack, just before it
    is passed to the miniport and associated network interface card. However, these
    drivers pose some challenges, such as significant code complexity, limited support
    for the network and transport layers, and a difficult installation process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: NDIS driver relationships</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'But perhaps the biggest issue with filter drivers when it comes to security
    monitoring is their lack of context. While they can capture the traffic being
    processed, they aren’t aware of the caller context (the process that initiated
    the request) and lack the metadata needed to provide valuable telemetry to the
    EDR agent. For this reason, EDRs nearly always use another framework: the Windows
    Filtering Platform (WFP).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows Filtering Platform</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WFP is a set of APIs and services for creating network-filtering applications,
    and it includes both user-mode and kernel-mode components. It was designed to
    replace legacy filtering technologies, including the NDIS filters, starting in
    Windows Vista and Server 2008\. While WFP has some downsides when it comes to
    network performance, it is generally considered the best option for creating filter
    drivers. Even the Windows firewall itself is built on WFP.
  prefs: []
  type: TYPE_NORMAL
- en: The platform offers numerous benefits. It allows EDRs to filter traffic related
    to specific applications, users, connections, network interface cards, and ports.
    It supports both IPv4 and IPv6, provides boot-time security until the base filtering
    engine has started, and lets drivers filter, modify, and reinject traffic. It
    can also process pre- and post-decryption IPsec packets and integrates hardware
    offloading, allowing filter drivers to use hardware for packet inspection.
  prefs: []
  type: TYPE_NORMAL
- en: WFP’s implementation can be tricky to understand, as it has a complex architecture
    and uses unique names for its core components, which are distributed across both
    user mode and kernel mode. The WFP architecture looks something like what is shown
    in [Figure 7-4](#fig7-4).
  prefs: []
  type: TYPE_NORMAL
- en: To make sense of all this, let’s follow part of a TCP stream coming from a client
    connected to a server on the internet. The client begins by calling a function
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!send()</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!WSASend()</samp> to send
    data over a connected socket. These functions eventually pass the packet down
    to the network stack provided by *tcpip.sys* for IPv4 and *tcpip6.sys* for IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: As the packet traverses the network stack, it is passed to a shim associated
    with the relevant layer of the stack, such as the stream layer. *Shims* are kernel
    components that have a few critical jobs. One of their first responsibilities
    is to extract data and properties from the packet and pass them to the filter
    engine to start the process of applying filters.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: The WFP architecture</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Filter Engine</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The filter engine, sometimes called the *generic filter engine* to avoid confusion
    with the user-mode *base filtering engine*, performs filtering at the network
    and transport layers. It contains layers of its own, which are containers used
    to organize filters into sets. Each of these layers, defined as GUIDs under the
    hood, has a schema that says what types of filters may be added to it. Layers
    may be further divided into sublayers that manage filtering conflicts. (For example,
    imagine that the rules “open port 1028” and “block all ports greater than 1024”
    were configured on the same host.) All layers inherit default sublayers, and developers
    can add their own.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter Arbitration</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering how the filter engine knows the order in which to evaluate
    sublayers and filters. If rules were applied to traffic in a random order, this
    could cause huge problems. For example, say the first rule was a default-deny
    that dropped all traffic. To address this problem, both sublayers and filters
    can be assigned a priority value, called a *weight*, that dictates the order in
    which they should be processed by the filter manager. This ordering logic is called
    *filter arbitration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'During filter arbitration, filters evaluate the data parsed from the packet
    from highest to lowest priority to determine what to do with the packet. Each
    filter contains conditions and an action, just like common firewall rules (for
    example, “if the destination port is 4444, block the packet” or “if the application
    is *edge.exe*, allow the packet”). The basic actions a filter can return are *Block*
    and *Permit*, but three other supported actions pass packet details to callout
    drivers: <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_TERMINATING</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_UNKNOWN</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Callout Drivers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Callout drivers are third-party drivers that extend WFP’s filtering functionality
    beyond that of the base filters. These drivers provide advanced features such
    as deep-packet inspection, parental controls, and data logging. When an EDR vendor
    is interested in capturing network traffic, it typically deploys a callout driver
    to monitor the system.
  prefs: []
  type: TYPE_NORMAL
- en: Like basic filters, callout drivers can select the types of traffic that they’re
    interested in. When the callout drivers associated with a particular operation
    are invoked, they can suggest action be taken on the packet based on their unique
    internal processing logic. A callout driver can permit some traffic, block it,
    continue it (meaning pass it to other callout drivers), defer it, drop it, or
    do nothing. These actions are only suggestions, and the driver might override
    them during the filter arbitration process.
  prefs: []
  type: TYPE_NORMAL
- en: When filter arbitration ends, the result is returned to the shim, which acts
    on the final filtering decision (for example, permitting the packet to leave the
    host).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Implementing a WFP Callout Driver</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an EDR product wants to intercept and process network traffic on a host,
    it most likely uses a WFP callout driver. These drivers must follow a somewhat
    complex workflow to set up their callout function, but the flow should make sense
    to you when you consider how packets traverse the network stack and filter manager.
    These drivers are also substantially easier to work with than their legacy NDIS
    counterparts, and Microsoft’s documentation should be very helpful for EDR developers
    looking to add this capability to their sensor lineup.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening a Filter
    Engine Session</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other types of drivers, WFP callout drivers begin their initialization
    inside their internal <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp>
    function. One of the first things the callout driver will do, an activity unique
    to WFP, is open a session with the filter engine. To do this, the driver calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmEngineOpen()</samp>,
    defined in [Listing 7-1](#list7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpmEngineOpen()</samp>
    function definition'
  prefs: []
  type: TYPE_NORMAL
- en: The most notable argument passed to this function as input is <samp class="SANS_TheSansMonoCd_W5Regular_11">authnService</samp>,
    which determines the authentication service to use. This can be either <samp class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_WINNT</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_DEFAULT</samp>, both
    of which essentially just tell the driver to use NTLM authentication. When this
    function completes successfully, a handle to the filter engine is returned through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">engineHandle</samp> parameter
    and typically preserved in a global variable, as the driver will need it during
    its unloading process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering Callouts</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, the driver registers its callouts. This is done through a call to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmCalloutRegister()</samp>
    API. Systems running Windows 8 or later will convert this function to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpsCalloutRegister2()</samp>,
    the definition of which is included in [Listing 7-2](#list7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpsCalloutRegister2()</samp>
    function definition'
  prefs: []
  type: TYPE_NORMAL
- en: The pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_CALLOUT2</samp>
    structure passed as input to this function (via its <samp class="SANS_TheSansMonoCd_W5Regular_11">callout</samp>
    parameter) contains details about the functions internal to the callout driver
    that will handle the filtering of packets. It is defined in [Listing 7-3](#list7-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_CALLOUT2</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">notifyFn</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">flowDeleteFn</samp> members are callout
    functions used to notify the driver when there is information to be passed related
    to the callout itself or when the data that the callout is processing has been
    terminated, respectively. Because these callout functions aren’t particularly
    relevant to detection efforts, we won’t cover them in further detail. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">classifyFn</samp> member, however, is
    a pointer to the function invoked whenever there is a packet to be processed,
    and it contains the bulk of the logic used for inspection. We’ll cover these callouts
    in “Detecting Adversary Tradecraft with Network Filters” on [page 135](#sec14).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Callout
    Function to the Filter Engine</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we’ve defined the callout function, we can add it to the filter engine
    by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmCalloutAdd()</samp>,
    passing the engine handle obtained earlier and a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_CALLOUT</samp>
    structure, shown in [Listing 7-4](#list7-4), as input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_CALLOUT</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: This structure contains data about the callout, such as its optional friendly
    name and description in its <samp class="SANS_TheSansMonoCd_W5Regular_11">displayData</samp>
    member, as well as the layers to which the callout should be assigned (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_STREAM_V4</samp> for
    IPv4 streams). Microsoft documents dozens of filter layer identifiers, each of
    which usually has IPv4 and IPv6 variants. When the function used by the driver
    to add its callout completes, it returns a runtime identifier for the callout
    that is preserved for use during unloading.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike filter layers, a developer may add their own sublayers to the system.
    In those cases, the driver will call <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmSublayerAdd()</samp>,
    which receives the engine handle, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER</samp>
    structure, and an optional security descriptor. The structure passed as input
    includes the sublayer key, a <samp class="SANS_TheSansMonoCd_W5Regular_11">GUID</samp>
    to uniquely identify the sublayer, an optional friendly name and description,
    an optional flag to ensure that the sublayer persists between reboots, the sublayer
    weight, and other members that contain the state associated with a sublayer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a New Filter
    Object</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last action a callout driver performs is adding a new filter object to the
    system. This filter object is the rule that the driver will evaluate when processing
    the connection. To create one, the driver calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>,
    passing in the engine handle, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp>
    structure shown in [Listing 7-5](#list7-5), and an optional pointer to a security
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure
    contains a few key members worth highlighting. The <samp class="SANS_TheSansMonoCd_W5Regular_11">flags</samp>
    member contains several flags that describe attributes of the filter, such as
    whether the filter should persist through system reboots (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_PERSISTENT</samp>)
    or if it is a boot-time filter (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_BOOTTIME</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp> member defines
    the priority value of the filter in relation to other filters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">numFilterConditions</samp>
    is the number of filtering conditions specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>
    member, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_CONDITION</samp>
    structures that describe all the filtering conditions. For the callout functions
    to process the event, all conditions must be true. Lastly, <samp class="SANS_TheSansMonoCd_W5Regular_11">action</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_TYPE</samp> value
    indicating what action to perform if all filtering conditions return true. These
    actions include permitting, blocking, or passing the request to a callout function.
  prefs: []
  type: TYPE_NORMAL
- en: Of these members, <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>
    is the most important, as each filter condition in the array represents a discrete
    “rule” against which the connections will be evaluated. Each rule is itself made
    up of a condition value and match type. The definition for this structure is shown
    in [Listing 7-6](#list7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER_CONDITION</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: The first member, <samp class="SANS_TheSansMonoCd_W5Regular_11">fieldKey</samp>,
    indicates the attribute to evaluate. Each filtering layer has its own attributes,
    identified by GUIDs. For example, a filter inserted in the stream layer can work
    with local and remote IP addresses and ports, traffic direction (whether inbound
    or outbound), and flags (for example, if the connection is using a proxy).
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">matchType</samp> member specifies
    the type of match to be performed. These comparison types are defined in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWP_MATCH_TYPE</samp> enumeration shown
    in [Listing 7-7](#list7-7) and can match strings, integers, ranges, and other
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_MATCH_TYPE</samp>
    enumeration'
  prefs: []
  type: TYPE_NORMAL
- en: The last member of the structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">conditionValue</samp>,
    is the condition against which the connection should be matched. The filter condition
    value is composed of two parts, the data type and a condition value, housed together
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_CONDITION_VALUE</samp>
    structure, shown in [Listing 7-8](#list7-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_CONDITION_VALUE</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_DATA_TYPE</samp> value
    indicates what union member the driver should use to evaluate the data. For instance,
    if the type member is <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_V4_ADDR_MASK</samp>,
    which maps to an IPv4 address, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">v4AddrMask</samp>
    member would be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The match type and condition value members form a discrete filtering requirement
    when combined. For example, this requirement could be “if the destination IP address
    is 1.1.1.1” or “if the TCP port is greater than 1024.” What should happen when
    the condition evaluates as true? To determine this, we use the action member of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure.
    In callout drivers that perform firewalling activities, we could choose to permit
    or block traffic based on certain attributes. In the context of security monitoring,
    however, most developers forward the request to the callout functions by specifying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp>
    flag, which passes the request to the callout without expecting the callout to
    make a permit/deny decision regarding the connection.
  prefs: []
  type: TYPE_NORMAL
- en: If we combine all three components of the <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp>
    member, we could represent a filtering condition as a complete sentence, such
    as the one shown in [Figure 7-5](#fig7-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Filtering conditions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have our rule’s basic “if this, do that” logic, but we have
    yet to deal with some other conditions related to filter arbitration.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Weights
    and Sublayers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if our driver has filters to, say, both permit traffic on TCP port 1080
    and block outbound connections on TCP ports greater than 1024? To handle these
    conflicts, we must assign each filter a weight. The greater the weight, the higher
    the priority of the condition, and the earlier it should be evaluated. For instance,
    the filter allowing traffic on port 1080 should be evaluated before the one blocking
    all traffic using ports higher than 1024 to permit software using port 1080 to
    function. In code, a weight is just an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">UINT8</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT64</samp>)
    assigned in the weight member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp>
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to assigning the weight, we need to assign the filter to a sublayer
    so that it is evaluated at the correct time. We do this by specifying a GUID in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">layerKey</samp> member of the
    structure. If we created our own sublayer, we would specify its GUID here. Otherwise,
    we’d use one of the default sublayer GUIDs listed in [Table 7-1](#tab7-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Default
    Sublayer GUIDs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Filter sublayer identifier</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Filter type</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_EDGE_TRAVERSAL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(BA69DC66-5176-4979-9C89-26A7B46A8327)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Edge traversal</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_INSPECTION</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(877519E1-E6A9-41A5-81B4-8C4F118E4A60)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Inspection</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_DOSP</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(E076D572-5D3D-48EF-802B-909EDDB098BD)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec denial-of-service (DoS) protection</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">_TUNNEL</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(A5082E73-8F71-4559-8A9A-101CEA04EF87)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec forward outbound tunnel</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_TUNNEL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(83F299ED-9FF4-4967-AFF4-C309F4DAB827)</samp>
    | <samp class="SANS_Futura_Std_Book_11">IPsec tunnel</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_LIPS</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1B75C0CE-FF60-4711-A70F-B4958CC3B2D0)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Legacy IPsec filters</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_RPC_AUDIT</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(758C84F4-FB48-4DE9-9AEB-3ED9551AB1FD)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Remote procedure call (RPC) audit</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_SECURE_SOCKET</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(15A66E17-3F3C-4F7B-AA6C-812AA613DD82)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Secure socket</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(337608B9-B7D5-4D5F-82F9-3618618BC058)</samp>
    | <samp class="SANS_Futura_Std_Book_11">TCP Chimney Offload</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_TEMPLATES</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(24421DCF-0AC5-4CAA-9E14-50F6E3636AF0)</samp>
    | <samp class="SANS_Futura_Std_Book_11">TCP template</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_UNIVERSAL</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(EEBECC03-CED4-4380-819A-2734397B2B74)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Those not assigned to any other sublayers</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_SECURITY_REALM</samp>
    sublayer identifier is defined in the *fwpmu.h* header but is undocumented.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a Security
    Descriptor</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last parameter we can pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>
    is a security descriptor. While optional, it allows the developer to explicitly
    set the access control list for their filter. Otherwise, the function will apply
    a default value to the filter. This default security descriptor grants <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    rights to members of the Local Administrators group, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>
    rights to members of the Network Configuration Operators group, as well as the
    diagnostic service host (*WdiServiceHost*), IPsec policy agent (*PolicyAgent*),
    network list service (*NetProfm*), remote procedure call (*RpcSs*), and Windows
    firewall (*MpsSvc*) services. Lastly, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_OPEN</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_CLASSIFY</samp> are
    granted to the Everyone group.
  prefs: []
  type: TYPE_NORMAL
- en: After the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>
    completes, the callout driver has been initialized, and it will process events
    until the driver is ready to be unloaded. The unloading process is outside the
    scope of this chapter, as it is largely irrelevant to security monitoring, but
    it closes all the previously opened handles, deletes created sublayers and filters,
    and safely removes the driver.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Adversary Tradecraft with
    Network Filters</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bulk of the telemetry that a WFP filter driver collects comes from its callouts.
    These are most often *classify* callouts, which receive information about the
    connection as input. From this data, developers can extract telemetry useful for
    detecting malicious activity. Let’s explore these functions further, starting
    with their definition in [Listing 7-9](#list7-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FwpsCalloutClassifyFn</samp>
    definition'
  prefs: []
  type: TYPE_NORMAL
- en: On invocation, the callout receives pointers to a few structures containing
    interesting details about the data being processed. These details include the
    basic network information you’d expect to receive from any packet-capturing application
    (the remote IP address, for example) and metadata that provides additional context,
    including the requesting process’s PID, image path, and token.
  prefs: []
  type: TYPE_NORMAL
- en: In return, the callout function will set the action for the stream-layer shim
    to take (assuming the packet being processed is in the stream layer), as well
    as an action for the filter engine to take, such as to block or allow the packet.
    It might also defer the decision-making to the next registered callout function.
    We describe this process in greater detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Basic Network
    Data</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first parameter, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_VALUES</samp>
    structure, is defined in [Listing 7-10](#list7-10) and contains information about
    the connection that has been passed from the filter engine to the callout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_VALUES</samp>
    structure'
  prefs: []
  type: TYPE_NORMAL
- en: The first member of this structure contains the identifier of the filter layer
    at which the data was obtained. Microsoft defines these values (for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_INBOUND_IPPACKET_V4</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: The second member contains the number of entries in the array pointed to by
    the third parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">incomingValue</samp>.
    This is an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS _INCOMING_VALUE</samp>
    structures containing the data that the filter engine passes to the callout. Each
    structure in the array has only an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp>
    structure, shown in [Listing 7-11](#list7-11), that describes the type and value
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_VALUE</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: To access the data inside the array, the driver needs to know the index at which
    the data resides. This index varies based on the layer identifier being processed.
    For instance, if the layer is <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_LAYER_OUTBOUND_IPPACKET_V4</samp>,
    the driver would access fields based on their index in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp>
    enumeration, defined in [Listing 7-12](#list7-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp>
    enumeration'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an EDR’s driver wanted to inspect the remote IP address, it
    could access this value using the code in [Listing 7-13](#list7-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-13: Accessing the remote IP address in the incoming values'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the EDR driver extracts the IP address by referencing the unsigned
    32-bit integer (<samp class="SANS_TheSansMonoCd_W5Regular_11">uint32</samp>) value
    at the index <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS</samp>
    in the incoming values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Metadata</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next parameter that the callout function receives is a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_METADATA_VALUES0</samp>
    structure, which provides incredibly valuable metadata to an EDR, beyond the information
    you’d expect to get from a packet-capture application such as Wireshark. You can
    see this metadata in [Listing 7-14](#list7-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_METADATA_VALUES0</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that one of the main benefits to monitoring network traffic on
    each endpoint is the context that this approach provides to the EDR. We can see
    this in the <samp class="SANS_TheSansMonoCd_W5Regular_11">processPath</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">processId</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">token</samp>
    members, which give us information about the endpoint process and the associated
    principal.
  prefs: []
  type: TYPE_NORMAL
- en: Note that not all values in this structure will be populated. To see which values
    are present, the callout function checks the <samp class="SANS_TheSansMonoCd_W5Regular_11">currentMetadataValues</samp>
    member, which is a bitwise-OR of a combination of metadata filter identifiers.
    Microsoft nicely provided us with a macro, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_IS_METADATA_FIELD_PRESENT()</samp>,
    that will return true if the value we’re interested in is present.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Layer Data</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the metadata, the classify function receives information about the layer
    being filtered and the conditions under which the callout is invoked. For example,
    if the data originates from the stream layer, the parameter will point to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_CALLOUT_IO_PACKET0</samp>
    structure. This layer data contains a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_DATA0</samp>
    structure, which contains flags that encode the characteristics of the stream
    (for example, whether it is inbound or outbound, whether it is high priority,
    and whether the network stack will pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">FIN</samp>
    flag in the final packet). It will also contain the offset to the stream, the
    size of its data in the stream, and a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp>
    that describes the current portion of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: This buffer list is a linked list of <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER</samp>
    structures. Each structure in the list contains a chain of memory descriptor lists
    used to hold the data sent or received over the network. Note that if the request
    didn’t originate from the stream layer, the <samp class="SANS_TheSansMonoCd_W5Regular_11">layerData</samp>
    parameter will point only to a <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp>,
    assuming it is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layer data structure also contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp>
    member, which is an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_TYPE</samp>
    value describing an action that the callout recommends the stream-layer shim take.
    These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Doing nothing (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NONE</samp>).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing all future data segments in the flow to continue without inspection
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_ALLOW_CONNECTION</samp>).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting more data. If this is set, the callout must populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">countBytesRequired</samp>
    member with the number of bytes of stream data required (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NEED_MORE_DATA</samp>).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropping the connection (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DROP_CONNECTION</samp>).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferring processing until <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpkclnt!FwpsStreamContinue0()</samp>
    is called. This is used for flow control, to slow down the rate of incoming data
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DEFER</samp>).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t confuse this <samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp>
    member with the <samp class="SANS_TheSansMonoCd_W5Regular_11">classifyOut</samp>
    parameter passed to the classify function to indicate the result of the filtering
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Network Filters</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re probably interested in evading network filters primarily because you’d
    like to get your command-and-control traffic to the internet, but other types
    of traffic are subject to filtering too, such as lateral movement and network
    reconnaissance.
  prefs: []
  type: TYPE_NORMAL
- en: However, when it comes to evading WFP callout drivers, there aren’t many options
    (at least not compared to those available for other sensor components). In a lot
    of ways, evading network filters is very similar to performing a standard firewall
    rule assessment. Some filters may opt to explicitly permit or deny traffic, or
    they may send the contents off for inspection by a callout.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other type of rule-coverage analysis, the bulk of the work comes
    down to enumerating the various filters on the system, their configurations, and
    their rulesets. Thankfully, many available tools can make this process relatively
    painless. The built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">netsh</samp>
    command allows you to export the currently registered filters as an XML document,
    an example of which is shown in [Listing 7-15](#list7-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-15: Enumerating registered filters with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">netsh</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because parsing XML can cause some headaches, you might prefer to use an alternative
    tool, NtObjectManager. It includes cmdlets for collecting information related
    to WFP components, including sublayer identifiers and filters.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first actions you should perform to get an idea of what drivers are
    inspecting traffic on the system is to list all the non-default sublayers. You
    can do this using the commands shown in [Listing 7-16](#list7-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-16: Enumerating WFP sublayers using NtObjectManager'
  prefs: []
  type: TYPE_NORMAL
- en: The weights indicate the order in which the sublayers will be evaluated during
    filter arbitration. Look for interesting sublayers worth exploring further, such
    as those associated with applications that provide security monitoring. Then,
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwFilter</samp> cmdlet,
    return filters associated with the specified sublayer, as shown in [Listing 7-17](#list7-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-17: Enumerating filters associated with a subfilter layer'
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, the most interesting filter in this layer is <samp class="SANS_TheSansMonoCd_W5Regular_11">CalloutInspection</samp>,
    as it sends the contents of the network connection to the driver, which will determine
    whether to terminate the connection. You can inspect callouts by passing their
    key names to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwCallout</samp>
    cmdlet. [Listing 7-18](#list7-18) shows the process of investigating one of Windows
    Defender’s filters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-18: Using NtObjectManager to inspect WFP filters'
  prefs: []
  type: TYPE_NORMAL
- en: This information helps us determine the type of traffic being inspected, as
    it includes the layer for which the callout is registered; a description that
    could make understanding the purpose of the callout more easily identifiable;
    and the security descriptor, which can be audited to find any potential misconfigurations
    that would grant excessive control over it. But it still doesn’t tell us exactly
    what the driver is looking for. No two EDR vendors will inspect the same attributes
    in the same way, so the only way to know what a driver is examining is to reverse
    engineer its callout routines.
  prefs: []
  type: TYPE_NORMAL
- en: We can, however, assess WFP filters by looking for configuration gaps like those
    found in standard firewalls. After all, why bother reverse-engineering a driver
    when we could just look for rules to abuse? One of my favorite ways of evading
    detection is to find gaps that allow the traffic to slip through. For example,
    if a callout only monitors IPv4 traffic, traffic sent using IPv6 won’t be inspected.
  prefs: []
  type: TYPE_NORMAL
- en: Because bypasses vary between vendors and environments, try looking for rules
    that explicitly allow traffic to a certain destination. In my experience, these
    are usually implemented for the particular environment in which the EDR is deployed
    rather than being part of the EDR’s default configuration. Some might even be
    outdated. Say you discover an old rule allowing all outbound traffic on TCP port
    443 to a certain domain. If the domain has expired, you may be able to purchase
    it and use it as an HTTPS command-and-control channel.
  prefs: []
  type: TYPE_NORMAL
- en: Also look for specific filter configurations that you can take advantage of.
    For instance, a filter might clear the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_CLEAR_ACTION_RIGHT</samp>.
    As a result, lower-priority filters won’t be able to override this filter’s decisions.
    Now say that an EDR explicitly allows traffic to egress to a domain and clears
    the aforementioned flag. Even if a lower-priority filter issues a block, the traffic
    will still be allowed out.
  prefs: []
  type: TYPE_NORMAL
- en: '(Of course, as with all things WFP, it’s not exactly that simple. There exists
    a flag, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_RIGHT_ACTION_WRITE</samp>,
    that vetoes this decision if reset prior to the evaluation of the filter. This
    is called a *filter conflict*, and it causes a few things to happen: the traffic
    is blocked, an audit event is generated, and applications subscribed to notifications
    will receive one, allowing them to become aware of the misconfiguration.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, evading WFP filters is a lot like evading traditional firewalls:
    we can look for gaps in the rulesets, configurations, and inspection logic implemented
    by an EDR’s network filter driver to find ways of getting our traffic out. Evaluate
    the viability of each technique in the context of the environment and each EDR’s
    particular filters. In some cases, this can be as simple as reviewing the filtering
    rules. In others, this may mean a deep dive into the driver’s inspection logic
    to determine what is being filtered and how.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network filter drivers have the capability to allow, deny, or inspect network
    traffic on the host. Most relevant to EDR is the inspection function facilitated
    by these drivers’ callouts. When an attacker activity involves the network stack,
    such as command-and-control agent beaconing and lateral movement, a network filter
    driver sitting inline of the traffic can pick out indicators of it. Evading these
    callouts requires understanding the types of traffic they wish to inspect and
    then identifying gaps in coverage, not dissimilar to a standard firewall rule
    audit.
  prefs: []
  type: TYPE_NORMAL
