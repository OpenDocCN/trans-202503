<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_231"/><span class="big">16</span><br/>INSTALLING AN OPERATING SYSTEM</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">In the preceding chapter, you set up your PowerLab module so that it’s ready to go. Now, you’ll take the next step in your automation journey: learning to automate installation of the operating system. Since you have a VM created with a VHD attached, you need to install</span> Windows. To do this, you’ll use a Windows Server ISO file, the <em>Convert-WindowsImage.ps1</em> PowerShell script, and a whole lot of scripting to create a hands-off, completely automated deployment of Windows!</p>&#13;
<h3 class="h3" id="ch16lev1">Prerequisites</h3>&#13;
<p class="noindent">I’m assuming that you followed along from the preceding chapter and have those prerequisites met. Here, you’ll need a few more things in order to keep up. First, since you’ll be deploying an operating system, you need a Windows Server 2016 ISO. A free trial is available at <a href="http://bit.ly/2r5TPRP"><em>http://bit.ly/2r5TPRP</em></a> once you log in with a free Microsoft account.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_232"/>From the preceding chapter, I’m expecting that you have a <em>C:\PowerLab</em> folder created on your Hyper-V server. Now you should make an ISOs subfolder, <em>C:\PowerLab\ISOs</em>, containing your Windows Server 2016 ISO. At the time of this writing, the ISO filename is <em>en_windows_server_2016_x64_dvd_9718492.iso</em>. You’ll use this file path in your scripts, so if yours is different, make sure to update the script code accordingly.</p>&#13;
<p class="indent">You also need to have the <em>Convert-WindowsImage.ps1</em> PowerShell script in your PowerLab module folder. If you downloaded the book’s resources, this script will come with the chapter’s resources.</p>&#13;
<p class="indent">A few more things: I’m expecting you to have the LABDC VM that you made in the preceding chapter on the Hyper-V server. You’ll use this as the place to associate your newly created virtual disk.</p>&#13;
<p class="indent">And finally, you need the unattended XML answer file (also available via the chapter’s downloadable resources) called <em>LABDC.xml</em> in the PowerLab module folder.</p>&#13;
<p class="indent">As always, go ahead and run the chapter’s associated <em>Prerequisites.Tests</em><em>.ps1</em> Pester test script to ensure that you meet all the prerequisites ahead of time.</p>&#13;
<h3 class="h3" id="ch16lev2">OS Deployments</h3>&#13;
<p class="noindent">When it comes to automating OS deployments, you’ll work with three basic components:</p>&#13;
<ul>&#13;
<li><p class="noindent">An ISO file containing the bits for the OS</p></li>&#13;
<li><p class="noindent">An answer file providing all the input you’d normally enter manually during install time</p></li>&#13;
<li><p class="noindent">Microsoft’s PowerShell script that converts the ISO file to a VHDX</p></li>&#13;
</ul>&#13;
<p class="indent">Your job is to figure out a way to stitch all these components together. Most of the heavy lifting is done by the answer file and the ISO conversion script. What you need to do is create a small script ensuring that the conversion script gets called with the appropriate parameters and attaches the newly created VHD to the appropriate VM.</p>&#13;
<p class="indent">You can follow along with this script called <em>Install-LABDCOperatingSystem.ps1</em> in the downloaded resources.</p>&#13;
<h4 class="h4" id="ch16lev2sec1">Creating the VHDX</h4>&#13;
<p class="noindent">The LABDC VM will have a 40GB, dynamic, VHDX disk-partitioned GUID Partition Table (GPT) running Windows Server 2016 Standard Core. The conversion script will need this information. It will also need to know the path to the source ISO, and the path to the unattended answer file.</p>&#13;
<p class="indent">First, define the paths to the ISO file and the prefilled answer file:</p>&#13;
<pre>$isoFilePath = 'C:\PowerLab\ISOs\en_windows_server_2016_x64_dvd_9718492.iso'&#13;
$answerFilePath = 'C:\PowerShellForSysAdmins\PartII\Automating Operating System Installs\LABDC.xml'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_233"/>Next, you’ll build all the parameters for the conversion script. Using PowerShell’s splatting technique, you can create a single hashtable and define all these parameters as one. This method of defining and passing parameters to commands is much cleaner than typing out every parameter on a single line:</p>&#13;
<pre>$convertParams = @{&#13;
    SourcePath        = $isoFilePath&#13;
    SizeBytes         = 40GB&#13;
    Edition           = 'ServerStandardCore'&#13;
    VHDFormat         = 'VHDX'&#13;
    VHDPath           = 'C:\PowerLab\VHDs\LABDC.vhdx'&#13;
    VHDType           = 'Dynamic'&#13;
    VHDPartitionStyle = 'GPT'&#13;
    UnattendPath      = $answerFilePath&#13;
}</pre>&#13;
<p class="indent">Once all the parameters are defined for the conversion script, you’ll dot source the <em>Convert-WindowsImage.ps1</em> script. You don’t want to call this conversion script directly because it contains a function also called <span class="literal">Convert-WindowsImage</span>. If you were to simply execute the <em>Convert-WindowsImage.ps1</em> script, nothing would happen because it would just be loading the function inside the script.</p>&#13;
<p class="indent"><em>Dot sourcing</em> is a way to load the function into memory to use it for later; it loads all functions defined in the script in the current session but doesn’t actually execute them. Here’s how to dot source the <em>Convert-WindowsImage.pst1</em> script:</p>&#13;
<pre>. "$PSScriptRoot\Convert-WindowsImage.ps1"</pre>&#13;
<p class="indent">Take a look at this code. There’s a new variable: <span class="literal">$PSScriptRoot</span>. This is an automatic variable representing the folder path in which the script resides. In this example, since the <em>Convert-WindowsImage.ps1</em> script is in the same folder as the PowerLab module, you’re referencing that script in the PowerLab module.</p>&#13;
<p class="indent">Once the conversion script has been dot sourced into the session, you have the ability to call the functions that were inside it, including <span class="literal">Convert-WindowsImage</span>. This function will do all the dirty work for you: it’ll open the ISO file, appropriately format a new virtual disk, set a boot volume, inject the answer file you provided it, and end up with a VHDX file that has a fresh copy of Windows ready for you to boot up!</p>&#13;
<pre>Convert-WindowsImage @convertParams&#13;
&#13;
Windows(R) Image to Virtual Hard Disk Converter for Windows(R) 10&#13;
Copyright (C) Microsoft Corporation.  All rights reserved.&#13;
Version 10.0.9000.0.amd64fre.fbl_core1_hyp_dev(mikekol).141224-3000 Beta&#13;
&#13;
INFO   : Opening ISO en_windows_server_2016_x64_dvd_9718492.iso...&#13;
INFO   : Looking for E:\sources\install.wim...&#13;
<span epub:type="pagebreak" id="page_234"/>INFO   : Image 1 selected (ServerStandardCore)...&#13;
INFO   : Creating sparse disk...&#13;
INFO   : Attaching VHDX...&#13;
INFO   : Disk initialized with GPT...&#13;
INFO   : Disk partitioned&#13;
INFO   : System Partition created&#13;
INFO   : Boot Partition created&#13;
INFO   : System Volume formatted (with DiskPart)...&#13;
INFO   : Boot Volume formatted (with Format-Volume)...&#13;
INFO   : Access path (F:\) has been assigned to the System Volume...&#13;
INFO   : Access path (G:\) has been assigned to the Boot Volume...&#13;
INFO   : Applying image to VHDX. This could take a while...&#13;
INFO   : Applying unattend file (LABDC.xml)...&#13;
INFO   : Signing disk...&#13;
INFO   : Image applied. Making image bootable...&#13;
INFO   : Drive is bootable. Cleaning up...&#13;
INFO   : Closing VHDX...&#13;
&#13;
INFO   : Closing Windows image...&#13;
INFO   : Closing ISO...&#13;
&#13;
INFO   : Done.</pre>&#13;
<p class="indent">Using community scripts such as <em>Convert-WindowsImage.ps1</em> is a great way to speed up development. The script saves considerable time, and since it was created by Microsoft, you can trust it. If you’re ever curious about what this script does, feel free to open it. It’s doing a lot, and I, for one, am glad we have a resource like this to automate operating system installations.</p>&#13;
<h4 class="h4" id="ch16lev2sec2">Attaching the VM</h4>&#13;
<p class="noindent">When the conversion script is complete, you should have a <em>LABDC.vhdx</em> file located in <em>C:\PowerLab\VHDs</em> that’s ready to boot. But you’re not done just yet. As is, this virtual disk isn’t attached to a VM. You have to attach this virtual disk to an existing VM (you’ll use the LABDC VM created earlier).</p>&#13;
<p class="indent">Just as you did in the preceding chapter, use the <span class="literal">Add-VmHardDiskDrive</span> function to attach the virtual disk to your VM:</p>&#13;
<pre>$vm = Get-Vm -Name 'LABDC'&#13;
Add-VMHardDiskDrive -VMName 'LABDC' -Path 'C:\PowerLab\VHDs\LABDC.vhdx'</pre>&#13;
<p class="indent">You need to boot from this disk, so let’s make sure it’s in the proper boot order. You can discover the existing boot order by using the <span class="literal">Get-VMFirmware</span> command and looking at the <span class="literal">BootOrder</span> property:</p>&#13;
<pre>$bootOrder = (Get-VMFirmware -VMName 'LABDC').Bootorder</pre>&#13;
<p class="indent">Notice that the boot order has a network boot as the first boot device. This isn’t what you want. You want the VM to boot from the disk you just created.</p>&#13;
<pre><span epub:type="pagebreak" id="page_235"/>$bootOrder.BootType&#13;
&#13;
BootType&#13;
------&#13;
Network</pre>&#13;
<p class="indent">To set the VHDX you just created as the first boot device, use the <span class="literal">Set-VMFirmware</span> command and the <span class="literal">FirstBootDevice</span> parameter:</p>&#13;
<pre>$vm | Set-VMFirmware -FirstBootDevice $vm.HardDrives[0]</pre>&#13;
<p class="indent">At this point, you should have a VM called LABDC with a virtual disk attached that will boot into Windows. Fire up the VM with <span class="codestrong">Start-VM -Name LABDC</span> and ensure that it boots into Windows successfully. If so, you’re finished!</p>&#13;
<h3 class="h3" id="ch16lev3">Automating OS Deployments</h3>&#13;
<p class="noindent">So far, you’ve successfully created a VM called LABDC that boots into Windows. Now it’s important to realize that the script you were using was specifically tailored to your single VM. In the real world, you’re rarely afforded that luxury. A great script is reusable and portable, meaning that it doesn’t need to be changed for every specific input, but instead works around a set of ever-changing parameter values.</p>&#13;
<p class="indent">Let’s take a look at the <span class="literal">Install-PowerLabOperatingSystem</span> function in the PowerLab module, found in this chapter’s downloadable resources. This function gives a good example of how to turn the <em>Install-LABDCOperatingSystem.ps1</em> script you were using into one that can be used to deploy operating systems across multiple virtual disks, all by simply changing parameter values.</p>&#13;
<p class="indent">I won’t cover the whole script in this section since we covered most of the functionality in the previous section, but I do want to point out a few differences. First, notice that you’re using more variables. Variables allow your script to be more flexible. They provide placeholders for values rather than hardcoding things directly into the code.</p>&#13;
<p class="indent">Notice, also, the conditional logic in the script. Take a look at the code in <a href="ch16.xhtml#ch16list1">Listing 16-1</a>. This is a <span class="literal">switch</span> statement that finds an ISO file path based on an operating system name. You didn’t need this in the previous script because everything was hardcoded into the script.</p>&#13;
<p class="indent">Because the <span class="literal">Install-PowerLabOperatingSystem</span> function has an <span class="literal">OperatingSystem</span> parameter, you have the flexibility needed to install different operating systems. You just need a way to account for all those operating systems. One great way to do that is a <span class="literal">switch</span> statement, which lets you easily add another condition.</p>&#13;
<pre>switch ($OperatingSystem) {&#13;
    'Server 2016' {&#13;
        $isoFilePath = "$IsoBaseFolderPath\en_windows_server_2016_x64_dvd_9718492.iso"&#13;
    }&#13;
    default {&#13;
<span epub:type="pagebreak" id="page_236"/>        throw "Unrecognized input: [$_]"&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch16list1"><em>Listing 16-1: Using the PowerShell <span class="codeitalic">switch</span> logic</em></p>&#13;
<p class="indent">You can see how you moved hardcoded values into parameters. I can’t stress this point enough: parameters are key to building reusable scripts. Avoid hardcoding as much as you can, and always keep an eye out for values that you’ll have to change at runtime (and then use a parameter for them!). But, you might wonder, what if you want to change the value of something only some of the time? Next, you can see that multiple parameters have default values. This allows you to statically set the “typical” values and then override as necessary.</p>&#13;
<pre>param&#13;
(&#13;
    [Parameter(Mandatory)]&#13;
    [string]$VmName,&#13;
&#13;
    [Parameter()]&#13;
    [string]$OperatingSystem = 'Server 2016',&#13;
&#13;
    [Parameter()]&#13;
    [ValidateSet('ServerStandardCore')]&#13;
    [string]$OperatingSystemEdition = 'ServerStandardCore',&#13;
&#13;
    [Parameter()]&#13;
    [string]$DiskSize = 40GB,&#13;
&#13;
    [Parameter()]&#13;
    [string]$VhdFormat = 'VHDX',&#13;
&#13;
    [Parameter()]&#13;
    [string]$VhdType = 'Dynamic',&#13;
&#13;
    [Parameter()]&#13;
    [string]$VhdPartitionStyle = 'GPT',&#13;
&#13;
    [Parameter()]&#13;
    [string]$VhdBaseFolderPath = 'C:\PowerLab\VHDs',&#13;
&#13;
    [Parameter()]&#13;
    [string]$IsoBaseFolderPath = 'C:\PowerLab\ISOs',&#13;
&#13;
    [Parameter()]&#13;
    [string]$VhdPath&#13;
)</pre>&#13;
<p class="indent">Using the <span class="literal">Install-PowerLabOperatingSystem</span> function, you can turn all that stuff into a single line that supports dozens of configurations. You now have a single, cohesive unit of code that you can call in many ways, all without changing a single line of the script!</p>&#13;
<h3 class="h3" id="ch16lev4"><span epub:type="pagebreak" id="page_237"/>Storing Encrypted Credentials on Disk</h3>&#13;
<p class="noindent">You’ll finish up this stage of the project soon enough, but before going any further, you need to take a slight detour. This is because you’re about to be doing things with PowerShell that require credentials. It’s common enough when scripting to have sensitive information (for example, username/password combos) stored in plaintext inside the script itself. And likewise, it’s not uncommon to think that if this is being done in a test environment, it’s no big deal—but it sets a dangerous precedent. It’s important to be conscious of security measures even when you’re testing so that you can build good security habits for when you’re moving out of testing and into production.</p>&#13;
<p class="indent">A simple way to avoid having plaintext passwords in your script is to encrypt them in a file. When you need them, your script can decrypt them and use them. Thankfully, PowerShell provides a way to natively do this: the Windows Data Protection API. This API is used under the hood of the <span class="literal">Get-Credential</span> command, a command that returns a <span class="literal">PSCredential</span> object.</p>&#13;
<p class="indent"><span class="literal">Get-Credential</span> creates an encrypted form of the password known as a <em>secure string</em>. Once in the secure string format, the whole credential object can be saved to the disk by using the <span class="literal">Export-CliXml</span> command; inversely, you can read the <span class="literal">PSCredential</span> object by using the <span class="literal">Import-CliXml</span> command. These commands make a handy password management system.</p>&#13;
<p class="indent">When handling credentials in PowerShell, you want to store <span class="literal">PSCredential</span> objects, the types of objects most <span class="literal">Credential</span> parameters accept. In previous chapters, you were either interactively typing in the username and password or storing them in plaintext. But now that you’ve gotten your feet wet, let’s do it for real and add protection for your credentials.</p>&#13;
<p class="indent">Saving a <span class="literal">PSCredential</span> object in an encrypted format to disk requires the <span class="literal">Export-CliXml</span> command. Using the <span class="literal">Get-Credential</span> command, you can create a prompt for username and password and prompt the result into <span class="literal">Export-CliXml</span>, which takes the path to save the XML file as shown in <a href="ch16.xhtml#ch16list2">Listing 16-2</a>.</p>&#13;
<pre>Get-Credential | Export-CliXml  -Path C:\DomainCredential.xml</pre>&#13;
<p class="caption" id="ch16list2"><em>Listing 16-2: Exporting a credential to a file</em></p>&#13;
<p class="indent">If you open the XML file, it should look something like this:</p>&#13;
<pre>&lt;TN RefId="0"&gt;&#13;
  &lt;T&gt;System.Management.Automation.PSCredential&lt;/T&gt;&#13;
  &lt;T&gt;System.Object&lt;/T&gt;&#13;
  &lt;/TN&gt;&#13;
  &lt;ToString&gt;System.Management.Automation.PSCredential&lt;/ToString&gt;&#13;
  &lt;Props&gt;&#13;
  &lt;S N="UserName"&gt;<span class="codeitalic1">userhere</span>&lt;/S&gt;&#13;
  &lt;SS N="Password"&gt;<span class="codeitalic1">ENCRYPTEDTEXTHERE</span>&lt;/SS&gt;&#13;
  &lt;/Props&gt;&#13;
  &lt;/Obj&gt;&#13;
&lt;/Objs&gt;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_238"/>Now that the credential has been saved to the disk, let’s see how to get it in PowerShell. Use the <span class="literal">Import-CliXml</span> command to interpret the XML file and create a <span class="literal">PSCredential</span> object:</p>&#13;
<pre>$cred = Import-Clixml -Path C:\DomainCredential.xml&#13;
$cred | Get-Member&#13;
&#13;
&#13;
   TypeName: System.Management.Automation.PSCredential&#13;
&#13;
Name                 MemberType Definition&#13;
----                 ---------- ----------&#13;
Equals               Method     bool Equals(System.Object obj)&#13;
GetHashCode          Method     int GetHashCode()&#13;
GetNetworkCredential Method     System.Net.NetworkCredential&#13;
                                GetNetworkCredential()&#13;
GetObjectData        Method     void GetObjectData(System.Runtime...&#13;
GetType              Method     type GetType()&#13;
ToString             Method     string ToString()&#13;
Password             Property   securestring Password {get;}&#13;
UserName             Property   string UserName {get;}</pre>&#13;
<p class="indent">You set the code up so that you simply need to pass <span class="literal">$cred</span> to any <span class="literal">Credential</span> parameter on a command. Now the code will work just as if you interactively typed it in. This method is short and sweet, but you wouldn’t generally use it in a production environment because the user that encrypted the text must also be the one that decrypts it (not how encryption is supposed to work!). The one-user requirement won’t scale well at all. But all that said, in a test environment, it works great!</p>&#13;
<h3 class="h3" id="ch16lev5">PowerShell Direct</h3>&#13;
<p class="noindent">Now, back to our project. Typically, when you run commands against remote computers in PowerShell, you’re forced to use PowerShell remoting. This, obviously, depends on network connectivity between your local host and a remote host. Wouldn’t it be nice if you could simplify this setup and not have to worry about network connectivity at all? Well, you can!</p>&#13;
<p class="indent">Because you’re running all your automation on a Windows Server 2016 Hyper-V host, you have a useful feature at your disposal: PowerShell Direct. <em>PowerShell Direct</em> is a newer feature of PowerShell that allows you to run commands on any VMs hosted on the Hyper-V server <em>without network connectivity</em>. There’s no need to set up the network adapters on the VMs ahead of time (although you already did this with the unattend XML file).</p>&#13;
<p class="indent">For convenience’s sake, rather than use the full network stack, you’ll use PowerShell Direct quite a bit. If you didn’t, because you’re in a workgroup environment, you’d have to configure PowerShell remoting in a workgroup environment—no easy task (see the guide at <em><a href="http://bit.ly/2D3deUX">http://bit.ly/2D3deUX</a></em>). It’s always a good idea to choose your battles in PowerShell, and here, I’ll choose the easiest one!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>PowerShell Direct is nearly identical to PowerShell remoting. It’s a way to run commands on remote computers. Typically, this requires network connectivity, but with PowerShell Direct, there’s no need. To initiate a command on a remote computer via PowerShell remoting, you’d usually use the <span class="literal">Invoke-Command</span> with the <span class="literal">ComputerName</span> and <span class="literal">ScriptBlock</span> parameters:</p>&#13;
<pre>Invoke-Command -ComputerName LABDC -ScriptBlock { hostname }</pre>&#13;
<p class="indent">When using PowerShell Direct, though, the <span class="literal">ComputerName</span> parameter turns into <span class="literal">VMName</span>, and a <span class="literal">Credential</span> parameter is added. The exact same command will run via PowerShell Direct as in the previous code, but only from the Hyper-V host itself. To make things easy, let’s first store a <span class="literal">PSCredential</span> object on disk so you don’t have to keep prompting for a credential in the future.</p>&#13;
<p class="indent">For this example, use the username <span class="literal">powerlabuser</span> and the password <span class="literal">P@$$w0rd12</span>:</p>&#13;
<pre>Get-Credential | Export-CliXml -Path C:\PowerLab\VMCredential.xml</pre>&#13;
<p class="indent">Now that you have saved the credential to disk, you’ll decrypt it and pass it to <span class="literal">Invoke-Command</span>. Let’s read the credential saved in <em>VMCredential.xml</em> and then use that credential to execute code on the LABDC VM:</p>&#13;
<pre>$cred = Import-CliXml -Path C:\PowerLab\VMCredential.xml&#13;
Invoke-Command -VMName LABDC -ScriptBlock { hostname } -Credential $cred</pre>&#13;
<p class="indent">A lot more is going on under the covers to make PowerShell Direct work, but I’m not going to go into the details here. For a full breakdown of how PowerShell Direct works, I recommend taking a look at the Microsoft blog post announcing the feature (<a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/powershell-direct"><em>https://docs.microsoft.com/en-us/virtualization</em><em>/hyper-v-on-windows/user-guide/powershell-direct</em></a>).</p>&#13;
<h3 class="h3" id="ch16lev6">Pester Tests</h3>&#13;
<p class="noindent">It’s now time for the most important part of the chapter: let’s bring it all together with the Pester tests! You’ll follow the same pattern as in the preceding chapter, but here I’d like to point out one piece of the tests. In this chapter’s Pester tests, you’ll use the <span class="literal">BeforeAll</span> and <span class="literal">AfterAll</span> blocks (<a href="ch16.xhtml#ch16list3">Listing 16-3</a>).</p>&#13;
<p class="indent">As their names suggest, the <span class="literal">BeforeAll</span> block contains code that’s executed before all the tests, and the <span class="literal">AfterAll</span> block contains code that’s executed after. You use these blocks because you’ll need to connect to your LABDC server multiple times via PowerShell Direct. PowerShell remoting and PowerShell Direct both support the concept of a session, which you learned about in <a href="part1.xhtml#part1">Part I</a> (<a href="ch08.xhtml#ch8">Chapter 8</a>). Rather than having <span class="literal">Invoke-Command</span> build and tear down multiple sessions, it’s better to define a single session ahead of time and reuse it.</p>&#13;
<pre><span epub:type="pagebreak" id="page_240"/>BeforeAll {&#13;
    $cred = Import-CliXml -Path C:\PowerLab\VMCredential.xml&#13;
    $session = New-PSSession -VMName 'LABDC' -Credential $cred&#13;
}&#13;
&#13;
AfterAll {&#13;
    $session | Remove-PSSession&#13;
}</pre>&#13;
<p class="caption" id="ch16list3"><em>Listing 16-3:</em> Tests.ps1—<span class="codeitalic">BeforeAll</span> <em>and</em> <span class="codeitalic">AfterAll</span> <em>blocks</em></p>&#13;
<p class="indent">You’ll notice that you’re decrypting your saved credential from disk inside the <span class="literal">BeforeAll</span> block. Once you create the credential, you pass it and the name of the VM to the <span class="literal">New-PSSession</span> command. This is the same <span class="literal">New-PSSession</span> covered in <a href="part1.xhtml#part1">Part I</a> (<a href="ch08.xhtml#ch8">Chapter 8</a>), but here you can see that instead of using <span class="literal">ComputerName</span> as a parameter, you’re using <span class="literal">VMName</span>.</p>&#13;
<p class="indent">This will create a single remote session that you can reuse throughout the tests. After all the tests are done, Pester will look in the <span class="literal">AfterAll</span> block and remove the session. This approach is much more efficient than repeatedly creating a session, especially if you have dozens or hundreds of tests that need to run code remotely.</p>&#13;
<p class="indent">The rest of the script in the chapter resources is straightforward and follows the same pattern you’ve been using. As you can see, all the Pester tests come back positive, which means you’re still on the right track!</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Pester 'C:\PowerShellForSysadmins\Part II\Automating Operating&#13;
System Installs\Automating Operating System Installs.Tests.ps1'</span>&#13;
Describing Automating Operating System Installs&#13;
   Context Virtual Disk&#13;
    [+] created a VHDX called LABDC in the expected location 305ms&#13;
    [+] attached the virtual disk to the expected VM 164ms&#13;
    [+] creates the expected VHDX format 79ms&#13;
    [+] creates the expected VHDX partition style 373ms&#13;
    [+] creates the expected VHDX type 114ms&#13;
    [+] creates the VHDDX of the expected size 104ms&#13;
   Context Operating System&#13;
    [+] sets the expected IP defined in the unattend XML file 1.07s&#13;
    [+] deploys the expected Windows version 65ms&#13;
Tests completed in 2.28s&#13;
Passed: 8 Failed: 0 Skipped: 0 Pending: 0 Inconclusive: 0</pre>&#13;
<h3 class="h3" id="ch16lev7">Summary</h3>&#13;
<p class="noindent">In this chapter, you went a little deeper into our real-world project. You used the existing VM you built in the preceding chapter and, both manually and automatically, deployed an operating system to it. At this point, you have a fully functioning Windows VM ready for the next stage in your journey.</p>&#13;
<p class="indent">In the next chapter, you’ll set up Active Directory (AD) on your LABDC VM. Setting up AD will create a new AD forest and domain to which, by the end of the session, you’ll have joined even more servers.</p>&#13;
</body></html>