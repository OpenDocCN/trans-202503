- en: '**11**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**OS X SCRIPTS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the most important changes in the world of Unix and Unix-like operating
    systems was the release of the completely rewritten OS X system, built atop a
    reliable Unix core called Darwin. Darwin is an open source Unix based on BSD Unix.
    If you know your Unix at all, the first time you open the Terminal application
    in OS X, you’ll doubtless swoon with delight. Everything you’d want, from development
    tools to standard Unix utilities, is included in the latest generation of Mac
    computers, with a gorgeous GUI quite capable of hiding all that power for people
    who aren’t ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: There are significant differences between OS X and Linux/Unix, however, so it’s
    good to learn some OS X tweaks that can help you in your day-to-day interaction.
    For example, OS X has an interesting command line application called `open`, which
    allows you to launch graphical applications from the command line. But `open`
    isn’t very flexible. If you want to open, say, Microsoft Excel, entering `open
    excel` won’t work because `open` is picky and expects you to enter `open -a "Microsoft
    Excel"`. Later in this chapter, we’ll write a wrapper script to work around this
    picky behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIXING OS X LINE ENDINGS**'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another occasional situation that’s made easier with a small tweak. If
    you work on the command line with files created for the GUI side of the Mac, you’ll
    find that the end-of-line character in these files isn’t the same as the character
    you need when working on the command line. In technical parlance, OS X systems
    have end-of-line carriage returns (using `\r` notation), while the Unix side wants
    line feeds (an `\n`). So instead of output in which each line is displayed one
    after the other, a Mac file will show up in the Terminal without the proper line
    breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Have a file that’s suffering from this problem? Here’s what you’d see if you
    tried to use `cat` to output the file contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet you know that the file is not empty. To see that there’s content, use the
    `-v` flag to `cat`, which makes all otherwise hidden control characters visible.
    Now you see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Clearly there’s something wrong! Fortunately, it’s easy to use `tr` to replace
    the carriage returns with the proper newlines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once this is applied to the sample file, things make more sense.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you open a Unix file in a Mac application like Microsoft Word and it looks
    all wonky, you can also switch end-of-line characters in the other direction—toward
    an Aqua application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Well, that’s just one of the little differences you’ll see in OS X. We’ll have
    to deal with these quirks, but we’ll also be able to take advantage of OS X’s
    nicer features.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump in, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: '**#79 Automating screencapture**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve used a Mac for any length of time, you’ve learned that it has a builtin
    screen capture capability that you access by pressing ![image](../images/common2.jpg)-SHIFT-3\.
    You can also use the OS X utilities `Preview` or `Grab`, located in the Applications
    and Utilities folders, respectively, and there are excellent third-party choices
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'But did you know that there’s a command line alternative? The super useful
    program `screencapture` can take shots of the current screen and save them to
    the Clipboard or to a specific named file (in JPEG or TIFF format). Enter the
    command with an undefined argument and you’ll see the basics of its operation,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an application begging for a wrapper script. For example, to take a
    shot of the screen 30 seconds in the future, you could use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But let’s make something more interesting, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 11-1](ch11.xhtml#ch11ex1) shows how we can automate the `screencapture`
    utility so it captures screenshots a bit more stealthily.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: The* `*screencapture2*` *wrapper script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This will take a screenshot every `$freq` seconds ➊ for up to `$maxshots` captures
    (with a default of every 60 seconds for 30 captures). The output is a series of
    JPEG files sequentially numbered starting at 0\. This could be very useful for
    training purposes or perhaps if you’re suspicious that someone has been using
    your computer while you’re at lunch: set this up, and you can review what occurred
    without anyone being the wiser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last section of the script is interesting: it optionally produces an animated
    GIF one-third the size of the original by using the ImageMagick `convert` tool
    ➋. This is a handy way of reviewing the images all at once. We’ll use ImageMagick
    a lot more in [Chapter 14](ch14.xhtml#ch14)! You may not have this command by
    default on your OS X system, but by using a package manager like `brew`, you can
    install it with a single command (`brew install imagemagick`).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because this code is designed to run stealthily in the background, the basic
    invocation is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all there is to it. Easy. As an example, to specify how many shots to
    take (30) and when to take them (every 5 seconds), you could start the `screencapture2`
    script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Running the script results in zero output, but new files do show up, as shown
    in [Listing 11-2](ch11.xhtml#ch11ex2). (If you specify the `-a` animate flag,
    you’ll get an additional result.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: The images of a screen that was captured over a period of time
    by* `*screencapture2*`'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a long-term screen-monitoring tool, you’ll want to find some means of checking
    when the screen actually changes so you’re not wasting hard drive space with uninteresting
    screenshots. There are third-party solutions that should allow `screencapture`
    to run for much longer periods, saving the history of when the screen actually
    changes rather than dozens—or hundreds—of copies of the same unchanged screen.
    (Note that if you have a clock display on your screen, every single screen capture
    will be slightly different, making it much harder to avoid this problem!)
  prefs: []
  type: TYPE_NORMAL
- en: With this capability, you could have “monitor ON” and “monitor OFF” as a wrapper
    that starts the capture sequence and analyzes whether any of the images differ
    from the first capture. But if you were using this script’s GIFs to create an
    online training tutorial, you might use finer-grained controls to set the length
    of capture, using that period of time as a command line argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**#80 Setting the Terminal Title Dynamically**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 11-3](ch11.xhtml#ch11ex3) is a fun little script for OS X users who
    like to work in the Terminal application. Instead of having to use the **Terminal**
    ![image](../images/common3.jpg) **Preferences** ![image](../images/common3.jpg)
    **Profiles** ![image](../images/common3.jpg) **Window** dialog to set or change
    the window title, you can use this script to change it whenever you like. In this
    example, we’ll make the Terminal window’s title just a bit more useful by including
    the present working directory in it.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: The* `*titleterm*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Terminal application has a variety of secret escape codes that it understands,
    and the `titleterm` script sends a sequence of `ESC ] 0; title BEL` ➊, which changes
    the title to the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To change the title of the Terminal window, simply enter the new title you desire
    as the argument to `titleterm`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s no apparent output from the command, as [Listing 11-4](ch11.xhtml#ch11ex4)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4: Running the* `*titleterm*` *script to set the terminal title
    to that of the current directory*'
  prefs: []
  type: TYPE_NORMAL
- en: However, it instantly changes the title of the Terminal window to the present
    working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With one small addition to your login script (*.bash_profile* or something
    else, depending on what login shell you have), you can automatically have the
    Terminal window title always show the current working directory. To make this
    code show your current working directory, for example, you can use this at `tcsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this at `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Just drop one of the commands above into your login script, and starting the
    next time you open up a Terminal window, you’ll find that your window title changes
    each time you move into a new directory. Darn helpful.
  prefs: []
  type: TYPE_NORMAL
- en: '**#81 Producing Summary Listings of iTunes Libraries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve used iTunes for any length of time, you’re sure to have a massive
    list of music, audiobooks, movies, and TV shows. Unfortunately, for all its wonderful
    capabilities, iTunes doesn’t have an easy way to export a list of your music in
    a succinct and easy-to-read format. Fortunately, it’s not hard to write a script
    that offers this functionality, as [Listing 11-5](ch11.xhtml#ch11ex5) shows. This
    script does rely on the “Share iTunes XML with other applications” feature of
    iTunes being enabled, so before running this script, ensure that it’s enabled
    in the iTunes preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5: The* `*ituneslist*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like many modern computer applications, iTunes expects its music library to
    be in a standard location—in this case *~/Music/iTunes/iTunes Media/*— but allows
    you to move it elsewhere if you want. The script needs to be able to ascertain
    the different location, and that’s done by extracting the `Music Folder` field
    value from the iTunes preferences file. That’s what the pipe at ➊ accomplishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preferences file (`$ituneconfig`) is an XML data file, so some chopping
    is necessary to identify the exact `Music Folder` field value. Here’s what the
    `iTunes Media` value in Dave’s iTunes config file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `iTunes Media` value is actually stored as a fully qualified URL, interestingly
    enough, so we need to chop off the *file://localhost/* prefix. This is the job
    of the first `cut` command. Finally, because many directories in OS X include
    spaces, and because the `Music Folder` field is saved as a URL, all spaces in
    that field are mapped to `%20` sequences and have to be restored to spaces by
    the `sed` invocation before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Music Folder` name determined, it’s now easy to generate music lists
    on two Mac systems and then use the `diff` command to compare them, making it
    a breeze to see which albums are unique to one or the other system and perhaps
    to sync them up.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no command arguments or flags to this script.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you have a large music collection, the output from the script can be large.
    [Listing 11-6](ch11.xhtml#ch11ex6) shows the first 15 lines of the output from
    Dave’s music collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6: Running the* `*ituneslist*` *script to print the top items in
    an iTunes collection*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All right, this isn’t about hacking the script per se, but because the iTunes
    library directory is saved as a fully qualified URL, it would be interesting to
    experiment with having a web-accessible iTunes directory and then using the URL
    of that directory as the `Music Folder` value in the XML file. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**#82 Fixing the open Command**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One neat innovation with OS X is the addition of the `open` command, which allows
    you to easily launch the appropriate application for just about any type of file,
    whether it’s a graphics image, a PDF document, or an Excel spreadsheet. The problem
    with `open` is that it’s a bit quirky. If you want it to launch a named application,
    you have to include the `-a` flag. And if you don’t specify the exact application
    name, it will complain and fail. This is a perfect job for a wrapper script like
    the one in [Listing 11-7](ch11.xhtml#ch11ex7).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7: The* `*open2*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script revolves around the zero and nonzero return codes, with the `open`
    program having a zero return code upon success and a nonzero return code upon
    failure ➊.
  prefs: []
  type: TYPE_NORMAL
- en: If the supplied argument is not a filename, the first conditional fails, and
    the script tests whether the supplied argument is a valid application name by
    adding `a`. If the second conditional fails, the script uses a `case` statement
    ➋ to test for common nicknames that people use to refer to popular applications.
  prefs: []
  type: TYPE_NORMAL
- en: It even offers a friendly message when it matches a nickname, just before launching
    the named application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `open2` script expects one or more filenames or application names to be
    specified on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Without this wrapper, an attempt to open the application Microsoft Word fails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather a scary error message, though it occurred only because the user did
    not supply the `-a` flag. The same invocation with the `open2` script shows that
    it is no longer necessary to remember the `-a` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'No output is good: the application launched and ready to use. In addition,
    the series of nicknames for common OS X applications means that while `open -a
    word` definitely won’t work, `open2 word` works just fine.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script could be considerably more useful if the nickname list were tailored
    to your specific needs or the needs of your user community. That should be easily
    accomplished!
  prefs: []
  type: TYPE_NORMAL
