<html><head></head><body><div id="sbo-rt-content"><div class="imagec"><span epub:type="pagebreak" id="page_77"/><img src="Images/f077-01.jpg" alt="Image" width="250" height="240"/></div>&#13;
<h2 class="h2" id="ch03"><span class="big">3</span><br/>Hatlight: A Cave Exploring Platform Game</h2>&#13;
<p class="noindent">In this chapter, you’ll combine everything you learned about programming, character design and animation, and level design to make your own platform game in Scratch. A <em>platform game</em> is a fancy name for games like <em>Super Mario Bros.</em>, where the player has a cutaway view of the game world and gets around mostly by jumping on platforms suspended in midair, as you can see here.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_78"/><img src="Images/f078-01.jpg" alt="Image" width="830" height="623"/></div>&#13;
<p class="caption"><em>The platform game we’ll create</em></p>&#13;
<p class="indent">If you don’t want to worry about the programming, go to <em><a href="http://tinyurl.com/hatlightempty/">http://tinyurl.com/hatlightempty/</a></em> to find a version of the game with the platform engine code already written. All it needs is your level design.</p>&#13;
<h3 class="h3" id="ch03lev1sec1">About Hatlight</h3>&#13;
<p class="noindent">Let’s preview a finished version of the <em>Hatlight</em> game to give you an idea of what we’re making. In this game, you’ll be an explorer who uses a hatlight (a flashlight mounted on a hat) to investigate a big, winding cave. Because it’s dark underground, you’ll need to use your trusty hatlight to find your way around, as shown in the following figure. If you can find some batteries, you can make your light stronger.</p>&#13;
<p class="indent">Play the game at the following link: <em><a href="https://scratch.mit.edu/projects/122190314/">https://scratch.mit.edu/projects/122190314/</a></em>. You can use the left and right arrow keys to move around, and the up arrow key to jump. (You can also use the spacebar to jump or even the Z key—whichever feels more natural for you!)</p>&#13;
<p class="indent">There are seven batteries in all! How many can you find?</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_79"/><img src="Images/f079-01.jpg" alt="Image" width="831" height="621"/></div>&#13;
<p class="caption"><em>Using the hatlight to explore!</em></p>&#13;
<h3 class="h3" id="ch03lev1sec2">Coding Platform Movement</h3>&#13;
<p class="noindent">When you’re making a game like <em>Hatlight</em>, you want to think about how the player will move. The player interacts with your game world by moving, so we want to make moving around the platform feel natural.</p>&#13;
<p class="indent">Platform movement is a big project, so let’s break it down into smaller parts. Breaking down a large task into smaller parts is called <em>decomposition</em>. We’ll program four types of movement:</p>&#13;
<ul>&#13;
<li class="noindent">Walking side to side.</li>&#13;
<li class="noindent">Jumping around (of course!).</li>&#13;
<li class="noindent">Falling when there’s nothing to stand on.</li>&#13;
<li class="noindent">Climbing sloped or uneven surfaces. (This means we can draw our own levels and not worry about having flat and straight floors. Our game will take place in a cave, so we want a <em>lot</em> of bumpy floors.)</li>&#13;
</ul>&#13;
<p class="indent">If we work on one part at a time, it will be easier to create the game.</p>&#13;
<h4 class="h4" id="ch03lev2sec1"><span epub:type="pagebreak" id="page_80"/>Creating a Hitbox Sprite</h4>&#13;
<p class="noindent">Let’s start by creating a sprite that contains code for all of the player’s platforming action.</p>&#13;
<p class="indent">Create a new project in Scratch and open the Paint Editor. Use the <strong>Rectangle</strong> tool to make a smooth, perfect rectangle, like this.</p>&#13;
<div class="image"><img src="Images/f080-01.jpg" alt="Image" width="850" height="649"/></div>&#13;
<p class="caption"><em>Drawing a hitbox rectangle</em></p>&#13;
<p class="indent">Don’t make the hitbox too big! We need to leave enough room on the screen so that the player can jump around and explore. When the player is running, jumping, and bouncing around from one platform to another, we’ll need to check for <em>collisions</em>. A collision lets us know whether the player runs into a wall. If that happens, we can say, “Hey! You and the wall shouldn’t be in the same place.” Then we can move the player outside the wall.</p>&#13;
<div class="note">&#13;
<p class="notep"><strong><span class="notes">NOTE:</span></strong> In the next chapter, we’ll create another sprite that handles the player’s animation. This sprite will move with the hitbox and change costumes depending on the status of the hitbox. For now, the hitbox looks perfectly flat and rectangular for the purpose of making collision easier.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>When Scratch checks whether two sprites are touching, the <em>exact shape</em> of the sprite matters. For example, if the player sprite has a very long nose, they could hang from a platform by the tip of their nose!</p>&#13;
<p class="indent">To prevent such situations, we’ll make sure Scratch always checks for collisions by making our sprite look like a neat, flat rectangle. This shape is sometimes called a <em>hitbox</em> or <em>bounding box</em>. In the finished game, it will be invisible. We’ll add better animation for the main character later.</p>&#13;
<p class="indent">Make sure your hitbox is centered on the <span class="literal">+</span>. Name the sprite <span class="literal">Hitbox</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec2">Drawing a Test Area</h4>&#13;
<p class="noindent">Before we code our <span class="literal">Hitbox</span> sprite, let’s create a test area where we can try out our movement and make sure it works the way we want it to.</p>&#13;
<p class="indent">Create a sprite named <span class="literal">Walls</span> that will contain all the solid objects in our game: the walls, the floor, and the ceilings. The following figure shows all the objects we want the player to collide with.</p>&#13;
<div class="image"><img src="Images/f081-01.jpg" alt="Image" width="636" height="791"/></div>&#13;
<p class="caption"><em>Creating <span class="codeitalic">Walls</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>The full size of the sprite drawing window is the same size as Scratch’s game window, so you can draw objects all the way to the edges. As you can see, this example shows the test level. We use the Rectangle tool to draw straight lines for all the floors. Later in this chapter, when we add code to make the player climb over bumpy floors, we’ll make the floors look less regular. For now, it’s okay to keep them simple.</p>&#13;
<p class="indent">Make sure your <span class="literal">Walls</span> sprite is positioned exactly within the game screen. Here’s a handy trick for doing this: give the <span class="literal">Walls</span> sprite the code block <span class="literal">go to x: 0 y: 0</span>. Then double-click the code block to snap the sprite into position in the middle of the screen. (You can delete the code block afterward.)</p>&#13;
<p class="indent">We’ll put all our levels into the <span class="literal">Walls</span> sprite as different costumes later on. But for now, all we need are some walls and platforms for our player to run around in.</p>&#13;
<h4 class="h4" id="ch03lev2sec3">Organizing Our Code with Events</h4>&#13;
<p class="noindent">Our platform game will involve quite a bit of code. We’ve already identified four different types of movement we need to code. If we don’t decide how to organize the code before we write it, it will get <em>very</em> confusing to keep track of.</p>&#13;
<p class="indent">Fortunately, we already identified different parts of the code that we need: walking, jumping, falling, and climbing. So instead of creating one long stack, we’ll create small stacks for each part.</p>&#13;
<h5 class="h5" id="ch03lev3sec1">Creating a Chain of Events</h5>&#13;
<p class="noindent">Every stack needs to begin with an event, so we’ll make a different event for each stack we want. Recall that in Scratch a sprite can receive the messages it broadcasts. This means that we can end each stack by broadcasting the next message in the sequence, creating the equivalent of a <span class="literal">forever</span> loop. The last event will call back to the first one, and the code will keep repeating.</p>&#13;
<p class="indent">Create these events in the <span class="literal">Hitbox</span> sprite.</p>&#13;
<div class="note">&#13;
<p class="notep"><strong><span class="notes">NOTE:</span></strong> The <span class="literal">wrap</span> event is for moving from screen to screen. We’ll come back to that later!</p>&#13;
</div>&#13;
<div class="image"><span epub:type="pagebreak" id="page_83"/><img src="Images/f083-01.jpg" alt="Image" width="856" height="668"/></div>&#13;
<p class="caption"><em>Creating a sequence of events</em></p>&#13;
<p class="indent">Now we have a series of events that play out in order, broadcasting the next one in sequence and eventually looping back to the start. None of the events have code in them yet, but we have a basic, working structure to build our game.</p>&#13;
<p class="indent">Let’s explore each event in more detail.</p>&#13;
<h4 class="h4" id="ch03lev2sec4">Creating Variables</h4>&#13;
<p class="noindent">We’ll begin by defining some variables using the Variables tab. We’ll put our variables in the <span class="literal">when green flag clicked</span> event, before our actual loop starts, as shown next. We only want them to be set once at the beginning of the game.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_84"/><img src="Images/f084-01.jpg" alt="Image" width="386" height="491"/></div>&#13;
<p class="caption"><em>Creating variables for <span class="codeitalic">when green flag clicked</span> event</em></p>&#13;
<p class="indent">The <span class="literal">grounded</span> variable is a special type of variable called a <em>Boolean</em> variable, which has one of two values, like true or false, on or off, and so on. In this case, <span class="literal">grounded</span> is always either 0 or 1. If it’s 0, the player is in midair. If it’s 1, the player is on the ground. We can use this value to make sure the player is on the ground before they can jump.</p>&#13;
<p class="indent">Similar to the way we define variables in programming, we’ll set these four variables to the values we want them to start the game at. Each time the game starts, the program will reset all four of these variables.</p>&#13;
<h3 class="h3" id="ch03lev1sec3">Coding Player Movement</h3>&#13;
<p class="noindent">Now that we’ve defined our variables and set their default values, we can start programming each stack.</p>&#13;
<h4 class="h4" id="ch03lev2sec5">Moving Left and Right</h4>&#13;
<p class="noindent">The first stack we’ll code is the <span class="literal">move left/right</span> stack. The full stack should look something like this.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_85"/><img src="Images/f085-01.jpg" alt="Image" width="1038" height="1041"/></div>&#13;
<p class="caption"><em>The <span class="codeitalic">move</span> code</em></p>&#13;
<p class="indent">Now let’s look at how this stack works step by step. Note that a positive value means the player moves to the right, and a negative value means the player moves to the left, like in a number line.</p>&#13;
<h4 class="h4" id="ch03lev2sec6">Climbing Slopes and Steps</h4>&#13;
<p class="noindent">So far we’ve programmed how the player should move on a flat surface. But we haven’t yet programmed how they should deal with sloping floors or steps.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_86"/><img src="Images/f086-01.jpg" alt="Image" width="824" height="1037"/></div>&#13;
<p class="caption"><em>The <span class="codeitalic">climb</span> code</em></p>&#13;
<p class="indent">Let’s program players to climb slopes and steps as long as they’re not too steep or high. The player can only walk up bumps or slopes that are less than three steps high. If the player takes more than three steps, it will mean the slope is too steep or they’ve bumped into a wall. So if the player walks into a slope or step that is too high to climb, we’ll make it impossible for the player to climb over it. Here’s the complete <span class="literal">climb</span> code.</p>&#13;
<p class="indent">This last <span class="literal">if () then</span> block to shake the player loose is an emergency measure just to make sure they can never get stuck in the wall!</p>&#13;
<h4 class="h4" id="ch03lev2sec7"><span epub:type="pagebreak" id="page_87"/>Falling</h4>&#13;
<p class="noindent">Here’s the <span class="literal">fall</span> code that determines how the player should fall when they’re not touching the ground.</p>&#13;
<div class="image"><img src="Images/f087-01.jpg" alt="Image" width="831" height="978"/></div>&#13;
<p class="caption"><em>The <span class="codeitalic">fall</span> code</em></p>&#13;
<p class="indent">Remember that negative numbers mean down and positive numbers mean up. Because of the player’s <span class="literal">y speed</span>, they won’t line up with the floor exactly but might overlap it a bit. If so, we undo their last move by multiplying <span class="literal">y speed</span> by –1, causing the player to move in reverse.</p>&#13;
<p class="indent">If <span class="literal">y speed</span> is negative, it means the player bumped into the floor while falling. If it’s positive, they’ve hit the ceiling while jumping. Either way, we set their <span class="literal">y speed</span> to 0 because they stop falling.</p>&#13;
<h4 class="h4" id="ch03lev2sec8"><span epub:type="pagebreak" id="page_88"/>Jumping</h4>&#13;
<p class="noindent">Next, we’ll look at how to program the player’s jumping motion. Here’s the code for <span class="literal">jump</span>.</p>&#13;
<div class="image"><img src="Images/f088-01.jpg" alt="Image" width="1099" height="527"/></div>&#13;
<p class="caption"><em>The <span class="codeitalic">jump</span> code</em></p>&#13;
<h4 class="h4" id="ch03lev2sec9">Creating Natural Movement with Variables</h4>&#13;
<p class="noindent">Why do we use <span class="literal">x speed</span> and <span class="literal">y speed</span> variables instead of just changing <span class="literal">x</span> and <span class="literal">y</span>? For example, to set the player’s speed to 10, we <em>could</em> just increase the player’s <span class="literal">x</span> by 10 whenever the player presses the right arrow key.</p>&#13;
<div class="image"><img src="Images/f088-02.jpg" alt="Image" width="554" height="403"/></div>&#13;
<p class="caption"><em>Increasing speed without using variables</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>In this example, the player has either stopped (speed 0) or is moving (speed 10). The program doesn’t allow for any speed in between. This results in a binary movement that looks unnatural.</p>&#13;
<div class="image"><img src="Images/f089-01.jpg" alt="Image" width="610" height="588"/></div>&#13;
<p class="caption"><em>Binary movement</em></p>&#13;
<p class="indent">But if we gradually increase the player’s speed over a series of moves, we create a more natural-feeling movement that allows the player to start slow and accelerate to full speed.</p>&#13;
<div class="image"><img src="Images/f089-02.jpg" alt="Image" width="607" height="586"/></div>&#13;
<p class="caption"><em>Gradual acceleration</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>Similarly, we can also have the player decelerate instead of stopping instantly.</p>&#13;
<div class="image"><img src="Images/f090-01.jpg" alt="Image" width="655" height="646"/></div>&#13;
<p class="caption"><em>Deceleration</em></p>&#13;
<p class="indent">If you haven’t yet, try out your code in your test level. Make sure you change the <span class="literal">broadcast wrap</span> block to <span class="literal">broadcast climb</span> because we haven’t written the <span class="literal">wrap</span> part yet. Make changes to the test level by adding a sloped floor. If the player can’t jump high enough to reach a platform, make the platform lower. Or change the initial speed of the player’s jump. (It’s set to 12, as you can see in the <span class="literal">jump</span> code.)</p>&#13;
<p class="indent">You can change how the game feels by experimenting with the numbers in your code blocks. For example, try changing the gravity value or the player’s jump speed, the player’s maximum walking speed, or the speed of acceleration. Can you make it feel like the player is on the moon? Can you make the player’s movement feel really heavy? If you’re feeling very confident, try coding a double jump!</p>&#13;
<h3 class="h3" id="ch03lev1sec4"><span epub:type="pagebreak" id="page_91"/>Creating a World that’s Fun to Explore</h3>&#13;
<p class="noindent">Platform games are neat because they give us an interesting way to think about space. In real life, down is always below, and up is always above. Because of gravity, it’s usually easier to move downward than upward. That means that getting to higher places can be tricky and require more effort.</p>&#13;
<p class="indent">But in our exploration platform game, the player can explore the world however they want, with fewer restrictions. It does mean we have to think about space a little differently. We have to consider how different parts of the platform connect with each other.</p>&#13;
<p class="indent">To really let the player feel like they’re exploring, we’ll need to create a world that’s larger than a single screen, but it will be consistent. For example, if the player walks off the right side of one screen, they should be able to return to where they started by walking left back into the screen. That way, the player can develop a feel for where all the different parts of the world are and how they connect.</p>&#13;
<p class="indent">Have you ever felt excited to discover a new way to get to a place that you didn’t know before? In that moment, you understand your neighborhood a little better: things start to connect like pieces in a puzzle! We can create this feeling in our players by making an interesting world to explore.</p>&#13;
<h4 class="h4" id="ch03lev2sec10">Using a Variable to Create a Grid Map</h4>&#13;
<p class="noindent">Just like blocks in your neighborhood, we’ll arrange our screens into a grid. We’ll start with a grid of 4 rooms by 4 rooms, 16 total! Not too big but not too small. We’ll number each room to keep track of them, like this.</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">5</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">6</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">7</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">8</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">9</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">10</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">11</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">13</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">14</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">15</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">16</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>Think of the grid like panels on a comic book page. Looking at this grid, we can easily figure out how to get from one screen to another. To move right one screen, we just add 1 to the number. Room 1 + 1 = room 2. To move left, we subtract 1. To move up or down, we have to get to a different row. For example, if we were trying to move down from room 2 to room 6, we would need to add 4. To go back up, we would subtract 4.</p>&#13;
<p class="indent">Moving up or down a row requires adding or subtracting 4 because each row has 4 spaces. But in a 5 × 5 grid, we’d need to add 5 to drop down a row!</p>&#13;
<p class="indent">This kind of movement is sometimes called <em>flickscreen</em> because instead of scrolling gradually, the screen flicks to a new image, like turning a page in a book.</p>&#13;
<p class="indent">We’ll use a variable to keep track of which screen the player is on.</p>&#13;
<h4 class="h4" id="ch03lev2sec11">Moving from Screen to Screen</h4>&#13;
<p class="noindent">We’ll use our <span class="literal">Walls</span> sprite to store all our screens. It has a costume for each room and changes costumes whenever the player walks off one screen to another. First, let’s code moving from one screen to another using the following code.</p>&#13;
<div class="image"><img src="Images/f092-01.jpg" alt="Image" width="397" height="570"/></div>&#13;
<p class="caption"><em>Code for screen swapping</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_93"/>You can see we use a new variable, <span class="literal">screen</span>, and a new event, <span class="literal">new screen</span>. When the game starts, the <span class="literal">Walls</span> sprite sets the <span class="literal">screen</span> variable to 1 and then broadcasts the <span class="literal">new screen</span> event, changing its costume to match the screen the player is on. From now on, it’s mostly the player sprite that will change the screen.</p>&#13;
<h5 class="h5" id="ch03lev3sec2">Testing Screen Switching</h5>&#13;
<p class="noindent">Now add 15 new costumes to the <span class="literal">Walls</span> sprite for a total of 16. It’s okay to leave these blank for now, and it’s fine if you just name them <span class="literal">costume2</span>, <span class="literal">costume3</span>, and so on. In fact, it’s better to use numbers in their names. Just make sure the numbers are accurate and in the correct order!</p>&#13;
<p class="indent">The one costume we should fill out is <span class="literal">costume2</span> so we can test whether screen switching works. It doesn’t matter what this screen looks like, but try to get platforms along the edge to line up with platforms in the first screen. The easiest way to do this is to use the Select tool to highlight just the edge of the previous screen before copying and pasting it into the new screen.</p>&#13;
<div class="image"><img src="Images/f093-01.jpg" alt="Image" width="940" height="732"/></div>&#13;
<p class="caption"><em>Copy and paste the edge of the previous screen to <span class="codeitalic">costume2</span>.</em></p>&#13;
<h4 class="h4" id="ch03lev2sec12"><span epub:type="pagebreak" id="page_94"/>Coding Screen Change</h4>&#13;
<p class="noindent">We added a <span class="literal">wrap</span> section to our code between the <span class="literal">move left/right</span> stack and the <span class="literal">climb</span> stack, but we left it blank. Now let’s fill it in!</p>&#13;
<div class="image"><img src="Images/f094-01.jpg" alt="Image" width="561" height="1072"/></div>&#13;
<p class="caption"><em>The <span class="codeitalic">wrap</span> code</em></p>&#13;
<p class="indent">We want the player to be able to walk off the side of the screen and then appear in the next one. For example, if they leave the right side of screen 1, they should appear at the left side of screen 2. We’ll write code for all four directions the player can move in: up, down, left, and right.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_95"/>For each direction, we need to do the following:</p>&#13;
<ol>&#13;
<li class="noindent"><strong>Check whether the player is outside the edge of the screen:</strong> Remember that <span class="literal">x</span> runs from –240 on the left to 240 on the right, and <span class="literal">y</span> runs from 180 at the top to –180 at the bottom.</li>&#13;
<li class="noindent"><strong>Move the player to enter the opposite edge of the screen:</strong> When the player exits the bottom of one screen, they should move to the top of the next screen.</li>&#13;
<li class="noindent"><strong>Adjust the <span class="codestrong">screen</span> variable:</strong> When moving up and down, the player needs to go –4 or 4 screens at a time.</li>&#13;
<li class="noindent"><strong>Broadcast the <span class="codestrong">new screen</span> event:</strong> This lets all the other sprites know the screen has changed, so the <span class="literal">Walls</span> sprite will change to the costume that matches the current screen number.</li>&#13;
</ol>&#13;
<p class="indent">You might need to adjust the values of the x and y positions depending on the size of your <span class="literal">Hitbox</span> sprite. Scratch stops sprites before they can get too far off-screen, which means a larger sprite might not be able to reach an x position of –240. In that case, you might try –239 instead. Keep adjusting values until the code works the way you want.</p>&#13;
<h4 class="h4" id="ch03lev2sec13">Using Light and Darkness</h4>&#13;
<p class="noindent">To make the feeling of exploration stronger, we’ll limit what the player can see to the circle of light coming from their hatlight. This is a very simple effect. All the walls and platforms are black. When we put a black background behind them, we can’t see where the walls are. By putting a small field of light between the black background and the black walls, we create an area around the player where they can see the walls.</p>&#13;
<p class="indent">Of course, this only works if all the walls and the background are the same color. If the walls were a different color than the background, the player would see everything, and there would be less mystery and not much to explore in the game. You can use other colors to draw walls if you want them to show up, such as glowing moss on cave walls, or lava cracks.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_96"/><img src="Images/f096-01.jpg" alt="Image" width="655" height="686"/></div>&#13;
<p class="caption"><em>Creating a field of light between the background and wall</em></p>&#13;
<p class="indent">Create a new sprite to represent the beam of light using the <strong>Ellipse</strong> tool. You can call the sprite <span class="literal">Flashlight</span>. An <em>ellipse</em> is a roundish shape that can be wider in one direction than the other, like a football. To draw a perfect circle, hold down the <small>SHIFT</small> key while you draw it.</p>&#13;
<div class="image"><img src="Images/f096-02.jpg" alt="Image" width="465" height="348"/></div>&#13;
<p class="caption"><em>Drawing a circle of light</em></p>&#13;
<p class="indent">The circle can be any size for now. Later, we’ll add code to make it bigger or smaller depending on the strength of the hatlight’s battery life! Just make sure the center of the circle is over the <span class="literal">+</span>. Here, we made it a bit yellow, like the color of a flashlight.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>Make sure the <span class="literal">Flashlight</span> sprite is between the black background and the walls. An easy way to adjust where sprites are is to drag a <span class="literal">go backward 1 layer</span> block into the <span class="literal">Flashlight</span> Scripts tab. You don’t have to connect it to an event. When you double-click on a code block, it will run instantly. Just double-click the <span class="literal">go backward 1 layer</span> block until the sprite is in the right place. Then you can delete the block.</p>&#13;
<h4 class="h4" id="ch03lev2sec14">Coding the Flashlight</h4>&#13;
<p class="noindent">Now it’s time to code the <span class="literal">Flashlight</span>. The following is the entire code that programs how the light will appear.</p>&#13;
<div class="image"><img src="Images/f097-01.jpg" alt="Image" width="1119" height="736"/></div>&#13;
<p class="caption"><em>The <span class="codeitalic">Flashlight</span> code</em></p>&#13;
<h4 class="h4" id="ch03lev2sec15">Creating Objects to Collect</h4>&#13;
<p class="noindent">In <a href="ch02.xhtml#ch02">Chapter 2</a>, we talked about how collecting berries encouraged the player to think and pay attention to the way the bug moved. In this game, collecting objects can encourage the player to explore and find new paths and secrets in the game environment.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>Let’s create a sprite for a collectible battery that the player uses to make their hatlight stronger. (That’s not how flashlights work in real life, but let’s imagine that’s how it works!)</p>&#13;
<div class="image"><img src="Images/f098-01.jpg" alt="Image" width="323" height="322"/></div>&#13;
<p class="caption"><em>Creating the <span class="codeitalic">battery</span> sprite</em></p>&#13;
<p class="indent">The batteries should be visible even if they’re not in the player’s field of light, as long as they’re on the same screen. That way, the player can see a battery somewhere onscreen and try to find a way to reach it.</p>&#13;
<p class="indent">The finished game will have seven batteries the player can collect. To create multiple batteries, we’ll use cloning, just like we did to create multiple berries in <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>&#13;
<p class="indent">When the game starts, the <span class="literal">battery</span> sprite visits every spot a battery should appear, sets its <span class="literal">location</span> variable to the correct screen, and clones itself. At the start of a game, the battery creates seven clones, each with a different <span class="literal">x</span> and <span class="literal">y</span> position and screen number. Each clone uses the <span class="literal">location</span> variable to keep track of which screen it should appear on.</p>&#13;
<p class="indent">After it’s finished making clones, the original <span class="literal">battery</span> sprite sets its own location to 0, so it doesn’t appear on any of the 16 screens. If we don’t do this, the parent <span class="literal">battery</span> will show up onscreen even though the player can never collect it.</p>&#13;
<p class="indent">To make sure batteries only appear when the player’s on their screens, we use the global <span class="literal">screen</span> variable to check whether it matches its local <span class="literal">location</span> variable. If it is, it’s the correct screen and the clone appears! Otherwise, it disappears.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_99"/><img src="Images/f099-01.jpg" alt="Image" width="894" height="1056"/></div>&#13;
<p class="caption"><em>The <span class="codeitalic">Battery</span> code</em></p>&#13;
<p class="indent">If a player makes contact with a battery, we add a value to the global <span class="literal">batteries found</span> variable, which was set to 0 at the start of the game, and makes the flashlight’s <span class="literal">glow</span> variable a little bigger. The more batteries the player collects, the more they can see, helping them track down even more batteries!</p>&#13;
<h3 class="h3" id="ch03lev1sec5"><span epub:type="pagebreak" id="page_100"/>What You Learned</h3>&#13;
<p class="noindent">In this chapter, we tackled a lot of complex ideas. You learned how to program platform movement and create a character who can walk, climb, jump, and fall. You created a flashlight that the player uses to see in the darkness. By using flickscreen movement, you also created a larger world for your character to explore.</p>&#13;
<p class="indent">In the next chapter, we’ll continue designing <em>Hatlight</em> by filling it with secrets, challenges, and more interesting places for the player to discover. We’ll also create and animate a player character to replace that hitbox. Take a break, eat a snack, pet a cat, and meet me in <a href="ch04.xhtml#ch04">Chapter 4</a> when you’re ready!</p>&#13;
</div>



  </body></html>