- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: MECHANICS IN ONE DIMENSION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一维力学
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: In this chapter, we’ll complete the story of mechanics in one dimension by developing
    tools for situations in which the forces on an object can depend on position as
    well as on time and velocity. This will require thinking about second-order differential
    equations, which we’ll convert into systems of first-order differential equations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将通过开发适用于物体所受力既依赖于位置又依赖于时间和速度的情况的工具，完成一维力学的故事。这将需要思考二阶微分方程，并将其转化为一阶微分方程系统。
- en: As before, we’ll transform information about the physical situation through
    several different forms, beginning with the object’s mass and the forces that
    act on it, and ending with functions that give the position and velocity of the
    object with time. A functional language like Haskell helps organize our thoughts
    about what it means to solve a mechanics problem by giving names and types to
    each form of information and by allowing that information to exist naturally in
    the form of a function when appropriate.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前一样，我们将通过几种不同的形式转化关于物理情况的信息，从物体的质量和作用在其上的力开始，最终得出给出物体位置和速度随时间变化的函数。像Haskell这样的函数式语言通过为每种信息形式赋予名称和类型，并允许在适当的时候将这些信息自然地以函数的形式存在，有助于我们组织思考如何解决力学问题。
- en: 'To apply the tools we’re developing, we’ll look at an example situation: the
    motion of a Ping-Pong ball attached to the end of a Slinky in the presence of
    air resistance—in other words, a damped harmonic oscillator. We’ll show how to
    apply the Euler method for a second-order differential equation, and we’ll see
    how either a list of states or position and velocity functions for an object can
    be regarded as a solution to a mechanics problem. We’ll then introduce the Euler-Cromer
    method, an improvement on the Euler method for second-order differential equations.
    Since we’ll continue to modify the state variables and the data type used for
    state as we introduce vectors and multiple particles in upcoming chapters, at
    the end of this chapter, we’ll generalize our differential equation solving methods
    to allow arbitrary data types for state and allow a choice of numerical methods.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用我们正在开发的工具，我们将看一个例子：乒乓球在弹簧末端运动，受到空气阻力的影响——换句话说，是一个阻尼谐振子。我们将展示如何应用欧拉法求解二阶微分方程，并展示如何将物体的状态列表或位置和速度函数视为力学问题的解。接着我们将介绍欧拉-克罗梅法，这是对欧拉法在二阶微分方程中的改进。由于我们将在接下来的章节中引入向量和多个粒子，修改状态变量和状态使用的数据类型，在本章结束时，我们将总结我们的微分方程求解方法，使其能够支持任意数据类型的状态，并允许选择数值方法。
- en: Introductory Code
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门代码
- en: Let’s begin with the code that needs to appear at the beginning of our source
    code file. I always like to start by turning on warnings. I also include two language
    settings that we will use in “Solving Differential Equations” later in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从源代码文件开头需要出现的代码开始。我总是喜欢先开启警告。我还会包含两个语言设置，我们将在本章“求解微分方程”部分稍后使用。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s make the code in this chapter into a module named `Mechanics1D`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将本章中的代码制作成一个名为`Mechanics1D`的模块。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll also want to make a plot later, so let’s import the necessary module.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后还需要绘制图表，所以让我们导入必要的模块。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For our example of a Ping-Pong ball on the end of a Slinky, we’ll use the air
    resistance function `fAir` from the previous chapter. To access this function,
    we import the module called `Newton2` we wrote in [Chapter 14](ch14.xhtml).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们举的例子——一个乒乓球挂在弹簧的末端，我们将使用上一章中的空气阻力函数`fAir`。要访问这个函数，我们需要导入我们在[第14章](ch14.xhtml)中编写的`Newton2`模块。
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Haskell compiler will look for a file called *Newton2.hs* in the current
    working directory (the same directory that contains the *Mechanics1D.hs* file
    we are writing in this chapter). The file *Newton2.hs* contains the code we wrote
    in the previous chapter and is available at [https://lpfp.io](https://lpfp.io).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell编译器将在当前工作目录（即包含我们正在编写的*Mechanics1D.hs*文件的目录）中查找一个名为*Newton2.hs*的文件。*Newton2.hs*文件包含了我们在上一章编写的代码，并可以通过[https://lpfp.io](https://lpfp.io)访问。
- en: If we include a comma-separated list of types and functions in parentheses after
    the module name, we’ll import only those types and functions. If we omit such
    a list, as we did when importing the `Graphics.Gnuplot.Simple` module, we’ll import
    all types and functions provided by the module.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在模块名称后面包含一个以逗号分隔的类型和函数列表（放在括号中），我们将只导入这些类型和函数。如果我们省略这个列表，像我们导入 `Graphics.Gnuplot.Simple`
    模块时那样，我们将导入该模块提供的所有类型和函数。
- en: As usual, we’ll use the type synonym `R` instead of `Double`. We made this type
    synonym in the `SimpleVec` module of [Chapter 10](ch10.xhtml), and we import it
    from there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将使用类型同义词 `R` 来代替 `Double`。我们在[第10章](ch10.xhtml)的 `SimpleVec` 模块中创建了这个类型同义词，并从那里导入它。
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The warnings option, the language setting, the module name, and the import statements
    need to be at the beginning of the source code file. Type synonyms can appear
    anywhere.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 警告选项、语言设置、模块名称和导入语句需要位于源代码文件的开头。类型同义词可以出现在任何地方。
- en: When we do mechanics in one dimension, time, a time step, mass, position, velocity,
    and force are each represented by a real number.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一维中做力学时，时间、时间步长、质量、位置、速度和力都用实数来表示。
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Forces That Depend on Time, Position, and Velocity
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖于时间、位置和速度的力
- en: When the forces on an object depend on time, position, and velocity, the force
    functions depend on three variables. We’ll use ![Image](Images/e0245-01.jpg) to
    denote the *j*th function of three variables that gives a force when supplied
    with time, position, and velocity; we’ll use ![Image](Images/e0245-02.jpg) to
    denote the function of three variables that gives net force. [Figure 15-1](ch15.xhtml#ch15fig1)
    shows a schematic diagram for Newton’s second law with forces that depend on time,
    position, and velocity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当物体上的力依赖于时间、位置和速度时，力函数依赖于三个变量。我们将使用 ![Image](Images/e0245-01.jpg) 来表示在给定时间、位置和速度时给出力的
    *j* 维函数；我们将使用 ![Image](Images/e0245-02.jpg) 来表示给出合力的三个变量的函数。[图15-1](ch15.xhtml#ch15fig1)展示了一个示意图，说明了牛顿第二定律在力依赖于时间、位置和速度时的情况。
- en: '![Image](Images/f0245-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0245-01.jpg)'
- en: '*Figure 15-1: Newton’s second law in one dimension. The forces depend on time,
    position, and velocity.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-1：牛顿第二定律在一维中的表现。力依赖于时间、位置和速度。*'
- en: The rectangular boxes in the diagram are pure functions whose output depends
    only on the input. The integrators are contained in circles to remind us that
    each integrator contains some state. The integrator whose output is *x*(*t*),
    for example, must contain the current position value. The schematic diagram in
    [Figure 15-1](ch15.xhtml#ch15fig1) is continuous and stateful.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的矩形框表示纯函数，其输出仅依赖于输入。积分器被包含在圆形中，以提醒我们每个积分器都包含一些状态。例如，输出为 *x*(*t*) 的积分器必须包含当前位置值。[图15-1](ch15.xhtml#ch15fig1)中的示意图是连续的，并且是有状态的。
- en: 'Newton’s second law appears as the following differential equation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律表现为以下的微分方程：
- en: '![Image](Images/e0245-03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/e0245-03.jpg)'
- en: We’ve come to the full generality of Newton’s second law in one dimension, as
    given in the previous chapter by Equation 14.2\. Position is the unknown function
    we want to find in this differential equation. This is a second-order differential
    equation because a second derivative of position appears in the equation. To solve
    a second-order differential equation using a state-based approach, we’ll choose
    some state variables and write first-order differential equations for each of
    the state variables.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了牛顿第二定律在一维中的完全一般形式，正如上一章方程14.2所给出的。位置是我们在这个微分方程中要找的未知函数。因为方程中出现了位置的二阶导数，所以这是一个二阶微分方程。为了使用基于状态的方法来求解二阶微分方程，我们将选择一些状态变量，并为每个状态变量写出一阶微分方程。
- en: What should our state variables be? [Figure 15-1](ch15.xhtml#ch15fig1) has two
    integrators contained in loops. These integrators hold position and velocity as
    state, so position and velocity are required to be state variables. While it is
    possible to solve Equation 15.1 using only position and velocity as state variables,
    it is easier if we also allow time to serve as a state variable because the forces
    could also depend on time. Our data type describing state for the mechanics of
    a single object moving in one dimension is a time-position-velocity triple.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态变量应该是什么？[图15-1](ch15.xhtml#ch15fig1)中包含了两个集成器，它们在循环中保持位置和速度作为状态，因此位置和速度必须是状态变量。虽然仅使用位置和速度作为状态变量也可以求解方程15.1，但如果我们也允许时间作为状态变量，则会更容易，因为力也可能依赖于时间。我们描述单个物体在一维运动的力学状态的数据类型是时间-位置-速度三元组。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the name *state space* for data types like `State1D` that describe state.
    The types `Velocity` and `(Time,Velocity)` from the previous chapter are other
    examples of state spaces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*状态空间*这个名称来描述像`State1D`这样的数据类型，它们表示状态。前一章中的类型`Velocity`和`(Time,Velocity)`是状态空间的其他示例。
- en: Equations 15.2, 15.3, and 15.4 show the three first-order differential equations
    obtained by writing expressions for the time derivatives of each state variable.
    What appears on the right side of these equations can involve the state variables
    but may not have any derivatives. Because the derivative of the position function
    depends on the velocity function, and vice versa, we refer to this as a set of
    *coupled* differential equations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 方程15.2、15.3和15.4显示了通过写出每个状态变量的时间导数所得到的三个一阶微分方程。方程右侧可能涉及状态变量，但可能没有任何导数。因为位置函数的导数依赖于速度函数，反之亦然，所以我们称这组方程为*耦合*微分方程。
- en: '![Image](Images/246equ01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/246equ01.jpg)'
- en: The function `newtonSecond1D` gives expressions for the time derivatives of
    the state variables in terms of the state variables themselves. Note that the
    state variables in this function are real numbers rather than functions of time.
    By expressing the differential Equations 15.2, 15.3, and 15.4, the function `newtonSecond1D`
    expresses Newton’s second law in one dimension. The schematic diagram in [Figure
    15-1](ch15.xhtml#ch15fig1), the differential equations, and the Haskell function
    `newtonSecond1D` each contain the essential information for understanding and
    solving Newton’s second law in one dimension.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`newtonSecond1D`给出了状态变量的时间导数的表达式，表达式中的状态变量本身就是状态变量。注意，在这个函数中，状态变量是实数，而不是时间的函数。通过表达微分方程15.2、15.3和15.4，函数`newtonSecond1D`表达了牛顿第二定律的一维形式。[图15-1](ch15.xhtml#ch15fig1)中的示意图、微分方程和Haskell函数`newtonSecond1D`都包含了理解和解决一维牛顿第二定律所需的基本信息。
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A General Strategy for Solving Mechanics Problems
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决力学问题的一般策略
- en: 'Our strategy for constructing and solving Newton’s second law consists of transforming
    information about the physical situation through a sequence of five different
    forms:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建和求解牛顿第二定律的策略包括通过一系列五种不同的形式来转化有关物理情况的信息：
- en: Mass and force functions
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 质量和力函数
- en: Differential equation
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微分方程
- en: State-update function
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态更新函数
- en: List of states
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态列表
- en: Position and velocity functions
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位置和速度函数
- en: The information begins with the mass of the object under consideration and the
    forces that act on it, expressed as functions of the state variables. The function
    `newtonSecond1D` transforms this mass and force information into a differential
    equation. A differential equation is a function `State1D -> (R,R,R)` that gives
    the derivatives of the state variables time, position, and velocity in terms of
    the state variables themselves. The Euler method transforms a differential equation
    into a state-update function, a function `State1D -> State1D` that computes the
    state variables at a later time from the state variables at an earlier time. From
    a state-update function and an initial state, we can then compute an infinite
    list of states, the fourth representation of the data describing our physical
    situation. Finally, we can extract position as a function of time and velocity
    as a function of time from the list of states. Predicting the position and velocity
    of the object as a function of time is the final data representation, which we
    regard as a solution to the problem of understanding the motion of an object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 信息从我们考虑的物体的质量以及作用在其上的力开始，这些力是状态变量的函数。函数`newtonSecond1D`将这些质量和力信息转化为微分方程。微分方程是一个函数`State1D
    -> (R,R,R)`，它给出了时间、位置和速度的状态变量的导数，表示为状态变量本身。欧拉法将微分方程转化为状态更新函数，即函数`State1D -> State1D`，该函数根据早期时刻的状态变量计算后期时刻的状态变量。从状态更新函数和初始状态开始，我们可以计算出一个无限长的状态列表，这是描述我们物理情况的第四种数据表示。最后，我们可以从状态列表中提取时间和速度作为时间的函数。预测物体位置和速度作为时间的函数是最终的数据表示，我们将其视为理解物体运动问题的解。
- en: '[Figure 15-2](ch15.xhtml#ch15fig2) is a functional diagram showing the five
    data representations above and the functions that transform the data from one
    representation to another.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-2](ch15.xhtml#ch15fig2)是一个功能图，展示了上述五种数据表示以及将数据从一种表示转换为另一种表示的函数。'
- en: '![Image](Images/248fig01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/248fig01.jpg)'
- en: '*Figure 15-2: Data flow for solving a mechanics problem in one dimension. Functions
    transform the data through a sequence of five representations.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：在一维中求解力学问题的数据流。函数通过五种表示的序列转换数据。*'
- en: We have already discussed how `newtonSecond1D` transforms mass and force data
    into a differential equation. We’ll discuss the other transformations in detail
    later. [Figure 15-2](ch15.xhtml#ch15fig2) is the first of several figures in this
    chapter and the next few chapters that serve to give an overview of the process
    of solving a mechanics problem. As we expand and generalize the ideas of state
    and numerical method, these figures will become more general, more streamlined,
    and a bit more abstract. Their purpose, central to a deep understanding of Newtonian
    mechanics, is to suggest a high-level way of thinking about the meanings and solution
    techniques of Newton’s laws. The figures organize the many functions we’ve written
    into a coherent, operational description of how to make predictions with Newtonian
    mechanics. Understanding what it takes to solve Newton’s second law is a prerequisite
    to a more profound insight into what the law means.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`newtonSecond1D`如何将质量和力数据转化为微分方程。我们稍后将详细讨论其他转换。[图 15-2](ch15.xhtml#ch15fig2)是本章和接下来几章中的第一张图，旨在概述解决力学问题的过程。随着我们扩展和概括状态和数值方法的思想，这些图将变得更加通用、更加简洁，并且有些抽象。它们的目的是，在深入理解牛顿力学的过程中，建议一种高级思维方式来思考牛顿定律的含义和解决技巧。这些图将我们编写的众多函数组织成一个连贯的、可操作的描述，说明如何用牛顿力学进行预测。理解求解牛顿第二定律所需的步骤是对这一法则意义的更深刻理解的先决条件。
- en: Note that there are two places in [Figure 15-2](ch15.xhtml#ch15fig2) where additional
    information comes in. A time step is required for the Euler method that transforms
    a differential equation into a state-update function, and an initial state is
    required to transform a state-update function into a list of states. In this figure,
    I regard the object’s mass, along with the forces, to be part of the initial information
    that specifies the problem.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图 15-2](ch15.xhtml#ch15fig2)中有两个地方需要额外的信息。欧拉法需要一个时间步长，将微分方程转化为状态更新函数，同时需要一个初始状态，将状态更新函数转化为状态列表。在这张图中，我认为物体的质量和所受的力是问题初始信息的一部分。
- en: Solving with Euler’s Method
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用欧拉法求解
- en: To solve differential Equations 15.2, 15.3, and 15.4, we will discretize time,
    choosing a time step *Δt* that is smaller than any important time scales in the
    problem we are solving. We’ll use the Euler method, which approximates the time-slope
    of each state variable over the course of one time step by the time derivative
    of that variable at the beginning of the time step. [Figure 15-3](ch15.xhtml#ch15fig3)
    shows the Euler method for solving Newton’s second law in one dimension.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决微分方程 15.2、15.3 和 15.4，我们将对时间进行离散化，选择一个比问题中任何重要时间尺度都小的时间步长*Δt*。我们将使用欧拉法，通过该方法在一个时间步内，利用该状态变量在时间步开始时的时间导数来近似每个状态变量的时间斜率。[图
    15-3](ch15.xhtml#ch15fig3)展示了欧拉法如何用于求解牛顿第二定律的一维形式。
- en: '![Image](Images/249fig01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/249fig01.jpg)'
- en: '*Figure 15-3: Euler method for Newton’s second law in one dimension*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：一维欧拉法求解牛顿第二定律*'
- en: Unlike the schematic diagram of [Figure 15-1](ch15.xhtml#ch15fig1), with values
    that continuously change with time, the functional diagram in [Figure 15-3](ch15.xhtml#ch15fig3)
    has values that do not change. Change in a quantity, such as position, over time
    is represented by a sequence of values on different wires.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与[图 15-1](ch15.xhtml#ch15fig1)中值随时间连续变化的示意图不同，[图 15-3](ch15.xhtml#ch15fig3)中的功能图的值保持不变。一个量（如位置）随时间变化的过程通过不同电线上的一系列值来表示。
- en: The function `euler1D`, shown below, transforms a differential equation into
    a state-update function, as shown in [Figure 15-2](ch15.xhtml#ch15fig2). To do
    this, it takes a time step in addition to the differential equation as input.
    Each state variable is updated by changing its value by its derivative (calculated
    from the differential equation) multiplied by the time step.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下述函数`euler1D`将微分方程转化为状态更新函数，如[图 15-2](ch15.xhtml#ch15fig2)所示。为此，它除了微分方程外，还将时间步长作为输入。每个状态变量通过改变其值，由其导数（从微分方程中计算得到）与时间步长的乘积来更新。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Figure 15-3](ch15.xhtml#ch15fig3) composes a state-update function over and
    over again. We call the state-update function `updateTXV` because it updates time,
    position, and velocity. As before, let’s go through three expressions of this
    state-update function. [Figure 15-4](ch15.xhtml#ch15fig4) shows the state-update
    function as a functional diagram, indicating how a new time-position-velocity
    triple is formed from an old triple.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-3](ch15.xhtml#ch15fig3)不断地组合状态更新函数。我们将这个状态更新函数称为`updateTXV`，因为它更新时间、位置和速度。如前所述，接下来我们将介绍这个状态更新函数的三种表示方式。[图
    15-4](ch15.xhtml#ch15fig4)展示了状态更新函数的功能图，说明了如何从一个旧的三元组生成一个新的时间-位置-速度三元组。'
- en: '![Image](Images/250fig01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/250fig01.jpg)'
- en: '*Figure 15-4: How to update the state variables time, position, and velocity
    when a small time interval* Δ*t has elapsed*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：当一个小的时间间隔* Δ*t *已经过去时，如何更新状态变量时间、位置和速度*'
- en: Now we’ll give state-update equations in mathematical notation. The state-update
    equations tell us how the state variables time, position, and velocity must be
    updated to advance to the next time step.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将给出数学符号表示的状态更新方程。状态更新方程告诉我们如何更新状态变量——时间、位置和速度——以便进入下一个时间步。
- en: '![Image](Images/251equ01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/251equ01.jpg)'
- en: Finally, we define the Haskell function `updateTXV`, which produces a new state
    triple from an old state triple.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了Haskell函数`updateTXV`，它从旧的状态三元组生成新的状态三元组。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that `updateTXV` is essentially the composition of `newtonSecond1D` and
    `euler1D`, so it transforms the mass and force data (the first of our five data
    representations) into a state-update function (the third of the five).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`updateTXV`本质上是`newtonSecond1D`和`euler1D`的组合，因此它将质量和力数据（我们五种数据表示中的第一种）转化为状态更新函数（五种中的第三种）。
- en: Producing a List of States
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成状态列表
- en: The next step in the data flow of [Figure 15-2](ch15.xhtml#ch15fig2) is to produce
    an infinite list of states from the state-update function and an initial state.
    The Haskell Prelude function `iterate` can do this, essentially transforming [Figure
    15-4](ch15.xhtml#ch15fig4) into [Figure 15-3](ch15.xhtml#ch15fig3). A list of
    time-position-velocity triples can be regarded as a solution to a Newton’s second
    law problem. The list of states contains a time-position-velocity triple for every
    time that has been probed by the Euler method of [Figure 15-3](ch15.xhtml#ch15fig3).
    The function `statesTXV` produces a list of states when given a time step, a mass,
    an initial state, and a list of force functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的下一步是根据状态更新函数和初始状态生成无限的状态列表，参见[图15-2](ch15.xhtml#ch15fig2)。Haskell Prelude函数`iterate`可以做到这一点，本质上将[图15-4](ch15.xhtml#ch15fig4)转换为[图15-3](ch15.xhtml#ch15fig3)。时间-位置-速度三元组的列表可以视为牛顿第二定律问题的解决方案。这个状态列表包含了每次通过欧拉方法（见[图15-3](ch15.xhtml#ch15fig3)）探测到的时间-位置-速度三元组。函数`statesTXV`在给定时间步长、质量、初始状态和力函数列表时，生成一个状态列表。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All we are doing here is iterating the update function to produce an infinite
    list of states. Note that we need to pass the time step, mass, and list of forces
    as parameters to `updateTXV` before it can serve as an iterable function passable
    to `iterate`. Iterate requires a function with type `a -> a` that can be applied
    again and again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的就是迭代更新函数，以生成一个无限状态列表。请注意，我们需要在`updateTXV`之前将时间步长、质量和力列表作为参数传入，才能使其成为一个可迭代的函数，可以传递给`iterate`。`Iterate`要求一个类型为`a
    -> a`的函数，该函数可以反复应用。
- en: The function `statesTXV` transforms the mass and force data (the first of our
    five data representations), along with a time step and an initial state, into
    an infinite list of states (the fourth of our five representations). With this
    function, we have a general-purpose way of solving any Newton’s second law type
    problem in one spatial dimension. By a solution, we mean an infinite list of states
    (time-position-velocity triples) of the object, spaced one time step apart from
    each other. From this infinite list of states, we can extract whatever data we
    are most interested in and graph it or animate it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`statesTXV`将质量和力的数据（我们五个数据表示中的第一个），以及一个时间步长和初始状态，转换为一个无限的状态列表（我们五个数据表示中的第四个）。通过这个函数，我们就有了一种通用的方法来解决任何一维空间中的牛顿第二定律问题。这里的“解决方案”是指一个无限的状态列表（时间-位置-速度三元组），这些状态彼此之间的时间间隔为一个时间步长。从这个无限的状态列表中，我们可以提取出我们最感兴趣的数据，并将其绘制成图表或动画。
- en: Position and Velocity Functions
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位置和速度函数
- en: For our fifth and last data representation, we wish to write a function `velocity`
    `Ftxv`, similar to `velocityCF`, `velocityFt`, `velocityFv`, and `velocityFtv`,
    but for the case of forces that depend on time, position, and velocity. This function
    will transform the mass and force data (the first of our five data representations),
    along with a time step and an initial state, into a velocity function (part of
    the fifth of our five representations).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第五个也是最后一个数据表示，我们希望编写一个函数`velocity` `Ftxv`，类似于`velocityCF`、`velocityFt`、`velocityFv`和`velocityFtv`，但针对依赖于时间、位置和速度的力。这个函数将把质量和力的数据（我们五个数据表示中的第一个），以及一个时间步长和初始状态，转换成一个速度函数（我们五个数据表示中的第五个部分）。
- en: To help us do this, we want to write a function `velocity1D` that transforms
    from an infinite list of states (the fourth of our five data representations)
    into a velocity function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们做到这一点，我们想编写一个函数`velocity1D`，它将从一个无限状态列表（我们五个数据表示中的第四个）转换成一个速度函数。
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We name the infinite list of states `sts` and the desired time `t`. We assume
    that the time step stays the same throughout the infinite list of states, and
    we calculate the time step from the time values in the first two states of the
    list. In the first two lines of the `let` clause, we use the list index operator
    (`!!`) to pick out the first and second states of the list. Since `State1D` is
    a type synonym for `(R,R,R)`, we use pattern matching to pick out the time from
    the state. The local variables `t0` and `t1` are the times for the first two states
    in the list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将无限状态列表命名为`sts`，并将目标时间命名为`t`。我们假设在整个无限状态列表中，时间步长保持不变，并通过列表中前两个状态的时间值来计算时间步长。在`let`子句的前两行中，我们使用列表索引运算符（`!!`）提取出列表中的第一个和第二个状态。由于`State1D`是`(R,R,R)`的类型同义词，我们使用模式匹配来提取状态中的时间。局部变量`t0`和`t1`分别是列表中前两个状态的时间。
- en: The third line in the `let` clause defines a local variable `dt` for the time
    step, calculated as the difference between the times of the first and second states.
    The fourth line in the `let` clause computes the number of time steps required
    to reach the state that is closest to the desired time, and it names this number
    of steps with the local variable `numSteps`. The fifth line in the `let` clause
    uses the list index operator to pick out the state closest to the desired time
    and then names the velocity of that state `v0` using pattern matching.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`语句中的第三行定义了一个局部变量`dt`，表示时间步长，计算方法是第一个和第二个状态的时间差。`let`语句中的第四行计算了达到最接近目标时间的状态所需的时间步数，并将这个步数命名为局部变量`numSteps`。`let`语句中的第五行使用列表索引运算符来选出最接近目标时间的状态，然后通过模式匹配将该状态的速度命名为`v0`。'
- en: All of the real work in this function is done in the `let` clause. The function
    returns `v0`, which is the velocity that occurs closest to the desired time `t`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的实际工作都在`let`语句中完成。该函数返回`v0`，即最接近目标时间`t`的速度。
- en: For the function `velocityFtxv`, which does the full transformation, we’ll use
    the infinite list produced by `statesTXV`, in conjunction with `velocity1D`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数`velocityFtxv`，我们将使用由`statesTXV`生成的无限列表，结合`velocity1D`进行完整的转换。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once we have a velocity function, we could integrate to get a position function,
    but all of this position information is contained in our list of states, so we
    might as well extract the position function from that using `position1D`, which
    is very similar to `velocity1D`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到速度函数，我们可以通过积分得到位置函数，但所有这些位置信息都包含在我们的状态列表中，所以我们可以直接从中提取位置函数，方法是使用`position1D`，它与`velocity1D`非常相似。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here is the function `positionFtxv`, which makes the full transition from our
    initial data representation in terms of mass and forces, along with a time step
    and an initial state, into our final representation giving the position of our
    object as a function of time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数`positionFtxv`，它将我们从初始数据表示（通过质量和力表示）以及时间步长和初始状态，转换为最终的表示，给出物体位置随时间变化的函数。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the functions `velocityFtxv` and `positionFtxv`, we have a general purpose
    way of solving any Newton’s second law problem in one spatial dimension.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`velocityFtxv`和`positionFtxv`这两个函数，我们就有了一种通用的方法来解决任何一维空间中的牛顿第二定律问题。
- en: 'Next let’s look at an example of where to use this technology: a Ping-Pong
    ball oscillating at the end of a Slinky. The restoring force of the Slinky on
    the ball depends on the position of the Ping-Pong ball, and air resistance depends
    on the velocity of the ball.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看一个使用这种技术的例子：一个乒乓球在弹簧玩具的末端摆动。弹簧对乒乓球的恢复力取决于乒乓球的位置，而空气阻力则取决于乒乓球的速度。
- en: A Damped Harmonic Oscillator
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个受阻尼的简谐振动器
- en: As an example of a situation with forces that depend on position and velocity,
    let’s consider a damped harmonic oscillator. In particular, let’s consider a Ping-Pong
    ball oscillating at the end of a vertically hanging Slinky. A Slinky is a spring,
    made of metal or plastic, that is sold as a child’s toy. We’ll choose a coordinate
    system where up is positive and choose the zero of position to be the place where
    the lower end of the Slinky hangs without the Ping-Pong ball attached. The Ping-Pong
    ball has a mass of 2.7 g and a radius of 2 cm.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个位置和速度相关力的例子，考虑一个受阻尼的简谐振动器。特别地，考虑一个乒乓球在垂直悬挂的弹簧玩具末端摆动的情况。弹簧玩具是一种由金属或塑料制成的弹簧，被当作儿童玩具出售。我们选择一个坐标系，其中向上为正，并选择位置的零点为弹簧玩具下端没有乒乓球时的挂点。乒乓球的质量为2.7克，半径为2厘米。
- en: We’ll include three forces on the ball, all acting vertically. The first force
    is produced by the spring and acts to restore the mass toward the equilibrium
    position. The spring force is given by *Hooke’s law*,
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑作用在乒乓球上的三个力，所有力都垂直作用。第一个力来自弹簧，作用于恢复物体至平衡位置。弹簧力由*胡克定律*给出，
- en: '![Image](Images/254equ01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/254equ01.jpg)'
- en: which claims that the force produced by the spring is proportional to the displacement
    *x*[0] of the mass from its equilibrium position. The constant *k* is called the
    *spring constant* of the spring. A spring with a large spring constant is stiff
    and takes lots of force to extend or compress. The minus sign makes the spring
    force a *restoring force*, which acts in a direction to restore the object to
    its equilibrium position.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该公式声称弹簧产生的力与质量从平衡位置的位移*x*[0]成正比。常数*k*称为弹簧的*弹簧常数*。具有较大弹簧常数的弹簧较为坚硬，需要较大的力来拉伸或压缩。负号使弹簧力成为*恢复力*，其作用方向是将物体恢复到平衡位置。
- en: The equilibrium position is *x*[0] = 0\. If *x*[0] is positive, then *F*[spring](*x*[0])
    is negative, and the force acts toward the equilibrium position. If *x*[0] is
    negative, then *F*[spring](*x*[0]) is positive, and again the force acts toward
    the equilibrium position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡位置为*x*[0] = 0。如果*x*[0]为正，则*F*[spring](*x*[0])为负，力的方向是指向平衡位置。如果*x*[0]为负，则*F*[spring](*x*[0])为正，力的方向同样指向平衡位置。
- en: The spring force depends only on the ball’s position and not on its velocity
    or on the time. But knowing that we want to use a function like `statesTXV` or
    `positionFtxv`, which requires a list of forces `State1D -> Force` given as functions
    of the state, we’ll write Hooke’s law so that it has this type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧力只依赖于球体的位置，而不依赖于它的速度或时间。但考虑到我们想使用一个类似`statesTXV`或`positionFtxv`的函数，它需要一个作为状态函数的力列表`State1D
    -> Force`，我们将按此形式编写胡克定律。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second force is the force of air resistance, a force that damps the natural
    oscillation of the ball on the spring. We’ll use Equation 14.9 for air resistance,
    repeated here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种力是空气阻力，它会阻碍弹簧上球体的自然振动。我们将使用方程14.9来表示空气阻力，公式如下。
- en: '![Image](Images/254equ02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/254equ02.jpg)'
- en: We use a drag coefficient of 2.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的阻力系数为2。
- en: The third force is the force of gravity acting on the ball. Near Earth’s surface,
    the force of gravity on an object with mass *m* is
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种力是作用在球体上的重力。在地球表面，质量为*m*的物体所受的重力为
- en: '*F[g]* = –*mg*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*F[g]* = –*mg*'
- en: where *g* = 9.80665 m/s² is the acceleration of gravity, and where we employ
    a coordinate system in which “away from Earth’s center” is the positive direction.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*g* = 9.80665 米/秒²是重力加速度，并且我们采用一个坐标系统，其中“远离地球中心”为正方向。
- en: We take the Slinky to have a spring constant of 0.8 kg/s². We’ll release the
    ball at a position 10 cm above the equilibrium position so that *x*(0 s) = 0.1
    m and *v*(0 s) = 0 m/s.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设弹簧的弹簧常数为0.8 kg/s²。我们将在距离平衡位置10厘米的地方释放球体，意味着*x*(0秒) = 0.1米，*v*(0秒) = 0米/秒。
- en: Before we use our Haskell functions to investigate the motion of the ball, let’s
    investigate it using Euler’s method by hand.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Haskell函数来研究球体的运动之前，让我们先通过手动计算欧拉方法来研究它。
- en: Euler Method by Hand
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动计算欧拉方法
- en: We want to have a clear mental picture of what the computer is doing when it
    applies the Euler method. To this end, we will calculate a few steps of the Euler
    method by hand (meaning with a calculator) to see in detail what is happening.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望清晰地理解计算机在应用欧拉方法时的处理过程。为此，我们将手动计算欧拉方法的几个步骤（即用计算器），以便详细了解发生了什么。
- en: We’ll use the state-update Equations 15.6 and 15.7 with a time step of Δ*t*
    = 0.1 s. A time step of 0.1 seconds is too large to get accurate results for this
    problem, but it serves to show the essence of the Euler method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用状态更新方程15.6和15.7，时间步长为Δ*t* = 0.1秒。0.1秒的时间步长对于这个问题来说过大，无法获得精确的结果，但它有助于展示欧拉方法的核心思想。
- en: Our mission is to complete the following table. We can fill in all of the time
    values because they are simply spaced at 0.1 s intervals. We’ll also fill in the
    initial values of position and velocity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是完成以下表格。由于时间值是以0.1秒的间隔均匀分布的，因此我们可以填入所有时间值。我们还将填入位置和速度的初始值。
- en: '| **t (s)** | **x(t) (m)** | **v(t) (m/s)** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **t (秒)** | **x(t) (米)** | **v(t) (米/秒)** |'
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0.0 | 0.1000 | 0.0000 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 0.0 | 0.1000 | 0.0000 |'
- en: '| 0.1 |  |  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 0.1 |  |  |'
- en: '| 0.2 |  |  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 0.2 |  |  |'
- en: '| 0.3 |  |  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 0.3 |  |  |'
- en: 'The net force on the Ping-Pong ball is given by the following expression:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 乒乓球所受的合力由以下表达式给出：
- en: '![Image](Images/255equ01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/255equ01.jpg)'
- en: Using *t* = 0.0 s, *x*(0.0 s) = 0.1000 m and *v*(0.0 s) = 0.0000 m/s (in other
    words, the information in the first row of our table) in the state-update Equations
    15.6 and 15.7, we can find *x*(0.1 s) and *v*(0.1 s) (the information in the second
    row of our table). The state-update equations are exactly what we need to produce
    a new row of our table from an existing row.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*t* = 0.0 s，*x*(0.0 s) = 0.1000 m和*v*(0.0 s) = 0.0000 m/s（换句话说，第一行的表格信息），代入状态更新方程15.6和15.7，我们可以求出*x*(0.1
    s)和*v*(0.1 s)（表格第二行的信息）。状态更新方程正是我们需要的，用来根据现有的一行数据生成新的一行数据。
- en: '![Image](Images/255equ02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/255equ02.jpg)'
- en: Using *t* = 0.1 s, *x*(0.1 s) = 0.1000 m, and *v*(0.1 s) = –3.9436 m/s (the
    information in the second row of our table) in the state-update equations, we
    can find *x*(0.2 s) and *v*(0.2 s) (the information in the third row).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*t* = 0.1 s，*x*(0.1 s) = 0.1000 m，以及*v*(0.1 s) = –3.9436 m/s（我们表格第二行的信息），代入状态更新方程，我们可以求出*x*(0.2
    s)和*v*(0.2 s)（我们表格第三行的信息）。
- en: '![Image](Images/255equ03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/255equ03.jpg)'
- en: Using *t* = 0.2 s, *x*(0.2 s) = –0.2944 m, and *v*(0.2 s) = –7.0005 m/s (the
    information in the third row of our table), we can find *x*(0.3 s) and *v*(0.3
    s). (the information in the fourth row).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*t* = 0.2 s，*x*(0.2 s) = –0.2944 m，以及*v*(0.2 s) = –7.0005 m/s（我们表格第三行的信息），代入状态更新方程，我们可以求出*x*(0.3
    s)和*v*(0.3 s)（我们表格第四行的信息）。
- en: '![Image](Images/256equ01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/256equ01.jpg)'
- en: 'The completed table looks as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的表格如下所示：
- en: '| **t (s)** | **x(t) (m)** | **v(t) (m/s)** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **t (s)** | **x(t) (m)** | **v(t) (m/s)** |'
- en: '| --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0.0 | 0.1000 | 0.0000 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 0.0 | 0.1000 | 0.0000 |'
- en: '| 0.1 | 0.1000 | –3.9436 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 0.1 | 0.1000 | –3.9436 |'
- en: '| 0.2 | –0.2944 | –7.0005 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 0.2 | –0.2944 | –7.0005 |'
- en: '| 0.3 | –0.9945 | 3.5359 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 0.3 | –0.9945 | 3.5359 |'
- en: Since states are time-position-velocity triples, this completed table contains
    the first four states of the Ping-Pong ball for the Euler method with a time step
    of 0.1 s. If we ask the computer to produce an infinite list of states using our
    function `statesTXV`, the first four states should look like this. We can imagine
    that the process we used to complete this table is what the computer is doing
    over and over again to produce a list of states for us.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态是时间-位置-速度三元组，完成的这个表格包含了使用欧拉方法和0.1 s时间步长得到的乒乓球的前四个状态。如果我们让计算机使用我们的`statesTXV`函数生成无限长的状态列表，那么前四个状态应当是这样的。我们可以想象，完成这个表格的过程就是计算机反复执行的操作，用来为我们生成一个状态列表。
- en: Let’s now turn to the technology we developed earlier in the chapter to find
    the position of the Ping-Pong ball as a function of time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到本章前面开发的技术，来找出乒乓球的位置随时间的变化。
- en: 'Method 1: Producing a List of States'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 1：生成状态列表
- en: Here we’ll use the `statesTXV` function to produce a list of states and then
    extract position versus time information to make a graph.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`statesTXV`函数生成状态列表，然后提取位置与时间的信息来绘制图表。
- en: We’re not required to give a name to the list of forces that act on the Ping-Pong
    ball. We could insert the list as the appropriate input to `statesTXV`, but I
    think it may organize and help our thinking to give the list of forces a name.
    Let’s call it `dampedHOForces`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要给作用在乒乓球上的力列表命名。我们可以将这个列表作为适当的输入传递给`statesTXV`，但我认为给这个力列表命名可能有助于我们的思考并使其更有条理。我们就把它称作`dampedHOForces`。
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We see that this is a list of the three forces we discussed earlier. First we
    have the spring force, then the force of air resistance, and then the force of
    gravity. We use anonymous-function notation to express the latter two forces because
    they need to be expressed as functions of the state. In the case of the force
    of gravity, we don’t care at all about the state, so we don’t need to name the
    state or name the time, position, and/or velocity variables that make up the state.
    For the force of air resistance, underscores in the time and position entries
    for the state are reminders that the air resistance function does not need their
    values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到这是一份我们之前讨论的三个力的列表。首先是弹簧力，然后是空气阻力，最后是重力。我们使用匿名函数符号来表示后两个力，因为它们需要表示为状态的函数。对于重力，我们完全不关心状态，因此不需要指定状态或组成状态的时间、位置和/或速度变量。对于空气阻力，状态中的时间和位置条目下划线提醒我们，空气阻力函数并不需要它们的值。
- en: To produce an infinite list of states, we use the `statesTXV` function with
    a time step of 1 ms, or 0.001 s, which is on the threshold of acceptability in
    the sense that smaller time steps would produce a graph that is only a little
    bit different in its results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成无限的状态列表，我们使用`statesTXV`函数，时间步长为1毫秒，即0.001秒，这在接受范围内，因为更小的时间步长只会导致图形结果有细微差别。
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need to send `dampedHOStates` all of the information about our problem. In
    addition to the time step of 0.001 s, we send the Ping-Pong ball mass of 0.0027
    kg, the initial state consisting of time 0 s, position 0.1 m, and velocity 0 m/s,
    and the list of forces, which we named `dampedHOForces`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将所有关于我们问题的信息传递给`dampedHOStates`。除了0.001秒的时间步长外，我们还需要传递乒乓球的质量0.0027 kg，初始状态为时间0秒、位置0.1米和速度0米/秒，以及我们命名为`dampedHOForces`的力的列表。
- en: If you want to look at the raw time-position-velocity data, you can use the
    list element operator (`!!`) to select particular states from the list, or you
    can `take` the first several elements of this infinite list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看原始的时间-位置-速度数据，可以使用列表元素操作符（`!!`）来选择列表中的特定状态，或者你可以`take`这个无限列表中的前几个元素。
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A list of pairs is something we can plot with the `plotPath` function from the
    `gnuplot` package, but we need to truncate the list to a finite list before plotting;
    otherwise, `plotPath` will hang while trying to finish calculating an infinite
    list. In the code that follows, we use the `take` function to extract the first
    3,000 states, corresponding to the first three seconds of motion.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一对对的数据是我们可以使用`gnuplot`包中的`plotPath`函数绘制的内容，但在绘制之前，我们需要将列表截断为有限的列表；否则，`plotPath`会在计算无限列表时挂起。接下来的代码中，我们使用`take`函数提取前3000个状态，表示运动的前三秒。
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Figure 15-5](ch15.xhtml#ch15fig5) shows the oscillation of the ball as a function
    of time. Notice the oscillation is not centered at position zero. This is because
    zero is the equilibrium position of the spring with no ball attached. When we
    attach the Ping-Pong ball, its weight will extend the spring downward, forming
    a new equilibrium position at the place where – *k*[*x*0] – *mg* = 0\. The upward
    force of the spring cancels the downward force of gravity; air resistance plays
    no role in the new equilibrium position because the ball is not moving at equilibrium.
    The new equilibrium position is *x*[0] = *–mg*/*k* = –0.033 m, so this is the
    position about which the oscillation is centered, as you can see in [Figure 15-5](ch15.xhtml#ch15fig5).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-5](ch15.xhtml#ch15fig5)显示了球随时间变化的振荡情况。注意，振荡并没有以位置零为中心。这是因为零是没有附着球的弹簧的平衡位置。当我们附上乒乓球时，它的重量会拉伸弹簧向下，形成一个新的平衡位置，在此位置
    – *k*[*x*0] – *mg* = 0。弹簧的向上力与重力的向下力相互抵消；空气阻力在新的平衡位置中不起作用，因为球在平衡时并未移动。新的平衡位置是
    *x*[0] = *–mg*/*k* = –0.033 m，因此振荡围绕此位置进行，如你在[图 15-5](ch15.xhtml#ch15fig5)中所见。'
- en: '![Image](Images/258fig01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/258fig01.jpg)'
- en: '*Figure 15-5: Oscillation of a Ping-Pong ball on the end of a Slinky*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：乒乓球在弹簧末端的振荡*'
- en: Having explored one data representation for a solution to Newton’s second law,
    namely a list of states, let’s take a look at another representation, that of
    position and velocity functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了使用状态列表作为解决牛顿第二定律的一种数据表示方式后，让我们来看另一种表示方式，即位置和速度函数。
- en: 'Method 2: Producing Position and Velocity Functions'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法二：生成位置和速度函数
- en: We can use the function `positionFtxv` to produce a position function for the
    Ping-Pong ball on the Slinky.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`positionFtxv`函数为乒乓球在弹簧上的运动生成一个位置函数。
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All of the information necessary to describe the situation is included in the
    one line that makes up the body of this function: the 0.0027-kg mass; the initial
    state consisting of time 0 s, position 0.1 m, and velocity 0 m/s; and the list
    `dampedHOForces` of three forces defined earlier.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 描述此情况所需的所有信息都包含在构成此函数主体的那一行中：0.0027 kg的质量；初始状态为时间0秒、位置0.1米和速度0米/秒；以及之前定义的三种力的列表`dampedHOForces`。
- en: The following code will produce a graph very much like that shown in [Figure
    15-5](ch15.xhtml#ch15fig5).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将生成与[图 15-5](ch15.xhtml#ch15fig5)中所示非常相似的图表。
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can use the function `velocityFtxv` to produce a velocity function for the
    Ping-Pong ball on the Slinky.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`velocityFtxv`函数为乒乓球在弹簧上的运动生成一个速度函数。
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As before, we can graph our function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所述，我们可以绘制我们的函数图形：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code produces [Figure 15-6](ch15.xhtml#ch15fig6), which shows a graph of
    velocity versus time for the Ping-Pong ball. Velocity starts at zero since we
    release the ball from rest and then becomes negative as the ball moves downward.
    The velocity oscillates and experiences the same sort of damping that the position
    does.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了[图15-6](ch15.xhtml#ch15fig6)，图中展示了乒乓球的速度与时间的关系。由于我们将球从静止状态释放，速度从零开始，随着球向下运动，速度变为负值。速度发生振荡，并且表现出与位置相同的阻尼效应。
- en: '![Image](Images/259fig01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/259fig01.jpg)'
- en: '*Figure 15-6: Velocity of a Ping-Pong ball on the end of a Slinky*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-6：一只弹簧球上的乒乓球的速度*'
- en: The Euler method is a general-purpose state-based way of solving a system of
    first-order differential equations (which is more or less equivalent to a single
    higher-order differential equation). However, the Euler method does not usually
    get very much bang out of the computational buck, in that the time step often
    must be very small to get acceptable results. There are many other methods to
    choose from, and a small modification to the Euler method, which we explore in
    the next section, typically allows one to get acceptable results with a larger
    step size, decreasing the computational cost of a calculation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉方法是一种通用的基于状态的求解一阶常微分方程组（或等价于单一高阶微分方程）的方法。然而，欧拉方法通常无法充分发挥计算效率，因为为了得到可接受的结果，时间步长通常需要非常小。有许多其他方法可以选择，我们将在下一节中探讨对欧拉方法的小改动，这通常能够在较大的步长下得到可接受的结果，从而减少计算成本。
- en: Euler-Cromer Method
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 欧拉-克罗默方法
- en: We can make a slight modification to the Euler method that improves the results
    of Newton’s second law calculations in many cases. Instead of the functional diagram
    that describes the Euler method in [Figure 15-3](ch15.xhtml#ch15fig3), let’s look
    at a functional diagram for the Euler-Cromer method, shown in [Figure 15-7](ch15.xhtml#ch15fig7).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对欧拉方法做一个小的修改，从而在许多情况下改善牛顿第二定律计算的结果。我们不再使用描述欧拉方法的功能图[图15-3](ch15.xhtml#ch15fig3)，而是来看一下欧拉-克罗默方法的功能图，如[图15-7](ch15.xhtml#ch15fig7)所示。
- en: '![Image](Images/260fig01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/260fig01.jpg)'
- en: '*Figure 15-7: The Euler-Cromer method for Newton’s second law in one dimension*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-7：一维牛顿第二定律的欧拉-克罗默方法*'
- en: The difference lies in the value of velocity used to update position. The Euler
    method used the old velocity to update the position. The Euler-Cromer method calculates
    a new velocity using the same velocity-update equation as in the Euler method
    but then uses this new velocity to update the position.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于用来更新位置的速度值。欧拉方法使用旧的速度值来更新位置。欧拉-克罗默方法使用与欧拉方法相同的速度更新方程计算新的速度，然后用这个新速度来更新位置。
- en: 'Instead of the state-update Equations 15.6 and 15.7 for the Euler method, the
    Euler-Cromer method uses the following slightly modified equations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉-克罗默方法使用了以下略微修改过的方程，而不是欧拉方法中的状态更新方程15.6和15.7：
- en: '![Image](Images/261equ01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/261equ01.jpg)'
- en: The velocity-update equation for Euler-Cromer is the same as the velocity-update
    equation for Euler. The difference is the replacement of *v*(*t*) with *v*(*t*
    + Δ*t*) in the position-update equation. While the order in which the Euler update
    equations 15.6 and 15.7 are evaluated is irrelevant, the Euler-Cromer velocity-update
    equation must be evaluated before the position-update equation because the updated
    velocity is used in the latter equation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉-克罗默方法的速度更新方程与欧拉方法的速度更新方程相同。不同之处在于在位置更新方程中将*v*(*t*)替换为*v*(*t* + Δ*t*)。尽管欧拉方法中的方程15.6和15.7的求值顺序无关紧要，但欧拉-克罗默方法中的速度更新方程必须在位置更新方程之前求值，因为更新后的速度将用于后者方程。
- en: 'However, one of the benefits of a functional language with names that refer
    to objects that don’t change is that we don’t need to worry about telling the
    computer to update the velocity first. We can put the equations in whatever order
    we want, and the compiler will figure out an appropriate order of evaluation.
    The following function plays the role for Euler-Cromer that `euler1D` played for
    Euler:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用具有不变对象引用的函数式编程语言的一个好处是，我们不需要担心告诉计算机先更新速度。我们可以按照任何顺序排列方程，编译器会自动确定合适的求值顺序。以下函数在欧拉-克罗默方法中起到了和`euler1D`在欧拉方法中所起的作用：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this code, I use the local variable `v1`, which is the updated value of velocity,
    before I give the equation for how to find it. The compiler will know to order
    the evaluations so that `v1` is computed before it is used.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我使用了局部变量 `v1`，它是更新后的速度值，先给出如何计算它的方程。编译器会知道如何安排计算顺序，以便在使用 `v1` 之前先计算出它。
- en: The function `updateTXVEC` is the Euler-Cromer version of the state-update function
    corresponding to Euler’s `updateTXV`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `updateTXVEC` 是对应欧拉的 `updateTXV` 的欧拉-克罗默版本的状态更新函数。
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Euler-Cromer method comes closer to conserving energy in cases where it
    should be conserved, and it’s generally better for situations with oscillatory
    behavior. Both the Euler and Euler-Cromer methods converge to the correct result
    as the time step is decreased, but Euler-Cromer can often achieve acceptable results
    with a larger time step than Euler would require.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉-克罗默方法在应该保持能量守恒的情况下更接近能量守恒，且通常对于具有振荡行为的情况更为适用。无论是欧拉方法还是欧拉-克罗默方法，当时间步长减小时，两者都会收敛到正确的结果，但欧拉-克罗默方法通常能在比欧拉方法所需的更大时间步长下也能得到可接受的结果。
- en: '[Figure 15-7](ch15.xhtml#ch15fig7) shows an alternative uncoiling of [Figure
    15-1](ch15.xhtml#ch15fig1) corresponding to the Euler-Cromer method. Comparing
    [Figure 15-3](ch15.xhtml#ch15fig3) (which describes the Euler method) and [Figure
    15-7](ch15.xhtml#ch15fig7), we see that the only difference is that the updated
    velocity is used to update the position.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-7](ch15.xhtml#ch15fig7) 显示了与欧拉-克罗默方法对应的 [图 15-1](ch15.xhtml#ch15fig1)
    的另一种展开方式。比较 [图 15-3](ch15.xhtml#ch15fig3)（描述欧拉方法）和 [图 15-7](ch15.xhtml#ch15fig7)，我们可以看到，唯一的区别在于使用更新后的速度来更新位置。'
- en: The functions `statesTXV`, `velocityFtxv`, and `positionFtxv` use the function
    `updateTXV`, which means they use the Euler method. In Exercise 15.13, you are
    asked to write analogous functions for the Euler-Cromer method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `statesTXV`、`velocityFtxv` 和 `positionFtxv` 使用了函数 `updateTXV`，这意味着它们使用的是欧拉方法。在习题
    15.13 中，你需要为欧拉-克罗默方法编写类似的函数。
- en: Note that the Euler-Cromer method is specific to second-order differential equations
    because there must be a state variable playing the role of velocity that can be
    updated first and then used to update the main unknown function (position for
    Newton’s second law).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，欧拉-克罗默方法是特定于二阶微分方程的，因为必须有一个状态变量扮演速度的角色，可以先更新它，然后用来更新主要未知函数（对于牛顿第二定律而言是位置）。
- en: As we expand our study of mechanics in the next several chapters, we’ll continue
    to solve differential equations. The final section of this chapter prepares the
    way for future chapters by treating the process of differential equation solving
    in greater generality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在接下来的几章中继续研究力学，我们将继续解微分方程。本章的最后一节通过更普遍地处理微分方程求解的过程，为未来章节的内容做准备。
- en: Solving Differential Equations
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解微分方程
- en: A typical mechanics problem starts as a physics problem as we use physical information
    to construct a differential equation, then becomes a mathematics problem as we
    solve the differential equation, and finally becomes a physics problem again as
    we interpret the results. This section focuses on the mathematical activity, beginning
    with a differential equation and ending with knowledge of how the state variables
    change with the independent variable (which in mechanics represents time).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的力学问题从物理问题开始，我们利用物理信息构建微分方程，然后变成数学问题，通过解微分方程得到结果，最后再变成物理问题，通过解释结果来得到物理意义。本节聚焦于数学活动，从微分方程开始，到最后掌握状态变量如何随自变量（在力学中代表时间）变化。
- en: In [Figure 15-2](ch15.xhtml#ch15fig2), we showed how information was transformed
    in the process of solving a mechanics problem. Starting with mass and force information,
    Newton’s second law produces a differential equation. The Euler method then transforms
    this differential equation into a state-update function. By iterating the state-update
    function, given some initial state, we arrive at a list of states. This list of
    states can be regarded as a solution to the problem, or we can proceed to an additional
    step and produce position and velocity functions for the object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 15-2](ch15.xhtml#ch15fig2) 中，我们展示了在解决力学问题的过程中信息是如何转化的。从质量和力的信息开始，牛顿第二定律产生了一个微分方程。然后，欧拉方法将该微分方程转化为状态更新函数。通过迭代状态更新函数，给定初始状态，我们可以得到一系列状态。这些状态序列可以看作是问题的解，或者我们可以进行一个附加步骤，得出物体的位移和速度函数。
- en: In the next several chapters, in which we use vectors to describe quantities
    like velocity and treat multiple interacting particles, we will continue to view
    the process of solving a mechanics problem as one of information transformation,
    like that in [Figure 15-2](ch15.xhtml#ch15fig2). For this purpose we need to generalize
    [Figure 15-2](ch15.xhtml#ch15fig2) in two ways. The function `euler1D` will work
    with any differential equation that uses the state space `State1D`. In the previous
    chapter, we used `Velocity` and `(Time,Velocity)` as state spaces, and in the
    coming chapters, we will continue to expand the state spaces we use to include
    vectors and multiple particles. We want to be able to use the Euler method with
    the new state spaces we design, and it would be really great if we could write
    the Euler method once and for all in a way that would work with any state space.
    Later in this section, we’ll identify the commonality among these state spaces
    that allows us to do this. So, the first generalization is from the state space
    `State1D` to a broader class of state spaces.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将使用向量来描述像速度这样的量，并处理多个相互作用的粒子，我们将继续将求解力学问题的过程视为信息转化的过程，就像在[图 15-2](ch15.xhtml#ch15fig2)中那样。为此，我们需要以两种方式对[图
    15-2](ch15.xhtml#ch15fig2)进行推广。`euler1D`方法将适用于任何使用状态空间`State1D`的微分方程。在前一章中，我们使用了`Velocity`和`(Time,Velocity)`作为状态空间，在接下来的章节中，我们将继续扩展我们使用的状态空间，包括向量和多个粒子。我们希望能够使用我们设计的新状态空间来应用欧拉方法，并且如果我们能够编写一次通用的欧拉方法，使其适用于任何状态空间，那将是非常棒的。在本节后面，我们将找出这些状态空间之间的共性，这使得我们能够做到这一点。因此，第一个推广是从状态空间`State1D`到更广泛的状态空间类别。
- en: '[Figure 15-2](ch15.xhtml#ch15fig2) uses the Euler method to transform a differential
    equation into a state-update function. Now that we have introduced the Euler-Cromer
    method, we have two numerical methods, each of which can perform this transformation.
    The second generalization is from the Euler method to other numerical methods.
    We want our information transformation process to allow whatever numerical method
    we might wish to use.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-2](ch15.xhtml#ch15fig2)使用欧拉方法将微分方程转化为状态更新函数。现在我们引入了欧拉-克罗默方法，我们有了两种数值方法，每种方法都可以执行这种转化。第二个推广是从欧拉方法到其他数值方法。我们希望我们的信息转化过程能够支持我们希望使用的任何数值方法。'
- en: Let’s turn to the question of how to generalize the state space.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探讨如何推广状态空间的问题。
- en: Generalizing the State Space
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 推广状态空间
- en: To generalize the state space from `State1D` to other possibilities, we will
    use a type variable `s` for the data type of the state. If we can write functions
    with types expressed in terms of `s`, rather than `State1D`, we can use these
    functions with any state space. When we generalize `Velocity`, `(Time,Velocity)`,
    and `State1D`, type `s` will contain whatever state variables are necessary for
    the physical system in question.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将状态空间从`State1D`推广到其他可能的状态空间，我们将使用类型变量`s`来表示状态的数据类型。如果我们能够编写以`s`而非`State1D`表示类型的函数，那么我们就可以在任何状态空间中使用这些函数。当我们推广`Velocity`、`(Time,Velocity)`和`State1D`时，类型`s`将包含任何物理系统所需的状态变量。
- en: Where [Figure 15-2](ch15.xhtml#ch15fig2) has a differential equation based on
    state space `State1D`, we want differential equations based on state space `s`.
    Where [Figure 15-2](ch15.xhtml#ch15fig2) has a state-update function based on
    state space `State1D`, we want a state-update function based on state space `s`.
    Where `euler1D` is a numerical method that transforms a differential equation
    based on `State1D` into a state-update function based on `State1D`, we want to
    be able to talk and write about numerical methods that transform a differential
    equation based on state space `s` into a state-update function based on `s`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 15-2](ch15.xhtml#ch15fig2)中，基于状态空间`State1D`的微分方程，我们希望得到基于状态空间`s`的微分方程。在[图
    15-2](ch15.xhtml#ch15fig2)中，基于状态空间`State1D`的状态更新函数，我们希望得到基于状态空间`s`的状态更新函数。`euler1D`是一个数值方法，将基于`State1D`的微分方程转化为基于`State1D`的状态更新函数，我们希望能够讨论和编写将基于状态空间`s`的微分方程转化为基于`s`的状态更新函数的数值方法。
- en: To be precise, we’re going to give formal definitions for the differential equation,
    state-update function, and numerical method for state space `s` by writing type
    synonyms. We’ll start with the state-update function because that is the simplest
    of the three.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 精确地说，我们将通过编写类型同义词，给出状态空间`s`的微分方程、状态更新函数和数值方法的形式定义。我们将从状态更新函数开始，因为它是三者中最简单的。
- en: Since a state-update function, such as `updateTXV dt m fs`, produces a new state
    with the same type as the input state, a state-update function for state space
    `s` is a function `s -> s`. This definition can be encoded as a type synonym.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态更新函数（例如 `updateTXV dt m fs`）会生成与输入状态具有相同类型的新状态，因此用于状态空间 `s` 的状态更新函数是一个 `s
    -> s` 的函数。这个定义可以通过类型同义词来表示。
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The type `UpdateFunction s` is the type for state-update functions that work
    with state space `s`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateFunction s` 类型是用于与状态空间 `s` 配合使用的状态更新函数类型。'
- en: '[Table 15-1](ch15.xhtml#ch15tab1) shows the state-update functions we have
    used so far in the last chapter and the current chapter.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-1](ch15.xhtml#ch15tab1) 显示了我们在上一章和本章中使用的状态更新函数。'
- en: '**Table 15-1:** State-Update Functions That Work with Different State Spaces'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-1：** 适用于不同状态空间的状态更新函数'
- en: '| **State-update function** | **Type** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **状态更新函数** | **类型** |'
- en: '| --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `updateVelocity dt m fs` | `UpdateFunction Velocity` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `updateVelocity dt m fs` | `UpdateFunction Velocity` |'
- en: '| `updateTV dt m fs` | `UpdateFunction (Time,Velocity)` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `updateTV dt m fs` | `UpdateFunction (Time,Velocity)` |'
- en: '| `updateTXV dt m fs` | `UpdateFunction State1D` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `updateTXV dt m fs` | `UpdateFunction State1D` |'
- en: Note that for each function we must supply a time step, a mass, and a list of
    force functions before the resulting expression has the type shown on the right
    side of the table.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于每个函数，我们必须提供时间步长、质量和一个力函数列表，之后结果表达式才会具有表格右侧所示的类型。
- en: A differential equation takes a state as input and produces derivatives of each
    state variable as output. With the state space `State1D`, the input consists of
    time, position, and velocity, while the output is numbers, velocity, and acceleration.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程以状态作为输入，并生成每个状态变量的导数作为输出。在状态空间 `State1D` 中，输入由时间、位置和速度组成，而输出则是数字、速度和加速度。
- en: Time is not the same thing as a dimensionless number, position is not the same
    thing as velocity, and velocity is not the same as acceleration. However, these
    are all real numbers for `State1D`, so the state space can also be written as
    `(R,R,R)`. In the function `euler1D` from earlier, I used the type `State1D ->
    (R,R,R)` for the differential equation and the type `State1D ->` `State1D` for
    the state-update function. To the compiler, these are the same type. I wrote them
    differently because numbers, velocity, and acceleration aren’t the quantities
    that belong in a `State1D`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 时间与无量纲数值不同，位置与速度不同，速度与加速度不同。然而，这些在 `State1D` 中都是实数，因此状态空间也可以写作 `(R,R,R)`。在前面提到的
    `euler1D` 函数中，我使用了类型 `State1D -> (R,R,R)` 来表示微分方程，并使用类型 `State1D -> State1D` 来表示状态更新函数。对编译器而言，这些是相同的类型。我之所以这样写，是因为数字、速度和加速度并不是属于
    `State1D` 中的量。
- en: To treat the difference between state variables and their time derivatives,
    we will use a type variable `ds` for a quantity that represents the time derivatives
    of the state variables. Just as the type variable `s` is for state, the type variable
    `ds` is for the time derivative of state.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理状态变量与其时间导数之间的差异，我们将使用一个类型变量 `ds` 来表示状态变量的时间导数。就像类型变量 `s` 用于状态一样，类型变量 `ds`
    用于状态的时间导数。
- en: A differential equation, as represented in Haskell, is a function that returns
    a set of derivatives of state variables when given a set of state variables. If
    `s` is the data type for state, and `ds` is the data type for time derivative
    of state, then the definition of a differential equation can be given as a type
    synonym.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程在 Haskell 中的表示方式是一个函数，给定一组状态变量时，它会返回一组状态变量的导数。如果 `s` 是状态的数据类型，而 `ds` 是状态的时间导数数据类型，那么微分方程的定义可以通过类型同义词给出。
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The type `DifferentialEquation s ds` is the type for differential equations
    that work with state space `s` and time derivative of state space `ds`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`DifferentialEquation s ds` 类型是适用于状态空间 `s` 和状态空间时间导数 `ds` 的微分方程类型。'
- en: '[Table 15-2](ch15.xhtml#ch15tab2) shows the differential equations we have
    used so far in the last chapter and the current chapter.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-2](ch15.xhtml#ch15tab2) 显示了我们在上一章和本章中使用的微分方程。'
- en: '**Table 15-2:** Differential Equations That Work with Different State Spaces'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-2：** 适用于不同状态空间的微分方程'
- en: '| **Differential equation** | **Type** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **微分方程** | **类型** |'
- en: '| --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `newtonSecondV m fs` | `DifferentialEquation Velocity R` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `newtonSecondV m fs` | `DifferentialEquation Velocity R` |'
- en: '| `newtonSecondTV m fs` | `DifferentialEquation (Time,Velocity) (R,R)` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `newtonSecondTV m fs` | `DifferentialEquation (Time,Velocity) (R,R)` |'
- en: '| `newtonSecond1D m fs` | `DifferentialEquation State1D (R,R,R)` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `newtonSecond1D m fs` | `DifferentialEquation State1D (R,R,R)` |'
- en: Note that for each function we must supply a mass and a list of force functions
    before the resulting expression has the type shown on the right side of the table.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于每个函数，我们必须提供质量和力函数列表，才能使结果表达式具有表右侧所示的类型。
- en: A numerical method transforms a differential equation into a state-update function.
    The definition of numerical method for state space `s` and derivative space `ds`
    can be given as a type synonym.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法将微分方程转化为状态更新函数。状态空间`s`和导数空间`ds`的数值方法定义可以通过类型同义词给出。
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The type `NumericalMethod s ds` is the type for numerical methods that work
    with the state space `s` and time derivative space `ds`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`NumericalMethod s ds`是与状态空间`s`和时间导数空间`ds`一起使用的数值方法的类型。
- en: 'While the differential equation itself is a mathematically exact expression,
    applying a numerical method to solve it necessarily involves approximation. We
    have seen two numerical methods so far: the Euler method and the Euler-Cromer
    method. However, there are many numerical methods to choose from in solving a
    differential equation.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微分方程本身是一个数学上精确的表达式，但应用数值方法来求解它必然涉及到近似。到目前为止，我们已经见过两种数值方法：欧拉方法和欧拉-克罗默方法。然而，在求解微分方程时还有许多数值方法可供选择。
- en: Since there are many numerical methods, which all lead to different approximations,
    it makes little sense to bake one particular numerical method into the foundational
    ideas and code that constitute both the structure of how we think about solving
    mechanics problems and the computational tools to solve them. We should be able
    to choose a numerical method freely, independently of the differential equation
    we are solving. We want to separate the numerical method from the differential
    equation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在许多数值方法，每种方法会导致不同的近似结果，因此将某个特定的数值方法嵌入到构成我们思考如何解决力学问题的基础理念和代码中并不合理。我们应该能够自由选择数值方法，与我们所求解的微分方程无关。我们希望将数值方法与微分方程分开。
- en: '[Table 15-3](ch15.xhtml#ch15tab3) shows the numerical methods we have used
    so far in this chapter. In the previous chapter, we never wrote an explicit numerical
    method, instead placing the Euler method code inside the state-update function.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-3](ch15.xhtml#ch15tab3) 显示了我们在本章中使用过的数值方法。在上一章中，我们从未编写过明确的数值方法，而是将欧拉方法的代码直接放入状态更新函数中。'
- en: '**Table 15-3:** Numerical Methods That Work with the State1D State Space'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-3：** 与 State1D 状态空间一起使用的数值方法'
- en: '| **Numerical method** | **Type** |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **数值方法** | **类型** |'
- en: '| --- | --- |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `euler1D dt` | `NumericalMethod State1D (R,R,R)` |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `euler1D dt` | `NumericalMethod State1D (R,R,R)` |'
- en: '| `eulerCromer1D dt` | `NumericalMethod State1D (R,R,R)` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `eulerCromer1D dt` | `NumericalMethod State1D (R,R,R)` |'
- en: Note that for each function we must supply a time step before the resulting
    expression has the type shown on the right side of the table.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于每个函数，我们必须提供时间步长，才能使结果表达式具有表右侧所示的类型。
- en: Given a differential equation and a numerical method, we can solve the differential
    equation by applying the numerical method, which results in a state-update function,
    and then iterate the state-update function to produce a list of states. The following
    function takes a numerical method, a differential equation, and an initial state
    as input and produces a list of states as output. We can think of this function
    as a general-purpose differential equation solver.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个微分方程和一个数值方法，我们可以通过应用该数值方法来求解微分方程，得到一个状态更新函数，然后迭代该状态更新函数生成状态列表。以下函数接收数值方法、微分方程和初始状态作为输入，输出一个状态列表。我们可以将该函数视为一个通用的微分方程求解器。
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We said earlier that solving a differential equation is the mathematical part
    of solving a mechanics problem, in which we transform a differential equation
    through a state-update function and ultimately to a list of states. The function
    `solver` carries out the entire mathematical process of solving a differential
    equation. In other words, it handles the mathematical part of solving a mechanics
    problem.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，求解微分方程是解决力学问题的数学部分，在此过程中，我们通过状态更新函数将微分方程转化，最终得到状态列表。函数`solver`完成了求解微分方程的整个数学过程。换句话说，它处理了求解力学问题的数学部分。
- en: We’ve given definitions for differential equation, state-update function, and
    numerical method, each of which works with a state space `s` and time derivative
    space `ds`. We now turn to writing a general-purpose function `euler` that can
    act as a numerical method for an almost-arbitrary state space `s`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给出了微分方程、状态更新函数和数值方法的定义，每个方法都与状态空间`s`和时间导数空间`ds`配合使用。现在，我们转向编写一个通用函数`euler`，它可以作为几乎任意状态空间`s`的数值方法。
- en: Type Classes for State Spaces
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态空间的类型类
- en: The state space type `s` and time derivative space `ds` cannot be just any data
    types. To carry out the Euler method and other numerical methods, we need to be
    able to add elements of the time derivative space `ds`, and we want to be able
    to scale elements by a time step. A space that supports addition of states and
    scalar multiplication of states by real numbers is called a *real vector space*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 状态空间类型`s`和时间导数空间`ds`不能是任意数据类型。为了执行欧拉方法和其他数值方法，我们需要能够对时间导数空间`ds`的元素进行加法运算，并且希望能够通过时间步长对元素进行缩放。一个支持状态加法和通过实数对状态进行标量乘法的空间称为*实向量空间*。
- en: To express the constraint that our time derivative space be a real vector space,
    we define a type class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达我们的时间导数空间是一个实向量空间的约束，我们定义了一个类型类。
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code defines a new type class `RealVectorSpace` that owns two functions:
    `(+++)` for addition and `scale` for scalar multiplication. You can see from the
    type signatures that the addition function takes two state derivatives as input
    and produces one as output, while the scalar multiplication function takes a real
    number and a state derivative as input and produces a state derivative as output.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个新的类型类`RealVectorSpace`，该类包含两个函数：`(+++)`用于加法，`scale`用于标量乘法。从类型签名可以看出，加法函数接受两个状态导数作为输入，输出一个状态导数，而标量乘法函数接受一个实数和一个状态导数作为输入，输出一个状态导数。
- en: 'For each derivative space we wish to use, we’ll write an instance declaration
    saying exactly how addition and scalar multiplication are to be defined for that
    data type. For the type `(R,R,R)`, which is the derivative space associated with
    state space `State1D`, here is the instance declaration:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们希望使用的每个导数空间，我们将编写一个实例声明，明确该数据类型的加法和标量乘法应如何定义。对于类型`(R,R,R)`，这是与状态空间`State1D`相关联的导数空间，以下是实例声明：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We use the local variable `dxdt0` to remind us that this name stands for a quantity
    that represents the derivative of a position with respect to time. The instance
    declaration defines adding two triples to mean adding each corresponding pair;
    it defines scaling a triple by a real number to mean scaling each item in the
    triple by the real number.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用局部变量`dxdt0`来提醒我们这个名称代表的是一个量，表示位置相对于时间的导数。实例声明定义了两个三元组相加意味着对每对对应元素进行相加；它定义了通过一个实数对三元组进行缩放意味着对三元组中的每个元素都进行该实数的缩放。
- en: We will also use a type class to claim a relationship that must hold between
    a state space `s` and its derivative space `ds`. The relationship describes how
    a state variable in `s` can be advanced in time using knowledge of the state variable’s
    time derivative in `ds`. We name the type class `Diff` to remind us of the differentiation
    (the taking of a time derivative) that relates a state space `s` to its derivative
    space `ds`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个类型类来声明一个必须在状态空间`s`和其导数空间`ds`之间保持的关系。这个关系描述了如何使用`ds`中状态变量的时间导数来推进状态空间`s`中的状态变量。我们将该类型类命名为`Diff`，以提醒我们它是与状态空间`s`和其导数空间`ds`之间的微分（即时间导数）相关的。
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This type class definition contains a type class constraint saying that `ds`
    must be a `RealVectorSpace`. The type class `Diff` owns the function `shift`.
    For each pair of types we wish to use as state space and derivative space, we
    will provide an instance declaration that defines what the function `shift` does
    with values of the two spaces. The function `shift` describes how a state can
    be advanced in time using knowledge of the derivative state. The function `shift`
    takes a time step, a state derivative, and a state as input and gives a new state
    as output.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型类定义包含一个类型类约束，要求`ds`必须是一个`RealVectorSpace`。类型类`Diff`包含函数`shift`。对于我们希望使用的每对类型作为状态空间和导数空间，我们将提供一个实例声明，定义函数`shift`如何处理这两个空间的值。函数`shift`描述了如何使用导数状态的信息来推进一个状态。函数`shift`接受一个时间步长、一个状态导数和一个状态作为输入，输出一个新的状态。
- en: A type class used to relate two types rather than to claim membership of a single
    type is called a *multi-parameter type class*. The second line of the introductory
    code for the module we are writing in this chapter turns on a `LANGUAGE` feature
    called `MultiParamTypeClasses` to allow the use of multiparameter type classes.
    Their use is disabled by default.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一种用于关联两种类型，而非声明单一类型成员的类型类被称为*多参数类型类*。我们在本章编写的模块的引言代码中的第二行启用了一个名为`MultiParamTypeClasses`的`LANGUAGE`特性，以允许使用多参数类型类。默认情况下，它们是禁用的。
- en: 'The following instance declaration claims a differentiation relationship between
    the types `State1D` and `(R,R,R)` by defining the function `shift` for them:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实例声明通过为`State1D`和`(R,R,R)`定义函数`shift`，声明了它们之间的微分关系：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The function `shift` says that to update time, we should multiply a time step
    `dt` by the rate `dtdt` at which time changes (which is 1). It says that to update
    position, we should multiply a time step `dt` by the rate `dxdt` at which position
    changes and act similarly to update velocity. Time, position, and velocity come
    from the state, while the rates of change come from the state derivative.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`shift`表示，为了更新时间，我们应该将时间步长`dt`与时间变化的速率`dtdt`（即1）相乘。它表示，为了更新位置，我们应该将时间步长`dt`与位置变化速率`dxdt`相乘，更新速度时也应类似处理。时间、位置和速度来自状态，而变化率则来自状态导数。
- en: We see that `shift` looks a lot like the Euler method. In fact, it is more basic
    than that. The `shift` function will be used by the Euler method but also by other
    numerical methods.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`shift`看起来很像欧拉方法。事实上，它比那更基本。`shift`函数将被欧拉方法使用，但也会被其他数值方法使用。
- en: Here is the generic version of the Euler method, which is suitable for any differential
    equation based on any state space.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是欧拉方法的通用版本，适用于任何基于任何状态空间的微分方程。
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As long as data types `s` and `ds` are appropriately related by the `Diff` type
    class, which is to say that `s` is a state space and `ds` is a derivative space
    that goes along with `s`, the function `euler` will carry out the Euler method
    with state variables from `s`, using the differential equation passed in as `deriv`.
    The Euler method is carried out by a single use of the `shift` function, where
    the derivatives are evaluated at the current state.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 只要数据类型`s`和`ds`通过`Diff`类型类恰当地关联，也就是说`s`是状态空间，`ds`是与`s`相伴随的导数空间，函数`euler`将使用状态变量从`s`进行欧拉方法运算，使用作为`deriv`传入的微分方程。欧拉方法通过一次调用`shift`函数来执行，其中导数在当前状态下被评估。
- en: '[Table 15-4](ch15.xhtml#ch15tab4) compares the types of `euler1D` and `euler`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[表15-4](ch15.xhtml#ch15tab4)比较了`euler1D`和`euler`的类型。'
- en: '**Table 15-4:** Comparison of the Function euler1D with the More General Function
    euler'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**表15-4：** 比较函数`euler1D`与更通用的函数`euler`'
- en: '| **Function** |  | **Type** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `euler1D` | `::` | `R -> NumericalMethod State1D (R,R,R)` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `euler1D` | `::` | `R -> NumericalMethod State1D (R,R,R)` |'
- en: '| `euler` | `::` | `Diff s ds => R -> NumericalMethod s ds` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `euler` | `::` | `Diff s ds => R -> NumericalMethod s ds` |'
- en: The function `euler` can be used anywhere that `euler1D` can be used, and in
    other places as well. Because it is written with a type variable, we’ll be able
    to use `euler` for the state spaces we make in future chapters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`euler`可以在任何可以使用`euler1D`的地方使用，并且也可以用于其他地方。由于它是使用类型变量编写的，我们可以在未来的章节中使用`euler`来处理我们创建的状态空间。
- en: Can we do the same thing with the Euler-Cromer method? That is, can we write,
    once and for all, a numerical method that works with any state space and any differential
    equation? Sadly, the answer is no. The Euler method is a general-purpose technique
    for solving any system of first-order differential equations. The Euler-Cromer
    method is a specialized method for second-order differential equations, or for
    systems of first-order differential equations where we can identify a quantity
    to play the role of velocity. We’ll need to write a new Euler-Cromer function
    for each state space we work with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否使用欧拉-克罗默方法做同样的事情？也就是说，我们能否一次性编写一个适用于任何状态空间和任何微分方程的数值方法？遗憾的是，答案是否定的。欧拉法是一种通用的解决任何一阶微分方程系统的技术。欧拉-克罗默方法是专门针对二阶微分方程，或者是当我们能够识别出一个量来充当速度时，适用于一阶微分方程系统的方法。我们需要为每个处理的状态空间编写新的欧拉-克罗默函数。
- en: Next we’ll introduce one more general-purpose numerical method that could be
    used instead of Euler or Euler-Cromer.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另一种通用数值方法，它可以替代欧拉方法或欧拉-克罗默方法。
- en: One More Numerical Method
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 另一种数值方法
- en: In this section, we’ll introduce one more general-purpose numerical method,
    called the fourth-order Runge-Kutta method. Numerical methods are sometimes classified
    by an order. The order gives an expectation of how the error (the difference between
    the numerical solution and the exact solution) scales with the step size. When
    we shrink the step size by a factor of 10, the error for a first-order solver
    shrinks by about 10, while the error for a second-order solver shrinks by about
    10², or 100\. The Euler and Euler-Cromer methods are first-order methods and have
    the advantage of simplicity; it is straightforward to see why they work. The fourth-order
    Runge-Kutta method is substantially more complex. We won’t get into why it works
    well or why it is a fourth-order method. However, it is a popular method for solving
    differential equations, and it allows us to see a second general-purpose method
    for solving a differential equation. Fourth-order Runge-Kutta is a general method
    that will work with any differential equation and state space.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the fourth-order Runge-Kutta method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can see that this method is more complex, but it has the same type as `euler`,
    and it plays the same role: transforming a differential equation into a state-update
    function.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have three numerical methods to use, let’s compare them on a differential
    equation to which we know the solution.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of Numerical Methods
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s do a comparison of the three numerical methods we’ve introduced. The differential
    equations
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/269equ01.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'can be written in Haskell as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These differential equations are exactly solvable and have a solution of
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*t*) = *Ae^t*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '*v*(*t*) = *Ae^t*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: or
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*t*) = *Ae^(”t)*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '*v*(*t*) = –*Ae^(–t)*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: for some constant *A*. If we focus on the initial state in which *x*(0) = 1
    and *v*(0) = 1, the solution is
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*t*) = *e^t*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '*v*(*t*) = *e^t*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare the exact solution at *t* = 8 to the approximations given by the
    three numerical methods we’ve presented using different step sizes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The `solver` function takes a numerical method, a differential equation, and
    an initial state to produce a list of states.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the first use of `solver`, we’re using a step size of 0.01, so item number
    800 in the list corresponds to *t* = 8\. The other two uses of `solver` use different
    step sizes and consequently different item numbers for *t* = 8.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-5](ch15.xhtml#ch15tab5) compares the three numerical methods we’ve
    discussed. You can see where these example calculations fit into the table.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-5:** Comparison of the Euler, Euler-Cromer, and Fourth-Order Runge-Kutta
    Methods with the Exact Solution of a Differential Equation'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Δ*t* = 1** | **Δ*t* = 0.1** | **Δ*t* = 0.01** | **Δ*t* = 0.001** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| Exact | 2981 | 2981 | 2981 | 2981 |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| RK4 | 2895 | 2981 | 2981 | 2981 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| Euler-Cromer | 2584 | 3043 | 2988 | 2982 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| Euler | 256 | 2048 | 2865 | 2969 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: The exact result does not depend on any step size; it is just *e*⁸. All three
    numerical methods get closer to the exact result as the step size decreases. The
    Euler method is within 4 percent of the exact value at a step size of Δ*t* = 0.01
    and within 1 percent at a step size of Δ*t* = 0.001\. Euler-Cromer at Δ*t* = 0.1
    is better than Euler at Δ*t* = 0.01, and Euler-Cromer at Δ*t* = 0.01 is better
    than Euler at Δ*t* = 0.001\. Thus, we can use roughly 10 times the step size with
    Euler-Cromer compared to Euler and get comparable results for this differential
    equation. Similarly, we can use roughly 10 times the step size with fourth-order
    Runge-Kutta compared to Euler-Cromer and get comparable results.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 精确结果不依赖于任何步长，它只是 *e*⁸。随着步长的减小，所有三种数值方法的结果会越来越接近精确结果。欧拉方法在步长Δ*t* = 0.01时与精确值的误差为4％，在步长Δ*t*
    = 0.001时为1％。在Δ*t* = 0.1时，欧拉-克罗梅方法比Δ*t* = 0.01的欧拉方法更准确，在Δ*t* = 0.01时，欧拉-克罗梅方法比Δ*t*
    = 0.001的欧拉方法更准确。因此，与欧拉方法相比，我们可以在使用欧拉-克罗梅时将步长增加约10倍，并且得到相当的结果。同样，使用四阶龙格-库塔方法时，可以将步长增加约10倍，相比欧拉-克罗梅得到相似的结果。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter completed the treatment of one-dimensional mechanics begun in
    the previous chapter. We saw how to handle forces that depend on position. With
    a force that depends on position, Newton’s second law is a second-order differential
    equation that we transform into coupled first-order differential equations for
    the state variables position and velocity. We can view the solution of a mechanics
    problem as the transformation of information about the physical situation through
    a sequence of five representations: mass and force functions, differential equation,
    state-update function, list of states, and position-velocity functions.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了上一章开始的一维力学的处理。我们看到了如何处理依赖于位置的力。对于依赖位置的力，牛顿第二定律是一个二阶微分方程，我们将其转换为位置和速度的状态变量的耦合一阶微分方程。我们可以将力学问题的解看作通过五种表示方式的序列转化：质量和力函数、微分方程、状态更新函数、状态列表和位置-速度函数。
- en: A Ping-Pong ball oscillating on the end of a Slinky in the presence of air resistance
    was the central example of the chapter. We introduced the Euler-Cromer method,
    an improvement on the Euler method for second-order differential equations. We
    also introduced the fourth-order Runge-Kutta method, which, along with the Euler
    method, is a general-purpose numerical method for solving any differential equation
    with any set of state variables. In the next chapter, we’ll start three-dimensional
    mechanics by treating position, velocity, and acceleration as vectors.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个乒乓球在弹簧玩具末端因空气阻力而发生的振荡是本章的核心示例。我们介绍了欧拉-克罗梅方法，这是一种改进的欧拉方法，用于求解二阶微分方程。我们还介绍了四阶龙格-库塔方法，它与欧拉方法一起，作为一种通用的数值方法，用于求解任何包含状态变量的微分方程。在下一章中，我们将通过将位置、速度和加速度视为向量，开始研究三维力学。
- en: Exercises
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 15.1.** Let’s warm up with a basic projectile motion problem where
    we know what the answer should look like. Suppose someone throws a ball from the
    ground straight up into the air with an initial velocity of 10 m/s. Ignoring air
    resistance, use the function `positionFtxv` to find the height of the ball as
    a function of time. Make a plot of height as a function of time.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 15.1.** 让我们通过一个基本的抛体运动问题来热身，我们知道答案应该是什么样子。假设某人从地面上将一个球直上抛起，初速度为 10 m/s。忽略空气阻力，使用函数
    `positionFtxv` 计算球的高度随时间的变化。绘制高度与时间的关系图。'
- en: '**Exercise 15.2.** Doing the Euler method by hand on [page 254](ch15.xhtml#ch15lev7),
    we arrived at a table of values for position and velocity. Show how to calculate
    these values using Haskell functions. The values may not match to four decimal
    places because I rounded intermediate results in doing the Euler method by hand,
    but the first two digits after the decimal point should match in every case.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 15.2.** 在[第254页](ch15.xhtml#ch15lev7)手动做欧拉方法时，我们得到了位置和速度的数值表。请展示如何使用 Haskell
    函数计算这些值。由于我在手动执行欧拉方法时对中间结果进行了四舍五入，所得值可能与四位小数不完全匹配，但在每种情况下，小数点后的前两位应该是相同的。'
- en: '**Exercise 15.3.** (Euler method by hand.) Consider the differential equations'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 15.3.**（手动欧拉方法。）考虑以下微分方程：'
- en: '![Image](Images/271equ01.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/271equ01.jpg)'
- en: along with the initial conditions
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以及初始条件
- en: '![Image](Images/271equ02a.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/271equ02a.jpg)'
- en: Use the Euler method with a step size of Δ*t* = 0.1 to approximate the value
    of *x*(0.3). Keep at least four figures after the decimal point in your calculations.
    Show your calculations in a small table. (The table will have three columns, one
    each for time, position, and velocity.)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.4.** Write a Haskell function'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: that takes a tuple (*t*[0], *x*[0], *v*[0]) and returns a tuple (*t*[1], *x*[1],
    *v*[1]) for a single step of the Euler method for the differential equations
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/271equ02.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: with a step size of Δ*t* = 0.1 and the same initial conditions as in the previous
    exercise. Show how to use the function `update2` to calculate the value *x*(0.3)
    that you calculated by hand in the previous exercise.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.5.** Consider a 3-kg mass connected to a wall by a linear spring
    with spring constant 100,000 N/m. Ignoring gravity and friction, if the spring
    is extended by 0.01 m and released, what does the subsequent motion look like?
    Investigate this motion over several cycles of oscillation. Compare your results
    to the exact solution. Find a time step that is small enough so that the Euler
    solution and the exact solution overlap precisely on a plot. Find another time
    step that is big enough so that you can see the difference between the Euler solution
    and the exact solution on a plot.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Make a nice plot (with title, axis labels, and so on) with these three solutions
    on a single graph (bad Euler, good Euler, and exact). Label the Euler results
    with the time step you used, and label the exact result “Exact.”
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.6.** Let’s investigate dropping things from large heights. In
    particular, let’s look at a Ping-Pong ball and a bowling ball. In each case, take
    *C* = 1/2\. You will need to find out good approximations for things like the
    size and mass of these balls. Let’s drop them from heights of 100 m and 500 m.
    Make graphs of velocity as a function of time and velocity as a function of vertical
    position. What fraction of terminal velocity is achieved in each case? Assemble
    your results in some meaningful and understandable way.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.7.** Return to the harmonic oscillator of Exercise 15.5\. Compare
    the Euler and Euler-Cromer solutions to the exact solution for a time step of
    0.001 s (you will recall that this is not a very good time step for the Euler
    method). Plot the displacement of the mass as a function of time for the first
    0.1 s of motion. Plot Euler, Euler-Cromer, and exact solutions on one set of axes.
    Also give the value of the position of the mass (to four significant figures)
    at *t* = 0.1 s for each of the three solutions.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.8.** Consider an object with mass *m* attached to a spring with
    spring constant *k*. The other end of the spring is attached to a vertical wall.
    The object slides horizontally across the floor. There is a coefficient of kinetic
    friction *μ[k]* = 0.3 between the object and the floor. The weight of the object
    is *mg*, so the force of kinetic friction on the object is μ[k] *mg*, directed
    opposite the velocity of the object.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Let *m* = 3 kg and *k* = 12 N/m.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: (a) Write a function with type `State1D -> Force` that gives the horizontal
    force of kinetic friction. You may want to use the `signum` function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: (b) Use the function `positionFtxv` to find the position of the object as a
    function of time.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: (c) Make a plot of position as a function of time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.9.** In most situations in mechanics, the mass of the object
    that we care about does not change. There is no need to include a quantity that
    doesn’t change in the state. However, since some forces, such as gravity, depend
    on mass, there is some motivation to include mass in the state simply for convenience.
    Several of the functions we developed in this chapter accept a list of force functions
    `[State1D -> Force]` as input. If we wanted to include Earth’s gravity as such
    a state-dependent force, we would need to write something like the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Suppose, on the other hand, we include the object’s mass in its state by using
    the following 4-tuple as the data type for state.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Then we could write an Earth gravity function as
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that since mass is included in the state, we no longer need `Mass` as
    an extra parameter in the function type.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Write definitions for the following functions, using `MState` in place of `State1D`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Exercise 15.10.** The Lennard-Jones potential'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/273equ01.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: is sometimes used to model the interaction between atoms. The expression V[*LJ*]
    (*r*) gives the potential energy for a system of two atoms when the atoms are
    a distance *r* apart from each other. As *r* → 0, the potential energy becomes
    infinite, expressing the difficulty of having the two atoms very close together.
    The lowest value of potential energy occurs at an inter-atomic separation of *r*
    = *r[e]*, meaning that the parameter *r[e]* is the equilibrium separation of the
    atoms. The parameter *D[e]* represents the dissociation energy for the two-atom
    molecule, or the amount of energy that must be provided to the molecule to pull
    the atoms (arbitrarily far) apart.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The Lennard-Jones force
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/273equ02.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: gives the force on one of the atoms produced by the other, with positive meaning
    repulsive and negative meaning attractive. We can think of the Lennard-Jones force
    as coming from a nonlinear spring that connects the two atoms. When the atomic
    separation is greater than *r[e]*, the spring provides an attractive force that
    attempts to restore equilibrium. When the atomic separation is less than *r[e]*,
    the spring provides a repulsive force that attempts to restore equilibrium. The
    spring is nonlinear in that the restoring force is not proportional to the deviation
    of the atomic separation from equilibrium.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-8](ch15.xhtml#ch15fig8) shows the Lennard-Jones force as a function
    of inter-atomic distance *r*, along with the linear spring force that most closely
    approximates it.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274fig01.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-8: The Lennard-Jones force (curved line) and the linear force (straight)
    that most closely approximates it*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The effective spring constant for the Lennard-Jones force is the negative slope
    of the force as a function of inter-atomic distance.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274equ01.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: Suppose we have a mass *m* attached by a Lennard-Jones spring to a wall. We’ll
    ignore gravity and friction in this problem so that the Lennard-Jones force is
    the only force that acts on the mass. If an oscillation about the equilibrium
    position is small in amplitude, the angular frequency of the oscillation will
    be close to
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274equ02.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: and the period will be close to
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274equ03.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: Choose any parameters for *r[e]*, *D[e]*, and *m*.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: (a) Make a graph of position versus time when the initial position is *r* =
    1.01*r[e]* and the initial velocity is zero. The graph should be oscillatory.
    Confirm that the period is close to the value given earlier.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: (b) Make a graph of position versus time when the initial position is *r* =
    5*r[e]* and the initial velocity is zero. What is the period now?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of an anharmonic oscillator, where the period depends on
    the amplitude of oscillation. It is only the special case of the harmonic oscillator
    in which period is independent of amplitude.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.11.** Applying the Euler method by hand on [page 254](ch15.xhtml#ch15lev8),
    we arrived at a table of values for position and velocity. Produce a similar table
    of values using the Euler-Cromer method by hand.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.12.** Write a function `statesTXVEC` that is similar to `statesTXV`
    but uses the Euler-Cromer method instead of the Euler method. Use this function
    to check the table of values you calculated by hand in the previous exercise.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.13.** Write versions of `statesTXV`, `velocityFtxv`, and `positionFtxv`
    that use the Euler-Cromer method rather than the Euler method.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.14.** Show how to use Haskell functions to calculate the entries
    of the comparison table for numerical methods.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.15.** With the code'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: we have made the data type `(R,R)` an instance of type class `RealVectorSpace`
    and written a `Diff` instance for the pair of types `(Time,Velocity)` and `(R,R)`.
    Now we can use `(Time,Velocity)` as a state space and `(R,R)` as its derivative
    space for the Euler or fourth-order Runge-Kutta methods. Write a function
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: that does the same thing as `updateTV` from [Chapter 14](ch14.xhtml) but uses
    the function `euler` from this chapter.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.16.** Newton’s second law generally produces a second-order differential
    equation (recall [Table 14-1](ch14.xhtml#ch14tab1)). Our `DifferentialEquation
    s ds` data type is for functions that return the derivatives of state variables
    when given the state variables themselves. A function with type `DifferentialEquation
    s ds` expresses a set of coupled first-order differential equations.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we’ll rewrite a second-order differential equation as two
    coupled first-order differential equations. A second-order (ordinary) differential
    equation has one independent variable and one dependent variable (in other words,
    one unknown function). A set of two coupled first-order differential equations
    has one independent variable and two dependent variables (two unknown functions
    of the independent variable).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the recipe for producing a set of two coupled first-order differential
    equations from a second-order differential equation:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The independent variable of the coupled set is the same as the independent variable
    of the second-order equation.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first unknown function of the coupled set, choose the unknown function
    of the second-order equation.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second unknown function of the coupled set, choose the derivative of
    the first unknown function with respect to the independent variable and give this
    function a new name.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first differential equation in the coupled set expresses that the derivative
    of the first unknown function is equal to the second unknown function.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To form the second differential equation in the set, start with the original
    second-order differential equation, replace the first derivative of the unknown
    function with the new second unknown function, replace the second derivative of
    the unknown function with the derivative of the new second unknown function, and
    solve for the derivative of the new second unknown function.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Express the differential equation
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/276equ01.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: as a set of two coupled first-order differential equations.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.17.** The Van der Pol oscillator is a generalization of the harmonic
    oscillator that is often used to explore chaos. It is described by the following
    differential equation:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/276equ02.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: 'We can view this equation as coming from Newton’s second law with two forces
    present: a spring-like linear restoring force and a damping force. We will abandon
    SI units for this exercise, setting both mass and spring constant to unity. The
    spring force is then given by'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[spring](*t, x, v*) = –*x*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: and the damping force is given by
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[damping](*t, x, v*) = *μ*(1 – *x*²)*v*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: where *μ* is a parameter that controls how nonlinear the damping force is. If
    *μ* = 0, the Van der Pol oscillator reduces to the harmonic oscillator.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: When studying chaos, people often like to make phase plane plots, which are
    graphs of velocity as a function of position. (They can also be graphs of momentum
    as a function of position, but we will use velocity.) Fill in the undefined parts
    of the following code to make phase plane plots for *μ* = 0, *μ* = 2, *μ* = 4,
    and *μ* = 6, all on the same graph.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The result should look something like [Figure 15-9](ch15.xhtml#ch15fig9).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/277fig01.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-9: Phase plane plots for the Van der Pol oscillator*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
