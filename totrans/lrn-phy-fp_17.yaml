- en: '15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MECHANICS IN ONE DIMENSION
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll complete the story of mechanics in one dimension by developing
    tools for situations in which the forces on an object can depend on position as
    well as on time and velocity. This will require thinking about second-order differential
    equations, which we’ll convert into systems of first-order differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we’ll transform information about the physical situation through
    several different forms, beginning with the object’s mass and the forces that
    act on it, and ending with functions that give the position and velocity of the
    object with time. A functional language like Haskell helps organize our thoughts
    about what it means to solve a mechanics problem by giving names and types to
    each form of information and by allowing that information to exist naturally in
    the form of a function when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the tools we’re developing, we’ll look at an example situation: the
    motion of a Ping-Pong ball attached to the end of a Slinky in the presence of
    air resistance—in other words, a damped harmonic oscillator. We’ll show how to
    apply the Euler method for a second-order differential equation, and we’ll see
    how either a list of states or position and velocity functions for an object can
    be regarded as a solution to a mechanics problem. We’ll then introduce the Euler-Cromer
    method, an improvement on the Euler method for second-order differential equations.
    Since we’ll continue to modify the state variables and the data type used for
    state as we introduce vectors and multiple particles in upcoming chapters, at
    the end of this chapter, we’ll generalize our differential equation solving methods
    to allow arbitrary data types for state and allow a choice of numerical methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Introductory Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin with the code that needs to appear at the beginning of our source
    code file. I always like to start by turning on warnings. I also include two language
    settings that we will use in “Solving Differential Equations” later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s make the code in this chapter into a module named `Mechanics1D`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also want to make a plot later, so let’s import the necessary module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For our example of a Ping-Pong ball on the end of a Slinky, we’ll use the air
    resistance function `fAir` from the previous chapter. To access this function,
    we import the module called `Newton2` we wrote in [Chapter 14](ch14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Haskell compiler will look for a file called *Newton2.hs* in the current
    working directory (the same directory that contains the *Mechanics1D.hs* file
    we are writing in this chapter). The file *Newton2.hs* contains the code we wrote
    in the previous chapter and is available at [https://lpfp.io](https://lpfp.io).
  prefs: []
  type: TYPE_NORMAL
- en: If we include a comma-separated list of types and functions in parentheses after
    the module name, we’ll import only those types and functions. If we omit such
    a list, as we did when importing the `Graphics.Gnuplot.Simple` module, we’ll import
    all types and functions provided by the module.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we’ll use the type synonym `R` instead of `Double`. We made this type
    synonym in the `SimpleVec` module of [Chapter 10](ch10.xhtml), and we import it
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The warnings option, the language setting, the module name, and the import statements
    need to be at the beginning of the source code file. Type synonyms can appear
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: When we do mechanics in one dimension, time, a time step, mass, position, velocity,
    and force are each represented by a real number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Forces That Depend on Time, Position, and Velocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the forces on an object depend on time, position, and velocity, the force
    functions depend on three variables. We’ll use ![Image](Images/e0245-01.jpg) to
    denote the *j*th function of three variables that gives a force when supplied
    with time, position, and velocity; we’ll use ![Image](Images/e0245-02.jpg) to
    denote the function of three variables that gives net force. [Figure 15-1](ch15.xhtml#ch15fig1)
    shows a schematic diagram for Newton’s second law with forces that depend on time,
    position, and velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0245-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Newton’s second law in one dimension. The forces depend on time,
    position, and velocity.*'
  prefs: []
  type: TYPE_NORMAL
- en: The rectangular boxes in the diagram are pure functions whose output depends
    only on the input. The integrators are contained in circles to remind us that
    each integrator contains some state. The integrator whose output is *x*(*t*),
    for example, must contain the current position value. The schematic diagram in
    [Figure 15-1](ch15.xhtml#ch15fig1) is continuous and stateful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton’s second law appears as the following differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/e0245-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ve come to the full generality of Newton’s second law in one dimension, as
    given in the previous chapter by Equation 14.2\. Position is the unknown function
    we want to find in this differential equation. This is a second-order differential
    equation because a second derivative of position appears in the equation. To solve
    a second-order differential equation using a state-based approach, we’ll choose
    some state variables and write first-order differential equations for each of
    the state variables.
  prefs: []
  type: TYPE_NORMAL
- en: What should our state variables be? [Figure 15-1](ch15.xhtml#ch15fig1) has two
    integrators contained in loops. These integrators hold position and velocity as
    state, so position and velocity are required to be state variables. While it is
    possible to solve Equation 15.1 using only position and velocity as state variables,
    it is easier if we also allow time to serve as a state variable because the forces
    could also depend on time. Our data type describing state for the mechanics of
    a single object moving in one dimension is a time-position-velocity triple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the name *state space* for data types like `State1D` that describe state.
    The types `Velocity` and `(Time,Velocity)` from the previous chapter are other
    examples of state spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Equations 15.2, 15.3, and 15.4 show the three first-order differential equations
    obtained by writing expressions for the time derivatives of each state variable.
    What appears on the right side of these equations can involve the state variables
    but may not have any derivatives. Because the derivative of the position function
    depends on the velocity function, and vice versa, we refer to this as a set of
    *coupled* differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/246equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The function `newtonSecond1D` gives expressions for the time derivatives of
    the state variables in terms of the state variables themselves. Note that the
    state variables in this function are real numbers rather than functions of time.
    By expressing the differential Equations 15.2, 15.3, and 15.4, the function `newtonSecond1D`
    expresses Newton’s second law in one dimension. The schematic diagram in [Figure
    15-1](ch15.xhtml#ch15fig1), the differential equations, and the Haskell function
    `newtonSecond1D` each contain the essential information for understanding and
    solving Newton’s second law in one dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A General Strategy for Solving Mechanics Problems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our strategy for constructing and solving Newton’s second law consists of transforming
    information about the physical situation through a sequence of five different
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Mass and force functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differential equation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State-update function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List of states
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position and velocity functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The information begins with the mass of the object under consideration and the
    forces that act on it, expressed as functions of the state variables. The function
    `newtonSecond1D` transforms this mass and force information into a differential
    equation. A differential equation is a function `State1D -> (R,R,R)` that gives
    the derivatives of the state variables time, position, and velocity in terms of
    the state variables themselves. The Euler method transforms a differential equation
    into a state-update function, a function `State1D -> State1D` that computes the
    state variables at a later time from the state variables at an earlier time. From
    a state-update function and an initial state, we can then compute an infinite
    list of states, the fourth representation of the data describing our physical
    situation. Finally, we can extract position as a function of time and velocity
    as a function of time from the list of states. Predicting the position and velocity
    of the object as a function of time is the final data representation, which we
    regard as a solution to the problem of understanding the motion of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-2](ch15.xhtml#ch15fig2) is a functional diagram showing the five
    data representations above and the functions that transform the data from one
    representation to another.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/248fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Data flow for solving a mechanics problem in one dimension. Functions
    transform the data through a sequence of five representations.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed how `newtonSecond1D` transforms mass and force data
    into a differential equation. We’ll discuss the other transformations in detail
    later. [Figure 15-2](ch15.xhtml#ch15fig2) is the first of several figures in this
    chapter and the next few chapters that serve to give an overview of the process
    of solving a mechanics problem. As we expand and generalize the ideas of state
    and numerical method, these figures will become more general, more streamlined,
    and a bit more abstract. Their purpose, central to a deep understanding of Newtonian
    mechanics, is to suggest a high-level way of thinking about the meanings and solution
    techniques of Newton’s laws. The figures organize the many functions we’ve written
    into a coherent, operational description of how to make predictions with Newtonian
    mechanics. Understanding what it takes to solve Newton’s second law is a prerequisite
    to a more profound insight into what the law means.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are two places in [Figure 15-2](ch15.xhtml#ch15fig2) where additional
    information comes in. A time step is required for the Euler method that transforms
    a differential equation into a state-update function, and an initial state is
    required to transform a state-update function into a list of states. In this figure,
    I regard the object’s mass, along with the forces, to be part of the initial information
    that specifies the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Solving with Euler’s Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To solve differential Equations 15.2, 15.3, and 15.4, we will discretize time,
    choosing a time step *Δt* that is smaller than any important time scales in the
    problem we are solving. We’ll use the Euler method, which approximates the time-slope
    of each state variable over the course of one time step by the time derivative
    of that variable at the beginning of the time step. [Figure 15-3](ch15.xhtml#ch15fig3)
    shows the Euler method for solving Newton’s second law in one dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/249fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: Euler method for Newton’s second law in one dimension*'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the schematic diagram of [Figure 15-1](ch15.xhtml#ch15fig1), with values
    that continuously change with time, the functional diagram in [Figure 15-3](ch15.xhtml#ch15fig3)
    has values that do not change. Change in a quantity, such as position, over time
    is represented by a sequence of values on different wires.
  prefs: []
  type: TYPE_NORMAL
- en: The function `euler1D`, shown below, transforms a differential equation into
    a state-update function, as shown in [Figure 15-2](ch15.xhtml#ch15fig2). To do
    this, it takes a time step in addition to the differential equation as input.
    Each state variable is updated by changing its value by its derivative (calculated
    from the differential equation) multiplied by the time step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 15-3](ch15.xhtml#ch15fig3) composes a state-update function over and
    over again. We call the state-update function `updateTXV` because it updates time,
    position, and velocity. As before, let’s go through three expressions of this
    state-update function. [Figure 15-4](ch15.xhtml#ch15fig4) shows the state-update
    function as a functional diagram, indicating how a new time-position-velocity
    triple is formed from an old triple.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/250fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: How to update the state variables time, position, and velocity
    when a small time interval* Δ*t has elapsed*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll give state-update equations in mathematical notation. The state-update
    equations tell us how the state variables time, position, and velocity must be
    updated to advance to the next time step.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/251equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we define the Haskell function `updateTXV`, which produces a new state
    triple from an old state triple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that `updateTXV` is essentially the composition of `newtonSecond1D` and
    `euler1D`, so it transforms the mass and force data (the first of our five data
    representations) into a state-update function (the third of the five).
  prefs: []
  type: TYPE_NORMAL
- en: Producing a List of States
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step in the data flow of [Figure 15-2](ch15.xhtml#ch15fig2) is to produce
    an infinite list of states from the state-update function and an initial state.
    The Haskell Prelude function `iterate` can do this, essentially transforming [Figure
    15-4](ch15.xhtml#ch15fig4) into [Figure 15-3](ch15.xhtml#ch15fig3). A list of
    time-position-velocity triples can be regarded as a solution to a Newton’s second
    law problem. The list of states contains a time-position-velocity triple for every
    time that has been probed by the Euler method of [Figure 15-3](ch15.xhtml#ch15fig3).
    The function `statesTXV` produces a list of states when given a time step, a mass,
    an initial state, and a list of force functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All we are doing here is iterating the update function to produce an infinite
    list of states. Note that we need to pass the time step, mass, and list of forces
    as parameters to `updateTXV` before it can serve as an iterable function passable
    to `iterate`. Iterate requires a function with type `a -> a` that can be applied
    again and again.
  prefs: []
  type: TYPE_NORMAL
- en: The function `statesTXV` transforms the mass and force data (the first of our
    five data representations), along with a time step and an initial state, into
    an infinite list of states (the fourth of our five representations). With this
    function, we have a general-purpose way of solving any Newton’s second law type
    problem in one spatial dimension. By a solution, we mean an infinite list of states
    (time-position-velocity triples) of the object, spaced one time step apart from
    each other. From this infinite list of states, we can extract whatever data we
    are most interested in and graph it or animate it.
  prefs: []
  type: TYPE_NORMAL
- en: Position and Velocity Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For our fifth and last data representation, we wish to write a function `velocity`
    `Ftxv`, similar to `velocityCF`, `velocityFt`, `velocityFv`, and `velocityFtv`,
    but for the case of forces that depend on time, position, and velocity. This function
    will transform the mass and force data (the first of our five data representations),
    along with a time step and an initial state, into a velocity function (part of
    the fifth of our five representations).
  prefs: []
  type: TYPE_NORMAL
- en: To help us do this, we want to write a function `velocity1D` that transforms
    from an infinite list of states (the fourth of our five data representations)
    into a velocity function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We name the infinite list of states `sts` and the desired time `t`. We assume
    that the time step stays the same throughout the infinite list of states, and
    we calculate the time step from the time values in the first two states of the
    list. In the first two lines of the `let` clause, we use the list index operator
    (`!!`) to pick out the first and second states of the list. Since `State1D` is
    a type synonym for `(R,R,R)`, we use pattern matching to pick out the time from
    the state. The local variables `t0` and `t1` are the times for the first two states
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The third line in the `let` clause defines a local variable `dt` for the time
    step, calculated as the difference between the times of the first and second states.
    The fourth line in the `let` clause computes the number of time steps required
    to reach the state that is closest to the desired time, and it names this number
    of steps with the local variable `numSteps`. The fifth line in the `let` clause
    uses the list index operator to pick out the state closest to the desired time
    and then names the velocity of that state `v0` using pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: All of the real work in this function is done in the `let` clause. The function
    returns `v0`, which is the velocity that occurs closest to the desired time `t`.
  prefs: []
  type: TYPE_NORMAL
- en: For the function `velocityFtxv`, which does the full transformation, we’ll use
    the infinite list produced by `statesTXV`, in conjunction with `velocity1D`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once we have a velocity function, we could integrate to get a position function,
    but all of this position information is contained in our list of states, so we
    might as well extract the position function from that using `position1D`, which
    is very similar to `velocity1D`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here is the function `positionFtxv`, which makes the full transition from our
    initial data representation in terms of mass and forces, along with a time step
    and an initial state, into our final representation giving the position of our
    object as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the functions `velocityFtxv` and `positionFtxv`, we have a general purpose
    way of solving any Newton’s second law problem in one spatial dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next let’s look at an example of where to use this technology: a Ping-Pong
    ball oscillating at the end of a Slinky. The restoring force of the Slinky on
    the ball depends on the position of the Ping-Pong ball, and air resistance depends
    on the velocity of the ball.'
  prefs: []
  type: TYPE_NORMAL
- en: A Damped Harmonic Oscillator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example of a situation with forces that depend on position and velocity,
    let’s consider a damped harmonic oscillator. In particular, let’s consider a Ping-Pong
    ball oscillating at the end of a vertically hanging Slinky. A Slinky is a spring,
    made of metal or plastic, that is sold as a child’s toy. We’ll choose a coordinate
    system where up is positive and choose the zero of position to be the place where
    the lower end of the Slinky hangs without the Ping-Pong ball attached. The Ping-Pong
    ball has a mass of 2.7 g and a radius of 2 cm.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll include three forces on the ball, all acting vertically. The first force
    is produced by the spring and acts to restore the mass toward the equilibrium
    position. The spring force is given by *Hooke’s law*,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/254equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which claims that the force produced by the spring is proportional to the displacement
    *x*[0] of the mass from its equilibrium position. The constant *k* is called the
    *spring constant* of the spring. A spring with a large spring constant is stiff
    and takes lots of force to extend or compress. The minus sign makes the spring
    force a *restoring force*, which acts in a direction to restore the object to
    its equilibrium position.
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium position is *x*[0] = 0\. If *x*[0] is positive, then *F*[spring](*x*[0])
    is negative, and the force acts toward the equilibrium position. If *x*[0] is
    negative, then *F*[spring](*x*[0]) is positive, and again the force acts toward
    the equilibrium position.
  prefs: []
  type: TYPE_NORMAL
- en: The spring force depends only on the ball’s position and not on its velocity
    or on the time. But knowing that we want to use a function like `statesTXV` or
    `positionFtxv`, which requires a list of forces `State1D -> Force` given as functions
    of the state, we’ll write Hooke’s law so that it has this type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The second force is the force of air resistance, a force that damps the natural
    oscillation of the ball on the spring. We’ll use Equation 14.9 for air resistance,
    repeated here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/254equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We use a drag coefficient of 2.
  prefs: []
  type: TYPE_NORMAL
- en: The third force is the force of gravity acting on the ball. Near Earth’s surface,
    the force of gravity on an object with mass *m* is
  prefs: []
  type: TYPE_NORMAL
- en: '*F[g]* = –*mg*'
  prefs: []
  type: TYPE_NORMAL
- en: where *g* = 9.80665 m/s² is the acceleration of gravity, and where we employ
    a coordinate system in which “away from Earth’s center” is the positive direction.
  prefs: []
  type: TYPE_NORMAL
- en: We take the Slinky to have a spring constant of 0.8 kg/s². We’ll release the
    ball at a position 10 cm above the equilibrium position so that *x*(0 s) = 0.1
    m and *v*(0 s) = 0 m/s.
  prefs: []
  type: TYPE_NORMAL
- en: Before we use our Haskell functions to investigate the motion of the ball, let’s
    investigate it using Euler’s method by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Euler Method by Hand
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want to have a clear mental picture of what the computer is doing when it
    applies the Euler method. To this end, we will calculate a few steps of the Euler
    method by hand (meaning with a calculator) to see in detail what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the state-update Equations 15.6 and 15.7 with a time step of Δ*t*
    = 0.1 s. A time step of 0.1 seconds is too large to get accurate results for this
    problem, but it serves to show the essence of the Euler method.
  prefs: []
  type: TYPE_NORMAL
- en: Our mission is to complete the following table. We can fill in all of the time
    values because they are simply spaced at 0.1 s intervals. We’ll also fill in the
    initial values of position and velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '| **t (s)** | **x(t) (m)** | **v(t) (m/s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.0 | 0.1000 | 0.0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.1 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 0.2 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 0.3 |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'The net force on the Ping-Pong ball is given by the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/255equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using *t* = 0.0 s, *x*(0.0 s) = 0.1000 m and *v*(0.0 s) = 0.0000 m/s (in other
    words, the information in the first row of our table) in the state-update Equations
    15.6 and 15.7, we can find *x*(0.1 s) and *v*(0.1 s) (the information in the second
    row of our table). The state-update equations are exactly what we need to produce
    a new row of our table from an existing row.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/255equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using *t* = 0.1 s, *x*(0.1 s) = 0.1000 m, and *v*(0.1 s) = –3.9436 m/s (the
    information in the second row of our table) in the state-update equations, we
    can find *x*(0.2 s) and *v*(0.2 s) (the information in the third row).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/255equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using *t* = 0.2 s, *x*(0.2 s) = –0.2944 m, and *v*(0.2 s) = –7.0005 m/s (the
    information in the third row of our table), we can find *x*(0.3 s) and *v*(0.3
    s). (the information in the fourth row).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/256equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The completed table looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **t (s)** | **x(t) (m)** | **v(t) (m/s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.0 | 0.1000 | 0.0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.1 | 0.1000 | –3.9436 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.2 | –0.2944 | –7.0005 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.3 | –0.9945 | 3.5359 |'
  prefs: []
  type: TYPE_TB
- en: Since states are time-position-velocity triples, this completed table contains
    the first four states of the Ping-Pong ball for the Euler method with a time step
    of 0.1 s. If we ask the computer to produce an infinite list of states using our
    function `statesTXV`, the first four states should look like this. We can imagine
    that the process we used to complete this table is what the computer is doing
    over and over again to produce a list of states for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now turn to the technology we developed earlier in the chapter to find
    the position of the Ping-Pong ball as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 1: Producing a List of States'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here we’ll use the `statesTXV` function to produce a list of states and then
    extract position versus time information to make a graph.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not required to give a name to the list of forces that act on the Ping-Pong
    ball. We could insert the list as the appropriate input to `statesTXV`, but I
    think it may organize and help our thinking to give the list of forces a name.
    Let’s call it `dampedHOForces`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We see that this is a list of the three forces we discussed earlier. First we
    have the spring force, then the force of air resistance, and then the force of
    gravity. We use anonymous-function notation to express the latter two forces because
    they need to be expressed as functions of the state. In the case of the force
    of gravity, we don’t care at all about the state, so we don’t need to name the
    state or name the time, position, and/or velocity variables that make up the state.
    For the force of air resistance, underscores in the time and position entries
    for the state are reminders that the air resistance function does not need their
    values.
  prefs: []
  type: TYPE_NORMAL
- en: To produce an infinite list of states, we use the `statesTXV` function with
    a time step of 1 ms, or 0.001 s, which is on the threshold of acceptability in
    the sense that smaller time steps would produce a graph that is only a little
    bit different in its results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We need to send `dampedHOStates` all of the information about our problem. In
    addition to the time step of 0.001 s, we send the Ping-Pong ball mass of 0.0027
    kg, the initial state consisting of time 0 s, position 0.1 m, and velocity 0 m/s,
    and the list of forces, which we named `dampedHOForces`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to look at the raw time-position-velocity data, you can use the
    list element operator (`!!`) to select particular states from the list, or you
    can `take` the first several elements of this infinite list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A list of pairs is something we can plot with the `plotPath` function from the
    `gnuplot` package, but we need to truncate the list to a finite list before plotting;
    otherwise, `plotPath` will hang while trying to finish calculating an infinite
    list. In the code that follows, we use the `take` function to extract the first
    3,000 states, corresponding to the first three seconds of motion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 15-5](ch15.xhtml#ch15fig5) shows the oscillation of the ball as a function
    of time. Notice the oscillation is not centered at position zero. This is because
    zero is the equilibrium position of the spring with no ball attached. When we
    attach the Ping-Pong ball, its weight will extend the spring downward, forming
    a new equilibrium position at the place where – *k*[*x*0] – *mg* = 0\. The upward
    force of the spring cancels the downward force of gravity; air resistance plays
    no role in the new equilibrium position because the ball is not moving at equilibrium.
    The new equilibrium position is *x*[0] = *–mg*/*k* = –0.033 m, so this is the
    position about which the oscillation is centered, as you can see in [Figure 15-5](ch15.xhtml#ch15fig5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/258fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Oscillation of a Ping-Pong ball on the end of a Slinky*'
  prefs: []
  type: TYPE_NORMAL
- en: Having explored one data representation for a solution to Newton’s second law,
    namely a list of states, let’s take a look at another representation, that of
    position and velocity functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 2: Producing Position and Velocity Functions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the function `positionFtxv` to produce a position function for the
    Ping-Pong ball on the Slinky.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the information necessary to describe the situation is included in the
    one line that makes up the body of this function: the 0.0027-kg mass; the initial
    state consisting of time 0 s, position 0.1 m, and velocity 0 m/s; and the list
    `dampedHOForces` of three forces defined earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: The following code will produce a graph very much like that shown in [Figure
    15-5](ch15.xhtml#ch15fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can use the function `velocityFtxv` to produce a velocity function for the
    Ping-Pong ball on the Slinky.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we can graph our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code produces [Figure 15-6](ch15.xhtml#ch15fig6), which shows a graph of
    velocity versus time for the Ping-Pong ball. Velocity starts at zero since we
    release the ball from rest and then becomes negative as the ball moves downward.
    The velocity oscillates and experiences the same sort of damping that the position
    does.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/259fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Velocity of a Ping-Pong ball on the end of a Slinky*'
  prefs: []
  type: TYPE_NORMAL
- en: The Euler method is a general-purpose state-based way of solving a system of
    first-order differential equations (which is more or less equivalent to a single
    higher-order differential equation). However, the Euler method does not usually
    get very much bang out of the computational buck, in that the time step often
    must be very small to get acceptable results. There are many other methods to
    choose from, and a small modification to the Euler method, which we explore in
    the next section, typically allows one to get acceptable results with a larger
    step size, decreasing the computational cost of a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Euler-Cromer Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make a slight modification to the Euler method that improves the results
    of Newton’s second law calculations in many cases. Instead of the functional diagram
    that describes the Euler method in [Figure 15-3](ch15.xhtml#ch15fig3), let’s look
    at a functional diagram for the Euler-Cromer method, shown in [Figure 15-7](ch15.xhtml#ch15fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/260fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-7: The Euler-Cromer method for Newton’s second law in one dimension*'
  prefs: []
  type: TYPE_NORMAL
- en: The difference lies in the value of velocity used to update position. The Euler
    method used the old velocity to update the position. The Euler-Cromer method calculates
    a new velocity using the same velocity-update equation as in the Euler method
    but then uses this new velocity to update the position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the state-update Equations 15.6 and 15.7 for the Euler method, the
    Euler-Cromer method uses the following slightly modified equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/261equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The velocity-update equation for Euler-Cromer is the same as the velocity-update
    equation for Euler. The difference is the replacement of *v*(*t*) with *v*(*t*
    + Δ*t*) in the position-update equation. While the order in which the Euler update
    equations 15.6 and 15.7 are evaluated is irrelevant, the Euler-Cromer velocity-update
    equation must be evaluated before the position-update equation because the updated
    velocity is used in the latter equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one of the benefits of a functional language with names that refer
    to objects that don’t change is that we don’t need to worry about telling the
    computer to update the velocity first. We can put the equations in whatever order
    we want, and the compiler will figure out an appropriate order of evaluation.
    The following function plays the role for Euler-Cromer that `euler1D` played for
    Euler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this code, I use the local variable `v1`, which is the updated value of velocity,
    before I give the equation for how to find it. The compiler will know to order
    the evaluations so that `v1` is computed before it is used.
  prefs: []
  type: TYPE_NORMAL
- en: The function `updateTXVEC` is the Euler-Cromer version of the state-update function
    corresponding to Euler’s `updateTXV`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Euler-Cromer method comes closer to conserving energy in cases where it
    should be conserved, and it’s generally better for situations with oscillatory
    behavior. Both the Euler and Euler-Cromer methods converge to the correct result
    as the time step is decreased, but Euler-Cromer can often achieve acceptable results
    with a larger time step than Euler would require.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-7](ch15.xhtml#ch15fig7) shows an alternative uncoiling of [Figure
    15-1](ch15.xhtml#ch15fig1) corresponding to the Euler-Cromer method. Comparing
    [Figure 15-3](ch15.xhtml#ch15fig3) (which describes the Euler method) and [Figure
    15-7](ch15.xhtml#ch15fig7), we see that the only difference is that the updated
    velocity is used to update the position.'
  prefs: []
  type: TYPE_NORMAL
- en: The functions `statesTXV`, `velocityFtxv`, and `positionFtxv` use the function
    `updateTXV`, which means they use the Euler method. In Exercise 15.13, you are
    asked to write analogous functions for the Euler-Cromer method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Euler-Cromer method is specific to second-order differential equations
    because there must be a state variable playing the role of velocity that can be
    updated first and then used to update the main unknown function (position for
    Newton’s second law).
  prefs: []
  type: TYPE_NORMAL
- en: As we expand our study of mechanics in the next several chapters, we’ll continue
    to solve differential equations. The final section of this chapter prepares the
    way for future chapters by treating the process of differential equation solving
    in greater generality.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Differential Equations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical mechanics problem starts as a physics problem as we use physical information
    to construct a differential equation, then becomes a mathematics problem as we
    solve the differential equation, and finally becomes a physics problem again as
    we interpret the results. This section focuses on the mathematical activity, beginning
    with a differential equation and ending with knowledge of how the state variables
    change with the independent variable (which in mechanics represents time).
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 15-2](ch15.xhtml#ch15fig2), we showed how information was transformed
    in the process of solving a mechanics problem. Starting with mass and force information,
    Newton’s second law produces a differential equation. The Euler method then transforms
    this differential equation into a state-update function. By iterating the state-update
    function, given some initial state, we arrive at a list of states. This list of
    states can be regarded as a solution to the problem, or we can proceed to an additional
    step and produce position and velocity functions for the object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next several chapters, in which we use vectors to describe quantities
    like velocity and treat multiple interacting particles, we will continue to view
    the process of solving a mechanics problem as one of information transformation,
    like that in [Figure 15-2](ch15.xhtml#ch15fig2). For this purpose we need to generalize
    [Figure 15-2](ch15.xhtml#ch15fig2) in two ways. The function `euler1D` will work
    with any differential equation that uses the state space `State1D`. In the previous
    chapter, we used `Velocity` and `(Time,Velocity)` as state spaces, and in the
    coming chapters, we will continue to expand the state spaces we use to include
    vectors and multiple particles. We want to be able to use the Euler method with
    the new state spaces we design, and it would be really great if we could write
    the Euler method once and for all in a way that would work with any state space.
    Later in this section, we’ll identify the commonality among these state spaces
    that allows us to do this. So, the first generalization is from the state space
    `State1D` to a broader class of state spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-2](ch15.xhtml#ch15fig2) uses the Euler method to transform a differential
    equation into a state-update function. Now that we have introduced the Euler-Cromer
    method, we have two numerical methods, each of which can perform this transformation.
    The second generalization is from the Euler method to other numerical methods.
    We want our information transformation process to allow whatever numerical method
    we might wish to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn to the question of how to generalize the state space.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing the State Space
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To generalize the state space from `State1D` to other possibilities, we will
    use a type variable `s` for the data type of the state. If we can write functions
    with types expressed in terms of `s`, rather than `State1D`, we can use these
    functions with any state space. When we generalize `Velocity`, `(Time,Velocity)`,
    and `State1D`, type `s` will contain whatever state variables are necessary for
    the physical system in question.
  prefs: []
  type: TYPE_NORMAL
- en: Where [Figure 15-2](ch15.xhtml#ch15fig2) has a differential equation based on
    state space `State1D`, we want differential equations based on state space `s`.
    Where [Figure 15-2](ch15.xhtml#ch15fig2) has a state-update function based on
    state space `State1D`, we want a state-update function based on state space `s`.
    Where `euler1D` is a numerical method that transforms a differential equation
    based on `State1D` into a state-update function based on `State1D`, we want to
    be able to talk and write about numerical methods that transform a differential
    equation based on state space `s` into a state-update function based on `s`.
  prefs: []
  type: TYPE_NORMAL
- en: To be precise, we’re going to give formal definitions for the differential equation,
    state-update function, and numerical method for state space `s` by writing type
    synonyms. We’ll start with the state-update function because that is the simplest
    of the three.
  prefs: []
  type: TYPE_NORMAL
- en: Since a state-update function, such as `updateTXV dt m fs`, produces a new state
    with the same type as the input state, a state-update function for state space
    `s` is a function `s -> s`. This definition can be encoded as a type synonym.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The type `UpdateFunction s` is the type for state-update functions that work
    with state space `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-1](ch15.xhtml#ch15tab1) shows the state-update functions we have
    used so far in the last chapter and the current chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** State-Update Functions That Work with Different State Spaces'
  prefs: []
  type: TYPE_NORMAL
- en: '| **State-update function** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `updateVelocity dt m fs` | `UpdateFunction Velocity` |'
  prefs: []
  type: TYPE_TB
- en: '| `updateTV dt m fs` | `UpdateFunction (Time,Velocity)` |'
  prefs: []
  type: TYPE_TB
- en: '| `updateTXV dt m fs` | `UpdateFunction State1D` |'
  prefs: []
  type: TYPE_TB
- en: Note that for each function we must supply a time step, a mass, and a list of
    force functions before the resulting expression has the type shown on the right
    side of the table.
  prefs: []
  type: TYPE_NORMAL
- en: A differential equation takes a state as input and produces derivatives of each
    state variable as output. With the state space `State1D`, the input consists of
    time, position, and velocity, while the output is numbers, velocity, and acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: Time is not the same thing as a dimensionless number, position is not the same
    thing as velocity, and velocity is not the same as acceleration. However, these
    are all real numbers for `State1D`, so the state space can also be written as
    `(R,R,R)`. In the function `euler1D` from earlier, I used the type `State1D ->
    (R,R,R)` for the differential equation and the type `State1D ->` `State1D` for
    the state-update function. To the compiler, these are the same type. I wrote them
    differently because numbers, velocity, and acceleration aren’t the quantities
    that belong in a `State1D`.
  prefs: []
  type: TYPE_NORMAL
- en: To treat the difference between state variables and their time derivatives,
    we will use a type variable `ds` for a quantity that represents the time derivatives
    of the state variables. Just as the type variable `s` is for state, the type variable
    `ds` is for the time derivative of state.
  prefs: []
  type: TYPE_NORMAL
- en: A differential equation, as represented in Haskell, is a function that returns
    a set of derivatives of state variables when given a set of state variables. If
    `s` is the data type for state, and `ds` is the data type for time derivative
    of state, then the definition of a differential equation can be given as a type
    synonym.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The type `DifferentialEquation s ds` is the type for differential equations
    that work with state space `s` and time derivative of state space `ds`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-2](ch15.xhtml#ch15tab2) shows the differential equations we have
    used so far in the last chapter and the current chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-2:** Differential Equations That Work with Different State Spaces'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Differential equation** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondV m fs` | `DifferentialEquation Velocity R` |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondTV m fs` | `DifferentialEquation (Time,Velocity) (R,R)` |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecond1D m fs` | `DifferentialEquation State1D (R,R,R)` |'
  prefs: []
  type: TYPE_TB
- en: Note that for each function we must supply a mass and a list of force functions
    before the resulting expression has the type shown on the right side of the table.
  prefs: []
  type: TYPE_NORMAL
- en: A numerical method transforms a differential equation into a state-update function.
    The definition of numerical method for state space `s` and derivative space `ds`
    can be given as a type synonym.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The type `NumericalMethod s ds` is the type for numerical methods that work
    with the state space `s` and time derivative space `ds`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the differential equation itself is a mathematically exact expression,
    applying a numerical method to solve it necessarily involves approximation. We
    have seen two numerical methods so far: the Euler method and the Euler-Cromer
    method. However, there are many numerical methods to choose from in solving a
    differential equation.'
  prefs: []
  type: TYPE_NORMAL
- en: Since there are many numerical methods, which all lead to different approximations,
    it makes little sense to bake one particular numerical method into the foundational
    ideas and code that constitute both the structure of how we think about solving
    mechanics problems and the computational tools to solve them. We should be able
    to choose a numerical method freely, independently of the differential equation
    we are solving. We want to separate the numerical method from the differential
    equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-3](ch15.xhtml#ch15tab3) shows the numerical methods we have used
    so far in this chapter. In the previous chapter, we never wrote an explicit numerical
    method, instead placing the Euler method code inside the state-update function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-3:** Numerical Methods That Work with the State1D State Space'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Numerical method** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `euler1D dt` | `NumericalMethod State1D (R,R,R)` |'
  prefs: []
  type: TYPE_TB
- en: '| `eulerCromer1D dt` | `NumericalMethod State1D (R,R,R)` |'
  prefs: []
  type: TYPE_TB
- en: Note that for each function we must supply a time step before the resulting
    expression has the type shown on the right side of the table.
  prefs: []
  type: TYPE_NORMAL
- en: Given a differential equation and a numerical method, we can solve the differential
    equation by applying the numerical method, which results in a state-update function,
    and then iterate the state-update function to produce a list of states. The following
    function takes a numerical method, a differential equation, and an initial state
    as input and produces a list of states as output. We can think of this function
    as a general-purpose differential equation solver.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We said earlier that solving a differential equation is the mathematical part
    of solving a mechanics problem, in which we transform a differential equation
    through a state-update function and ultimately to a list of states. The function
    `solver` carries out the entire mathematical process of solving a differential
    equation. In other words, it handles the mathematical part of solving a mechanics
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve given definitions for differential equation, state-update function, and
    numerical method, each of which works with a state space `s` and time derivative
    space `ds`. We now turn to writing a general-purpose function `euler` that can
    act as a numerical method for an almost-arbitrary state space `s`.
  prefs: []
  type: TYPE_NORMAL
- en: Type Classes for State Spaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The state space type `s` and time derivative space `ds` cannot be just any data
    types. To carry out the Euler method and other numerical methods, we need to be
    able to add elements of the time derivative space `ds`, and we want to be able
    to scale elements by a time step. A space that supports addition of states and
    scalar multiplication of states by real numbers is called a *real vector space*.
  prefs: []
  type: TYPE_NORMAL
- en: To express the constraint that our time derivative space be a real vector space,
    we define a type class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines a new type class `RealVectorSpace` that owns two functions:
    `(+++)` for addition and `scale` for scalar multiplication. You can see from the
    type signatures that the addition function takes two state derivatives as input
    and produces one as output, while the scalar multiplication function takes a real
    number and a state derivative as input and produces a state derivative as output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each derivative space we wish to use, we’ll write an instance declaration
    saying exactly how addition and scalar multiplication are to be defined for that
    data type. For the type `(R,R,R)`, which is the derivative space associated with
    state space `State1D`, here is the instance declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We use the local variable `dxdt0` to remind us that this name stands for a quantity
    that represents the derivative of a position with respect to time. The instance
    declaration defines adding two triples to mean adding each corresponding pair;
    it defines scaling a triple by a real number to mean scaling each item in the
    triple by the real number.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use a type class to claim a relationship that must hold between
    a state space `s` and its derivative space `ds`. The relationship describes how
    a state variable in `s` can be advanced in time using knowledge of the state variable’s
    time derivative in `ds`. We name the type class `Diff` to remind us of the differentiation
    (the taking of a time derivative) that relates a state space `s` to its derivative
    space `ds`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This type class definition contains a type class constraint saying that `ds`
    must be a `RealVectorSpace`. The type class `Diff` owns the function `shift`.
    For each pair of types we wish to use as state space and derivative space, we
    will provide an instance declaration that defines what the function `shift` does
    with values of the two spaces. The function `shift` describes how a state can
    be advanced in time using knowledge of the derivative state. The function `shift`
    takes a time step, a state derivative, and a state as input and gives a new state
    as output.
  prefs: []
  type: TYPE_NORMAL
- en: A type class used to relate two types rather than to claim membership of a single
    type is called a *multi-parameter type class*. The second line of the introductory
    code for the module we are writing in this chapter turns on a `LANGUAGE` feature
    called `MultiParamTypeClasses` to allow the use of multiparameter type classes.
    Their use is disabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instance declaration claims a differentiation relationship between
    the types `State1D` and `(R,R,R)` by defining the function `shift` for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The function `shift` says that to update time, we should multiply a time step
    `dt` by the rate `dtdt` at which time changes (which is 1). It says that to update
    position, we should multiply a time step `dt` by the rate `dxdt` at which position
    changes and act similarly to update velocity. Time, position, and velocity come
    from the state, while the rates of change come from the state derivative.
  prefs: []
  type: TYPE_NORMAL
- en: We see that `shift` looks a lot like the Euler method. In fact, it is more basic
    than that. The `shift` function will be used by the Euler method but also by other
    numerical methods.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the generic version of the Euler method, which is suitable for any differential
    equation based on any state space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As long as data types `s` and `ds` are appropriately related by the `Diff` type
    class, which is to say that `s` is a state space and `ds` is a derivative space
    that goes along with `s`, the function `euler` will carry out the Euler method
    with state variables from `s`, using the differential equation passed in as `deriv`.
    The Euler method is carried out by a single use of the `shift` function, where
    the derivatives are evaluated at the current state.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-4](ch15.xhtml#ch15tab4) compares the types of `euler1D` and `euler`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-4:** Comparison of the Function euler1D with the More General Function
    euler'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `euler1D` | `::` | `R -> NumericalMethod State1D (R,R,R)` |'
  prefs: []
  type: TYPE_TB
- en: '| `euler` | `::` | `Diff s ds => R -> NumericalMethod s ds` |'
  prefs: []
  type: TYPE_TB
- en: The function `euler` can be used anywhere that `euler1D` can be used, and in
    other places as well. Because it is written with a type variable, we’ll be able
    to use `euler` for the state spaces we make in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Can we do the same thing with the Euler-Cromer method? That is, can we write,
    once and for all, a numerical method that works with any state space and any differential
    equation? Sadly, the answer is no. The Euler method is a general-purpose technique
    for solving any system of first-order differential equations. The Euler-Cromer
    method is a specialized method for second-order differential equations, or for
    systems of first-order differential equations where we can identify a quantity
    to play the role of velocity. We’ll need to write a new Euler-Cromer function
    for each state space we work with.
  prefs: []
  type: TYPE_NORMAL
- en: Next we’ll introduce one more general-purpose numerical method that could be
    used instead of Euler or Euler-Cromer.
  prefs: []
  type: TYPE_NORMAL
- en: One More Numerical Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll introduce one more general-purpose numerical method,
    called the fourth-order Runge-Kutta method. Numerical methods are sometimes classified
    by an order. The order gives an expectation of how the error (the difference between
    the numerical solution and the exact solution) scales with the step size. When
    we shrink the step size by a factor of 10, the error for a first-order solver
    shrinks by about 10, while the error for a second-order solver shrinks by about
    10², or 100\. The Euler and Euler-Cromer methods are first-order methods and have
    the advantage of simplicity; it is straightforward to see why they work. The fourth-order
    Runge-Kutta method is substantially more complex. We won’t get into why it works
    well or why it is a fourth-order method. However, it is a popular method for solving
    differential equations, and it allows us to see a second general-purpose method
    for solving a differential equation. Fourth-order Runge-Kutta is a general method
    that will work with any differential equation and state space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the fourth-order Runge-Kutta method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that this method is more complex, but it has the same type as `euler`,
    and it plays the same role: transforming a differential equation into a state-update
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have three numerical methods to use, let’s compare them on a differential
    equation to which we know the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of Numerical Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s do a comparison of the three numerical methods we’ve introduced. The differential
    equations
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/269equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'can be written in Haskell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These differential equations are exactly solvable and have a solution of
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*t*) = *Ae^t*'
  prefs: []
  type: TYPE_NORMAL
- en: '*v*(*t*) = *Ae^t*'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*t*) = *Ae^(”t)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*v*(*t*) = –*Ae^(–t)*'
  prefs: []
  type: TYPE_NORMAL
- en: for some constant *A*. If we focus on the initial state in which *x*(0) = 1
    and *v*(0) = 1, the solution is
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*t*) = *e^t*'
  prefs: []
  type: TYPE_NORMAL
- en: '*v*(*t*) = *e^t*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare the exact solution at *t* = 8 to the approximations given by the
    three numerical methods we’ve presented using different step sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The `solver` function takes a numerical method, a differential equation, and
    an initial state to produce a list of states.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the first use of `solver`, we’re using a step size of 0.01, so item number
    800 in the list corresponds to *t* = 8\. The other two uses of `solver` use different
    step sizes and consequently different item numbers for *t* = 8.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-5](ch15.xhtml#ch15tab5) compares the three numerical methods we’ve
    discussed. You can see where these example calculations fit into the table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-5:** Comparison of the Euler, Euler-Cromer, and Fourth-Order Runge-Kutta
    Methods with the Exact Solution of a Differential Equation'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Δ*t* = 1** | **Δ*t* = 0.1** | **Δ*t* = 0.01** | **Δ*t* = 0.001** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Exact | 2981 | 2981 | 2981 | 2981 |'
  prefs: []
  type: TYPE_TB
- en: '| RK4 | 2895 | 2981 | 2981 | 2981 |'
  prefs: []
  type: TYPE_TB
- en: '| Euler-Cromer | 2584 | 3043 | 2988 | 2982 |'
  prefs: []
  type: TYPE_TB
- en: '| Euler | 256 | 2048 | 2865 | 2969 |'
  prefs: []
  type: TYPE_TB
- en: The exact result does not depend on any step size; it is just *e*⁸. All three
    numerical methods get closer to the exact result as the step size decreases. The
    Euler method is within 4 percent of the exact value at a step size of Δ*t* = 0.01
    and within 1 percent at a step size of Δ*t* = 0.001\. Euler-Cromer at Δ*t* = 0.1
    is better than Euler at Δ*t* = 0.01, and Euler-Cromer at Δ*t* = 0.01 is better
    than Euler at Δ*t* = 0.001\. Thus, we can use roughly 10 times the step size with
    Euler-Cromer compared to Euler and get comparable results for this differential
    equation. Similarly, we can use roughly 10 times the step size with fourth-order
    Runge-Kutta compared to Euler-Cromer and get comparable results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter completed the treatment of one-dimensional mechanics begun in
    the previous chapter. We saw how to handle forces that depend on position. With
    a force that depends on position, Newton’s second law is a second-order differential
    equation that we transform into coupled first-order differential equations for
    the state variables position and velocity. We can view the solution of a mechanics
    problem as the transformation of information about the physical situation through
    a sequence of five representations: mass and force functions, differential equation,
    state-update function, list of states, and position-velocity functions.'
  prefs: []
  type: TYPE_NORMAL
- en: A Ping-Pong ball oscillating on the end of a Slinky in the presence of air resistance
    was the central example of the chapter. We introduced the Euler-Cromer method,
    an improvement on the Euler method for second-order differential equations. We
    also introduced the fourth-order Runge-Kutta method, which, along with the Euler
    method, is a general-purpose numerical method for solving any differential equation
    with any set of state variables. In the next chapter, we’ll start three-dimensional
    mechanics by treating position, velocity, and acceleration as vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 15.1.** Let’s warm up with a basic projectile motion problem where
    we know what the answer should look like. Suppose someone throws a ball from the
    ground straight up into the air with an initial velocity of 10 m/s. Ignoring air
    resistance, use the function `positionFtxv` to find the height of the ball as
    a function of time. Make a plot of height as a function of time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.2.** Doing the Euler method by hand on [page 254](ch15.xhtml#ch15lev7),
    we arrived at a table of values for position and velocity. Show how to calculate
    these values using Haskell functions. The values may not match to four decimal
    places because I rounded intermediate results in doing the Euler method by hand,
    but the first two digits after the decimal point should match in every case.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.3.** (Euler method by hand.) Consider the differential equations'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/271equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: along with the initial conditions
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/271equ02a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use the Euler method with a step size of Δ*t* = 0.1 to approximate the value
    of *x*(0.3). Keep at least four figures after the decimal point in your calculations.
    Show your calculations in a small table. (The table will have three columns, one
    each for time, position, and velocity.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.4.** Write a Haskell function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: that takes a tuple (*t*[0], *x*[0], *v*[0]) and returns a tuple (*t*[1], *x*[1],
    *v*[1]) for a single step of the Euler method for the differential equations
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/271equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with a step size of Δ*t* = 0.1 and the same initial conditions as in the previous
    exercise. Show how to use the function `update2` to calculate the value *x*(0.3)
    that you calculated by hand in the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.5.** Consider a 3-kg mass connected to a wall by a linear spring
    with spring constant 100,000 N/m. Ignoring gravity and friction, if the spring
    is extended by 0.01 m and released, what does the subsequent motion look like?
    Investigate this motion over several cycles of oscillation. Compare your results
    to the exact solution. Find a time step that is small enough so that the Euler
    solution and the exact solution overlap precisely on a plot. Find another time
    step that is big enough so that you can see the difference between the Euler solution
    and the exact solution on a plot.'
  prefs: []
  type: TYPE_NORMAL
- en: Make a nice plot (with title, axis labels, and so on) with these three solutions
    on a single graph (bad Euler, good Euler, and exact). Label the Euler results
    with the time step you used, and label the exact result “Exact.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.6.** Let’s investigate dropping things from large heights. In
    particular, let’s look at a Ping-Pong ball and a bowling ball. In each case, take
    *C* = 1/2\. You will need to find out good approximations for things like the
    size and mass of these balls. Let’s drop them from heights of 100 m and 500 m.
    Make graphs of velocity as a function of time and velocity as a function of vertical
    position. What fraction of terminal velocity is achieved in each case? Assemble
    your results in some meaningful and understandable way.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.7.** Return to the harmonic oscillator of Exercise 15.5\. Compare
    the Euler and Euler-Cromer solutions to the exact solution for a time step of
    0.001 s (you will recall that this is not a very good time step for the Euler
    method). Plot the displacement of the mass as a function of time for the first
    0.1 s of motion. Plot Euler, Euler-Cromer, and exact solutions on one set of axes.
    Also give the value of the position of the mass (to four significant figures)
    at *t* = 0.1 s for each of the three solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.8.** Consider an object with mass *m* attached to a spring with
    spring constant *k*. The other end of the spring is attached to a vertical wall.
    The object slides horizontally across the floor. There is a coefficient of kinetic
    friction *μ[k]* = 0.3 between the object and the floor. The weight of the object
    is *mg*, so the force of kinetic friction on the object is μ[k] *mg*, directed
    opposite the velocity of the object.'
  prefs: []
  type: TYPE_NORMAL
- en: Let *m* = 3 kg and *k* = 12 N/m.
  prefs: []
  type: TYPE_NORMAL
- en: (a) Write a function with type `State1D -> Force` that gives the horizontal
    force of kinetic friction. You may want to use the `signum` function.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Use the function `positionFtxv` to find the position of the object as a
    function of time.
  prefs: []
  type: TYPE_NORMAL
- en: (c) Make a plot of position as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.9.** In most situations in mechanics, the mass of the object
    that we care about does not change. There is no need to include a quantity that
    doesn’t change in the state. However, since some forces, such as gravity, depend
    on mass, there is some motivation to include mass in the state simply for convenience.
    Several of the functions we developed in this chapter accept a list of force functions
    `[State1D -> Force]` as input. If we wanted to include Earth’s gravity as such
    a state-dependent force, we would need to write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Suppose, on the other hand, we include the object’s mass in its state by using
    the following 4-tuple as the data type for state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Then we could write an Earth gravity function as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that since mass is included in the state, we no longer need `Mass` as
    an extra parameter in the function type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write definitions for the following functions, using `MState` in place of `State1D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 15.10.** The Lennard-Jones potential'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/273equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: is sometimes used to model the interaction between atoms. The expression V[*LJ*]
    (*r*) gives the potential energy for a system of two atoms when the atoms are
    a distance *r* apart from each other. As *r* → 0, the potential energy becomes
    infinite, expressing the difficulty of having the two atoms very close together.
    The lowest value of potential energy occurs at an inter-atomic separation of *r*
    = *r[e]*, meaning that the parameter *r[e]* is the equilibrium separation of the
    atoms. The parameter *D[e]* represents the dissociation energy for the two-atom
    molecule, or the amount of energy that must be provided to the molecule to pull
    the atoms (arbitrarily far) apart.
  prefs: []
  type: TYPE_NORMAL
- en: The Lennard-Jones force
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/273equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: gives the force on one of the atoms produced by the other, with positive meaning
    repulsive and negative meaning attractive. We can think of the Lennard-Jones force
    as coming from a nonlinear spring that connects the two atoms. When the atomic
    separation is greater than *r[e]*, the spring provides an attractive force that
    attempts to restore equilibrium. When the atomic separation is less than *r[e]*,
    the spring provides a repulsive force that attempts to restore equilibrium. The
    spring is nonlinear in that the restoring force is not proportional to the deviation
    of the atomic separation from equilibrium.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-8](ch15.xhtml#ch15fig8) shows the Lennard-Jones force as a function
    of inter-atomic distance *r*, along with the linear spring force that most closely
    approximates it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-8: The Lennard-Jones force (curved line) and the linear force (straight)
    that most closely approximates it*'
  prefs: []
  type: TYPE_NORMAL
- en: The effective spring constant for the Lennard-Jones force is the negative slope
    of the force as a function of inter-atomic distance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose we have a mass *m* attached by a Lennard-Jones spring to a wall. We’ll
    ignore gravity and friction in this problem so that the Lennard-Jones force is
    the only force that acts on the mass. If an oscillation about the equilibrium
    position is small in amplitude, the angular frequency of the oscillation will
    be close to
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the period will be close to
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/274equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choose any parameters for *r[e]*, *D[e]*, and *m*.
  prefs: []
  type: TYPE_NORMAL
- en: (a) Make a graph of position versus time when the initial position is *r* =
    1.01*r[e]* and the initial velocity is zero. The graph should be oscillatory.
    Confirm that the period is close to the value given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Make a graph of position versus time when the initial position is *r* =
    5*r[e]* and the initial velocity is zero. What is the period now?
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of an anharmonic oscillator, where the period depends on
    the amplitude of oscillation. It is only the special case of the harmonic oscillator
    in which period is independent of amplitude.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.11.** Applying the Euler method by hand on [page 254](ch15.xhtml#ch15lev8),
    we arrived at a table of values for position and velocity. Produce a similar table
    of values using the Euler-Cromer method by hand.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.12.** Write a function `statesTXVEC` that is similar to `statesTXV`
    but uses the Euler-Cromer method instead of the Euler method. Use this function
    to check the table of values you calculated by hand in the previous exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.13.** Write versions of `statesTXV`, `velocityFtxv`, and `positionFtxv`
    that use the Euler-Cromer method rather than the Euler method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.14.** Show how to use Haskell functions to calculate the entries
    of the comparison table for numerical methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.15.** With the code'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: we have made the data type `(R,R)` an instance of type class `RealVectorSpace`
    and written a `Diff` instance for the pair of types `(Time,Velocity)` and `(R,R)`.
    Now we can use `(Time,Velocity)` as a state space and `(R,R)` as its derivative
    space for the Euler or fourth-order Runge-Kutta methods. Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: that does the same thing as `updateTV` from [Chapter 14](ch14.xhtml) but uses
    the function `euler` from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.16.** Newton’s second law generally produces a second-order differential
    equation (recall [Table 14-1](ch14.xhtml#ch14tab1)). Our `DifferentialEquation
    s ds` data type is for functions that return the derivatives of state variables
    when given the state variables themselves. A function with type `DifferentialEquation
    s ds` expresses a set of coupled first-order differential equations.'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we’ll rewrite a second-order differential equation as two
    coupled first-order differential equations. A second-order (ordinary) differential
    equation has one independent variable and one dependent variable (in other words,
    one unknown function). A set of two coupled first-order differential equations
    has one independent variable and two dependent variables (two unknown functions
    of the independent variable).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the recipe for producing a set of two coupled first-order differential
    equations from a second-order differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: The independent variable of the coupled set is the same as the independent variable
    of the second-order equation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first unknown function of the coupled set, choose the unknown function
    of the second-order equation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second unknown function of the coupled set, choose the derivative of
    the first unknown function with respect to the independent variable and give this
    function a new name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first differential equation in the coupled set expresses that the derivative
    of the first unknown function is equal to the second unknown function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To form the second differential equation in the set, start with the original
    second-order differential equation, replace the first derivative of the unknown
    function with the new second unknown function, replace the second derivative of
    the unknown function with the derivative of the new second unknown function, and
    solve for the derivative of the new second unknown function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Express the differential equation
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/276equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: as a set of two coupled first-order differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 15.17.** The Van der Pol oscillator is a generalization of the harmonic
    oscillator that is often used to explore chaos. It is described by the following
    differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/276equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can view this equation as coming from Newton’s second law with two forces
    present: a spring-like linear restoring force and a damping force. We will abandon
    SI units for this exercise, setting both mass and spring constant to unity. The
    spring force is then given by'
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[spring](*t, x, v*) = –*x*'
  prefs: []
  type: TYPE_NORMAL
- en: and the damping force is given by
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[damping](*t, x, v*) = *μ*(1 – *x*²)*v*'
  prefs: []
  type: TYPE_NORMAL
- en: where *μ* is a parameter that controls how nonlinear the damping force is. If
    *μ* = 0, the Van der Pol oscillator reduces to the harmonic oscillator.
  prefs: []
  type: TYPE_NORMAL
- en: When studying chaos, people often like to make phase plane plots, which are
    graphs of velocity as a function of position. (They can also be graphs of momentum
    as a function of position, but we will use velocity.) Fill in the undefined parts
    of the following code to make phase plane plots for *μ* = 0, *μ* = 2, *μ* = 4,
    and *μ* = 6, all on the same graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The result should look something like [Figure 15-9](ch15.xhtml#ch15fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/277fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-9: Phase plane plots for the Van der Pol oscillator*'
  prefs: []
  type: TYPE_NORMAL
