- en: '**9 nRF51 Gadgets in ROM**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First documented in Brosch (2015), this chapter describes an exploit for extracting
    protected memory from the nRF51822 despite code protection features. The vulnerability
    is that while the debugger cannot read protected memory directly or write shellcode
    to SRAM, it can single-step through the protected code in flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: Although this version is described for the nRF51 series, a similar bug is described
    in Obermaier, Schink, and Moczek (2020) for the CKS32F103 and GD32VF103, which
    are clones of the popular STM32F103\. Kovrizhnykh (2023) notes that the SN32F248B
    from Sonix has been exploited by the same technique.
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning All the Rules**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nRF51’s protection mechanism, documented in [Chapter 9](ch09.xhtml#ch09)
    of Nordic (2014), is built as an extension of the memory protection unit (MPU).
    An MPU is sort of like a memory management unit (MMU), except that it is coarser-grained
    and provides no support for virtual memory.
  prefs: []
  type: TYPE_NORMAL
- en: The most common readout protection for this chip is called Protect All (`PALL`),
    which is configured by writing zero into the I/O port `UICR.RBPCONF.PAL`. This
    is designed to prevent the SWD debugger from accessing code region 0, code region
    1, RAM, or any peripherals except for the `NVMC` peripheral, the `RESET` register
    in the `POWER` peripheral, and the `DISABLEINDEBUG` register in the `MPU` peripheral.
    You will often see a bootloader perform this protection at every boot, but the
    protection persists. It is only necessary to apply the protection once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0100-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: NXP nRF51822'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0101-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: nRF51822 Memory Map'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0102-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Brosch’s PoC nRF51822 Exploit'
  prefs: []
  type: TYPE_NORMAL
- en: There are also lesser protection modes, which restrict code region 1 from accessing
    code region 0\. The purpose of these modes is to protect soft devices, binary
    blob radio drivers that often require commercial licensing but still allow custom
    code to sit alongside. These blobs freely run in the lower region, and while the
    upper region can call into the lower, it cannot read that region as data.
  prefs: []
  type: TYPE_NORMAL
- en: The reference manual also mentions that whatever the protection mode, CPU fetches
    from code memory will not be denied and that the interrupt table from `0x00` to
    `0x80` is not protected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bypassing the Rules**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve covered the documented behavior of the protection, it’s necessary
    to experiment a bit and learn the unwritten rules. Kris Brosch discovered that
    by attaching a debugger to a locked chip, he had quite a bit of freedom to direct
    the CPU. He could read and write registers, including the program counter. He
    could also read from a few memory-mapped registers, such as the read-back protection
    configuration (`RBPCONF`) at `0x10001004`.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, while he did not have the freedom to directly read from protected
    regions with the debugger, he was able to single-step through existing code, controlling
    registers both before an instruction (as inputs) and after that same instruction
    (as outputs).
  prefs: []
  type: TYPE_NORMAL
- en: He reset the chip, which loads the program counter and the stack pointer from
    the interrupt vector table, then read the program counter back as `0x000114cc`.
    So he knew that the value of the reset vector at `0x00000004` ought to be `0x000114cd`.
    (Odd pointers indicate Thumb2 mode in ARM, but the PC itself does not hold the
    odd value. Instead, that status bit is held in a status register.)
  prefs: []
  type: TYPE_NORMAL
- en: Knowing one word in memory, he then repeatedly loaded all of the registers with
    `0x00000004` and jumped the PC to new addresses until he saw `r3` change to `0x000114cd`,
    indicating an arbitrary read gadget!
  prefs: []
  type: TYPE_NORMAL
- en: 'The gadget was `ldr r3, [r3, #0]` and it appeared as the second instruction
    in the reset handler. Repeatedly jumping into this gadget with different values
    of `r3` will expose all memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Brosch’s proof-of-concept can be found in [Figure 9.3](ch09.xhtml#ch9fig3).
    The telnet connection is to OpenOCD, and it assumes that the gadget is found in
    the reset handler. You’ll need to adjust it if the gadget is found elsewhere in
    your target.
  prefs: []
  type: TYPE_NORMAL
