- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE TYPE SYSTEM**
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented programming is an exceptionally bad idea which could only
    have originated in California.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Edsger Dijkstra
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Up to now we’ve been using and creating a lot of functions. We can think of
    functions as the verbs of the Julia language. And just as in natural languages,
    verbs act on nouns. The nouns in Julia are numbers, collections, strings, and
    other instances of types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve encountered many data types in our journey up to this point: different
    varieties of numbers, strings, characters, and collections such as arrays and
    maps. Although our focus hasn’t been on types, it’s impossible to talk much about
    Julia programming without making some reference to them. Julia is unusual in that
    it allows us to create very fast code without having to specify the types of variables,
    unlike other fast languages such as Fortran (where the specifications can be implicit)
    and C. However, effective Julia programming requires some knowledge of its type
    system. The main reason for this is that Julia programs are organized around functions
    and methods through its dispatch system, which relies on argument types. A secondary
    reason has to do with those occasions where an awareness of types allows us to
    write more efficient programs. This chapter covers both of these concerns.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Types in Practice**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than delve into the abstract theory of type systems, let’s approach types
    from a practical point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the type of any value, Julia provides the `typeof()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already considered the difference between strings and characters, and
    the related difference between single and double quotes; however, it’s important
    to have some understanding of the various numeric types. Although, for example,
    `17`, `17//1`, and `17.0` have the same values, they are different types of objects,
    and their behavior is potentially different. The difference in their types reflects
    this reality.
  prefs: []
  type: TYPE_NORMAL
- en: The curly brackets used in reporting the type of a rational number ➊ indicate
    that this is a *parametric type*, a topic we’ll return to in “Parametric Types”
    on [page 248](ch08.xhtml#ch08lev6). For now, it’s sufficient to understand that
    this is a `Rational` made up of `Int64` pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type reported for the floating-point literal is `Float64`, which means
    it’s a floating-point number, or a number with a decimal point, and that it’s
    stored in a 64-bit segment of memory. The 64 bits are apportioned as follows:
    1 for the sign, 11 for the exponent, and 52 for the “fraction.” The maximum absolute
    value of a `Float64` is about 10^(300), and it has 17 significant digits, or 16
    digits of precision beyond the decimal point. (This agrees with the observation
    that it takes three binary digits to represent a decimal digit.) We can see this
    using the `@printf` macro, supplied by the `Printf` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This shows incorrect digits appearing if we ask for more than 16.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll see more incorrect digits if we use floating-point types with lower precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we used the names of the types as functions to cast their arguments to
    the named types. Without the cast, expressions like `1/3` are `Float64` by default
    on most systems.
  prefs: []
  type: TYPE_NORMAL
- en: The default integer type on typical systems, `Int64`, ranges between *−*2^(63)
    and 2^(63) *−* 1, with one bit used for the sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia supplies built-in functions for finding the maximum and minimum values
    representable with each numeric type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But `typemax()` and `typemin()` aren’t very helpful if we ask them about floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Apparently infinity is a floating-point number, and Julia has infinities for
    each size float. This is consistent: since nothing is larger than infinity, if
    `Inf16` is a `Float16` it must be the largest possible `Float16`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia has another function that comes to the rescue here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The functions `floatmax()` and `floatmin()` return the maximum *finite* float
    and the minimum positive float of the requested type.
  prefs: []
  type: TYPE_NORMAL
- en: Usually we should perform arithmetic in our programs using these *native types*,
    which are the most efficient choices. If needed, and if possible, we can use smaller
    numbers to save space—for example, `Int16`—and we can get larger integers using
    `Int128`. However, if the native types are not adequate for our purposes, it’s
    usually because we need a lot of precision—in other words, many digits—in our
    computation. This is the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a particular value has a certain type, use the `isa()` function.
    We can use it as a normal function or in infix position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a Boolean value. The first two calls return `true` because
    `17` is both an `Int64` and a `Number`. The former implies the latter (see “The
    Type Hierarchy” on [page 222](ch08.xhtml#ch08lev1sec4)).
  prefs: []
  type: TYPE_NORMAL
- en: '***“Big” and Irrational Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Julia makes it easy to perform *arbitrary precision arithmetic* using types
    whose precision grows as needed: where the number of digits can grow without bound.
    Arithmetic with these types is slower than normal computation with native types,
    but for some jobs it’s the only choice.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arbitrary Precision**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As a simple example of where we would need arbitrary precision types, suppose
    we want to graph the factorial function. This is the function usually spelled
    with an exclamation mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/math217.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The corresponding Julia function is `factorial(n)`. The function grows extremely
    quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This shows that 20 is the largest factorial that fits in an `Int64`. We can
    go up to 33! if we use `Int128`, but what if we want to go bigger?
  prefs: []
  type: TYPE_NORMAL
- en: The error message provides a hint. The `big()` function converts its argument
    to a corresponding type with unlimited size and precision. For integers, this
    is called `BigInt`, and for floats it’s `BigFloat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `BigInt` to make a plot of the factorial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re plotting up to 50!, which is far beyond what can fit in a native
    integer. [Figure 8-1](ch08.xhtml#ch8fig1) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: The factorial function calculated using BigInt*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit the factorial in “Factorials” on [page 312](ch10.xhtml#ch10lev1sec1),
    where it appears as the number of ways to permute *n* objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BigFloat` type also offers unlimited magnitude. Its default precision
    is 256, giving us about 80 significant digits. We can set the `BigFloat` precision
    to be anything we need, using the `setprecision()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the precision, we have the `precision()` function, which accepts
    the type that we’re asking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The number of digits used for a `BigInt` grows as needed, so it doesn’t come
    with the concept of a fixed precision applicable to the floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Irrationals**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An unusual attribute of Julia is the existence of the *irrational type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The number represented by the Greek letter π is printed with three dots appended
    to suggest that there is more to the story. Although it appears to be a floating-point
    number, its type is not given as `Float64`, but as something new: `Irrational`.
    That’s because in Julia, π represents *not* a floating-point number, but the *exact
    value* of the ratio of a circle’s circumference to its diameter. The three dots
    remind us that the digits presented are simply the first few in an endless, nonrepeating
    series.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia calculates and presents more digits as and when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The number is not printed with trailing dots, as it’s no longer a representation
    of an exact value, but an approximation to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several other irrational numbers are built into Julia; the most important of
    these for general purposes is *e*, the base of the natural logarithms. To insert
    this character, which is the Unicode codepoint 212F (Script Small E), enter \euler
    and press TAB in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As with π, Julia displays the value of *e* with three trailing dots to indicate
    that it’s showing us a few digits of an exact value.
  prefs: []
  type: TYPE_NORMAL
- en: We can see an approximation to *e* ➊ to any desired number of digits by converting
    it to a `BigFloat`. By definition, the value of the natural logarithm of *e* is
    exactly the integer 1 ➋, but if we take the logarithms of approximations to *e*,
    we get an approximate, or floating-point, result.
  prefs: []
  type: TYPE_NORMAL
- en: '***Type Promotion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When performing arithmetic on a mixture of different numerical types, Julia
    will silently *promote* types as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The addition of two integers provides no reason to leave integer land, so the
    result is also an `Int64`. But if one of the numbers is a `Float64`, the other
    is promoted to that type, which is also the type of the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia will not promote nonnumerical types to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Its treatment of types and promotion is therefore similar to Python and dissimilar
    from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `promote()` function takes any number of numerical arguments and returns
    a tuple with (possibly) some of them promoted as necessary to give them all a
    common type so they can be used in subsequent calculations without further promotion.
    It performs the same promotions as would be performed automatically when doing
    arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The promotion in the first line shows how some numbers (2.0, 3.5) have an exact
    binary representation, but others (3.4) do not. The two following commands provide
    examples of how `promote()` converts its arguments to a common type.
  prefs: []
  type: TYPE_NORMAL
- en: '***Collections***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Julia prints the types of collections in the REPL when printing their values
    more often than it announces simple numerical types, so we’ve seen more of the
    former:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia prints the type of collection (`Matrix`, `Vector`, or `Array`) and its
    dimensions. A `Vector` is one-dimensional, and a `Matrix` is two-dimensional.
    For the more general `Array` type, Julia prints an integer showing the number
    of dimensions: here it’s a three-dimensional array ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It also indicates the types of the collection’s elements inside curly brackets.
    We can extract this information separately using the `eltype()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, the result, `Int64`, is the type of both elements of
    the array. The second example shows how Julia promotes numerical types when possible
    to create homogeneous arrays, which are more efficient to calculate with. However,
    when confronted with types where no promotion is possible ➊, the element type
    becomes `Any`: a type that literally means any type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These results follow the behavior of the `promote()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If elements can be promoted to a common type, that type is used for the `eltype`
    of the collection; otherwise, the `Any` type is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection types `Vector`, `Matrix`, and `Array` have some behaviors in
    common: for example, they can all be indexed. This is not true of all collections,
    however. The `Set` type has no ordering, hence no ability to be indexed. These
    three collection types share certain behaviors because they’re special cases of
    a more general type, a concept that we’ll explore in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Type Hierarchy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All types in Julia are *subtypes* of types that are their *supertypes.* The
    one type that has no strict supertype is the `Any` type, which is its own supertype.
    The concepts of supertypes and subtypes are connected with the inheritance of
    behaviors, and the configuration of the type hierarchy is usually intuitive when
    applied to particular cases. For example, we expect that any kind of number will
    support some notion of addition. Exactly what addition means may vary among various
    species of numbers—addition of complex numbers is a generalization of addition
    of real numbers, for example—but when we encounter a type that is a subtype of
    the `Number` type, we can be confident that, at least, the `+` operator is defined
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 8-1](ch08.xhtml#ch8lis1), the `supertype()` function, when
    supplied a type, returns its supertype.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Walking up the type hierarchy*'
  prefs: []
  type: TYPE_NORMAL
- en: The `typeof()` function returns the type of a literal value or variable. The
    types that we actually compute with, such as `Float64` and `Int64`, are called
    *concrete types*. Concrete types are leaves at the tips of the tree of types;
    they can not subtype each other.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-1](ch08.xhtml#ch8lis1) shows a series of calls to `supertype()`
    to find where the default integer type, `Int64`, lies in the type hierarchy. All
    of the types that concrete types such as `Int64` inherit from are *abstract types*.
    The purpose of abstract types, such as `Number`, is simply to create nodes in
    the tree of types to enable the definition of methods. The function of these abstract
    types, and the type hierarchy that they constitute, is not to make things more
    complicated, but to make the life of the Julia programmer easier. Because of the
    tree of types, we can define functions and methods that operate at the ideal level
    of abstraction, as we’ll see in “Functions and Methods: Multiple Dispatch” on
    [page 229](ch08.xhtml#ch08lev2).'
  prefs: []
  type: TYPE_NORMAL
- en: The final two lines in [Listing 8-1](ch08.xhtml#ch8lis1) show that `Number`
    is at the top of the hierarchy of numerical types, and its supertype, `Any`, is
    the root of the entire hierarchy, and, as the last line shows, is its own supertype.
  prefs: []
  type: TYPE_NORMAL
- en: By making more calls to `supertype()`, we can explore more of the type tree.
    [Listing 8-2](ch08.xhtml#ch8lis2) shows a modification of the program in [Listing
    7-3](ch07.xhtml#ch7lis3) to visualize a section of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Visualizing part of the type hierarchy*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve collected a handful of mostly numeric types in the `sometypes` vector.
    These are a subset of the total number of types that come with Julia and its standard
    library, and many more are defined in various packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-2](ch08.xhtml#ch8lis2) uses the `supertype()` function to create
    the edges ➊ of the tree graph, connecting each type to its supertype. [Figure
    8-2](ch08.xhtml#ch8fig2) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: The relationships among a few types*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-2](ch08.xhtml#ch8fig2) makes it clear that `Any` is the root of the
    tree and reminds us that, for example, characters and strings are distinct types.
    But it also obscures certain relationships, such as that some types are aliases
    of others. This is a topic we’ll explore later in this chapter (see “Type Aliases”
    on [page 247](ch08.xhtml#ch08lev5)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two additional functions that are handy for exploring the type hierarchy are
    `subtypes()`, which returns a vector of all the *immediate* subtypes of the type
    supplied as an argument, and `supertypes()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that `supertypes()` returns a tuple containing the type supplied
    and all of its supertypes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Type Assertions and Declarations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we know how to discover the type of any variable and the supertype of any
    type. On occasion, we also need to tell Julia that a variable is of a particular
    type (a *type declaration*), or that the value of an expression should have a
    specified type (a *type assertion*). The `::` operator performs either operation,
    depending on where it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Assertions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes in our programs we reach a point where it is important to ensure that
    the value of a particular expression has a certain type. If it does not, we want
    to generate an error, which we can either handle or allow to halt the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest expression in Julia is a literal value. Let’s use `17` as our
    first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first line is an assertion that `17` has the `Number` type, which of course
    it does. An expression with a type assertion attached returns the value of the
    expression if the assertion is true, so here Julia simply returns `17`. The following
    two lines are also true assertions. A type assertion is true if it specifies any
    supertype of the type of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: The final type assertion returns an error because `17` is neither a `String`
    nor a subtype of the `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how we might use a type assertion in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The program asks the user a question, receives the reply using `readline()`,
    and joins it with two other strings to construct a greeting, which it returns.
    We used a type assertion ➊ to ensure that the type returned by the function is
    what is expected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Declarations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We also use the `::` operator for type declarations. Its meaning is determined
    from its position within a statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare that a variable has a particular type in two ways. One way is
    to supplement the usual assignment statement with a declaration, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here the assignment and the type declaration happen simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Julia v1.8 was the first version that allowed type declarations of global
    variables; this makes working in the REPL more convenient. In earlier versions,
    all type declarations must occur in a local scope.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we declare the type of a variable, we are committed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As this example shows, an attempt to assign a value of the wrong type to a declared
    variable, or to explicitly change its type, results in an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any value assigned to `a` must be convertible to `a`’s type, `Int16`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The second assignment failed because 32,768 is larger than the largest value
    that an `Int16` can hold, which is 2^(15)−1 = 32,767, returned by `typemax(Int16)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-3](ch08.xhtml#ch8lis3) shows the other way to declare a type: as
    part of a `local` or `global` definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Type declarations*'
  prefs: []
  type: TYPE_NORMAL
- en: We define `gf` to be global and to have the `Float64` type. Julia seems happy
    to let us assign a literal integer to it, but it has converted the value to a
    `Float64` as part of the assignment ➊. Because there is no way to convert a literal
    string to a `Float64`, our attempt to assign a string to the variable failed ➋.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a variable of the same name, declared to be local, inside a function
    ➍ ; this local variable has no relationship with the global `gf`. The function
    `weather_report()` expects a `Bool` from the user (`true` or `false`), and uses
    it to construct a sentence about the weather. It uses the `isa` operator to check
    that it’s received the correct type ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following short program illustrates an important behavior of type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this function produces the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The line that prints the type of `a` comes *before* the type declaration; so
    why is `a` already an `Int16`? After all, this is what happens in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This output is what we expect, as the concrete type `Int64` is the native integer
    on a 64-bit machine, which is the most common architecture. The explanation is
    that a type declaration within a scope block, in this case a function definition,
    enforces an unchangeable type for the entire block. The declaration can occur
    anywhere within the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the absence of a declaration, a variable *can* change type within a block
    as a consequence of arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This function produces the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Allowing this to happen can interfere with performance, a topic we return to
    in “Vanquish Type Instability” on [page 242](ch08.xhtml#ch08lev1sec13).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `::` operator can also declare the type of the value returned by a function.
    For example, we can change the first line of the definition of `weather_report()`
    in [Listing 8-3](ch08.xhtml#ch8lis3) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This asserts that the function must return a `String` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of such declarations is the same as type declarations for variables:
    they are never required, and usually not needed, but in some cases they can provide
    extra information to the compiler that helps with performance. We’ll see some
    examples of this in “Performance Tips” on [page 242](ch08.xhtml#ch08lev4). When
    we construct expressions using functions, it’s helpful to know the types returned
    by each function call; using type declarations in function definitions assists
    in writing correct and efficient programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions and Methods: Multiple Dispatch**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we define a function in the REPL, if there are no errors, we’ll see a
    message like the one we saw after the definition of `weather_report()` in [Listing
    8-3](ch08.xhtml#ch8lis3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A generic function is defined by its name, in this case `weather_report()`.
    Each generic function can have any number of *methods* associated with it, which
    are distinguished by their method *signatures*. The signature is the part that
    goes inside the parentheses when you define the method. Up until now, these signatures
    have included the names of positional and keyword arguments and their default
    values, if any. If we make a second definition of `weather_report()` with a different
    set of arguments in its signature, we will have created a second method.
  prefs: []
  type: TYPE_NORMAL
- en: A further use of the `::` operator is within method signatures, to specify the
    types that the arguments therein are supposed to have. Two definitions, both with
    the same arguments, define different methods if any of these type specifications
    are different, even if the signatures are otherwise the same.
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler sees a function call, it invokes the method with the most
    specific definition that matches the arguments supplied in the call. Here is where
    we see the real purpose of the abstract types that we learned about in “The Type
    Hierarchy” on [page 222](ch08.xhtml#ch08lev1sec4). With all else being equal,
    a method defined using a particular type for one of its arguments is more specific
    than one defined for a supertype for the same argument.
  prefs: []
  type: TYPE_NORMAL
- en: To determine which method to call, the compiler examines *all* of the arguments.
    This procedure for method selection, or *dispatch*, is called *multiple dispatch*
    for this reason. It is an unusual, but not unique, feature in the landscape of
    programming languages, and it’s a major reason for Julia’s power and success.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, object-oriented languages dispatch solely on the first argument
    of a method, often supplied implicitly as the object the method is part of and
    represented within the procedure with variables such as `this` or `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Functional languages have no real dispatch mechanism at all. All specialization
    must take the form of alternative code paths within one large function.
  prefs: []
  type: TYPE_NORMAL
- en: Julia’s multiple dispatch paradigm means that it is neither an object-oriented
    nor a functional language, but something more general and flexible than either
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Multiple Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our definition of `weather_report()` included a check that the supplied argument
    was the correct type and a measure to take in case it wasn’t, implemented in an
    `if` block. We can eliminate that check by restarting the REPL and replacing the
    definition of `weather_report()` with two other methods with different signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After the first definition, the REPL replies with the same message as before,
    but after the second, we are informed that `weather_report()` now has two methods.
    The only difference between our two methods is that the first has a type specification
    for the single argument, `raining`, in its signature, whereas the second does
    not. The absence of a type specification means that the compiler will accept an
    argument with any type, or, said another way, with the `Any` type. The rule is
    that the compiler will always select the most specific method for the arguments
    supplied. If we supply a `Bool` (`true` or `false`), the first method is selected,
    because it’s more specific than the second, as `Bool` is a subtype of `Any`. Any
    other type dispatches the second method, and the request to supply `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify that the two methods work the way we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This technique of creating a collection of methods rather than cramming a bunch
    of type-checking code into one larger function is more idiomatic to Julia and
    leads to better-organized projects that are easier to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wanted to extend the function by giving it the ability to comment
    on the weather in a city supplied by the user. The power of multiple dispatch
    allows us to simply add another method without changing anything we’ve already
    written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to call `weather_report()` with arguments that don’t match the signature
    of any existing method, we get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message tells us that none of the methods of `weather_report()` have
    the right signature and lists some of the available methods, showing the types
    we can use for their arguments. We’ll get a similar error if we, for instance,
    try to add two things that can’t be added, such as `1 + "1"`, but the three or
    so possible methods mentioned in the error message will be a small fraction of
    the over 200 methods defined for the `+` operator. To see a list of all the methods
    defined for any function, call `methods()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here we see the list of methods we’ve defined for `weather_report()` with their
    method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extending Built-in Functions with New Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we had a program that reads numbers from a file, or from user input,
    and adds them to an existing number. The read-in values would be strings, and
    the program would have to convert them to numbers before performing the addition.
    [Listing 8-4](ch08.xhtml#ch8lis4) shows a case like this, where we might decide
    to eliminate the explicit conversion step from the program by adding a method
    to `+` that does the conversion automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Extending addition with a new method*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not allowed to extend certain basic functions, such as `+`, unless we
    first explicitly import them, which is accomplished in the first line. After defining
    this method, it will be dispatched on any attempt to add a string to a number,
    something that normally results in a `MethodError`. If the `String` argument can
    be parsed as a `Number`, that number is added to the first argument and the method
    returns the result. If it can’t, the method simply returns the first argument.
    This method definition is an example of the use of abstract types in signatures.
    It will work for any type of number in the first argument, without the need to
    write definitions for each subtype of `Number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check that this method works as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added to the language by extending the behavior of one of its basic operators.
    Multiple dispatch gives us the power to do this without altering any existing
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**DON’T BE A PIRATE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We would never place methods such as the one defined in [Listing 8-4](ch08.xhtml#ch8lis4)
    in a public package. That’s because we are responsible neither for the “+” function
    nor the data types in our new method definition. Someone importing our package
    may suffer conflicts or unexpected behavior. With the great power to extend the
    language comes great responsibility: transgressing this expectation is called
    *type piracy*. If we want to make our method public, we have three choices: name
    it something besides “+”; have it operate on our own string-like data type; or
    make a pull request on GitHub for inclusion in `Base`. The last option will endow
    “+” with a new method in addition to its current paltry 207, and all Julia users
    will automatically have the benefit of our creation.'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized methods are not only useful for creating new behaviors, they’re
    sometimes created for efficiency. For example, operations such as matrix multiplication
    or matrix inverse produce mathematically well-defined results (when they exist);
    however, for matrices with certain properties, specialized algorithms for computing
    that result may be more efficient than a general algorithm. The `SparseArrays`
    package (see “The Adjacency Matrix” on [page 196](ch07.xhtml#ch07lev1sec1)) provides
    methods for these matrix operations that are more efficient when one or both of
    the arguments is a sparse array. Multiple dispatch will automatically select the
    ideal method when a matrix operator is passed a sparse array, without any intervention
    needed on the part of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can create new methods to do anything we want, it makes sense that
    their behavior be conceptually related to the purpose or meaning of the generic
    function that they are a part of. Each of the over 200 methods for `+` has something
    to do with the idea of addition, as does the new method that we’ve defined here.
    Multiple dispatch should be seen as a paradigm for code organization rather than
    a license for chaos. The language does nothing to enforce this principle, which
    depends on the discipline of the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding Union Types and the <: Operator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, when constructing a method, a single abstract type is not general
    enough for our purposes. In such cases, we can declare an argument to have any
    one of several types using `Union{}`. This is an operator that accepts a list
    of types and constructs a new type that includes all of them. A value that has
    the type of anything in the list belongs to the new union type. Also, a type that
    is a subtype of any of the types in the list is a subtype of the union.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<:` infix operator is a test that acts on types and returns `true` if
    the type on its left is a subtype of the type on its right. This example illustrates
    the creation of a union type and the use of the `<:` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Because `17` is a `Number`, the first expression returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to write a function that acts on real numbers other than integers:
    numbers with a decimal point. We might consider using a type declaration in the
    function signature such as `n::AbstractFloat`, which would include all the concrete
    floating types, such as `Float64` and `Float32`. However, examining [Figure 8-2](ch08.xhtml#ch8fig2)
    reminds us that this declaration would exclude any number supplied as an `Irrational`.
    If the user stuck in a literal π as an argument, a `MethodError` would be the
    result. We can use a union type to handle this scenario: `n::Union{AbstractFloat,
    Irrational}`. We might also consider adding `Rational` to the union, depending
    on the purpose of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Defined Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as we can create our own verbs (functions and methods) for our own purposes,
    we can create our own nouns (data types) as well. The purpose of user-defined
    types in Julia is the same as the main purpose of types in general: to organize
    projects around methods that can be dispatched based on the types of their arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Abstract Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, rather than simply adding a leaf to the tree of types we will want
    to add a branch and then create types as leaves attached to that branch. As we
    mentioned earlier, these branches are *abstract* types, and we can make our own
    with the `abstract type` declaration. As an example of its use, here is how to
    create a new abstract type descended from the `Number` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: After executing this statement, the new type `MyNumber` will be a subtype of
    the existing abstract type `Number` (recall that concrete types cannot be subtyped).
  prefs: []
  type: TYPE_NORMAL
- en: If the new type is something really new that won’t share methods with existing
    types, there’s no need for it to inherit from any existing type. However, if it
    is a new type of number, string, or other existing type, it makes sense to place
    it appropriately in the type hierarchy. This way, existing methods that act on
    the `Number` type, for example, will be able to handle the new subtype of number.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Composite Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The purpose of creating a new abstract type is to be able to define new types
    as its subtypes, types that actually hold values and that we manipulate in calculations.
    These new types can either descend directly from `Any` or descend from an abstract
    type that we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'In almost all cases, these new types will be *composite types*, defined in
    a `struct` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Composite types typically have several fields (but may have only one). The new
    `EarthLocation` type is intended to represent a location on Earth by its latitude
    and longitude and includes a field for the location’s time zone. The type declarations
    on the fields are optional; a field without a declaration will be of the `Any`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following creates a variable with this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This function, created by Julia using the same name as the type, is called a
    *constructor*. As the second interaction shows, it creates values with the `EarthLocation`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access a composite type’s field values using property notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The fields are assigned in the order in which they appear in the type’s definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a constructor is a function, we can define multiple methods for it. Here
    is one that handles the case where the caller supplies coordinates but no time
    zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The method dispatched when the caller uses only two arguments calls the original
    method with `"Unknown"` as the time zone. This method could have done anything,
    but naming it the same as the constructor for `EarthLocation` types and having
    it return something other than an instance of that type would be confusing. As
    mentioned in “Parametric Types” on [page 248](ch08.xhtml#ch08lev6), we should
    exploit the type system and multiple dispatch to make our code easier to understand,
    rather than the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we decide to use a different convention for recording time zones, and
    try to make some changes to existing variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia objects to what seems like a reasonable attempt to assign a new value
    to one of the fields of `NYC`. By default, composite types are immutable, which
    permits the compiler to generate more efficient code in some circumstances. If
    a program requires types whose field values can be changed, we need to explicitly
    define our type using the `mutable` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, we can alter variables with the `MutableEarthLocation`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can change the values of fields of mutable composite types at will. However,
    when this isn’t necessary, such as when the type represents a permanent object
    that should not be mutated, it’s generally better to define it without the `mutable`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Composite Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s explore a simple example that shows the usefulness of creating our own
    types, along with methods designed to operate on them. The idea is to define a
    couple of types representing circles. They’ll be somewhat different from each
    other, but since they both represent circles, they will have some commonality.
    We plan to write some methods that are specialized to our two circle types, and
    at least one that should be applicable to both (or more, if we extend the project
    in the future). This situation calls for the creation of an abstract type to represent
    circles in general, from which we’ll derive each composite circle type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we’re not concerned *where* a circle is, we can define it completely by
    its radius. With this in mind, let’s define our first composite circle type to
    have only one field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `r` represents the circle’s radius, which can be any `Real` number. The
    type `FloatingCircle` is a subtype of our abstract `Circle` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next circle type also contains information about the shape’s position in
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, `PositionedCircle` is also defined as a subtype of `Circle`. The
    real numbers `x` and `y` are intended to hold the coordinates of its center. The
    abstract `Circle` type now has two subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: What we have so far might be the beginnings of a package to perform some geometrical
    calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the next step is to write a function that calculates the area of a
    circle. This area doesn’t depend on where the circle happens to be, only on its
    radius. Therefore, it should accept either subtype of the abstract `Circle` type
    and any future subtype that we might come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `circle_area()` function’s signature demands that the type of its argument
    is a subtype of `Circle`. If it is, it will have a radius, which, by convention,
    we call `r` in all of our circular composite types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: After confirming that the new function calculates areas correctly for both `FloatingCircle`s
    ➊ and `PositionedCircle`s ➋, we forget that `circle_area()` deals only with subtypes
    of `Circle` and try to hand it a number, which results in a `MethodError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add one more function to this geometry project: a routine that takes
    two circles and tells us if the second circle is entirely within the first.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The function calculates the distance between the centers of the two circles
    using their x- and y-coordinates, and then checks whether one lies inside the
    other by referring to their radii. Of course, the concept of a circle being “inside”
    another makes sense only if we can say where the circles are, so the new function
    accepts only `PositionedCircle`s and will have only one method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems to be working, but to be sure, it will help to make a diagram. We
    can draw our three circles using `Luxor` in a program similar to the one in [Listing
    7-1](ch07.xhtml#ch7lis1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `Luxor` package uses points as its unit of length, so we expand our dimensions
    ➊ to make a reasonably sized illustration. The labels on the circles are the same
    as the names we gave them before. [Figure 8-3](ch08.xhtml#ch8fig3) shows the diagram
    that this program creates, where we can see that the `is_inside()` function calculates
    the “inside” relationship correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Circle b is inside a, but c is not.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know how to enforce types used in constructors for user-defined types. But
    what if we want to constrain the allowed values passed to the constructors? Here’s
    how to make a type like our `FloatingCircle` that demands a positive radius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As with functions, constraints on the values passed as arguments must be enforced
    in the body. The method inside the body ➊ is called an *inner constructor*; the
    other constructors we’ve been using up to now are *outer constructors*. The function
    `new()` creates the instance. It’s used only inside inner constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those who have experience with a class-based object-oriented language, such
    as Python, are sometimes at a temporary disadvantage when trying to absorb the
    concept of a user-defined composite type in Julia. We all have a tendency, when
    confronting a new concept, to relate it to concepts that are familiar to us. Composite
    types in Julia are not classes; Julia has no classes and, obviously, no class
    inheritance. In an object-oriented language, the next step would be to define
    methods as part of the class: the nouns and verbs are bound together. The more
    flexible multiple dispatch paradigm decouples nouns and verbs. Julia programmers
    are free to write methods that act upon any combination of types and to create
    new types at will, without friction.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining structs with Base.@kwdef***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The default method for defining composite types leaves a bit to be desired.
    Its main deficiency is that the constructor it creates requires the programmer
    to remember the order in which a type’s fields appear in its definition. The `Base.@kwdef`
    macro improves on this limitation by creating constructors that we can use with
    field names. For repeated use, it’s convenient to import this macro and rename
    it: `import Base.@kwdef as @kwdef`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s expand our geometry package with a new type representing ellipses as shown
    in [Listing 8-5](ch08.xhtml#ch8lis5). This time we’ll use `@kwdef`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Defining an* Ellipse *type with* @kwdef'
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition shows the second convenient feature of `@kwdef`: we can supply
    default values for fields. We also have the option to define a mutable struct
    with `@kwdef mutable struct`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make an ellipse and assign it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows how we can supply a subset of the type’s keyword arguments,
    and the ones we omit will get their default arguments. As with functions, any
    keyword argument without a default in the type definition must be supplied when
    using the constructor. Also, similarly to functions, we may not mix positional
    and keyword forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As there is no drawback to using `@kwdef` when defining composite types, it’s
    convenient to use it routinely.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way Julia’s JIT compiler works with the type system, computing
    with user-defined types is as fast as using native types. We can work at a higher
    level of abstraction, creating a set of types that naturally conform to the objects
    in our problem, without any compromise in performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance Tips**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speed and efficiency are often of great concern in scientific programming. While
    Julia generally produces performant code without requiring extreme expertise or
    knowledge of internals, good performance does sometimes depend on an awareness
    of the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included topics related to performance in various places throughout this
    book. Here we’ll learn about several such issues specifically related to types.
  prefs: []
  type: TYPE_NORMAL
- en: '***Vanquish Type Instability***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Type stability* is perhaps the single most important performance-related concept
    in Julia. Its central principle is that the return values of functions should
    have types we can predict based on the types of the arguments supplied to the
    function. The returned type should not depend on the *values* of the arguments.
    A secondary issue is that the local variables used within a function should not
    change type.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to have a function for dividing two numbers that would return
    `0` when the denominator is `0`, rather than `Inf`. [Listing 8-6](ch08.xhtml#ch8lis6)
    shows one way to write such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: This function needs improving.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It certainly seems to work as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the sharp-eyed programmer may notice that in the first case, the function
    returns a `Float64`, whereas in the second case it returns an `Int64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The types of the arguments in both cases are integers, but the types of the
    results depend on their values. This type instability may not matter. However,
    an insidious problem is lurking, as one day we may pull out our `safe_divide()`
    function to use within some other program where its varying return type affects
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more complicated functions, the type instability may not be so obvious.
    In situations where performance or memory consumption makes us wonder whether
    one of our functions may have such an issue, Julia provides a convenient tool
    for ferreting out type instability: the `@code_warntype` macro. Let’s use it on
    our `safe_divide()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one of several macros and functions available for use in the REPL that
    display a translated version of a Julia function. The `@code_warntype` macro prints
    a *lowered form* of the code: a representation of the computation in terms of
    a smaller set of operations. It is one of four stages of code transformation beginning
    with our Julia source and ending with machine code specific to the processor we’re
    running on. This lowered form is similar to the version that is sent to the compiler,
    but it contains the type information that we can examine when debugging performance
    issues. Other than that, it’s not particularly useful and not intended for routine
    human consumption.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When printed in the REPL, type information that indicates a possible type stability
    issue is displayed in red type, which I’ve converted to bold for printing in the
    book. The bold fragment indicates that the return type can be either a `Float64`
    or an `Int64`: in other words, it’s not determined from the types of the input
    arguments. This is the signature of a type-unstable function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this case has a simple fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Since `a/b` is always a float, even if `a` and `b` are integers, we can ensure
    that the function always returns a float by replacing the integer `0` with `0.0`
    ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm whether we’ve fixed the type instability problem, let’s turn to
    `@code_warntype` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This time, there are no red (bold) warnings, and the macro confirms ➊ that the
    return type is always a `Float64`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The output from* @code_warntype *often also includes yellow warnings involving
    unions with the* Nothing *type, which is used when a function does not return
    a result. These are not usually considered type instabilities.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also correct this type stability problem by defining the function using
    a type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This version, when called with `b = 0`, will convert its return value to `0.0`.
    It will always return a `Float64`; `@code_warntype` will verify its type stability.
  prefs: []
  type: TYPE_NORMAL
- en: Although the form of the code returned by `@code_warntype` can be difficult
    to parse, it’s fairly simple to use it to scan for type stability problems.
  prefs: []
  type: TYPE_NORMAL
- en: '***Avoid Changing the Types of Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function to approximate π using the Leibniz sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/math245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is not a good way to get the digits of π, as it converges quite slowly,
    but it’ll be useful for our demonstration. One version of the function might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This works as intended; [Figure 8-4](ch08.xhtml#ch8fig4) shows its output gradually
    converging to the correct value for π.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: The Leibniz sum approximation to π*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is clearly not type-unstable in the sense used earlier: the output
    is always a `Float64`, regardless of the number supplied as an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, taking a look at the output of `@code_warntype` indicates a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the warnings are rendered in bold. They inform us that the local
    variable `s` is a union of the types `Float64` and `Int64`, rather than a single
    numerical type. This happens because we initialize it as a literal integer, `0`,
    but then use it in a loop that causes Julia to promote it to a float.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the type of a local variable may prevent the compiler from optimizing
    our code as well as it could otherwise. This is a common mistake, as the pattern
    of initializing variables and then using them in a `for` loop is routine. When
    doing so, we should take care to initialize them with types appropriate to the
    arithmetic in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This case is also easy to fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As before, we simply have to replace `0` with `0.0` ➊. I won’t reproduce the
    (mostly redundant) output here, but checking with `@code_warntype` shows that
    the warnings are gone.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Aliases**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several types have alternative names, called *type aliases*. The use of aliases
    is for convenience; they are typically shorter names or dispense with the indication
    of the machine’s pointer size. For example, on a 64-bit computer, `Int` is another
    name, or alias, for `Int64`, but on a 32-bit machine, `Int` means `Int32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This shows that, at least on my computer, `Int` is another name for `Int64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own type aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve created an alternative name for the default floating-point type.
    After this definition, we can use `F64` and `Float64` interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Defining type aliases as `const` is not required, but it makes sense, as they
    are additional names for something that will not change.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parametric Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A parametric type is a type made from pieces that themselves can be of several
    possible types. The parameters are variables that vary with the types of the pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-7](ch08.xhtml#ch8lis7) shows an example of a parametric type that
    we’ve already encountered, the type used for complex numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: The types of some complex numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: The curly brackets (`{}`) in the type names indicate that we’re dealing with
    *parametric types*. In the first line, we’ve asked for the type of a complex number
    that’s written using integer literals for each coefficient. The response indicates
    that the number is `Complex` with an `Int64` parameter; this parameter is the
    type of the coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: The second line tells us something similar, but this time the complex number
    has floating-point coefficients. In addition, we learn about an alias for the
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that there is only one parameter within the curly brackets suggests
    that both coefficients must have the same type. This is indeed true; mixing literal
    floats and integers causes an automatic conversion of the integer coefficient
    to a `Float64` coefficient ➊.
  prefs: []
  type: TYPE_NORMAL
- en: In the final example, we’ve created a complex number with `Rational` coefficients.
    This time the parameter is itself a parametric type. Rational numbers can be composed
    of any integers. The `Rational{Int64}` notation means that the numerator and denominator
    are `Int64`s rather than, for example, `Int32`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Collection types, such as `Array`, are defined as parametric types because
    they can hold elements of various types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of aliases is common for collection types, as in these examples. We
    see here that `Array` is a parametric type with two parameters: the first is the
    type of the array’s elements, and the second is the number of dimensions.'
  prefs: []
  type: TYPE_NORMAL
- en: The `where` keyword creates a `UnionAll` type, a union of many types, each defined
    by assigning a particular type to the type variable `T`. One example of this is
    the notation `AbstractArray{T, 1}`, where `T` denotes an abstract type that is
    the union of `AbstractArray{Int64, 1}`, `AbstractArray{Float64, 1}`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own parametric types for the same reason we create any type:
    to organize our methods with the help of the type system and multiple dispatch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit our `Ellipse` type from [Listing 8-5](ch08.xhtml#ch8lis5) and
    make a parametric version of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the fields can be any type, as long as they are both the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining a new `CEllipse`, the REPL tells us the type, with `Float64`
    substituted in place of the parameter `T`. Our attempt to give the fields two
    different types failed because they are both `T` in the type definition. `T` can
    be anything, but the definition requires that both axes have the same type, so
    the final example is accepted. But what does it mean to have an ellipse with arbitrary
    strings for the axes? It’s up to us. We are creating types for our own purposes,
    to organize our projects. If we prefer to limit the `CEllipse` type to have numerical
    values for the axes, we can use the subtyping operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Before defining this struct, if we’re working in the REPL, we’re obligated to
    begin a new session if the previous definition of `CEllipse` is still active.
    Another option would be to name it differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now a `CEllipse` can have two axes of the same type, and that type can be anything,
    as long as it’s a subtype of `Number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we make `T` a subtype of `Number`, rather than a subtype of the more
    specific `Real`, we are allowing the possibility of ellipses with complex-valued
    axes. In some cases, our functions for calculating properties of ellipses will
    need methods specialized for this case. For an example, let’s write a function
    that returns the eccentricity of an ellipse. This is a measure of how elongated
    the ellipse is, where an eccentricity of 0 is a circle. If *a* is the longer of
    the two axes and *b* is the shorter, the eccentricity is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/250math.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s a direct translation of this formula into a Julia function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This definition works for real-valued axes, so to ensure that the function accepts
    only such ellipses, its type parameter specifies subtypes of `Real`.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize an ellipse with complex-valued axes as lying in the complex
    plane. We can define ellipses this way as long as we ensure that their axes are
    perpendicular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a method of our eccentricity function that handles these ellipses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `abs()` function, when handed a complex number, returns its length. We use
    the `<:` operator in the type parameter slot to include every possible kind of
    complex number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know a bit more about ellipses with complex axes: not merely their eccentricities,
    but their orientations. [Figure 8-5](ch08.xhtml#ch8fig5) shows an ellipse in the
    complex plane.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: An ellipse in the complex plane*'
  prefs: []
  type: TYPE_NORMAL
- en: Its axes, represented by dotted lines, are 2 + 2*i* and *−*1 + *i*. We’ll define
    the orientation as the angle that its major (longer) axis makes with the real
    axis, shown in the figure by *α*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the program that created the illustration in [Figure 8-5](ch08.xhtml#ch8fig5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Remember, in `Luxor` the vertical coordinate goes from the top down, opposite
    to the conventional direction in mathematical diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function calculates the orientation of an ellipse with complex axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Since no orientation can be defined for an ellipse with axes given only by real-number
    lengths, `orientation()` will have just this one method. The `angle()` function
    returns a complex number’s phase angle; it’s equivalent to `atan(imag(a)/real(a))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define an ellipse with complex axes and calculate its eccentricity and
    orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This ellipse corresponds to [Figure 8-5](ch08.xhtml#ch8fig5). The `orientation()`
    function returns its result in radians, so for good measure, we’ve converted that
    to degrees in the final expression.
  prefs: []
  type: TYPE_NORMAL
- en: Parametric types make Julia’s rich type system even more flexible and expressive.
    Like the other parts of the type system, we’re not required to use any of it in
    our own programs, but a little bit can go a long way in helping with code organization,
    reuse, and efficiency. Finally, a basic knowledge of parametric types is essential
    in understanding the messages and information that Julia sends to us, and in reading
    language and package documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plot Recipes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As authors of programs, modules, and perhaps packages, we should expect to create
    our own data types routinely. There is no performance penalty for using custom
    data types in Julia, and they are essential for writing concise, well-organized
    code and for taking the best advantage of multiple dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part II](part2.xhtml) of this book we’ll explore various packages from the
    Julia scientific ecosystem. Many of these packages define one or a variety of
    data types that describe the objects they manipulate. These objects include audio
    signals, solutions to differential equations, images, measurements with uncertainties,
    entire environments housing interacting creatures, the creatures themselves, and
    much more. We’ll discover that we can use the plotting commands from [Chapter
    4](ch04.xhtml) to visualize these data structures directly, with no preprocessing
    needed on our part. How is it possible that `Plots` knows what to do with all
    these different data types?
  prefs: []
  type: TYPE_NORMAL
- en: Visualization is an essential part of scientific computation. The plot *recipe*
    system is how we hook our data types into Julia’s plotting system, that is, how
    we teach it to handle and display our custom objects. The authors of the scientific
    packages that we use in [Part II](part2.xhtml) did not have to touch the code
    in the `Plots` package, which in turn doesn’t need to know anything about the
    new data types. Plot recipes insert data transformations into the plotting *pipeline*,
    so existing plotting functions can handle our data types as if they were the familiar
    arrays of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that users of our programs need simply call `plot()`, `scatter()`,
    or another plotting function on the new data type to get a reasonable visual representation.
    We can also define entirely new plotting functions for more elaborate visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a specific application in mind to make the operation of plot recipes
    clear. Let’s imagine that we’re creating a program that has something to do with
    the weather, and create some simple data types for representing daily temperature
    and rainfall data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Our temperature data, we’ll suppose, comes to us as two measurements per day,
    representing that day’s minimum and maximum temperatures. We’ll store these measurements
    in a vector of tuples ➊, one tuple per day, containing the temperature extrema.
    That vector of tuples, along with a string holding the temperature unit, are packaged
    together in the TempExtremes data type.
  prefs: []
  type: TYPE_NORMAL
- en: That data type is put next to a vector of rainfall measurements in another data
    type called `WeatherData`.
  prefs: []
  type: TYPE_NORMAL
- en: A third data type, `WeatherReport`, contains the `WeatherData` along with some
    notes, a pair of numbers (latitude and longitude) for the location of the measurements,
    and the date recording when the series of measurements begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we make instances of these three data types to have something to plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `randn()` function produces normally distributed (see “The Normal Distribution”
    on [page 323](ch10.xhtml#ch10lev1sec3)) fake random temperature and rain data.
    Earlier we imported the `Date` module so we can use one of its data types to define
    a starting date.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Plotting Pipeline***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The recipe system consists of a series of four recipe varieties that get processed
    in order in the plotting pipeline, as shown in [Listing 8-8](ch08.xhtml#ch8lis8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: The plotting pipeline*'
  prefs: []
  type: TYPE_NORMAL
- en: Each recipe type transforms its input and passes it to the next stage in the
    pipeline; these transformations are indicated after the recipe names. The built-in
    plotting functions generally know how to plot arrays of numbers, so the plotting
    recipes have to transform our custom types into ordinary arrays. The first two
    recipe types, user recipes and type recipes, can do this. The final two recipe
    types take numerical arrays and produce *series*, which are the components of
    plots that represent individual vectors, which may be extracted from matrix columns
    (in one dimension).
  prefs: []
  type: TYPE_NORMAL
- en: The user and plot recipes can also create layouts and set overall plot properties.
    We don’t need to define every one of these recipes, and generally won’t require
    all of them for any particular plotting task. Any that we *have* defined we can
    use separately, or as part of the pipeline, for different purposes. In this discussion,
    we’ll start at the end of the pipeline and work our way toward the beginning,
    defining recipes as we go. In this way, each example recipe will do something
    when we call it directly, passing information along to the previously defined
    recipes to produce a plot.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Series Recipe***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define recipes with the `@recipe` macro, exported by the `RecipesBase` package.
    The macro decorates a function definition where the name of the function is arbitrary.
    The function’s signature determines the type of recipe created. In the following
    listing, we create two series recipes. The signature, a type followed by three
    additional positional arguments `x`, `y`, and `z`, tells the pipeline that these
    are series recipes. As always, the keyword arguments are not part of the function
    signature for dispatch. Referring to [Listing 8-8](ch08.xhtml#ch8lis8), we see
    that these recipes will accept numerical arrays and create series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: To define recipes, we need only import `RecipesBase`. This is important because
    it means that packages can define plotting behaviors without a dependence on the
    large `Plots` package. `RecipesBase` is tiny, containing only about 400 lines
    of Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Plot recipes defined using the `@recipe` macro use several special-purpose syntax
    conveniences. The `:=` operator ➊ makes a setting in the `plotattributes` dictionary,
    which holds attributes such as line color—all the options for the plot. Here we
    set the `seriestype` in the attribute dictionary to `:line`. This is the default
    series type, which creates a continuous line through the plotted points. Another
    option is `:scatter`, for plotting individual marks. In fact, the familiar `scatter()`
    function is a shorthand for `plot(; seriestype=:scatter)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-->` operator ➌ also makes settings in the `plotattributes` dictionary,
    but, in this case, defers to settings made in keyword arguments previously in
    the pipeline. In a sense, these are optional, whereas settings we make with `:=`
    are important for the series under construction.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have a `for` loop that divides the input `y` vector into segments of
    `cycle` elements and calculates extrema and an average for each segment. It inserts
    `NaN`s after each segment to separate them in the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Next come three blocks preceded by the `@series` macro ➋. Each `@series` block
    creates a new series for the plot. In this case, each will be a `:line` series,
    since we make that setting outside the blocks, but in general, they can be of
    different types. They can also create a series type unknown to `Plots`, in which
    case the pipeline will pass the data on to the recipe where the new series is
    defined. There can be a chain of series recipes of any length. The data will pass
    through each in turn until a recipe creates a series type known to the backend
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe is designed to accept an *N*×2 matrix. It will plot each of
    the two columns as lines, the first in blue and the second in red. It will fill
    the space between the two lines using the `fillrange` attribute. This presents
    a small problem, as we need to refer to the first column to define the `fillrange`
    when plotting the second, but the pipeline starts afresh for each column in the
    input data. However, we know which column we’re on by referring to the `:series_plotindex`
    key in the attribute dictionary. One way to pass information between different
    columns is to stuff it into the `:extra_kwargs` entry in the attribute dictionary
    ➍. We call our new attribute `:nextfr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we have in mind the weather data types defined previously, these recipes
    don’t know anything about that. Like all series recipes, they can plot any arrays
    of numbers. For actual plotting, we need to import `Plots`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `@shorthands` macro, provided by `RecipesBase`, takes the names in the function
    signatures of recipes and makes function names that we can call directly to make
    plots. For each one, it makes two functions, one for creating a new plot and one
    for adding to an existing plot, just like `plot()` and `plot!()`.
  prefs: []
  type: TYPE_NORMAL
- en: After transforming the temperature data in `wd` to a matrix, we can use the
    shorthand on it directly, creating [Figure 8-6](ch08.xhtml#ch8fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: A* fillrange *plot created by a series recipe*'
  prefs: []
  type: TYPE_NORMAL
- en: For [Figure 8-7](ch08.xhtml#ch8fig7), we call `ebxbox()` on the rainfall vector.
    It only plots the extrema and mean bars, so we add a normal plot of the vector
    using `plot!()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: A plot using the* ebxbox *series recipe*'
  prefs: []
  type: TYPE_NORMAL
- en: We can use these series recipes in other programs and as components within other
    pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Plot Recipe***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type of recipe called a *plot recipe* (not to be confused with the general
    concept) also transforms series into other series or numerical data into series,
    as do series recipes, but can create complete visualizations containing subplots
    and other elements as well. Like all recipes, it’s identified by its particular
    function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The recipe takes input data in the form of an *N*×3 matrix. It uses a `frames`
    attribute, which we invented for the purpose, to decide whether to place all the
    series in one plot or to use two subplots ➋, one with temperature and the other
    with rainfall. (As in the case of the series recipes, this recipe knows nothing
    of our weather-related data types, so we can repurpose it to plot other types
    of data as well.)
  prefs: []
  type: TYPE_NORMAL
- en: The `cycle` variable sets the length of the segments used for calculating extrema
    and averages in the third column of the input data, which we intend to use for
    the rainfall data. We use 7 as a default value for this keyword argument, for
    weekly summaries. If, however, we supply the parameter when calling the recipe
    directly or upstream in the pipeline, we override the default by reading its value
    from the `plotattributes` dictionary ➊.
  prefs: []
  type: TYPE_NORMAL
- en: The three `@series` blocks handle the first two columns, containing temperature
    minimums and maximums, and the rainfall in the third column. The temperature `@series`
    block sets the series type to `temprange` ➌, which won’t work unless we’ve already
    defined a series recipe for it, as we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe, then, is to use the visualizations defined in our
    series recipes to create a graph with either one or two subplots, with labels
    appropriate for either case. We can also call it directly, as shown in [Listing
    8-9](ch08.xhtml#ch8lis9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: Calling the plot recipe with array data*'
  prefs: []
  type: TYPE_NORMAL
- en: But we’ll defer this for now.
  prefs: []
  type: TYPE_NORMAL
- en: '***Type Recipes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Referring back to [Listing 8-8](ch08.xhtml#ch8lis8), we can see that *type
    recipes* are the first recipes in the pipeline that can accept user-defined types.
    They’re the simplest class of recipe. They have one job: to transform user types
    into numerical arrays that the functions from `Plots` can plot directly, or that
    can be fed into the following steps in the pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing defines two type recipes; they’re recognized as such
    by their particular function signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The first recipe takes instances of the `*TempExtremes*` type defined previously
    and returns a matrix with two columns; the second transforms `WeatherData` into
    a three-column matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining these recipes, we can now plot either of these types directly
    by calling `plot(td)` or `plot(wd)`. If we do so, we’ll get simple line plots
    of the columns: two from the first call and three from the second, as in [Figure
    8-8](ch08.xhtml#ch8fig8).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: Plotting directly from a type recipe*'
  prefs: []
  type: TYPE_NORMAL
- en: We call `plot(wd)` to produce [Figure 8-8](ch08.xhtml#ch8fig8). The top two
    lines are the temperature extrema and the bottom line is the rainfall.
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, we call `weatherplot(wd)`, we get the exact same plot that would
    result from the call in [Listing 8-9](ch08.xhtml#ch8lis9) because the type recipe
    transforms `wd` into a three-column matrix. [Figure 8-9](ch08.xhtml#ch8fig9) shows
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: A plot recipe called on user data transformed by a type recipe*'
  prefs: []
  type: TYPE_NORMAL
- en: Here the plot recipe assembles the two types of visualizations, defined in series
    recipes, onto a single plot, and adds a label on the vertical axis. Since we don’t
    define `frames`, we get the default single frame.
  prefs: []
  type: TYPE_NORMAL
- en: '***User Recipes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ve ascended to the top of the pipeline. The *user recipes* accept not
    only single user types, but any combination of types, with each different signature
    creating a new method for dispatch. They can emit array data or other types, but
    if they emit types other than array data we must have defined a type recipe to
    transform them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such is the case with the following user recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The pipeline will see this as a user recipe because of its signature. It takes
    an instance of the `WeatherReport` data type, creates a title from its `notes`
    field, and constructs a useful label for the x-axis by referring to the `start`
    field. It has a single `@series` block, to which it passes the `data` field. The
    series invoked is the plot recipe `weatherplot`, but the `data` field is not an
    array, it’s `WeatherData`. The next step in the pipeline, the type recipes, handles
    any type conversions. Here the `WeatherData` instance is transformed into a three-column
    matrix that is handed off to the `weatherplot` recipe, which optionally sets up
    the subplots and passes the matrix columns to the series recipes. Calling `plot(wr;
    frames=2)` invokes this recipe and creates [Figure 8-10](ch08.xhtml#ch8fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: The result of calling the user recipe*'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user recipe teaches the `plot()` function how to handle a new data
    type. As we’ve seen throughout this section, we can enter the plotting pipeline
    at any point for a different result, or reuse any of these recipes as part of
    different pipelines for handling different types of data.
  prefs: []
  type: TYPE_NORMAL
- en: '***The @userplot Macro***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `RecipesBase` package also exports the `@userplot` macro, which is convenient
    for defining a visualization without having to define a new data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The first line after the import creates a new type and a shorthand using its
    lowercase name. The user recipe that we define using the name of the type is invoked
    using the shorthand name. Inside the recipe, we can access plot data using the
    `args` property ➊. The `@userplot` is useful when we want a shorthand name for
    a particular visualization for an existing type. In this case, we want to plot
    complex numbers by separating their real and imaginary parts, which may be more
    useful than the default treatment given them by `plot()`. After defining the recipe,
    we can invoke it directly using its name as in the last line. The `expint()` function
    is an exponential integral from the `SpecialFunctions` package, parameterized
    by its first argument. With the parameter here, it maps real numbers to complex
    numbers. The result appears in [Figure 8-11](ch08.xhtml#ch8fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: Using @userplot to render a vector of complex numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `@userplot` macro to create alternative visualizations for
    user-defined types by using type aliases or subtyping.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this survey of the most important practical aspects of the type system,
    our introduction to the Julia language is complete. The ideas in this chapter
    and the preceding ones will find concrete application in the chapters of [Part
    II](part2.xhtml), where we’ll put Julia to work to solve real problems in a variety
    of fields.
  prefs: []
  type: TYPE_NORMAL
- en: This book’s division into language learning and application sections isn’t a
    strict one, however. We’ve seen several useful applications in the preceding chapters,
    and the chapters in [Part II](part2.xhtml) will introduce various programming
    techniques and Julia features in places where they can be immediately applied
    and more readily appreciated in the context of solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: Details on performance implications of one form of type instability are available
    at [*https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable*](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dr. Chris Rackauckas gives an example of when dynamic dispatch is a net win
    here: [*https://discourse.julialang.org/t/why-type-instability/4013/8*](https://discourse.julialang.org/t/why-type-instability/4013/8).
    This is a case where type instability is beneficial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interesting information about π in Julia is available at [*https://julialang.org/blog/2017/03/piday/*](https://julialang.org/blog/2017/03/piday/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My attempt to explain multiple dispatch using an extended recipe analogy is
    available at [*https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/*](https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a detailed tutorial about optimization and the type system, visit [*https://huijzer.xyz/posts/inference/*](https://huijzer.xyz/posts/inference/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a package for nice visualization of type hierarchies: [*https://github.com/claytonpbarrows/D3TypeTrees.jl*](https://github.com/claytonpbarrows/D3TypeTrees.jl).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another approach to finding and fixing type instabilities is offered by the
    `Cthulhu` package: [*https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/*](https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
