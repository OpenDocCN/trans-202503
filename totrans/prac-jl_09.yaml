- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: THE TYPE SYSTEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统**
- en: '*Object-oriented programming is an exceptionally bad idea which could only
    have originated in California.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程是一个极其糟糕的想法，只有在加利福尼亚才能诞生。**'
- en: —Edsger Dijkstra
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —埃兹格·迪克斯特拉
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Up to now we’ve been using and creating a lot of functions. We can think of
    functions as the verbs of the Julia language. And just as in natural languages,
    verbs act on nouns. The nouns in Julia are numbers, collections, strings, and
    other instances of types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用并创建了很多函数。我们可以将函数看作是 Julia 语言中的动词。正如在自然语言中，动词作用于名词一样，Julia 中的名词包括数字、集合、字符串以及其他类型的实例。
- en: 'We’ve encountered many data types in our journey up to this point: different
    varieties of numbers, strings, characters, and collections such as arrays and
    maps. Although our focus hasn’t been on types, it’s impossible to talk much about
    Julia programming without making some reference to them. Julia is unusual in that
    it allows us to create very fast code without having to specify the types of variables,
    unlike other fast languages such as Fortran (where the specifications can be implicit)
    and C. However, effective Julia programming requires some knowledge of its type
    system. The main reason for this is that Julia programs are organized around functions
    and methods through its dispatch system, which relies on argument types. A secondary
    reason has to do with those occasions where an awareness of types allows us to
    write more efficient programs. This chapter covers both of these concerns.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在学习过程中遇到了许多数据类型：不同种类的数字、字符串、字符，以及像数组和映射这样的集合。尽管我们的重点并不是类型，但在谈论 Julia
    编程时，无法不提及它们。Julia 的特别之处在于，它允许我们在不指定变量类型的情况下创建非常快速的代码，这与其他快速语言（如 Fortran（其中类型规格可以是隐式的）和
    C）不同。然而，要有效地编写 Julia 程序，还是需要了解它的类型系统。这样做的主要原因是，Julia 程序是围绕函数和方法组织的，依赖于其分发系统，而该系统依赖于参数类型。其次，了解类型有助于我们编写更高效的程序。本章将涵盖这两个方面的问题。
- en: '**Types in Practice**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践中的类型**'
- en: Rather than delve into the abstract theory of type systems, let’s approach types
    from a practical point of view.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与其深入探讨类型系统的抽象理论，不如从实际的角度来看待类型。
- en: 'To find the type of any value, Julia provides the `typeof()` function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出任何值的类型，Julia 提供了 `typeof()` 函数：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve already considered the difference between strings and characters, and
    the related difference between single and double quotes; however, it’s important
    to have some understanding of the various numeric types. Although, for example,
    `17`, `17//1`, and `17.0` have the same values, they are different types of objects,
    and their behavior is potentially different. The difference in their types reflects
    this reality.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过字符串和字符之间的区别，以及单引号和双引号的相关区别；然而，理解各种数值类型同样很重要。例如，`17`、`17//1` 和 `17.0`
    具有相同的值，但它们是不同类型的对象，它们的行为可能不同。它们类型的差异反映了这一现实。
- en: The curly brackets used in reporting the type of a rational number ➊ indicate
    that this is a *parametric type*, a topic we’ll return to in “Parametric Types”
    on [page 248](ch08.xhtml#ch08lev6). For now, it’s sufficient to understand that
    this is a `Rational` made up of `Int64` pieces.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告有理数类型时使用的花括号 ➊ 表明这是一个 *参数化类型*，我们将在“参数化类型”一节中（[第 248 页](ch08.xhtml#ch08lev6)）回到这个话题。现在，理解这是由
    `Int64` 组成的 `Rational` 类型就足够了。
- en: 'The type reported for the floating-point literal is `Float64`, which means
    it’s a floating-point number, or a number with a decimal point, and that it’s
    stored in a 64-bit segment of memory. The 64 bits are apportioned as follows:
    1 for the sign, 11 for the exponent, and 52 for the “fraction.” The maximum absolute
    value of a `Float64` is about 10^(300), and it has 17 significant digits, or 16
    digits of precision beyond the decimal point. (This agrees with the observation
    that it takes three binary digits to represent a decimal digit.) We can see this
    using the `@printf` macro, supplied by the `Printf` package:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动小数点字面量的类型是 `Float64`，这意味着它是一个浮动小数，或者说是带有小数点的数字，并且它被存储在一个 64 位的内存段中。这 64 位被分配如下：1
    位表示符号，11 位表示指数，52 位表示“分数”。`Float64` 的最大绝对值大约是 10^(300)，并且它具有 17 位有效数字，或者说是小数点后
    16 位的精度。（这与观察结果一致，即表示一个十进制数字需要三个二进制数字。）我们可以通过 `Printf` 包提供的 `@printf` 宏来看到这一点：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This shows incorrect digits appearing if we ask for more than 16.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求超过 16 位的数字，将会显示错误的数字。
- en: 'We’ll see more incorrect digits if we use floating-point types with lower precision:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用精度较低的浮点类型，将会看到更多不正确的数字：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we used the names of the types as functions to cast their arguments to
    the named types. Without the cast, expressions like `1/3` are `Float64` by default
    on most systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将类型名称作为函数来将它们的参数转换为命名类型。如果不进行类型转换，像`1/3`这样的表达式在大多数系统上默认是`Float64`类型。
- en: The default integer type on typical systems, `Int64`, ranges between *−*2^(63)
    and 2^(63) *−* 1, with one bit used for the sign.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型系统上，默认的整数类型`Int64`的范围是*−*2^(63)到2^(63) *−* 1，其中一个位用于符号位。
- en: 'Julia supplies built-in functions for finding the maximum and minimum values
    representable with each numeric type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了内建函数，用于查找每种数值类型所能表示的最大值和最小值：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But `typemax()` and `typemin()` aren’t very helpful if we ask them about floats:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们询问浮点数，`typemax()`和`typemin()`并不太有用：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Apparently infinity is a floating-point number, and Julia has infinities for
    each size float. This is consistent: since nothing is larger than infinity, if
    `Inf16` is a `Float16` it must be the largest possible `Float16`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，无穷大是一个浮点数，而Julia为每种浮点数大小提供了无穷大。这是自洽的：因为没有什么比无穷大更大，所以如果`Inf16`是`Float16`，它必须是最大可能的`Float16`。
- en: 'Julia has another function that comes to the rescue here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Julia还有另一个函数可以在这里提供帮助：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The functions `floatmax()` and `floatmin()` return the maximum *finite* float
    and the minimum positive float of the requested type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`floatmax()`和`floatmin()`分别返回所请求类型的最大*有限*浮点数和最小正浮点数。
- en: Usually we should perform arithmetic in our programs using these *native types*,
    which are the most efficient choices. If needed, and if possible, we can use smaller
    numbers to save space—for example, `Int16`—and we can get larger integers using
    `Int128`. However, if the native types are not adequate for our purposes, it’s
    usually because we need a lot of precision—in other words, many digits—in our
    computation. This is the subject of the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该在程序中使用这些*原生类型*进行算术运算，因为它们是最有效的选择。如果需要，而且可能的话，我们可以使用更小的数字来节省空间——例如`Int16`——并且我们可以使用`Int128`来获取更大的整数。然而，如果原生类型不能满足我们的需求，通常是因为我们需要大量的精度——换句话说，很多位数字——来进行计算。这是下一节的主题。
- en: 'To check whether a particular value has a certain type, use the `isa()` function.
    We can use it as a normal function or in infix position:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查某个值是否具有特定类型，可以使用`isa()`函数。我们可以将其用作普通函数或在中缀位置使用：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function returns a Boolean value. The first two calls return `true` because
    `17` is both an `Int64` and a `Number`. The former implies the latter (see “The
    Type Hierarchy” on [page 222](ch08.xhtml#ch08lev1sec4)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个布尔值。前两个调用返回`true`，因为`17`既是`Int64`也是`Number`。前者意味着后者（参见[第222页](ch08.xhtml#ch08lev1sec4)的“类型层次结构”）。
- en: '***“Big” and Irrational Types***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***“大”与无理类型***'
- en: 'Julia makes it easy to perform *arbitrary precision arithmetic* using types
    whose precision grows as needed: where the number of digits can grow without bound.
    Arithmetic with these types is slower than normal computation with native types,
    but for some jobs it’s the only choice.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Julia使得使用精度根据需要增长的类型进行*任意精度算术运算*变得简单：这些类型的数字位数可以无限增加。使用这些类型的算术运算比使用原生类型的正常计算要慢，但对于某些任务，它是唯一的选择。
- en: '**Arbitrary Precision**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**任意精度**'
- en: 'As a simple example of where we would need arbitrary precision types, suppose
    we want to graph the factorial function. This is the function usually spelled
    with an exclamation mark:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为需要任意精度类型的一个简单示例，假设我们想要绘制阶乘函数。这就是通常用感叹号表示的函数：
- en: '![Image](../images/math217.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/math217.jpg)'
- en: 'The corresponding Julia function is `factorial(n)`. The function grows extremely
    quickly:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的Julia函数是`factorial(n)`。该函数增长得非常快：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This shows that 20 is the largest factorial that fits in an `Int64`. We can
    go up to 33! if we use `Int128`, but what if we want to go bigger?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了20是可以适应`Int64`的最大阶乘。如果我们使用`Int128`，可以达到33!，但如果我们想要更大呢？
- en: The error message provides a hint. The `big()` function converts its argument
    to a corresponding type with unlimited size and precision. For integers, this
    is called `BigInt`, and for floats it’s `BigFloat`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息提供了一个线索。`big()`函数将其参数转换为具有无限大小和精度的对应类型。对于整数，这叫做`BigInt`，而对于浮点数则是`BigFloat`。
- en: 'Let’s use `BigInt` to make a plot of the factorial function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`BigInt`来绘制阶乘函数：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we’re plotting up to 50!, which is far beyond what can fit in a native
    integer. [Figure 8-1](ch08.xhtml#ch8fig1) shows the result.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们绘制的是最大到50!，这远远超出了本地整数能表示的范围。[图8-1](ch08.xhtml#ch8fig1)展示了结果。
- en: '![Image](../images/ch08fig01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig01.jpg)'
- en: '*Figure 8-1: The factorial function calculated using BigInt*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：使用 BigInt 计算的阶乘函数*'
- en: We’ll revisit the factorial in “Factorials” on [page 312](ch10.xhtml#ch10lev1sec1),
    where it appears as the number of ways to permute *n* objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“阶乘”一节中重新讨论阶乘，参考 [第312页](ch10.xhtml#ch10lev1sec1)，其中它作为排列 *n* 个对象的方式数量出现。
- en: 'The `BigFloat` type also offers unlimited magnitude. Its default precision
    is 256, giving us about 80 significant digits. We can set the `BigFloat` precision
    to be anything we need, using the `setprecision()` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigFloat` 类型也提供无限的大小。它的默认精度是 256，约为 80 位有效数字。我们可以使用 `setprecision()` 函数将 `BigFloat`
    的精度设置为任何需要的值：'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To retrieve the precision, we have the `precision()` function, which accepts
    the type that we’re asking about:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索精度，我们可以使用 `precision()` 函数，传入我们要查询的类型：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The number of digits used for a `BigInt` grows as needed, so it doesn’t come
    with the concept of a fixed precision applicable to the floating-point numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInt` 类型的数字所使用的位数会根据需要增加，因此它没有像浮点数那样固定的精度概念。'
- en: '**Irrationals**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**无理数**'
- en: 'An unusual attribute of Julia is the existence of the *irrational type*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的一个独特属性是存在 *无理数类型*：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The number represented by the Greek letter π is printed with three dots appended
    to suggest that there is more to the story. Although it appears to be a floating-point
    number, its type is not given as `Float64`, but as something new: `Irrational`.
    That’s because in Julia, π represents *not* a floating-point number, but the *exact
    value* of the ratio of a circle’s circumference to its diameter. The three dots
    remind us that the digits presented are simply the first few in an endless, nonrepeating
    series.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 希腊字母 π 所表示的数字打印时附带三个点，提示我们这只是故事的一部分。虽然它看起来像一个浮点数，但它的类型并非 `Float64`，而是一个新的类型：`Irrational`。这是因为在
    Julia 中，π 表示的*不是*浮点数，而是圆周率与直径的比值的*精确值*。这三个点提醒我们，展示的数字仅仅是这个无限、不重复序列的前几位。
- en: 'Julia calculates and presents more digits as and when needed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 会根据需要计算并展示更多数字：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The number is not printed with trailing dots, as it’s no longer a representation
    of an exact value, but an approximation to it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该数字不会以尾部点的形式显示，因为它不再是精确值的表示，而是对精确值的近似。
- en: 'Several other irrational numbers are built into Julia; the most important of
    these for general purposes is *e*, the base of the natural logarithms. To insert
    this character, which is the Unicode codepoint 212F (Script Small E), enter \euler
    and press TAB in the REPL:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个无理数被内建到 Julia 中；其中最重要的无理数是 *e*，自然对数的底数。要插入该字符，可以输入 Unicode 码点 212F（Script
    Small E），在 REPL 中输入 \euler 并按 TAB 键：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with π, Julia displays the value of *e* with three trailing dots to indicate
    that it’s showing us a few digits of an exact value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像π一样，Julia 用三个点显示 *e* 的值，表示它正在展示一个精确值的部分数字。
- en: We can see an approximation to *e* ➊ to any desired number of digits by converting
    it to a `BigFloat`. By definition, the value of the natural logarithm of *e* is
    exactly the integer 1 ➋, but if we take the logarithms of approximations to *e*,
    we get an approximate, or floating-point, result.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 *e* 转换为 `BigFloat` 来查看它的任何所需精度的近似值 ➊。根据定义，*e* 的自然对数的值恰好是整数 1 ➋，但如果我们取
    *e* 的近似值的对数，我们将得到一个近似值，或者说是浮点数结果。
- en: '***Type Promotion***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型提升***'
- en: 'When performing arithmetic on a mixture of different numerical types, Julia
    will silently *promote* types as needed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在对不同数值类型的混合进行算术运算时，Julia 会根据需要默默地 *提升* 类型：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The addition of two integers provides no reason to leave integer land, so the
    result is also an `Int64`. But if one of the numbers is a `Float64`, the other
    is promoted to that type, which is also the type of the result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 两个整数相加时没有理由离开整数领域，因此结果也是一个 `Int64`。但是，如果其中一个数字是 `Float64`，另一个数字会被提升到该类型，结果的类型也将是该类型。
- en: 'Julia will not promote nonnumerical types to numbers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 不会将非数值类型提升为数字：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Its treatment of types and promotion is therefore similar to Python and dissimilar
    from JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它对类型和提升的处理方式因此类似于 Python，而不同于 JavaScript。
- en: 'The `promote()` function takes any number of numerical arguments and returns
    a tuple with (possibly) some of them promoted as necessary to give them all a
    common type so they can be used in subsequent calculations without further promotion.
    It performs the same promotions as would be performed automatically when doing
    arithmetic:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`promote()`函数可以接受任意数量的数字参数，并返回一个元组（可能）将其中的一些参数提升为必要的共同类型，以便它们可以在后续的计算中使用，而无需再次提升。它执行的提升操作与进行算术运算时自动执行的提升操作相同：'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The promotion in the first line shows how some numbers (2.0, 3.5) have an exact
    binary representation, but others (3.4) do not. The two following commands provide
    examples of how `promote()` converts its arguments to a common type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行中的提升展示了某些数字（如2.0、3.5）具有精确的二进制表示，而其他一些数字（如3.4）则没有。接下来的两个命令示例展示了`promote()`如何将其参数转换为共同类型。
- en: '***Collections***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合***'
- en: 'Julia prints the types of collections in the REPL when printing their values
    more often than it announces simple numerical types, so we’ve seen more of the
    former:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Julia在REPL中打印集合的类型时，比打印简单的数字类型更频繁，因此我们已经看到更多前者：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Julia prints the type of collection (`Matrix`, `Vector`, or `Array`) and its
    dimensions. A `Vector` is one-dimensional, and a `Matrix` is two-dimensional.
    For the more general `Array` type, Julia prints an integer showing the number
    of dimensions: here it’s a three-dimensional array ➊.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Julia打印集合的类型（`Matrix`、`Vector`或`Array`）及其维度。`Vector`是一维的，`Matrix`是二维的。对于更通用的`Array`类型，Julia会打印一个整数，显示维度数：这里是一个三维数组➊。
- en: 'It also indicates the types of the collection’s elements inside curly brackets.
    We can extract this information separately using the `eltype()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会显示集合元素的类型，并在花括号内显示。我们可以使用`eltype()`函数单独提取这些信息：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the first example, the result, `Int64`, is the type of both elements of
    the array. The second example shows how Julia promotes numerical types when possible
    to create homogeneous arrays, which are more efficient to calculate with. However,
    when confronted with types where no promotion is possible ➊, the element type
    becomes `Any`: a type that literally means any type.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，结果`Int64`是数组中两个元素的类型。第二个示例展示了Julia如何在可能的情况下提升数字类型，以创建同质数组，这样可以更高效地进行计算。然而，当遇到无法进行提升的类型时➊，元素类型会变成`Any`：这个类型字面意思是任何类型。
- en: 'These results follow the behavior of the `promote()` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果遵循`promote()`函数的行为：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If elements can be promoted to a common type, that type is used for the `eltype`
    of the collection; otherwise, the `Any` type is used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素可以提升为一个共同类型，则该类型会被用作集合的`eltype`；否则，使用`Any`类型。
- en: 'The collection types `Vector`, `Matrix`, and `Array` have some behaviors in
    common: for example, they can all be indexed. This is not true of all collections,
    however. The `Set` type has no ordering, hence no ability to be indexed. These
    three collection types share certain behaviors because they’re special cases of
    a more general type, a concept that we’ll explore in the next section.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型`Vector`、`Matrix`和`Array`有一些共同的行为：例如，它们都可以被索引。然而，并非所有集合类型都有这种特性。`Set`类型没有顺序，因此无法进行索引。这三个集合类型之所以共享某些行为，是因为它们是更通用类型的特殊情况，这一概念我们将在下一节中探讨。
- en: '***The Type Hierarchy***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型层次结构***'
- en: All types in Julia are *subtypes* of types that are their *supertypes.* The
    one type that has no strict supertype is the `Any` type, which is its own supertype.
    The concepts of supertypes and subtypes are connected with the inheritance of
    behaviors, and the configuration of the type hierarchy is usually intuitive when
    applied to particular cases. For example, we expect that any kind of number will
    support some notion of addition. Exactly what addition means may vary among various
    species of numbers—addition of complex numbers is a generalization of addition
    of real numbers, for example—but when we encounter a type that is a subtype of
    the `Number` type, we can be confident that, at least, the `+` operator is defined
    for it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的所有类型都是*子类型*，它们的*超类型*则是某个类型的上级。唯一没有严格超类型的类型是`Any`类型，它是自己的超类型。超类型和子类型的概念与行为的继承相关，类型层次结构的配置在应用于特定情况时通常是直观的。例如，我们期望任何种类的数字都会支持某种加法运算。尽管不同种类的数字的加法含义可能有所不同——例如复数加法是实数加法的一种推广——但当我们遇到`Number`类型的子类型时，我们可以确信，至少`+`运算符是为它定义的。
- en: As shown in [Listing 8-1](ch08.xhtml#ch8lis1), the `supertype()` function, when
    supplied a type, returns its supertype.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 8-1](ch08.xhtml#ch8lis1)所示，`supertype()` 函数在提供一个类型时，返回它的超类型。
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-1: Walking up the type hierarchy*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：向上遍历类型层次结构*'
- en: The `typeof()` function returns the type of a literal value or variable. The
    types that we actually compute with, such as `Float64` and `Int64`, are called
    *concrete types*. Concrete types are leaves at the tips of the tree of types;
    they can not subtype each other.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof()` 函数返回字面值或变量的类型。我们实际进行计算的类型，如 `Float64` 和 `Int64`，被称为*具体类型*。具体类型是类型树的叶子节点；它们不能互相作为子类型。'
- en: '[Listing 8-1](ch08.xhtml#ch8lis1) shows a series of calls to `supertype()`
    to find where the default integer type, `Int64`, lies in the type hierarchy. All
    of the types that concrete types such as `Int64` inherit from are *abstract types*.
    The purpose of abstract types, such as `Number`, is simply to create nodes in
    the tree of types to enable the definition of methods. The function of these abstract
    types, and the type hierarchy that they constitute, is not to make things more
    complicated, but to make the life of the Julia programmer easier. Because of the
    tree of types, we can define functions and methods that operate at the ideal level
    of abstraction, as we’ll see in “Functions and Methods: Multiple Dispatch” on
    [page 229](ch08.xhtml#ch08lev2).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch8lis1)展示了一系列对 `supertype()` 的调用，用于找出默认整数类型 `Int64` 在类型层次结构中的位置。像
    `Int64` 这样的具体类型所继承的所有类型都是*抽象类型*。抽象类型，如 `Number`，的作用仅仅是创建类型树中的节点，以便定义方法。这些抽象类型及其构成的类型层次结构，并不是为了使事情更加复杂，而是为了让
    Julia 程序员的工作更加轻松。由于类型树的存在，我们可以在理想的抽象层次上定义函数和方法，正如我们将在《函数和方法：多重分发》一章的[第 229 页](ch08.xhtml#ch08lev2)中看到的那样。'
- en: The final two lines in [Listing 8-1](ch08.xhtml#ch8lis1) show that `Number`
    is at the top of the hierarchy of numerical types, and its supertype, `Any`, is
    the root of the entire hierarchy, and, as the last line shows, is its own supertype.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch8lis1)的最后两行显示，`Number` 位于数值类型层次结构的顶部，而它的超类型 `Any` 是整个层次结构的根，正如最后一行所示，`Any`
    还是它自己的超类型。'
- en: By making more calls to `supertype()`, we can explore more of the type tree.
    [Listing 8-2](ch08.xhtml#ch8lis2) shows a modification of the program in [Listing
    7-3](ch07.xhtml#ch7lis3) to visualize a section of it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多次调用 `supertype()`，我们可以探索更多的类型树。[清单 8-2](ch08.xhtml#ch8lis2)展示了对[清单 7-3](ch07.xhtml#ch7lis3)程序的修改，用于可视化它的一部分。
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-2: Visualizing part of the type hierarchy*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：可视化部分类型层次结构*'
- en: We’ve collected a handful of mostly numeric types in the `sometypes` vector.
    These are a subset of the total number of types that come with Julia and its standard
    library, and many more are defined in various packages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `sometypes` 向量中收集了一些主要的数值类型。这些是 Julia 及其标准库提供的类型的子集，更多类型定义在各种包中。
- en: '[Listing 8-2](ch08.xhtml#ch8lis2) uses the `supertype()` function to create
    the edges ➊ of the tree graph, connecting each type to its supertype. [Figure
    8-2](ch08.xhtml#ch8fig2) shows the result.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](ch08.xhtml#ch8lis2)使用 `supertype()` 函数来创建树图的边 ➊，将每个类型与其超类型连接。[图 8-2](ch08.xhtml#ch8fig2)展示了结果。'
- en: '![Image](../images/ch08fig02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig02.jpg)'
- en: '*Figure 8-2: The relationships among a few types*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：几种类型之间的关系*'
- en: '[Figure 8-2](ch08.xhtml#ch8fig2) makes it clear that `Any` is the root of the
    tree and reminds us that, for example, characters and strings are distinct types.
    But it also obscures certain relationships, such as that some types are aliases
    of others. This is a topic we’ll explore later in this chapter (see “Type Aliases”
    on [page 247](ch08.xhtml#ch08lev5)).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](ch08.xhtml#ch8fig2)清晰地显示了 `Any` 是树的根，并提醒我们，例如，字符和字符串是不同的类型。但它也模糊了一些关系，比如某些类型是其他类型的别名。这是我们将在本章后面（参见“类型别名”章节，位于[第
    247 页](ch08.xhtml#ch08lev5)）进一步探讨的内容。'
- en: 'Two additional functions that are handy for exploring the type hierarchy are
    `subtypes()`, which returns a vector of all the *immediate* subtypes of the type
    supplied as an argument, and `supertypes()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个方便探索类型层次结构的函数是 `subtypes()`，它返回作为参数传入的类型的所有*直接*子类型的向量，以及 `supertypes()`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example shows that `supertypes()` returns a tuple containing the type supplied
    and all of its supertypes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了 `supertypes()` 返回一个元组，包含传入的类型及其所有的超类型。
- en: '***Type Assertions and Declarations***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型断言和声明***'
- en: Now we know how to discover the type of any variable and the supertype of any
    type. On occasion, we also need to tell Julia that a variable is of a particular
    type (a *type declaration*), or that the value of an expression should have a
    specified type (a *type assertion*). The `::` operator performs either operation,
    depending on where it occurs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何发现任何变量的类型以及任何类型的超类型。有时，我们还需要告诉 Julia 一个变量是某种特定类型（*类型声明*），或者一个表达式的值应该具有指定的类型（*类型断言*）。`::`
    操作符根据其所在的位置执行其中的任一操作。
- en: '**Type Assertions**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**类型断言**'
- en: Sometimes in our programs we reach a point where it is important to ensure that
    the value of a particular expression has a certain type. If it does not, we want
    to generate an error, which we can either handle or allow to halt the program.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在我们的程序中，我们会遇到一个需要确保某个特定表达式的值具有某种类型的情况。如果不是，我们希望生成一个错误，这个错误可以被处理或者允许程序终止。
- en: 'The simplest expression in Julia is a literal value. Let’s use `17` as our
    first example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中最简单的表达式是字面值。让我们以 `17` 作为第一个示例：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line is an assertion that `17` has the `Number` type, which of course
    it does. An expression with a type assertion attached returns the value of the
    expression if the assertion is true, so here Julia simply returns `17`. The following
    two lines are also true assertions. A type assertion is true if it specifies any
    supertype of the type of the expression.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是对 `17` 具有 `Number` 类型的断言，显然它是正确的。带有类型断言的表达式如果断言为真，则返回该表达式的值，因此这里 Julia 只是返回
    `17`。接下来的两行也是正确的断言。如果类型断言指定了表达式类型的任何超类型，那么这个断言就为真。
- en: The final type assertion returns an error because `17` is neither a `String`
    nor a subtype of the `String` type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的类型断言返回错误，因为 `17` 既不是 `String` 类型，也不是 `String` 类型的子类型。
- en: 'Here’s an example of how we might use a type assertion in a program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了我们如何在程序中使用类型断言：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The program asks the user a question, receives the reply using `readline()`,
    and joins it with two other strings to construct a greeting, which it returns.
    We used a type assertion ➊ to ensure that the type returned by the function is
    what is expected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序向用户提问，使用 `readline()` 接收回复，并将其与其他两个字符串连接以构造问候语，然后返回结果。我们使用了类型断言 ➊ 来确保函数返回的类型符合预期。
- en: '**Type Declarations**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**类型声明**'
- en: We also use the `::` operator for type declarations. Its meaning is determined
    from its position within a statement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也使用 `::` 操作符进行类型声明。它的含义取决于它在语句中的位置。
- en: 'We can declare that a variable has a particular type in two ways. One way is
    to supplement the usual assignment statement with a declaration, as in this example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式声明一个变量具有特定类型。第一种方式是通过声明来补充常规的赋值语句，如下所示：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here the assignment and the type declaration happen simultaneously.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里赋值和类型声明是同时发生的。
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Julia v1.8 was the first version that allowed type declarations of global
    variables; this makes working in the REPL more convenient. In earlier versions,
    all type declarations must occur in a local scope.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*Julia v1.8 是第一个允许全局变量类型声明的版本；这使得在 REPL 中工作更加方便。在早期版本中，所有类型声明必须出现在局部作用域中。*'
- en: 'Once we declare the type of a variable, we are committed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了变量的类型，就已经确定了：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As this example shows, an attempt to assign a value of the wrong type to a declared
    variable, or to explicitly change its type, results in an error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所示，尝试将错误类型的值赋给已声明的变量，或显式地改变其类型，将导致错误。
- en: 'Any value assigned to `a` must be convertible to `a`’s type, `Int16`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值给 `a` 的任何值必须可以转换为 `a` 的类型 `Int16`：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The second assignment failed because 32,768 is larger than the largest value
    that an `Int16` can hold, which is 2^(15)−1 = 32,767, returned by `typemax(Int16)`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次赋值失败是因为 32,768 大于 `Int16` 所能容纳的最大值，即 2^(15)−1 = 32,767，这个值由 `typemax(Int16)`
    返回。
- en: '[Listing 8-3](ch08.xhtml#ch8lis3) shows the other way to declare a type: as
    part of a `local` or `global` definition.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-3](ch08.xhtml#ch8lis3) 显示了声明类型的另一种方式：作为 `local` 或 `global` 定义的一部分。'
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-3: Type declarations*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-3：类型声明*'
- en: We define `gf` to be global and to have the `Float64` type. Julia seems happy
    to let us assign a literal integer to it, but it has converted the value to a
    `Float64` as part of the assignment ➊. Because there is no way to convert a literal
    string to a `Float64`, our attempt to assign a string to the variable failed ➋.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `gf` 为全局变量，并且类型为 `Float64`。Julia 似乎允许我们将一个字面量整数赋值给它，但它已经在赋值过程中将该值转换为 `Float64`
    ➊。因为没有办法将字面量字符串转换为 `Float64`，我们尝试将一个字符串赋值给变量时失败了 ➋。
- en: We can use a variable of the same name, declared to be local, inside a function
    ➍ ; this local variable has no relationship with the global `gf`. The function
    `weather_report()` expects a `Bool` from the user (`true` or `false`), and uses
    it to construct a sentence about the weather. It uses the `isa` operator to check
    that it’s received the correct type ➌.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数内使用相同名称的局部变量，并声明为局部变量➍；这个局部变量与全局变量 `gf` 没有任何关系。函数 `weather_report()`
    期望从用户那里得到一个 `Bool` 类型的值（`true` 或 `false`），并用它来构建一个关于天气的句子。它使用 `isa` 操作符来检查是否收到了正确的类型
    ➌。
- en: 'The following short program illustrates an important behavior of type declarations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这个简短的程序演示了类型声明的一个重要行为：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running this function produces the output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个函数会产生以下输出：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The line that prints the type of `a` comes *before* the type declaration; so
    why is `a` already an `Int16`? After all, this is what happens in the REPL:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `a` 类型的那一行出现在类型声明的*之前*；那么为什么 `a` 已经是一个 `Int16` 类型了呢？毕竟，在 REPL 中会发生这样的情况：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This output is what we expect, as the concrete type `Int64` is the native integer
    on a 64-bit machine, which is the most common architecture. The explanation is
    that a type declaration within a scope block, in this case a function definition,
    enforces an unchangeable type for the entire block. The declaration can occur
    anywhere within the block.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出是我们预期的，因为 `Int64` 类型是 64 位机器上原生的整数类型，而 64 位架构是最常见的架构。解释是，作用域块中的类型声明（在本例中是函数定义）强制整个块内类型不可更改。声明可以在块的任何位置出现。
- en: 'In the absence of a declaration, a variable *can* change type within a block
    as a consequence of arithmetic operations:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有声明，一个变量*可以*在块内通过算术运算改变类型：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function produces the output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会产生如下输出：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Allowing this to happen can interfere with performance, a topic we return to
    in “Vanquish Type Instability” on [page 242](ch08.xhtml#ch08lev1sec13).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 允许这种情况发生可能会影响性能，关于这一点我们将在“消除类型不稳定性”一节中讨论，详见 [page 242](ch08.xhtml#ch08lev1sec13)。
- en: 'The `::` operator can also declare the type of the value returned by a function.
    For example, we can change the first line of the definition of `weather_report()`
    in [Listing 8-3](ch08.xhtml#ch8lis3) as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`::` 操作符还可以声明函数返回值的类型。例如，我们可以像这样修改 [Listing 8-3](ch08.xhtml#ch8lis3) 中 `weather_report()`
    定义的第一行：'
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This asserts that the function must return a `String` value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句声明函数必须返回一个 `String` 类型的值。
- en: 'The purpose of such declarations is the same as type declarations for variables:
    they are never required, and usually not needed, but in some cases they can provide
    extra information to the compiler that helps with performance. We’ll see some
    examples of this in “Performance Tips” on [page 242](ch08.xhtml#ch08lev4). When
    we construct expressions using functions, it’s helpful to know the types returned
    by each function call; using type declarations in function definitions assists
    in writing correct and efficient programs.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明的目的与变量的类型声明相同：它们从不强制要求，通常也不需要，但在某些情况下，它们可以为编译器提供额外的信息，从而帮助提高性能。我们将在“性能优化”一节中看到一些例子，详见
    [page 242](ch08.xhtml#ch08lev4)。当我们使用函数构造表达式时，知道每个函数调用返回的类型是很有帮助的；在函数定义中使用类型声明有助于编写正确且高效的程序。
- en: '**Functions and Methods: Multiple Dispatch**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数和方法：多重分派**'
- en: 'When we define a function in the REPL, if there are no errors, we’ll see a
    message like the one we saw after the definition of `weather_report()` in [Listing
    8-3](ch08.xhtml#ch8lis3):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 REPL 中定义一个函数时，如果没有错误，我们会看到类似我们在 [Listing 8-3](ch08.xhtml#ch8lis3) 中看到的消息：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A generic function is defined by its name, in this case `weather_report()`.
    Each generic function can have any number of *methods* associated with it, which
    are distinguished by their method *signatures*. The signature is the part that
    goes inside the parentheses when you define the method. Up until now, these signatures
    have included the names of positional and keyword arguments and their default
    values, if any. If we make a second definition of `weather_report()` with a different
    set of arguments in its signature, we will have created a second method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用函数由它的名称定义，在本例中是 `weather_report()`。每个通用函数可以有任意数量的*方法*与之关联，这些方法通过它们的方法*签名*来区分。签名是定义方法时，放在括号内的部分。到目前为止，这些签名包含了位置参数和关键字参数的名称及其默认值（如果有的话）。如果我们使用不同的参数集合重新定义
    `weather_report()`，我们就创建了一个第二个方法。
- en: A further use of the `::` operator is within method signatures, to specify the
    types that the arguments therein are supposed to have. Two definitions, both with
    the same arguments, define different methods if any of these type specifications
    are different, even if the signatures are otherwise the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`::`运算符的另一个用法是在方法签名中，用来指定方法参数应具有的类型。如果两个方法的定义具有相同的参数，但其中任何一个类型规范不同，那么即便签名其他部分相同，它们也定义了不同的方法。'
- en: When the compiler sees a function call, it invokes the method with the most
    specific definition that matches the arguments supplied in the call. Here is where
    we see the real purpose of the abstract types that we learned about in “The Type
    Hierarchy” on [page 222](ch08.xhtml#ch08lev1sec4). With all else being equal,
    a method defined using a particular type for one of its arguments is more specific
    than one defined for a supertype for the same argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器看到函数调用时，它会调用最匹配传入参数的最具体的定义。这里我们看到我们在《类型层次结构》一章中学到的抽象类型的真正用途，[在第222页](ch08.xhtml#ch08lev1sec4)中提到过。其他条件相同的情况下，为某个参数定义了特定类型的方法，比为该参数的超类型定义的方法更具体。
- en: To determine which method to call, the compiler examines *all* of the arguments.
    This procedure for method selection, or *dispatch*, is called *multiple dispatch*
    for this reason. It is an unusual, but not unique, feature in the landscape of
    programming languages, and it’s a major reason for Julia’s power and success.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定调用哪个方法，编译器会检查*所有*的参数。这个方法选择过程，或称为*分派*，因此被称为*多重分派*。它是编程语言中一个不常见但并非独特的特性，也是Julia强大和成功的一个主要原因。
- en: In contrast, object-oriented languages dispatch solely on the first argument
    of a method, often supplied implicitly as the object the method is part of and
    represented within the procedure with variables such as `this` or `self`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，面向对象语言仅根据方法的第一个参数进行分派，这个参数通常隐式地作为方法所属的对象提供，并在程序中通过像`this`或`self`这样的变量表示。
- en: Functional languages have no real dispatch mechanism at all. All specialization
    must take the form of alternative code paths within one large function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言根本没有真正的分派机制。所有的特殊化都必须以在一个大函数中的替代代码路径的形式出现。
- en: Julia’s multiple dispatch paradigm means that it is neither an object-oriented
    nor a functional language, but something more general and flexible than either
    of them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的多重分派范式意味着它既不是面向对象语言，也不是函数式语言，而是比它们更通用、更灵活的一种语言。
- en: '***Creating Multiple Methods***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建多个方法***'
- en: 'Our definition of `weather_report()` included a check that the supplied argument
    was the correct type and a measure to take in case it wasn’t, implemented in an
    `if` block. We can eliminate that check by restarting the REPL and replacing the
    definition of `weather_report()` with two other methods with different signatures:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`weather_report()`的定义包括了一个检查，确保传入的参数是正确类型，并在参数不符时采取措施，这一检查通过`if`语句块实现。我们可以通过重新启动REPL并将`weather_report()`的定义替换为两个具有不同签名的其他方法来消除这个检查。
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After the first definition, the REPL replies with the same message as before,
    but after the second, we are informed that `weather_report()` now has two methods.
    The only difference between our two methods is that the first has a type specification
    for the single argument, `raining`, in its signature, whereas the second does
    not. The absence of a type specification means that the compiler will accept an
    argument with any type, or, said another way, with the `Any` type. The rule is
    that the compiler will always select the most specific method for the arguments
    supplied. If we supply a `Bool` (`true` or `false`), the first method is selected,
    because it’s more specific than the second, as `Bool` is a subtype of `Any`. Any
    other type dispatches the second method, and the request to supply `true` or `false`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次定义之后，REPL会回复与之前相同的消息，但在第二次定义后，我们会被告知`weather_report()`现在有两个方法。这两个方法的唯一区别在于，第一个方法的签名为单个参数`raining`指定了类型，而第二个没有。没有类型指定意味着编译器会接受任何类型的参数，或者换句话说，会接受`Any`类型。规则是编译器会始终选择最具体的方法来匹配提供的参数。如果我们传递一个`Bool`值（`true`或`false`），第一个方法会被选择，因为它比第二个方法更具体，因为`Bool`是`Any`的子类型。任何其他类型都会调用第二个方法，并要求传递`true`或`false`。
- en: 'Let’s verify that the two methods work the way we expect:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证这两个方法是否按预期工作：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This technique of creating a collection of methods rather than cramming a bunch
    of type-checking code into one larger function is more idiomatic to Julia and
    leads to better-organized projects that are easier to maintain and extend.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种创建一组方法的技术，而不是将大量类型检查代码塞进一个更大的函数，是Julia的更地道做法，有助于更好地组织项目，便于维护和扩展。
- en: 'Suppose we wanted to extend the function by giving it the ability to comment
    on the weather in a city supplied by the user. The power of multiple dispatch
    allows us to simply add another method without changing anything we’ve already
    written:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望通过让程序能够评论用户提供的城市天气来扩展功能。多重分派的强大功能使我们能够简单地添加另一个方法，而无需更改我们已经编写的任何内容：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we try to call `weather_report()` with arguments that don’t match the signature
    of any existing method, we get an error message:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用与任何现有方法的签名不匹配的参数调用`weather_report()`，我们会收到一条错误消息：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The error message tells us that none of the methods of `weather_report()` have
    the right signature and lists some of the available methods, showing the types
    we can use for their arguments. We’ll get a similar error if we, for instance,
    try to add two things that can’t be added, such as `1 + "1"`, but the three or
    so possible methods mentioned in the error message will be a small fraction of
    the over 200 methods defined for the `+` operator. To see a list of all the methods
    defined for any function, call `methods()`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息告诉我们`weather_report()`的所有方法都没有正确的签名，并列出了一些可用的方法，展示了可以用于其参数的类型。如果我们尝试添加两种不能相加的东西，例如`1
    + "1"`，我们会收到类似的错误，但错误消息中提到的三种或更多的方法只是`+`运算符定义的200多种方法中的一小部分。要查看为任何函数定义的所有方法的列表，可以调用`methods()`：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we see the list of methods we’ve defined for `weather_report()` with their
    method signatures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们为`weather_report()`定义的方法列表及其方法签名。
- en: '***Extending Built-in Functions with New Methods***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过新方法扩展内置函数***'
- en: Suppose we had a program that reads numbers from a file, or from user input,
    and adds them to an existing number. The read-in values would be strings, and
    the program would have to convert them to numbers before performing the addition.
    [Listing 8-4](ch08.xhtml#ch8lis4) shows a case like this, where we might decide
    to eliminate the explicit conversion step from the program by adding a method
    to `+` that does the conversion automatically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个程序，它从文件或用户输入中读取数字，并将它们加到现有的数字上。读取的值将是字符串，程序必须将它们转换为数字，然后才能执行加法操作。[Listing
    8-4](ch08.xhtml#ch8lis4)展示了这种情况，我们可能决定通过向`+`添加一个方法来自动完成转换，从而省略显式转换步骤。
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 8-4: Extending addition with a new method*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-4：通过新方法扩展加法*'
- en: We’re not allowed to extend certain basic functions, such as `+`, unless we
    first explicitly import them, which is accomplished in the first line. After defining
    this method, it will be dispatched on any attempt to add a string to a number,
    something that normally results in a `MethodError`. If the `String` argument can
    be parsed as a `Number`, that number is added to the first argument and the method
    returns the result. If it can’t, the method simply returns the first argument.
    This method definition is an example of the use of abstract types in signatures.
    It will work for any type of number in the first argument, without the need to
    write definitions for each subtype of `Number`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不允许扩展某些基本函数，例如`+`，除非我们首先显式地导入它们，这在第一行中完成。定义此方法后，当尝试将字符串与数字相加时，它将被分派，这通常会导致`MethodError`。如果`String`参数可以解析为`Number`，则该数字会与第一个参数相加，方法返回结果。如果不能，方法将简单地返回第一个参数。这个方法定义是抽象类型在签名中使用的一个示例。它适用于第一个参数的任何数字类型，而无需为`Number`的每个子类型编写定义。
- en: 'Let’s check that this method works as intended:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这个方法是否按预期工作：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve added to the language by extending the behavior of one of its basic operators.
    Multiple dispatch gives us the power to do this without altering any existing
    methods.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过扩展其中一个基本运算符的行为，向语言中添加了新特性。多重分派使我们能够做到这一点，而无需更改任何现有的方法。
- en: '**DON’T BE A PIRATE**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要做海盗**'
- en: 'We would never place methods such as the one defined in [Listing 8-4](ch08.xhtml#ch8lis4)
    in a public package. That’s because we are responsible neither for the “+” function
    nor the data types in our new method definition. Someone importing our package
    may suffer conflicts or unexpected behavior. With the great power to extend the
    language comes great responsibility: transgressing this expectation is called
    *type piracy*. If we want to make our method public, we have three choices: name
    it something besides “+”; have it operate on our own string-like data type; or
    make a pull request on GitHub for inclusion in `Base`. The last option will endow
    “+” with a new method in addition to its current paltry 207, and all Julia users
    will automatically have the benefit of our creation.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝不会将像在[清单 8-4](ch08.xhtml#ch8lis4)中定义的方法放入公共包中。这是因为我们对新方法定义中的“+”函数和数据类型不负责。导入我们包的某人可能会遇到冲突或意外行为。语言扩展的强大能力伴随着巨大的责任：违反这一期望被称为*类型盗用*。如果我们想公开我们的这个方法，我们有三个选择：给它起个别的名字，而不是“+”；让它作用于我们自己的类似字符串的数据类型；或者在
    GitHub 上提交一个 Pull Request，要求将其包含到`Base`中。最后一个选项将为“+”增添一个新方法，除了当前的207个方法之外，所有 Julia
    用户都将自动受益于我们的创作。
- en: Specialized methods are not only useful for creating new behaviors, they’re
    sometimes created for efficiency. For example, operations such as matrix multiplication
    or matrix inverse produce mathematically well-defined results (when they exist);
    however, for matrices with certain properties, specialized algorithms for computing
    that result may be more efficient than a general algorithm. The `SparseArrays`
    package (see “The Adjacency Matrix” on [page 196](ch07.xhtml#ch07lev1sec1)) provides
    methods for these matrix operations that are more efficient when one or both of
    the arguments is a sparse array. Multiple dispatch will automatically select the
    ideal method when a matrix operator is passed a sparse array, without any intervention
    needed on the part of the user.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 专门化方法不仅对创建新行为有用，有时它们是为了效率而创建的。例如，矩阵乘法或矩阵求逆等操作会产生数学上定义明确的结果（当结果存在时）；然而，对于具有特定属性的矩阵，计算该结果的专门算法可能比通用算法更高效。`SparseArrays`包（参见[第196页](ch07.xhtml#ch07lev1sec1)中的《邻接矩阵》）提供了用于这些矩阵操作的方法，当其中一个或两个参数是稀疏数组时，这些方法会更高效。多重派发会自动选择理想的方法，当矩阵操作符传递稀疏数组时，无需用户干预。
- en: Although we can create new methods to do anything we want, it makes sense that
    their behavior be conceptually related to the purpose or meaning of the generic
    function that they are a part of. Each of the over 200 methods for `+` has something
    to do with the idea of addition, as does the new method that we’ve defined here.
    Multiple dispatch should be seen as a paradigm for code organization rather than
    a license for chaos. The language does nothing to enforce this principle, which
    depends on the discipline of the programmer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以创建新的方法来做任何想做的事情，但合理的做法是让这些方法的行为在概念上与它们所属的通用函数的目的或意义相关。`+`的200多个方法中的每一个都与加法的概念有关，正如我们在这里定义的新方法一样。多重派发应该被视为一种代码组织的范式，而不是混乱的许可证。语言本身并不强制执行这一原则，这取决于程序员的自律。
- en: '***Understanding Union Types and the <: Operator***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解联合类型和<:运算符***'
- en: Sometimes, when constructing a method, a single abstract type is not general
    enough for our purposes. In such cases, we can declare an argument to have any
    one of several types using `Union{}`. This is an operator that accepts a list
    of types and constructs a new type that includes all of them. A value that has
    the type of anything in the list belongs to the new union type. Also, a type that
    is a subtype of any of the types in the list is a subtype of the union.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在构造方法时，单一的抽象类型对我们的用途来说不够通用。在这种情况下，我们可以使用`Union{}`声明一个参数可以是多个类型中的任何一个。这个操作符接受一个类型列表并构造一个新类型，包含所有这些类型。任何属于列表中类型的值都属于这个新联合类型。而且，任何是列表中某个类型的子类型的类型，也是该联合类型的子类型。
- en: 'The `<:` infix operator is a test that acts on types and returns `true` if
    the type on its left is a subtype of the type on its right. This example illustrates
    the creation of a union type and the use of the `<:` operator:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`<:` 中缀运算符是一个类型测试，如果其左侧的类型是右侧类型的子类型，则返回`true`。这个例子演示了联合类型的创建和`<:`运算符的使用：'
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Because `17` is a `Number`, the first expression returns `true`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`17`是一个`Number`，所以第一个表达式返回`true`。
- en: 'Suppose we want to write a function that acts on real numbers other than integers:
    numbers with a decimal point. We might consider using a type declaration in the
    function signature such as `n::AbstractFloat`, which would include all the concrete
    floating types, such as `Float64` and `Float32`. However, examining [Figure 8-2](ch08.xhtml#ch8fig2)
    reminds us that this declaration would exclude any number supplied as an `Irrational`.
    If the user stuck in a literal π as an argument, a `MethodError` would be the
    result. We can use a union type to handle this scenario: `n::Union{AbstractFloat,
    Irrational}`. We might also consider adding `Rational` to the union, depending
    on the purpose of the function.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要编写一个作用于实数（而非整数）的函数：具有小数点的数字。我们可能会考虑在函数签名中使用类型声明，如`n::AbstractFloat`，这将包含所有具体的浮动类型，如`Float64`和`Float32`。然而，查看[图8-2](ch08.xhtml#ch8fig2)提醒我们，这个声明会排除任何作为`Irrational`提供的数字。如果用户将字面量π作为参数传入，结果将是一个`MethodError`。我们可以使用联合类型来处理这种情况：`n::Union{AbstractFloat,
    Irrational}`。根据函数的目的，我们还可以考虑将`Rational`添加到联合类型中。
- en: '**User-Defined Types**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户自定义类型**'
- en: 'Just as we can create our own verbs (functions and methods) for our own purposes,
    we can create our own nouns (data types) as well. The purpose of user-defined
    types in Julia is the same as the main purpose of types in general: to organize
    projects around methods that can be dispatched based on the types of their arguments.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以为自己的目的创建动词（函数和方法）一样，我们也可以创建自己的名词（数据类型）。在Julia中，用户自定义类型的目的是与类型的主要目的相同：围绕方法组织项目，这些方法可以根据其参数的类型进行分发。
- en: '***Creating Abstract Types***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建抽象类型***'
- en: 'Sometimes, rather than simply adding a leaf to the tree of types we will want
    to add a branch and then create types as leaves attached to that branch. As we
    mentioned earlier, these branches are *abstract* types, and we can make our own
    with the `abstract type` declaration. As an example of its use, here is how to
    create a new abstract type descended from the `Number` type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不仅仅是往类型树中添加一个叶子，而是希望添加一个分支，然后创建作为叶子附加到该分支的类型。正如我们之前提到的，这些分支是*抽象*类型，我们可以通过`abstract
    type`声明来创建自己的抽象类型。作为示例，下面是如何创建一个从`Number`类型派生的新抽象类型：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After executing this statement, the new type `MyNumber` will be a subtype of
    the existing abstract type `Number` (recall that concrete types cannot be subtyped).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此语句后，新的`MyNumber`类型将成为现有抽象类型`Number`的子类型（回想一下，具体类型不能被子类化）。
- en: If the new type is something really new that won’t share methods with existing
    types, there’s no need for it to inherit from any existing type. However, if it
    is a new type of number, string, or other existing type, it makes sense to place
    it appropriately in the type hierarchy. This way, existing methods that act on
    the `Number` type, for example, will be able to handle the new subtype of number.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的类型是全新的，并且不会与现有类型共享方法，那么它无需继承任何现有类型。然而，如果它是新的数字、字符串或其他现有类型的一种，最好将其适当地放入类型层次结构中。这样，现有方法（例如作用于`Number`类型的方法）将能够处理新的数字子类型。
- en: '***Creating Composite Types***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建组合类型***'
- en: The purpose of creating a new abstract type is to be able to define new types
    as its subtypes, types that actually hold values and that we manipulate in calculations.
    These new types can either descend directly from `Any` or descend from an abstract
    type that we create.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新抽象类型的目的是能够将新类型定义为其子类型，这些子类型实际承载值，并在计算中被操作。这些新类型可以直接从`Any`类型派生，也可以从我们创建的抽象类型派生。
- en: 'In almost all cases, these new types will be *composite types*, defined in
    a `struct` block:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，这些新类型将是*组合类型*，在`struct`块中定义：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Composite types typically have several fields (but may have only one). The new
    `EarthLocation` type is intended to represent a location on Earth by its latitude
    and longitude and includes a field for the location’s time zone. The type declarations
    on the fields are optional; a field without a declaration will be of the `Any`
    type.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 组合类型通常有多个字段（但也可以只有一个）。新的`EarthLocation`类型旨在通过纬度和经度表示地球上的一个位置，并包括一个表示该位置时区的字段。字段上的类型声明是可选的；没有声明的字段将是`Any`类型。
- en: 'The following creates a variable with this type:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个具有此类型的变量：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function, created by Julia using the same name as the type, is called a
    *constructor*. As the second interaction shows, it creates values with the `EarthLocation`
    type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个由Julia创建的函数，名称与类型相同，称为*构造函数*。如第二次交互所示，它创建了`EarthLocation`类型的值。
- en: 'We can access a composite type’s field values using property notation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用属性符号访问复合类型的字段值：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The fields are assigned in the order in which they appear in the type’s definition.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 字段是按照它们在类型定义中出现的顺序赋值的。
- en: 'Since a constructor is a function, we can define multiple methods for it. Here
    is one that handles the case where the caller supplies coordinates but no time
    zone:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数是一个函数，我们可以为其定义多个方法。这里是一个处理调用者提供坐标但没有时区的情况的方法：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The method dispatched when the caller uses only two arguments calls the original
    method with `"Unknown"` as the time zone. This method could have done anything,
    but naming it the same as the constructor for `EarthLocation` types and having
    it return something other than an instance of that type would be confusing. As
    mentioned in “Parametric Types” on [page 248](ch08.xhtml#ch08lev6), we should
    exploit the type system and multiple dispatch to make our code easier to understand,
    rather than the opposite.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用者只使用两个参数时，分派的方法调用原始方法，并将 `"Unknown"` 作为时区传入。这个方法本可以做任何事情，但如果将其命名为 `EarthLocation`
    类型的构造函数，并且让它返回除该类型实例之外的东西，就会造成混淆。正如在“参数类型”章节的 [第248页](ch08.xhtml#ch08lev6) 中提到的，我们应该利用类型系统和多重分派来使代码更易于理解，而不是相反。
- en: 'Suppose we decide to use a different convention for recording time zones, and
    try to make some changes to existing variables:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定使用不同的约定来记录时区，并尝试对现有变量做一些修改：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Julia objects to what seems like a reasonable attempt to assign a new value
    to one of the fields of `NYC`. By default, composite types are immutable, which
    permits the compiler to generate more efficient code in some circumstances. If
    a program requires types whose field values can be changed, we need to explicitly
    define our type using the `mutable` keyword:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 对于似乎是合理尝试给 `NYC` 的某个字段赋新值的操作。默认情况下，复合类型是不可变的，这使得编译器在某些情况下能够生成更高效的代码。如果程序需要可以改变字段值的类型，我们需要显式地使用
    `mutable` 关键字来定义我们的类型：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this definition, we can alter variables with the `MutableEarthLocation`
    type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，我们可以修改 `MutableEarthLocation` 类型的变量：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can change the values of fields of mutable composite types at will. However,
    when this isn’t necessary, such as when the type represents a permanent object
    that should not be mutated, it’s generally better to define it without the `mutable`
    keyword.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随意更改可变复合类型的字段值。然而，当没有必要这样做时，比如当类型表示一个不应被修改的永久对象时，通常最好在定义时不使用 `mutable` 关键字。
- en: '***Using Composite Types***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用复合类型***'
- en: 'Let’s explore a simple example that shows the usefulness of creating our own
    types, along with methods designed to operate on them. The idea is to define a
    couple of types representing circles. They’ll be somewhat different from each
    other, but since they both represent circles, they will have some commonality.
    We plan to write some methods that are specialized to our two circle types, and
    at least one that should be applicable to both (or more, if we extend the project
    in the future). This situation calls for the creation of an abstract type to represent
    circles in general, from which we’ll derive each composite circle type:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个简单的例子，展示创建自定义类型及其操作方法的有用性。我们的想法是定义几种表示圆形的类型。它们会有所不同，但因为它们都表示圆形，所以会有一些共性。我们计划编写一些针对这两种圆形类型的专用方法，至少有一个方法应该适用于这两种类型（如果我们将来扩展项目，可能适用于更多类型）。这种情况需要创建一个抽象类型来表示一般的圆形，从中派生每种复合圆形类型：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we’re not concerned *where* a circle is, we can define it completely by
    its radius. With this in mind, let’s define our first composite circle type to
    have only one field:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不关心圆的位置，我们可以完全通过它的半径来定义它。考虑到这一点，我们定义我们的第一个复合圆形类型，只有一个字段：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here `r` represents the circle’s radius, which can be any `Real` number. The
    type `FloatingCircle` is a subtype of our abstract `Circle` type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `r` 代表圆的半径，可以是任意 `Real` 数字。`FloatingCircle` 类型是我们抽象 `Circle` 类型的一个子类型：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our next circle type also contains information about the shape’s position in
    space:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个圆形类型还包含关于形状在空间中的位置的信息：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Of course, `PositionedCircle` is also defined as a subtype of `Circle`. The
    real numbers `x` and `y` are intended to hold the coordinates of its center. The
    abstract `Circle` type now has two subtypes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`PositionedCircle` 也被定义为 `Circle` 的一个子类型。实数 `x` 和 `y` 用于表示其圆心的坐标。抽象的 `Circle`
    类型现在有了两个子类型：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What we have so far might be the beginnings of a package to perform some geometrical
    calculations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的可能是一个几何计算包的开端。
- en: 'Suppose the next step is to write a function that calculates the area of a
    circle. This area doesn’t depend on where the circle happens to be, only on its
    radius. Therefore, it should accept either subtype of the abstract `Circle` type
    and any future subtype that we might come up with:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设下一步是编写一个计算圆面积的函数。这个面积与圆的位置无关，仅与其半径有关。因此，它应该接受抽象`Circle`类型的任何子类型，以及我们将来可能创建的任何子类型：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `circle_area()` function’s signature demands that the type of its argument
    is a subtype of `Circle`. If it is, it will have a radius, which, by convention,
    we call `r` in all of our circular composite types:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`circle_area()`函数的签名要求其参数类型必须是`Circle`的子类型。如果是，它将具有半径，按惯例，我们在所有圆形复合类型中将其称为`r`：'
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After confirming that the new function calculates areas correctly for both `FloatingCircle`s
    ➊ and `PositionedCircle`s ➋, we forget that `circle_area()` deals only with subtypes
    of `Circle` and try to hand it a number, which results in a `MethodError`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认新函数正确计算了`FloatingCircle`类型 ➊ 和`PositionedCircle`类型 ➋ 的面积之后，我们忘记了`circle_area()`只处理`Circle`的子类型，并尝试传入一个数字，这导致了`MethodError`错误。
- en: 'Let’s add one more function to this geometry project: a routine that takes
    two circles and tells us if the second circle is entirely within the first.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个几何项目中添加一个功能：一个例程，接受两个圆，并告诉我们第二个圆是否完全位于第一个圆内。
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The function calculates the distance between the centers of the two circles
    using their x- and y-coordinates, and then checks whether one lies inside the
    other by referring to their radii. Of course, the concept of a circle being “inside”
    another makes sense only if we can say where the circles are, so the new function
    accepts only `PositionedCircle`s and will have only one method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过使用圆心的x坐标和y坐标计算两个圆之间的距离，然后检查其中一个是否完全包含在另一个圆内，通过它们的半径来判断。当然，圆形“包含”另一个圆的概念只有在我们知道圆的位置时才有意义，因此新函数只接受`PositionedCircle`类型，并且只会有一个方法。
- en: 'Let’s try it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It seems to be working, but to be sure, it will help to make a diagram. We
    can draw our three circles using `Luxor` in a program similar to the one in [Listing
    7-1](ch07.xhtml#ch7lis1):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它似乎在工作，但为了确保，我们最好画个图。我们可以使用`Luxor`在一个类似于[示例 7-1](ch07.xhtml#ch7lis1)的程序中绘制我们的三个圆：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `Luxor` package uses points as its unit of length, so we expand our dimensions
    ➊ to make a reasonably sized illustration. The labels on the circles are the same
    as the names we gave them before. [Figure 8-3](ch08.xhtml#ch8fig3) shows the diagram
    that this program creates, where we can see that the `is_inside()` function calculates
    the “inside” relationship correctly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Luxor`包使用点作为长度单位，因此我们将尺寸 ➊ 扩展，以便制作出合理大小的插图。圆圈上的标签与我们之前为它们命名时使用的名称相同。[图 8-3](ch08.xhtml#ch8fig3)展示了该程序创建的图示，我们可以看到`is_inside()`函数正确地计算了“包含”关系。'
- en: '![Image](../images/ch08fig03.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig03.jpg)'
- en: '*Figure 8-3: Circle b is inside a, but c is not.*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：圆 b 在圆 a 内，但圆 c 不在其中。*'
- en: 'We know how to enforce types used in constructors for user-defined types. But
    what if we want to constrain the allowed values passed to the constructors? Here’s
    how to make a type like our `FloatingCircle` that demands a positive radius:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何强制要求用户定义类型的构造函数中使用的类型。但如果我们想限制传递给构造函数的允许值该怎么办呢？以下是如何创建一个类似我们`FloatingCircle`类型的类型，要求半径为正数：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As with functions, constraints on the values passed as arguments must be enforced
    in the body. The method inside the body ➊ is called an *inner constructor*; the
    other constructors we’ve been using up to now are *outer constructors*. The function
    `new()` creates the instance. It’s used only inside inner constructors.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数类似，传递给参数的值的约束必须在函数体内进行强制。在函数体内 ➊ 的方法被称为*内构造函数*；我们之前使用的其他构造函数被称为*外构造函数*。`new()`函数用于创建实例，仅在内构造函数内使用。
- en: 'Those who have experience with a class-based object-oriented language, such
    as Python, are sometimes at a temporary disadvantage when trying to absorb the
    concept of a user-defined composite type in Julia. We all have a tendency, when
    confronting a new concept, to relate it to concepts that are familiar to us. Composite
    types in Julia are not classes; Julia has no classes and, obviously, no class
    inheritance. In an object-oriented language, the next step would be to define
    methods as part of the class: the nouns and verbs are bound together. The more
    flexible multiple dispatch paradigm decouples nouns and verbs. Julia programmers
    are free to write methods that act upon any combination of types and to create
    new types at will, without friction.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 那些有过类基础的面向对象语言（如Python）经验的人，在尝试理解Julia中的用户自定义复合类型时，有时会暂时处于不利地位。当面对一个新概念时，我们通常会倾向于将其与我们熟悉的概念联系起来。Julia中的复合类型并不是类；Julia没有类，显然也没有类继承。在面向对象语言中，下一步通常是定义作为类一部分的方法：名词和动词被绑定在一起。而更加灵活的多重分发范式则将名词和动词解耦。Julia程序员可以自由地编写作用于任何类型组合的方法，并且可以随意创建新类型，没有任何摩擦。
- en: '***Defining structs with Base.@kwdef***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Base.@kwdef定义结构体***'
- en: 'The default method for defining composite types leaves a bit to be desired.
    Its main deficiency is that the constructor it creates requires the programmer
    to remember the order in which a type’s fields appear in its definition. The `Base.@kwdef`
    macro improves on this limitation by creating constructors that we can use with
    field names. For repeated use, it’s convenient to import this macro and rename
    it: `import Base.@kwdef as @kwdef`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 定义复合类型的默认方法还有些不足。其主要缺点是它创建的构造函数要求程序员记住类型字段在定义中的顺序。`Base.@kwdef`宏通过创建可以使用字段名的构造函数来改进这个限制。为了便于重复使用，可以导入这个宏并重新命名为：`import
    Base.@kwdef as @kwdef`。
- en: Let’s expand our geometry package with a new type representing ellipses as shown
    in [Listing 8-5](ch08.xhtml#ch8lis5). This time we’ll use `@kwdef`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过引入一个新的类型表示椭圆，来扩展我们的几何学包，如[示例 8-5](ch08.xhtml#ch8lis5)所示。这次我们将使用`@kwdef`。
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Listing 8-5: Defining an* Ellipse *type with* @kwdef'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-5：使用* @kwdef *定义一个* Ellipse *类型*'
- en: 'This definition shows the second convenient feature of `@kwdef`: we can supply
    default values for fields. We also have the option to define a mutable struct
    with `@kwdef mutable struct`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义展示了`@kwdef`的第二个便利功能：我们可以为字段提供默认值。我们还可以选择使用`@kwdef mutable struct`定义一个可变的结构体。
- en: 'Let’s make an ellipse and assign it to a variable:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个椭圆并将其赋值给一个变量：
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This example shows how we can supply a subset of the type’s keyword arguments,
    and the ones we omit will get their default arguments. As with functions, any
    keyword argument without a default in the type definition must be supplied when
    using the constructor. Also, similarly to functions, we may not mix positional
    and keyword forms:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何为类型的关键词参数提供一个子集，未提供的参数将使用默认值。与函数类似，类型定义中没有默认值的任何关键词参数在使用构造函数时必须提供。另外，与函数类似，我们不能混合使用位置参数和关键词参数：
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As there is no drawback to using `@kwdef` when defining composite types, it’s
    convenient to use it routinely.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在定义复合类型时使用`@kwdef`没有缺点，因此通常使用它非常方便。
- en: Because of the way Julia’s JIT compiler works with the type system, computing
    with user-defined types is as fast as using native types. We can work at a higher
    level of abstraction, creating a set of types that naturally conform to the objects
    in our problem, without any compromise in performance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Julia的JIT编译器与类型系统的工作方式，使用用户自定义类型进行计算与使用原生类型一样快。我们可以在更高的抽象层次上工作，创建一组自然符合我们问题对象的类型，而不必在性能上做出妥协。
- en: '**Performance Tips**'
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**性能提示**'
- en: Speed and efficiency are often of great concern in scientific programming. While
    Julia generally produces performant code without requiring extreme expertise or
    knowledge of internals, good performance does sometimes depend on an awareness
    of the compilation process.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学编程中，速度和效率通常是非常重要的关注点。虽然Julia通常可以在不需要极端专业知识或了解内部机制的情况下生成高效的代码，但良好的性能有时仍然依赖于对编译过程的理解。
- en: I’ve included topics related to performance in various places throughout this
    book. Here we’ll learn about several such issues specifically related to types.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书的多个地方讨论了与性能相关的话题。在这里，我们将专门了解几个与类型相关的问题。
- en: '***Vanquish Type Instability***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***消除类型不稳定性***'
- en: '*Type stability* is perhaps the single most important performance-related concept
    in Julia. Its central principle is that the return values of functions should
    have types we can predict based on the types of the arguments supplied to the
    function. The returned type should not depend on the *values* of the arguments.
    A secondary issue is that the local variables used within a function should not
    change type.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型稳定性*也许是Julia中与性能相关的最重要概念。它的核心原则是，函数的返回值类型应该根据传递给函数的参数类型来预测。返回类型不应依赖于参数的*值*。其次，函数内部使用的局部变量类型也不应发生变化。'
- en: Suppose we want to have a function for dividing two numbers that would return
    `0` when the denominator is `0`, rather than `Inf`. [Listing 8-6](ch08.xhtml#ch8lis6)
    shows one way to write such a function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个除法函数，当分母为`0`时返回`0`，而不是`Inf`，[清单 8-6](ch08.xhtml#ch8lis6)展示了一种编写此类函数的方法。
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Listing 8-6: This function needs improving.*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-6：此函数需要改进。*'
- en: 'It certainly seems to work as intended:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它似乎确实按预期工作：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, the sharp-eyed programmer may notice that in the first case, the function
    returns a `Float64`, whereas in the second case it returns an `Int64`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，细心的程序员可能会注意到，在第一个例子中，函数返回的是`Float64`，而在第二个例子中返回的是`Int64`：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The types of the arguments in both cases are integers, but the types of the
    results depend on their values. This type instability may not matter. However,
    an insidious problem is lurking, as one day we may pull out our `safe_divide()`
    function to use within some other program where its varying return type affects
    performance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 两种情况下参数的类型都是整数，但结果的类型取决于它们的值。这种类型不稳定性可能并不重要。然而，一个潜在的问题在于，某一天我们可能会把`safe_divide()`函数提取到其他程序中使用，而它不同的返回类型可能会影响性能。
- en: 'In more complicated functions, the type instability may not be so obvious.
    In situations where performance or memory consumption makes us wonder whether
    one of our functions may have such an issue, Julia provides a convenient tool
    for ferreting out type instability: the `@code_warntype` macro. Let’s use it on
    our `safe_divide()` function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的函数中，类型不稳定性可能不那么明显。在性能或内存消耗让我们怀疑某个函数可能存在此类问题时，Julia提供了一个方便的工具来查找类型不稳定性：`@code_warntype`宏。我们可以在`safe_divide()`函数上使用它：
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is one of several macros and functions available for use in the REPL that
    display a translated version of a Julia function. The `@code_warntype` macro prints
    a *lowered form* of the code: a representation of the computation in terms of
    a smaller set of operations. It is one of four stages of code transformation beginning
    with our Julia source and ending with machine code specific to the processor we’re
    running on. This lowered form is similar to the version that is sent to the compiler,
    but it contains the type information that we can examine when debugging performance
    issues. Other than that, it’s not particularly useful and not intended for routine
    human consumption.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在REPL中可用的多个宏和函数之一，用于显示Julia函数的翻译版本。`@code_warntype`宏打印出一个*降级形式*的代码：这是一种将计算表示为更小操作集的形式。它是代码转换的四个阶段之一，从我们的Julia源代码开始，最终生成特定于我们运行的处理器的机器代码。这种降级形式类似于发送给编译器的版本，但它包含了我们可以在调试性能问题时检查的类型信息。除此之外，它并不特别有用，也不适合日常人类使用。
- en: 'When printed in the REPL, type information that indicates a possible type stability
    issue is displayed in red type, which I’ve converted to bold for printing in the
    book. The bold fragment indicates that the return type can be either a `Float64`
    or an `Int64`: in other words, it’s not determined from the types of the input
    arguments. This is the signature of a type-unstable function.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当在REPL中打印时，表示可能存在类型稳定性问题的类型信息会以红色显示，我已将其转为粗体以便在书中打印。粗体部分表明返回类型可能是`Float64`或`Int64`：换句话说，它并不由输入参数的类型决定。这是一个类型不稳定函数的标志。
- en: 'Fortunately, this case has a simple fix:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种情况有一个简单的修复方法：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Since `a/b` is always a float, even if `a` and `b` are integers, we can ensure
    that the function always returns a float by replacing the integer `0` with `0.0`
    ➊.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`a/b`总是一个浮动数值，即使`a`和`b`是整数，我们可以通过将整数`0`替换为`0.0` ➊，确保函数始终返回浮动数值。
- en: 'To confirm whether we’ve fixed the type instability problem, let’s turn to
    `@code_warntype` again:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们是否解决了类型不稳定性问题，让我们再次使用`@code_warntype`：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This time, there are no red (bold) warnings, and the macro confirms ➊ that the
    return type is always a `Float64`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有红色（加粗）警告，宏确认➊返回类型始终是`Float64`。
- en: '**NOTE**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The output from* @code_warntype *often also includes yellow warnings involving
    unions with the* Nothing *type, which is used when a function does not return
    a result. These are not usually considered type instabilities.*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*@code_warntype的输出*通常还包括与*Nothing*类型联合的黄色警告，Nothing类型表示函数没有返回结果。这些通常不被认为是类型不稳定。'
- en: 'We can also correct this type stability problem by defining the function using
    a type declaration:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用类型声明定义该函数来修正这个类型稳定性问题：
- en: '[PRE72]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This version, when called with `b = 0`, will convert its return value to `0.0`.
    It will always return a `Float64`; `@code_warntype` will verify its type stability.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本在调用时，`b = 0`会将返回值转换为`0.0`。它将始终返回`Float64`；`@code_warntype`将验证其类型稳定性。
- en: Although the form of the code returned by `@code_warntype` can be difficult
    to parse, it’s fairly simple to use it to scan for type stability problems.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`@code_warntype`返回的代码形式可能很难解析，但用它来扫描类型稳定性问题其实很简单。
- en: '***Avoid Changing the Types of Variables***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***避免更改变量类型***'
- en: 'Let’s write a function to approximate π using the Leibniz sum:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个函数，使用莱布尼茨求和公式来近似π：
- en: '![Image](../images/math245.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/math245.jpg)'
- en: 'This is not a good way to get the digits of π, as it converges quite slowly,
    but it’ll be useful for our demonstration. One version of the function might be:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不是获取π的好方法，因为它收敛得很慢，但它对我们的演示很有用。该函数的一个版本可能是：
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This works as intended; [Figure 8-4](ch08.xhtml#ch8fig4) shows its output gradually
    converging to the correct value for π.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这按预期工作；[图8-4](ch08.xhtml#ch8fig4)显示它的输出逐渐收敛到正确的π值。
- en: '![Image](../images/ch08fig04.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig04.jpg)'
- en: '*Figure 8-4: The Leibniz sum approximation to π*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-4：莱布尼茨求和公式对π的近似值*'
- en: 'This function is clearly not type-unstable in the sense used earlier: the output
    is always a `Float64`, regardless of the number supplied as an argument.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数显然不属于之前提到的类型不稳定的情况：无论传递什么数字作为参数，输出始终是`Float64`。
- en: 'Nevertheless, taking a look at the output of `@code_warntype` indicates a problem:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，查看`@code_warntype`的输出会发现一个问题：
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Once again, the warnings are rendered in bold. They inform us that the local
    variable `s` is a union of the types `Float64` and `Int64`, rather than a single
    numerical type. This happens because we initialize it as a literal integer, `0`,
    but then use it in a loop that causes Julia to promote it to a float.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 再次出现的警告以加粗字体显示。它们告知我们，局部变量`s`是`Float64`和`Int64`类型的联合体，而不是单一的数值类型。这是因为我们将它初始化为字面整数`0`，但在循环中使用时，导致Julia将其提升为浮动类型。
- en: Changing the type of a local variable may prevent the compiler from optimizing
    our code as well as it could otherwise. This is a common mistake, as the pattern
    of initializing variables and then using them in a `for` loop is routine. When
    doing so, we should take care to initialize them with types appropriate to the
    arithmetic in the loop.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 更改局部变量的类型可能会导致编译器无法充分优化我们的代码。这是一个常见的错误，因为初始化变量并在`for`循环中使用它们的模式是日常操作。当这样做时，我们应该小心使用适合循环中算术运算的类型来初始化这些变量。
- en: 'This case is also easy to fix:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题也很容易修复：
- en: '[PRE75]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As before, we simply have to replace `0` with `0.0` ➊. I won’t reproduce the
    (mostly redundant) output here, but checking with `@code_warntype` shows that
    the warnings are gone.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所述，我们只需将`0`替换为`0.0` ➊。我不会在这里重复（大多数是冗余的）输出，但使用`@code_warntype`检查显示警告已经消失。
- en: '**Type Aliases**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**类型别名**'
- en: 'Several types have alternative names, called *type aliases*. The use of aliases
    is for convenience; they are typically shorter names or dispense with the indication
    of the machine’s pointer size. For example, on a 64-bit computer, `Int` is another
    name, or alias, for `Int64`, but on a 32-bit machine, `Int` means `Int32`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 多种类型有替代名称，称为*类型别名*。使用别名是为了方便；它们通常是更短的名称，或者省略了机器指针大小的表示。例如，在64位计算机上，`Int`是`Int64`的另一个名称或别名，但在32位机器上，`Int`表示`Int32`：
- en: '[PRE76]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This shows that, at least on my computer, `Int` is another name for `Int64`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，至少在我的计算机上，`Int`是`Int64`的另一个名称。
- en: 'We can create our own type aliases:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的类型别名：
- en: '[PRE77]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here we’ve created an alternative name for the default floating-point type.
    After this definition, we can use `F64` and `Float64` interchangeably.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们为默认的浮动点类型创建了一个替代名称。定义之后，我们可以将`F64`和`Float64`互换使用。
- en: Defining type aliases as `const` is not required, but it makes sense, as they
    are additional names for something that will not change.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型别名为`const`并不是必须的，但这样做是有意义的，因为它们是不会改变的某些事物的额外名称。
- en: '**Parametric Types**'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数化类型**'
- en: A parametric type is a type made from pieces that themselves can be of several
    possible types. The parameters are variables that vary with the types of the pieces.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型是由多个组成部分构成的类型，这些组成部分本身可以是几种可能类型中的任何一种。参数是随着组成部分类型变化而变化的变量。
- en: '[Listing 8-7](ch08.xhtml#ch8lis7) shows an example of a parametric type that
    we’ve already encountered, the type used for complex numbers.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-7](ch08.xhtml#ch8lis7)展示了我们已经遇到的一个参数化类型——用于复数的类型。'
- en: '[PRE78]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '*Listing 8-7: The types of some complex numbers*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-7：一些复数的类型*'
- en: The curly brackets (`{}`) in the type names indicate that we’re dealing with
    *parametric types*. In the first line, we’ve asked for the type of a complex number
    that’s written using integer literals for each coefficient. The response indicates
    that the number is `Complex` with an `Int64` parameter; this parameter is the
    type of the coefficients.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 类型名称中的花括号（`{}`）表示我们正在处理*参数化类型*。在第一行中，我们请求的是一个使用整数字面量表示每个系数的复数类型。响应表明该复数是`Complex`类型，且参数为`Int64`；这个参数即系数的类型。
- en: The second line tells us something similar, but this time the complex number
    has floating-point coefficients. In addition, we learn about an alias for the
    type.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行告诉我们类似的信息，但这次复数具有浮点系数。此外，我们还了解了该类型的别名。
- en: The fact that there is only one parameter within the curly brackets suggests
    that both coefficients must have the same type. This is indeed true; mixing literal
    floats and integers causes an automatic conversion of the integer coefficient
    to a `Float64` coefficient ➊.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号内只有一个参数，表明两个系数必须具有相同的类型。这个确实成立；将浮点数和整数混合会导致整数系数自动转换为`Float64`系数 ➊。
- en: In the final example, we’ve created a complex number with `Rational` coefficients.
    This time the parameter is itself a parametric type. Rational numbers can be composed
    of any integers. The `Rational{Int64}` notation means that the numerator and denominator
    are `Int64`s rather than, for example, `Int32`s.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们创建了一个具有`Rational`系数的复数。这次参数本身就是一个参数化类型。有理数可以由任何整数组成。`Rational{Int64}`表示分子和分母是`Int64`类型，而不是例如`Int32`类型。
- en: 'Collection types, such as `Array`, are defined as parametric types because
    they can hold elements of various types:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型，如`Array`，被定义为参数化类型，因为它们可以包含不同类型的元素：
- en: '[PRE79]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The use of aliases is common for collection types, as in these examples. We
    see here that `Array` is a parametric type with two parameters: the first is the
    type of the array’s elements, and the second is the number of dimensions.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 别名的使用在集合类型中很常见，如这些示例所示。我们看到，`Array`是一个参数化类型，有两个参数：第一个是数组元素的类型，第二个是维度的数量。
- en: The `where` keyword creates a `UnionAll` type, a union of many types, each defined
    by assigning a particular type to the type variable `T`. One example of this is
    the notation `AbstractArray{T, 1}`, where `T` denotes an abstract type that is
    the union of `AbstractArray{Int64, 1}`, `AbstractArray{Float64, 1}`, and so on.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`关键字创建了一个`UnionAll`类型，它是许多类型的联合，每个类型通过将特定类型分配给类型变量`T`来定义。一个例子是`AbstractArray{T,
    1}`，其中`T`表示一个抽象类型，它是`AbstractArray{Int64, 1}`、`AbstractArray{Float64, 1}`等的联合。'
- en: 'We can create our own parametric types for the same reason we create any type:
    to organize our methods with the help of the type system and multiple dispatch.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的参数化类型，原因与我们创建任何类型的原因相同：通过类型系统和多重分派来组织我们的方法。
- en: 'Let’s revisit our `Ellipse` type from [Listing 8-5](ch08.xhtml#ch8lis5) and
    make a parametric version of it:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[示例 8-5](ch08.xhtml#ch8lis5)中的`Ellipse`类型，并将其转化为一个参数化版本：
- en: '[PRE80]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now the fields can be any type, as long as they are both the same type:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，字段可以是任何类型，只要它们都是相同的类型：
- en: '[PRE81]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'After defining a new `CEllipse`, the REPL tells us the type, with `Float64`
    substituted in place of the parameter `T`. Our attempt to give the fields two
    different types failed because they are both `T` in the type definition. `T` can
    be anything, but the definition requires that both axes have the same type, so
    the final example is accepted. But what does it mean to have an ellipse with arbitrary
    strings for the axes? It’s up to us. We are creating types for our own purposes,
    to organize our projects. If we prefer to limit the `CEllipse` type to have numerical
    values for the axes, we can use the subtyping operator:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了一个新的 `CEllipse` 后，REPL 会告诉我们类型，并将 `Float64` 代入参数 `T`。我们尝试给字段设置两种不同类型失败了，因为它们在类型定义中都是
    `T`。`T` 可以是任何类型，但定义要求两条坐标轴具有相同类型，因此最终的示例被接受。但是，坐标轴是任意字符串的椭圆意味着什么呢？这由我们自己决定。我们在为自己的目的创建类型，以组织我们的项目。如果我们希望限制
    `CEllipse` 类型的坐标轴只能是数值类型，可以使用子类型操作符：
- en: '[PRE82]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Before defining this struct, if we’re working in the REPL, we’re obligated to
    begin a new session if the previous definition of `CEllipse` is still active.
    Another option would be to name it differently.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义这个结构体之前，如果我们在 REPL 中工作，并且之前的 `CEllipse` 定义仍然有效，我们必须开始一个新的会话。另一种选择是给它起一个不同的名字。
- en: 'Now a `CEllipse` can have two axes of the same type, and that type can be anything,
    as long as it’s a subtype of `Number`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个 `CEllipse` 可以有两条相同类型的坐标轴，而且这个类型可以是任何类型，只要它是 `Number` 的子类型：
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Since we make `T` a subtype of `Number`, rather than a subtype of the more
    specific `Real`, we are allowing the possibility of ellipses with complex-valued
    axes. In some cases, our functions for calculating properties of ellipses will
    need methods specialized for this case. For an example, let’s write a function
    that returns the eccentricity of an ellipse. This is a measure of how elongated
    the ellipse is, where an eccentricity of 0 is a circle. If *a* is the longer of
    the two axes and *b* is the shorter, the eccentricity is given by:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 `T` 定义为 `Number` 的子类型，而不是更具体的 `Real` 的子类型，因此我们允许具有复数坐标轴的椭圆的可能性。在某些情况下，我们计算椭圆属性的函数需要专门处理这种情况。举个例子，我们写一个返回椭圆偏心率的函数。这是一个衡量椭圆拉长程度的指标，其中偏心率为
    0 时是圆形。如果 *a* 是两轴中较长的，*b* 是较短的，那么偏心率由以下公式给出：
- en: '![Image](../images/250math.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/250math.jpg)'
- en: 'Here’s a direct translation of this formula into a Julia function:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将此公式直接转化为 Julia 函数的例子：
- en: '[PRE84]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This definition works for real-valued axes, so to ensure that the function accepts
    only such ellipses, its type parameter specifies subtypes of `Real`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义适用于实数坐标轴，因此，为了确保该函数仅接受此类椭圆，它的类型参数指定了 `Real` 的子类型。
- en: We can visualize an ellipse with complex-valued axes as lying in the complex
    plane. We can define ellipses this way as long as we ensure that their axes are
    perpendicular.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将具有复数坐标轴的椭圆视为位于复平面内。只要确保它们的坐标轴是垂直的，我们就可以这样定义椭圆。
- en: 'Let’s make a method of our eccentricity function that handles these ellipses:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的偏心率函数编写一个处理这些椭圆的方法：
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `abs()` function, when handed a complex number, returns its length. We use
    the `<:` operator in the type parameter slot to include every possible kind of
    complex number.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`abs()` 函数在接收一个复数时返回它的长度。我们在类型参数位置使用 `<:` 操作符来包含所有可能的复数类型。'
- en: 'We know a bit more about ellipses with complex axes: not merely their eccentricities,
    but their orientations. [Figure 8-5](ch08.xhtml#ch8fig5) shows an ellipse in the
    complex plane.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对具有复坐标轴的椭圆了解得更多：不仅是它们的偏心率，还有它们的方向。[图 8-5](ch08.xhtml#ch8fig5) 显示了复平面中的椭圆。
- en: '![Image](../images/ch08fig05.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig05.jpg)'
- en: '*Figure 8-5: An ellipse in the complex plane*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：复平面中的椭圆*'
- en: Its axes, represented by dotted lines, are 2 + 2*i* and *−*1 + *i*. We’ll define
    the orientation as the angle that its major (longer) axis makes with the real
    axis, shown in the figure by *α*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 它的坐标轴，由虚线表示，是 2 + 2*i* 和 *−*1 + *i*。我们将定义其方向为主轴（较长轴）与实轴之间的角度，如图中所示的 *α*。
- en: 'Here’s the program that created the illustration in [Figure 8-5](ch08.xhtml#ch8fig5):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成[图 8-5](ch08.xhtml#ch8fig5)插图的程序：
- en: '[PRE86]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Remember, in `Luxor` the vertical coordinate goes from the top down, opposite
    to the conventional direction in mathematical diagrams.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 `Luxor` 中，垂直坐标是从上到下的，方向与数学图表中的常规方向相反。
- en: 'This function calculates the orientation of an ellipse with complex axes:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算具有复数坐标轴的椭圆的方向：
- en: '[PRE87]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Since no orientation can be defined for an ellipse with axes given only by real-number
    lengths, `orientation()` will have just this one method. The `angle()` function
    returns a complex number’s phase angle; it’s equivalent to `atan(imag(a)/real(a))`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法为仅由实数长度给定的椭圆轴定义方向，`orientation()`函数将只有这一种方法。`angle()`函数返回一个复数的相位角；它等价于`atan(imag(a)/real(a))`。
- en: 'Let’s define an ellipse with complex axes and calculate its eccentricity and
    orientation:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个具有复数轴的椭圆，并计算其偏心率和方向：
- en: '[PRE88]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This ellipse corresponds to [Figure 8-5](ch08.xhtml#ch8fig5). The `orientation()`
    function returns its result in radians, so for good measure, we’ve converted that
    to degrees in the final expression.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个椭圆对应于[图 8-5](ch08.xhtml#ch8fig5)。`orientation()`函数以弧度为单位返回结果，因此为了更加直观，我们在最终表达式中将其转换为度数。
- en: Parametric types make Julia’s rich type system even more flexible and expressive.
    Like the other parts of the type system, we’re not required to use any of it in
    our own programs, but a little bit can go a long way in helping with code organization,
    reuse, and efficiency. Finally, a basic knowledge of parametric types is essential
    in understanding the messages and information that Julia sends to us, and in reading
    language and package documentation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型使得Julia的强大类型系统更加灵活和富有表现力。像类型系统的其他部分一样，我们在自己的程序中不必使用任何参数化类型，但稍微使用一些可以大大帮助代码的组织、重用和效率提升。最后，了解基本的参数化类型对于理解Julia向我们传递的消息和信息，以及阅读语言和包的文档至关重要。
- en: '**Plot Recipes**'
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绘图配方**'
- en: As authors of programs, modules, and perhaps packages, we should expect to create
    our own data types routinely. There is no performance penalty for using custom
    data types in Julia, and they are essential for writing concise, well-organized
    code and for taking the best advantage of multiple dispatch.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序、模块甚至包的作者，我们应该期望定期创建自己的数据类型。在Julia中使用自定义数据类型不会产生性能惩罚，而且它们对于编写简洁、结构良好的代码以及充分利用多重分派至关重要。
- en: In [Part II](part2.xhtml) of this book we’ll explore various packages from the
    Julia scientific ecosystem. Many of these packages define one or a variety of
    data types that describe the objects they manipulate. These objects include audio
    signals, solutions to differential equations, images, measurements with uncertainties,
    entire environments housing interacting creatures, the creatures themselves, and
    much more. We’ll discover that we can use the plotting commands from [Chapter
    4](ch04.xhtml) to visualize these data structures directly, with no preprocessing
    needed on our part. How is it possible that `Plots` knows what to do with all
    these different data types?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第二部分](part2.xhtml)中，我们将探索来自Julia科学生态系统的各种包。这些包中的许多定义了一种或多种数据类型，用来描述它们所操作的对象。这些对象包括音频信号、微分方程的解、图像、带有不确定性的测量、包含互动生物的完整环境、生物本身等等。我们将发现，使用[第4章](ch04.xhtml)中的绘图命令，我们可以直接可视化这些数据结构，而无需做任何预处理。那么，`Plots`是如何知道如何处理这些不同的数据类型的呢？
- en: Visualization is an essential part of scientific computation. The plot *recipe*
    system is how we hook our data types into Julia’s plotting system, that is, how
    we teach it to handle and display our custom objects. The authors of the scientific
    packages that we use in [Part II](part2.xhtml) did not have to touch the code
    in the `Plots` package, which in turn doesn’t need to know anything about the
    new data types. Plot recipes insert data transformations into the plotting *pipeline*,
    so existing plotting functions can handle our data types as if they were the familiar
    arrays of numbers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是科学计算的重要组成部分。绘图*配方*系统是我们将数据类型与Julia的绘图系统连接起来的方式，也就是我们教它如何处理和显示我们自定义的对象。在我们[第二部分](part2.xhtml)中使用的科学包的作者们并不需要修改`Plots`包中的代码，而`Plots`包也无需了解这些新的数据类型。绘图配方将数据转换插入到绘图*管道*中，使得现有的绘图函数能够像处理常见的数字数组一样处理我们的数据类型。
- en: The result is that users of our programs need simply call `plot()`, `scatter()`,
    or another plotting function on the new data type to get a reasonable visual representation.
    We can also define entirely new plotting functions for more elaborate visualizations.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们的程序用户只需对新数据类型调用`plot()`、`scatter()`或其他绘图函数，就能得到合理的可视化表示。我们还可以为更复杂的可视化定义全新的绘图函数。
- en: 'We need a specific application in mind to make the operation of plot recipes
    clear. Let’s imagine that we’re creating a program that has something to do with
    the weather, and create some simple data types for representing daily temperature
    and rainfall data:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Our temperature data, we’ll suppose, comes to us as two measurements per day,
    representing that day’s minimum and maximum temperatures. We’ll store these measurements
    in a vector of tuples ➊, one tuple per day, containing the temperature extrema.
    That vector of tuples, along with a string holding the temperature unit, are packaged
    together in the TempExtremes data type.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: That data type is put next to a vector of rainfall measurements in another data
    type called `WeatherData`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: A third data type, `WeatherReport`, contains the `WeatherData` along with some
    notes, a pair of numbers (latitude and longitude) for the location of the measurements,
    and the date recording when the series of measurements begin.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we make instances of these three data types to have something to plot:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `randn()` function produces normally distributed (see “The Normal Distribution”
    on [page 323](ch10.xhtml#ch10lev1sec3)) fake random temperature and rain data.
    Earlier we imported the `Date` module so we can use one of its data types to define
    a starting date.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '***The Plotting Pipeline***'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The recipe system consists of a series of four recipe varieties that get processed
    in order in the plotting pipeline, as shown in [Listing 8-8](ch08.xhtml#ch8lis8).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '*Listing 8-8: The plotting pipeline*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Each recipe type transforms its input and passes it to the next stage in the
    pipeline; these transformations are indicated after the recipe names. The built-in
    plotting functions generally know how to plot arrays of numbers, so the plotting
    recipes have to transform our custom types into ordinary arrays. The first two
    recipe types, user recipes and type recipes, can do this. The final two recipe
    types take numerical arrays and produce *series*, which are the components of
    plots that represent individual vectors, which may be extracted from matrix columns
    (in one dimension).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The user and plot recipes can also create layouts and set overall plot properties.
    We don’t need to define every one of these recipes, and generally won’t require
    all of them for any particular plotting task. Any that we *have* defined we can
    use separately, or as part of the pipeline, for different purposes. In this discussion,
    we’ll start at the end of the pipeline and work our way toward the beginning,
    defining recipes as we go. In this way, each example recipe will do something
    when we call it directly, passing information along to the previously defined
    recipes to produce a plot.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '***The Series Recipe***'
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define recipes with the `@recipe` macro, exported by the `RecipesBase` package.
    The macro decorates a function definition where the name of the function is arbitrary.
    The function’s signature determines the type of recipe created. In the following
    listing, we create two series recipes. The signature, a type followed by three
    additional positional arguments `x`, `y`, and `z`, tells the pipeline that these
    are series recipes. As always, the keyword arguments are not part of the function
    signature for dispatch. Referring to [Listing 8-8](ch08.xhtml#ch8lis8), we see
    that these recipes will accept numerical arrays and create series:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To define recipes, we need only import `RecipesBase`. This is important because
    it means that packages can define plotting behaviors without a dependence on the
    large `Plots` package. `RecipesBase` is tiny, containing only about 400 lines
    of Julia.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Plot recipes defined using the `@recipe` macro use several special-purpose syntax
    conveniences. The `:=` operator ➊ makes a setting in the `plotattributes` dictionary,
    which holds attributes such as line color—all the options for the plot. Here we
    set the `seriestype` in the attribute dictionary to `:line`. This is the default
    series type, which creates a continuous line through the plotted points. Another
    option is `:scatter`, for plotting individual marks. In fact, the familiar `scatter()`
    function is a shorthand for `plot(; seriestype=:scatter)`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The `-->` operator ➌ also makes settings in the `plotattributes` dictionary,
    but, in this case, defers to settings made in keyword arguments previously in
    the pipeline. In a sense, these are optional, whereas settings we make with `:=`
    are important for the series under construction.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Next we have a `for` loop that divides the input `y` vector into segments of
    `cycle` elements and calculates extrema and an average for each segment. It inserts
    `NaN`s after each segment to separate them in the plot.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Next come three blocks preceded by the `@series` macro ➋. Each `@series` block
    creates a new series for the plot. In this case, each will be a `:line` series,
    since we make that setting outside the blocks, but in general, they can be of
    different types. They can also create a series type unknown to `Plots`, in which
    case the pipeline will pass the data on to the recipe where the new series is
    defined. There can be a chain of series recipes of any length. The data will pass
    through each in turn until a recipe creates a series type known to the backend
    in use.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe is designed to accept an *N*×2 matrix. It will plot each of
    the two columns as lines, the first in blue and the second in red. It will fill
    the space between the two lines using the `fillrange` attribute. This presents
    a small problem, as we need to refer to the first column to define the `fillrange`
    when plotting the second, but the pipeline starts afresh for each column in the
    input data. However, we know which column we’re on by referring to the `:series_plotindex`
    key in the attribute dictionary. One way to pass information between different
    columns is to stuff it into the `:extra_kwargs` entry in the attribute dictionary
    ➍. We call our new attribute `:nextfr`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配方设计用于接受*Ｎ*×2矩阵。它将绘制两个列，每列作为线条，第一列为蓝色，第二列为红色。它将使用`fillrange`属性填充这两条线之间的区域。这提出了一个小问题，因为我们需要引用第一列来定义绘制第二列时的`fillrange`，但是管道对于输入数据中的每一列都会重新开始。然而，我们可以通过引用属性字典中的`:series_plotindex`键来知道当前处理的是哪一列。传递不同列之间信息的一种方法是将其塞入属性字典中的`:extra_kwargs`条目➍。我们将新属性命名为`:nextfr`。
- en: 'Although we have in mind the weather data types defined previously, these recipes
    don’t know anything about that. Like all series recipes, they can plot any arrays
    of numbers. For actual plotting, we need to import `Plots`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们心里有之前定义的天气数据类型，但这些配方并不知晓这些数据类型。像所有系列配方一样，它们可以绘制任何数字数组。对于实际绘图，我们需要导入`Plots`：
- en: '[PRE93]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `@shorthands` macro, provided by `RecipesBase`, takes the names in the function
    signatures of recipes and makes function names that we can call directly to make
    plots. For each one, it makes two functions, one for creating a new plot and one
    for adding to an existing plot, just like `plot()` and `plot!()`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`@shorthands`宏由`RecipesBase`提供，它获取配方函数签名中的名称，并生成可以直接调用的函数名称，用于绘制图表。对于每一个，它都会生成两个函数，一个用于创建新图表，另一个用于向现有图表添加内容，就像`plot()`和`plot!()`一样。'
- en: After transforming the temperature data in `wd` to a matrix, we can use the
    shorthand on it directly, creating [Figure 8-6](ch08.xhtml#ch8fig6).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`wd`中的温度数据转换为矩阵后，我们可以直接对其使用简写，创建[图 8-6](ch08.xhtml#ch8fig6)。
- en: '![Image](../images/ch08fig06.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig06.jpg)'
- en: '*Figure 8-6: A* fillrange *plot created by a series recipe*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：由系列配方创建的填充范围*图'
- en: For [Figure 8-7](ch08.xhtml#ch8fig7), we call `ebxbox()` on the rainfall vector.
    It only plots the extrema and mean bars, so we add a normal plot of the vector
    using `plot!()`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图 8-7](ch08.xhtml#ch8fig7)，我们对降水量向量调用`ebxbox()`。它只绘制极值和均值条，因此我们使用`plot!()`添加该向量的常规图表。
- en: '![Image](../images/ch08fig07.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig07.jpg)'
- en: '*Figure 8-7: A plot using the* ebxbox *series recipe*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：使用*ebxbox*系列配方的图表*'
- en: We can use these series recipes in other programs and as components within other
    pipelines.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在其他程序中使用这些系列配方，也可以作为其他管道中的组件。
- en: '***The Plot Recipe***'
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘图配方***'
- en: 'The type of recipe called a *plot recipe* (not to be confused with the general
    concept) also transforms series into other series or numerical data into series,
    as do series recipes, but can create complete visualizations containing subplots
    and other elements as well. Like all recipes, it’s identified by its particular
    function signature:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一种称为*绘图配方*的配方（不要与通用概念混淆）也会将系列转换为其他系列或将数值数据转换为系列，和系列配方一样，但它可以创建包含子图和其他元素的完整可视化。像所有配方一样，它由其特定的函数签名来标识：
- en: '[PRE94]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The recipe takes input data in the form of an *N*×3 matrix. It uses a `frames`
    attribute, which we invented for the purpose, to decide whether to place all the
    series in one plot or to use two subplots ➋, one with temperature and the other
    with rainfall. (As in the case of the series recipes, this recipe knows nothing
    of our weather-related data types, so we can repurpose it to plot other types
    of data as well.)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方接收*Ｎ*×3矩阵形式的输入数据。它使用我们为此目的发明的`frames`属性来决定是将所有系列放置在一个图中，还是使用两个子图➋，一个显示温度，另一个显示降水量。（与系列配方的情况一样，这个配方对我们的天气相关数据类型一无所知，因此我们也可以将其重新用于绘制其他类型的数据。）
- en: The `cycle` variable sets the length of the segments used for calculating extrema
    and averages in the third column of the input data, which we intend to use for
    the rainfall data. We use 7 as a default value for this keyword argument, for
    weekly summaries. If, however, we supply the parameter when calling the recipe
    directly or upstream in the pipeline, we override the default by reading its value
    from the `plotattributes` dictionary ➊.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle`变量设置用于计算输入数据中第三列的极值和平均值的段长度，我们打算将其用于降水量数据。我们为此关键字参数使用7作为默认值，表示每周汇总。然而，如果我们在直接调用配方时或在管道的上游提供该参数，我们会通过从`plotattributes`字典中读取其值来覆盖默认值
    ➊。'
- en: The three `@series` blocks handle the first two columns, containing temperature
    minimums and maximums, and the rainfall in the third column. The temperature `@series`
    block sets the series type to `temprange` ➌, which won’t work unless we’ve already
    defined a series recipe for it, as we did previously.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 三个`@series`块处理前两列，包含最低和最高温度，以及第三列中的降水量。温度的`@series`块将系列类型设置为`temprange` ➌，除非我们已经为其定义了系列配方，否则该设置不起作用，正如我们之前所做的那样。
- en: The purpose of this recipe, then, is to use the visualizations defined in our
    series recipes to create a graph with either one or two subplots, with labels
    appropriate for either case. We can also call it directly, as shown in [Listing
    8-9](ch08.xhtml#ch8lis9).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个配方的目的是使用我们在系列配方中定义的可视化效果，创建一个带有一个或两个子图的图表，并且根据情况设置适当的标签。我们也可以直接调用它，如[清单
    8-9](ch08.xhtml#ch8lis9)所示。
- en: '[PRE95]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '*Listing 8-9: Calling the plot recipe with array data*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-9：使用数组数据调用绘图配方*'
- en: But we’ll defer this for now.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们现在先搁置这个问题。
- en: '***Type Recipes***'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型配方***'
- en: 'Referring back to [Listing 8-8](ch08.xhtml#ch8lis8), we can see that *type
    recipes* are the first recipes in the pipeline that can accept user-defined types.
    They’re the simplest class of recipe. They have one job: to transform user types
    into numerical arrays that the functions from `Plots` can plot directly, or that
    can be fed into the following steps in the pipeline.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[清单 8-8](ch08.xhtml#ch8lis8)，我们可以看到*类型配方*是管道中第一个可以接受用户自定义类型的配方。它们是最简单的一类配方。它们的任务很简单：将用户类型转换为可以直接由`Plots`中的函数绘制的数值数组，或者可以输入到管道中的后续步骤。
- en: 'The following listing defines two type recipes; they’re recognized as such
    by their particular function signatures:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单定义了两个类型配方；它们通过其特定的函数签名被识别为类型配方：
- en: '[PRE96]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The first recipe takes instances of the `*TempExtremes*` type defined previously
    and returns a matrix with two columns; the second transforms `WeatherData` into
    a three-column matrix.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个配方获取先前定义的`*TempExtremes*`类型的实例，并返回一个包含两列的矩阵；第二个配方将`WeatherData`转换为一个三列矩阵。
- en: 'After defining these recipes, we can now plot either of these types directly
    by calling `plot(td)` or `plot(wd)`. If we do so, we’ll get simple line plots
    of the columns: two from the first call and three from the second, as in [Figure
    8-8](ch08.xhtml#ch8fig8).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些配方后，我们现在可以直接通过调用`plot(td)`或`plot(wd)`来绘制这两种类型中的任意一种。如果这样做，我们将得到简单的折线图：第一次调用得到两列数据，第二次调用得到三列数据，如[图
    8-8](ch08.xhtml#ch8fig8)所示。
- en: '![Image](../images/ch08fig08.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig08.jpg)'
- en: '*Figure 8-8: Plotting directly from a type recipe*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：直接从类型配方绘图*'
- en: We call `plot(wd)` to produce [Figure 8-8](ch08.xhtml#ch8fig8). The top two
    lines are the temperature extrema and the bottom line is the rainfall.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`plot(wd)`来生成[图 8-8](ch08.xhtml#ch8fig8)。前两条线是温度极值，底部的线是降水量。
- en: If, instead, we call `weatherplot(wd)`, we get the exact same plot that would
    result from the call in [Listing 8-9](ch08.xhtml#ch8lis9) because the type recipe
    transforms `wd` into a three-column matrix. [Figure 8-9](ch08.xhtml#ch8fig9) shows
    the result.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为调用`weatherplot(wd)`，我们将得到与[清单 8-9](ch08.xhtml#ch8lis9)中调用的结果完全相同的图，因为类型配方将`wd`转换为一个三列矩阵。[图
    8-9](ch08.xhtml#ch8fig9)显示了结果。
- en: '![Image](../images/ch08fig09.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch08fig09.jpg)'
- en: '*Figure 8-9: A plot recipe called on user data transformed by a type recipe*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-9：在由类型配方转换的用户数据上调用的绘图配方*'
- en: Here the plot recipe assembles the two types of visualizations, defined in series
    recipes, onto a single plot, and adds a label on the vertical axis. Since we don’t
    define `frames`, we get the default single frame.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，绘图配方将两种类型的可视化效果（在系列配方中定义）组装到一个图表中，并在垂直轴上添加标签。由于我们没有定义`frames`，因此会得到默认的单帧。
- en: '***User Recipes***'
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户配方***'
- en: Now we’ve ascended to the top of the pipeline. The *user recipes* accept not
    only single user types, but any combination of types, with each different signature
    creating a new method for dispatch. They can emit array data or other types, but
    if they emit types other than array data we must have defined a type recipe to
    transform them.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Such is the case with the following user recipe:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The pipeline will see this as a user recipe because of its signature. It takes
    an instance of the `WeatherReport` data type, creates a title from its `notes`
    field, and constructs a useful label for the x-axis by referring to the `start`
    field. It has a single `@series` block, to which it passes the `data` field. The
    series invoked is the plot recipe `weatherplot`, but the `data` field is not an
    array, it’s `WeatherData`. The next step in the pipeline, the type recipes, handles
    any type conversions. Here the `WeatherData` instance is transformed into a three-column
    matrix that is handed off to the `weatherplot` recipe, which optionally sets up
    the subplots and passes the matrix columns to the series recipes. Calling `plot(wr;
    frames=2)` invokes this recipe and creates [Figure 8-10](ch08.xhtml#ch8fig10).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig10.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: The result of calling the user recipe*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user recipe teaches the `plot()` function how to handle a new data
    type. As we’ve seen throughout this section, we can enter the plotting pipeline
    at any point for a different result, or reuse any of these recipes as part of
    different pipelines for handling different types of data.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '***The @userplot Macro***'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `RecipesBase` package also exports the `@userplot` macro, which is convenient
    for defining a visualization without having to define a new data type:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The first line after the import creates a new type and a shorthand using its
    lowercase name. The user recipe that we define using the name of the type is invoked
    using the shorthand name. Inside the recipe, we can access plot data using the
    `args` property ➊. The `@userplot` is useful when we want a shorthand name for
    a particular visualization for an existing type. In this case, we want to plot
    complex numbers by separating their real and imaginary parts, which may be more
    useful than the default treatment given them by `plot()`. After defining the recipe,
    we can invoke it directly using its name as in the last line. The `expint()` function
    is an exponential integral from the `SpecialFunctions` package, parameterized
    by its first argument. With the parameter here, it maps real numbers to complex
    numbers. The result appears in [Figure 8-11](ch08.xhtml#ch8fig11).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig11.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: Using @userplot to render a vector of complex numbers*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `@userplot` macro to create alternative visualizations for
    user-defined types by using type aliases or subtyping.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this survey of the most important practical aspects of the type system,
    our introduction to the Julia language is complete. The ideas in this chapter
    and the preceding ones will find concrete application in the chapters of [Part
    II](part2.xhtml), where we’ll put Julia to work to solve real problems in a variety
    of fields.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对类型系统最重要实践方面的概述，我们对 Julia 语言的介绍已告一段落。本章以及前面的章节中的思想将在[第二部分](part2.xhtml)的章节中得到具体应用，我们将在那里利用
    Julia 来解决各个领域中的实际问题。
- en: This book’s division into language learning and application sections isn’t a
    strict one, however. We’ve seen several useful applications in the preceding chapters,
    and the chapters in [Part II](part2.xhtml) will introduce various programming
    techniques and Julia features in places where they can be immediately applied
    and more readily appreciated in the context of solving problems.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书将语言学习与应用部分的划分并不是严格的。在前面的章节中，我们已经看到了一些有用的应用，而在[第二部分](part2.xhtml)的章节中，我们将介绍各种编程技巧和
    Julia 特性，并在实际应用和解决问题的背景下更好地理解它们。
- en: '**FURTHER READING**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: Details on performance implications of one form of type instability are available
    at [*https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable*](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable).
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于一种类型不稳定形式对性能影响的详细信息，请访问[*https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable*](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable)。
- en: 'Dr. Chris Rackauckas gives an example of when dynamic dispatch is a net win
    here: [*https://discourse.julialang.org/t/why-type-instability/4013/8*](https://discourse.julialang.org/t/why-type-instability/4013/8).
    This is a case where type instability is beneficial.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dr. Chris Rackauckas 讲解了动态分派在以下情况下如何带来净收益：[ *https://discourse.julialang.org/t/why-type-instability/4013/8*](https://discourse.julialang.org/t/why-type-instability/4013/8)。这是一个类型不稳定性有益的案例。
- en: Interesting information about π in Julia is available at [*https://julialang.org/blog/2017/03/piday/*](https://julialang.org/blog/2017/03/piday/).
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 π 在 Julia 中的有趣信息，请访问[*https://julialang.org/blog/2017/03/piday/*](https://julialang.org/blog/2017/03/piday/)。
- en: My attempt to explain multiple dispatch using an extended recipe analogy is
    available at [*https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/*](https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/).
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我尝试通过扩展的食谱类比来解释多重分派的文章可以在[*https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/*](https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/)找到。
- en: For a detailed tutorial about optimization and the type system, visit [*https://huijzer.xyz/posts/inference/*](https://huijzer.xyz/posts/inference/).
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于优化和类型系统的详细教程，请访问[*https://huijzer.xyz/posts/inference/*](https://huijzer.xyz/posts/inference/)。
- en: 'Here is a package for nice visualization of type hierarchies: [*https://github.com/claytonpbarrows/D3TypeTrees.jl*](https://github.com/claytonpbarrows/D3TypeTrees.jl).'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个用于类型层次结构可视化的包：[ *https://github.com/claytonpbarrows/D3TypeTrees.jl*](https://github.com/claytonpbarrows/D3TypeTrees.jl)。
- en: 'Another approach to finding and fixing type instabilities is offered by the
    `Cthulhu` package: [*https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/*](https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/).'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种查找和修复类型不稳定性的方法是由`Cthulhu`包提供的：[ *https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/*](https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/)。
