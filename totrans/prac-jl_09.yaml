- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: THE TYPE SYSTEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统**
- en: '*Object-oriented programming is an exceptionally bad idea which could only
    have originated in California.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程是一个极其糟糕的想法，只有在加利福尼亚才能诞生。**'
- en: —Edsger Dijkstra
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —埃兹格·迪克斯特拉
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Up to now we’ve been using and creating a lot of functions. We can think of
    functions as the verbs of the Julia language. And just as in natural languages,
    verbs act on nouns. The nouns in Julia are numbers, collections, strings, and
    other instances of types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用并创建了很多函数。我们可以将函数看作是 Julia 语言中的动词。正如在自然语言中，动词作用于名词一样，Julia 中的名词包括数字、集合、字符串以及其他类型的实例。
- en: 'We’ve encountered many data types in our journey up to this point: different
    varieties of numbers, strings, characters, and collections such as arrays and
    maps. Although our focus hasn’t been on types, it’s impossible to talk much about
    Julia programming without making some reference to them. Julia is unusual in that
    it allows us to create very fast code without having to specify the types of variables,
    unlike other fast languages such as Fortran (where the specifications can be implicit)
    and C. However, effective Julia programming requires some knowledge of its type
    system. The main reason for this is that Julia programs are organized around functions
    and methods through its dispatch system, which relies on argument types. A secondary
    reason has to do with those occasions where an awareness of types allows us to
    write more efficient programs. This chapter covers both of these concerns.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在学习过程中遇到了许多数据类型：不同种类的数字、字符串、字符，以及像数组和映射这样的集合。尽管我们的重点并不是类型，但在谈论 Julia
    编程时，无法不提及它们。Julia 的特别之处在于，它允许我们在不指定变量类型的情况下创建非常快速的代码，这与其他快速语言（如 Fortran（其中类型规格可以是隐式的）和
    C）不同。然而，要有效地编写 Julia 程序，还是需要了解它的类型系统。这样做的主要原因是，Julia 程序是围绕函数和方法组织的，依赖于其分发系统，而该系统依赖于参数类型。其次，了解类型有助于我们编写更高效的程序。本章将涵盖这两个方面的问题。
- en: '**Types in Practice**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践中的类型**'
- en: Rather than delve into the abstract theory of type systems, let’s approach types
    from a practical point of view.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与其深入探讨类型系统的抽象理论，不如从实际的角度来看待类型。
- en: 'To find the type of any value, Julia provides the `typeof()` function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出任何值的类型，Julia 提供了 `typeof()` 函数：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve already considered the difference between strings and characters, and
    the related difference between single and double quotes; however, it’s important
    to have some understanding of the various numeric types. Although, for example,
    `17`, `17//1`, and `17.0` have the same values, they are different types of objects,
    and their behavior is potentially different. The difference in their types reflects
    this reality.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过字符串和字符之间的区别，以及单引号和双引号的相关区别；然而，理解各种数值类型同样很重要。例如，`17`、`17//1` 和 `17.0`
    具有相同的值，但它们是不同类型的对象，它们的行为可能不同。它们类型的差异反映了这一现实。
- en: The curly brackets used in reporting the type of a rational number ➊ indicate
    that this is a *parametric type*, a topic we’ll return to in “Parametric Types”
    on [page 248](ch08.xhtml#ch08lev6). For now, it’s sufficient to understand that
    this is a `Rational` made up of `Int64` pieces.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告有理数类型时使用的花括号 ➊ 表明这是一个 *参数化类型*，我们将在“参数化类型”一节中（[第 248 页](ch08.xhtml#ch08lev6)）回到这个话题。现在，理解这是由
    `Int64` 组成的 `Rational` 类型就足够了。
- en: 'The type reported for the floating-point literal is `Float64`, which means
    it’s a floating-point number, or a number with a decimal point, and that it’s
    stored in a 64-bit segment of memory. The 64 bits are apportioned as follows:
    1 for the sign, 11 for the exponent, and 52 for the “fraction.” The maximum absolute
    value of a `Float64` is about 10^(300), and it has 17 significant digits, or 16
    digits of precision beyond the decimal point. (This agrees with the observation
    that it takes three binary digits to represent a decimal digit.) We can see this
    using the `@printf` macro, supplied by the `Printf` package:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动小数点字面量的类型是 `Float64`，这意味着它是一个浮动小数，或者说是带有小数点的数字，并且它被存储在一个 64 位的内存段中。这 64 位被分配如下：1
    位表示符号，11 位表示指数，52 位表示“分数”。`Float64` 的最大绝对值大约是 10^(300)，并且它具有 17 位有效数字，或者说是小数点后
    16 位的精度。（这与观察结果一致，即表示一个十进制数字需要三个二进制数字。）我们可以通过 `Printf` 包提供的 `@printf` 宏来看到这一点：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This shows incorrect digits appearing if we ask for more than 16.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求超过 16 位的数字，将会显示错误的数字。
- en: 'We’ll see more incorrect digits if we use floating-point types with lower precision:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用精度较低的浮点类型，将会看到更多不正确的数字：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we used the names of the types as functions to cast their arguments to
    the named types. Without the cast, expressions like `1/3` are `Float64` by default
    on most systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将类型名称作为函数来将它们的参数转换为命名类型。如果不进行类型转换，像`1/3`这样的表达式在大多数系统上默认是`Float64`类型。
- en: The default integer type on typical systems, `Int64`, ranges between *−*2^(63)
    and 2^(63) *−* 1, with one bit used for the sign.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型系统上，默认的整数类型`Int64`的范围是*−*2^(63)到2^(63) *−* 1，其中一个位用于符号位。
- en: 'Julia supplies built-in functions for finding the maximum and minimum values
    representable with each numeric type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了内建函数，用于查找每种数值类型所能表示的最大值和最小值：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But `typemax()` and `typemin()` aren’t very helpful if we ask them about floats:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们询问浮点数，`typemax()`和`typemin()`并不太有用：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Apparently infinity is a floating-point number, and Julia has infinities for
    each size float. This is consistent: since nothing is larger than infinity, if
    `Inf16` is a `Float16` it must be the largest possible `Float16`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，无穷大是一个浮点数，而Julia为每种浮点数大小提供了无穷大。这是自洽的：因为没有什么比无穷大更大，所以如果`Inf16`是`Float16`，它必须是最大可能的`Float16`。
- en: 'Julia has another function that comes to the rescue here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Julia还有另一个函数可以在这里提供帮助：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The functions `floatmax()` and `floatmin()` return the maximum *finite* float
    and the minimum positive float of the requested type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`floatmax()`和`floatmin()`分别返回所请求类型的最大*有限*浮点数和最小正浮点数。
- en: Usually we should perform arithmetic in our programs using these *native types*,
    which are the most efficient choices. If needed, and if possible, we can use smaller
    numbers to save space—for example, `Int16`—and we can get larger integers using
    `Int128`. However, if the native types are not adequate for our purposes, it’s
    usually because we need a lot of precision—in other words, many digits—in our
    computation. This is the subject of the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该在程序中使用这些*原生类型*进行算术运算，因为它们是最有效的选择。如果需要，而且可能的话，我们可以使用更小的数字来节省空间——例如`Int16`——并且我们可以使用`Int128`来获取更大的整数。然而，如果原生类型不能满足我们的需求，通常是因为我们需要大量的精度——换句话说，很多位数字——来进行计算。这是下一节的主题。
- en: 'To check whether a particular value has a certain type, use the `isa()` function.
    We can use it as a normal function or in infix position:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查某个值是否具有特定类型，可以使用`isa()`函数。我们可以将其用作普通函数或在中缀位置使用：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function returns a Boolean value. The first two calls return `true` because
    `17` is both an `Int64` and a `Number`. The former implies the latter (see “The
    Type Hierarchy” on [page 222](ch08.xhtml#ch08lev1sec4)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个布尔值。前两个调用返回`true`，因为`17`既是`Int64`也是`Number`。前者意味着后者（参见[第222页](ch08.xhtml#ch08lev1sec4)的“类型层次结构”）。
- en: '***“Big” and Irrational Types***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***“大”与无理类型***'
- en: 'Julia makes it easy to perform *arbitrary precision arithmetic* using types
    whose precision grows as needed: where the number of digits can grow without bound.
    Arithmetic with these types is slower than normal computation with native types,
    but for some jobs it’s the only choice.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Julia使得使用精度根据需要增长的类型进行*任意精度算术运算*变得简单：这些类型的数字位数可以无限增加。使用这些类型的算术运算比使用原生类型的正常计算要慢，但对于某些任务，它是唯一的选择。
- en: '**Arbitrary Precision**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**任意精度**'
- en: 'As a simple example of where we would need arbitrary precision types, suppose
    we want to graph the factorial function. This is the function usually spelled
    with an exclamation mark:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为需要任意精度类型的一个简单示例，假设我们想要绘制阶乘函数。这就是通常用感叹号表示的函数：
- en: '![Image](../images/math217.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/math217.jpg)'
- en: 'The corresponding Julia function is `factorial(n)`. The function grows extremely
    quickly:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的Julia函数是`factorial(n)`。该函数增长得非常快：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This shows that 20 is the largest factorial that fits in an `Int64`. We can
    go up to 33! if we use `Int128`, but what if we want to go bigger?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了20是可以适应`Int64`的最大阶乘。如果我们使用`Int128`，可以达到33!，但如果我们想要更大呢？
- en: The error message provides a hint. The `big()` function converts its argument
    to a corresponding type with unlimited size and precision. For integers, this
    is called `BigInt`, and for floats it’s `BigFloat`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息提供了一个线索。`big()`函数将其参数转换为具有无限大小和精度的对应类型。对于整数，这叫做`BigInt`，而对于浮点数则是`BigFloat`。
- en: 'Let’s use `BigInt` to make a plot of the factorial function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`BigInt`来绘制阶乘函数：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we’re plotting up to 50!, which is far beyond what can fit in a native
    integer. [Figure 8-1](ch08.xhtml#ch8fig1) shows the result.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们绘制的是最大到50!，这远远超出了本地整数能表示的范围。[图8-1](ch08.xhtml#ch8fig1)展示了结果。
- en: '![Image](../images/ch08fig01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig01.jpg)'
- en: '*Figure 8-1: The factorial function calculated using BigInt*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：使用 BigInt 计算的阶乘函数*'
- en: We’ll revisit the factorial in “Factorials” on [page 312](ch10.xhtml#ch10lev1sec1),
    where it appears as the number of ways to permute *n* objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“阶乘”一节中重新讨论阶乘，参考 [第312页](ch10.xhtml#ch10lev1sec1)，其中它作为排列 *n* 个对象的方式数量出现。
- en: 'The `BigFloat` type also offers unlimited magnitude. Its default precision
    is 256, giving us about 80 significant digits. We can set the `BigFloat` precision
    to be anything we need, using the `setprecision()` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigFloat` 类型也提供无限的大小。它的默认精度是 256，约为 80 位有效数字。我们可以使用 `setprecision()` 函数将 `BigFloat`
    的精度设置为任何需要的值：'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To retrieve the precision, we have the `precision()` function, which accepts
    the type that we’re asking about:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索精度，我们可以使用 `precision()` 函数，传入我们要查询的类型：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The number of digits used for a `BigInt` grows as needed, so it doesn’t come
    with the concept of a fixed precision applicable to the floating-point numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInt` 类型的数字所使用的位数会根据需要增加，因此它没有像浮点数那样固定的精度概念。'
- en: '**Irrationals**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**无理数**'
- en: 'An unusual attribute of Julia is the existence of the *irrational type*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的一个独特属性是存在 *无理数类型*：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The number represented by the Greek letter π is printed with three dots appended
    to suggest that there is more to the story. Although it appears to be a floating-point
    number, its type is not given as `Float64`, but as something new: `Irrational`.
    That’s because in Julia, π represents *not* a floating-point number, but the *exact
    value* of the ratio of a circle’s circumference to its diameter. The three dots
    remind us that the digits presented are simply the first few in an endless, nonrepeating
    series.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 希腊字母 π 所表示的数字打印时附带三个点，提示我们这只是故事的一部分。虽然它看起来像一个浮点数，但它的类型并非 `Float64`，而是一个新的类型：`Irrational`。这是因为在
    Julia 中，π 表示的*不是*浮点数，而是圆周率与直径的比值的*精确值*。这三个点提醒我们，展示的数字仅仅是这个无限、不重复序列的前几位。
- en: 'Julia calculates and presents more digits as and when needed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 会根据需要计算并展示更多数字：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The number is not printed with trailing dots, as it’s no longer a representation
    of an exact value, but an approximation to it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该数字不会以尾部点的形式显示，因为它不再是精确值的表示，而是对精确值的近似。
- en: 'Several other irrational numbers are built into Julia; the most important of
    these for general purposes is *e*, the base of the natural logarithms. To insert
    this character, which is the Unicode codepoint 212F (Script Small E), enter \euler
    and press TAB in the REPL:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个无理数被内建到 Julia 中；其中最重要的无理数是 *e*，自然对数的底数。要插入该字符，可以输入 Unicode 码点 212F（Script
    Small E），在 REPL 中输入 \euler 并按 TAB 键：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with π, Julia displays the value of *e* with three trailing dots to indicate
    that it’s showing us a few digits of an exact value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像π一样，Julia 用三个点显示 *e* 的值，表示它正在展示一个精确值的部分数字。
- en: We can see an approximation to *e* ➊ to any desired number of digits by converting
    it to a `BigFloat`. By definition, the value of the natural logarithm of *e* is
    exactly the integer 1 ➋, but if we take the logarithms of approximations to *e*,
    we get an approximate, or floating-point, result.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 *e* 转换为 `BigFloat` 来查看它的任何所需精度的近似值 ➊。根据定义，*e* 的自然对数的值恰好是整数 1 ➋，但如果我们取
    *e* 的近似值的对数，我们将得到一个近似值，或者说是浮点数结果。
- en: '***Type Promotion***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型提升***'
- en: 'When performing arithmetic on a mixture of different numerical types, Julia
    will silently *promote* types as needed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在对不同数值类型的混合进行算术运算时，Julia 会根据需要默默地 *提升* 类型：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The addition of two integers provides no reason to leave integer land, so the
    result is also an `Int64`. But if one of the numbers is a `Float64`, the other
    is promoted to that type, which is also the type of the result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 两个整数相加时没有理由离开整数领域，因此结果也是一个 `Int64`。但是，如果其中一个数字是 `Float64`，另一个数字会被提升到该类型，结果的类型也将是该类型。
- en: 'Julia will not promote nonnumerical types to numbers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 不会将非数值类型提升为数字：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Its treatment of types and promotion is therefore similar to Python and dissimilar
    from JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它对类型和提升的处理方式因此类似于 Python，而不同于 JavaScript。
- en: 'The `promote()` function takes any number of numerical arguments and returns
    a tuple with (possibly) some of them promoted as necessary to give them all a
    common type so they can be used in subsequent calculations without further promotion.
    It performs the same promotions as would be performed automatically when doing
    arithmetic:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`promote()`函数可以接受任意数量的数字参数，并返回一个元组（可能）将其中的一些参数提升为必要的共同类型，以便它们可以在后续的计算中使用，而无需再次提升。它执行的提升操作与进行算术运算时自动执行的提升操作相同：'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The promotion in the first line shows how some numbers (2.0, 3.5) have an exact
    binary representation, but others (3.4) do not. The two following commands provide
    examples of how `promote()` converts its arguments to a common type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行中的提升展示了某些数字（如2.0、3.5）具有精确的二进制表示，而其他一些数字（如3.4）则没有。接下来的两个命令示例展示了`promote()`如何将其参数转换为共同类型。
- en: '***Collections***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合***'
- en: 'Julia prints the types of collections in the REPL when printing their values
    more often than it announces simple numerical types, so we’ve seen more of the
    former:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Julia在REPL中打印集合的类型时，比打印简单的数字类型更频繁，因此我们已经看到更多前者：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Julia prints the type of collection (`Matrix`, `Vector`, or `Array`) and its
    dimensions. A `Vector` is one-dimensional, and a `Matrix` is two-dimensional.
    For the more general `Array` type, Julia prints an integer showing the number
    of dimensions: here it’s a three-dimensional array ➊.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Julia打印集合的类型（`Matrix`、`Vector`或`Array`）及其维度。`Vector`是一维的，`Matrix`是二维的。对于更通用的`Array`类型，Julia会打印一个整数，显示维度数：这里是一个三维数组➊。
- en: 'It also indicates the types of the collection’s elements inside curly brackets.
    We can extract this information separately using the `eltype()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会显示集合元素的类型，并在花括号内显示。我们可以使用`eltype()`函数单独提取这些信息：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the first example, the result, `Int64`, is the type of both elements of
    the array. The second example shows how Julia promotes numerical types when possible
    to create homogeneous arrays, which are more efficient to calculate with. However,
    when confronted with types where no promotion is possible ➊, the element type
    becomes `Any`: a type that literally means any type.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，结果`Int64`是数组中两个元素的类型。第二个示例展示了Julia如何在可能的情况下提升数字类型，以创建同质数组，这样可以更高效地进行计算。然而，当遇到无法进行提升的类型时➊，元素类型会变成`Any`：这个类型字面意思是任何类型。
- en: 'These results follow the behavior of the `promote()` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果遵循`promote()`函数的行为：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If elements can be promoted to a common type, that type is used for the `eltype`
    of the collection; otherwise, the `Any` type is used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素可以提升为一个共同类型，则该类型会被用作集合的`eltype`；否则，使用`Any`类型。
- en: 'The collection types `Vector`, `Matrix`, and `Array` have some behaviors in
    common: for example, they can all be indexed. This is not true of all collections,
    however. The `Set` type has no ordering, hence no ability to be indexed. These
    three collection types share certain behaviors because they’re special cases of
    a more general type, a concept that we’ll explore in the next section.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型`Vector`、`Matrix`和`Array`有一些共同的行为：例如，它们都可以被索引。然而，并非所有集合类型都有这种特性。`Set`类型没有顺序，因此无法进行索引。这三个集合类型之所以共享某些行为，是因为它们是更通用类型的特殊情况，这一概念我们将在下一节中探讨。
- en: '***The Type Hierarchy***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型层次结构***'
- en: All types in Julia are *subtypes* of types that are their *supertypes.* The
    one type that has no strict supertype is the `Any` type, which is its own supertype.
    The concepts of supertypes and subtypes are connected with the inheritance of
    behaviors, and the configuration of the type hierarchy is usually intuitive when
    applied to particular cases. For example, we expect that any kind of number will
    support some notion of addition. Exactly what addition means may vary among various
    species of numbers—addition of complex numbers is a generalization of addition
    of real numbers, for example—but when we encounter a type that is a subtype of
    the `Number` type, we can be confident that, at least, the `+` operator is defined
    for it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的所有类型都是*子类型*，它们的*超类型*则是某个类型的上级。唯一没有严格超类型的类型是`Any`类型，它是自己的超类型。超类型和子类型的概念与行为的继承相关，类型层次结构的配置在应用于特定情况时通常是直观的。例如，我们期望任何种类的数字都会支持某种加法运算。尽管不同种类的数字的加法含义可能有所不同——例如复数加法是实数加法的一种推广——但当我们遇到`Number`类型的子类型时，我们可以确信，至少`+`运算符是为它定义的。
- en: As shown in [Listing 8-1](ch08.xhtml#ch8lis1), the `supertype()` function, when
    supplied a type, returns its supertype.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 8-1](ch08.xhtml#ch8lis1)所示，`supertype()` 函数在提供一个类型时，返回它的超类型。
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-1: Walking up the type hierarchy*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：向上遍历类型层次结构*'
- en: The `typeof()` function returns the type of a literal value or variable. The
    types that we actually compute with, such as `Float64` and `Int64`, are called
    *concrete types*. Concrete types are leaves at the tips of the tree of types;
    they can not subtype each other.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof()` 函数返回字面值或变量的类型。我们实际进行计算的类型，如 `Float64` 和 `Int64`，被称为*具体类型*。具体类型是类型树的叶子节点；它们不能互相作为子类型。'
- en: '[Listing 8-1](ch08.xhtml#ch8lis1) shows a series of calls to `supertype()`
    to find where the default integer type, `Int64`, lies in the type hierarchy. All
    of the types that concrete types such as `Int64` inherit from are *abstract types*.
    The purpose of abstract types, such as `Number`, is simply to create nodes in
    the tree of types to enable the definition of methods. The function of these abstract
    types, and the type hierarchy that they constitute, is not to make things more
    complicated, but to make the life of the Julia programmer easier. Because of the
    tree of types, we can define functions and methods that operate at the ideal level
    of abstraction, as we’ll see in “Functions and Methods: Multiple Dispatch” on
    [page 229](ch08.xhtml#ch08lev2).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch8lis1)展示了一系列对 `supertype()` 的调用，用于找出默认整数类型 `Int64` 在类型层次结构中的位置。像
    `Int64` 这样的具体类型所继承的所有类型都是*抽象类型*。抽象类型，如 `Number`，的作用仅仅是创建类型树中的节点，以便定义方法。这些抽象类型及其构成的类型层次结构，并不是为了使事情更加复杂，而是为了让
    Julia 程序员的工作更加轻松。由于类型树的存在，我们可以在理想的抽象层次上定义函数和方法，正如我们将在《函数和方法：多重分发》一章的[第 229 页](ch08.xhtml#ch08lev2)中看到的那样。'
- en: The final two lines in [Listing 8-1](ch08.xhtml#ch8lis1) show that `Number`
    is at the top of the hierarchy of numerical types, and its supertype, `Any`, is
    the root of the entire hierarchy, and, as the last line shows, is its own supertype.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch8lis1)的最后两行显示，`Number` 位于数值类型层次结构的顶部，而它的超类型 `Any` 是整个层次结构的根，正如最后一行所示，`Any`
    还是它自己的超类型。'
- en: By making more calls to `supertype()`, we can explore more of the type tree.
    [Listing 8-2](ch08.xhtml#ch8lis2) shows a modification of the program in [Listing
    7-3](ch07.xhtml#ch7lis3) to visualize a section of it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多次调用 `supertype()`，我们可以探索更多的类型树。[清单 8-2](ch08.xhtml#ch8lis2)展示了对[清单 7-3](ch07.xhtml#ch7lis3)程序的修改，用于可视化它的一部分。
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-2: Visualizing part of the type hierarchy*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：可视化部分类型层次结构*'
- en: We’ve collected a handful of mostly numeric types in the `sometypes` vector.
    These are a subset of the total number of types that come with Julia and its standard
    library, and many more are defined in various packages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `sometypes` 向量中收集了一些主要的数值类型。这些是 Julia 及其标准库提供的类型的子集，更多类型定义在各种包中。
- en: '[Listing 8-2](ch08.xhtml#ch8lis2) uses the `supertype()` function to create
    the edges ➊ of the tree graph, connecting each type to its supertype. [Figure
    8-2](ch08.xhtml#ch8fig2) shows the result.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](ch08.xhtml#ch8lis2)使用 `supertype()` 函数来创建树图的边 ➊，将每个类型与其超类型连接。[图 8-2](ch08.xhtml#ch8fig2)展示了结果。'
- en: '![Image](../images/ch08fig02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch08fig02.jpg)'
- en: '*Figure 8-2: The relationships among a few types*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：几种类型之间的关系*'
- en: '[Figure 8-2](ch08.xhtml#ch8fig2) makes it clear that `Any` is the root of the
    tree and reminds us that, for example, characters and strings are distinct types.
    But it also obscures certain relationships, such as that some types are aliases
    of others. This is a topic we’ll explore later in this chapter (see “Type Aliases”
    on [page 247](ch08.xhtml#ch08lev5)).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](ch08.xhtml#ch8fig2)清晰地显示了 `Any` 是树的根，并提醒我们，例如，字符和字符串是不同的类型。但它也模糊了一些关系，比如某些类型是其他类型的别名。这是我们将在本章后面（参见“类型别名”章节，位于[第
    247 页](ch08.xhtml#ch08lev5)）进一步探讨的内容。'
- en: 'Two additional functions that are handy for exploring the type hierarchy are
    `subtypes()`, which returns a vector of all the *immediate* subtypes of the type
    supplied as an argument, and `supertypes()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个方便探索类型层次结构的函数是 `subtypes()`，它返回作为参数传入的类型的所有*直接*子类型的向量，以及 `supertypes()`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example shows that `supertypes()` returns a tuple containing the type supplied
    and all of its supertypes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了 `supertypes()` 返回一个元组，包含传入的类型及其所有的超类型。
- en: '***Type Assertions and Declarations***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型断言和声明***'
- en: Now we know how to discover the type of any variable and the supertype of any
    type. On occasion, we also need to tell Julia that a variable is of a particular
    type (a *type declaration*), or that the value of an expression should have a
    specified type (a *type assertion*). The `::` operator performs either operation,
    depending on where it occurs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Assertions**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes in our programs we reach a point where it is important to ensure that
    the value of a particular expression has a certain type. If it does not, we want
    to generate an error, which we can either handle or allow to halt the program.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest expression in Julia is a literal value. Let’s use `17` as our
    first example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line is an assertion that `17` has the `Number` type, which of course
    it does. An expression with a type assertion attached returns the value of the
    expression if the assertion is true, so here Julia simply returns `17`. The following
    two lines are also true assertions. A type assertion is true if it specifies any
    supertype of the type of the expression.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The final type assertion returns an error because `17` is neither a `String`
    nor a subtype of the `String` type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how we might use a type assertion in a program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The program asks the user a question, receives the reply using `readline()`,
    and joins it with two other strings to construct a greeting, which it returns.
    We used a type assertion ➊ to ensure that the type returned by the function is
    what is expected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Declarations**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We also use the `::` operator for type declarations. Its meaning is determined
    from its position within a statement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare that a variable has a particular type in two ways. One way is
    to supplement the usual assignment statement with a declaration, as in this example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here the assignment and the type declaration happen simultaneously.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*Julia v1.8 was the first version that allowed type declarations of global
    variables; this makes working in the REPL more convenient. In earlier versions,
    all type declarations must occur in a local scope.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we declare the type of a variable, we are committed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As this example shows, an attempt to assign a value of the wrong type to a declared
    variable, or to explicitly change its type, results in an error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Any value assigned to `a` must be convertible to `a`’s type, `Int16`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The second assignment failed because 32,768 is larger than the largest value
    that an `Int16` can hold, which is 2^(15)−1 = 32,767, returned by `typemax(Int16)`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-3](ch08.xhtml#ch8lis3) shows the other way to declare a type: as
    part of a `local` or `global` definition.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-3: Type declarations*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We define `gf` to be global and to have the `Float64` type. Julia seems happy
    to let us assign a literal integer to it, but it has converted the value to a
    `Float64` as part of the assignment ➊. Because there is no way to convert a literal
    string to a `Float64`, our attempt to assign a string to the variable failed ➋.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We can use a variable of the same name, declared to be local, inside a function
    ➍ ; this local variable has no relationship with the global `gf`. The function
    `weather_report()` expects a `Bool` from the user (`true` or `false`), and uses
    it to construct a sentence about the weather. It uses the `isa` operator to check
    that it’s received the correct type ➌.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数内使用相同名称的局部变量，并声明为局部变量➍；这个局部变量与全局变量 `gf` 没有任何关系。函数 `weather_report()`
    期望从用户那里得到一个 `Bool` 类型的值（`true` 或 `false`），并用它来构建一个关于天气的句子。它使用 `isa` 操作符来检查是否收到了正确的类型
    ➌。
- en: 'The following short program illustrates an important behavior of type declarations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这个简短的程序演示了类型声明的一个重要行为：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running this function produces the output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个函数会产生以下输出：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The line that prints the type of `a` comes *before* the type declaration; so
    why is `a` already an `Int16`? After all, this is what happens in the REPL:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `a` 类型的那一行出现在类型声明的*之前*；那么为什么 `a` 已经是一个 `Int16` 类型了呢？毕竟，在 REPL 中会发生这样的情况：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This output is what we expect, as the concrete type `Int64` is the native integer
    on a 64-bit machine, which is the most common architecture. The explanation is
    that a type declaration within a scope block, in this case a function definition,
    enforces an unchangeable type for the entire block. The declaration can occur
    anywhere within the block.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出是我们预期的，因为 `Int64` 类型是 64 位机器上原生的整数类型，而 64 位架构是最常见的架构。解释是，作用域块中的类型声明（在本例中是函数定义）强制整个块内类型不可更改。声明可以在块的任何位置出现。
- en: 'In the absence of a declaration, a variable *can* change type within a block
    as a consequence of arithmetic operations:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有声明，一个变量*可以*在块内通过算术运算改变类型：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function produces the output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会产生如下输出：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Allowing this to happen can interfere with performance, a topic we return to
    in “Vanquish Type Instability” on [page 242](ch08.xhtml#ch08lev1sec13).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 允许这种情况发生可能会影响性能，关于这一点我们将在“消除类型不稳定性”一节中讨论，详见 [page 242](ch08.xhtml#ch08lev1sec13)。
- en: 'The `::` operator can also declare the type of the value returned by a function.
    For example, we can change the first line of the definition of `weather_report()`
    in [Listing 8-3](ch08.xhtml#ch8lis3) as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`::` 操作符还可以声明函数返回值的类型。例如，我们可以像这样修改 [Listing 8-3](ch08.xhtml#ch8lis3) 中 `weather_report()`
    定义的第一行：'
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This asserts that the function must return a `String` value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句声明函数必须返回一个 `String` 类型的值。
- en: 'The purpose of such declarations is the same as type declarations for variables:
    they are never required, and usually not needed, but in some cases they can provide
    extra information to the compiler that helps with performance. We’ll see some
    examples of this in “Performance Tips” on [page 242](ch08.xhtml#ch08lev4). When
    we construct expressions using functions, it’s helpful to know the types returned
    by each function call; using type declarations in function definitions assists
    in writing correct and efficient programs.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明的目的与变量的类型声明相同：它们从不强制要求，通常也不需要，但在某些情况下，它们可以为编译器提供额外的信息，从而帮助提高性能。我们将在“性能优化”一节中看到一些例子，详见
    [page 242](ch08.xhtml#ch08lev4)。当我们使用函数构造表达式时，知道每个函数调用返回的类型是很有帮助的；在函数定义中使用类型声明有助于编写正确且高效的程序。
- en: '**Functions and Methods: Multiple Dispatch**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数和方法：多重分派**'
- en: 'When we define a function in the REPL, if there are no errors, we’ll see a
    message like the one we saw after the definition of `weather_report()` in [Listing
    8-3](ch08.xhtml#ch8lis3):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 REPL 中定义一个函数时，如果没有错误，我们会看到类似我们在 [Listing 8-3](ch08.xhtml#ch8lis3) 中看到的消息：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A generic function is defined by its name, in this case `weather_report()`.
    Each generic function can have any number of *methods* associated with it, which
    are distinguished by their method *signatures*. The signature is the part that
    goes inside the parentheses when you define the method. Up until now, these signatures
    have included the names of positional and keyword arguments and their default
    values, if any. If we make a second definition of `weather_report()` with a different
    set of arguments in its signature, we will have created a second method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用函数由它的名称定义，在本例中是 `weather_report()`。每个通用函数可以有任意数量的*方法*与之关联，这些方法通过它们的方法*签名*来区分。签名是定义方法时，放在括号内的部分。到目前为止，这些签名包含了位置参数和关键字参数的名称及其默认值（如果有的话）。如果我们使用不同的参数集合重新定义
    `weather_report()`，我们就创建了一个第二个方法。
- en: A further use of the `::` operator is within method signatures, to specify the
    types that the arguments therein are supposed to have. Two definitions, both with
    the same arguments, define different methods if any of these type specifications
    are different, even if the signatures are otherwise the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler sees a function call, it invokes the method with the most
    specific definition that matches the arguments supplied in the call. Here is where
    we see the real purpose of the abstract types that we learned about in “The Type
    Hierarchy” on [page 222](ch08.xhtml#ch08lev1sec4). With all else being equal,
    a method defined using a particular type for one of its arguments is more specific
    than one defined for a supertype for the same argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: To determine which method to call, the compiler examines *all* of the arguments.
    This procedure for method selection, or *dispatch*, is called *multiple dispatch*
    for this reason. It is an unusual, but not unique, feature in the landscape of
    programming languages, and it’s a major reason for Julia’s power and success.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, object-oriented languages dispatch solely on the first argument
    of a method, often supplied implicitly as the object the method is part of and
    represented within the procedure with variables such as `this` or `self`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Functional languages have no real dispatch mechanism at all. All specialization
    must take the form of alternative code paths within one large function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Julia’s multiple dispatch paradigm means that it is neither an object-oriented
    nor a functional language, but something more general and flexible than either
    of them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Multiple Methods***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our definition of `weather_report()` included a check that the supplied argument
    was the correct type and a measure to take in case it wasn’t, implemented in an
    `if` block. We can eliminate that check by restarting the REPL and replacing the
    definition of `weather_report()` with two other methods with different signatures:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After the first definition, the REPL replies with the same message as before,
    but after the second, we are informed that `weather_report()` now has two methods.
    The only difference between our two methods is that the first has a type specification
    for the single argument, `raining`, in its signature, whereas the second does
    not. The absence of a type specification means that the compiler will accept an
    argument with any type, or, said another way, with the `Any` type. The rule is
    that the compiler will always select the most specific method for the arguments
    supplied. If we supply a `Bool` (`true` or `false`), the first method is selected,
    because it’s more specific than the second, as `Bool` is a subtype of `Any`. Any
    other type dispatches the second method, and the request to supply `true` or `false`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify that the two methods work the way we expect:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This technique of creating a collection of methods rather than cramming a bunch
    of type-checking code into one larger function is more idiomatic to Julia and
    leads to better-organized projects that are easier to maintain and extend.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wanted to extend the function by giving it the ability to comment
    on the weather in a city supplied by the user. The power of multiple dispatch
    allows us to simply add another method without changing anything we’ve already
    written:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we try to call `weather_report()` with arguments that don’t match the signature
    of any existing method, we get an error message:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The error message tells us that none of the methods of `weather_report()` have
    the right signature and lists some of the available methods, showing the types
    we can use for their arguments. We’ll get a similar error if we, for instance,
    try to add two things that can’t be added, such as `1 + "1"`, but the three or
    so possible methods mentioned in the error message will be a small fraction of
    the over 200 methods defined for the `+` operator. To see a list of all the methods
    defined for any function, call `methods()`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we see the list of methods we’ve defined for `weather_report()` with their
    method signatures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '***Extending Built-in Functions with New Methods***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we had a program that reads numbers from a file, or from user input,
    and adds them to an existing number. The read-in values would be strings, and
    the program would have to convert them to numbers before performing the addition.
    [Listing 8-4](ch08.xhtml#ch8lis4) shows a case like this, where we might decide
    to eliminate the explicit conversion step from the program by adding a method
    to `+` that does the conversion automatically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 8-4: Extending addition with a new method*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We’re not allowed to extend certain basic functions, such as `+`, unless we
    first explicitly import them, which is accomplished in the first line. After defining
    this method, it will be dispatched on any attempt to add a string to a number,
    something that normally results in a `MethodError`. If the `String` argument can
    be parsed as a `Number`, that number is added to the first argument and the method
    returns the result. If it can’t, the method simply returns the first argument.
    This method definition is an example of the use of abstract types in signatures.
    It will work for any type of number in the first argument, without the need to
    write definitions for each subtype of `Number`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check that this method works as intended:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve added to the language by extending the behavior of one of its basic operators.
    Multiple dispatch gives us the power to do this without altering any existing
    methods.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**DON’T BE A PIRATE**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'We would never place methods such as the one defined in [Listing 8-4](ch08.xhtml#ch8lis4)
    in a public package. That’s because we are responsible neither for the “+” function
    nor the data types in our new method definition. Someone importing our package
    may suffer conflicts or unexpected behavior. With the great power to extend the
    language comes great responsibility: transgressing this expectation is called
    *type piracy*. If we want to make our method public, we have three choices: name
    it something besides “+”; have it operate on our own string-like data type; or
    make a pull request on GitHub for inclusion in `Base`. The last option will endow
    “+” with a new method in addition to its current paltry 207, and all Julia users
    will automatically have the benefit of our creation.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Specialized methods are not only useful for creating new behaviors, they’re
    sometimes created for efficiency. For example, operations such as matrix multiplication
    or matrix inverse produce mathematically well-defined results (when they exist);
    however, for matrices with certain properties, specialized algorithms for computing
    that result may be more efficient than a general algorithm. The `SparseArrays`
    package (see “The Adjacency Matrix” on [page 196](ch07.xhtml#ch07lev1sec1)) provides
    methods for these matrix operations that are more efficient when one or both of
    the arguments is a sparse array. Multiple dispatch will automatically select the
    ideal method when a matrix operator is passed a sparse array, without any intervention
    needed on the part of the user.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Although we can create new methods to do anything we want, it makes sense that
    their behavior be conceptually related to the purpose or meaning of the generic
    function that they are a part of. Each of the over 200 methods for `+` has something
    to do with the idea of addition, as does the new method that we’ve defined here.
    Multiple dispatch should be seen as a paradigm for code organization rather than
    a license for chaos. The language does nothing to enforce this principle, which
    depends on the discipline of the programmer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding Union Types and the <: Operator***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, when constructing a method, a single abstract type is not general
    enough for our purposes. In such cases, we can declare an argument to have any
    one of several types using `Union{}`. This is an operator that accepts a list
    of types and constructs a new type that includes all of them. A value that has
    the type of anything in the list belongs to the new union type. Also, a type that
    is a subtype of any of the types in the list is a subtype of the union.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<:` infix operator is a test that acts on types and returns `true` if
    the type on its left is a subtype of the type on its right. This example illustrates
    the creation of a union type and the use of the `<:` operator:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Because `17` is a `Number`, the first expression returns `true`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to write a function that acts on real numbers other than integers:
    numbers with a decimal point. We might consider using a type declaration in the
    function signature such as `n::AbstractFloat`, which would include all the concrete
    floating types, such as `Float64` and `Float32`. However, examining [Figure 8-2](ch08.xhtml#ch8fig2)
    reminds us that this declaration would exclude any number supplied as an `Irrational`.
    If the user stuck in a literal π as an argument, a `MethodError` would be the
    result. We can use a union type to handle this scenario: `n::Union{AbstractFloat,
    Irrational}`. We might also consider adding `Rational` to the union, depending
    on the purpose of the function.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Defined Types**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as we can create our own verbs (functions and methods) for our own purposes,
    we can create our own nouns (data types) as well. The purpose of user-defined
    types in Julia is the same as the main purpose of types in general: to organize
    projects around methods that can be dispatched based on the types of their arguments.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Abstract Types***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, rather than simply adding a leaf to the tree of types we will want
    to add a branch and then create types as leaves attached to that branch. As we
    mentioned earlier, these branches are *abstract* types, and we can make our own
    with the `abstract type` declaration. As an example of its use, here is how to
    create a new abstract type descended from the `Number` type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After executing this statement, the new type `MyNumber` will be a subtype of
    the existing abstract type `Number` (recall that concrete types cannot be subtyped).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: If the new type is something really new that won’t share methods with existing
    types, there’s no need for it to inherit from any existing type. However, if it
    is a new type of number, string, or other existing type, it makes sense to place
    it appropriately in the type hierarchy. This way, existing methods that act on
    the `Number` type, for example, will be able to handle the new subtype of number.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Composite Types***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The purpose of creating a new abstract type is to be able to define new types
    as its subtypes, types that actually hold values and that we manipulate in calculations.
    These new types can either descend directly from `Any` or descend from an abstract
    type that we create.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In almost all cases, these new types will be *composite types*, defined in
    a `struct` block:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Composite types typically have several fields (but may have only one). The new
    `EarthLocation` type is intended to represent a location on Earth by its latitude
    and longitude and includes a field for the location’s time zone. The type declarations
    on the fields are optional; a field without a declaration will be of the `Any`
    type.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The following creates a variable with this type:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function, created by Julia using the same name as the type, is called a
    *constructor*. As the second interaction shows, it creates values with the `EarthLocation`
    type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access a composite type’s field values using property notation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The fields are assigned in the order in which they appear in the type’s definition.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a constructor is a function, we can define multiple methods for it. Here
    is one that handles the case where the caller supplies coordinates but no time
    zone:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The method dispatched when the caller uses only two arguments calls the original
    method with `"Unknown"` as the time zone. This method could have done anything,
    but naming it the same as the constructor for `EarthLocation` types and having
    it return something other than an instance of that type would be confusing. As
    mentioned in “Parametric Types” on [page 248](ch08.xhtml#ch08lev6), we should
    exploit the type system and multiple dispatch to make our code easier to understand,
    rather than the opposite.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we decide to use a different convention for recording time zones, and
    try to make some changes to existing variables:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Julia objects to what seems like a reasonable attempt to assign a new value
    to one of the fields of `NYC`. By default, composite types are immutable, which
    permits the compiler to generate more efficient code in some circumstances. If
    a program requires types whose field values can be changed, we need to explicitly
    define our type using the `mutable` keyword:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this definition, we can alter variables with the `MutableEarthLocation`
    type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can change the values of fields of mutable composite types at will. However,
    when this isn’t necessary, such as when the type represents a permanent object
    that should not be mutated, it’s generally better to define it without the `mutable`
    keyword.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Composite Types***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s explore a simple example that shows the usefulness of creating our own
    types, along with methods designed to operate on them. The idea is to define a
    couple of types representing circles. They’ll be somewhat different from each
    other, but since they both represent circles, they will have some commonality.
    We plan to write some methods that are specialized to our two circle types, and
    at least one that should be applicable to both (or more, if we extend the project
    in the future). This situation calls for the creation of an abstract type to represent
    circles in general, from which we’ll derive each composite circle type:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we’re not concerned *where* a circle is, we can define it completely by
    its radius. With this in mind, let’s define our first composite circle type to
    have only one field:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here `r` represents the circle’s radius, which can be any `Real` number. The
    type `FloatingCircle` is a subtype of our abstract `Circle` type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our next circle type also contains information about the shape’s position in
    space:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Of course, `PositionedCircle` is also defined as a subtype of `Circle`. The
    real numbers `x` and `y` are intended to hold the coordinates of its center. The
    abstract `Circle` type now has two subtypes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What we have so far might be the beginnings of a package to perform some geometrical
    calculations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the next step is to write a function that calculates the area of a
    circle. This area doesn’t depend on where the circle happens to be, only on its
    radius. Therefore, it should accept either subtype of the abstract `Circle` type
    and any future subtype that we might come up with:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `circle_area()` function’s signature demands that the type of its argument
    is a subtype of `Circle`. If it is, it will have a radius, which, by convention,
    we call `r` in all of our circular composite types:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After confirming that the new function calculates areas correctly for both `FloatingCircle`s
    ➊ and `PositionedCircle`s ➋, we forget that `circle_area()` deals only with subtypes
    of `Circle` and try to hand it a number, which results in a `MethodError`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add one more function to this geometry project: a routine that takes
    two circles and tells us if the second circle is entirely within the first.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The function calculates the distance between the centers of the two circles
    using their x- and y-coordinates, and then checks whether one lies inside the
    other by referring to their radii. Of course, the concept of a circle being “inside”
    another makes sense only if we can say where the circles are, so the new function
    accepts only `PositionedCircle`s and will have only one method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It seems to be working, but to be sure, it will help to make a diagram. We
    can draw our three circles using `Luxor` in a program similar to the one in [Listing
    7-1](ch07.xhtml#ch7lis1):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `Luxor` package uses points as its unit of length, so we expand our dimensions
    ➊ to make a reasonably sized illustration. The labels on the circles are the same
    as the names we gave them before. [Figure 8-3](ch08.xhtml#ch8fig3) shows the diagram
    that this program creates, where we can see that the `is_inside()` function calculates
    the “inside” relationship correctly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig03.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Circle b is inside a, but c is not.*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'We know how to enforce types used in constructors for user-defined types. But
    what if we want to constrain the allowed values passed to the constructors? Here’s
    how to make a type like our `FloatingCircle` that demands a positive radius:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As with functions, constraints on the values passed as arguments must be enforced
    in the body. The method inside the body ➊ is called an *inner constructor*; the
    other constructors we’ve been using up to now are *outer constructors*. The function
    `new()` creates the instance. It’s used only inside inner constructors.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Those who have experience with a class-based object-oriented language, such
    as Python, are sometimes at a temporary disadvantage when trying to absorb the
    concept of a user-defined composite type in Julia. We all have a tendency, when
    confronting a new concept, to relate it to concepts that are familiar to us. Composite
    types in Julia are not classes; Julia has no classes and, obviously, no class
    inheritance. In an object-oriented language, the next step would be to define
    methods as part of the class: the nouns and verbs are bound together. The more
    flexible multiple dispatch paradigm decouples nouns and verbs. Julia programmers
    are free to write methods that act upon any combination of types and to create
    new types at will, without friction.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining structs with Base.@kwdef***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The default method for defining composite types leaves a bit to be desired.
    Its main deficiency is that the constructor it creates requires the programmer
    to remember the order in which a type’s fields appear in its definition. The `Base.@kwdef`
    macro improves on this limitation by creating constructors that we can use with
    field names. For repeated use, it’s convenient to import this macro and rename
    it: `import Base.@kwdef as @kwdef`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Let’s expand our geometry package with a new type representing ellipses as shown
    in [Listing 8-5](ch08.xhtml#ch8lis5). This time we’ll use `@kwdef`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Listing 8-5: Defining an* Ellipse *type with* @kwdef'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition shows the second convenient feature of `@kwdef`: we can supply
    default values for fields. We also have the option to define a mutable struct
    with `@kwdef mutable struct`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make an ellipse and assign it to a variable:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This example shows how we can supply a subset of the type’s keyword arguments,
    and the ones we omit will get their default arguments. As with functions, any
    keyword argument without a default in the type definition must be supplied when
    using the constructor. Also, similarly to functions, we may not mix positional
    and keyword forms:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As there is no drawback to using `@kwdef` when defining composite types, it’s
    convenient to use it routinely.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way Julia’s JIT compiler works with the type system, computing
    with user-defined types is as fast as using native types. We can work at a higher
    level of abstraction, creating a set of types that naturally conform to the objects
    in our problem, without any compromise in performance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance Tips**'
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speed and efficiency are often of great concern in scientific programming. While
    Julia generally produces performant code without requiring extreme expertise or
    knowledge of internals, good performance does sometimes depend on an awareness
    of the compilation process.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included topics related to performance in various places throughout this
    book. Here we’ll learn about several such issues specifically related to types.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '***Vanquish Type Instability***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Type stability* is perhaps the single most important performance-related concept
    in Julia. Its central principle is that the return values of functions should
    have types we can predict based on the types of the arguments supplied to the
    function. The returned type should not depend on the *values* of the arguments.
    A secondary issue is that the local variables used within a function should not
    change type.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to have a function for dividing two numbers that would return
    `0` when the denominator is `0`, rather than `Inf`. [Listing 8-6](ch08.xhtml#ch8lis6)
    shows one way to write such a function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Listing 8-6: This function needs improving.*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'It certainly seems to work as intended:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, the sharp-eyed programmer may notice that in the first case, the function
    returns a `Float64`, whereas in the second case it returns an `Int64`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The types of the arguments in both cases are integers, but the types of the
    results depend on their values. This type instability may not matter. However,
    an insidious problem is lurking, as one day we may pull out our `safe_divide()`
    function to use within some other program where its varying return type affects
    performance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'In more complicated functions, the type instability may not be so obvious.
    In situations where performance or memory consumption makes us wonder whether
    one of our functions may have such an issue, Julia provides a convenient tool
    for ferreting out type instability: the `@code_warntype` macro. Let’s use it on
    our `safe_divide()` function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is one of several macros and functions available for use in the REPL that
    display a translated version of a Julia function. The `@code_warntype` macro prints
    a *lowered form* of the code: a representation of the computation in terms of
    a smaller set of operations. It is one of four stages of code transformation beginning
    with our Julia source and ending with machine code specific to the processor we’re
    running on. This lowered form is similar to the version that is sent to the compiler,
    but it contains the type information that we can examine when debugging performance
    issues. Other than that, it’s not particularly useful and not intended for routine
    human consumption.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'When printed in the REPL, type information that indicates a possible type stability
    issue is displayed in red type, which I’ve converted to bold for printing in the
    book. The bold fragment indicates that the return type can be either a `Float64`
    or an `Int64`: in other words, it’s not determined from the types of the input
    arguments. This is the signature of a type-unstable function.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this case has a simple fix:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Since `a/b` is always a float, even if `a` and `b` are integers, we can ensure
    that the function always returns a float by replacing the integer `0` with `0.0`
    ➊.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm whether we’ve fixed the type instability problem, let’s turn to
    `@code_warntype` again:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This time, there are no red (bold) warnings, and the macro confirms ➊ that the
    return type is always a `Float64`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '*The output from* @code_warntype *often also includes yellow warnings involving
    unions with the* Nothing *type, which is used when a function does not return
    a result. These are not usually considered type instabilities.*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also correct this type stability problem by defining the function using
    a type declaration:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This version, when called with `b = 0`, will convert its return value to `0.0`.
    It will always return a `Float64`; `@code_warntype` will verify its type stability.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Although the form of the code returned by `@code_warntype` can be difficult
    to parse, it’s fairly simple to use it to scan for type stability problems.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '***Avoid Changing the Types of Variables***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function to approximate π using the Leibniz sum:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/math245.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'This is not a good way to get the digits of π, as it converges quite slowly,
    but it’ll be useful for our demonstration. One version of the function might be:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This works as intended; [Figure 8-4](ch08.xhtml#ch8fig4) shows its output gradually
    converging to the correct value for π.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig04.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: The Leibniz sum approximation to π*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is clearly not type-unstable in the sense used earlier: the output
    is always a `Float64`, regardless of the number supplied as an argument.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, taking a look at the output of `@code_warntype` indicates a problem:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Once again, the warnings are rendered in bold. They inform us that the local
    variable `s` is a union of the types `Float64` and `Int64`, rather than a single
    numerical type. This happens because we initialize it as a literal integer, `0`,
    but then use it in a loop that causes Julia to promote it to a float.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Changing the type of a local variable may prevent the compiler from optimizing
    our code as well as it could otherwise. This is a common mistake, as the pattern
    of initializing variables and then using them in a `for` loop is routine. When
    doing so, we should take care to initialize them with types appropriate to the
    arithmetic in the loop.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'This case is also easy to fix:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As before, we simply have to replace `0` with `0.0` ➊. I won’t reproduce the
    (mostly redundant) output here, but checking with `@code_warntype` shows that
    the warnings are gone.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Aliases**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several types have alternative names, called *type aliases*. The use of aliases
    is for convenience; they are typically shorter names or dispense with the indication
    of the machine’s pointer size. For example, on a 64-bit computer, `Int` is another
    name, or alias, for `Int64`, but on a 32-bit machine, `Int` means `Int32`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This shows that, at least on my computer, `Int` is another name for `Int64`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own type aliases:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here we’ve created an alternative name for the default floating-point type.
    After this definition, we can use `F64` and `Float64` interchangeably.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Defining type aliases as `const` is not required, but it makes sense, as they
    are additional names for something that will not change.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '**Parametric Types**'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A parametric type is a type made from pieces that themselves can be of several
    possible types. The parameters are variables that vary with the types of the pieces.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-7](ch08.xhtml#ch8lis7) shows an example of a parametric type that
    we’ve already encountered, the type used for complex numbers.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '*Listing 8-7: The types of some complex numbers*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The curly brackets (`{}`) in the type names indicate that we’re dealing with
    *parametric types*. In the first line, we’ve asked for the type of a complex number
    that’s written using integer literals for each coefficient. The response indicates
    that the number is `Complex` with an `Int64` parameter; this parameter is the
    type of the coefficients.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The second line tells us something similar, but this time the complex number
    has floating-point coefficients. In addition, we learn about an alias for the
    type.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The fact that there is only one parameter within the curly brackets suggests
    that both coefficients must have the same type. This is indeed true; mixing literal
    floats and integers causes an automatic conversion of the integer coefficient
    to a `Float64` coefficient ➊.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: In the final example, we’ve created a complex number with `Rational` coefficients.
    This time the parameter is itself a parametric type. Rational numbers can be composed
    of any integers. The `Rational{Int64}` notation means that the numerator and denominator
    are `Int64`s rather than, for example, `Int32`s.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Collection types, such as `Array`, are defined as parametric types because
    they can hold elements of various types:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The use of aliases is common for collection types, as in these examples. We
    see here that `Array` is a parametric type with two parameters: the first is the
    type of the array’s elements, and the second is the number of dimensions.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The `where` keyword creates a `UnionAll` type, a union of many types, each defined
    by assigning a particular type to the type variable `T`. One example of this is
    the notation `AbstractArray{T, 1}`, where `T` denotes an abstract type that is
    the union of `AbstractArray{Int64, 1}`, `AbstractArray{Float64, 1}`, and so on.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own parametric types for the same reason we create any type:
    to organize our methods with the help of the type system and multiple dispatch.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit our `Ellipse` type from [Listing 8-5](ch08.xhtml#ch8lis5) and
    make a parametric version of it:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now the fields can be any type, as long as they are both the same type:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'After defining a new `CEllipse`, the REPL tells us the type, with `Float64`
    substituted in place of the parameter `T`. Our attempt to give the fields two
    different types failed because they are both `T` in the type definition. `T` can
    be anything, but the definition requires that both axes have the same type, so
    the final example is accepted. But what does it mean to have an ellipse with arbitrary
    strings for the axes? It’s up to us. We are creating types for our own purposes,
    to organize our projects. If we prefer to limit the `CEllipse` type to have numerical
    values for the axes, we can use the subtyping operator:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Before defining this struct, if we’re working in the REPL, we’re obligated to
    begin a new session if the previous definition of `CEllipse` is still active.
    Another option would be to name it differently.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Now a `CEllipse` can have two axes of the same type, and that type can be anything,
    as long as it’s a subtype of `Number`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Since we make `T` a subtype of `Number`, rather than a subtype of the more
    specific `Real`, we are allowing the possibility of ellipses with complex-valued
    axes. In some cases, our functions for calculating properties of ellipses will
    need methods specialized for this case. For an example, let’s write a function
    that returns the eccentricity of an ellipse. This is a measure of how elongated
    the ellipse is, where an eccentricity of 0 is a circle. If *a* is the longer of
    the two axes and *b* is the shorter, the eccentricity is given by:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/250math.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: 'Here’s a direct translation of this formula into a Julia function:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This definition works for real-valued axes, so to ensure that the function accepts
    only such ellipses, its type parameter specifies subtypes of `Real`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize an ellipse with complex-valued axes as lying in the complex
    plane. We can define ellipses this way as long as we ensure that their axes are
    perpendicular.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a method of our eccentricity function that handles these ellipses:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `abs()` function, when handed a complex number, returns its length. We use
    the `<:` operator in the type parameter slot to include every possible kind of
    complex number.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'We know a bit more about ellipses with complex axes: not merely their eccentricities,
    but their orientations. [Figure 8-5](ch08.xhtml#ch8fig5) shows an ellipse in the
    complex plane.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig05.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: An ellipse in the complex plane*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Its axes, represented by dotted lines, are 2 + 2*i* and *−*1 + *i*. We’ll define
    the orientation as the angle that its major (longer) axis makes with the real
    axis, shown in the figure by *α*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the program that created the illustration in [Figure 8-5](ch08.xhtml#ch8fig5):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Remember, in `Luxor` the vertical coordinate goes from the top down, opposite
    to the conventional direction in mathematical diagrams.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'This function calculates the orientation of an ellipse with complex axes:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Since no orientation can be defined for an ellipse with axes given only by real-number
    lengths, `orientation()` will have just this one method. The `angle()` function
    returns a complex number’s phase angle; it’s equivalent to `atan(imag(a)/real(a))`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define an ellipse with complex axes and calculate its eccentricity and
    orientation:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This ellipse corresponds to [Figure 8-5](ch08.xhtml#ch8fig5). The `orientation()`
    function returns its result in radians, so for good measure, we’ve converted that
    to degrees in the final expression.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Parametric types make Julia’s rich type system even more flexible and expressive.
    Like the other parts of the type system, we’re not required to use any of it in
    our own programs, but a little bit can go a long way in helping with code organization,
    reuse, and efficiency. Finally, a basic knowledge of parametric types is essential
    in understanding the messages and information that Julia sends to us, and in reading
    language and package documentation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '**Plot Recipes**'
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As authors of programs, modules, and perhaps packages, we should expect to create
    our own data types routinely. There is no performance penalty for using custom
    data types in Julia, and they are essential for writing concise, well-organized
    code and for taking the best advantage of multiple dispatch.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: In [Part II](part2.xhtml) of this book we’ll explore various packages from the
    Julia scientific ecosystem. Many of these packages define one or a variety of
    data types that describe the objects they manipulate. These objects include audio
    signals, solutions to differential equations, images, measurements with uncertainties,
    entire environments housing interacting creatures, the creatures themselves, and
    much more. We’ll discover that we can use the plotting commands from [Chapter
    4](ch04.xhtml) to visualize these data structures directly, with no preprocessing
    needed on our part. How is it possible that `Plots` knows what to do with all
    these different data types?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Visualization is an essential part of scientific computation. The plot *recipe*
    system is how we hook our data types into Julia’s plotting system, that is, how
    we teach it to handle and display our custom objects. The authors of the scientific
    packages that we use in [Part II](part2.xhtml) did not have to touch the code
    in the `Plots` package, which in turn doesn’t need to know anything about the
    new data types. Plot recipes insert data transformations into the plotting *pipeline*,
    so existing plotting functions can handle our data types as if they were the familiar
    arrays of numbers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The result is that users of our programs need simply call `plot()`, `scatter()`,
    or another plotting function on the new data type to get a reasonable visual representation.
    We can also define entirely new plotting functions for more elaborate visualizations.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a specific application in mind to make the operation of plot recipes
    clear. Let’s imagine that we’re creating a program that has something to do with
    the weather, and create some simple data types for representing daily temperature
    and rainfall data:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Our temperature data, we’ll suppose, comes to us as two measurements per day,
    representing that day’s minimum and maximum temperatures. We’ll store these measurements
    in a vector of tuples ➊, one tuple per day, containing the temperature extrema.
    That vector of tuples, along with a string holding the temperature unit, are packaged
    together in the TempExtremes data type.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: That data type is put next to a vector of rainfall measurements in another data
    type called `WeatherData`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: A third data type, `WeatherReport`, contains the `WeatherData` along with some
    notes, a pair of numbers (latitude and longitude) for the location of the measurements,
    and the date recording when the series of measurements begin.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we make instances of these three data types to have something to plot:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `randn()` function produces normally distributed (see “The Normal Distribution”
    on [page 323](ch10.xhtml#ch10lev1sec3)) fake random temperature and rain data.
    Earlier we imported the `Date` module so we can use one of its data types to define
    a starting date.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '***The Plotting Pipeline***'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The recipe system consists of a series of four recipe varieties that get processed
    in order in the plotting pipeline, as shown in [Listing 8-8](ch08.xhtml#ch8lis8).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '*Listing 8-8: The plotting pipeline*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Each recipe type transforms its input and passes it to the next stage in the
    pipeline; these transformations are indicated after the recipe names. The built-in
    plotting functions generally know how to plot arrays of numbers, so the plotting
    recipes have to transform our custom types into ordinary arrays. The first two
    recipe types, user recipes and type recipes, can do this. The final two recipe
    types take numerical arrays and produce *series*, which are the components of
    plots that represent individual vectors, which may be extracted from matrix columns
    (in one dimension).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The user and plot recipes can also create layouts and set overall plot properties.
    We don’t need to define every one of these recipes, and generally won’t require
    all of them for any particular plotting task. Any that we *have* defined we can
    use separately, or as part of the pipeline, for different purposes. In this discussion,
    we’ll start at the end of the pipeline and work our way toward the beginning,
    defining recipes as we go. In this way, each example recipe will do something
    when we call it directly, passing information along to the previously defined
    recipes to produce a plot.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '***The Series Recipe***'
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define recipes with the `@recipe` macro, exported by the `RecipesBase` package.
    The macro decorates a function definition where the name of the function is arbitrary.
    The function’s signature determines the type of recipe created. In the following
    listing, we create two series recipes. The signature, a type followed by three
    additional positional arguments `x`, `y`, and `z`, tells the pipeline that these
    are series recipes. As always, the keyword arguments are not part of the function
    signature for dispatch. Referring to [Listing 8-8](ch08.xhtml#ch8lis8), we see
    that these recipes will accept numerical arrays and create series:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To define recipes, we need only import `RecipesBase`. This is important because
    it means that packages can define plotting behaviors without a dependence on the
    large `Plots` package. `RecipesBase` is tiny, containing only about 400 lines
    of Julia.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Plot recipes defined using the `@recipe` macro use several special-purpose syntax
    conveniences. The `:=` operator ➊ makes a setting in the `plotattributes` dictionary,
    which holds attributes such as line color—all the options for the plot. Here we
    set the `seriestype` in the attribute dictionary to `:line`. This is the default
    series type, which creates a continuous line through the plotted points. Another
    option is `:scatter`, for plotting individual marks. In fact, the familiar `scatter()`
    function is a shorthand for `plot(; seriestype=:scatter)`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The `-->` operator ➌ also makes settings in the `plotattributes` dictionary,
    but, in this case, defers to settings made in keyword arguments previously in
    the pipeline. In a sense, these are optional, whereas settings we make with `:=`
    are important for the series under construction.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Next we have a `for` loop that divides the input `y` vector into segments of
    `cycle` elements and calculates extrema and an average for each segment. It inserts
    `NaN`s after each segment to separate them in the plot.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Next come three blocks preceded by the `@series` macro ➋. Each `@series` block
    creates a new series for the plot. In this case, each will be a `:line` series,
    since we make that setting outside the blocks, but in general, they can be of
    different types. They can also create a series type unknown to `Plots`, in which
    case the pipeline will pass the data on to the recipe where the new series is
    defined. There can be a chain of series recipes of any length. The data will pass
    through each in turn until a recipe creates a series type known to the backend
    in use.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe is designed to accept an *N*×2 matrix. It will plot each of
    the two columns as lines, the first in blue and the second in red. It will fill
    the space between the two lines using the `fillrange` attribute. This presents
    a small problem, as we need to refer to the first column to define the `fillrange`
    when plotting the second, but the pipeline starts afresh for each column in the
    input data. However, we know which column we’re on by referring to the `:series_plotindex`
    key in the attribute dictionary. One way to pass information between different
    columns is to stuff it into the `:extra_kwargs` entry in the attribute dictionary
    ➍. We call our new attribute `:nextfr`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we have in mind the weather data types defined previously, these recipes
    don’t know anything about that. Like all series recipes, they can plot any arrays
    of numbers. For actual plotting, we need to import `Plots`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `@shorthands` macro, provided by `RecipesBase`, takes the names in the function
    signatures of recipes and makes function names that we can call directly to make
    plots. For each one, it makes two functions, one for creating a new plot and one
    for adding to an existing plot, just like `plot()` and `plot!()`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: After transforming the temperature data in `wd` to a matrix, we can use the
    shorthand on it directly, creating [Figure 8-6](ch08.xhtml#ch8fig6).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig06.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: A* fillrange *plot created by a series recipe*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: For [Figure 8-7](ch08.xhtml#ch8fig7), we call `ebxbox()` on the rainfall vector.
    It only plots the extrema and mean bars, so we add a normal plot of the vector
    using `plot!()`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig07.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: A plot using the* ebxbox *series recipe*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: We can use these series recipes in other programs and as components within other
    pipelines.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '***The Plot Recipe***'
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type of recipe called a *plot recipe* (not to be confused with the general
    concept) also transforms series into other series or numerical data into series,
    as do series recipes, but can create complete visualizations containing subplots
    and other elements as well. Like all recipes, it’s identified by its particular
    function signature:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The recipe takes input data in the form of an *N*×3 matrix. It uses a `frames`
    attribute, which we invented for the purpose, to decide whether to place all the
    series in one plot or to use two subplots ➋, one with temperature and the other
    with rainfall. (As in the case of the series recipes, this recipe knows nothing
    of our weather-related data types, so we can repurpose it to plot other types
    of data as well.)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The `cycle` variable sets the length of the segments used for calculating extrema
    and averages in the third column of the input data, which we intend to use for
    the rainfall data. We use 7 as a default value for this keyword argument, for
    weekly summaries. If, however, we supply the parameter when calling the recipe
    directly or upstream in the pipeline, we override the default by reading its value
    from the `plotattributes` dictionary ➊.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The three `@series` blocks handle the first two columns, containing temperature
    minimums and maximums, and the rainfall in the third column. The temperature `@series`
    block sets the series type to `temprange` ➌, which won’t work unless we’ve already
    defined a series recipe for it, as we did previously.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe, then, is to use the visualizations defined in our
    series recipes to create a graph with either one or two subplots, with labels
    appropriate for either case. We can also call it directly, as shown in [Listing
    8-9](ch08.xhtml#ch8lis9).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '*Listing 8-9: Calling the plot recipe with array data*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: But we’ll defer this for now.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '***Type Recipes***'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Referring back to [Listing 8-8](ch08.xhtml#ch8lis8), we can see that *type
    recipes* are the first recipes in the pipeline that can accept user-defined types.
    They’re the simplest class of recipe. They have one job: to transform user types
    into numerical arrays that the functions from `Plots` can plot directly, or that
    can be fed into the following steps in the pipeline.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing defines two type recipes; they’re recognized as such
    by their particular function signatures:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The first recipe takes instances of the `*TempExtremes*` type defined previously
    and returns a matrix with two columns; the second transforms `WeatherData` into
    a three-column matrix.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining these recipes, we can now plot either of these types directly
    by calling `plot(td)` or `plot(wd)`. If we do so, we’ll get simple line plots
    of the columns: two from the first call and three from the second, as in [Figure
    8-8](ch08.xhtml#ch8fig8).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig08.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: Plotting directly from a type recipe*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: We call `plot(wd)` to produce [Figure 8-8](ch08.xhtml#ch8fig8). The top two
    lines are the temperature extrema and the bottom line is the rainfall.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, we call `weatherplot(wd)`, we get the exact same plot that would
    result from the call in [Listing 8-9](ch08.xhtml#ch8lis9) because the type recipe
    transforms `wd` into a three-column matrix. [Figure 8-9](ch08.xhtml#ch8fig9) shows
    the result.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig09.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: A plot recipe called on user data transformed by a type recipe*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Here the plot recipe assembles the two types of visualizations, defined in series
    recipes, onto a single plot, and adds a label on the vertical axis. Since we don’t
    define `frames`, we get the default single frame.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '***User Recipes***'
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ve ascended to the top of the pipeline. The *user recipes* accept not
    only single user types, but any combination of types, with each different signature
    creating a new method for dispatch. They can emit array data or other types, but
    if they emit types other than array data we must have defined a type recipe to
    transform them.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Such is the case with the following user recipe:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The pipeline will see this as a user recipe because of its signature. It takes
    an instance of the `WeatherReport` data type, creates a title from its `notes`
    field, and constructs a useful label for the x-axis by referring to the `start`
    field. It has a single `@series` block, to which it passes the `data` field. The
    series invoked is the plot recipe `weatherplot`, but the `data` field is not an
    array, it’s `WeatherData`. The next step in the pipeline, the type recipes, handles
    any type conversions. Here the `WeatherData` instance is transformed into a three-column
    matrix that is handed off to the `weatherplot` recipe, which optionally sets up
    the subplots and passes the matrix columns to the series recipes. Calling `plot(wr;
    frames=2)` invokes this recipe and creates [Figure 8-10](ch08.xhtml#ch8fig10).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig10.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: The result of calling the user recipe*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user recipe teaches the `plot()` function how to handle a new data
    type. As we’ve seen throughout this section, we can enter the plotting pipeline
    at any point for a different result, or reuse any of these recipes as part of
    different pipelines for handling different types of data.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '***The @userplot Macro***'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `RecipesBase` package also exports the `@userplot` macro, which is convenient
    for defining a visualization without having to define a new data type:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The first line after the import creates a new type and a shorthand using its
    lowercase name. The user recipe that we define using the name of the type is invoked
    using the shorthand name. Inside the recipe, we can access plot data using the
    `args` property ➊. The `@userplot` is useful when we want a shorthand name for
    a particular visualization for an existing type. In this case, we want to plot
    complex numbers by separating their real and imaginary parts, which may be more
    useful than the default treatment given them by `plot()`. After defining the recipe,
    we can invoke it directly using its name as in the last line. The `expint()` function
    is an exponential integral from the `SpecialFunctions` package, parameterized
    by its first argument. With the parameter here, it maps real numbers to complex
    numbers. The result appears in [Figure 8-11](ch08.xhtml#ch8fig11).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch08fig11.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: Using @userplot to render a vector of complex numbers*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `@userplot` macro to create alternative visualizations for
    user-defined types by using type aliases or subtyping.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this survey of the most important practical aspects of the type system,
    our introduction to the Julia language is complete. The ideas in this chapter
    and the preceding ones will find concrete application in the chapters of [Part
    II](part2.xhtml), where we’ll put Julia to work to solve real problems in a variety
    of fields.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: This book’s division into language learning and application sections isn’t a
    strict one, however. We’ve seen several useful applications in the preceding chapters,
    and the chapters in [Part II](part2.xhtml) will introduce various programming
    techniques and Julia features in places where they can be immediately applied
    and more readily appreciated in the context of solving problems.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Details on performance implications of one form of type instability are available
    at [*https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable*](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable).
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dr. Chris Rackauckas gives an example of when dynamic dispatch is a net win
    here: [*https://discourse.julialang.org/t/why-type-instability/4013/8*](https://discourse.julialang.org/t/why-type-instability/4013/8).
    This is a case where type instability is beneficial.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interesting information about π in Julia is available at [*https://julialang.org/blog/2017/03/piday/*](https://julialang.org/blog/2017/03/piday/).
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My attempt to explain multiple dispatch using an extended recipe analogy is
    available at [*https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/*](https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/).
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a detailed tutorial about optimization and the type system, visit [*https://huijzer.xyz/posts/inference/*](https://huijzer.xyz/posts/inference/).
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a package for nice visualization of type hierarchies: [*https://github.com/claytonpbarrows/D3TypeTrees.jl*](https://github.com/claytonpbarrows/D3TypeTrees.jl).'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another approach to finding and fixing type instabilities is offered by the
    `Cthulhu` package: [*https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/*](https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/).'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
