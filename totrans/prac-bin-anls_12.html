<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_223"/><span class="big">9</span><br/>BINARY INSTRUMENTATION</h2>&#13;
<p class="startpara">In <a href="ch07.xhtml#ch07">Chapter 7</a>, you learned several techniques for modifying and augmenting binary programs. While relatively simple to use, those techniques are limited in the amount of new code you can insert into the binary and where you can insert it. In this chapter, you’ll learn about a technique called<em> binary instrumentation</em> that allows you to insert a practically unlimited amount of code at any location in a binary to observe or modify that binary’s behavior.</p>&#13;
<p class="indent">After a brief overview of binary instrumentation, I’ll discuss how to implement<em> static binary instrumentation (SBI)</em> and<em> dynamic binary instrumentation (DBI)</em>, two types of binary instrumentation with different trade-offs. Finally, you’ll learn how to build your own binary instrumentation tools with Pin, a popular DBI system made by Intel.</p>&#13;
<h3 class="h3" id="ch09_1"><span epub:type="pagebreak" id="page_224"/>9.1 What Is Binary Instrumentation?</h3>&#13;
<p class="noindent">Inserting new code at any point in an existing binary to observe or modify the binary’s behavior in some way is called<em> instrumenting</em> the binary. The point where you add new code is called the<em> instrumentation point</em>, and the added code is called<em> instrumentation code</em>.</p>&#13;
<p class="indent">For example, let’s say you want to know which functions in a binary are called most often so that you can focus on optimizing those functions. To find this out, you can instrument all <code>call</code> instructions in the binary,<sup><a id="ch09fn_1a" href="footnote.xhtml#ch09fn_1">1</a></sup> adding instrumentation code that records the target of the call so that the instrumented binary produces a list of called functions when you execute it.</p>&#13;
<p class="indent">Although this example only observes the binary’s behavior, you can also modify it. For instance, you can improve a binary’s security against control-flow-hijacking attacks by instrumenting all indirect control transfers (such as <code>call rax</code> and <code>ret</code>) with code that checks whether the control-flow target is in a set of expected targets. If not, you abort the execution and raise an alert.<sup><a id="ch09fn_2a" href="footnote.xhtml#ch09fn_2">2</a></sup></p>&#13;
<h4 class="h4" id="ch09_1_1"><em>9.1.1 Binary Instrumentation APIs</em></h4>&#13;
<p class="noindent">Generic binary instrumentation that allows you to add new code at every point in a binary is far more difficult to implement correctly than the simple binary modification techniques you saw in <a href="ch07.xhtml#ch07">Chapter 7</a>. Recall that you cannot simply insert new code into an existing binary code section because the new code will shift existing code to different addresses, thereby breaking references to that code. It’s practically impossible to locate and patch all existing references after moving code around, because binaries don’t contain any information that tells you where these references are and there’s no way to reliably distinguish referenced addresses from constants that<em> look</em> like addresses but aren’t.</p>&#13;
<p class="indent">Fortunately, there are generic binary instrumentation platforms you can use to handle all of the implementation complexities for you, and they offer relatively easy-to-use APIs with which you can implement binary instrumentation tools. These APIs typically allow you to install callbacks to instrumentation code at instrumentation points of your choice.</p>&#13;
<p class="indent">Later in this chapter, you’ll see two practical examples of binary instrumentation using Pin, a popular binary instrumentation platform. You’ll use Pin to implement a profiler that records statistics about a binary’s execution to aid optimization. You’ll also use Pin to implement an automatic unpacker that helps you deobfuscate<em> packed binaries</em>.<sup><a id="ch09fn_3a" href="footnote.xhtml#ch09fn_3">3</a></sup></p>&#13;
<p class="indent">You can distinguish two classes of binary instrumentation platforms: static and dynamic. Let’s first discuss the differences between these two classes and then explore how they work at a low level.</p>&#13;
<h4 class="h4" id="ch09_1_2"><span epub:type="pagebreak" id="page_225"/><em>9.1.2 Static vs. Dynamic Binary Instrumentation</em></h4>&#13;
<p class="noindent">Static and dynamic binary instrumentation solve the difficulties with inserting and relocating code using different approaches. SBI uses<em> binary rewriting</em> techniques to permanently modify binaries on disk. You’ll learn about the various binary rewriting approaches that SBI platforms use in <a href="ch09.xhtml#ch09_2">Section 9.2</a>.</p>&#13;
<p class="indent">On the other hand, DBI doesn’t modify binaries on disk at all but instead monitors binaries as they execute and inserts new instructions into the instruction stream on the fly. The advantage of this approach is that it avoids code relocation issues. The instrumentation code is injected only into the instruction stream, not into the binary’s code section in memory, so it doesn’t break references. However, the trade-off is that DBI’s runtime instrumentation is more computationally expensive, causing larger slowdowns in the instrumented binary than SBI.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09tab1">Table 9-1</a> summarizes the main advantages and disadvantages of SBI and DBI, showing advantages with a + symbol and disadvantages with a – symbol.</p>&#13;
<p class="tab-caption" id="ch09tab1"><strong>Table 9-1:</strong> Trade-offs of Dynamic and Static Binary Instrumentation</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Dynamic instrumentation</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Static instrumentation</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td>– Relatively slow (4 times or more)</td>&#13;
<td>+ Relatively fast (10% to 2 times)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>– Depends on DBI library and tool</td>&#13;
<td>+ Stand-alone binary</td>&#13;
</tr>&#13;
<tr>&#13;
<td>+ Transparently instruments libraries</td>&#13;
<td>– Must explicitly instrument libraries</td>&#13;
</tr>&#13;
<tr>&#13;
<td>+ Handles dynamically generated code</td>&#13;
<td>– Dynamically generated code unsupported</td>&#13;
</tr>&#13;
<tr>&#13;
<td>+ Can dynamically attach/detach</td>&#13;
<td>– Instruments entire execution</td>&#13;
</tr>&#13;
<tr>&#13;
<td>+ No need for disassembly</td>&#13;
<td>– Prone to disassembly errors</td>&#13;
</tr>&#13;
<tr>&#13;
<td>+ Transparent, no need to modify binary</td>&#13;
<td>– Error-prone binary rewriting</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;">+ No symbols needed</td>&#13;
<td style="border-bottom: solid 0.2em;">– Symbols preferable to minimize errors</td>&#13;
</tr>&#13;
</thead>&#13;
</table>&#13;
<p class="indent">As you can see, DBI’s need for runtime analysis and instrumentation induces slowdowns of four times or more, while SBI only induces a slowdown of 10 percent to two times. Note that these are ballpark numbers, and the actual slowdown can vary significantly depending on your instrumentation needs and the implementation quality of your tool. Moreover, binaries instrumented with DBI are more difficult to distribute: you have to ship not only the binary itself but also the DBI platform and tool that contain the instrumentation code. On the other hand, binaries instrumented with SBI are stand-alone, and you can distribute them normally once the instrumentation is done.</p>&#13;
<p class="indent">A major advantage of DBI is that it’s much easier to use than SBI. Because DBI uses runtime instrumentation, it automatically accounts for all executed instructions, whether those are part of the original binary or of libraries used by the binary. In contrast, with SBI you have to explicitly <span epub:type="pagebreak" id="page_226"/>instrument and distribute all libraries that the binary uses, unless you’re willing to leave those libraries uninstrumented. The fact that DBI operates on the executed instruction stream also means that it supports dynamically generated code that SBI cannot support, such as JIT-compiled code or self-modifying code.</p>&#13;
<p class="indent">Additionally, DBI platforms can typically attach to and detach from processes dynamically, just like debuggers can. That’s convenient if you want to observe part of the execution of a long-running process, for example. With DBI, you can simply attach to that process, gather the information you want, and then detach, leaving the process running normally again. With SBI, this is not possible; you either instrument the entire execution or don’t instrument at all.</p>&#13;
<p class="indent">Finally, DBI is far less error-prone than SBI. SBI instruments binaries by disassembling them and then making any needed changes. That means disassembly errors can easily cause errors in the instrumentation, potentially causing incorrect results or even breaking the binary. DBI doesn’t have this problem because it doesn’t require disassembly; it simply observes instructions as they’re being executed, so it’s guaranteed to see the correct instruction stream.<sup><a id="ch09fn_4a" href="footnote.xhtml#ch09fn_4">4</a></sup> To minimize the possibility of disassembly errors, many SBI platforms require symbols, while DBI has no such requirement.<sup><a id="ch09fn_5a" href="footnote.xhtml#ch09fn_5">5</a></sup></p>&#13;
<p class="indent">As I mentioned earlier, there are various ways to implement SBI’s binary rewriting and DBI’s runtime instrumentation. In the next two sections, let’s look at the most popular ways to implement SBI and DBI, respectively.</p>&#13;
<h3 class="h3" id="ch09_2">9.2 Static Binary Instrumentation</h3>&#13;
<p class="noindent">Static binary instrumentation works by disassembling a binary and then adding instrumentation code where needed and storing the updated binary permanently on disk. Well-known SBI platforms include PEBIL<sup><a id="ch09fn_6a" href="footnote.xhtml#ch09fn_6">6</a></sup> and Dyninst<sup><a id="ch09fn_7a" href="footnote.xhtml#ch09fn_7">7</a></sup> (which supports both DBI and SBI). PEBIL requires symbols while Dyninst does not. Note that both PEBIL and Dyninst are research tools, so they’re not as well documented as a production-quality tool.</p>&#13;
<p class="indent">The main challenge in implementing SBI is finding a way to add the instrumentation code and rewrite the binary without breaking any existing code or data references. Let’s consider two popular solutions to this challenge, which I call the<em> int 3 approach</em> and the<em> trampoline approach</em>. Note that, in practice, SBI engines may incorporate elements from both these techniques or use another technique entirely.</p>&#13;
<h4 class="h4" id="ch09_2_1"><span epub:type="pagebreak" id="page_227"/><em>9.2.1 The int 3 Approach</em></h4>&#13;
<p class="noindent">The<em> int 3 approach</em> gets its name from the x86 <code>int 3</code> instruction, which debuggers use to implement software breakpoints. To illustrate the need for <code>int 3</code>, let’s first consider an SBI approach that does<em> not</em> work in the general case.</p>&#13;
<h3 class="h3">A Naive SBI Implementation</h3>&#13;
<p class="noindent">Given the practical impossibility of fixing all references to relocated code, it’s clear that SBI cannot store the instrumentation code inline in an existing code section. Because there’s no room for arbitrary amounts of new code in the existing code sections, it follows that SBI approaches must store instrumentation code in a separate location, such as a new section or a shared library, and then somehow transfer control to the instrumentation code when execution reaches an instrumentation point. To achieve this, you might come up with the solution shown in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>.</p>&#13;
<div class="image"><a id="ch09fig1"/><img src="Images/f227-01.jpg" alt="image" width="697" height="126"/></div>&#13;
<p class="fig-caption"><em>Figure 9-1: A nongeneric SBI approach that uses</em> <code>jmp</code> <em>to hook instrumentation points</em></p>&#13;
<p class="indent">The leftmost column of <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> shows a chunk of original, uninstrumented code. Let’s say you want to instrument the instruction <code>mov edx,0x1</code> <span class="ent">➊</span>, adding instrumentation code to run before and after that instruction. To get around the problem that there’s no room to add the new code inline, you overwrite <code>mov edx,0x1</code> with a <code>jmp</code> to your instrumentation code <span class="ent">➋</span>, stored in a separate code section or library. The instrumentation code first runs any <em>pre-instrumentation</em> code that you added <span class="ent">➌</span>, which is code that runs before the original instruction. Next, it runs the original <code>mov edx,0x1</code> instruction <span class="ent">➍</span> and then the<em> post-instrumentation</em> code <span class="ent">➎</span>. Finally, the instrumentation code jumps back to the instruction following the instrumentation point <span class="ent">➏</span>, resuming normal execution.</p>&#13;
<p class="indent">Note that if the pre-instrumentation or post-instrumentation code changes register contents, that may inadvertently affect other parts of the program. That’s why SBI platforms store the register state before running this added code and restore the state afterward, unless you explicitly tell the SBI platform that you<em> want</em> to change the register state.</p>&#13;
<p class="indent">As you can see, the approach in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> is a simple and elegant way to run arbitrary amounts of code of your choice before or after any instruction. So what’s the problem with this approach? The issue is that <code>jmp</code> instructions take up multiple bytes; to jump to instrumentation code, you typically need a 5-byte <code>jmp</code> instruction that consists of 1 opcode byte with a 32-bit offset.</p>&#13;
<p class="indent">When you instrument a short instruction, the <code>jmp</code> to your instrumentation code may be longer than the instruction it replaces. For example, the <code>xor esi,esi</code> instruction at the top left of <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> is only 2 bytes long, so if you replace that with a 5-byte <code>jmp</code>, the <code>jmp</code> will overwrite and corrupt part of <span epub:type="pagebreak" id="page_228"/>the next instruction. You can’t solve this issue by making that next overwritten instruction part of the instrumentation code because the instruction may be a branch target. Any branches targeting that instruction would end up in the middle of the <code>jmp</code> you inserted, breaking the binary.</p>&#13;
<p class="indent">This brings us back to the <code>int 3</code> instruction. You can use the <code>int 3</code> instruction to instrument short instructions where multibyte jumps don’t fit, as you’ll see next.</p>&#13;
<h3 class="h3">Solving the Multibyte Jump Problem with int 3</h3>&#13;
<p class="noindent">The x86 <code>int 3</code> instruction generates a software interrupt that user-space programs like SBI libraries or debuggers can catch (on Linux) in the form of a <code>SIGTRAP</code> signal delivered by the operating system. The key detail about <code>int 3</code> is that it’s only 1 byte long, so you can overwrite any instruction with it without fear of overwriting a neighboring instruction. The opcode for <code>int 3</code> is <code>0xcc</code>.</p>&#13;
<p class="indent">From an SBI viewpoint, to instrument an instruction using <code>int3</code>, you simply overwrite the first byte of that instruction with <code>0xcc</code>. When a <code>SIGTRAP</code> happens, you can use Linux’s <code>ptrace</code> API to find out at which address the interrupt occurred, telling you the instrumentation point address. You can then invoke the appropriate instrumentation code for that instrumentation point, just as you saw in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>.</p>&#13;
<p class="indent">From a purely functional standpoint, <code>int 3</code> is an ideal way to implement SBI because it’s easy to use and doesn’t require any code relocation. Unfortunately, software interrupts like <code>int 3</code> are slow, causing excessive overhead in the instrumented application. Moreover, the<em> int 3 approach</em> is incompatible with programs that are already being debugged using <code>int 3</code> for breakpoints. That’s why in practice many SBI platforms use more complicated but faster rewriting methods, such as the trampoline approach.</p>&#13;
<h4 class="h4" id="ch09_2_2"><em>9.2.2 The Trampoline Approach</em></h4>&#13;
<p class="noindent">Unlike the <code>int 3</code> approach, the trampoline approach makes no attempt to instrument the original code directly. Instead, it creates a copy of all the original code and instruments only this copied code. The idea is that this won’t break any code or data references because these all still point to the original, unchanged locations. To ensure that the binary runs the instrumented code instead of the original code, the trampoline approach uses <code>jmp</code> instructions called<em> trampolines</em> to redirect the original code to the instrumented copy. Whenever a call or jump transfers control to a part of the original code, the trampoline at that location immediately jumps to the corresponding instrumented code.</p>&#13;
<p class="indent">To clarify the trampoline approach, consider the example shown in <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>. The figure shows an uninstrumented binary on the left side, while the right side shows how that binary transforms when you instrument it.</p>&#13;
<div class="image"><a id="ch09fig2"/><img src="Images/f229-01.jpg" alt="image" width="695" height="726"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_229"/><em>Figure 9-2: Static binary instrumentation with trampolines</em></p>&#13;
<p class="indent">Let’s assume the original noninstrumented binary contains two functions called <code>f1</code> and <code>f2</code>. <a href="ch09.xhtml#ch09fig2">Figure 9-2</a> shows that <code>f1</code> contains the following code. The contents of <code>f2</code> are not important for this example.</p>&#13;
<pre>&lt;f1&gt;:<br/>  test edi,edi<br/>  jne _ret<br/>  xor eax,eax<br/>  call f2<br/>_ret:<br/>  ret</pre>&#13;
<p class="indent">When you instrument a binary using the trampoline approach, the SBI engine creates copies of all the original functions, places them in a new code section (called <code>.text.instrum</code> in <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>), and overwrites the first <span epub:type="pagebreak" id="page_230"/>instruction of each original function with a <code>jmp</code> trampoline that jumps to the corresponding copied function. For example, the SBI engine rewrites the original <code>f1</code> as follows to redirect it to <code>f1_copy</code>:</p>&#13;
<pre>&lt;f1&gt;:<br/>  jmp f1_copy<br/>  ; junk bytes</pre>&#13;
<p class="indent">The trampoline instruction is a 5-byte <code>jmp</code>, so it may partially overwrite and corrupt multiple instructions, creating “junk bytes” just after the trampoline. However, this isn’t normally a problem for the trampoline approach because it ensures that these corrupted instructions are never executed. You’ll see some cases where this may go wrong at the end of this section.</p>&#13;
<h3 class="h3">Trampoline Control Flow</h3>&#13;
<p class="noindent">To get a better sense of the control flow of a program instrumented with the trampoline approach, let’s return to the right side of <a href="ch09.xhtml#ch09fig2">Figure 9-2</a> showing the instrumented binary and assume that the original <code>f1</code> function has just been called. As soon as <code>f1</code> is called, the trampoline jumps to <code>f1_copy</code> <span class="ent">➊</span>, the instrumented version of <code>f1</code>. There may be some junk bytes following the trampoline <span class="ent">➋</span>, but these aren’t executed.</p>&#13;
<p class="indent">The SBI engine inserts several <code>nop</code> instructions at every possible instrumentation point in <code>f1_copy</code> <span class="ent">➌</span>. That way, to instrument an instruction, the SBI engine can simply overwrite the <code>nop</code> instructions at that instrumentation point with a <code>jmp</code> or <code>call</code> to a chunk of instrumentation code. Note that both the <code>nop</code> insertion and the instrumentation are done statically, not at runtime. In <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>, all of the <code>nop</code> regions are unused except for the last one, just before the <code>ret</code> instruction, as I’ll explain in a moment.</p>&#13;
<p class="indent">To maintain the correctness of relative jumps despite the code shifting because of newly inserted instructions, the SBI engine patches the offsets of all relative <code>jmp</code> instructions. Additionally, the engine replaces all 2-byte relative <code>jmp</code> instructions, which have an 8-bit offset, with a corresponding 5-byte version that has a 32-bit offset <span class="ent">➍</span>. This is necessary because as you shift code around in <code>f1_copy</code>, the offset between <code>jmp</code> instructions and their targets may become too large to encode in 8 bits.</p>&#13;
<p class="indent">Similarly, the SBI engine rewrites direct calls, such as <code>call f2</code>, so that they target the instrumented function instead of the original <span class="ent">➎</span>. Given this rewriting of direct calls, you may wonder why the trampolines at the start of every original function are needed at all. As I’ll explain in a moment, they’re necessary to accommodate indirect calls.</p>&#13;
<p class="indent">Now let’s assume you’ve told the SBI engine to instrument every <code>ret</code> instruction. To do this, the SBI engine overwrites the <code>nop</code> instructions reserved for this purpose with a <code>jmp</code> or <code>call</code> to your instrumentation code <span class="ent">➏</span>. In the example of <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>, the instrumentation code is a function named <code>hook_ret</code>, which is placed in a shared library and reached by a <code>call</code> that the SBI engine placed at the instrumentation point.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_231"/>The <code>hook_ret</code> function first saves state <span class="ent">➐</span>, such as register contents, and then runs any instrumentation code that you specified. Finally, it restores the saved state <span class="ent">➑</span> and resumes normal execution by returning to the instruction following the instrumentation point.</p>&#13;
<p class="indent">Now that you’ve seen how the trampoline approach rewrites direct control flow instructions, let’s take a look at how it handles indirect control flow.</p>&#13;
<h3 class="h3">Handling Indirect Control Flow</h3>&#13;
<p class="noindent">Because indirect control flow instructions target dynamically computed addresses, there’s no reliable way for SBI engines to statically redirect them. The trampoline approach allows indirect control transfers to flow to original, uninstrumented code and uses trampolines placed in the original code to intercept and redirect the control flow back to the instrumented code. <a href="ch09.xhtml#ch09fig3">Figure 9-3</a> shows how the trampoline approach handles two types of indirect control flow: indirect function calls and indirect jumps used to implement C/C++ <code>switch</code> statements.</p>&#13;
<div class="image"><a id="ch09fig3"/><img src="Images/f231-01.jpg" alt="image" width="599" height="430"/></div>&#13;
<p class="fig-caption"><em>Figure 9-3: Indirect control transfers in a statically instrumented binary</em></p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09fig3">Figure 9-3a</a> shows how the trampoline approach handles indirect calls. The SBI engine doesn’t alter code that computes addresses, so the target addresses used by indirect calls point to the original function <span class="ent">➊</span>. Because there’s a trampoline at the start of every original function, control flows immediately back to the instrumented version of the function <span class="ent">➋</span>.</p>&#13;
<p class="indent">For indirect jumps, things are more complicated, as you can see in <a href="ch09.xhtml#ch09fig3">Figure 9-3b</a>. For the purposes of this example, let’s assume an indirect jump that’s part of a C/C++ <code>switch</code> statement. At the binary level, switch statements are often implemented using a<em> jump table</em> that contains all the addresses of the possible <code>switch</code> cases. To jump to a particular case, the <code>switch</code> computes <span epub:type="pagebreak" id="page_232"/>the corresponding jump table index and uses an indirect <code>jmp</code> to jump to the address stored there <span class="ent">➊</span>.</p>&#13;
<div class="box">&#13;
<p class="headbox">Trampolines in Position-Independent Code</p>&#13;
<p class="noindent">SBI engines based on the trampoline approach require special support for indirect control flows in position-independent executables (PIE binaries), which don’t depend on any particular load address. PIE binaries read the value of the program counter and use it as the basis for address computations. On 32-bit x86, PIE binaries read the program counter by executing a <code>call</code> instruction and then reading the return address from the stack. For example, <code>gcc 5.4.0</code> emits the following function that you can call to read the address of the instruction after the <code>call</code>:</p>&#13;
<pre>&lt;__x86.get_pc_thunk.bx&gt;:<br/>  mov ebx,DWORD PTR [esp]<br/>  ret</pre>&#13;
<p class="indent">This function copies the return address into <code>ebx</code> and then returns. On x64, you can read the program counter (<code>rip</code>) directly.</p>&#13;
<p class="indent">The danger with PIE binaries is that they may read the program counter while running instrumented code and use it in address computations. This likely yields incorrect results because the layout of the instrumented code differs from the original layout that the address computation assumes. To solve this, SBI engines instrument code constructs that read the program counter such that they return the value the program counter would have in the original code. That way, subsequent address computations yield the original code location just as in an uninstrumented binary, allowing the SBI engine to intercept control there with a trampoline.</p>&#13;
</div>&#13;
<p class="indent">By default, the addresses stored in the jump table all point into the original code <span class="ent">➋</span>. Thus, the indirect <code>jmp</code> ends up in the middle of an original function, where there’s no trampoline, and resumes execution there <span class="ent">➌</span>. To avoid this problem, the SBI engine must either patch the jump table, changing original code addresses to new ones, or place a trampoline at every <code>switch</code> case in the original code.</p>&#13;
<p class="indent">Unfortunately, basic symbolic information (as opposed to extensive DWARF information) contains no information on the layout of <code>switch</code> statements, making it hard to figure out where to place the trampolines. Additionally, there may not be enough room between the <code>switch</code> statements to accommodate all trampolines. Patching jump tables is also dangerous because you risk erroneously changing data that just happens to be a valid address but isn’t really part of a jump table.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_233"/>Reliability of the Trampoline Approach</h3>&#13;
<p class="noindent">As you can tell from the problems handling <code>switch</code> statements, the trampoline approach is error-prone. Similar to <code>switch</code> cases that are too small to accommodate a normal trampoline, programs may (however unlikely) contain very short functions that don’t have enough room for a 5-byte <code>jmp</code>, requiring the SBI engine to fall back to another solution like the <code>int 3</code> approach. Moreover, if the binary contains any inline data mixed in with the code, trampolines may inadvertently overwrite part of that data, causing errors when the program uses the data. All this is assuming that the disassembly used is correct in the first place; if it’s not, any changes made by the SBI engine may break the binary.</p>&#13;
<p class="indent">Unfortunately, there’s no known SBI technique that’s both efficient and sound, making SBI dangerous to use on production binaries. In many cases, DBI solutions are preferable, because they’re not prone to the errors SBI faces. Although they’re not as fast as SBI, modern DBI platforms perform efficiently enough for many practical use cases. The rest of this chapter focuses on DBI, specifically on a well-known DBI platform called Pin. Let’s take a look at some of DBI’s implementation details and then explore practical examples.</p>&#13;
<h3 class="h3" id="ch09_3">9.3 Dynamic Binary Instrumentation</h3>&#13;
<p class="noindent">Because DBI engines monitor binaries (or rather, processes) as they execute and instrument the instruction stream, they don’t require disassembly or binary rewriting like SBI does, making them less error-prone.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09fig4">Figure 9-4</a> shows the architecture of modern DBI systems like Pin and DynamoRIO. These systems are all based on the same high-level approach, although they differ in implementation details and optimizations. I’ll focus the rest of this chapter on the kind of “pure” DBI systems shown in the figure, rather than hybrid platforms like Dyninst that support both SBI and DBI by using code-patching techniques such as trampolines.</p>&#13;
<h4 class="h4" id="ch09_3_1"><em>9.3.1 Architecture of a DBI System</em></h4>&#13;
<p class="noindent">DBI engines dynamically instrument processes by monitoring and controlling all the executed instructions. The DBI engine exposes an API that allows you to write user-defined DBI tools (often in the form of a shared library loaded by the engine) that specify which code should be instrumented and how. For example, the DBI tool shown on the right side of <a href="ch09.xhtml#ch09fig4">Figure 9-4</a> implements (in pseudocode) a simple profiler that counts how many basic blocks are executed. To achieve that, it uses the DBI engine’s API to instrument the last instruction of every basic block with a callback to a function that increments a counter.</p>&#13;
<p class="indent">Before the DBI engine starts the main application process (or resumes it, if you attach to an existing process), it allows the DBI tool to initialize itself. In <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>, the DBI tool’s initialization function registers a function called <code>instrument_bb</code> with the DBI engine <span class="ent">➊</span>. This function tells the DBI <span epub:type="pagebreak" id="page_234"/>engine how to instrument every basic block; in this case, it adds a callback to <code>bb_callback</code> after the last instruction in the basic block. Next, the initialization function informs the DBI engine that it’s done initializing and ready to start the application <span class="ent">➋</span>.</p>&#13;
<div class="image"><a id="ch09fig4"/><img src="Images/f234-01.jpg" alt="image" width="696" height="876"/></div>&#13;
<p class="fig-caption"><em>Figure 9-4: Architecture of a DBI system</em></p>&#13;
<p class="indent">The DBI engine never runs the application process directly but instead runs code in a<em> code cache</em> that contains all the instrumented code. Initially, the code cache is empty, so the DBI engine fetches a block of code from the process <span class="ent">➌</span> and instruments that code <span class="ent">➍</span> as instructed by the DBI tool <span class="ent">➎</span>. Note that DBI engines don’t necessarily fetch and instrument code at basic block <span epub:type="pagebreak" id="page_235"/>granularity, as I’ll explain further in <a href="ch09.xhtml#ch09_4">Section 9.4</a>. However, for this example I’ll assume that the engine instruments code at basic block granularity by calling <code>instrument_bb</code>.</p>&#13;
<p class="indent">After instrumenting the code, the DBI engine compiles it with a just-intime (JIT) compiler <span class="ent">➏</span>, which re-optimizes the instrumented code and stores the compiled code in the code cache <span class="ent">➐</span>. The JIT compiler also rewrites control flow instructions to ensure that the DBI engine retains control, preventing control transfers from continuing execution in the uninstrumented application process. Note that unlike most compilers, the JIT compiler in a DBI engine doesn’t translate the code into a different language; it compiles from native machine code to native machine code. It’s only necessary to instrument and JIT-compile code the first time it’s executed. After that, it’s stored in the code cache and reused.</p>&#13;
<p class="indent">The instrumented and JIT-compiled code now executes in the code cache until there’s a control-flow instruction that requires fetching new code or looking up another code chunk in the cache <span class="ent">➑</span> DBI engines like Pin and DynamoRIO reduce runtime overhead by rewriting control-flow instructions when possible, so they jump directly to the next block in the code cache without mediation by the DBI engine. When that’s not possible (for example, for indirect calls), the rewritten instructions return control to the DBI engine so that it can prepare and start the next code chunk.</p>&#13;
<p class="indent">While most instructions run natively in the code cache, the DBI engine may emulate some instructions instead of running them directly. For example, Pin does this for system calls like <code>execve</code> that require special handling by the DBI engine.</p>&#13;
<p class="indent">The instrumented code contains callbacks to functions in the DBI tool that observe or modify the code’s behavior <span class="ent">➒</span>. For instance, in <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>, the DBI tool’s <code>instrument_bb</code> function adds a callback at the end of every basic block that invokes <code>bb_callback</code>, which increments the DBI tool’s basic block counter. The DBI engine automatically saves and restores register state when transferring control to or from a callback function in the DBI tool.</p>&#13;
<p class="indent">Now that you’re familiar with the workings of DBI engines, let’s discuss Pin, the DBI engine I’ll use for the examples in this chapter.</p>&#13;
<h4 class="h4" id="ch09_3_2"><em>9.3.2 Introduction to Pin</em></h4>&#13;
<p class="noindent">One of the most popular DBI platforms, Intel Pin is an actively developed, free-to-use (though not open source), and well-documented tool that offers a relatively easy-to-use API.<sup><a id="ch09fn_8a" href="footnote.xhtml#ch09fn_8">8</a></sup> You’ll find Pin v3.6 preinstalled on the virtual machine in<em> ~/pin/pin-3.6-97554-g31f0a167d-gcc-linux</em>. Pin ships with many example tools that you can find in the<em> source/tools</em> subdirectory of the main Pin directory.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_236"/>Pin Internals</h3>&#13;
<p class="noindent">Pin currently supports Intel CPU architectures including x86 and x64 and is available for Linux, Windows, and macOS. Its architecture is similar to <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>. Pin fetches and JIT-compiles code at<em> trace</em> granularity, a basic block-like abstraction that can be entered only at the top but may contain multiple exits, unlike regular basic blocks.<sup><a id="ch09fn_9a" href="footnote.xhtml#ch09fn_9">9</a></sup> Pin defines a trace as a straight-line instruction sequence that ends when it hits an unconditional control transfer or reaches a predefined maximum length or number of conditional control-flow instructions.</p>&#13;
<p class="indent">Although Pin always JIT-compiles code at trace granularity, it allows you to instrument code at many granularities, including instruction, basic block, trace, function, and image (a complete executable or library). Both Pin’s DBI engine and Pintools run in user space, so you can only instrument user-space processes with Pin.</p>&#13;
<h3 class="h3">Implementing Pintools</h3>&#13;
<p class="noindent">The DBI tools you implement with Pin are called<em> Pintools</em>, which are shared libraries that you write in C/C++ using the Pin API. The Pin API is architecture independent as far as possible, using architecture-specific components only when needed. This allows you to write Pintools that are portable between architectures or require only minimal changes to support another architecture.</p>&#13;
<p class="indent">To create a Pintool, you write two different kinds of functions:<em> instrumentation routines</em> and<em> analysis routines</em>. Instrumentation routines tell Pin which instrumentation code to add and where; these functions run only the first time Pin encounters a particular piece of code that’s not yet instrumented. To instrument code, the instrumentation routines install callbacks to analysis routines that contain the actual instrumentation code and are called every time an instrumented code sequence runs.</p>&#13;
<p class="indent">Note that you shouldn’t confuse Pin’s<em> instrumentation routines</em> with the SBI term<em> instrumentation code</em>. Instrumentation code is new code added to an instrumented program and corresponds to Pin’s analysis routines, not to the instrumentation routines that insert the callbacks to the analysis routines. The distinction between instrumentation and analysis routines will become clearer in the practical examples that follow.</p>&#13;
<p class="indent">Because of Pin’s popularity, many other binary analysis platforms are based on it. For example, you’ll see Pin again in <a href="ch10.xhtml#ch10">Chapters 10</a> through <a href="ch13.xhtml#ch13">13</a> about dynamic taint analysis and symbolic execution.</p>&#13;
<p class="indent">In this chapter, you’ll see two practical examples implemented with Pin: a profiling tool and an automatic unpacker. In the course of implementing these tools, you’ll learn about Pin’s internals, such as the instrumentation points it supports. Let’s start with the profiling tool.</p>&#13;
<h3 class="h3" id="ch09_4"><span epub:type="pagebreak" id="page_237"/>9.4 Profiling with Pin</h3>&#13;
<p class="noindent">The profiling tool records statistics about a program’s execution to help optimize that program. Specifically, it counts the number of executed instructions and the number of times basic blocks, functions, and syscalls are invoked.</p>&#13;
<h4 class="h4" id="ch09_4_1"><em>9.4.1 The Profiler’s Data Structures and Setup Code</em></h4>&#13;
<p class="noindent"><a href="ch09.xhtml#ch09list1">Listing 9-1</a> shows the first part of the profiler’s code. The following discussion omits standard includes and functions that don’t use any Pin functionality, such as the usage function and the function that prints the results. You can see these in the<em> profiler.cpp</em> source file on the VM. I’ll refer to the profiler Pintool as “the Pintool” or “the profiler” and to the profiled program, which the profiler instruments, as “the application.”</p>&#13;
<p class="listing1" id="ch09list1"><em>Listing 9-1:</em> profiler.cpp</p>&#13;
<pre><span class="ent">➊</span> #include "pin.H"<br/><br/><span class="ent">➋</span> KNOB&lt;bool&gt; ProfileCalls(KNOB_MODE_WRITEONCE, "pintool", "c", "0", "Profile function calls");<br/>   KNOB&lt;bool&gt; ProfileSyscalls(KNOB_MODE_WRITEONCE, "pintool", "s", "0", "Profile syscalls");<br/><br/><span class="ent">➌</span> std::map&lt;ADDRINT, std::map&lt;ADDRINT, unsigned long&gt; &gt; cflows;<br/>   std::map&lt;ADDRINT, std::map&lt;ADDRINT, unsigned long&gt; &gt; calls;<br/>   std::map&lt;ADDRINT, unsigned long&gt; syscalls;<br/>   std::map&lt;ADDRINT, std::string&gt; funcnames;<br/><br/>   unsigned long insn_count    = 0;<br/>   unsigned long cflow_count   = 0;<br/>   unsigned long call_count    = 0;<br/>   unsigned long syscall_count = 0;<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/><span class="ent">➍</span>   PIN_InitSymbols();<br/><span class="ent">➎</span>   if(PIN_Init(argc,argv)) {<br/>       print_usage();<br/>       return 1;<br/>     }<br/><br/><span class="ent">➏</span>   IMG_AddInstrumentFunction(parse_funcsyms, NULL);<br/>     TRACE_AddInstrumentFunction(instrument_trace, NULL);<br/>     INS_AddInstrumentFunction(instrument_insn, NULL);<br/><span class="ent">➐</span>   if(ProfileSyscalls.Value()) {<br/>       PIN_AddSyscallEntryFunction(log_syscall, NULL);<br/>     }<br/><br/><span epub:type="pagebreak" id="page_238"/><br/><span class="ent">➑</span>   PIN_AddFiniFunction(print_results, NULL);<br/><br/>     /* Never returns */<br/><span class="ent">➒</span>   PIN_StartProgram();<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent">Every Pintool must include <em>pin.H</em> to access the Pin API <span class="ent">➊</span>.<sup><a id="ch09fn_10a" href="footnote.xhtml#ch09fn_10">10</a></sup> This single header file provides the entire API.</p>&#13;
<p class="indent">Note that Pin observes the program starting from the first instruction, which means the profiler sees not only the application code but also the instructions executed by the dynamic loader and shared libraries. This is important to keep in mind for all Pintools that you write.</p>&#13;
<h3 class="h3">Command Line Options and Data Structures</h3>&#13;
<p class="noindent">Pintools can implement tool-specific command line options, which are called<em> knobs</em> in Pin parlance. The Pin API includes a dedicated <code>KNOB</code> class that you use to create command line options. In <a href="ch09.xhtml#ch09list1">Listing 9-1</a>, there are two Boolean options (<code>KNOB&lt;bool&gt;</code>) <span class="ent">➋</span> called <code>ProfileCalls</code> and <code>ProfileSyscalls</code>. The options use mode <code>KNOB_MODE_WRITEONCE</code> because they’re Boolean flags that are set only once when you supply the flag. You enable the <code>ProfileCalls</code> option by passing the flag <code>-c</code> to the Pintool, and you enable <code>ProfileSyscalls</code> by passing <code>-s</code>. (You’ll see how to pass these options in the profiler tests.) Both options have the default value 0, meaning they’re false if you don’t pass the flag. Pin also allows you to create other types of command line options, such as <code>string</code> or <code>int</code> options. To learn more about these options, you can refer to the Pin documentation online or take a look at the example tools.</p>&#13;
<p class="indent">The profiler uses multiple <code>std::map</code> data structures and counters to keep track of the program’s runtime statistics <span class="ent">➌</span>. The <code>cflows</code> and <code>calls</code> data structures map addresses of control flow targets (basic blocks or functions) to another map that in turn tracks the addresses of the control flow instructions (jumps, calls, and so on) that invoked each target and counts how often that control transfer was taken. The <code>syscall</code> map simply tracks how often each syscall number was invoked, and <code>funcnames</code> maps function addresses to symbolic names, if known. The counters (<code>insn_count</code>, <code>cflow_count</code>, <code>call_count</code>, and <code>syscall_count</code>) track the total number of executed instructions, control flow instructions, calls, and syscalls, respectively.</p>&#13;
<h3 class="h3">Initializing Pin</h3>&#13;
<p class="noindent">Like normal C/C++ programs, Pintools start in the <code>main</code> function. The first Pin function that the profiler calls is <code>PIN_InitSymbols</code> <span class="ent">➍</span>, which causes Pin to read the application’s symbol tables. To use symbols in your Pintool, Pin requires that you call <code>PIN_InitSymbols</code> before any other Pin API function. The <span epub:type="pagebreak" id="page_239"/>profiler uses symbols when they’re available to show human-readable statistics on how often each function was called.</p>&#13;
<p class="indent">The next function the profiler calls is <code>PIN_Init</code> <span class="ent">➎</span>, which initializes Pin and must be called before any other Pin function except <code>PIN_InitSymbols</code>. It returns <code>true</code> if anything went wrong during initialization, in which case the profiler prints usage instructions and exits. The <code>PIN_Init</code> function processes Pin’s command line options as well as your Pintool’s options as specified by the <code>KNOB</code>s you created. Usually, your Pintool won’t need to implement any of its own command line processing code.</p>&#13;
<h3 class="h3">Registering Instrumentation Functions</h3>&#13;
<p class="noindent">Now that Pin is initialized, it’s time to initialize the Pintool. The most important part of that is registering the instrumentation routines that are responsible for instrumenting the application.</p>&#13;
<p class="indent">The profiler registers three instrumentation routines <span class="ent">➏</span>. The first of these, called <code>parse_funcsyms</code>, instruments at image granularity, while <code>instrument_trace</code> and <code>instrument_insn</code> instrument at trace and instruction granularity, respectively. To register these routines with Pin, you call <code>IMG _AddInstrumentFunction</code>, <code>TRACE_AddInstrument Function</code>, and <code>INS_AddInstrument Function</code>, respectively. Note that you can add as many instrumentation routines of each type as you want.</p>&#13;
<p class="indent">As you’ll see shortly, the three instrumentation routines take an <code>IMG</code>, a <code>TRACE</code>, and an <code>INS</code> object as their first parameter, respectively, depending on their type. Additionally, they all take a <code>void*</code> as their second parameter, which allows you to pass a Pintool-specific data structure that you specify when you register the instrumentation routines using <code>*_AddInstrument Function</code>. The profiler doesn’t use this facility (it passes <code>NULL</code> for each <code>void*</code>).</p>&#13;
<h3 class="h3">Registering a Syscall Entry Function</h3>&#13;
<p class="noindent">Pin also allows you to register functions that are called before or after every syscall, in the same way as you register instrumentation callbacks. Note that you can’t specify callbacks for only some syscalls; you can only differentiate between syscalls inside the callback function.</p>&#13;
<p class="indent">The profiler uses <code>PIN_AddSyscallEntryFunction</code> to register a function named <code>log_syscall</code> that’s called whenever a syscall is entered <span class="ent">➐</span>. To register a callback that triggers when a syscall exits, use <code>PIN_AddSyscallExitFunction</code> instead. The profiler registers the callback only if <code>ProfileSyscalls.Value()</code>, the value of the <code>ProfileSyscalls</code> knob, is <code>true</code>.</p>&#13;
<h3 class="h3">Registering a Fini Function</h3>&#13;
<p class="noindent">The final callback that the profiler registers is a<em> fini function</em>, which is called when the application exits or when you detach Pin from it <span class="ent">➑</span>. Fini functions receive an exit status code (an <code>INT32</code>) and a user-defined <code>void*</code>. To register a fini function, you use <code>PIN_AddFiniFunction</code>. Note that fini functions may not be called reliably for some programs, depending on how the program exits.</p>&#13;
<p class="indent">The fini function that the profiler registers is responsible for printing the profiling results. I won’t discuss it here because it doesn’t contain any <span epub:type="pagebreak" id="page_240"/>Pin-specific code, but you can see the output of <code>print_results</code> when testing the profiler.</p>&#13;
<h3 class="h3">Starting the Application</h3>&#13;
<p class="noindent">The last step of every Pintool’s initialization is to call <code>PIN_StartProgram</code>, which starts the application running <span class="ent">➒</span>. After that, it’s no longer possible to register any new callbacks; the Pintool gets back control only when an instrumentation or analysis routine is called. The <code>PIN_StartProgram</code> function never returns, meaning that the <code>return 0</code> at the end of <code>main</code> is never reached.</p>&#13;
<h4 class="h4" id="ch09_4_2"><em>9.4.2 Parsing Function Symbols</em></h4>&#13;
<p class="noindent">Now that you know how to initialize a Pintool and register instrumentation routines and other callbacks, let’s take a detailed look at the callback functions just registered. Let’s start with <code>parse_funcsyms</code>, shown in <a href="ch09.xhtml#ch09list2">Listing 9-2</a>.</p>&#13;
<p class="listing1" id="ch09list2"><em>Listing 9-2:</em> profiler.cpp<em> (continued)</em></p>&#13;
<pre>   static void<br/>   parse_funcsyms(IMG img, void *v)<br/>   {<br/><span class="ent">➊</span>    if(!IMG_Valid(img)) return;<br/><br/><span class="ent">➋</span>    for(SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)) {<br/><span class="ent">➌</span>      for(RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn)) {<br/><span class="ent">➍</span>        funcnames[RTN_Address(rtn)] = RTN_Name(rtn);<br/>        }<br/>      }<br/>   }</pre>&#13;
<p class="indent">Recall that <code>parse_funcsyms</code> is an image-granularity instrumentation routine, which you can tell because it receives an <code>IMG</code> object as its first argument. Image instrumentation routines are called when a new image (an executable or shared library) loads, allowing you to instrument the image as a whole. Among other things, this lets you loop over all the functions in the image and add analysis routines that run before or after each function. Note that function instrumentation is reliable only if the binary contains symbolic information, and after-function instrumentation doesn’t work with some optimizations, such as tail calls.</p>&#13;
<p class="indent">However, <code>parse_funcsyms</code> doesn’t add any instrumentation at all. Instead, it takes advantage of another feature of image instrumentation, which lets you inspect the symbolic names of all functions in the image. The profiler saves these names so that it can read them back later to show human-readable function names in the output.</p>&#13;
<p class="indent">Before using its <code>IMG</code> argument, <code>parse_funcsyms</code> calls <code>IMG_Valid</code> to ensure that it’s a valid image <span class="ent">➊</span>. If it is, <code>parse_funcsyms</code> loops over all the <code>SEC</code> objects in the image, which represent all the sections <span class="ent">➋</span>. <code>IMG_SecHead</code> returns the first section in the image, and <code>SEC_Next</code> returns the next section; the loop <span epub:type="pagebreak" id="page_241"/>continues until <code>SEC_Valid</code> returns <code>false</code>, indicating that there’s no next remaining section.</p>&#13;
<p class="indent">For each section, <code>parse_funcsyms</code> loops over all the functions (represented by <code>RTN</code> objects, as in “routine”) <span class="ent">➌</span> and maps each function’s address (as returned by <code>RTN_Address</code>) in the <code>funcnames</code> map to the symbolic name of the function (as returned by <code>RTN_Name</code>) <span class="ent">➍</span>. If the function’s name is not known (for example, when the binary has no symbol table), <code>RTN_Name</code> returns an empty string.</p>&#13;
<p class="indent">After <code>parse_funcsyms</code> completes, <code>funcnames</code> contains a mapping of all known function addresses to symbolic names.</p>&#13;
<h4 class="h4" id="ch09_4_3"><em>9.4.3 Instrumenting Basic Blocks</em></h4>&#13;
<p class="noindent">Recall that one of the things the profiler records is the number of instructions the program executes. To that end, the profiler instruments every basic block with a call to an analysis function that increases the instruction counter (<code>insn_count</code>) by the number of instructions in the basic block.</p>&#13;
<h3 class="h3">A Few Notes on Basic Blocks in Pin</h3>&#13;
<p class="noindent">Because Pin discovers basic blocks dynamically, the basic blocks that Pin finds may differ from what you would find based on static analysis. For example, Pin may initially find a large basic block, only to later discover a jump into the middle of that basic block, forcing Pin to renew its decision, break the basic block in two, and reinstrument both basic blocks. Although this doesn’t matter for the profiler since it doesn’t care about the shape of basic blocks, only the number of executed instructions, it’s important to keep in mind to prevent confusion with some Pintools.</p>&#13;
<p class="indent">Also note that as an alternative implementation, you could increment <code>insn_count</code> on every instruction. However, that would be significantly slower than the basic block-level implementation because it requires one callback per instruction to the analysis function that increments <code>insn_count</code>. In contrast, the basic block-level implementation requires only one callback per basic block. When writing a Pintool, it’s important to optimize the analysis routines as much as you can because they’re called repeatedly throughout the execution, unlike instrumentation routines, which are called only the first time a piece of code is encountered.</p>&#13;
<h3 class="h3">Implementing Basic Block Instrumentation</h3>&#13;
<p class="noindent">You can’t directly instrument basic blocks in the Pin API. That is, there’s no <code>BBL_AddInstrumentFunction</code>. To instrument basic blocks, you have to add a trace-level instrumentation routine and then loop over all the basic blocks in the trace, instrumenting each one, as shown in <a href="ch09.xhtml#ch09list3">Listing 9-3</a>.</p>&#13;
<p class="listing1" id="ch09list3"><em>Listing 9-3:</em> profiler.cpp<em> (continued)</em></p>&#13;
<pre>   static void<br/>   instrument_trace(TRACE trace, void *v)<br/>   {<br/><span epub:type="pagebreak" id="page_242"/><span class="ent">➊</span>    IMG img = IMG_FindByAddress(TRACE_Address(trace));<br/>     if(!IMG_Valid(img) || !IMG_IsMainExecutable(img)) return;<br/><br/><span class="ent">➋</span>    for(BBL bb = TRACE_BblHead(trace); BBL_Valid(bb); bb = BBL_Next(bb)) {<br/><span class="ent">➌</span>      instrument_bb(bb);<br/>     }<br/>   }<br/><br/>   static void<br/>   instrument_bb(BBL bb)<br/>   {<br/><span class="ent">➍</span>    BBL_InsertCall(<br/>       bb, <span class="ent">➎</span>IPOINT_ANYWHERE, <span class="ent">➏</span>(AFUNPTR)count_bb_insns,<br/>       <span class="ent">➐</span>IARG_UINT32, BBL_NumIns(bb),<br/>       <span class="ent">➑</span>IARG_END<br/>     );<br/>   }</pre>&#13;
<p class="indent">The first function in the listing, <code>instrument_trace</code>, is the trace-level instrumentation routine that the profiler registered earlier. Its first argument is the <code>TRACE</code> to instrument.</p>&#13;
<p class="indent">First, <code>instrument_trace</code> calls <code>IMG_FindByAddress</code> with the trace’s address to find the <code>IMG</code> that the trace is part of <span class="ent">➊</span>. Next, it verifies that the image is valid and calls <code>IMG_IsMainExecutable</code> to check that the trace is part of the main application executable. If not, <code>instrument_trace</code> returns without instrumenting the trace. The rationale behind this is that when you’re profiling an application, you typically want to count code only inside the application itself, not code in shared libraries or the dynamic loader.</p>&#13;
<p class="indent">If the trace is valid and part of the main application, <code>instrument_trace</code> loops over all the basic blocks (<code>BBL</code> objects) in the trace <span class="ent">➋</span>. For each <code>BBL</code>, it calls <code>instrument_bb</code> <span class="ent">➌</span>, which performs the actual instrumentation of each <code>BBL</code>.</p>&#13;
<p class="indent">To instrument a given <code>BBL</code>, <code>instrument_bb</code> calls <code>BBL_InsertCall</code> <span class="ent">➍</span>, which is Pin’s API function to instrument a basic block with an analysis routine callback. The <code>BBL_InsertCall</code> function takes three mandatory arguments: the basic block to instrument (<code>bb</code> in this case), an<em> insertion point</em>, and a function pointer to the analysis routine you want to add.</p>&#13;
<p class="indent">The insertion point determines where in the basic block Pin inserts the analysis callback. In this case, the insertion point is <code>IPOINT_ANYWHERE</code> <span class="ent">➎</span> because it doesn’t matter at what point in the basic block the instruction counter is updated. This allows Pin to optimize the placement of the analysis callback. <a href="ch09.xhtml#ch09tab2">Table 9-2</a> shows all the possible insertion points. These apply not only for basic block-level instrumentation but also for instruction instrumentation and all other granularities.</p>&#13;
<p class="indent">The name of the analysis routine is <code>count_bb_insns</code> <span class="ent">➏</span>, and you’ll see its implementation in a moment. Pin provides an <code>AFUNPTR</code> type that you should cast function pointers to when passing them to Pin API functions.</p>&#13;
<p class="tab-caption" id="ch09tab2"><span epub:type="pagebreak" id="page_243"/>Table 9-2: Pin Insertion Points</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Insertion point</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Analysis callback</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Validity</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>IPOINT_BEFORE</code></td>&#13;
<td>Before instrumented object</td>&#13;
<td>Always valid</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>IPOINT_AFTER</code></td>&#13;
<td>On fallthrough edge (of branch or “regular” instruction)</td>&#13;
<td>If <code>INS_HasFallthrough</code> is <code>true</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>IPOINT_ANYWHERE</code></td>&#13;
<td>Anywhere in instrumented object</td>&#13;
<td>For <code>TRACE</code> or <code>BBL</code> only</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;"><code>IPOINT_TAKEN_BRANCH</code></td>&#13;
<td style="border-bottom: solid 0.2em;">On taken edge of branch</td>&#13;
<td style="border-bottom: solid 0.2em;">If <code>INS_IsBranchOrCall</code> is <code>true</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">After the mandatory arguments to <code>BBL_InsertCall</code>, you can add optional arguments to pass to the analysis routine. In this case, there’s an optional argument of type <code>IARG_UINT32</code> <span class="ent">➐</span> with value <code>BBL_NumIns</code>. This way, the analysis routine (<code>count_bb_insns</code>) receives a <code>UINT32</code> argument containing the number of instructions in the basic block so that it can increment the instruction counter as needed. You’ll see other types of arguments in the rest of this example and the next example. You can find a complete overview of all possible argument types in the Pin documentation. When you’re done passing in optional arguments, you add the special argument <code>IARG_END</code> <span class="ent">➑</span> to inform Pin that the argument list is complete.</p>&#13;
<p class="indent">The final result of the code in <a href="ch09.xhtml#ch09list3">Listing 9-3</a> is that Pin instruments each executed basic block in the main application with a callback to <code>count _bb_insns</code>, which increases the profiler’s instruction counter by the number of instructions in the basic block.</p>&#13;
<h4 class="h4" id="ch09_4_4"><em>9.4.4 Instrumenting Control Flow Instructions</em></h4>&#13;
<p class="noindent">Besides counting how many instructions the application executes, the profiler also counts the number of control flow transfers and, optionally, the number of calls. It uses the instruction-level instrumentation routine shown in <a href="ch09.xhtml#ch09list4">Listing 9-4</a> to insert the analysis callbacks that count control-flow transfers and calls.</p>&#13;
<p class="listing1" id="ch09list4"><em>Listing 9-4:</em> profiler.cpp<em> (continued)</em></p>&#13;
<pre>   static void<br/>   instrument_insn(INS ins, void *v)<br/>   {<br/><span class="ent">➊</span>   if(!INS_IsBranchOrCall(ins)) return;<br/><br/>     IMG img = IMG_FindByAddress(INS_Address(ins));<br/>     if(!IMG_Valid(img) || !IMG_IsMainExecutable(img)) return;<br/><br/><span class="ent">➋</span>   INS_InsertPredicatedCall(<br/>       ins, <span class="ent">➌</span>IPOINT_TAKEN_BRANCH, (AFUNPTR)count_cflow,<br/>       <span class="ent">➍</span>IARG_INST_PTR, <span class="ent">➎</span>IARG_BRANCH_TARGET_ADDR,<br/>       IARG_END<br/>     );<br/> <span epub:type="pagebreak" id="page_244"/><br/><span class="ent">➏</span>   if(INS_HasFallThrough(ins)) {<br/>       INS_InsertPredicatedCall(<br/>         ins, <span class="ent">➐</span>IPOINT_AFTER, (AFUNPTR)count_cflow,<br/>         IARG_INST_PTR, <span class="ent">➑</span>IARG_FALLTHROUGH_ADDR,<br/>         IARG_END<br/>       );<br/>     }<br/><br/><span class="ent">➒</span>   if(INS_IsCall(ins)) {<br/>       if(ProfileCalls.Value()) {<br/>         INS_InsertCall(<br/>           ins, <span class="ent">➓</span>IPOINT_BEFORE, (AFUNPTR)count_call,<br/>           IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR,<br/>           IARG_END<br/>         );<br/>       }<br/>     }<br/>   }</pre>&#13;
<p class="indent">The instrumentation routine, named <code>instrument_insn</code>, receives an <code>INS</code> object as its first argument, representing the instruction to instrument. First, <code>instrument_insn</code> calls <code>INS_IsBranchOrCall</code> to check whether this is a control-flow instruction <span class="ent">➊</span>. If not, it doesn’t add any instrumentation. After ensuring that it’s dealing with a control-flow instruction, <code>instrument_insn</code> checks that the instruction is part of the main application, just as you saw for the basic block instrumentation.</p>&#13;
<h3 class="h3">Instrumenting the Taken Edge</h3>&#13;
<p class="noindent">To record control transfers and calls, <code>instrument_insn</code> inserts three different analysis callbacks. First, it uses <code>INS_InsertPredicatedCall</code> <span class="ent">➋</span> to insert a callback on the instruction’s taken edge <span class="ent">➌</span> (see <a href="ch09.xhtml#ch09fig5">Figure 9-5</a>). The inserted analysis callback to <code>count_cflow</code> increments the control-flow counter (<code>cflow_count</code>) in case the branch is taken and records the source and target addresses of the control transfer. To that end, the analysis routine takes two arguments: the instruction pointer value at the time of the callback (<code>IARG_INST_PTR</code>) <span class="ent">➍</span> and the target address of the branch’s taken edge (<code>IARG_BRANCH_TARGET_ADDR</code>) <span class="ent">➎</span>.</p>&#13;
<p class="indent">Note that <code>IARG_INST_PTR</code> and <code>IARG_BRANCH_TARGET_ADDR</code> are special argument types for which the data type and value are implicit. In contrast, for the <code>IARG_UINT32</code> argument you saw in <a href="ch09.xhtml#ch09list3">Listing 9-3</a>, you have to separately specify the type (<code>IARG_UINT32</code>) and the value (<code>BBL_NumIns</code> in that example).</p>&#13;
<p class="indent">As you saw in <a href="ch09.xhtml#ch09tab2">Table 9-2</a>, the taken edge is a valid instrumentation point only for branch or call instructions (<code>INS_IsBranchOrCall</code> must return <code>true</code>). In this case, the check at the start of <code>instrument_insn</code> guarantees that it’s a branch or call.</p>&#13;
<div class="image"><a id="ch09fig5"/><img src="Images/f245-01.jpg" alt="image" width="415" height="340"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_245"/><em>Figure 9-5: Insertion points on the fallthrough and taken edges of a branch</em></p>&#13;
<p class="indent">Note that <code>instrument_insn</code> uses <code>INS_InsertPredicatedCall</code> to insert the analysis callback instead of <code>INS_InsertCall</code>. Some x86 instructions, such as conditional moves (<code>cmov</code>) and string operations with <code>rep</code> prefixes, have built-in predicates that cause the instruction to repeat if certain conditions hold. Analysis callbacks inserted with <code>INS_InsertPredicatedCall</code> are called only if that condition holds and the instruction is actually executed. In contrast, callbacks inserted with <code>INS_InsertCall</code> are called even if the repeat condition doesn’t hold, leading to an overestimation of the instruction count.</p>&#13;
<h3 class="h3">Instrumenting the Fallthrough Edge</h3>&#13;
<p class="noindent">You’ve just seen how the profiler instruments the taken edge of control-flow instructions. However, the profiler should record control transfers regardless of the branch direction. In other words, it should instrument not only the taken edge but also the fallthrough edge of control-flow instructions that have one (see <a href="ch09.xhtml#ch09fig5">Figure 9-5</a>). Note that some instructions, such as unconditional jumps, have no fallthrough edge, so you have to explicitly check <code>INS_HasFallthrough</code> before you try to instrument an instruction’s fallthrough edge <span class="ent">➏</span>. Also note that by Pin’s definition, non-control-flow instructions that just continue to the next instruction do have a fallthrough edge.</p>&#13;
<p class="indent">If the given instruction turns out to have a fallthrough edge, <code>instrument _insn</code> inserts an analysis callback to <code>count_cflow</code> on that edge just as it did for the taken edge. The only difference is that this new callback uses insertion point <code>IPOINT_AFTER</code> <span class="ent">➐</span> and passes the fallthrough address (<code>IARG _FALLTHROUGH_ADDR</code>) as the target address to record <span class="ent">➑</span>.</p>&#13;
<h3 class="h3">Instrumenting Calls</h3>&#13;
<p class="noindent">Finally, the profiler keeps a separate counter and mapping to track called functions so that you can see which functions are the most rewarding <span epub:type="pagebreak" id="page_246"/>options for optimizing your application. Recall that to track called functions, you have to enable the profiler’s <code>-c</code> option.</p>&#13;
<p class="indent">To instrument calls, <code>instrument_insn</code> first uses <code>INS_IsCall</code> to separate calls from other instructions <span class="ent">➒</span>. If the instruction currently being instrumented is indeed a call and if the <code>-c</code> option was passed to the Pintool, the profiler inserts an analysis callback before the call instruction (at <code>IPOINT _BEFORE</code>) <span class="ent">➓</span> to an analysis routine called <code>count_call</code>, passing in the call’s source (<code>IARG_INST_PTR</code>) and target address (<code>IARG_BRANCH_TARGET_ADDR</code>). Note that in this case, it’s safe to use <code>INS_InsertCall</code> instead of <code>INS_InsertPredicatedCall</code> because there are no call instructions with built-in conditionals.</p>&#13;
<h4 class="h4" id="ch09_4_5"><em>9.4.5 Counting Instructions, Control Transfers, and Syscalls</em></h4>&#13;
<p class="noindent">So far, you’ve seen all the code responsible for initializing the Pintool and inserting the required instrumentation in the form of callbacks to analysis routines. The only code you haven’t seen yet consists of the actual analysis routines that count and record statistics as the application runs. <a href="ch09.xhtml#ch09list5">Listing 9-5</a> shows all the analysis routines that the profiler uses.</p>&#13;
<p class="listing1" id="ch09list5"><em>Listing 9-5:</em> profiler.cpp<em> (continued)</em></p>&#13;
<pre>   static void<br/><span class="ent">➊</span> count_bb_insns(UINT32 n)<br/>   {<br/>     insn_count += n;<br/>   }<br/><br/>   static void<br/><span class="ent">➋</span> count_cflow(<span class="ent">➌</span>ADDRINT ip, ADDRINT target)<br/>   {<br/>     cflows[target][ip]++;<br/>     cflow_count++;<br/>   }<br/><br/>   static void<br/><span class="ent">➍</span> count_call(ADDRINT ip, ADDRINT target)<br/>   {<br/>     calls[target][ip]++;<br/>     call_count++;<br/>   }<br/><br/>   static void<br/><span class="ent">➎</span> log_syscall(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v)<br/>   {<br/>     syscalls[<span class="ent">➏</span>PIN_GetSyscallNumber(ctxt, std)]++;<br/>     syscall_count++;<br/>   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_247"/>As you can see, the analysis routines are simple, implementing only the bare minimum code to track the required statistics. That’s important because analysis routines are called often as the application executes and so have a major impact on the performance of your Pintool.</p>&#13;
<p class="indent">The first analysis routine <code>count_bb_insns</code> <span class="ent">➊</span> is called when a basic block executes and simply increments <code>insn_count</code> by the number of instructions in the basic block. Similarly, <code>count_cflow</code> <span class="ent">➋</span> increments <code>cflow_count</code> when a control flow instruction executes. Additionally, it records the branch’s source and target address in the <code>cflows</code> map and increments the counter for this particular combination of source and target. In Pin, you use the <code>ADDRINT</code> integer type <span class="ent">➌</span> to store addresses. The analysis routine that records call information, <code>count_call</code> <span class="ent">➍</span>, is analogous to <code>count_cflow</code>.</p>&#13;
<p class="indent">The last function in <a href="ch09.xhtml#ch09list5">Listing 9-5</a>, <code>log_syscall</code> <span class="ent">➎</span>, is not a regular analysis routine but a callback for syscall entry events. In Pin, syscall handlers take four arguments: a <code>THREADID</code> identifying the thread that made the syscall; a <code>CONTEXT*</code> containing things like the syscall number, arguments, and return value (only for syscall exit handlers); a <code>SYSCALL_STANDARD</code> argument that identifies the syscall’s calling convention; and finally, the now-familiar <code>void*</code> that lets you pass in a user-defined data structure.</p>&#13;
<p class="indent">Recall that the purpose of <code>log_syscall</code> is to record how often each syscall is called. To that end, it calls <code>PIN_GetSyscallNumber</code> to get the number of the current syscall <span class="ent">➏</span> and records a hit for that syscall in the <code>syscalls</code> map.</p>&#13;
<p class="indent">Now that you’ve seen all of the profiler’s important code, let’s test it!</p>&#13;
<h4 class="h4" id="ch09_4_6"><em>9.4.6 Testing the Profiler</em></h4>&#13;
<p class="noindent">In this test, you’ll see two use cases for the profiler. First you’ll see how to profile an application’s entire execution from the start, and then you’ll learn how to attach the profiler Pintool to a running application.</p>&#13;
<h3 class="h3">Profiling an Application from the Start</h3>&#13;
<p class="noindent"><a href="ch09.xhtml#ch09list6">Listing 9-6</a> shows how to profile an application from the start.</p>&#13;
<p class="listing1" id="ch09list6"><em>Listing 9-6: Profiling</em> /bin/true<em> with the profiler Pintool</em></p>&#13;
<pre><span class="ent">➊</span> $ <span class="codestrong1">cd ~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/</span><br/><span class="ent">➋</span> $ <span class="codestrong1">./pin -t ~/code/chapter9/profiler/obj-intel64/profiler.so -c -s -- /bin/true</span><br/><span class="ent">➌</span> executed 95 instructions<br/><br/><span class="ent">➍</span> ******* CONTROL TRANSFERS *******<br/>   0x00401000 &lt;- 0x00403f7c:   1 (4.35%)<br/>   0x00401015 &lt;- 0x0040100e:   1 (4.35%)<br/>   0x00401020 &lt;- 0x0040118b:   1 (4.35%)<br/>   0x00401180 &lt;- 0x004013f4:   1 (4.35%)<br/>   0x00401186 &lt;- 0x00401180:   1 (4.35%)<br/>   0x00401335 &lt;- 0x00401333:   1 (4.35%)<br/>   0x00401400 &lt;- 0x0040148d:   1 (4.35%)<br/>   0x00401430 &lt;- 0x00401413:   1 (4.35%)<br/><span epub:type="pagebreak" id="page_248"/>   0x00401440 &lt;- 0x004014ab:   1 (4.35%)<br/>   0x00401478 &lt;- 0x00401461:   1 (4.35%)<br/>   0x00401489 &lt;- 0x00401487:   1 (4.35%)<br/>   0x00401492 &lt;- 0x00401431:   1 (4.35%)<br/>   0x004014a0 &lt;- 0x00403f99:   1 (4.35%)<br/>   0x004014ab &lt;- 0x004014a9:   1 (4.35%)<br/>   0x00403f81 &lt;- 0x00401019:   1 (4.35%)<br/>   0x00403f86 &lt;- 0x00403f84:   1 (4.35%)<br/>   0x00403f9d &lt;- 0x00401479:   1 (4.35%)<br/>   0x00403fa6 &lt;- 0x00403fa4:   1 (4.35%)<br/>   0x7fa9f58437bf &lt;- 0x00403fb4:   1 (4.35%)<br/>   0x7fa9f5843830 &lt;- 0x00401337:   1 (4.35%)<br/>   0x7faa09235de7 &lt;- 0x0040149a:   1 (4.35%)<br/>   0x7faa09235e05 &lt;- 0x00404004:   1 (4.35%)<br/>   0x7faa0923c870 &lt;- 0x00401026:   1 (4.35%)<br/><br/><span class="ent">➎</span> ******* FUNCTION CALLS *******<br/>   [_init                         ] 0x00401000 &lt;- 0x00403f7c:   1 (25.00%)<br/>   [__libc_start_main@plt         ] 0x00401180 &lt;- 0x004013f4:   1 (25.00%)<br/>   [                              ] 0x00401400 &lt;- 0x0040148d:   1 (25.00%)<br/>   [                              ] 0x004014a0 &lt;- 0x00403f99:   1 (25.00%)<br/><br/><span class="ent">➏</span> ******* SYSCALLS *******<br/>     0:   1 (4.00%)<br/>     2:   2 (8.00%)<br/>     3:   2 (8.00%)<br/>     5:   2 (8.00%)<br/>     9:   7 (28.00%)<br/>    10:   4 (16.00%)<br/>    11:   1 (4.00%)<br/>    12:   1 (4.00%)<br/>    21:   3 (12.00%)<br/>   158:   1 (4.00%)<br/>   231:   1 (4.00%)</pre>&#13;
<p class="indent">To use Pin, you first navigate to the main Pin directory <span class="ent">➊</span>, where you’ll find an executable called <code>pin</code> that starts the Pin engine. Next, you start your application running under the control of <code>pin</code> with the Pintool of your choice <span class="ent">➋</span>.</p>&#13;
<p class="indent">As you can see, <code>pin</code> uses a special format for the command line parameters. The <code>-t</code> option indicates the path to the Pintool you want to use and is followed by any options you want to pass<em> to the Pintool</em>. In this case, the used options are <code>-c</code> and <code>-s</code> to enable profiling for both calls and syscalls. Next, the <code>--</code> indicates the end of the Pintool’s options, which is followed by the name and options of the application you want to run with Pin (<em>/bin/true</em> in this case, without any command line options).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_249"/>When the application terminates, the Pintool invokes its fini function to print the recorded statistics, and then Pin terminates itself after the fini function completes. The profiler prints statistics on the number of executed instructions <span class="ent">➌</span>, the taken control transfers <span class="ent">➍</span>, the function calls <span class="ent">➎</span>, and the syscalls <span class="ent">➏</span>. Because<em> /bin/true</em> is an extremely simple program,<sup><a id="ch09fn_11a" href="footnote.xhtml#ch09fn_11">11</a></sup> it executes only 95 instructions during its lifetime.</p>&#13;
<p class="indent">The profiler reports control transfers in the format <code>target &lt;- source: count</code>, where the count indicates how often this specific branch edge was taken and for what percentage of all control transfers the branch edge accounts. In this case, all control transfers are taken exactly once: there were apparently no loops or other repetitions of the same code. Aside from <code>_init</code> and <code>__libc_start_main</code>,<em> /bin/true</em> makes only two function calls to internal functions with no known symbolic name. The most used syscall is syscall number 9, which is <code>sys_mmap</code>. This is because of the dynamic loader, which sets up the address space for<em> /bin/true</em>. (In contrast to instructions and control transfers, the profiler does record syscalls that originate in the loader or shared libraries.)</p>&#13;
<p class="indent">Now that you know how to run an application with a Pintool from the start, let’s look at how to attach Pin to an already running process.</p>&#13;
<h3 class="h3">Attaching the Profiler to a Running Application</h3>&#13;
<p class="noindent">To attach Pin to a running process, you use the <code>pin</code> program just like when you instrument an application from the start. However, the <code>pin</code> options are a little different, as you can see in <a href="ch09.xhtml#ch09list7">Listing 9-7</a>.</p>&#13;
<p class="listing1" id="ch09list7"><em>Listing 9-7: Attaching the profiler to a running</em> <span class="codeitalic">netcat</span><em> process</em></p>&#13;
<pre><span class="ent">➊</span> $ <span class="codestrong1">echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br/><span class="ent">➋</span> $ <span class="codestrong1">nc -l -u 127.0.0.1 9999 &amp;</span><br/>   [1] <span class="ent">➌</span>3100<br/><span class="ent">➍</span> $ <span class="codestrong1">cd ~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/</span><br/><span class="ent">➎</span> $ <span class="codestrong1">./pin -pid 3100 -t /home/binary/code/chapter9/profiler/obj-intel64/profiler.so -c -s</span><br/><span class="ent">➏</span> $ <span class="codestrong1">echo "Testing the profiler" | nc -u 127.0.0.1 9999</span><br/>   Testing the profiler<br/>   ˆ<span class="codestrong1">C</span><br/><span class="ent">➐</span> $ <span class="codestrong1">fg</span><br/>   nc -l -u 127.0.0.1 9999<br/>   ˆ<span class="codestrong1">C</span><br/>   executed 164 instructions<br/><br/><span class="ent">➑</span> ******* CONTROL TRANSFERS *******<br/>   0x00401380 &lt;- 0x0040140b:   1 (2.04%)<br/>   0x00401380 &lt;- 0x0040144b:   1 (2.04%)<br/>   0x00401380 &lt;- 0x004014db:   1 (2.04%)<br/>   ...<br/>   0x7f4741177ad0 &lt;- 0x004015e0:   1 (2.04%)<br/><span epub:type="pagebreak" id="page_250"/><br/>   0x7f474121b0b0 &lt;- 0x004014d0:   1 (2.04%)<br/>   0x7f4741913870 &lt;- 0x00401386:   5 (10.20%)<br/><br/><span class="ent">➒</span> ******* FUNCTION CALLS *******<br/>   [__read_chk@plt                ] 0x00401400 &lt;- 0x00402dc7:   1 (11.11%)<br/>   [write@plt                     ] 0x00401440 &lt;- 0x00403c06:   1 (11.11%)<br/>   [__poll_chk@plt                ] 0x004014d0 &lt;- 0x00402eba:   2 (22.22%)<br/>   [fileno@plt                    ] 0x004015e0 &lt;- 0x00402d62:   1 (11.11%)<br/>   [fileno@plt                    ] 0x004015e0 &lt;- 0x00402d71:   1 (11.11%)<br/>   [connect@plt                   ] 0x004016a0 &lt;- 0x00401e80:   1 (11.11%)<br/>   [                              ] 0x00402d30 &lt;- 0x00401e90:   1 (11.11%)<br/>   [                              ] 0x00403bb0 &lt;- 0x00402dfc:   1 (11.11%)<br/><br/><span class="ent">➓</span> ******* SYSCALLS *******<br/>     0:   1 (16.67%)<br/>     1:   1 (16.67%)<br/>     7:   2 (33.33%)<br/>    42:   1 (16.67%)<br/>    45:   1 (16.67%)</pre>&#13;
<p class="indent">On some Linux platforms, including the Ubuntu distribution on the virtual machine, there’s a security mechanism in place that prevents Pin from attaching to running processes. To allow Pin to attach normally, you have to temporarily disable that security mechanism, as shown in <a href="ch09.xhtml#ch09list7">Listing 9-7</a> <span class="ent">➊</span> (it will automatically be re-enabled on the next reboot). Additionally, you’ll need a suitable test process to attach Pin to. <a href="ch09.xhtml#ch09list7">Listing 9-7</a> starts a background <code>netcat</code> process for this purpose that listens on UDP port 9999 on the local-host <span class="ent">➋</span>. To attach to a process, you need to know its PID, which you can write down when you start the process <span class="ent">➌</span> or find with <code>ps</code>.</p>&#13;
<p class="indent">With these preliminaries out of the way, you can now navigate to the Pin folder <span class="ent">➍</span> and start <code>pin</code> <span class="ent">➎</span>. The <code>-pid</code> option tells Pin to attach to the running process with the given PID (3100 for the example <code>netcat</code> process), and the <code>-t</code> option tells Pin the path to your Pintool as usual.</p>&#13;
<p class="indent">To coax the listening <code>netcat</code> process into executing some instructions rather than blocking waiting for network input, <a href="ch09.xhtml#ch09list7">Listing 9-7</a> uses another <code>netcat</code> instance to send it the message “Testing the profiler” <span class="ent">➏</span>. Then, it brings the listening <code>netcat</code> process to the foreground <span class="ent">➐</span> and terminates it. When the application terminates, the profiler calls its fini function and prints statistics for you to inspect, including a list of control transfers <span class="ent">➑</span>, called functions <span class="ent">➒</span> and syscalls <span class="ent">➓</span>. You can see network-related function calls like <code>connect</code>, as well as a <code>sys_recvfrom</code> system call (number 45) that <code>netcat</code> used to receive the test message.</p>&#13;
<p class="indent">Note that once you attach Pin to a running process, it will stay attached until that process terminates or you call <code>PIN_Detach</code> from somewhere inside your Pintool. This means if you want to instrument a system process that <span epub:type="pagebreak" id="page_251"/>never terminates, you have to incorporate some suitable termination criterion into your Pintool.</p>&#13;
<p class="indent">Now let’s look at a slightly more complex Pintool: an automatic unpacker that can extract obfuscated binaries!</p>&#13;
<h3 class="h3" id="ch09_5">9.5 Automatic Binary Unpacking with Pin</h3>&#13;
<p class="noindent">In this example, you’ll see how to use Pin to build a Pintool that can automatically unpack packed binaries. But first, let’s briefly discuss what packed binaries are so that you can better understand the example that follows.</p>&#13;
<h4 class="h4" id="ch09_5_1"><em>9.5.1 Introduction to Executable Packers</em></h4>&#13;
<p class="noindent"><em>Executable packers</em>, or<em> packers</em> for short, are programs that take a binary as input and “pack” that binary’s code and data sections together into a compressed or encrypted data region, producing a new<em> packed executable</em>. Originally, packers were used mainly for compressing binaries, but nowadays they’re often used by malware to produce binaries that are more difficult for reverse engineers to analyze statically. <a href="ch09.xhtml#ch09fig6">Figure 9-6</a> illustrates the packing process and the loading process of a packed binary.</p>&#13;
<div class="image"><a id="ch09fig6"/><img src="Images/f251-01.jpg" alt="image" width="673" height="402"/></div>&#13;
<p class="fig-caption"><em>Figure 9-6: Creating and running a packed binary</em></p>&#13;
<p class="indent">The left part of <a href="ch09.xhtml#ch09fig6">Figure 9-6</a> shows a normal binary containing an executable header and a code and data section <span class="ent">➊</span>. The entry point field in the executable header points into the code section.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_252"/>Creating and Executing Packed Binaries</h3>&#13;
<p class="noindent">When you process the binary with a packer, it produces a new binary in which all the original code and data are compressed or encrypted into a packed region <span class="ent">➋</span> (see <a href="ch09.xhtml#ch09fig6">Figure 9-6</a>). Additionally, the packer inserts a new code section that contains bootstrap code and redirects the binary’s entry point to the bootstrap code. When you try to statically disassemble and analyze the packed program, you see only the packed region and the bootstrap code, which don’t give you any idea of what the binary actually does at runtime.</p>&#13;
<p class="indent">When you load and execute the packed binary, the bootstrap code extracts the original code and data into memory and then transfers control to the<em> original entry point (OEP)</em> of the binary, resuming execution normally <span class="ent">➌</span>.<sup><a id="ch09fn_12a" href="footnote.xhtml#ch09fn_12">12</a></sup> The point of the automatic unpacking Pintool you’ll see shortly is to detect the moment that the bootstrap code transfers control to the OEP and then to dump the unpacked code and data to disk so that you can statically disassemble and reverse engineer it as you would a normal binary.</p>&#13;
<h3 class="h3">Unpacking Packed Binaries</h3>&#13;
<p class="noindent">There are many different packers that pack binaries in their own way. For well-known packers, such as UPX<sup><a id="ch09fn_13a" href="footnote.xhtml#ch09fn_13">13</a></sup> and AsPack,<sup><a id="ch09fn_14a" href="footnote.xhtml#ch09fn_14">14</a></sup> there are specialized unpacking tools that can automatically extract an approximation of the original binary from a packed binary. However, that’s not always possible for packers used in malware, which malware authors often customize or design from scratch. To unpack such malware, you have to build your own unpacking tool, unpack the malware manually (for instance, by using a debugger to locate the jump to OEP and then dumping the code to disk), or use a generic unpacker, as you’ll see next.</p>&#13;
<p class="indent">Generic unpackers rely on common (but not foolproof) runtime patterns indicative of packers to try to detect the jump to the original entry point and then dump the memory region that contains the OEP (and ideally the rest of the code) to disk. The automatic unpacker you’ll see in a moment is a simple generic unpacker. It assumes that when you run a packed binary, the bootstrap code unpacks the original code completely, writes it into memory, and later transfers control to the OEP in the previously written code. When the unpacker detects that control transfer, it dumps the targeted memory region to disk.</p>&#13;
<p class="indent">Now that you know how packers work and have a high-level intuition of the automatic unpacker’s behavior, let’s implement the automatic unpacker with Pin. After that, you’ll learn how to use it to unpack a UPX-packed binary.</p>&#13;
<h4 class="h4" id="ch09_5_2"><span epub:type="pagebreak" id="page_253"/><em>9.5.2 The Unpacker’s Data Structures and Setup Code</em></h4>&#13;
<p class="noindent">Let’s begin by taking a look at the unpacker’s setup code and the data structures it revolves around. <a href="ch09.xhtml#ch09list8">Listing 9-8</a> shows the first part of the unpacker’s code, omitting standard C++ includes.</p>&#13;
<p class="listing1" id="ch09list8"><em>Listing 9-8:</em> unpacker.cpp</p>&#13;
<pre>   #include "pin.H"<br/><br/><span class="ent">➊</span> typedef struct mem_access {<br/>     mem_access()                                  : w(false), x(false), val(0) {}<br/>     mem_access(bool ww, bool xx, unsigned char v) : w(ww)   , x(xx)   , val(v) {}<br/>     bool w;<br/>     bool x;<br/>     unsigned char val;<br/>   } mem_access_t;<br/><br/><span class="ent">➋</span> typedef struct mem_cluster {<br/>     mem_cluster() : base(0), size(0), w(false), x(false) {}<br/>     mem_cluster(ADDRINT b, unsigned long s, bool ww, bool xx)<br/>                   : base(b), size(s), w(ww), x(xx)       {}<br/>     ADDRINT       base;<br/>     unsigned long size;<br/>     bool          w;<br/>     bool          x;<br/>   } mem_cluster_t;<br/><br/><span class="ent">➌</span> FILE *logfile;<br/>   std::map&lt;ADDRINT, mem_access_t&gt; shadow_mem;<br/>   std::vector&lt;mem_cluster_t&gt; clusters;<br/>   ADDRINT saved_addr;<br/><br/><span class="ent">➍</span> KNOB&lt;string&gt; KnobLogFile(KNOB_MODE_WRITEONCE, "pintool", "l", "unpacker.log", "log file");<br/><br/>   static void<br/><span class="ent">➎</span> fini(INT32 code, void *v)<br/>   {<br/>     print_clusters();<br/>     fprintf(logfile, "------- unpacking complete -------\n");<br/>     fclose(logfile);<br/>   }<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/><span class="ent">➏</span>   if(PIN_Init(argc, argv) != 0) {<br/>       fprintf(stderr, "PIN_Init failed\n");<br/>       return 1;<br/>     }<br/><br/><span epub:type="pagebreak" id="page_254"/><span class="ent">➐</span>   logfile = fopen(KnobLogFile.Value().c_str(), "a");<br/>     if(!logfile) {<br/>       fprintf(stderr, "failed to open '%s'\n", KnobLogFile.Value().c_str());<br/>       return 1;<br/>     }<br/>     fprintf(logfile, "------- unpacking binary -------\n");<br/><br/><span class="ent">➑</span>   INS_AddInstrumentFunction(instrument_mem_cflow, NULL);<br/><span class="ent">➒</span>   PIN_AddFiniFunction(fini, NULL);<br/><br/><span class="ent">➓</span>   PIN_StartProgram();<br/><br/>     return 1;<br/>   }</pre>&#13;
<p class="indent">The unpacker tracks memory activity by logging written or executed memory bytes in a <code>struct</code> type called <code>mem_access_t</code> <span class="ent">➊</span>, which records the type of memory access (write or execute) and the value of written bytes. Later in the unpacking process, when dumping memory to disk, the unpacker needs to cluster adjacent memory bytes. It uses a second <code>struct</code> type called <code>mem_cluster_t</code> <span class="ent">➋</span> to cluster those bytes, recording the base address, size, and access permissions of the memory cluster.</p>&#13;
<p class="indent">There are four global variables <span class="ent">➌</span>. First, there’s a log file where the unpacker logs details on the unpacking progress and the written memory regions. Then there’s a global <code>std::map</code> called <code>shadow_mem</code>, which is a “shadow memory” that maps memory addresses to <code>mem_access_t</code> objects that detail the accesses and writes to each address. The <code>std::vector</code> called <code>clusters</code> is where the unpacker stores all the unpacked memory clusters it’s found, and <code>saved_addr</code> is a temporary variable that’s needed for storing state between two analysis routines.</p>&#13;
<p class="indent">Note that <code>clusters</code> can contain multiple unpacked memory regions because some binaries may have multiple layers of packing. In other words, you can pack an already packed binary again with another packer. When the unpacker detects a control transfer to a previously written memory region, it has no way of knowing whether that’s the jump to the OEP or simply a jump to the bootstrap code of the next packer. Therefore, the unpacker dumps all of the candidate regions it finds to disk, leaving you to figure out which dumped file is the final unpacked binary.</p>&#13;
<p class="indent">The unpacker has only one command line option <span class="ent">➍</span>: a <code>string</code> knob where you can specify the name of the log file. By default, the log file is named<em> unpacker.log</em> .</p>&#13;
<p class="indent">As you’ll see shortly, the unpacker registers one fini function called <code>fini</code> <span class="ent">➎</span>, which calls <code>print_clusters</code> to print a summary of all the memory clusters the unpacker found to the log file. I won’t show the listing of that function here because it doesn’t use any Pin functionality, but you’ll see its output when we test the unpacker.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>The unpacker’s <code>main</code> function is similar to the profiler’s you saw previously. It initializes Pin <span class="ent">➏</span>, skipping symbol initialization since the unpacker doesn’t use symbols. Next, it opens the log file <span class="ent">➐</span>, registers an instruction-level instrumentation routine called <code>instrument_mem_cflow</code> <span class="ent">➑</span> and the fini function <span class="ent">➒</span>, and finally starts the packed application running <span class="ent">➓</span>.</p>&#13;
<p class="indent">Now, let’s look at the instrumentation that <code>instrument_mem_cflow</code> adds to the packed program to track its memory access and control flow activity.</p>&#13;
<h4 class="h4" id="ch09_5_3"><em>9.5.3 Instrumenting Memory Writes</em></h4>&#13;
<p class="noindent"><a href="ch09.xhtml#ch09list9">Listing 9-9</a> shows how <code>instrument_mem_cflow</code> instruments memory writes and control-flow instructions.</p>&#13;
<p class="listing1" id="ch09list9"><em>Listing 9-9:</em> unpacker.cpp<em> (continued)</em></p>&#13;
<pre>   static void<br/>   instrument_mem_cflow(INS ins, void *v)<br/>   {<br/><span class="ent">➊</span>   if(INS_IsMemoryWrite(ins) &amp;&amp; INS_hasKnownMemorySize(ins)) {<br/><span class="ent">➋</span>     INS_InsertPredicatedCall(<br/>         ins, IPOINT_BEFORE, (AFUNPTR)queue_memwrite,<br/><span class="ent">➌</span>       IARG_MEMORYWRITE_EA,<br/>         IARG_END<br/>       );<br/><span class="ent">➍</span>     if(INS_HasFallThrough(ins)) {<br/><span class="ent">➎</span>       INS_InsertPredicatedCall(<br/>           ins, IPOINT_AFTER, (AFUNPTR)log_memwrite,<br/><span class="ent">➏</span>         IARG_MEMORYWRITE_SIZE,<br/>           IARG_END<br/>         );<br/>       }<br/><span class="ent">➐</span>     if(INS_IsBranchOrCall(ins)) {<br/><span class="ent">➑</span>       INS_InsertPredicatedCall(<br/>           ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)log_memwrite,<br/>           IARG_MEMORYWRITE_SIZE,<br/>           IARG_END<br/>         );<br/>       }<br/>     }<br/><br/><span class="ent">➒</span>   if(INS_IsIndirectBranchOrCall(ins) &amp;&amp; INS_OperandCount(ins) &gt; 0) {<br/><span class="ent">➓</span>     INS_InsertCall(<br/>         ins, IPOINT_BEFORE, (AFUNPTR)check_indirect_ctransfer,<br/>         IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR,<br/>         IARG_END<br/>      );<br/>    }<br/>  }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>The first three analysis callbacks that <code>instrument_mem_cflow</code> inserts (at <span class="ent">➊</span> through <span class="ent">➑</span>) are for tracking memory writes. It adds these callbacks only for instructions for which <code>INS_IsMemoryWrite</code> and <code>INS_hasKnownMemorySize</code> are both true <span class="ent">➊</span>. The first of these, <code>INS_IsMemoryWrite</code>, tells you whether an instruction writes to memory, while <code>INS_hasKnownMemorySize</code> tells you whether the size (in bytes) of the write is known. That’s important because the unpacker records written bytes in <code>shadow_mem</code>, and it can copy the right number of bytes only if the write size is known. Because memory writes with an unknown size occur only for special-purpose instructions, such as MMX and SSE instructions, the unpacker simply ignores them.</p>&#13;
<p class="indent">For every memory write, the unpacker needs to know the written address and the write size so that it can record all the written bytes. Unfortunately, in Pin the write address is known only<em> before</em> the memory write happens (at <code>IPOINT_BEFORE</code>), but you can’t copy the written bytes until after the write is done. That’s why <code>instrument_mem_cflow</code> inserts multiple analysis routines for every write.</p>&#13;
<p class="indent">First, it adds an analysis callback to <code>queue_memwrite</code> before every memory write <span class="ent">➋</span>, which saves the write’s effective address (<code>IARG_MEMORYWRITE_EA</code> <span class="ent">➌</span>) into the global <code>saved_addr</code> variable. Then, for memory write instructions that have a fallthrough edge <span class="ent">➍</span>, <code>instrument_mem_cflow</code> instruments that fallthrough edge with a callback to <code>log_memwrite</code> <span class="ent">➎</span>, which records all the written bytes in <code>shadow_mem</code>. The <code>IARG_MEMORYWRITE_SIZE</code> parameter <span class="ent">➏</span> tells <code>log_memwrite</code> how many bytes to record, starting from the <code>saved_addr</code> that <code>queue_memwrite</code> saved before the write. Similarly, for writes that happen as part of a branch or call <span class="ent">➐</span>, the unpacker adds an analysis callback to <code>log_memwrite</code> on the taken edge <span class="ent">➑</span>, ensuring that the write will be recorded regardless of which branch direction the application takes at runtime.</p>&#13;
<h4 class="h4" id="ch09_5_4"><em>9.5.4 Instrumenting Control-Flow Instructions</em></h4>&#13;
<p class="noindent">Recall that the unpacker’s goal is to detect the control transfer to the original entry point and then dump the unpacked binary to disk. To that end, <code>instrument_mem_cflow</code> instruments indirect branches and calls <span class="ent">➒</span> with a call-back to <code>check_indirect_ctransfer</code> <span class="ent">➓</span>, an analysis routine that checks whether the branch targets a previously writable memory region and, if so, marks it as a possible jump to OEP and dumps the targeted memory region to disk.</p>&#13;
<p class="indent">Note that for optimization, <code>instrument_mem_cflow</code> instruments only indirect control transfers because many packers use indirect branches or calls to jump to the unpacked code. This may not be true for all packers, and you can easily change <code>instrument_mem_cflow</code> to instrument all control transfers instead of only indirect ones, but this will be at the cost of a significant performance hit.</p>&#13;
<h4 class="h4" id="ch09_5_5"><em>9.5.5 Tracking Memory Writes</em></h4>&#13;
<p class="noindent"><a href="ch09.xhtml#ch09list10">Listing 9-10</a> shows the analysis routines responsible for recording memory writes, which you’ve already seen in the previous sections.</p>&#13;
<p class="listing1" id="ch09list10"><span epub:type="pagebreak" id="page_257"/><em>Listing 9-10:</em> unpacker.cpp<em> (continued)</em></p>&#13;
<pre>   static void<br/><span class="ent">➊</span> queue_memwrite(ADDRINT addr)<br/>   {<br/>     saved_addr = addr;<br/>   }<br/><br/>   static void<br/><span class="ent">➋</span> log_memwrite(UINT32 size)<br/>   {<br/><span class="ent">➌</span>   ADDRINT addr = saved_addr;<br/><span class="ent">➍</span>   for(ADDRINT i = addr; i &lt; addr+size; i++) {<br/><span class="ent">➎</span>     shadow_mem[i].w = true;<br/><span class="ent">➏</span>     PIN_SafeCopy(&amp;shadow_mem[i].val, (const void*)i, 1);<br/>     }<br/>   }</pre>&#13;
<p class="indent">The first of the analysis routines, <code>queue_memwrite</code> <span class="ent">➊</span>, is called before every memory write and stores the write’s address in the global variable <code>saved_addr</code>. Recall that this is necessary because Pin allows you to inspect the write’s address only at <code>IPOINT_BEFORE</code>.</p>&#13;
<p class="indent">After every memory write (on the fallthrough or taken edge), there’s a callback to <code>log_memwrite</code> <span class="ent">➋</span>, which records all the written bytes in <code>shadow_mem</code>. It first retrieves the write’s base address by reading <code>saved_addr</code> <span class="ent">➌</span> and then loops over all the written addresses <span class="ent">➍</span>. It marks each address as written in <code>shadow_mem</code> <span class="ent">➎</span> and calls <code>PIN_SafeCopy</code> to copy the value of the written byte from application memory into <code>shadow_mem</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Note that the unpacker must copy all written bytes into its own memory because when it later dumps unpacked memory to disk, the application may have already deallocated part of that memory region. When copying bytes from application memory, you should always use <code>PIN_SafeCopy</code> because Pin may modify some memory contents. If you read from application memory directly, you’d see the contents written by Pin, which is usually not what you want. In contrast, <code>PIN_SafeCopy</code> will always show you the memory state as written by the original application and will also safely handle cases where memory regions are inaccessible without causing a segmentation fault.</p>&#13;
<p class="indent">You may notice that the unpacker ignores the return value of <code>PIN _SafeCopy</code>, which indicates the number of bytes it successfully read. For the unpacker, there’s nothing it can do if a read from application memory fails; the unpacked code will simply be corrupted. In other Pintools, you’ll want to check the return value and handle errors gracefully.</p>&#13;
<h4 class="h4" id="ch09_5_6"><span epub:type="pagebreak" id="page_258"/><em>9.5.6 Detecting the Original Entry Point and Dumping the Unpacked Binary</em></h4>&#13;
<p class="noindent">The ultimate goal of the unpacker is to detect the jump to the OEP and dump the unpacked code. <a href="ch09.xhtml#ch09list11">Listing 9-11</a> shows the analysis routine that implements this.</p>&#13;
<p class="listing1" id="ch09list11"><em>Listing 9-11:</em> unpacker.cpp<em> (continued)</em></p>&#13;
<pre>   static void<br/>   check_indirect_ctransfer(ADDRINT ip, ADDRINT target)<br/>   {<br/><span class="ent">➊</span>   mem_cluster_t c;<br/><br/><span class="ent">➋</span>   shadow_mem[target].x = true;<br/><span class="ent">➌</span>   if(shadow_mem[target].w &amp;&amp; <span class="ent">➍</span>!in_cluster(target)) {<br/>       /* control transfer to a once-writable memory region, suspected transfer<br/>        * to original entry point of an unpacked binary */<br/><span class="ent">➎</span>     set_cluster(target, &amp;c);<br/><span class="ent">➏</span>     clusters.push_back(c);<br/>       /* dump the new cluster containing the unpacked region to file */<br/><span class="ent">➐</span>     mem_to_file(&amp;c, target);<br/>       /* we don't stop here because there might be multiple unpacking stages */<br/>     }<br/>   }</pre>&#13;
<p class="indent">When <code>check_indirect_ctransfer</code> detects a suspected jump to OEP, it builds a memory cluster <span class="ent">➊</span> of all the consecutive bytes surrounding the OEP and dumps that to disk. Because <code>check_indirect_ctransfer</code> is called only on control-flow instructions, it always marks the target address as executable <span class="ent">➋</span>. If the target address lies within a once-written memory region <span class="ent">➌</span>, then this may be a jump to OEP, and the unpacker proceeds to dump the targeted memory region if it hasn’t already done so. To check whether the region has been dumped before, the unpacker calls <code>in_cluster</code> <span class="ent">➍</span>, which checks whether there’s already a memory cluster containing the target address. I won’t discuss <code>in_cluster</code>’s code here since it doesn’t use any Pin functionality.</p>&#13;
<div class="image"><a id="ch09fig7"/><img src="Images/f258-01.jpg" alt="image" width="696" height="157"/></div>&#13;
<p class="fig-caption"><em>Figure 9-7: Building a memory cluster after a control transfer to a candidate OEP</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>If the targeted region isn’t unpacked yet, <code>check_indirect_ctransfer</code> calls <code>set_cluster</code> <span class="ent">➎</span> to cluster the memory around the suspected OEP into a contiguous chunk it can dump to disk and stores that chunk into <code>clusters</code> <span class="ent">➏</span>, the global list of all unpacked regions. I won’t go over <code>set_cluster</code>’s code here, but <a href="ch09.xhtml#ch09fig7">Figure 9-7</a> illustrates how it simply searches backward and forward in <code>shadow_mem</code> starting from the suspected OEP, expanding the cluster across all neighboring bytes that have been written, until it hits a “gap” of unwritten memory locations.</p>&#13;
<p class="indent">Next, <code>check_indirect_ctransfer</code> unpacks the just-built memory cluster by dumping it to disk <span class="ent">➐</span>. Rather than assuming that the unpacking was successful and exiting the application, the unpacker continues just as it did before because there might be another layer of packing to discover and unpack.</p>&#13;
<h4 class="h4" id="ch09_5_7"><em>9.5.7 Testing the Unpacker</em></h4>&#13;
<p class="noindent">Now let’s test the automatic unpacker by using it to unpack an executable packed with UPX, a well-known packer that you can install on Ubuntu with <code>apt install upx</code>. <a href="ch09.xhtml#ch09list12">Listing 9-12</a> shows how to pack a test binary with UPX (the <em>Makefile</em> for this chapter does this automatically).</p>&#13;
<p class="listing1" id="ch09list12"><em>Listing 9-12: Packing</em> /bin/ls<em> with UPX</em></p>&#13;
<pre><span class="ent">➊</span> $ <span class="codestrong1">cp /bin/ls packed</span><br/><span class="ent">➋</span> $ <span class="codestrong1">upx packed</span><br/>                           Ultimate Packer for eXecutables<br/>                              Copyright (C) 1996 - 2013<br/>   UPX 3.91         Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep 30th 2013<br/><br/>           File size         Ratio      Format      Name<br/>      --------------------   ------   -----------   -----------<br/><span class="ent">➌</span>     126584 -&gt;     57188   45.18%  linux/ElfAMD   packed<br/><br/>   Packed 1 file.</pre>&#13;
<p class="indent">For this example, let’s copy<em> /bin/ls</em> to a file called<em> packed</em> <span class="ent">➊</span> and then pack it with UPX <span class="ent">➋</span>. UPX reports that it successfully packed the binary and compressed it to 45.18 percent of its original size <span class="ent">➌</span>. You can confirm that a binary is packed by viewing it in IDA Pro, as shown in <a href="ch09.xhtml#ch09fig8">Figure 9-8</a>. As you can see, the packed binary contains a much smaller number of functions than most binaries; IDA finds only four functions because all others are packed. You can also use IDA to see that there’s a large region of data containing the packed code and data (not shown in the figure).</p>&#13;
<div class="image"><a id="ch09fig8"/><img src="Images/f260-01.jpg" alt="image" width="638" height="485"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_260"/><em>Figure 9-8: The packed binary as shown in IDA Pro</em></p>&#13;
<p class="indent">Now let’s test the unpacker’s ability to recover<em> ls</em>’s original code and data from the packed binary. <a href="ch09.xhtml#ch09list13">Listing 9-13</a> shows how to use the unpacker.</p>&#13;
<p class="listing1" id="ch09list13"><em>Listing 9-13: Testing the binary unpacker</em></p>&#13;
<pre>   $ <span class="codestrong1">cd ~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/</span><br/><span class="ent">➊</span> $ <span class="codestrong1">./pin -t ~/code/chapter9/unpacker/obj-intel64/unpacker.so -- ~/code/chapter9/packed</span><br/><span class="ent">➋</span> doc  extlicense  extras  ia32  intel64  LICENSE  pin  pin.log  README  redist.txt  source<br/>   unpacked.0x400000-0x41da64_entry-0x40000c  unpacked.0x800000-0x80d6d0_entry-0x80d465<br/>   unpacked.0x800000-0x80dd42_entry-0x80d6d0  unpacker.log<br/><span class="ent">➌</span> $ <span class="codestrong1">head unpacker.log</span><br/>   ------- unpacking binary -------<br/>   extracting unpacked region 0x0000000000800000 (   53.7kB) wx entry 0x000000000080d465<br/>   extracting unpacked region 0x0000000000800000 (   55.3kB) wx entry 0x000000000080d6d0<br/><span class="ent">➍</span> extracting unpacked region 0x0000000000400000 (  118.6kB) wx entry 0x000000000040000c<br/>   ******* Memory access clusters *******<br/>   0x0000000000400000 (  118.6kB) wx: =======================================================...==<br/>   0x0000000000800000 (   55.3kB) wx: =====================================<br/>   0x000000000061de00 (    4.5kB) w-: ===<br/>   0x00007ffc89084f60 (    3.8kB) w-: ==<br/>   0x00007efc65ac12a0 (    3.3kB) w-: ==<br/><span class="ent">➎</span> $ <span class="codestrong1">file unpacked.0x400000-0x41da64_entry-0x40000c</span><br/>   unpacked.0x400000-0x41da64_entry-0x40000c: ERROR: ELF 64-bit LSB executable, x86-64,<br/>   version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2<br/>   error reading (Invalid argument)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_261"/>To use the unpacker, you call <code>pin</code> with the unpacker as the Pintool and the packed binary (<em>packed</em>) as the application <span class="ent">➊</span>. The application now runs with the unpacker’s instrumentation and, because it’s a copy of<em> /bin/ls</em>, prints a directory listing <span class="ent">➋</span>. You can see that the directory listing contains several unpacked files, each of which uses a naming scheme that indicates the dumped region’s start and end address and the entry point address detected by the instrumentation code.</p>&#13;
<p class="indent">The log file<em> unpacker.log</em> details the extracted regions and lists all the memory clusters (even the ones that weren’t unpacked) that the unpacker found <span class="ent">➌</span>. Let’s take a more detailed look at the largest unpacked file <span class="ent">➍</span>, named<em> unpacked.0x400000-0x41da64_entry-0x40000c</em>.<sup><a id="ch09fn_15a" href="footnote.xhtml#ch09fn_15">15</a></sup> Using <code>file</code>, you can tell it’s an ELF binary <span class="ent">➎</span>, although a somewhat “damaged” one in the sense that ELF binaries’ memory representation doesn’t correspond directly to the on-disk representation that utilities like <code>file</code> expect. For example, the section header table isn’t available at runtime, so there’s no way for the unpacker to recover it. Nevertheless, let’s see if IDA Pro and other utilities can parse the unpacked file.</p>&#13;
<p class="indent">As shown in <a href="ch09.xhtml#ch09fig9">Figure 9-9</a>, IDA Pro manages to find a lot more functions in the unpacked binary than it did in the packed one, which is promising.</p>&#13;
<div class="image"><a id="ch09fig9"/><img src="Images/f261-01.jpg" alt="image" width="607" height="504"/></div>&#13;
<p class="fig-caption"><em>Figure 9-9: The unpacked binary as shown in IDA Pro</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_262"/>Moreover, you can use <code>strings</code> to see that the unpacked binary contains many human-readable strings that suggest a successful unpack, as shown in <a href="ch09.xhtml#ch09list14">Listing 9-14</a>.</p>&#13;
<p class="listing1" id="ch09list14"><em>Listing 9-14: Strings found in the unpacked binary</em></p>&#13;
<pre><span class="ent">➊</span>  $ <span class="codestrong1">strings unpacked.0x400000-0x41da64_entry-0x40000c</span><br/>    ...<br/><span class="ent">➋</span>  Usage: %s [OPTION]... [FILE]...<br/>    List information about the FILEs (the current directory by default).<br/>    Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.<br/>    Mandatory arguments to long options are mandatory for short options too.<br/>      -a, --all                 do not ignore entries starting with .<br/>      -A, --almost-all          do not list implied . and ..<br/>          --author              with -l, print the author of each file<br/>      -b, --escape              print C-style escapes for nongraphic characters<br/>          --block-size=SIZE     scale sizes by SIZE before printing them; e.g.,<br/>                                  '--block-size=M' prints sizes in units of<br/>                                  1,048,576 bytes; see SIZE format below<br/>      -B, --ignore-backups      do not list implied entries ending with ~<br/>      -c                        with -lt: sort by, and show, ctime (time of last<br/>                                  modification of file status information);<br/>                                  with -l: show ctime and sort by name;<br/>                                  otherwise: sort by ctime, newest first<br/>      -C                        list entries by columns<br/>          --color[=WHEN]        colorize the output; WHEN can be 'always' (default<br/>                                  if omitted), 'auto', or 'never'; more info below<br/>      -d, --directory           list directories themselves, not their contents<br/>     ...</pre>&#13;
<p class="indent">Recall from <a href="ch05.xhtml#ch05">Chapter 5</a> that <code>strings</code> <span class="ent">➊</span> is a Linux utility that shows you human-readable strings that it finds in any file. For the unpacked binary, <code>strings</code> shows the usage instructions for<em> /bin/ls</em> <span class="ent">➋</span> (among many other strings).</p>&#13;
<p class="indent">As a final sanity check, let’s use <code>objdump</code> to compare the unpacked code to<em> ls</em>’s original code. <a href="ch09.xhtml#ch09list15">Listing 9-15</a> shows part of the original <code>main</code> function in <em>/bin/ls</em>, and <a href="ch09.xhtml#ch09list16">Listing 9-16</a> shows the corresponding unpacked code.</p>&#13;
<p class="indent">To disassemble the original binary, you can use <code>objdump</code> normally <span class="ent">➊</span>, but for the unpacked binary you need to pass some special options <span class="ent">➋</span> telling <code>objdump</code> to treat the file as a raw binary containing x86-64 code and to disassemble all of the file’s contents (<code>-D</code> instead of the usual <code>-d</code>). That’s necessary because the unpacked binary doesn’t contain a section header table that <code>objdump</code> can use to figure out where the code sections are.</p>&#13;
<p class="listing1" id="ch09list15"><span epub:type="pagebreak" id="page_263"/><em>Listing 9-15: Partial disassembly of</em> <span class="codeitalic">main</span><em> in the original</em> /bin/ls</p>&#13;
<pre><span class="ent">➊</span>  $ <span class="codestrong1">objdump -M intel -d /bin/ls</span><br/><br/>   402a00: push   r15<br/>   402a02: push   r14<br/>   402a04: push   r13<br/>   402a06: push   r12<br/>   402a08: push   rbp<br/>   402a09: push   rbx<br/>   402a0a: mov    ebx,edi<br/>   402a0c: mov    rbp,rsi<br/>   402a0f: sub    rsp,0x388<br/>   402a16: mov    rdi,QWORD PTR [rsi]<br/>   402a19: mov    rax,QWORD PTR fs:0x28<br/>   402a22: mov    QWORD PTR [rsp+0x378],rax<br/>   402a2a: xor    eax,eax<br/>   402a2c: call   40db00 &lt;__sprintf_...&gt;<br/>   402a31: mov    esi,0x419ac1<br/>   402a36: mov    edi,0x6<br/>   402a3b: call   402840 &lt;setlocale@plt&gt;</pre>&#13;
<p class="listing1" id="ch09list16"><em>Listing 9-16: Partial disassembly of</em> <span class="codeitalic">main</span><em> in the unpacked binary</em></p>&#13;
<pre><span class="ent">➋</span>  $ <span class="codestrong1">objdump -M intel -b binary -mi386 -Mx86-64 \</span><br/>     <span class="codestrong1">-D unpacked.0x400000-0x41da64_entry-0x40000c</span><br/>   2a00: push  r15<br/>   2a02: push  r14<br/>   2a04: push  r13<br/>   2a06: push  r12<br/>   2a08: push  rbp<br/>   2a09: push  rbx<br/>   2a0a: mov   ebx,edi<br/>   2a0c: mov   rbp,rsi<br/>   2a0f: sub   rsp,0x388<br/>   2a16: mov   rdi,QWORD PTR [rsi]<br/>   2a19: mov   rax,QWORD PTR fs:0x28<br/>   2a22: mov   QWORD PTR [rsp+0x378],rax<br/>   2a2a: xor   eax,eax<br/><span class="ent">➌</span>  2a2c: call  0xdb00<br/>   2a31: mov   esi,0x419ac1<br/>   2a36: mov   edi,0x6<br/><span class="ent">➍</span>  2a3b: call  0x2840</pre>&#13;
<p class="indent">Comparing <a href="ch09.xhtml#ch09list15">Listings 9-15</a> and <a href="ch09.xhtml#ch09list16">9-16</a> side by side, you can see that the code is identical, except for code addresses at <span class="ent">➌</span> and <span class="ent">➍</span>. That’s because <code>objdump</code> isn’t aware of the unpacked binary’s expected load address because of the missing section header table. Note that in the unpacked binary, <code>objdump</code> is also unable to automatically annotate calls to PLT stubs with the corresponding function names. Fortunately, disassemblers like IDA Pro allow you to manually specify a load address so that after some configuration, you can reverse engineer the unpacked binary just like you would a normal one!</p>&#13;
<h3 class="h3" id="ch09_6">9.6 Summary</h3>&#13;
<p class="noindent">In this chapter, you learned how binary instrumentation techniques work and how to instrument binaries with Pin. You should now be ready to build your own Pintools to analyze and modify binaries at runtime. You’ll see Pin again in <a href="ch10.xhtml#ch10">Chapters 10</a> through <a href="ch13.xhtml#ch13">13</a> when I cover taint analysis and symbolic execution platforms that build on Pin.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch09_7"><span epub:type="pagebreak" id="page_264"/>Exercises</p>&#13;
<p class="boxhead1">1. Extending the Profiler</p>&#13;
<p class="noindent">The profiler records all syscalls, even ones that happen outside of the main application. Modify the profiler to check where a syscall originated and profile only those that originate in the main application. To find out how to do this, you’ll have to consult the Pin user manual online.</p>&#13;
<p class="boxhead1">2. Investigating Unpacked Files</p>&#13;
<p class="noindent">When you were testing the unpacker, it dumped several files, one of which was the unpacked<em> /bin/ls</em>. Investigate what the other files contain and why the unpacker dumped them.</p>&#13;
<p class="boxhead1">3. Extending the Unpacker</p>&#13;
<p class="noindent">Add a command line option to the automatic unpacker that, when enabled, causes it to instrument<em> all</em> control transfers, rather than just indirect ones, to look for the jump to OEP. Compare the runtimes of the unpacker with and without this option enabled. How would a packer that jumps to OEP with a direct control transfer work?</p>&#13;
<p class="boxhead1">4. Dumping Decrypted Data</p>&#13;
<p class="noindent">Build a Pintool that can monitor an application and automatically detect and dump data when the application decrypts it with RC4 (or another cryptographic algorithm of your choice). Your Pintool is allowed to report false positives (bogus data that’s not really decrypted) but should try to minimize them.</p>&#13;
</div>&#13;
</div></body></html>