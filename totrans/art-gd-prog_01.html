<html><head></head><body><div id="sbo-rt-content"><section>
      <header>
        <h1 class="chapter">
          <span class="ChapterNumber"><span epub:type="pagebreak" title="1" id="Page_1"/>1</span><br/>
          <span class="ChapterTitle">The Fundamentals of Drawing</span></h1>
      </header><figure class="opener">
        <img src="Images/chapterart.png" alt="" width="206" height="206"/>
      </figure>
      <h2 id="h1-501645c01-0001" class="HeadProject"><span><span epub:type="pagebreak" title="2" id="Page_2"/>Sketch 1: A Circle</span></h2>
      <p class="BodyFirst">Drawing a circle requires quite a bit of code in C or Java, but it’s one
        of the simplest programs in Processing. There isn’t a circle function in Processing, so to
        draw a circle we draw an ellipse that has equal width and height, which is the same thing as
        a circle. </p>
      <h3 id="h2-501645c01-0001">Example A</h3>
      <p class="BodyFirst">The <code>setup()</code> function calls the predefined
          <code>size()</code> function to open a sketch window with a width of 400 pixels and a
        height of 300 pixels <span class="CodeAnnotation" aria-label="annotation1">1</span>. </p>
      <p>The <code>draw()</code> function draws a circle every time it’s called (60 times per second
        by default) with the <code>ellipse()</code> function, which has four parameters. The first
        and second parameters specify the pixel coordinates of the ellipse’s center. The third and
        fourth parameters specify the ellipse’s width and height. The call <code>ellipse (200, 150,
          50, 50)</code>
        <span class="CodeAnnotation" aria-label="annotation2">2</span> draws an ellipse centered at
        (200, 100) that is 50 pixels wide and 50 pixels high, which is essentially a circle with a
        diameter of 50 pixels. </p>
      <p>By default, the background color is set to a medium grey, and the color that fills the
        circle is white. The circle is outlined by a black line.</p>
      <h3 id="h2-501645c01-0002">Example B</h3>
      <p class="BodyFirst">This example is much like Example A, but now the background color is set
        to white, and the color that fills the circle (and any other basic closed shape) is set to
        black.</p>
      <p>The <code>background()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> specifies the background color with a single number
        parameter ranging from 0 to 255 that indicates levels of gray, where 0 is black and 255 is
        white. Numerical values outside of this range are illegal. In this case the color is set to
        white (<code>255</code>). The <code>background()</code> function is specified in the
          <code>draw()</code> function so that the background is redrawn each time. If
          <code>background()</code> was called in <code>setup()</code>, the background would only be
        drawn once, at the beginning of execution.</p>
      <p>The <code>fill()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span> specifies the fill color of basic closed shapes with the same single number
        parameter as the <code>background()</code> function. In this case the fill color is set to
        black (<code>0</code>), and it remains so until changed by another call to
          <code>fill()</code>. Thus, <code>fill()</code> could have been called just once within
          <code>setup()</code> and the effect would have been the same.</p>
      <h3 id="h2-501645c01-0003">Example C</h3>
      <p class="BodyFirst">In this case the background color (white = <code>255</code>) <span class="CodeAnnotation" aria-label="annotation1">1</span> and fill color (black =
          <code>0</code>) <span class="CodeAnnotation" aria-label="annotation2">2</span> are
        specified in <code>setup()</code>. This sketch draws two ellipses, not circles, in the
          <code>draw()</code> function to show how the width and height parameters are used. The
        first call to <code>ellipse()</code>
        <span class="CodeAnnotation" aria-label="annotation3">3</span> draws the leftmost ellipse,
        which is 100 pixels wide and 50 pixels high. The second call to <code>ellipse()</code>
        <span class="CodeAnnotation" aria-label="annotation4">4</span> draws the rightmost ellipse,
        which is 50 pixels wide and 100 pixels high.</p>
      <p> The <code>noFill() </code>function causes ellipses and other objects to be drawn without
        any fill color so that the background color shows inside the object.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <p class="BoxCodeLabel">Example A</p>
          <pre><code>void setup ()
{
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> size (400, 300);
}

void draw ()
{
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> ellipse (200, 150, 50, 50);
}</code></pre>
          <span epub:type="pagebreak" title="3" id="Page_3"/><figure class="graphic"><img src="Images/g01001.png" alt="g01001" width="353" height="182"/></figure>
          <p class="BoxCodeLabel">Example B</p>
          <pre><code>void setup ()
{
  size (400, 300);  
}

void draw ()
{
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> background (255);
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> fill (0);
  ellipse (200, 150, 50, 50);
}</code></pre>
          <figure class="graphic"><img src="Images/g01002.png" alt="g01002" width="347" height="233"/></figure>
          <p class="BoxCodeLabel">Example C</p>
          <pre><code>void setup ()
{
  size (400, 300);
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> background (255);
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> fill (0);
}

void draw ()
{
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> ellipse (100, 150, 100, 50);
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> ellipse (300, 150, 50, 100);
}</code></pre>
          <figure class="graphic"><img src="Images/g01003.png" alt="g01003" width="347" height="253"/></figure>
          <div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0002" class="HeadProject"><span><span epub:type="pagebreak" title="4" id="Page_4"/>Sketch 2: Colors</span></h2>
      <p class="BodyFirst">We can specify a shade of grey with a single numerical component, but we
        can also specify a color by providing three numerical components to the same function. These
        components are given in the traditional order: red, then green, then blue. Each component
        fits in a single byte (8 bits), and it is represented by a number ranging from 0 to 255 that
        determines the shade of the component. Smaller values yield a darker color.</p>
      <p>The numbers (255, 0, 0) specify the brightest shade of red, while the numbers (254, 0, 0)
        specify a slightly darker shade of red. Green would be (0, 255, 0) and blue would be (0, 0,
        255). Yellow is red and green, so a set of RGB coordinates for yellow would be (255, 255,
        0). Magenta is red and blue, so it would be written as (255, 0, 255). Grey values have the
        three components nearly equal. </p>
      <p>This is the <span class="KeyTerm">RGB representation of color</span>. There are other
        representations.</p>
      <h3 id="h2-501645c01-0004">Example A</h3>
      <p class="BodyFirst">This sketch draws circles of various colors. In the <code>draw()</code>
        function, the first three calls to <code>fill()</code> and <code>ellipse()</code> draw the
        first row of circles: red <span class="CodeAnnotation" aria-label="annotation1">1</span>,
        green <span class="CodeAnnotation" aria-label="annotation2">2</span>, and blue <span class="CodeAnnotation" aria-label="annotation3">3</span>. The fill color changes prior to
        drawing each circle. </p>
      <p>The second row of circles is filled with yellow <span class="CodeAnnotation" aria-label="annotation4">4</span>, magenta <span class="CodeAnnotation" aria-label="annotation5">5</span>, and cyan <span class="CodeAnnotation" aria-label="annotation6">6</span>. Each color here has two nonzero color values. </p>
      <p>The final row contains circles filled with increasingly brighter grey values <span class="CodeAnnotation" aria-label="annotation7">7</span>. Each color here has three equal
        color values.</p>
      <h3 id="h2-501645c01-0005">Example B</h3>
      <p class="BodyFirst">We can also use a fourth color component that represents <span class="KeyTerm">transparency</span>, sometimes referred to as the <span class="KeyTerm">alpha</span> channel. The components (255, 0, 0, 128) indicate that red is 255, green and
        blue are 0, and transparency is 128, or 50 percent. Higher numerical values indicate lower
        transparency. We can give any color any legal transparency value in addition to R, G, and B
        values.</p>
      <p>This sketch draws sets of overlapping red, green, and blue circles to show transparency. </p>
      <p>In the <code>draw()</code> function, the first three calls to <code>fill()</code> and
          <code>ellipse()</code>
        <span class="CodeAnnotation" aria-label="annotation1">1</span> draw the upper-left set of
        circles with a fill color transparency value of 20. </p>
      <p>The second three calls <span class="CodeAnnotation" aria-label="annotation2">2</span> draw
        the upper-right set of circles with a transparency value of 100. </p>
      <p>The third three calls <span class="CodeAnnotation" aria-label="annotation3">3</span> draw
        the lower-left set with a transparency value of 180.</p>
      <p>The final three calls <span class="CodeAnnotation" aria-label="annotation4">4</span> draw
        the lower-right set of circles with a transparency value of 255, which means the color is
        completely opaque. </p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="note">
          <h2><span class="NoteHead">NOTE</span></h2>
          <p> Processing defines a <code>color</code> type for specifying colors. It contains values
            for red, green, blue, and transparency. The function <code>color(</code><code>r, g, b,
              a)</code> takes numerical values and returns a value of the <code>color</code> type.
            Variables can also hold values of the <code>color</code> type.</p>
          <p class="continued">We could declare a variable and initialize it as follows:</p>
          <pre><code>color r;
r = color(255, 0, 0);   // The variable r now holds a red color.</code></pre><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <p class="BoxCodeLabel"><span epub:type="pagebreak" title="5" id="Page_5"/>Example
            A</p>
          <pre><code>void setup ()
{
  size (400, 300);  
  background (255);     
}

void draw ()
{
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> fill (255, 0, 0); ellipse (100, 50, 50, 50);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> fill (0, 255, 0); ellipse (200, 50, 50, 50);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> fill (0, 0, 255); ellipse (300, 50, 50, 50);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> fill (255, 255, 0); ellipse (100, 150, 50, 50);
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> fill (255, 0, 255); ellipse (200, 150, 50, 50);
  <span class="CodeAnnotationHang" aria-label="annotation6">6</span> fill (0, 255, 255); ellipse (300, 150, 50, 50);
  <span class="CodeAnnotationHang" aria-label="annotation7">7</span> fill (64, 64, 64); ellipse (100, 250, 50, 50);
  fill (128, 128, 128); ellipse (200, 250, 50, 50);
  fill (196, 196, 196); ellipse (300, 250, 50, 50);
}</code></pre>
          <figure class="graphic"><img src="Images/g02001.png" alt="g02001" width="347" height="257"/></figure>
          <p class="BoxCodeLabel">Example B</p>
          <pre><code>void setup ()
{
  size (400, 300);
  background (255);
}

void draw ()
{
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> fill (255, 0, 0, 20); ellipse (50,  50, 100, 100);
  fill (0, 255, 0, 20); ellipse (100, 75, 100, 100);
  fill (0, 0, 255, 20); ellipse (50, 100, 100, 100);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> fill (255, 0, 0, 100); ellipse (250, 50, 100, 100);
  fill (0, 255, 0, 100); ellipse (300, 75, 100, 100);
  fill (0, 0, 255, 100); ellipse (250, 100, 100, 100);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> fill (255, 0, 0, 180); ellipse (50,  200, 100, 100);
  fill (0, 255, 0, 180); ellipse (100, 220, 100, 100);
  fill (0, 0, 255, 180); ellipse (50,  250, 100, 100);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> fill (255, 0, 0, 255); ellipse (250, 200, 100, 100);
  fill (0, 255, 0, 255); ellipse (300, 220, 100, 100);
  fill (0, 0, 255, 255); ellipse (250, 250, 100, 100);
}</code></pre>
          <figure class="graphic"><img src="Images/g02002.png" alt="g02002" width="324" height="261"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0003" class="HeadProject"><span><span epub:type="pagebreak" title="6" id="Page_6"/>Sketch 3: if Statements—Changing Colors Conditionally</span></h2>
      <p class="BodyFirst">In daily life, people often deal with conditional actions, although
        little if any thought is given to the idea. We express the conditions in human language, of
        course:</p>
      <ol class="none">
        <li>“If it is raining, we’ll watch TV, but if it is sunny, we’ll go skiing.” </li>
        <li>“If the light is red, then stop, but if it is green, just drive on through.”</li>
      </ol>
      <p>We can also use conditional actions when programming a computer. If some situation is true,
        we execute a certain section of code. The condition or situation has to be expressed in
        numerical terms, and the result is a <code>true</code> or <code>false</code> result. Such
        conditions are frequently the result of comparisons between numbers, such as “is <em>i</em>
        equal to 10” or “is the x-coordinate less than the width.”</p>
      <p>Conditional code is dealt with using an <code>if</code> statement, which has the following
        syntax:</p>
      <pre><code>if ( condition ) code ;    </code></pre>
      <p>Conditions can be comparisons between numbers, so the following are all conditions:</p>
      <pre><code>(x &gt; 2)      (P &lt; q+1)     (width == 640)     (width != height)</code></pre>
      <p>There are some special symbols in use here. The <code>=</code> symbol means assignment, so
        to compare for equality a different symbol must be used: Processing uses <code>==</code>. To
        compare for inequality, the symbol <code>!=</code> is used, meaning “not equal.” </p>
      <h3 id="h2-501645c01-0006">Example A</h3>
      <p class="BodyFirst">This sketch uses an <code>if</code> statement to increase an integer
        variable, <code>count</code>, every time <code>draw()</code> is called, and it changes the
        background color from red to green when the count reaches 100 <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
      <h3 id="h2-501645c01-0007">Example B</h3>
      <p class="BodyFirst">The previous English condition examples illustrate a normal use of
        another idea: <span class="KeyTerm">otherwise</span>. One example was “If it is raining,
        we’ll watch TV, but if it is sunny, we’ll go skiing.” That example could also be phrased as
        “If it is raining, we’ll watch TV; otherwise we’ll go skiing,” meaning that if it’s not
        raining, we’ll go skiing. In most computer languages this is written as an <code>else</code>
        part to an <code>if</code> statement with the following syntax:</p>
      <pre><code>if ( condition ) code ;
else code;</code></pre>
      <p>Example B uses an <code>else</code> to accomplish the same task as Example A <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
      <h3 id="h2-501645c01-0008">Example C</h3>
      <p class="BodyFirst">The third code example alternates between red and green each time
          <code>draw()</code> is called, creating a colored flashing effect.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <p class="BoxCodeLabel">Example A</p>
          <pre><code>int count = 0;
void setup()
{
  size (300, 300);
}

void draw ()
{
  background (0, 255, 0);
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> if (count&lt;100) 
    background(255, 0, 0);
  count = count + 1;
}</code></pre>
          <span epub:type="pagebreak" title="7" id="Page_7"/><figure class="graphic"><img src="Images/g03001a.png" alt="g03001a" width="312" height="329"/></figure>
          <p class="BoxCodeLabel">Example B</p>
          <pre><code>int count = 0;
void setup()
{
  size (300, 300);
}

void draw ()
{
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> if (count&lt;100) 
    background(255, 0, 0);
  else background (0, 255, 0);
  count = count + 1;
}</code></pre>
          <figure class="graphic"><img src="Images/g03001b.png" alt="g03001b" width="312" height="339"/></figure>
          <p class="BoxCodeLabel">Example C</p>
          <pre><code>int count = 0;
void setup()
{
  size (300, 300);
}

void draw ()
{
  if (count == 0) 
  {
    background(255, 0, 0);   count = 1;
  } else
  {
    background(0, 255, 0);   count = 0;
  }
}</code></pre>
          <div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0004" class="HeadProject"><span><span epub:type="pagebreak" title="8" id="Page_8"/>Sketch 4: Loops—Drawing 20 Circles</span></h2>
      <p class="BodyFirst">Programmers often need to execute the same code over and over again,
        sometimes with small variations. A program that draws 50 ellipses within the sketch window
        could be written using fifty calls to the <code>ellipse()</code> function, one for each
        ellipse drawn. Another way is to have one statement with a call to <code>ellipse(),</code>
        and execute it 50 times in a loop.</p>
      <p>A <span class="KeyTerm">loop</span> in a program is a collection of statements that
        executes repeatedly from the first statement to the last, in the same order. You must
        specify the condition upon which the loop will exit. It’s pretty common to know in advance
        how many times the loop should execute, as in the example of drawing 50 ellipses. Sometimes
        you won’t know the number ahead of time, but you can calculate it, so the loop will execute
          <em>N</em> times, and <em>N</em> depends on some other thing. In either case, a counting
        loop is called a <code>for</code> loop in Processing because the reserved word
          <code>for</code> is used to begin the loop. For example,</p>
      <pre><code>for (i=0; i&lt;10; i=i+1)  statementA ;</code></pre>
      <p>This loop executes 10 times: once when the variable <code>i=0</code>, again when
          <code>i=1</code>, again when <code>i=2</code>, and so on until <code>i=9</code>. When
          <code>i</code> is 10, the condition (<code>i&lt;10</code>) becomes false and the loop
        ends. As a result, <code>statementA</code> executes 10 times, once for each value of
          <code>i</code> from 0 to 9. </p>
      <p>The <code>for</code> loop has four parts:</p>
      <ol class="none">
        <li><span class="RunInHead"><code class="bold">i=0</code></span> The <span class="KeyTerm">initialization</span> is executed the first time through the loop.</li>
        <li><span class="RunInHead"><code class="bold">i&lt;10</code></span> The loop will continue
          to execute so long as the <span class="KeyTerm">continuation condition</span> is
          true.</li>
        <li><span class="RunInHead"><code class="bold">i=i+1</code></span> At the end of each
          iteration, after the statement is executed, the <span class="KeyTerm">increment</span>
          will be executed.</li>
        <li><span class="RunInHead"><code class="bold">statementA</code></span> This is the code
          that gets executed repeatedly.</li>
      </ol>
      <p>If the expression is false at the beginning, the loop does not execute even once.</p>
      <p>The statement that executes can be a <span class="KeyTerm">compound statement</span>, which
        is a collection of statements enclosed in braces. In fact, any time I refer to a
          <em>statement</em>, it can mean a compound statement. </p>
      <h3 id="h2-501645c01-0009">Example A</h3>
      <p class="BodyFirst">A simple loop in Processing can draw 20 ellipses <span class="CodeAnnotation" aria-label="annotation1">1</span> starting at (20, 40) and ending
        at (210, 40). The ellipses are circles and are drawn next to each other. The
          <code>draw()</code> function exists but does not do anything <span class="CodeAnnotation" aria-label="annotation2">2</span>. </p>
      <h3 id="h2-501645c01-0010">Example B</h3>
      <p class="BodyFirst">We can make the color change for each circle by using a compound
        statement. Let’s change the green value by 10 each time a circle is drawn, starting with
          <code>green = 10 </code><span class="CodeAnnotation" aria-label="annotation1">1</span>.
        Red and blue both stay at their maximum of 255. The code within the loop needs to set the
        fill color, draw the circle, and adjust the fill color for the next iteration <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
      <p>The loop executes for 20 values of <code>i</code>: 0 to 19 inclusive. If we were to expand
        the code to show what was being executed, it would look like this:</p>
      <pre><code>(i=0);  fill (255, 10, 255);  ellipse (20, 40, 10, 10);  g = 20;
(i=1);  fill (255, 20, 255);  ellipse (30, 40, 10, 10);  g = 30;
(i=2);  fill (255, 30, 255);  ellipse (40, 40, 10, 10);  g = 40;
<var>--snip--</var>
(i=19);	 fill (255, 190, 255); ellipse (210, 40, 10, 10); g = 200;</code></pre>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <p class="BoxCodeLabel"><span epub:type="pagebreak" title="9" id="Page_9"/>Example
            A</p>
          <pre><code>void setup ()
{
  size (500, 300);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> for (int i=0; i&lt;20; i++)
    ellipse (i*10+20,40,10,10);
}

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> void draw () { }</code></pre>
          <figure class="graphic"><img src="Images/g04001.png" alt="g04001" width="600" height="200"/></figure>
          <p class="BoxCodeLabel">Example B</p>
          <pre><code>void setup ()
{
  size (500, 300);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> int green = 10;
  for (int i=0; i&lt;20; i++)
  {
    fill (255, green, 255);
    ellipse (i*10+20, 40, 10, 10);
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> green = green+10;
  }
}
void draw (){ } </code></pre>
          <figure class="graphic"><img src="Images/g04002.png" alt="g04002" width="600" height="200"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0005" class="HeadProject"><span><span epub:type="pagebreak" title="10" id="Page_10"/>Sketch 5: Lines</span></h2>
      <p class="BodyFirst">Drawing lines is a basic thing to do in graphics. A <span class="KeyTerm">line</span> in Processing is really a <span class="KeyTerm">line segment</span>, and it
        is specified by identifying two endpoints that are to be connected by the line. The function
        that draws a line is named <code>line()</code>, and it takes the coordinates of the
        endpoints as parameters (for a total of four parameters). The call <code>line (10,10,
          20,20)</code> will draw a line in the window between coordinates (10, 10) and (20,
        20).</p>
      <h3 id="h2-501645c01-0011">Example A</h3>
      <p class="BodyFirst">Let’s draw some note paper. We can draw a horizontal line that runs the
        full width of the sketch window using this call, for some vertical position
        <code>y</code>:</p>
      <pre><code>line (0, y, width, y);</code></pre>
      <p class="BodyContinued">The width of the window is given by the variable <code>width</code>,
        and the height of the window is given by the variable <code>height</code>. The start of the
        line is <code>(0, y)</code> at the left of the image window <code>y</code> pixels down from
        the top; the end of the line is at <code>(width, y)</code> at the right of the window and
        the same <em>y</em> value.</p>
      <p>The color for drawing lines can be specified using a call to <code>stroke()</code> with a
        color as the parameter. For example, <code>stroke (255,0,0</code>) <span class="CodeAnnotation" aria-label="annotation1">1</span> specifies that red lines will be
        drawn.</p>
      <h3 id="h2-501645c01-0012">Example B</h3>
      <p class="BodyFirst">Processing will tell you where the mouse cursor is within the window
        using the built-in variables <code>mouseX</code> and <code>mouseY</code>
        <span class="CodeAnnotation" aria-label="annotation1">1</span>. Whenever a mouse button is
        pressed, Processing calls a function called <code>mousePressed()</code>, if it exists. You
        have to write it if you want to use the mouse. When a mouse button is released, Processing
        calls the <code>mouseReleased()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>. You have to write that one too. The
          <code>mousePressed()</code> and <code>mouseReleased()</code> functions are referred to as
          <span class="KeyTerm">callbacks</span>, and they offer a very simple way to access button
        presses. Additionally, press and release amount to touches on a touch screen device, so the
        program will work on touch screen devices as well. </p>
      <p>This example uses <span class="KeyTerm">clicks</span> (presses and releases) to draw lines.
        The first mouse click defines the starting point for the line (<code>x0</code>,
          <code>y0</code>) <span class="CodeAnnotation" aria-label="annotation3">3</span>. The
        second click (when <code>x1 &lt; 0</code>) <span class="CodeAnnotation" aria-label="annotation4">4</span> defines the endpoint of the line. A third click (when
          <code>x1 &gt;= 0</code>) <span class="CodeAnnotation" aria-label="annotation5">5</span>
        clears the endpoints and starts again.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="note">
          <h2><span class="NoteHead">NOTE</span></h2>
          <p> The thickness of a line can be specified by calling the function
              <code>strokeWeight</code><code>(n)</code>. The parameter <code>n</code> is the number
            of pixels thick the line will be.</p>
          <p class="continued">The symbol <code>&amp;&amp;</code> means <em>and</em>. It can be
            applied to any pair of variables or expressions that have the value <code>true</code> or
              <code>false</code>; in other words, things of Boolean type. It is used in
              <code>if</code> statements, and the effect is that the result is <code>true</code> if
            both sides of the expression are <code>true</code>. So the expression <code>(a
              &amp;&amp; b)</code> is only true if both <code>a</code> and <code>b</code> are true.
            For example, this statement tests whether the value of <code>x</code> is horizontally
            within the window boundaries:</p>
          <pre><code>if ( (x&gt;=0) &amp;&amp; (x&lt;width) ) statementA;</code></pre>
          <p class="continued">That is the same as this:</p>
          <pre><code>if (x &gt;= 0) 
  if (x&lt;width)
    statementA;</code></pre><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <p class="BoxCodeLabel"><span epub:type="pagebreak" title="11" id="Page_11"/>Example
            A</p>
          <pre><code>void setup ()
{
  size(500, 500);
}
void draw ()
{
  background (220, 220, 220);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> stroke (255, 0, 0);    // Red margin line
  line (20, 0, 20, height);
  stroke (100, 0, 250);  // Blue horizontal lines
  for (int i=4; i&lt;50; i++)
    line (0, i*10, width, i*10);
}</code></pre>
          <figure class="graphic"><img src="Images/g05001.png" alt="g05001" width="280" height="280"/></figure>
          <p class="BoxCodeLabel">Example B</p>
          <pre><code>int x0=-1, y0=-1;
int x1=-1, y1=-1;

void setup ()
{
  size(300, 300);
}

void draw ()
{
  background (200, 200, 200);          
  if (x1 &gt;= 0)    line (x0, y0, x1, y1);
  else if (x0 &gt;= 0)  line (x0, y0, <span class="CodeAnnotation" aria-label="annotation1">1</span>mouseX, mouseY);
}

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> void mouseReleased ()
{
  if (x0 &lt; 0)
    { 
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> x0 = mouseX;    y0 = mouseY;
    }
  else if <span class="CodeAnnotationCode" aria-label="annotation4">4</span>(x1 &lt; 0)
    {
      x1 = mouseX;    y1 = mouseY;  
    }
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> else  {  x0 = y0 = -1;    x1 = y1 = -1;  }
}</code></pre>
          <figure class="graphic"><img src="Images/g05002.png" alt="g05002" width="192" height="584"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0006" class="HeadProject"><span><span epub:type="pagebreak" title="12" id="Page_12"/>Sketch 6: Arrays—Drawing Many Circles</span></h2>
      <p class="BodyFirst">A variable can hold a value, such as a single number. If we want more
        values, we can use more variables. For example, to draw two circles, we could have two sets
        of coordinate variables, say <code>x0</code>, <code>y0</code> and <code>x1</code>,
          <code>y1</code>, and we could draw the two circles with two calls:</p>
      <pre><code>ellipse (x0, y0, 10, 10);
ellipse (x1, y1, 10, 10);</code></pre>
      <p>But what if we wanted to draw a circle every time the mouse button was clicked, and to draw
        it where the cursor is on the screen? We don’t know how many circles to draw in advance, so
        we don’t know how many variables to declare. Instead, we can keep track of <em>x</em> and
          <em>y</em> using what Processing calls an <span class="KeyTerm">array</span>. An array is
        a collection of values all having the same type. The syntax for declaring an array is</p>
      <pre><code>int [] x = new int[100];</code></pre>
      <p>This declaration defines an array named <code>x</code> that can hold 100 integers. The
        phrase <code>int [] x</code> means “define a new array named x,” and the phrase <code>new
          int[100]</code> defines the size, where 100 could be replaced by any constant. The
        preceding declaration could also be done in two parts:</p>
      <pre><code>int [] x;
x = new int[100];</code></pre>
      <p>You access the values in the array using an <span class="KeyTerm">index</span>, a number
        that specifies which of the values you want, starting from 0: <code>x[0]</code> is the first
        element (value) in the array with an index of <code>0</code>, <code>x[1]</code> is the
        second with an index of <code>1</code>, and so on to the last one, <code>x[99]</code>.</p>
      <p>The example sketch uses two arrays, one for <code>x</code> and one for <code>y</code>, and
        it draws a circle at the coordinates where the mouse button is clicked (pressed and
        released). Initially each element in the <code>x</code> and <code>y</code> array is given
        the value −1 <span class="CodeAnnotation" aria-label="annotation1">1</span> in
          <code>setup()</code>. This is called a <span class="KeyTerm">sentinel</span> value, and it
        indicates that there is no circle defined at that index. The <code>ncircles</code> variable
        indicates how many circles have been defined, which is how many mouse clicks have been
        recorded; it starts at 0 and is incremented up to the maximum number of circles
          (<code>MAXCIRCLES</code>, a constant defined to be 100). When the mouse button is
        released, the system calls the <code>mouseReleased()</code> callback function <span class="CodeAnnotation" aria-label="annotation3">3</span>, which saves the current value of
        the mouse coordinates in the arrays <code>x</code> and <code>y</code> at the current
        position (<code>ncircles</code>) and increases <code>ncircles</code> by 1. If
          <code>ncircles</code> becomes equal to <code>MAXCIRCLES</code>, it is reset to 0 <span class="CodeAnnotation" aria-label="annotation4">4</span>, which means that new circles
        will be saved over the earliest ones drawn. The old ones will, of course, be lost.</p>
      <p>The <code>draw()</code> function first sets the background and then draws a circle at the
        mouse coordinates. Then all the elements of the <code>x</code> array are examined, and if
        the value of element <code>i</code> is greater than 0, a circle is drawn at <code>x[i],
          y[i]</code>
        <span class="CodeAnnotation" aria-label="annotation2">2</span> using this call:</p>
      <pre><code>ellipse (x[i], y[i], 18, 18);</code></pre>
      <p>The constant value <code>MAXCIRCLES</code> is defined using a special <code>final</code>
        property in its declaration:</p>
      <pre><code>final int MAXCIRCLES = 100;</code></pre>
      <p>The value of <code>MAXCIRCLES</code> can’t be changed anywhere in the program because it is
          <code>final</code>. It can (and should) be used to define the size of the two arrays:</p>
      <pre><code>int x[] = new int[MAXCIRCLES];</code></pre>
      <p><span epub:type="pagebreak" title="13" id="Page_13"/>Defining the size of the arrays
        using a constant means that to increase the number of circles allowed, you only need to
        change the value of <code>MAXCIRCLES</code>.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <pre><code>
final int MAXCIRCLES = 100;
int x[] = new int[MAXCIRCLES];
int y[] = new int[MAXCIRCLES];
int ncircles  = 0;

void setup ()
{
  size (600, 400);
  fill (200, 150, 100);
  for (int i=0; i&lt;MAXCIRCLES; i++) 
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> x[i] = -1;
}

void draw ()
{ 
  background (200);
  ellipse (mouseX, mouseY, 20, 20);  
  
  for (int i=0; i&lt;MAXCIRCLES; i++)  
    if (x[i] &gt;= 0) 
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> ellipse (x[i], y[i], 18, 18);
    else break;
}

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> void mouseReleased ()
{
  x[ncircles] = mouseX; 
  y[ncircles] = mouseY;
  ncircles = (ncircles+1);
  if (ncircles&gt;=MAXCIRCLES) 
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> ncircles = 0;
}</code></pre>
          <figure class="graphic"><img src="Images/g06001.png" alt="g06001" width="698" height="461"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0007" class="HeadProject"><span><span epub:type="pagebreak" title="14" id="Page_14"/>Sketch 7: Lines with Rubber Banding</span></h2>
      <p class="BodyFirst">We are going to use the mouse to draw lines again. A line consists of a
        starting point and an endpoint, each having an x and a y component. We previously drew a
        line when the mouse was clicked on start and end points on the screen, but it only drew
          <em>one</em> line. What if we wanted to be able to draw many lines like this? </p>
      <p>We can define a starting point when the mouse button is pressed <span class="CodeAnnotation" aria-label="annotation3">3</span> and the endpoint when the button
        is released <span class="CodeAnnotation" aria-label="annotation4">4</span>, as we did
        before. But now we can store these points in arrays and draw them all during each screen
        update. The array <code>x0</code> saves the starting x-coordinate of a line, and
          <code>y0</code> has the corresponding y-coordinate. The arrays <code>x1</code> and
          <code>y1</code> will store the end coordinates. When the mouse button is pressed, we save
        the starting point (<code>x0[n]</code>, <code>y0[n]</code>), and<b> </b>when the mouse
        button is released, we save the endpoint as <code>x1[n]</code> and <code>y1[n]</code> and
        increment the value of <code>n</code>. This program will allow us to draw 256 lines because
        of the fixed size of the arrays.</p>
      <p>When the starting point has been selected, we draw a line from that point to the current
        mouse coordinates to show how the line <em>would</em> look <span class="CodeAnnotation" aria-label="annotation2">2</span>. This is called <span class="KeyTerm">rubber
          banding</span> because the line appears to stretch and contract as the mouse moves. When
        the mouse button is released, we finalize the end coordinates and draw the final line. </p>
      <p>During each frame (the default is 30 frames per second) we draw all of the saved lines by
        calling <code>line (x0[i], y0[i], x1[i], y1[i])</code> for all <code>i</code> from
          <code>0</code> to <code>n-1</code>
        <span class="CodeAnnotation" aria-label="annotation1">1</span>. We then draw the rubber band
        line if the mouse button is currently depressed (when <code>down</code> is set to
          <code>true</code>). Setting <code>down</code> to <code>true</code> happens in
          <code>mousePressed</code>, and it is set to <code>false</code> when the button is
        released, within <code>mouseReleased</code>. If <code>down</code> is <code>true</code>, a
        line is drawn from the last selected point to the mouse coordinates:</p>
      <pre><code>line (x0[n], y0[n], mouseX, mouseY);</code></pre>
      <p class="BodyContinued">This implements the rubber banding.</p>
      <p>As a new idea, the sketch implements an <em>erase</em> feature. If the user types the <span class="KeyCaps">backspace</span> key, the most recent line is deleted. When the system
        detects a key press, Processing calls a user-defined function named
          <code>keyPressed()</code>
        <span class="CodeAnnotation" aria-label="annotation5">5</span>. A variable named
          <code>key</code> provides the value of the key that was pressed, so inside
          <code>keyPressed()</code> we check if the key is <span class="KeyCaps">backspace</span>,
        and if so we decrease the value of <code>n</code> (the number of lines so far) by 1. As a
        result, the last line will not be drawn, and the next line will be saved over the erased
        line in the coordinate arrays. </p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <pre><code><span epub:type="pagebreak" title="15" id="Page_15"/>int N = 10;
int x0[] = new int[N];  
int y0[] = new int[N];
int x1[] = new int[N];
int y1[] = new int[N];
int n = 0;              
boolean down = false; // A boolean variable can only be true or false

void setup ()
{
  size(500, 500);
}

void draw ()
{
  background (200, 200, 200);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> for (int i=0; i&lt;n; i++)   
   {
     line (x0[i], y0[i], 
        x1[i], y1[i]);
   }     
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> if (down) line (x0[n], y0[n], mouseX, mouseY);
}

void mousePressed()
{
  down = true;
  if (n&lt;N)   
  {
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> x0[n] = mouseX;    
    y0[n] = mouseY;
  }
}

void mouseReleased ()
{
  if (n&lt;N-1)
  {
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> x1[n] = mouseX;
    y1[n] = mouseY;
    n = n + 1;
  }
  down = false;
}

<span class="CodeAnnotationHang" aria-label="annotation5">5</span> void keyPressed ()
{
  if (key==BACKSPACE &amp;&amp; n&gt;0)
     n = n - 1;
}</code></pre>
          <figure class="graphic"><img src="Images/g07001.png" alt="g07001" width="347" height="347"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0008" class="HeadProject"><span><span epub:type="pagebreak" title="16" id="Page_16"/>Sketch 8: Random Circles</span></h2>
      <p class="BodyFirst">This sketch draws circles at random places on the screen, with random
        colors. Randomness refers to unpredictability, and it is a complex concept. If you try to
        draw straight lines with a pencil, it is impossible that any two of them will be identical.
        There are variations that creep in and cause minor changes in each line. The same is true of
        brush strokes when painting. No two human activities will be exactly the same, and the
        differences will be unpredictable but apparent. </p>
      <p>When using a computer, a <span class="KeyTerm">random number generator</span> creates
        numbers that are random with respect to each other. Random numbers can be used to simulate
        random events in games like dice or poker, to do things that a user would find
        unpredictable, or to simulate complex real-world situations. For example, things like the
        spacing between cars on a road and the appearance of raindrops on a window appear random
        because we do not understand all of the complex factors that went into the situation. </p>
      <p>The random number generator in Processing is named <code>random</code>. The call
          <code>random (100)</code> will generate a real number between 0 and 100, not including
        100. The call <code>random (10, 20)</code> will return a real number between 10 and 20, but
        less than 20. The call <code>random (0, width)</code> generates a random <em>x</em> position
        within the sketch window, and <code>random (0, height)</code> generates a random <em>y</em>
        position.</p>
      <p>Like Sketch 6, this sketch stores coordinates in arrays and uses them to draw circles with
        calls to <code>ellipse()</code>, but instead of drawing circles when the mouse is clicked, a
        new circle is created automatically every second. To do this, we set the rate at which
          <code>draw()</code> is called (the <span class="KeyTerm">frame rate</span>) to 1 using the
        call <code>frameRate(1)</code>
        <span class="CodeAnnotation" aria-label="annotation1">1</span> in <code>setup()</code>. Each
        time <code>draw()</code> is called, we generate a new x- and y-coordinate using
          <code>random()</code> and save it in the <code>x</code> and <code>y</code> arrays <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
      <pre><code>x[ncircles] = (int)random(0, width); 
y[ncircles] = (int)random(0, height);</code></pre>
      <p>The <code>(int)</code> in front of the calls to random converts the result, a
          <code>float</code>, into a new type, <code>int</code>. This is called a <span class="KeyTerm">cast</span>, and we are changing the <span class="KeyTerm">floating-point</span> value into an integer because we can’t use values with decimal
        points as coordinates. This can also be done using a call to the function
        <code>int()</code>:</p>
      <pre><code>x[ncircles] = int(random(0, width)); 
y[ncircles] = int(random(0, height));</code></pre>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="note">
          <h2><span class="NoteHead">NOTE</span></h2>
          <p> The random number generator can be used to generate random die rolls using this
            call:</p>
          <pre><code>roll = int(random(1, 7));</code></pre>
          <p class="continued">This call can never return the value 7, and it truncates the float
            values between 1 and 2 to be 1, 2 and 3 to be 2, and so on. A random coin toss (1=heads,
            2=tails) would be generated as follows: </p>
          <pre><code>toss = int(random(1, 2) + 0.5);</code></pre><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <pre><code><span epub:type="pagebreak" title="17" id="Page_17"/>final int MAXCIRCLES = 256;
int x[] = new int[MAXCIRCLES];
int y[] = new int[MAXCIRCLES];
int ncircles  = 0;

void setup ()
{
  size (600, 400);        
  fill (200, 150, 100);   
  for (int i=0; i&lt;MAXCIRCLES; i++) 
    x[i] = -1; 
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> frameRate(1);   
}

void draw ()
{ 
  background (200);         
  
  for (int i=0; i&lt;MAXCIRCLES; i++)  
    if (x[i] &gt;= 0) 
      ellipse (x[i], y[i], 18, 18);
    else break;
    
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> x[ncircles] = int(random(0, width)); 
  y[ncircles] = int(random(0, height));
  ncircles = (ncircles+1);
  if (ncircles&gt;=MAXCIRCLES) 
    ncircles = 0;
}</code></pre>
          <figure class="graphic"><img src="Images/g08001.png" alt="g08001" width="692" height="391"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0009" class="HeadProject"><span><span epub:type="pagebreak" title="18" id="Page_18"/>Sketch 9: A Rectangle</span></h2>
      <p class="BodyFirst">You could draw a rectangle by drawing four lines that represent the
        edges, but the Processing system would not consider this to be a rectangle; it has no way to
        know that the four lines are a single object. Instead, Processing has a function for drawing
        rectangles, called <code>rect()</code>. Rectangles will be filled using the current fill
        color, just as circles were.</p>
      <p>The default way to specify a rectangle is <code>CORNER</code> mode, where the first two
        parameters you supply are the coordinates of the upper-left corner of the rectangle,
        followed by the width and the height, in pixels. If you specify <code>CENTER</code> mode,
        the first two parameters are the coordinates of the center of the rectangle.
          <code>CORNERS</code> mode specifies the coordinates of the first corner, then the
        coordinates of the diagonally opposite corner. You can change the mode using one of the
        following calls:</p>
      <pre><code>rectMode(CORNER);
rectMode(CENTER);
rectMode(CORNERS);</code></pre>
      <p>In this sketch we’ll use <code>CORNERS</code> mode <span class="CodeAnnotation" aria-label="annotation1">1</span>, as specified in the <code>setup</code> function, and
        fill the rectangle with a shade of purple: <code>(200, 0, 160)</code>. As in the previous
        sketches, the <code>mousePressed()</code> function sets a Boolean <code>flag</code> variable
        to <code>true</code> when the mouse button is pressed <span class="CodeAnnotation" aria-label="annotation3">3</span>, and <code>mouseReleased()</code> clears the variable
        (sets it to <code>false</code>) <span class="CodeAnnotation" aria-label="annotation5">5</span>. </p>
      <p>The global variables <code>x</code> and <code>y</code> represent the first corner of the
        rectangle and are initialized to −1. When the mouse button is pressed, we set <code>x</code>
        and <code>y</code> to the current value of <code>mouseX</code> and <code>mouseY </code><span class="CodeAnnotation" aria-label="annotation4">4</span>, and the <code>flag</code>
        variable is set to indicate that <code>x</code> has been set. Then the <code>draw()</code>
        function will draw a rectangle with <code>(x, y)</code> as one corner and the current mouse
        position <code>(mouseX, mouseY)</code> as the other <span class="CodeAnnotation" aria-label="annotation2">2</span>. This implements the rubber band effect.</p>
      <p>Global variables <code>x1</code> and <code>y1</code> are the coordinates of the second
        corner of the rectangle. When the mouse is released, we see the values of <code>x1</code>
        and <code>y1</code> to the current mouse coordinates <span class="CodeAnnotation" aria-label="annotation6">6</span>, and this completes the rectangle. The
          <code>draw()</code> function will draw the rectangle with the value of <code>x1</code> and
          <code>y1</code> as the opposite corner because <code>flag</code> is now false.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="note">
          <h2><span class="NoteHead">NOTE</span></h2>
          <p> Ellipses have drawing modes too, as set by the function
              <code>ellipseMode</code><code>(</code><code>)</code>.
              <code>ellipseMode</code><code>(</code><code>CENTER)</code> is the default mode, and
            the one with which you are familiar.
              <code>ellipseMode</code><code>(</code><code>CORNER)</code> treats the first two
            parameters of ellipse as the coordinates of the upper-left corner and the remaining two
            as the width and height. <code>ellipseMode</code><code>(</code><code>CORNERS)</code>
            treats the first two parameters as the coordinates of one corner of a box enclosing the
            ellipse and the second two parameters as the coordinates of the second corner.</p>
          <div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <pre><code><span epub:type="pagebreak" title="19" id="Page_19"/>int x = -1, y = -1;
int x1 = -1, y1 = -1;
boolean flag = false;

void setup ()
{
  size (600, 400);
  fill (200, 0, 160);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> rectMode (CORNERS);
}

void draw ()
{
  background (200);
  if (flag)
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> rect (x, y, mouseX, mouseY);
  else
    rect (x, y, x1, y1);
}

void mousePressed ()
{
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> flag = true;
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> x = mouseX; y = mouseY;
}
  
void mouseReleased ()
{
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> flag = false;
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> x1 = mouseX; y1 = mouseY; 
}</code></pre>
          <figure class="graphic"><img src="Images/g09001.png" alt="g09001" width="555" height="364"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0010" class="HeadProject"><span><span epub:type="pagebreak" title="20" id="Page_20"/>Sketch 10: Triangles and Motion</span></h2>
      <p class="BodyFirst">Just as rectangles are drawn using the built-in <code>rect()</code>
        function, triangles are drawn using the built-in <code>triangle()</code> function. Triangles
        can’t be drawn using a height and width; their shape is determined by their three angles. As
        a result, the <code>triangle()</code> function has six arguments: the x, y coordinates of
        the three <span class="KeyTerm">vertices</span> (corners).</p>
      <p>This sketch draws triangles using the mouse. Like the previous sketches that draw
        rectangles and lines, this sketch uses <code>mouseReleased()</code>
        <span class="CodeAnnotation" aria-label="annotation3">3</span> to determine when a point has
        been selected. After three clicks, a triangle will be drawn using the three selected points
        as the vertices.</p>
      <p>After the triangle is drawn, it begins to move downward, as if it had been pushed slightly.
        It continues to move downward until it hits the bottom border of the sketch window, where it
        disappears.</p>
      <p>We accomplish the motion by adding a small value <span class="CodeAnnotation" aria-label="annotation1">1</span> (<code>delta </code>= 1) to the y-coordinates of the
        triangle after each time it is drawn. This draws the triangle at successively lower
        locations in the window until it appears to pass beyond the bottom edge of the window. In
        fact, the triangle still exists to the Processing system, and its coordinates continue to
        update even though it can’t be seen.</p>
      <p>If the user of this program clicks the mouse after the triangle is drawn, the triangle
        disappears and the drawing process begins again. We restart the drawing process by
        re-initializing all of the vertices to −1 <span class="CodeAnnotation" aria-label="annotation4">4</span>, which indicates that they have not been defined yet. </p>
      <p>The following line of code is commented out inside of <code>draw()</code>:</p>
      <pre><code><span class="CodeAnnotationHang" aria-label="annotation2">2</span> // delta = delta + 1;</code></pre>
      <p>If you remove the <code>//</code> at the beginning of the line, the line will execute and
        the triangle will fall faster and faster, as if being pulled by a force (for example,
        gravity). Remove the // from the line near the end of <code>mouseReleased()</code> as well
        and the initial speed will reset to 1 with each new triangle drawn.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <pre><code><span epub:type="pagebreak" title="21" id="Page_21"/>int x0=-1, y0=-1;
int x1=-1, y1=-1;
int x2=-1, y2=-1;
int delta = 1;

void setup ()
{
  size (400, 400);
}

void draw ()
{
  background (200);

  if (x2 &gt;= 0)
  {
    triangle (x0, y0, x1, y1, x2, y2);
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> y0 = y0 + delta; y1 = y1 + delta; y2 = y2 + delta;
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> // delta = delta + 1;
  }
  else if (x1 &gt;= 0) 
  {
    line (x0, y0, x1, y1);
    line (x1, y1, mouseX, mouseY);
  } else if (x0 &gt; 0)  line (x0, y0, mouseX, mouseY);
}
  
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> void mouseReleased ()
{
  if (x0 &lt; 0)  {  x0 = mouseX; y0 = mouseY; }
  else if (x1 &lt; 0) {  x1 = mouseX; y1 = mouseY; }
  else if (x2 &lt; 0)
  {
    x2 = mouseX; y2 = mouseY;
  } else  
  { 
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> x0 = y0 = -1;  
    x1 = y1 = -1;   
    x2 = y2 = -1;  
    // delta = 1;
  }
}</code></pre>
          <figure class="graphic"><img src="Images/g10001.png" alt="g10001" width="278" height="704"/></figure>
          <div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0011" class="HeadProject"><span><span epub:type="pagebreak" title="22" id="Page_22"/>Sketch 11: Displaying Text</span></h2>
      <p class="BodyFirst">Text is essential in nearly all practical computational programs and in
        many generative art and net art programs as well. Text is a primary way that humans
        communicate, and while we say that “a picture is worth a thousand words,” it is frequently
        true that a few carefully chosen words can make an otherwise incomprehensible image into a
        valuable communications tool. Think of the labels along the axis of a graph, for
        instance.</p>
      <p>We draw text in the sketch window in the same way that we draw lines and ellipses, using a
        simple function. The first thing you need to know is that text is drawn starting at a
        particular (<em>x</em>, <em>y</em>) location, where <em>x </em>and <em>y</em> represent the
        coordinates of the lower-left corner of the box that encloses the text <em>when not
          considering descenders</em>. Characters such as <em>y</em> and <em>j</em> extend below
        this box, and they so have <em>y</em> values greater than the value specified.</p>
      <p>We will draw text using a call to the function <code>text()</code>
        <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
      <pre><code>text ("This is a string to be drawn", 100, 20);</code></pre>
      <p class="BodyContinued">In this case, the coordinates of the lower left of the string are
          <code>(100, 20)</code>. The initial font and size are defaults, and these defaults are
        system dependent. Size is easy to specify using the <code>textSize(n)</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span>, passing the desired size of the
        characters <em>in pixels</em> (not points). The color used to draw the text is the current
        fill color, not the stroke color.</p>
      <p>The alignment of the text can be specified using calls to the <code>textAlign()</code>
        function <span class="CodeAnnotation" aria-label="annotation3">3</span>. Horizontal
        alignment can be <code>LEFT</code>, <code>CENTER</code>, or <code>RIGHT</code> with respect
        to the x- and y-coordinates specified in the <code>text()</code> function call; the default
        is <code>LEFT</code>. Vertical alignment can be <code>TOP</code>, <code>CENTER</code>,
          <code>BOTTOM</code>, or <code>BASELINE</code> with respect to the x- and y-coordinates
        specified in the <code>text()</code> function call; the default is <code>BASELINE</code>.
          <code>BOTTOM</code> is the line that defines the lowest <em>y</em> value for any
        character, such as the bottom of a descender. <code>BASELINE</code> defines the lowest point
        of a typical character with no descender. So, the call</p>
      <pre><code>textAlign (CENTER, BOTTOM);</code></pre>
      <p class="BodyContinued">will center the current text from left to right (the specified
          <em>x</em> value is the center of the string) and aligned so that the specified <em>y</em>
        value is the bottom of the string.</p>
      <p>Example A illustrates how to display text in two different sizes. Example B shows a line
        drawn horizontally on each x-coordinate and vertically down each y-coordinate specified in
        the <code>text()</code> call. It shows the alignment of the text with respect to the
        specified coordinates.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="note">
          <h2><span class="NoteHead">NOTE</span></h2>
          <p> The names <code>CENTER</code>, <code>LEFT</code>, <code>RIGHT</code>, and so on are
            just constants declared by the Processing system. Their specific values are not
            important, but the system must know what that value is so that the system can make the
            proper alignments.</p>
          <div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <p class="BoxCodeLabel">Example A</p>
          <pre><code>void setup ()
{
  size (400, 300);
  fill (255, 0, 0);
}

void draw ()
{
  background(200);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> textSize(12);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> text ("12 pixel text starts at (100, 50).", 100, 50);
  textSize (20);
  text ("20 pixel text starts at (50, 100).", 50, 100);
}</code></pre>
          <span epub:type="pagebreak" title="23" id="Page_23"/><figure class="graphic"><img src="Images/g11001a.png" alt="g11001a" width="316" height="240"/></figure>
          <p class="BoxCodeLabel">Example B</p>
          <pre><code>void setup ()
{
  size (300, 200);
  fill (255, 0, 0);
}

void draw ()
{
  line (100, 0, 100, height);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> textAlign(LEFT); text ("LEFT", 100, 50);
  line (0, 50, width, 50);
  textAlign(CENTER); text ("CENTER", 100, 90);
  line (0, 90, width, 90);
  textAlign(RIGHT);  text ("RIGHT", 100, 130);
  line (0, 130, width, 130);
  textAlign (LEFT, BASELINE); text ("BASELINE", 200, 50);
  line (200, 0, 200, height);
  textAlign (LEFT, CENTER); text ("CENTER", 200, 90); 
  textAlign (LEFT, TOP); text ("TOP", 200, 130);
}</code></pre>
          <figure class="graphic"><img src="Images/g11001.png" alt="g11001" width="316" height="237"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
      <h2 id="h1-501645c01-0012" class="HeadProject"><span><span epub:type="pagebreak" title="24" id="Page_24"/>Sketch 12: Manipulating Text Strings</span></h2>
      <p class="BodyFirst">The previous sketch is really an introduction to character strings, which
        are a natural way for a human to communicate with a computer. A <span class="KeyTerm">string</span> is a sequence of characters; so is a word, a sentence, or a paragraph. At a
        high level, a string consists of a collection of characters in a specific order. There is a
        first character, a second, and so on until the final one is reached. The number of
        characters in this sequence is the <span class="KeyTerm">length</span> of the string.</p>
      <p><span class="KeyTerm">String constants</span> are character sequences enclosed in double
        quotes like this: <code>"To be or not to be"</code>. We can use string constants to declare
        variables that are <code>String</code>s and assign values to them. At <span class="CodeAnnotation" aria-label="annotation1">1</span>, for example, we declare two
        string variables and assign string constants to them:</p>
      <pre><code>String s1 = "To be or not to be"
String s2 = "that is the question."</code></pre>
      <p>Strings can be constructed by sticking other strings together. The <code>+</code> operator,
        when applied to strings, means <span class="KeyTerm">concatenate</span> or append, so the
        quote can be completed by concatenating these two strings:</p>
      <pre><code>s1 = s1 + s2;</code></pre>
      <p class="BodyContinued">This makes <code>s1</code> become <code>"To be or not to bethat is
          the question."</code> Unfortunately, this is not quite right, because we need a comma and
        a space between the two strings. This would be better:</p>
      <pre><code><span class="CodeAnnotationHang" aria-label="annotation2">2</span> s1 = s1 + ", " + s2;</code></pre>
      <p>The first character, “T”, in this new string has an <span class="KeyTerm">index</span> of
        0, meaning it is in the 0 position in the string. The character “o” is in position 1, and so
        on. </p>
      <p>A <span class="KeyTerm">substring</span> is a sequence of characters within the string
        specified by indices. The substring of <code>s1</code> from index 6 to 11 is the string
          <code>"or not"</code>, and it is found in Processing as follows:</p>
      <pre><code>s1.substring (6,12)</code></pre>
      <p>The length of this string is six characters, and that length is returned by the function
          <code>length()</code>:</p>
      <pre><code>s1.substring(6,12).length()</code></pre>
      <p>The character at a specific location can be found with the <code>charAt()</code> function.
        For example, <code>s1.charAt(3)</code> is “b” and<code> s1.charAt(18)</code> is “,”.</p>
      <p>Strings cannot be compared using the standard relational operators (because they are really
          <span class="KeyTerm">class instances</span>, which will be discussed later). Instead,
        there are functions for comparison. Comparing <code>s1</code> and <code>s2</code> could be
        accomplished like this:</p>
      <pre><code>if (s1.equals(s2)) ...;</code></pre>
      <p>This sketch shows some string operations and their results, drawn using the
          <code>text()</code> function discussed in Sketch 11. The sketch includes examples of
          <code>length()</code>
        <span class="CodeAnnotation" aria-label="annotation3">3</span>, <code>charAt()</code>
        <span class="CodeAnnotation" aria-label="annotation4">4</span>, and <code>substring()</code>
        <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>
      <aside epub:type="sidebar">
        <div class="top hr"><hr/></div>
        <section class="boxcustom1">
          <pre><code><span epub:type="pagebreak" title="25" id="Page_25"/><span class="CodeAnnotationHang" aria-label="annotation1">1</span> String s1 = "To be or not to be";
String s2 = "that is the question.";

void setup ()
{
  size (500, 400); fill(0);
  text ("s1 = '"+s1+"'", 10, 20);
  text ("s2 = '"+s2+"'", 10, 35);
  text ("s1+s2 is '"+s1+s2+"'", 160, 35);
  text ("s1+\", \"+s2 is '"+ s1+", "+s2+"'", 160, 50);
  text ("Let s1 = \"To be or not to be, that is the question.\"", 10, 75);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> s1 = s1 + ", " + s2;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> text ("Then s1.length() is "+s1.length(), 25, 90);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> text ("s1.charAt(0) is '"+s1.charAt(0)+"'", 160, 90);
  text ("s1.charAt(6) is '"+s1.charAt(6)+"'", 160, 105);
  text ("s1.charAt(13) is '"+s1.charAt(13)+"'", 160, 120);
  text ("s1.charAt(41) is '"+s1.charAt(40)+"'", 160, 135);
  text ("The length() function returns the number of characters in the string.", 10, 150);
  text ("The index of the final character is length()-1. It's an error to index past the end.", 10, 165);
  text ("Putting a \" into a string  is done by using a backslash: \\\" does it.", 10, 180);
  
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> text ("s1.substring (0, 10) is \""+s1.substring(0,10)+"\"", 15, 200);
  text ("s1.substring (10, 20) is \""+s1.substring(10,20)+"\"", 15, 215);
  text ("s1.substring (12) is \""+s1.substring(12)+"\"", 15, 230); 
  text ("s1.substring (20, s1.length()-1) is \""+s1.substring(20,s1.length()-1)+"\"", 15, 245); 
  noLoop();
}
void draw () {    }</code></pre>
          <figure class="graphic"><img src="Images/g12001-r.png" alt="g12001-r" width="694" height="555"/></figure><div class="bottom hr"><hr/></div>
        </section>
      </aside>
    </section>
  </div></body></html>