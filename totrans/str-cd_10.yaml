- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE ABCS OF ABCS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'ABC (*[https://esolangs.org/wiki/ABC](https://esolangs.org/wiki/ABC)*) was
    created by a programmer known as “Orange,” an esolang fan with several entries
    in the esolangs wiki. Some are jokes, others more serious, and then there’s ABC.
    I selected ABC because of its simplicity. Think of it as a starting point: something
    that is, but begs to be more. This chapter takes ABC from its unadorned description
    to a vanilla Python implementation, ultimately evolving it into something more
    via extensions to the language. This will be a warm-up for the esolangs that follow.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we’ll present and implement ABC as originally described. Then,
    we’ll morph ABC into the cleverly named ABC2\. We follow ABC2 and its implementation
    with some examples that help us think in this new language. As always, we’ll end
    with a discussion of the languages.
  prefs: []
  type: TYPE_NORMAL
- en: '**ABC**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start slowly. In this section, we’ll discuss what the ABC language entails,
    then we’ll implement it in Python. It won’t take much. After that, we’ll test
    the implementation with some existing ABC examples.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The esolang wiki description of ABC is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is; there isn’t any more. However, that’s all we need. The
    description tells us ABC uses an accumulator that can be incremented by one, decremented
    by one, or inverted (negated).
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t much here, but that’s the charm of it—what can we do with something
    so simple?
  prefs: []
  type: TYPE_NORMAL
- en: '***An ABC Implementation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Implementing ABC shouldn’t take too much effort on our part. The esolang wiki
    has an implementation in Java, but we’ll use Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-1](ch07.xhtml#ch07list1) is the complete source code to our ABC
    implementation (see *ABC.py*).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: A Python implementation of ABC*'
  prefs: []
  type: TYPE_NORMAL
- en: Python isn’t normally written so compactly, but we’re implementing a tiny language,
    so a tiny implementation seems appropriate. We’ll admit one slight deviation from
    the language description. The `r` command should set the accumulator (`A`) to
    a random value in [0, *A*]. Instead, our implementation uses [0, *A*), which is
    closer to how pseudorandom generators are typically used—the upper limit is not
    usually included in the range. The effect on example code is minimal.
  prefs: []
  type: TYPE_NORMAL
- en: ABC reads a source code file from the command line ➊, keeping only characters
    representing ABC commands ➋. This means text that isn’t a valid ABC command is
    fair game for comments. Channeling our inner COBOL, we adopt the convention of
    using uppercase letters with minimal punctuation for comments.
  prefs: []
  type: TYPE_NORMAL
- en: We store the program in the variable `prog`. Program state is set to the defaults
    of number output (`mode==False`), accumulator of zero (`A=0`), and program counter
    zero (`k=0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main body of ABC now runs: a `while` loop with a nested `if` asking whether
    the current instruction (`t`) matches a command or not ➌. The program ends when
    all commands have been executed. By design, the `l` command causes an infinite
    loop, as there is no exit command.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing ABC***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The esolang wiki page for ABC includes several example programs. Let’s use
    them to test the implementation. The simplest one counts forever: `acl`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With comments, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Other examples include *1337.abc*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: which prints `1337` (leetspeak). The program increments `A` to print `1`, then
    two more times to print `3` twice, and finally four more times to print `7`. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: We also have *dice.abc*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: which rolls a standard die. The program increments until *A* = 6, then replaces
    it with a random integer in [0, 6). A final increment sets *A* ∈ [1, 7) before
    printing it. Note that *dice.abc* has an extra `a` before the `r` to accommodate
    our change in how `r` works.
  prefs: []
  type: TYPE_NORMAL
- en: The examples also include *hello.abc*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: which prints “Hello, world!” by setting ASCII output mode, then incrementing,
    decrementing, and starting from 0 to get the accumulator to hold the necessary
    ASCII codes for each letter. Note that the accumulator isn’t reset for each character,
    but rather uses an offset from the last character’s code. It’s as easy as ABC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final example program, *phone.abc*, prints a randomly generated US-style
    telephone number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The clever trick in this program is to add `d` to make the accumulator negative
    before printing it, thereby adding the dash between the parts of the number: `1-883-386-3219`.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, ABC and its examples are finished. As mentioned, ABC begs to be more.
    Spend a lot of time with esolangs and you’ll eventually get the itch to work on
    your own, and see how to take what exists and modify and enhance it. If you have
    that itch, scratch it; creativity is asking you to dance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have some fun rebuilding ABC. We’ll maintain compatibility with what it
    is now, but we can add more.
  prefs: []
  type: TYPE_NORMAL
- en: '**ABC2**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After much deliberation and several focus groups, the name we’ve selected for
    ABC’s successor is ABC2\. There is precedent: Modula became Modula-2 (and Modula-3),
    Oberon became Oberon-2, and so on. What should be done to ABC to make it ABC2?
    Existing ABC programs should run without modification, meaning that ABC2 is backward
    compatible. Of course, most anything could be done, but in the next section, we’ll
    describe what we did and then follow with the updated Python implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Extensions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Extending ABC is fun. Here’s what turned ABC into ABC2:'
  prefs: []
  type: TYPE_NORMAL
- en: An interactive mode if no program is supplied at the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second accumulator, `B`, and a command to toggle between `A` and `B` ( `^`
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stack with arithmetic commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A command to exchange the top stack value and the active accumulator (`x`) as
    well as push (`!`) and pop (`@`) the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A primitive conditional command (`?`) with `<`, `>`, and `=` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A command to halt a program (`q`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A command to get a character from the user (`k`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A branch command (`g`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A command to toggle adding newline to output (`e`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll discuss these changes and their effect on what ABC was and became in the
    final section of this chapter. For now, let’s turn our attention to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '***An ABC2 Implementation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ABC2 is in the file *ABC2.py*. It isn’t as compact as *ABC.py*, but follows
    standard Python conventions. The structure of the interpreter remains the same:
    process each character in `prog` as a command until all have been processed. Some
    modification is necessary to allow a purely interactive mode. We’ll present the
    code in pieces, starting with [Listing 7-2](ch07.xhtml#ch07list2), which shows
    the code to parse the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Parsing program text in ABC2*'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` loads and parses a program, keeping only actual command characters,
    or sets the `interactive` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the default state and the modified main loop ([Listing 7-3](ch07.xhtml#ch07list3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: The ABC2 state and main loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The single accumulator is now a pair of accumulators, both initially zero (`A`).
    The value of `I` toggles between them. Output defaults to numbers (`mode=0`) and
    no newline (`cr=0`). The `stack` is a standard Python list. We’ll use the seldom
    seen `pop` method. All stack operations are in `ops`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, two loops begin. The outer `while` loop runs forever. If interactive,
    `prog` is set to whatever sequence of commands the user enters. Note that the
    state is not reset, so whatever state is active when the entered commands are
    complete is still present for the next set. The second `while` loop is the same
    as in ABC proper: get the character of the command and evaluate it. When the program
    ends, if not in interactive mode, exit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the actual implementation, the second `while` loop contains a rather lengthy
    compound `if` statement to execute the command ([Listing 7-4](ch07.xhtml#ch07list4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: Executing ABC2 commands*'
  prefs: []
  type: TYPE_NORMAL
- en: A conceptually more elegant implementation would make ABC2 a class and use a
    dictionary of methods associated with each command in a small loop. Readers are
    invited to build such an implementation and share it. However, for pedagogical
    purposes, building on the existing ABC `if` statement approach seems easier to
    follow, even if it’s less creative.
  prefs: []
  type: TYPE_NORMAL
- en: ABC2 is backward compatible with ABC, so we’ll only describe the extensions.
    All previous commands operate as before, with `A` replaced by `A[I]` to use the
    active accumulator. Most of the extended commands require no more than one or
    two lines of code (see [Table 7-1](ch07.xhtml#ch07tab1)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Python Code for the Extended ABC2 Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Implementation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | `I ^= 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `k` | `A[I] = ord(getch())` |'
  prefs: []
  type: TYPE_TB
- en: '| `q` | `quit()` |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | `cr ^= 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | `stack.append(A[I])` |'
  prefs: []
  type: TYPE_TB
- en: '| `@` | `A[I].stack.pop()` |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | `k = k + stack.pop() - 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | `if (not stack.pop()):` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `   k += 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | `v = stack.pop()` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `stack.append(A[I])` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `A[I] = v` |'
  prefs: []
  type: TYPE_TB
- en: '| *stack ops* | `if (t == "="):` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `    t = "=="` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `v=eval("%d %s %d" % (stack[-2],t,stack[-1]))` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `if (type(v) is bool):` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `    v = 1 if (v) else 0` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `stack.pop(); stack.pop()` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `stack.append(int(v))` |'
  prefs: []
  type: TYPE_TB
- en: There is no need to walk through each of the little code snippets in [Table
    7-1](ch07.xhtml#ch07tab1), as most are self-explanatory. Note that sanity checks
    for things like popping the stack are not in [Table 7-1](ch07.xhtml#ch07tab1);
    however, they are in *ABC2.py*, so please read through the full source code.
  prefs: []
  type: TYPE_NORMAL
- en: There is one piece of code in [Table 7-1](ch07.xhtml#ch07tab1) we should discuss.
    The `k` command calls a function, `getch`, which returns a keypress without waiting
    for the user to press ENTER. This is not a standard Python function. The top portion
    of *ABC2.py* implements `getch` for Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `$` and `^` commands make use of an operator that might be unfamiliar
    to some: `^` (exclusive-OR or XOR). Exclusive-OR is a logical operation with the
    truth table'
  prefs: []
  type: TYPE_NORMAL
- en: '| `A` | `B` | `A^B` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: which states that the output of XOR is 1 when either of the inputs, but not
    both, is 1\. This behavior makes toggling straightforward because `0^1 = 1` and
    `1^1 = 0`, meaning XORing a 0 or 1 with 1 results in 1 or 0, thereby flipping
    its state. As with other Python operators, `I ^= 1` is shorthand for `I = I^1`.
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation is complete. Now, let’s see what ABC2 can do.
  prefs: []
  type: TYPE_NORMAL
- en: '**ABC2 in Action**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After surviving Forth, ABC2 will seem straightforward. Let’s begin with the
    simplest of examples: adding two numbers. This is something ABC cannot do easily:
    you have to count up to the first value with `a`s and then use more `a`s to add
    a positive number before printing the result. ABC2 makes this a little easier.
    Consider *add.abc2*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The comments clarify the actions, but the gist is to set newline mode to print
    one number per line of output, count up to 10, and push the accumulator on the
    stack. As the accumulator is already at 10, and pushing to the stack does not
    alter it, we count down to 7 and push that to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The last line calls `+` to put 10 + 7 = 17 on the stack before popping it off
    the stack to the accumulator to print with `c`. Note that only values in the accumulators,
    `A` and `B`, can be printed. There is no “print the top stack" item as in Forth.
    To run *add.abc2*, use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Well, that was easy enough. Let’s try something similar using interactive mode.
    Launch ABC2 (python3 ABC2.py), but don’t supply a filename. Then, enter the sequence
    of statements in [Listing 7-5](ch07.xhtml#ch07list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: An interactive ABC2 session*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](ch07.xhtml#ch07list5) might look like random noise at first,
    but there’s a method to the madness. Let’s walk through it. ABC2’s interactive
    prompt is a colon (`:`). The first line shows five `a`s followed by a semicolon
    (`;`). We know `a`; it adds 1 to the accumulator, so the accumulator now holds
    the number 5\. The `;` is the “debug” command from ABC. That’s what produces the
    second line, `{5:0: (5,`''''`)(0,`''''`)}`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are four parts to the debug line. The first part shows the current program
    counter, which is the instruction number followed by a colon and a 0 or 1\. In
    this case, the program counter is 5, as the `;` is the sixth instruction entered
    (always count from 0). The next bit, `0:`, tells us A is the current accumulator,
    `A[0]` in *ABC2.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Next come two sets of parentheses. These are the current numeric value and value
    as a character for the two accumulators, A and B. In this case, A is 5, and B
    is its default of 0\. Characters are shown if the accumulator is in [32,127],
    which excludes 5 and 0, so no characters are shown.
  prefs: []
  type: TYPE_NORMAL
- en: After the closing brace comes the stack. The number of items on the stack comes
    first. In this case it’s `<0>`, as the stack is empty. Any items on the stack
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of commands entered, `!;`, store A on the stack and print the
    debug information again. This time we see `<1>: 5` telling us that there is one
    item on the stack, a 5.'
  prefs: []
  type: TYPE_NORMAL
- en: The following commands push A on the stack a second time, call debug, multiply
    the top two stack items, and call debug again, leaving 25 on the stack. Lastly,
    `@ec;` pops the stack, sets A to 25, moves to newline mode, and prints `A`. The
    `q` command exits ABC2\. If you venture to try your hand at ABC2 code, and I strongly
    suggest you do, you’ll find the interactive mode useful during program development.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through three more ABC2 examples. Each example explores an additional
    capability of ABC2, culminating in a final program that serves as a tribute to
    an underappreciated early computing pioneer.
  prefs: []
  type: TYPE_NORMAL
- en: '***HELLO WORLD!***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Hello World Collection website lists versions of “Hello, world!” in more
    than 600 different programming languages (*[http://helloworldcollection.de/](http://helloworldcollection.de/)*).
    It’s become almost a moral obligation for every language capable of printing “Hello,
    world!” to do so at some point. Therefore, we’ll be good citizens and do our duty.
  prefs: []
  type: TYPE_NORMAL
- en: The file *hello.abc2* contains the obligatory, and slightly grammatically incorrect,
    ABC2 version of “Hello, world!” Running *hello.abc2* produces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The ABC version incremented and decremented the accumulator to arrive at the
    necessary ASCII code for each character. ABC2 has a stack, which, as we learned
    in [Chapter 4](ch04.xhtml#ch04), is a LIFO data structure; the last thing in is
    the first thing out. Let’s use the stack to store the characters we want to output,
    pushing them in reverse order so they print correctly when popped off the stack.
    Moreover, the stack supports arithmetic, so we don’t need to count up to the values
    we want. We can take shortcuts to reach the necessary ASCII codes more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-6](ch07.xhtml#ch07list6) gives us the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: “Hello, world!” in ABC2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line is, of course, the comment. Let’s parse the first line after
    the comment `aaa!aaaaaaaa!*@!!!+@aa!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each line shows the ABC2 commands on the left and the state of the stack afterward.
    Look at the last line. The stack contains 33 and 68, the ASCII codes for `!` and
    `D`, respectively, which are the final two characters to output. The program builds
    the output string on the stack in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder over `HELLO WORLD!` is similarly placed on the stack. When the
    second to last line of [Listing 7-6](ch07.xhtml#ch07list6) is complete, the stack
    contains
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: which the final line of [Listing 7-6](ch07.xhtml#ch07list6) outputs by enabling
    character mode (`$`) and repeatedly popping the stack and printing (`@c`). Before
    the final character is output, `e` turns on newline mode.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s do some math with ABC2.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Slice of Pi***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’m writing this section on March 14th, which, using American-style dates, is
    3/14—Pi Day. Therefore, in honor of everyone’s favorite mathematical constant,
    our next example uses ABC2 to estimate the value of *π* = 3*.*14159*…* using nothing
    more than random integers.
  prefs: []
  type: TYPE_NORMAL
- en: The area of a circle is *A*[circle] = *πr*², where *r* is the radius, the distance
    from the center to the edge. If we set *r* = 1, the area of the resulting circle
    is *A*[circle] = *π*(1)² = *π*. A circle of radius 1 has a diameter of 2\. If
    this circle is centered at the origin, the diameter goes from *–*1 to +1\. Now
    imagine a square with a side length of 2 set over the circle. The square is *circumscribed*
    over the circle (see [Figure 7-1](ch07.xhtml#ch07fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: A square circumscribed over a circle of radius 1*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get to the dots in [Figure 7-1](ch07.xhtml#ch07fig1) momentarily. For
    now, just consider the relationship between the square and the circle. If the
    square’s side is 2, its area is *A*[square] = *s*² = (2)² = 4.
  prefs: []
  type: TYPE_NORMAL
- en: The ratio between the areas of the circle and the square is *A*[circle]/*A*[square]
    = *π*/4\. This ratio remains even if we only consider the first quadrant, that
    is, one quarter of the shapes (where the dots are in [Figure 7-1](ch07.xhtml#ch07fig1)).
    The area of the circle in quadrant one is one quarter of *π*, that is, *π*/4,
    and the area of the square in quadrant one is 4/4 = 1, meaning the ratio between
    the two is *π*/4/1 = *π*/4.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so what? Well, if we had an estimate of the area of the circle and the
    square in quadrant one, we’d be able to divide the two and expect that it matches
    *π*/4\. Here’s where the dots in [Figure 7-1](ch07.xhtml#ch07fig1) come into the
    picture. They represent random points in the range [0,1) in both *x* and *y*.
    What if we generate many of these random points? In a sense, the points will slowly
    fill in the area of both the circle and the square. If we count how many land
    within the circle and divide by those that land within the square, which is all
    of them because we are using [0, 1), we’ll have an estimate of the ratio between
    the circle and the square, which, as we just saw, is *π*/4\. Therefore, if multiplied
    by 4, this ratio should give us an estimate of *π*, which is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let’s select random values in the range [0,1) and start counting how
    many land within the circle. How do we know if the point is within the circle?
    That’s straightforward. It’s really an application of the Pythagorean theorem:
    *c*² = *a*² + *b*², where *a* is *x* and *b* is *y*. The circle is centered at
    the origin and has a radius of 1\. If *x*² + *y*²—the distance from the origin
    to the randomly selected point—is less than the radius squared, then the point
    is within the circle. For the circle, *r*² = 1, so the point is within the circle
    if its distance from the origin is less than 1.'
  prefs: []
  type: TYPE_NORMAL
- en: We need two counters. The first counts every randomly generated point because
    [0,1) covers the entire area of the square in quadrant one. This means that every
    point lands within the square so no test is needed. We’ll call this counter `S`.
    The second counter is for all the points that land within the circle, (*x*, *y*),
    where *x*² + *y*² < 1\. We’ll call this counter `C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the algorithm we want to code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On every pass through the loop, the code selects a new (*x*, *y*) point, increments
    `S`, and if the point is within the circle, increments `C`. The ratio, then, will
    approach *π*/4, which when multiplied by 4 is an estimate for *π*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you’ve likely already noticed the problem. ABC2 works with integers
    only. The algorithm expects floating-point numbers. Are we stymied? No, we’re
    not. We want a ratio of two areas, one for the circle and one for the square.
    We aren’t really restricted to the range [0,1). What if we use integers and select
    points in the range [0,1,000,000,000)? ABC2 has no difficulty working with integers
    in that range. If we scale the *x* and *y* by one billion, then the limit we check
    scales by the square of that. So instead of checking if *x*² + *y*² < 1, we check
    if *x*² + *y*² < 10^(18), one billion squared. Again, ABC2, thanks to our Python
    implementation, has no difficulty with an integer like 10^(18).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, our algorithm remains the same, and only the limits on the random
    numbers and the distance from the origin change. However, our output must change
    as well. We won’t calculate `4*C/S`, but instead display `C/S` *as a fraction*.
    That is, literally as `C` followed by a `/` and then `S`. At any point, we can
    take an output value, dump it in a calculator to get the actual floating-point
    ratio, and multiply by 4 to get the current estimate of *π*.
  prefs: []
  type: TYPE_NORMAL
- en: The code we need is in [Listing 7-7](ch07.xhtml#ch07list7) and *pi.abc2*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7: Estimating π with random numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use accumulator B to hold `S` and the stack to hold `C`. When the program
    starts, accumulators A and B are both zero. So we push A on the stack to initialize
    the counter.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use `r` to select a random integer in [0, 10⁹), so we need to make A one
    billion. That’s what the second line of [Listing 7-7](ch07.xhtml#ch07list7) does.
    First A is 10, then after squaring by pushing it on the stack twice, A is 100\.
    Then 100 × 100 = 10,000 and 10,000 × 10,000 = 100,000,000 on the stack. A final
    multiplication by 10 sets A to one billion. That was the painful part. Selecting
    a random value and squaring it is `r!!*` to select the value, push it on the stack
    twice, then multiply. The stack now contains `( C x*x -- )`. The next two lines
    of [Listing 7-7](ch07.xhtml#ch07list7) repeat the previous two to get *y*² on
    the stack so `+` can add them together.
  prefs: []
  type: TYPE_NORMAL
- en: The stack now contains `C` followed by the square of the distance of the random
    point, (*x*, *y*), from the origin. We must increment `C` if this distance is
    less than 10^(18), so we use an approach similar to setting A to one billion to
    get 10^(18) on the stack. The stack is now `(C x*x+y*y 10**18 -- )`.
  prefs: []
  type: TYPE_NORMAL
- en: The less-than command, `<`, performs the comparison and leaves 0 or 1 on the
    stack. This is particularly convenient. If the comparison is false, that is, the
    distance isn’t less than 10^(18), we get 0; otherwise, we get 1, so the stack
    is `( C 0|1 -- )`. Either way, adding this result to `C` works. If the comparison
    is true, the 1 is on the stack, which increments `C` for us. Otherwise, there’s
    no harm in adding 0 to `C`. Because of this happy arrangement, the only branching
    necessary is the loop at the end of the program to generate the next point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve incremented `C`, if necessary, but we still need to increment `S`. As
    it’s in accumulator B, incrementing is particularly easy: switch to accumulator
    B, increment with `a`, and then switch back to accumulator A with `^a^` .'
  prefs: []
  type: TYPE_NORMAL
- en: We’re ready to display our current estimate for *π*/4\. First, we print `C`
    and return it to the stack so it isn’t lost (`@!c`). Then, we set A to 47, the
    ASCII code for a slash, and display it with `$c$`. Lastly, we switch to accumulator
    B, toggle newline mode with `e`, and print `S`, remembering to turn off newline
    mode and toggle back to accumulator A.
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction is `!` to store A on the stack, meaning store `C`. Just
    before we loop, we pull `C` off the stack with `@` and then loop with `l`.
  prefs: []
  type: TYPE_NORMAL
- en: The program runs forever, generating ever better estimates of *π*/4\. Let’s
    see how well it does. For one run of the program, the first few iterations output
    are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: with the last iteration giving an estimate of *π* ≈ 4(19)/21 = 3*.*6190476\.
    Not too good, but the program’s just started. The output a second or two later
    was *π* ≈ 4(992)/1280 = 3*.*1, so it’s heading in the right direction. After about
    15 seconds, the estimate was *π* ≈ 4(44893)/57153 = 3*.*1419523, which is definitely
    in the ballpark.
  prefs: []
  type: TYPE_NORMAL
- en: How quickly does the output approach *π*? If we capture the program’s output
    and plot the estimate of *π* as a function of the iteration number, we arrive
    at [Figure 7-2](ch07.xhtml#ch07fig2), which shows the convergence as iterations
    proceed. After some 100,000 iterations, the estimate was 3.1416803, which is accurate
    to nearly four decimals.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: The estimate of *π* as a function of iteration number*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.xhtml#ch07fig2) shows that many iterations are necessary
    to get close to *π*—around 25,000 or so. This isn’t too surprising, as we’re trying
    to replace an actual area with a collection of random points. You might feel a
    little unsettled as a point has no area, so how can a collection of them have
    an area? I think of it this way: imagine that infinite space is actually discrete.
    In that sense, an area is a collection of (extremely) tiny cells (think pixels)
    where the random points fill in an ever-increasing set of cells. The difference
    here is that a cell *does* have an area, even if a tiny one, and all of the cells
    together tile the circle and square. From that point of view, we randomly fill
    cell after cell to arrive at a better and better estimate of the actual circle
    and square areas. We would expect over time to get a better and better estimate
    of *π*/4, and ultimately *π*.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this little Pi Day example. It’s nice that ABC2, for all
    its simplicity, can do something like this and that the logical operators for
    ABC2 happened to give exactly the right value in the right place (that is, on
    the stack above `C`) so no painful looping construct was necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s develop our version of an early computing machine, and learn a bit
    about its remarkable, though largely unknown, inventor.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Electromechanical Arithmometer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve likely never heard of Leonardo Torres y Quevedo (sometimes written as
    Leonardo Torres Quevedo). Before I started writing my first book, I had never
    heard of him, either. If you have heard of him, fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: Torres Quevedo was a Spanish inventor born in the mid-19th century. His many
    accomplishments include cable cars, dirigibles, an early form of remote control,
    a working chess-playing automaton, and, of most interest to us, the electromechanical
    arithmometer. An arithmometer is a 19th-century mechanical calculator. Torres
    Quevedo’s version, presented in Paris in 1920 (see [Figure 7-3](ch07.xhtml#ch07fig3)),
    was electronic and mechanical.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: The electromechanical arithmometer circa 1920\. Image used with
    the kind permission of Francisco A. González Redondo, Universidad Complutense,
    Madrid.*'
  prefs: []
  type: TYPE_NORMAL
- en: On the right of [Figure 7-3](ch07.xhtml#ch07fig3) is a typewriter. This was
    the keyboard used by the operator. The operator put paper in the typewriter and
    proceeded to type an expression such as `123 × 321 =` to which the machine would
    respond by typing `39483` on the same line before advancing the paper to the next
    line. Recall that this was 1920, well before the first true electronic computers
    and before the pioneering work of Konrad Zuse. Torres Quevedo showed the electromechanical
    arithmometer and then put it aside. It was never marketed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll get back to [Figure 7-3](ch07.xhtml#ch07fig3) in a little bit, but, as
    this is a book on programming languages, it seems fitting to point out that not
    only did Torres Quevedo build such an impressive machine, he also, even earlier,
    worked through what it means to implement floating-point arithmetic in a machine-friendly
    way. In his 1914 work “Essays on Automatics,” he writes that numbers should be
    stored as *n* × 10^(*m*), which is how we store floating-point numbers now: *n*
    × 2^(*m*). A problem with floating-point is that numbers in scientific notation
    are not unique: 3*.*1415 × 10⁰ = 0*.*31415 × 10¹ = 31*.*415 × 10^(*–*1). Torres
    Quevedo understood this, so he proposed the following rules to store numbers in
    a consistent way for a machine to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n* will always be the same number of digits (six, for example).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first digit of *n* will be in the order of tenths, the second in hundredths,
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One will write each quantity in the form: *n;m*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modern computers store floating-point numbers with a fixed size *n*; for example,
    52 bits for a C `double` (really 53 bits; a leading 1 is implied as the integer
    part of the significand, 1*.b*[51] *b*[50]*…**b*[0]). It’s clear that Torres Quevedo
    was thinking in base-10, but the idea of fixing the significand size was key.
    Zuse, mentioned above, was likely the first to implement floating-point numbers
    in computers in base-2, much as we do now—see the IEEE 754 standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last observation on Torres Quevedo’s floating-point format before we get
    back to the electromechanical arithmometer. Notice that he suggests, again in
    1914, that floating-point numbers be written as *n;m*. So using his rules, he
    would write *π* as 0.314159;1, meaning 0*.*314159 × 10¹ = 3*.*14159\. This is
    very close to how floating-point numbers are entered today: 0.314159e1\. The only
    difference is using a semicolon (;) for *e*.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this is all very interesting, but what does it have to do with ABC2? One
    feature of ABC2 we have yet to explore is the `k` command, the command that reads
    a character from the keyboard and places its character code in the current accumulator.
    Let’s use this command to mimic Torres Quevedo’s arithmometer. We’ll restrict
    ourselves to multiplication only.
  prefs: []
  type: TYPE_NORMAL
- en: The code we’ll work with is in *multiply.abc2*. This is the most complex ABC2
    program we’ll consider. Not only does it use `k` for input, it also uses `?`,
    the only conditional command available in ABC2.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with an outline of what we want to accomplish. Leonardo’s arithmometer
    let the user type a number, an operation, and a second number. We’re fixing the
    operation, multiplication, so what we need from the user are two numbers—specifically,
    two three-digit numbers—though the leading digits might be zero. The `k` instruction
    gets one character from the keyboard, so how will we turn characters into numbers?
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that the ASCII code for zero is 48\. The ASCII
    codes for the digits follow in order, meaning that 49 is one, 50 is two, and so
    on. Therefore, if the user presses 3, the accumulator will contain 51\. Subtracting
    48 from 51 leaves 3\. To convert the ASCII code for a digit into the digit itself
    we would subtract 48\. We now know how to get single digits. But what about a
    three-digit number?
  prefs: []
  type: TYPE_NORMAL
- en: We have a three-digit number, 451\. In grade school, you likely learned how
    to write numbers in expanded form as
  prefs: []
  type: TYPE_NORMAL
- en: 451 = 400 + 50 + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'but there’s another way to expand a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 451 | = (((4 × 10) + 5) × 10) + 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = ((40 + 5) × 10) + 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = (45 × 10) + 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = 450 + 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = 451 |'
  prefs: []
  type: TYPE_TB
- en: 'Expanding a number this way points us toward an algorithm for entering three
    digits and converting them to a three-digit number:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the first digit, multiply by 10, and store it on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the second digit and add it to the number on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the number on the stack by 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the third digit and add it to the number on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When these steps are complete, the stack contains the three-digit number the
    user entered character by character. Let’s follow the steps and see if they work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The steps work. The user entered 4, 5, and 1, and the stack holds the number
    451\. When implemented in ABC2, there is one additional step: after the user enters
    the digit, we must subtract 48 to convert the character code to the digit value.'
  prefs: []
  type: TYPE_NORMAL
- en: We know how to get a number from the user. To implement the “arithmometer,”
    we must get two numbers from the user, each on the stack, and multiply.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-8](ch07.xhtml#ch07list8) shows all of *multiply.abc2*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-8: Multiplying pairs of numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line has the comment `B IS 48`. This line switches to accumulator
    B ( `^` ) and makes sure it is 0, which is necessary because we loop. It then
    increments to 5, pushes it on the stack, and increments five more times to push
    10 on the stack. Multiplying leaves 50 on the stack, which is popped off the stack
    to accumulator B (`@`) and finally decremented twice to leave B equal to 48\.
    This is the constant we need to subtract from the digit ASCII codes the user will
    enter. For this program, we use B as a constant. When needed, we switch to accumulator
    B, push its value on the stack, and then immediately switch back to accumulator
    A.
  prefs: []
  type: TYPE_NORMAL
- en: The next line is `FIRST KEYPRESS`, `^ k!!`. The `^` statement toggles back to
    accumulator A. We read a character from the keyboard (`k`) and push it on the
    stack twice with `!!`. We push it twice because program will loop to ask the user
    for pairs of numbers repeatedly. For the first digit, if the user presses ESC
    (ASCII 27), we want to exit the program instead. We push the first digit twice,
    once to use in calculating the number as we did above, and a second time to compare
    the key to ESC.
  prefs: []
  type: TYPE_NORMAL
- en: The `QUIT IF ESC PRESSED` line checks if the top stack value is 27\. First,
    we set A to 27 with `naaa!aaaaaa!*`. We increment A to 3 and push it onto the
    stack, and then increment six more times to 9 and push it onto the stack and multiply
    the two numbers to leave 27 on the stack with the ASCII code of the character
    the user entered immediately below it. Executing `=` checks if the top two stack
    items are equal. While `?` pops the stack, if the top stack value is true (not
    0), the program executes the command immediately after `?`. Otherwise, it skips
    the next command and execution continues with the following command. In this case,
    the next command is `q`, quit, so if the key the user pressed was ESC, the `=`
    left true on the stack for `?` to pick up and, because it’s true, execute `q`
    to end the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve checked whether the first key is ESC, but we have not yet displayed the
    key nor subtracted 48 to get its digit value. It’s currently on the stack, so
    we load it back into accumulator A with `@!`: `@` to pull it from the stack into
    accumulator A and `!` to push it back to the stack because we need it there as
    well. Next, `$c$` prints the character by switching to character mode, printing
    with `c`, and switching back to number mode.'
  prefs: []
  type: TYPE_NORMAL
- en: To subtract 48, we use `^ ! ^ -`. This pattern repeats throughout the program
    every time we need to subtract 48\. It switches to accumulator B, pushes B on
    the stack, switches back to accumulator A, and subtracts. The stack now contains
    the digit value, which must be multiplied by 10 via `naa!aaa!**`, which puts 2
    and then 5 on the stack, multiplies them to get 10, and finally multiplies the
    digit value by 10\. This pattern also repeats whenever a digit value must be multiplied
    by 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first digit is a special case because we need to check for ESC. The remaining
    five digits are essentially the same: `k$c$!^!^-+` to get the digit, display it,
    push it, push 48, subtract, and then add the digit value to the value already
    on the stack. If necessary, this pattern is followed by the multiply-by-10 pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The other lines in [Listing 7-8](ch07.xhtml#ch07list8) handle necessary text
    output. The final line is `*@ecel`. The stack now contains the two numbers the
    user entered, so `*` multiplies them and `@` pulls the result into accumulator
    A for display with `ec`, where `e` turns on newline mode. To go back and get another
    pair of numbers, we first turn off newline mode and then loop `l`.
  prefs: []
  type: TYPE_NORMAL
- en: The description above is necessarily dense. Do review the code to see what it
    does and try some of the patterns in interactive mode as well. Let’s see what
    the output of *multiply.abc2* looks like; however, naturally, in print you won’t
    see the flow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although not as impressive as Torres Quevedo’s electromechanical arithmometer,
    we might argue there’s at least some utility to a little program like this. As
    an exercise, extend *multiply.abc2* to accept four-digit numbers. Note that there
    is no check to ensure that the key pressed is actually a valid digit. The program
    is happy with any keypress; however, the results will not be meaningful in that
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s bid Torres Quevedo a fond farewell and conclude our ABC2 adventure with
    a short discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began with the esolang wiki description of ABC and our Python implementation.
    It is abundantly clear that as a programming language, ABC isn’t even remotely
    Turing complete. Nor was it meant to be; it was just a cute idea for something
    capable of simple tasks. We then extended ABC to create ABC2\. Is ABC2 Turing
    complete? No, it isn’t. There are only two memory locations and a stack that cannot
    be accessed cell-by-cell like an array.
  prefs: []
  type: TYPE_NORMAL
- en: What might make ABC2 Turing complete? One might imagine ABC3, with the stack
    and, instead of two accumulators, an “infinite” set of accumulators accessible
    by index. In other words, an array. That scenario would use the stack much like
    the arithmetic logic unit of a CPU and the accumulators as memory. I suspect such
    a language might be Turing complete. I might make it as it wouldn’t be difficult.
    Better still, you make it, and if you feel like sharing, send it to me and I’ll
    put it on the book’s GitHub site.
  prefs: []
  type: TYPE_NORMAL
- en: ABC2’s stack is limited because there are no intrinsic commands to manipulate
    it like DUP, SWAP, ROT, and OVER in Forth. Or is that really the case?
  prefs: []
  type: TYPE_NORMAL
- en: ABC2 does not have stack manipulation commands, but we can create patterns that
    function like stack words, provided we don’t need to preserve the contents of
    the accumulators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, these ABC2 patterns act like the given Forth word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run ABC2 in interactive mode and give them a try. Use `;` to show the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The ABC2 examples in this chapter showed repeating patterns of code. This happens
    in all languages—think of the design patterns often used in software development.
    The *multiply.abc2* example, in particular, used several repeating patterns of
    code to push a constant on the stack, get a digit from the user, and multiply
    by 10\. As each command in ABC2 is itself a single character, the patterns become
    words. Space is not an ABC2 command, meaning we could write code with the patterns
    as words, words that, with time, “experienced” ABC2 coders (keep your eye on the
    Help Wanted ads) would learn to recognize.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one pattern in *multiply.abc2* is `k$c$!^!^-+`, which gets a character
    and adds its digit value to the number already on the stack. This pattern (a sentence?)
    could be written as `k $c$ ! ^!^ - +` to separate the commands into words with
    meaning. Another pattern stored a constant in accumulator B. In one instance,
    the constant was *–*7 to use with `g` for branching in a loop. The other was 48,
    which is the number we needed to subtract from the ASCII character code for a
    digit. Using accumulator B as a constant argues in favor of a language like ABC3,
    where we’d have as many variables as we need.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, ABC and ABC2 are toy languages, as esolangs often are. They are
    fun to think about, fun to implement, and fun to experiment with. They also help
    us appreciate the careful thought that went into designing the programming languages
    we use daily.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced an exceedingly simple esolang called ABC. We took its
    language description, all that implementors generally have to work with, and built
    a Python implementation. We quickly understood the language’s limitations and
    extended it to make ABC2, a language with more capabilities that maintained backward
    compatibility with the original ABC.
  prefs: []
  type: TYPE_NORMAL
- en: We developed a few examples in ABC2 and had some fun with them. We learned how
    to estimate the value of *π* by using random numbers. We then paid tribute to
    an early computer pioneer, Leonardo Torres y Quevedo, with a program mimicking
    his electromechanical arithmometer from 1920\. During that exercise, we learned
    that ABC2 lends itself to coding patterns we might call words (with apologies
    to Forth), and that ABC2 programs could be written as a series of words, that
    is, sentences.
  prefs: []
  type: TYPE_NORMAL
- en: ABC and ABC2 were perfect introductions to our esolang exploration. Let’s move
    on now to FRACTRAN, perhaps the most intellectually interesting esolang we’ll
    encounter.
  prefs: []
  type: TYPE_NORMAL
