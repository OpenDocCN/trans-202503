- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: THE ABCS OF ABCS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ABC 的基础
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common01.jpg)'
- en: 'ABC (*[https://esolangs.org/wiki/ABC](https://esolangs.org/wiki/ABC)*) was
    created by a programmer known as “Orange,” an esolang fan with several entries
    in the esolangs wiki. Some are jokes, others more serious, and then there’s ABC.
    I selected ABC because of its simplicity. Think of it as a starting point: something
    that is, but begs to be more. This chapter takes ABC from its unadorned description
    to a vanilla Python implementation, ultimately evolving it into something more
    via extensions to the language. This will be a warm-up for the esolangs that follow.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ABC (*[https://esolangs.org/wiki/ABC](https://esolangs.org/wiki/ABC)*) 是由一位名为“Orange”的程序员创建的，他是一个
    esolang 爱好者，在 esolangs 维基中有几个条目。有些是玩笑，有些则较为严肃，而 ABC 则介于两者之间。我选择 ABC 是因为它的简洁。可以把它当作一个起点：它是存在的，但又渴望更多。本章将
    ABC 从简洁的描述扩展到一个基础的 Python 实现，最终通过对语言的扩展使其变得更丰富。这将为接下来的 esolangs 做一个热身。
- en: Specifically, we’ll present and implement ABC as originally described. Then,
    we’ll morph ABC into the cleverly named ABC2\. We follow ABC2 and its implementation
    with some examples that help us think in this new language. As always, we’ll end
    with a discussion of the languages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将按照最初的描述呈现并实现 ABC。接着，我们将把 ABC 转变为巧妙命名的 ABC2。我们会通过一些示例来帮助我们用这种新语言思考，之后继续探讨
    ABC2 及其实现。最后，像往常一样，我们将结束对这些语言的讨论。
- en: '**ABC**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ABC**'
- en: Let’s start slowly. In this section, we’ll discuss what the ABC language entails,
    then we’ll implement it in Python. It won’t take much. After that, we’ll test
    the implementation with some existing ABC examples.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从慢慢来开始。在这一部分，我们将讨论 ABC 语言的内容，然后用 Python 实现它。这不会花太多时间。之后，我们将通过一些现有的 ABC 示例来测试实现。
- en: '***The Language***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***语言***'
- en: The esolang wiki description of ABC is
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ABC 在 esolang 维基中的描述是
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s all there is; there isn’t any more. However, that’s all we need. The
    description tells us ABC uses an accumulator that can be incremented by one, decremented
    by one, or inverted (negated).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么多了；没有更多内容。然而，这正是我们所需要的。描述中告诉我们，ABC 使用一个累加器，可以加一、减一或取反（取负）。
- en: There isn’t much here, but that’s the charm of it—what can we do with something
    so simple?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的内容不多，但这正是它的魅力所在——我们能用这么简单的东西做什么呢？
- en: '***An ABC Implementation***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ABC 实现***'
- en: Implementing ABC shouldn’t take too much effort on our part. The esolang wiki
    has an implementation in Java, but we’ll use Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 ABC 不需要我们付出太多努力。esolang 维基中有一个 Java 实现，但我们将使用 Python。
- en: '[Listing 7-1](ch07.xhtml#ch07list1) is the complete source code to our ABC
    implementation (see *ABC.py*).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-1](ch07.xhtml#ch07list1) 是我们 ABC 实现的完整源代码（参见 *ABC.py*）。'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-1: A Python implementation of ABC*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：ABC 的 Python 实现*'
- en: Python isn’t normally written so compactly, but we’re implementing a tiny language,
    so a tiny implementation seems appropriate. We’ll admit one slight deviation from
    the language description. The `r` command should set the accumulator (`A`) to
    a random value in [0, *A*]. Instead, our implementation uses [0, *A*), which is
    closer to how pseudorandom generators are typically used—the upper limit is not
    usually included in the range. The effect on example code is minimal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常不会写得这么紧凑，但我们正在实现一个小型语言，所以小巧的实现似乎是合适的。我们承认有一个小小的偏差。`r` 命令应该将累加器（`A`）设置为
    [0, *A*] 范围内的随机值。相反，我们的实现使用了 [0, *A*)，这更接近伪随机生成器的常见用法——上限通常不包括在范围内。这个差异对示例代码的影响很小。
- en: ABC reads a source code file from the command line ➊, keeping only characters
    representing ABC commands ➋. This means text that isn’t a valid ABC command is
    fair game for comments. Channeling our inner COBOL, we adopt the convention of
    using uppercase letters with minimal punctuation for comments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ABC 从命令行读取源代码文件 ➊，仅保留表示 ABC 命令的字符 ➋。这意味着不是有效 ABC 命令的文本可以作为注释使用。我们借鉴 COBOL，采用使用大写字母并尽量减少标点符号的方式来表示注释。
- en: We store the program in the variable `prog`. Program state is set to the defaults
    of number output (`mode==False`), accumulator of zero (`A=0`), and program counter
    zero (`k=0`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将程序存储在变量 `prog` 中。程序状态设置为默认的数字输出模式（`mode==False`）、零值累加器（`A=0`）和零值程序计数器（`k=0`）。
- en: 'The main body of ABC now runs: a `while` loop with a nested `if` asking whether
    the current instruction (`t`) matches a command or not ➌. The program ends when
    all commands have been executed. By design, the `l` command causes an infinite
    loop, as there is no exit command.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ABC 的主体部分开始运行：一个 `while` 循环，其中嵌套着一个 `if` 判断当前指令（`t`）是否匹配某个命令 ➌。当所有命令执行完毕时，程序结束。根据设计，`l`
    命令会导致一个无限循环，因为没有退出命令。
- en: '***Testing ABC***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试ABC***'
- en: 'The esolang wiki page for ABC includes several example programs. Let’s use
    them to test the implementation. The simplest one counts forever: `acl`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ABC的esolang维基页面包含了几个示例程序。我们可以用它们来测试实现。最简单的程序是永远计数：`acl`。
- en: 'With comments, it looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 带有注释的代码如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Other examples include *1337.abc*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其他示例包括*1337.abc*
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which prints `1337` (leetspeak). The program increments `A` to print `1`, then
    two more times to print `3` twice, and finally four more times to print `7`. Simple.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印`1337`（黑客语言）。程序首先增加`A`以打印`1`，然后增加两次打印`3`两次，最后再增加四次打印`7`。很简单。
- en: We also have *dice.abc*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有*dice.abc*
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: which rolls a standard die. The program increments until *A* = 6, then replaces
    it with a random integer in [0, 6). A final increment sets *A* ∈ [1, 7) before
    printing it. Note that *dice.abc* has an extra `a` before the `r` to accommodate
    our change in how `r` works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它会掷一个标准骰子。程序递增直到*A* = 6，然后用[0, 6)中的随机整数替换它。最后一次递增将*A*设置为[1, 7)范围内的值，然后打印出来。请注意，*dice.abc*在`r`之前有一个额外的`a`，以适应我们改变`r`工作方式的修改。
- en: The examples also include *hello.abc*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例还包括*hello.abc*
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: which prints “Hello, world!” by setting ASCII output mode, then incrementing,
    decrementing, and starting from 0 to get the accumulator to hold the necessary
    ASCII codes for each letter. Note that the accumulator isn’t reset for each character,
    but rather uses an offset from the last character’s code. It’s as easy as ABC.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过设置ASCII输出模式打印“Hello, world!”，然后递增、递减，并从0开始，使累加器保存每个字母的必要ASCII码。请注意，累加器不会在每个字符之间重置，而是使用上一个字符的代码作为偏移量。就像ABC一样简单。
- en: 'The final example program, *phone.abc*, prints a randomly generated US-style
    telephone number:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最终示例程序*phone.abc*打印一个随机生成的美国风格电话号码：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The clever trick in this program is to add `d` to make the accumulator negative
    before printing it, thereby adding the dash between the parts of the number: `1-883-386-3219`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的巧妙之处在于通过加上`d`使累加器变为负数，然后再打印它，从而在数字的各部分之间添加了破折号：`1-883-386-3219`。
- en: With that, ABC and its examples are finished. As mentioned, ABC begs to be more.
    Spend a lot of time with esolangs and you’ll eventually get the itch to work on
    your own, and see how to take what exists and modify and enhance it. If you have
    that itch, scratch it; creativity is asking you to dance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，ABC及其示例就完成了。如前所述，ABC渴望变得更强大。花费大量时间与esolang互动，你最终会产生自己动手做点什么的冲动，看看如何修改和增强现有的内容。如果你有这种冲动，那就去做吧；创造力在邀请你跳舞。
- en: Let’s have some fun rebuilding ABC. We’ll maintain compatibility with what it
    is now, but we can add more.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重建ABC，享受其中的乐趣。我们将保持与现在的兼容性，但可以添加更多功能。
- en: '**ABC2**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ABC2**'
- en: 'After much deliberation and several focus groups, the name we’ve selected for
    ABC’s successor is ABC2\. There is precedent: Modula became Modula-2 (and Modula-3),
    Oberon became Oberon-2, and so on. What should be done to ABC to make it ABC2?
    Existing ABC programs should run without modification, meaning that ABC2 is backward
    compatible. Of course, most anything could be done, but in the next section, we’ll
    describe what we did and then follow with the updated Python implementation.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 经过充分的思考和几个焦点小组讨论，我们为ABC的继任者选择的名字是ABC2。之前有先例：Modula变成了Modula-2（以及Modula-3），Oberon变成了Oberon-2，等等。要让ABC变成ABC2，应该做些什么呢？现有的ABC程序应该无需修改即可运行，这意味着ABC2是向后兼容的。当然，几乎任何事情都可以做，但在下一节中，我们将描述我们所做的工作，然后给出更新后的Python实现。
- en: '***The Extensions***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扩展***'
- en: 'Extending ABC is fun. Here’s what turned ABC into ABC2:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展ABC很有趣。以下是将ABC转变为ABC2的过程：
- en: An interactive mode if no program is supplied at the command line
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果命令行未提供程序，则进入交互模式
- en: A second accumulator, `B`, and a command to toggle between `A` and `B` ( `^`
    )
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个累加器`B`，以及一个切换`A`和`B`的命令（`^`）
- en: A stack with arithmetic commands
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有算术命令的栈
- en: A command to exchange the top stack value and the active accumulator (`x`) as
    well as push (`!`) and pop (`@`) the stack
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命令，用于交换栈顶值和活动累加器（`x`），以及推送（`!`）和弹出（`@`）栈
- en: A primitive conditional command (`?`) with `<`, `>`, and `=` commands
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个原始的条件命令（`?`），包括`<`、`>`和`=`命令
- en: A command to halt a program (`q`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命令，用于终止程序（`q`）
- en: A command to get a character from the user (`k`)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命令，用于获取用户输入的字符（`k`）
- en: A branch command (`g`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分支命令（`g`）
- en: A command to toggle adding newline to output (`e`)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命令，用于切换是否将换行符添加到输出中（`e`）
- en: We’ll discuss these changes and their effect on what ABC was and became in the
    final section of this chapter. For now, let’s turn our attention to the implementation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章最后一节讨论这些变化以及它们对ABC从何而来、变成何样的影响。现在，让我们把注意力转向实现部分。
- en: '***An ABC2 Implementation***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ABC2 is in the file *ABC2.py*. It isn’t as compact as *ABC.py*, but follows
    standard Python conventions. The structure of the interpreter remains the same:
    process each character in `prog` as a command until all have been processed. Some
    modification is necessary to allow a purely interactive mode. We’ll present the
    code in pieces, starting with [Listing 7-2](ch07.xhtml#ch07list2), which shows
    the code to parse the command line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-2: Parsing program text in ABC2*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The `if` loads and parses a program, keeping only actual command characters,
    or sets the `interactive` flag.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the default state and the modified main loop ([Listing 7-3](ch07.xhtml#ch07list3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-3: The ABC2 state and main loop*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The single accumulator is now a pair of accumulators, both initially zero (`A`).
    The value of `I` toggles between them. Output defaults to numbers (`mode=0`) and
    no newline (`cr=0`). The `stack` is a standard Python list. We’ll use the seldom
    seen `pop` method. All stack operations are in `ops`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, two loops begin. The outer `while` loop runs forever. If interactive,
    `prog` is set to whatever sequence of commands the user enters. Note that the
    state is not reset, so whatever state is active when the entered commands are
    complete is still present for the next set. The second `while` loop is the same
    as in ABC proper: get the character of the command and evaluate it. When the program
    ends, if not in interactive mode, exit.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'In the actual implementation, the second `while` loop contains a rather lengthy
    compound `if` statement to execute the command ([Listing 7-4](ch07.xhtml#ch07list4)):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-4: Executing ABC2 commands*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: A conceptually more elegant implementation would make ABC2 a class and use a
    dictionary of methods associated with each command in a small loop. Readers are
    invited to build such an implementation and share it. However, for pedagogical
    purposes, building on the existing ABC `if` statement approach seems easier to
    follow, even if it’s less creative.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: ABC2 is backward compatible with ABC, so we’ll only describe the extensions.
    All previous commands operate as before, with `A` replaced by `A[I]` to use the
    active accumulator. Most of the extended commands require no more than one or
    two lines of code (see [Table 7-1](ch07.xhtml#ch07tab1)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Python Code for the Extended ABC2 Commands'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Implementation** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `^` | `I ^= 1` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `k` | `A[I] = ord(getch())` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `q` | `quit()` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| `e` | `cr ^= 1` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| `!` | `stack.append(A[I])` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| `@` | `A[I].stack.pop()` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `g` | `k = k + stack.pop() - 1` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `?` | `if (not stack.pop()):` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '|  | `   k += 1` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `x` | `v = stack.pop()` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '|  | `stack.append(A[I])` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '|  | `A[I] = v` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| *stack ops* | `if (t == "="):` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '|  | `    t = "=="` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '|  | `v=eval("%d %s %d" % (stack[-2],t,stack[-1]))` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '|  | `if (type(v) is bool):` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '|  | `    v = 1 if (v) else 0` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '|  | `stack.pop(); stack.pop()` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '|  | `stack.append(int(v))` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: There is no need to walk through each of the little code snippets in [Table
    7-1](ch07.xhtml#ch07tab1), as most are self-explanatory. Note that sanity checks
    for things like popping the stack are not in [Table 7-1](ch07.xhtml#ch07tab1);
    however, they are in *ABC2.py*, so please read through the full source code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: There is one piece of code in [Table 7-1](ch07.xhtml#ch07tab1) we should discuss.
    The `k` command calls a function, `getch`, which returns a keypress without waiting
    for the user to press ENTER. This is not a standard Python function. The top portion
    of *ABC2.py* implements `getch` for Linux, macOS, and Windows.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `$` and `^` commands make use of an operator that might be unfamiliar
    to some: `^` (exclusive-OR or XOR). Exclusive-OR is a logical operation with the
    truth table'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '| `A` | `B` | `A^B` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: which states that the output of XOR is 1 when either of the inputs, but not
    both, is 1\. This behavior makes toggling straightforward because `0^1 = 1` and
    `1^1 = 0`, meaning XORing a 0 or 1 with 1 results in 1 or 0, thereby flipping
    its state. As with other Python operators, `I ^= 1` is shorthand for `I = I^1`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation is complete. Now, let’s see what ABC2 can do.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**ABC2 in Action**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After surviving Forth, ABC2 will seem straightforward. Let’s begin with the
    simplest of examples: adding two numbers. This is something ABC cannot do easily:
    you have to count up to the first value with `a`s and then use more `a`s to add
    a positive number before printing the result. ABC2 makes this a little easier.
    Consider *add.abc2*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The comments clarify the actions, but the gist is to set newline mode to print
    one number per line of output, count up to 10, and push the accumulator on the
    stack. As the accumulator is already at 10, and pushing to the stack does not
    alter it, we count down to 7 and push that to the stack.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The last line calls `+` to put 10 + 7 = 17 on the stack before popping it off
    the stack to the accumulator to print with `c`. Note that only values in the accumulators,
    `A` and `B`, can be printed. There is no “print the top stack" item as in Forth.
    To run *add.abc2*, use
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Well, that was easy enough. Let’s try something similar using interactive mode.
    Launch ABC2 (python3 ABC2.py), but don’t supply a filename. Then, enter the sequence
    of statements in [Listing 7-5](ch07.xhtml#ch07list5).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 7-5: An interactive ABC2 session*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](ch07.xhtml#ch07list5) might look like random noise at first,
    but there’s a method to the madness. Let’s walk through it. ABC2’s interactive
    prompt is a colon (`:`). The first line shows five `a`s followed by a semicolon
    (`;`). We know `a`; it adds 1 to the accumulator, so the accumulator now holds
    the number 5\. The `;` is the “debug” command from ABC. That’s what produces the
    second line, `{5:0: (5,`''''`)(0,`''''`)}`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: There are four parts to the debug line. The first part shows the current program
    counter, which is the instruction number followed by a colon and a 0 or 1\. In
    this case, the program counter is 5, as the `;` is the sixth instruction entered
    (always count from 0). The next bit, `0:`, tells us A is the current accumulator,
    `A[0]` in *ABC2.py*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 调试行有四个部分。第一部分显示当前程序计数器，即指令号，后跟冒号和0或1。在这个例子中，程序计数器是5，因为`;`是第六条输入的指令（总是从0开始计数）。接下来的部分，`0:`，告诉我们A是当前的累加器，即在*ABC2.py*中的`A[0]`。
- en: Next come two sets of parentheses. These are the current numeric value and value
    as a character for the two accumulators, A and B. In this case, A is 5, and B
    is its default of 0\. Characters are shown if the accumulator is in [32,127],
    which excludes 5 and 0, so no characters are shown.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是两个括号。这些是两个累加器A和B的当前数值和字符值。在这个例子中，A是5，B是它的默认值0。只有当累加器的值在[32,127]之间时，才会显示字符，这排除了5和0，因此没有字符显示。
- en: After the closing brace comes the stack. The number of items on the stack comes
    first. In this case it’s `<0>`, as the stack is empty. Any items on the stack
    follow.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 闭括号后是堆栈。首先显示堆栈中的项目数量。在这个例子中是`<0>`，因为堆栈为空。接下来的部分显示堆栈中的所有项目。
- en: 'The next set of commands entered, `!;`, store A on the stack and print the
    debug information again. This time we see `<1>: 5` telling us that there is one
    item on the stack, a 5.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '输入的下一个命令集，`!;`，将A压入堆栈并再次打印调试信息。这一次我们看到`<1>: 5`，告诉我们堆栈上有一个项目，即数字5。'
- en: The following commands push A on the stack a second time, call debug, multiply
    the top two stack items, and call debug again, leaving 25 on the stack. Lastly,
    `@ec;` pops the stack, sets A to 25, moves to newline mode, and prints `A`. The
    `q` command exits ABC2\. If you venture to try your hand at ABC2 code, and I strongly
    suggest you do, you’ll find the interactive mode useful during program development.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将A第二次压入堆栈，调用调试，乘以堆栈顶部的两个项目，再次调用调试，最终将25留在堆栈中。最后，`@ec;`弹出堆栈，将A设置为25，进入换行模式，并打印`A`。`q`命令退出ABC2。如果你敢尝试编写ABC2代码，强烈建议你这么做，你会发现交互模式在程序开发过程中非常有用。
- en: Let’s walk through three more ABC2 examples. Each example explores an additional
    capability of ABC2, culminating in a final program that serves as a tribute to
    an underappreciated early computing pioneer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过三个ABC2示例逐步讲解。每个示例探讨了ABC2的一个新功能，最终形成一个致敬于一位被低估的早期计算机先驱的程序。
- en: '***HELLO WORLD!***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***HELLO WORLD!***'
- en: The Hello World Collection website lists versions of “Hello, world!” in more
    than 600 different programming languages (*[http://helloworldcollection.de/](http://helloworldcollection.de/)*).
    It’s become almost a moral obligation for every language capable of printing “Hello,
    world!” to do so at some point. Therefore, we’ll be good citizens and do our duty.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Hello World Collection网站列出了超过600种不同编程语言的“Hello, world!”版本（* [http://helloworldcollection.de/](http://helloworldcollection.de/)*）。对于每一种能够打印“Hello,
    world！”的语言，几乎成了一种道德义务，必须在某个时刻打印出来。因此，我们也要做个好公民，履行我们的责任。
- en: The file *hello.abc2* contains the obligatory, and slightly grammatically incorrect,
    ABC2 version of “Hello, world!” Running *hello.abc2* produces
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*hello.abc2*包含了ABC2版本的“Hello, world!”（你好，世界！），虽然略有语法错误。运行*hello.abc2*会产生如下结果：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ABC version incremented and decremented the accumulator to arrive at the
    necessary ASCII code for each character. ABC2 has a stack, which, as we learned
    in [Chapter 4](ch04.xhtml#ch04), is a LIFO data structure; the last thing in is
    the first thing out. Let’s use the stack to store the characters we want to output,
    pushing them in reverse order so they print correctly when popped off the stack.
    Moreover, the stack supports arithmetic, so we don’t need to count up to the values
    we want. We can take shortcuts to reach the necessary ASCII codes more quickly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ABC版本通过递增和递减累加器来达到每个字符所需的ASCII码。ABC2有一个堆栈，正如我们在[第4章](ch04.xhtml#ch04)中学到的，它是一个LIFO数据结构（后进先出）；最后压入的是第一个弹出的。让我们使用堆栈来存储我们想要输出的字符，按照相反的顺序压入，这样当它们从堆栈中弹出时会正确打印出来。而且，堆栈支持算术运算，所以我们不需要数到我们想要的值。我们可以通过快捷方式更快地达到所需的ASCII码。
- en: '[Listing 7-6](ch07.xhtml#ch07list6) gives us the code.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-6](ch07.xhtml#ch07list6)给出了代码。'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 7-6: “Hello, world!” in ABC2*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6: 在ABC2中输出“Hello, world！”*'
- en: 'The first line is, of course, the comment. Let’s parse the first line after
    the comment `aaa!aaaaaaaa!*@!!!+@aa!`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行当然是注释。让我们解析注释后的第一行`aaa!aaaaaaaa!*@!!!+@aa!`：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each line shows the ABC2 commands on the left and the state of the stack afterward.
    Look at the last line. The stack contains 33 and 68, the ASCII codes for `!` and
    `D`, respectively, which are the final two characters to output. The program builds
    the output string on the stack in reverse order.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行展示了左侧的 ABC2 命令以及栈的后续状态。看看最后一行。栈中包含 33 和 68，分别是 `!` 和 `D` 的 ASCII 码，这两个字符是最终输出的字符。程序在栈上反向构建输出字符串。
- en: The remainder over `HELLO WORLD!` is similarly placed on the stack. When the
    second to last line of [Listing 7-6](ch07.xhtml#ch07list6) is complete, the stack
    contains
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余部分将被类似地放入栈中。当[清单 7-6](ch07.xhtml#ch07list6)的倒数第二行完成时，栈中包含了
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: which the final line of [Listing 7-6](ch07.xhtml#ch07list6) outputs by enabling
    character mode (`$`) and repeatedly popping the stack and printing (`@c`). Before
    the final character is output, `e` turns on newline mode.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过启用字符模式（`$`）并反复弹出栈并打印（`@c`）所得到的[清单 7-6](ch07.xhtml#ch07list6)的最后一行输出结果。在最后一个字符输出之前，`e`
    会开启换行模式。
- en: Now, let’s do some math with ABC2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 ABC2 做一些数学计算。
- en: '***A Slice of Pi***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一片圆周率***'
- en: I’m writing this section on March 14th, which, using American-style dates, is
    3/14—Pi Day. Therefore, in honor of everyone’s favorite mathematical constant,
    our next example uses ABC2 to estimate the value of *π* = 3*.*14159*…* using nothing
    more than random integers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 3 月 14 日写这部分内容，使用美国式日期格式就是 3/14——圆周率日。因此，为了纪念大家最喜欢的数学常数，接下来的例子使用 ABC2 来估算
    *π* = 3*.*14159*…*，仅通过随机整数。
- en: The area of a circle is *A*[circle] = *πr*², where *r* is the radius, the distance
    from the center to the edge. If we set *r* = 1, the area of the resulting circle
    is *A*[circle] = *π*(1)² = *π*. A circle of radius 1 has a diameter of 2\. If
    this circle is centered at the origin, the diameter goes from *–*1 to +1\. Now
    imagine a square with a side length of 2 set over the circle. The square is *circumscribed*
    over the circle (see [Figure 7-1](ch07.xhtml#ch07fig1)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 圆的面积是 *A*[circle] = *πr*²，其中 *r* 是半径，即从圆心到边缘的距离。如果我们设定 *r* = 1，那么得到的圆的面积是 *A*[circle]
    = *π*(1)² = *π*。半径为 1 的圆的直径是 2。如果这个圆的圆心在原点，直径的范围是从 *–*1 到 +1。现在，假设一个边长为 2 的正方形被放置在圆上。这个正方形是*外接*于圆的（见[图
    7-1](ch07.xhtml#ch07fig1)）。
- en: '![Image](Images/07fig01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig01.jpg)'
- en: '*Figure 7-1: A square circumscribed over a circle of radius 1*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：一个正方形外接于半径为 1 的圆*'
- en: We’ll get to the dots in [Figure 7-1](ch07.xhtml#ch07fig1) momentarily. For
    now, just consider the relationship between the square and the circle. If the
    square’s side is 2, its area is *A*[square] = *s*² = (2)² = 4.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讨论[图 7-1](ch07.xhtml#ch07fig1)中的点。目前，先考虑正方形与圆之间的关系。如果正方形的边长为 2，那么它的面积是
    *A*[square] = *s*² = (2)² = 4。
- en: The ratio between the areas of the circle and the square is *A*[circle]/*A*[square]
    = *π*/4\. This ratio remains even if we only consider the first quadrant, that
    is, one quarter of the shapes (where the dots are in [Figure 7-1](ch07.xhtml#ch07fig1)).
    The area of the circle in quadrant one is one quarter of *π*, that is, *π*/4,
    and the area of the square in quadrant one is 4/4 = 1, meaning the ratio between
    the two is *π*/4/1 = *π*/4.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 圆和正方形的面积比是 *A*[circle]/*A*[square] = *π*/4。即使我们只考虑第一象限，也就是说，考虑四分之一的图形（其中的点在[图
    7-1](ch07.xhtml#ch07fig1)中），这个比例依然成立。第一象限中的圆的面积是 *π* 的四分之一，即 *π*/4，而第一象限中的正方形面积是
    4/4 = 1，这意味着它们之间的比例是 *π*/4/1 = *π*/4。
- en: Okay, so what? Well, if we had an estimate of the area of the circle and the
    square in quadrant one, we’d be able to divide the two and expect that it matches
    *π*/4\. Here’s where the dots in [Figure 7-1](ch07.xhtml#ch07fig1) come into the
    picture. They represent random points in the range [0,1) in both *x* and *y*.
    What if we generate many of these random points? In a sense, the points will slowly
    fill in the area of both the circle and the square. If we count how many land
    within the circle and divide by those that land within the square, which is all
    of them because we are using [0, 1), we’ll have an estimate of the ratio between
    the circle and the square, which, as we just saw, is *π*/4\. Therefore, if multiplied
    by 4, this ratio should give us an estimate of *π*, which is exactly what we want.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么呢？如果我们能估算出第一象限中圆和正方形的面积，我们就能将二者相除，预期结果应接近*π*/4。这时，[图 7-1](ch07.xhtml#ch07fig1)中的点就派上用场了。它们代表了在区间[0,1)内，*x*和*y*方向上的随机点。如果我们生成许多这些随机点，会发生什么呢？从某种意义上讲，这些点会慢慢填充圆和正方形的区域。如果我们统计落在圆内的点数，并将其除以落在正方形内的点数（因为我们使用的是[0,1)，所以正方形内的点数就是所有点数），我们就可以估算圆和正方形之间的比例，而正如我们刚才看到的，这个比例就是*π*/4。因此，如果将这个比例乘以4，就可以得到*π*的估算值，这正是我们想要的。
- en: 'Great! Let’s select random values in the range [0,1) and start counting how
    many land within the circle. How do we know if the point is within the circle?
    That’s straightforward. It’s really an application of the Pythagorean theorem:
    *c*² = *a*² + *b*², where *a* is *x* and *b* is *y*. The circle is centered at
    the origin and has a radius of 1\. If *x*² + *y*²—the distance from the origin
    to the randomly selected point—is less than the radius squared, then the point
    is within the circle. For the circle, *r*² = 1, so the point is within the circle
    if its distance from the origin is less than 1.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！让我们在区间[0,1)内选择随机值，并开始统计落在圆内的点数。我们如何知道某个点是否在圆内呢？这个很简单。实际上，这是勾股定理的应用：*c*²
    = *a*² + *b*²，其中*a*是*x*，*b*是*y*。圆心在原点，半径为1。如果*x*² + *y*²——即从原点到随机选定点的距离——小于半径的平方，则该点在圆内。对于圆，*r*²
    = 1，因此当点与原点的距离小于1时，它就在圆内。
- en: We need two counters. The first counts every randomly generated point because
    [0,1) covers the entire area of the square in quadrant one. This means that every
    point lands within the square so no test is needed. We’ll call this counter `S`.
    The second counter is for all the points that land within the circle, (*x*, *y*),
    where *x*² + *y*² < 1\. We’ll call this counter `C`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个计数器。第一个用于统计每个随机生成的点，因为[0,1)覆盖了第一象限内整个正方形的区域。这意味着每个点都落在正方形内，因此无需测试。我们将这个计数器称为`S`。第二个计数器用于统计所有落在圆内的点，(*x*,
    *y*)，其中*x*² + *y*² < 1。我们将这个计数器称为`C`。
- en: 'Here’s the algorithm we want to code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要编写的算法：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On every pass through the loop, the code selects a new (*x*, *y*) point, increments
    `S`, and if the point is within the circle, increments `C`. The ratio, then, will
    approach *π*/4, which when multiplied by 4 is an estimate for *π*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环中，代码会选择一个新的(*x*, *y*)点，增加`S`，如果该点落在圆内，则增加`C`。然后，比例会接近*π*/4，当这个比例乘以4时，就可以得到*π*的估算值。
- en: Of course, you’ve likely already noticed the problem. ABC2 works with integers
    only. The algorithm expects floating-point numbers. Are we stymied? No, we’re
    not. We want a ratio of two areas, one for the circle and one for the square.
    We aren’t really restricted to the range [0,1). What if we use integers and select
    points in the range [0,1,000,000,000)? ABC2 has no difficulty working with integers
    in that range. If we scale the *x* and *y* by one billion, then the limit we check
    scales by the square of that. So instead of checking if *x*² + *y*² < 1, we check
    if *x*² + *y*² < 10^(18), one billion squared. Again, ABC2, thanks to our Python
    implementation, has no difficulty with an integer like 10^(18).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能已经注意到问题了。ABC2仅适用于整数。该算法期望使用浮点数。我们就此受阻了吗？并没有。我们需要的是两个面积的比率，一个是圆的面积，一个是正方形的面积。实际上，我们并不局限于[0,1)这个区间。假设我们使用整数，并选择[0,1,000,000,000)这个区间内的点。ABC2在这个范围内处理整数没有问题。如果我们将*x*和*y*扩大十亿倍，那么我们检查的限制也会按平方比例扩大。所以，不再检查*x*²
    + *y*² < 1，而是检查*x*² + *y*² < 10^(18)，即十亿的平方。再次感谢我们的Python实现，ABC2可以轻松处理像10^(18)这样的整数。
- en: Therefore, our algorithm remains the same, and only the limits on the random
    numbers and the distance from the origin change. However, our output must change
    as well. We won’t calculate `4*C/S`, but instead display `C/S` *as a fraction*.
    That is, literally as `C` followed by a `/` and then `S`. At any point, we can
    take an output value, dump it in a calculator to get the actual floating-point
    ratio, and multiply by 4 to get the current estimate of *π*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的算法保持不变，只有随机数的限制和距离原点的变化。不过，我们的输出也必须有所变化。我们将不再计算`4*C/S`，而是以*分数*的形式显示`C/S`。也就是说，实际上是将`C`后跟一个斜杠，然后是`S`。在任何时候，我们都可以取出输出值，将其输入计算器以获得实际的浮动点比率，再乘以4以得到当前的*π*估算值。
- en: The code we need is in [Listing 7-7](ch07.xhtml#ch07list7) and *pi.abc2*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的代码在[Listing 7-7](ch07.xhtml#ch07list7)和*pi.abc2*中。
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-7: Estimating π with random numbers*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-7：使用随机数估算π*'
- en: We’ll use accumulator B to hold `S` and the stack to hold `C`. When the program
    starts, accumulators A and B are both zero. So we push A on the stack to initialize
    the counter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用累加器B保存`S`，并将栈用来保存`C`。当程序开始时，累加器A和B都为零。因此我们将A压入栈中以初始化计数器。
- en: We’ll use `r` to select a random integer in [0, 10⁹), so we need to make A one
    billion. That’s what the second line of [Listing 7-7](ch07.xhtml#ch07list7) does.
    First A is 10, then after squaring by pushing it on the stack twice, A is 100\.
    Then 100 × 100 = 10,000 and 10,000 × 10,000 = 100,000,000 on the stack. A final
    multiplication by 10 sets A to one billion. That was the painful part. Selecting
    a random value and squaring it is `r!!*` to select the value, push it on the stack
    twice, then multiply. The stack now contains `( C x*x -- )`. The next two lines
    of [Listing 7-7](ch07.xhtml#ch07list7) repeat the previous two to get *y*² on
    the stack so `+` can add them together.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`r`从[0, 10⁹)中选择一个随机整数，因此我们需要将A设置为十亿。这就是[Listing 7-7](ch07.xhtml#ch07list7)第二行的作用。首先A是10，然后通过将它压入栈中两次进行平方，A变为100。接着100
    × 100 = 10,000，再将10,000 × 10,000 = 100,000,000压入栈中。最终乘以10将A设置为十亿。这个过程比较痛苦。选择一个随机值并对其进行平方是`r!!*`，即选择值，将其压入栈中两次，然后进行乘法。此时栈中的内容为`(
    C x*x -- )`。接下来的[Listing 7-7](ch07.xhtml#ch07list7)的两行重复了前两行的操作，将*y*²放入栈中，以便`+`可以将它们相加。
- en: The stack now contains `C` followed by the square of the distance of the random
    point, (*x*, *y*), from the origin. We must increment `C` if this distance is
    less than 10^(18), so we use an approach similar to setting A to one billion to
    get 10^(18) on the stack. The stack is now `(C x*x+y*y 10**18 -- )`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当前栈中包含`C`，后跟随机点（*x*, *y*）到原点的距离的平方。若该距离小于10^(18)，我们必须增加`C`，因此我们采用类似的方法：将A设置为十亿，最终得到10^(18)放入栈中。此时栈中的内容为`(C
    x*x+y*y 10**18 -- )`。
- en: The less-than command, `<`, performs the comparison and leaves 0 or 1 on the
    stack. This is particularly convenient. If the comparison is false, that is, the
    distance isn’t less than 10^(18), we get 0; otherwise, we get 1, so the stack
    is `( C 0|1 -- )`. Either way, adding this result to `C` works. If the comparison
    is true, the 1 is on the stack, which increments `C` for us. Otherwise, there’s
    no harm in adding 0 to `C`. Because of this happy arrangement, the only branching
    necessary is the loop at the end of the program to generate the next point.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 小于命令`<`执行比较，并在栈上留下0或1。这非常方便。如果比较结果为假，即距离不小于10^(18)，我们得到0；否则，我们得到1，因此栈中是`( C
    0|1 -- )`。无论哪种情况，将此结果加到`C`上都是可行的。如果比较为真，栈中是1，这会增加`C`的值。如果比较为假，则将0加到`C`也没有问题。由于这种安排，唯一需要分支的地方是在程序的末尾生成下一个点的循环。
- en: 'We’ve incremented `C`, if necessary, but we still need to increment `S`. As
    it’s in accumulator B, incrementing is particularly easy: switch to accumulator
    B, increment with `a`, and then switch back to accumulator A with `^a^` .'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经根据需要增加了`C`，但仍然需要增加`S`。由于`S`在累加器B中，因此增量操作特别容易：切换到累加器B，使用`a`进行增量操作，然后通过`^a^`切换回累加器A。
- en: We’re ready to display our current estimate for *π*/4\. First, we print `C`
    and return it to the stack so it isn’t lost (`@!c`). Then, we set A to 47, the
    ASCII code for a slash, and display it with `$c$`. Lastly, we switch to accumulator
    B, toggle newline mode with `e`, and print `S`, remembering to turn off newline
    mode and toggle back to accumulator A.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好显示当前的*π*/4估算值。首先，我们打印`C`并将其返回栈中，以免丢失（`@!c`）。然后，我们将A设置为47，即斜杠的ASCII码，并通过`$c$`显示它。最后，我们切换到累加器B，使用`e`切换到换行模式，打印`S`，并记得关闭换行模式，切换回累加器A。
- en: The first instruction is `!` to store A on the stack, meaning store `C`. Just
    before we loop, we pull `C` off the stack with `@` and then loop with `l`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The program runs forever, generating ever better estimates of *π*/4\. Let’s
    see how well it does. For one run of the program, the first few iterations output
    are
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: with the last iteration giving an estimate of *π* ≈ 4(19)/21 = 3*.*6190476\.
    Not too good, but the program’s just started. The output a second or two later
    was *π* ≈ 4(992)/1280 = 3*.*1, so it’s heading in the right direction. After about
    15 seconds, the estimate was *π* ≈ 4(44893)/57153 = 3*.*1419523, which is definitely
    in the ballpark.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: How quickly does the output approach *π*? If we capture the program’s output
    and plot the estimate of *π* as a function of the iteration number, we arrive
    at [Figure 7-2](ch07.xhtml#ch07fig2), which shows the convergence as iterations
    proceed. After some 100,000 iterations, the estimate was 3.1416803, which is accurate
    to nearly four decimals.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/07fig02.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: The estimate of *π* as a function of iteration number*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.xhtml#ch07fig2) shows that many iterations are necessary
    to get close to *π*—around 25,000 or so. This isn’t too surprising, as we’re trying
    to replace an actual area with a collection of random points. You might feel a
    little unsettled as a point has no area, so how can a collection of them have
    an area? I think of it this way: imagine that infinite space is actually discrete.
    In that sense, an area is a collection of (extremely) tiny cells (think pixels)
    where the random points fill in an ever-increasing set of cells. The difference
    here is that a cell *does* have an area, even if a tiny one, and all of the cells
    together tile the circle and square. From that point of view, we randomly fill
    cell after cell to arrive at a better and better estimate of the actual circle
    and square areas. We would expect over time to get a better and better estimate
    of *π*/4, and ultimately *π*.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this little Pi Day example. It’s nice that ABC2, for all
    its simplicity, can do something like this and that the logical operators for
    ABC2 happened to give exactly the right value in the right place (that is, on
    the stack above `C`) so no painful looping construct was necessary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s develop our version of an early computing machine, and learn a bit
    about its remarkable, though largely unknown, inventor.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '***The Electromechanical Arithmometer***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve likely never heard of Leonardo Torres y Quevedo (sometimes written as
    Leonardo Torres Quevedo). Before I started writing my first book, I had never
    heard of him, either. If you have heard of him, fantastic.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Torres Quevedo was a Spanish inventor born in the mid-19th century. His many
    accomplishments include cable cars, dirigibles, an early form of remote control,
    a working chess-playing automaton, and, of most interest to us, the electromechanical
    arithmometer. An arithmometer is a 19th-century mechanical calculator. Torres
    Quevedo’s version, presented in Paris in 1920 (see [Figure 7-3](ch07.xhtml#ch07fig3)),
    was electronic and mechanical.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/07fig03.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: The electromechanical arithmometer circa 1920\. Image used with
    the kind permission of Francisco A. González Redondo, Universidad Complutense,
    Madrid.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: On the right of [Figure 7-3](ch07.xhtml#ch07fig3) is a typewriter. This was
    the keyboard used by the operator. The operator put paper in the typewriter and
    proceeded to type an expression such as `123 × 321 =` to which the machine would
    respond by typing `39483` on the same line before advancing the paper to the next
    line. Recall that this was 1920, well before the first true electronic computers
    and before the pioneering work of Konrad Zuse. Torres Quevedo showed the electromechanical
    arithmometer and then put it aside. It was never marketed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll get back to [Figure 7-3](ch07.xhtml#ch07fig3) in a little bit, but, as
    this is a book on programming languages, it seems fitting to point out that not
    only did Torres Quevedo build such an impressive machine, he also, even earlier,
    worked through what it means to implement floating-point arithmetic in a machine-friendly
    way. In his 1914 work “Essays on Automatics,” he writes that numbers should be
    stored as *n* × 10^(*m*), which is how we store floating-point numbers now: *n*
    × 2^(*m*). A problem with floating-point is that numbers in scientific notation
    are not unique: 3*.*1415 × 10⁰ = 0*.*31415 × 10¹ = 31*.*415 × 10^(*–*1). Torres
    Quevedo understood this, so he proposed the following rules to store numbers in
    a consistent way for a machine to process:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '*n* will always be the same number of digits (six, for example).'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first digit of *n* will be in the order of tenths, the second in hundredths,
    and so on.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One will write each quantity in the form: *n;m*.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modern computers store floating-point numbers with a fixed size *n*; for example,
    52 bits for a C `double` (really 53 bits; a leading 1 is implied as the integer
    part of the significand, 1*.b*[51] *b*[50]*…**b*[0]). It’s clear that Torres Quevedo
    was thinking in base-10, but the idea of fixing the significand size was key.
    Zuse, mentioned above, was likely the first to implement floating-point numbers
    in computers in base-2, much as we do now—see the IEEE 754 standard.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'One last observation on Torres Quevedo’s floating-point format before we get
    back to the electromechanical arithmometer. Notice that he suggests, again in
    1914, that floating-point numbers be written as *n;m*. So using his rules, he
    would write *π* as 0.314159;1, meaning 0*.*314159 × 10¹ = 3*.*14159\. This is
    very close to how floating-point numbers are entered today: 0.314159e1\. The only
    difference is using a semicolon (;) for *e*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this is all very interesting, but what does it have to do with ABC2? One
    feature of ABC2 we have yet to explore is the `k` command, the command that reads
    a character from the keyboard and places its character code in the current accumulator.
    Let’s use this command to mimic Torres Quevedo’s arithmometer. We’ll restrict
    ourselves to multiplication only.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The code we’ll work with is in *multiply.abc2*. This is the most complex ABC2
    program we’ll consider. Not only does it use `k` for input, it also uses `?`,
    the only conditional command available in ABC2.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with an outline of what we want to accomplish. Leonardo’s arithmometer
    let the user type a number, an operation, and a second number. We’re fixing the
    operation, multiplication, so what we need from the user are two numbers—specifically,
    two three-digit numbers—though the leading digits might be zero. The `k` instruction
    gets one character from the keyboard, so how will we turn characters into numbers?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that the ASCII code for zero is 48\. The ASCII
    codes for the digits follow in order, meaning that 49 is one, 50 is two, and so
    on. Therefore, if the user presses 3, the accumulator will contain 51\. Subtracting
    48 from 51 leaves 3\. To convert the ASCII code for a digit into the digit itself
    we would subtract 48\. We now know how to get single digits. But what about a
    three-digit number?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: We have a three-digit number, 451\. In grade school, you likely learned how
    to write numbers in expanded form as
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 451 = 400 + 50 + 1
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'but there’s another way to expand a number:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '| 451 | = (((4 × 10) + 5) × 10) + 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '|  | = ((40 + 5) × 10) + 1 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '|  | = (45 × 10) + 1 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '|  | = 450 + 1 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '|  | = 451 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: 'Expanding a number this way points us toward an algorithm for entering three
    digits and converting them to a three-digit number:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Get the first digit, multiply by 10, and store it on the stack.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the second digit and add it to the number on the stack.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the number on the stack by 10.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the third digit and add it to the number on the stack.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When these steps are complete, the stack contains the three-digit number the
    user entered character by character. Let’s follow the steps and see if they work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The steps work. The user entered 4, 5, and 1, and the stack holds the number
    451\. When implemented in ABC2, there is one additional step: after the user enters
    the digit, we must subtract 48 to convert the character code to the digit value.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: We know how to get a number from the user. To implement the “arithmometer,”
    we must get two numbers from the user, each on the stack, and multiply.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-8](ch07.xhtml#ch07list8) shows all of *multiply.abc2*.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 7-8: Multiplying pairs of numbers*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The first line has the comment `B IS 48`. This line switches to accumulator
    B ( `^` ) and makes sure it is 0, which is necessary because we loop. It then
    increments to 5, pushes it on the stack, and increments five more times to push
    10 on the stack. Multiplying leaves 50 on the stack, which is popped off the stack
    to accumulator B (`@`) and finally decremented twice to leave B equal to 48\.
    This is the constant we need to subtract from the digit ASCII codes the user will
    enter. For this program, we use B as a constant. When needed, we switch to accumulator
    B, push its value on the stack, and then immediately switch back to accumulator
    A.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The next line is `FIRST KEYPRESS`, `^ k!!`. The `^` statement toggles back to
    accumulator A. We read a character from the keyboard (`k`) and push it on the
    stack twice with `!!`. We push it twice because program will loop to ask the user
    for pairs of numbers repeatedly. For the first digit, if the user presses ESC
    (ASCII 27), we want to exit the program instead. We push the first digit twice,
    once to use in calculating the number as we did above, and a second time to compare
    the key to ESC.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The `QUIT IF ESC PRESSED` line checks if the top stack value is 27\. First,
    we set A to 27 with `naaa!aaaaaa!*`. We increment A to 3 and push it onto the
    stack, and then increment six more times to 9 and push it onto the stack and multiply
    the two numbers to leave 27 on the stack with the ASCII code of the character
    the user entered immediately below it. Executing `=` checks if the top two stack
    items are equal. While `?` pops the stack, if the top stack value is true (not
    0), the program executes the command immediately after `?`. Otherwise, it skips
    the next command and execution continues with the following command. In this case,
    the next command is `q`, quit, so if the key the user pressed was ESC, the `=`
    left true on the stack for `?` to pick up and, because it’s true, execute `q`
    to end the program.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve checked whether the first key is ESC, but we have not yet displayed the
    key nor subtracted 48 to get its digit value. It’s currently on the stack, so
    we load it back into accumulator A with `@!`: `@` to pull it from the stack into
    accumulator A and `!` to push it back to the stack because we need it there as
    well. Next, `$c$` prints the character by switching to character mode, printing
    with `c`, and switching back to number mode.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: To subtract 48, we use `^ ! ^ -`. This pattern repeats throughout the program
    every time we need to subtract 48\. It switches to accumulator B, pushes B on
    the stack, switches back to accumulator A, and subtracts. The stack now contains
    the digit value, which must be multiplied by 10 via `naa!aaa!**`, which puts 2
    and then 5 on the stack, multiplies them to get 10, and finally multiplies the
    digit value by 10\. This pattern also repeats whenever a digit value must be multiplied
    by 10.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The first digit is a special case because we need to check for ESC. The remaining
    five digits are essentially the same: `k$c$!^!^-+` to get the digit, display it,
    push it, push 48, subtract, and then add the digit value to the value already
    on the stack. If necessary, this pattern is followed by the multiply-by-10 pattern.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The other lines in [Listing 7-8](ch07.xhtml#ch07list8) handle necessary text
    output. The final line is `*@ecel`. The stack now contains the two numbers the
    user entered, so `*` multiplies them and `@` pulls the result into accumulator
    A for display with `ec`, where `e` turns on newline mode. To go back and get another
    pair of numbers, we first turn off newline mode and then loop `l`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The description above is necessarily dense. Do review the code to see what it
    does and try some of the patterns in interactive mode as well. Let’s see what
    the output of *multiply.abc2* looks like; however, naturally, in print you won’t
    see the flow.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although not as impressive as Torres Quevedo’s electromechanical arithmometer,
    we might argue there’s at least some utility to a little program like this. As
    an exercise, extend *multiply.abc2* to accept four-digit numbers. Note that there
    is no check to ensure that the key pressed is actually a valid digit. The program
    is happy with any keypress; however, the results will not be meaningful in that
    case.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Let’s bid Torres Quevedo a fond farewell and conclude our ABC2 adventure with
    a short discussion.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began with the esolang wiki description of ABC and our Python implementation.
    It is abundantly clear that as a programming language, ABC isn’t even remotely
    Turing complete. Nor was it meant to be; it was just a cute idea for something
    capable of simple tasks. We then extended ABC to create ABC2\. Is ABC2 Turing
    complete? No, it isn’t. There are only two memory locations and a stack that cannot
    be accessed cell-by-cell like an array.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: What might make ABC2 Turing complete? One might imagine ABC3, with the stack
    and, instead of two accumulators, an “infinite” set of accumulators accessible
    by index. In other words, an array. That scenario would use the stack much like
    the arithmetic logic unit of a CPU and the accumulators as memory. I suspect such
    a language might be Turing complete. I might make it as it wouldn’t be difficult.
    Better still, you make it, and if you feel like sharing, send it to me and I’ll
    put it on the book’s GitHub site.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: ABC2’s stack is limited because there are no intrinsic commands to manipulate
    it like DUP, SWAP, ROT, and OVER in Forth. Or is that really the case?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: ABC2 does not have stack manipulation commands, but we can create patterns that
    function like stack words, provided we don’t need to preserve the contents of
    the accumulators.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, these ABC2 patterns act like the given Forth word:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run ABC2 in interactive mode and give them a try. Use `;` to show the stack.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The ABC2 examples in this chapter showed repeating patterns of code. This happens
    in all languages—think of the design patterns often used in software development.
    The *multiply.abc2* example, in particular, used several repeating patterns of
    code to push a constant on the stack, get a digit from the user, and multiply
    by 10\. As each command in ABC2 is itself a single character, the patterns become
    words. Space is not an ABC2 command, meaning we could write code with the patterns
    as words, words that, with time, “experienced” ABC2 coders (keep your eye on the
    Help Wanted ads) would learn to recognize.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: For example, one pattern in *multiply.abc2* is `k$c$!^!^-+`, which gets a character
    and adds its digit value to the number already on the stack. This pattern (a sentence?)
    could be written as `k $c$ ! ^!^ - +` to separate the commands into words with
    meaning. Another pattern stored a constant in accumulator B. In one instance,
    the constant was *–*7 to use with `g` for branching in a loop. The other was 48,
    which is the number we needed to subtract from the ASCII character code for a
    digit. Using accumulator B as a constant argues in favor of a language like ABC3,
    where we’d have as many variables as we need.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In the end, ABC and ABC2 are toy languages, as esolangs often are. They are
    fun to think about, fun to implement, and fun to experiment with. They also help
    us appreciate the careful thought that went into designing the programming languages
    we use daily.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced an exceedingly simple esolang called ABC. We took its
    language description, all that implementors generally have to work with, and built
    a Python implementation. We quickly understood the language’s limitations and
    extended it to make ABC2, a language with more capabilities that maintained backward
    compatibility with the original ABC.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We developed a few examples in ABC2 and had some fun with them. We learned how
    to estimate the value of *π* by using random numbers. We then paid tribute to
    an early computer pioneer, Leonardo Torres y Quevedo, with a program mimicking
    his electromechanical arithmometer from 1920\. During that exercise, we learned
    that ABC2 lends itself to coding patterns we might call words (with apologies
    to Forth), and that ABC2 programs could be written as a series of words, that
    is, sentences.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: ABC and ABC2 were perfect introductions to our esolang exploration. Let’s move
    on now to FRACTRAN, perhaps the most intellectually interesting esolang we’ll
    encounter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
