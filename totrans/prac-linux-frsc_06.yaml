- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RECONSTRUCTING SYSTEM BOOT AND INITIALIZATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers the forensic analysis of the Linux system boot and initialization
    process. We’ll examine the early boot stages where the BIOS or UEFI firmware pass
    control to the bootloader, the loading and executing of the kernel, and systemd
    initialization of a running system. Also included here is analysis of power management
    activities like sleep and hibernation, and the final shutdown process of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis of Bootloaders**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditional PCs used a BIOS (basic input/output system) chip to run code from
    the first sector of a disk to boot the computer. This first sector is called the
    *master boot record (MBR)*, and it initiates the process of loading the operating
    system kernel and other components into memory for execution. Modern PCs use the
    *unified extensible firmware interface (UEFI)* to run EFI binary program files
    from a FAT filesystem in the EFI system partition. These UEFI-specific programs
    are run directly by the firmware and manage the process of loading and executing
    the operating system. This section describes forensic artifacts from these early
    boot stages of a Linux system that may be interesting for an investigator.
  prefs: []
  type: TYPE_NORMAL
- en: PC-based Linux systems booting with BIOS or UEFI use software called a *bootloader*
    to start up. The bootloader is responsible for loading the Linux kernel and other
    components into memory, choosing the right kernel parameters, and executing the
    kernel. Non-PC systems may have a completely different boot process. For example,
    the Raspberry Pi doesn’t use BIOS or UEFI, but has its own bootloading mechanism,^([1](footnotes.xhtml#ch06foot_01))
    which is also described here.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Linux PCs overwhelmingly use the *GRand Unified Bootloader (GRUB)* system
    for booting. GRUB replaced the older, more basic loader called LILO (LInux LOader).
    This section focuses primarily on MBR and UEFI booting with GRUB. I’ll cover Raspberry
    Pi booting and briefly describe other bootloaders later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a forensics perspective, we might identify or extract a number of artifacts
    when analyzing the bootloader process, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The installed bootloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evidence of booting more than one operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evidence of multiple Linux kernels previously installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamps of boot files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UUIDs of partitions and filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters passed to the kernel on boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root filesystem location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hibernation image location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootloader password hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EFI system partition contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unusual bootloader binaries (for possible malware analysis)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.xhtml) covered the analysis of partition tables, and even
    though the bootloader and partition tables are closely related, I’ve chosen to
    cover them separately. A comprehensive analysis of bootloader executable code
    is beyond the scope of this book. Analyzing maliciously modified bootloaders involves
    malware reverse engineering, binary code decompilation and disassembly, and execution
    debugging or tracing of code blocks. This topic alone could easily fill an entire
    book, so here I include only the extraction of bootloader components and data
    to be analyzed. The analysis of BIOS settings and EFI variables are operating
    system independent and are mentioned only briefly.'
  prefs: []
  type: TYPE_NORMAL
- en: '***BIOS/MBR GRUB Booting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Booting with an MBR is considered legacy, but it’s still used (often for small
    virtual machines). Modern UEFI mainboards support MBR boots using the *compatibility
    support module (CSM)*.^([2](footnotes.xhtml#ch06foot_02)) Checking the PC’s BIOS/firmware
    settings will indicate whether CSM booting is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](ch06.xhtml#ch06fig01) shows the diagram for Linux GRUB using the
    MBR.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch06fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: GRUB MBR boot data flow*'
  prefs: []
  type: TYPE_NORMAL
- en: The BIOS reads the first sector of a drive and executes the code if the last
    two bytes of sector zero are 0x55 and 0xAA.^([3](footnotes.xhtml#ch06foot_03))
    This signature indicates that it is an MBR. The 64 bytes just before the signature
    are reserved for a DOS partition table consisting of four entries of 16 bytes
    each. The first 446 bytes of an MBR contain executable binary code (written in
    assembly language) that is loaded into memory by the BIOS and executed. When you
    install or update the GRUB MBR, the *boot.img* file is written to sector zero
    (after being modified to the requirements of the system) and is used as the initial
    bootloader code.^([4](footnotes.xhtml#ch06foot_04))
  prefs: []
  type: TYPE_NORMAL
- en: 'GRUB’s MBR contains several searchable strings shown here together with their
    hexadecimal representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `grub-install` program runs `grub-bios-setup` to write the MBR. The 512-byte
    boot sector (*boot.img*) can be extracted using `dd` or with a hex editor that
    supports exporting the sector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in sector zero is responsible for loading the next stage of the bootloader
    code and executing it. This subsequent code is also read directly from sectors
    on the disk; however, it is much larger (tens of kilobytes), giving it the functionality
    to understand partitions and filesystems, and read files. GRUB version 2 calls
    this stage the *core.img*, and it’s assembled from **.img* files and modules in
    the *grub/* directory. This image is created with `grub-mkimage` and written directly
    to the drive sectors when GRUB is installed or updated. The first sector of *core.img*
    is stored in the MBR at byte offset 92 (0x5c) and is 8 bytes long (stored in little-endian
    form on Intel). In DOS-partitioned drives, the *core.img* code is typically located
    in the area between the MBR (from sector 1) and the start of the first partition
    (usually sector 63 or 2048). If this “MBR gap” is not available, the *core.img*
    can be stored elsewhere on the drive and read using a specified list of sectors.
    The first sector of *core.img* contains several searchable strings shown in the
    following example together with their hexadecimal representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `grub-install` program runs `grub-mkimage` to create and write the *core
    .img* to the drive. The size of the *core.img* and the list of sectors used (“block
    list” in the documentation) are specified in the initial sector of *core.img*
    (called *diskboot.img*). The *core.img* sectors can be extracted using `dd` or
    with a hex editor that supports exporting by sector.^([5](footnotes.xhtml#ch06foot_05))
    The *core.img* code finds and reads the *grub.conf* file, loads additional GRUB
    modules, provides the menu system, and performs other GRUB tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '***UEFI GRUB Booting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BIOS/MBR boot process was introduced in the early 1980s with the original
    IBM PC. Around 20 years later, Intel developed a new more advanced firmware and
    boot system for PCs. This evolved into the UEFI standard that defines a modern
    interface between hardware and operating system. It includes a more scalable partitioning
    scheme called *GPT*, a file-based boot partition (instead of a sector-based mechanism)
    called the *EFI System Partition (ESP)*, and many other modern features.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent accidental partition data loss on GPT-partitioned drives, a *protective
    MBR* is installed on sector zero that defines a single maximal DOS partition with
    a type 0xEE, indicating the drive is using GPT partitions. (The GPT partitioning
    scheme is discussed in [Chapter 3](ch03.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: The firmware’s increased sophistication helped reduce the complexity of the
    bootloading process. Unlike MBR, EFI booting does not require writing code blocks
    directly to raw sectors on a drive. Executable code can be placed in regular files
    and simply copied to expected locations on a normal FAT filesystem (the ESP).
  prefs: []
  type: TYPE_NORMAL
- en: A Linux distribution can specify a path in the ESP for a file, such as *EFI/Linux/grubx64.efi*.
    If this file is not found (or the EFI variable is not set), the default file is
    located at *EFI/BOOT/BOOT64.EFI*. This file combines the functionality of both
    the *boot.img* and *core.img* files described in the preceding subsection. [Figure
    6-2](ch06.xhtml#ch06fig02) is a diagram of Linux GRUB using UEFI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch06fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: Grub UEFI boot data flow*'
  prefs: []
  type: TYPE_NORMAL
- en: A mainboard with UEFI support contains more interesting forensic evidence than
    traditional BIOS/MBR mainboards. The firmware contains persistent EFI variables,
    including information about current and previously installed operating systems,
    boot order, secure boot information, asset and inventory tags, and more (it’s
    generic and can be used to store any variables). Extracting and analyzing EFI
    variables from a mainboard’s NVRAM variables is beyond the scope of this book.
    GRUB detects whether a system is booting with UEFI or MBR and can install on both
    as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a forensics perspective, it’s important to identify and analyze suspicious
    binaries found in the ESP partition. ESP has been used for both exploitation and
    as a forensic technique for extracting memory. WikiLeaks has published leaked
    documents related to EFI and UEFI from Vault 7: CIA Hacking Tools Revealed (*[https://wikileaks.org/ciav7p1/cms/page_26968080.html](https://wikileaks.org/ciav7p1/cms/page_26968080.html)*).
    Academic research work has been done to describe the use of UEFI binaries for
    dumping memory images (*[https://www.diva-portal.org/smash/get/diva2:830892/FULLTEXT01.pdf](https://www.diva-portal.org/smash/get/diva2:830892/FULLTEXT01.pdf)*).'
  prefs: []
  type: TYPE_NORMAL
- en: '***GRUB Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The GRUB differences between MBR and UEFI are primarily found in the installation
    process (writing sectors for MBR versus copying files and setting EFI variables
    for UEFI). However, the configuration between the two is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration revolves around the *grub.conf* file, which is stored in
    different places depending on the distribution. Here are several typical locations
    where the *grub.conf* might be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/boot/grub/grub.cfg*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/boot/grub2/grub.cfg*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*EFI/fedora/grub.cfg* (on the UEFI FAT filesystem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes a Linux system will have a separate small filesystem mounted on */boot/*
    where the GRUB configuration files are saved.
  prefs: []
  type: TYPE_NORMAL
- en: The *grub.cfg* file is not usually modified by hand, but rather generated from
    the `grub-mkconfig` script (`update-grub` on some systems). These scripts read
    configuration variables from the */etc/default/grub* file and include helper scripts
    from the */etc/grub.d/* directory. The files */etc/grub.d/40_custom* and */boot/grub/custom.cfg*
    (if they exist) are intended for additional customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files mentioned here may contain changes and customization made by a system
    administrator and should be analyzed during a forensic examination. The following
    is a sample */etc/default/grub* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The */usr/bin/grub-mkconfig* shell script^([6](footnotes.xhtml#ch06foot_06))
    contains all the variables that can be defined (look for the `GRUB_*` lines inside
    the script). The `GRUB_CMDLINE_*` variables are interesting because they contain
    information passed to the kernel. The other variables are processed by the helper
    scripts. On some systems, like Fedora and SUSE, */etc/sysconfig/grub* may be symbolically
    linked (symlinked) to */etc/default/grub*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting *grub.cfg* file consists of multiple sections generated from
    each of the helper scripts. GRUB has a built-in scripting language used to parse
    more complex *grub.cfg* files and provide an elaborate menu and submenu interface
    for a user to choose boot options. Here is an example of the menu options found
    in a sample *grub.cfg* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: During a forensic examination, the `menuentry` and `submenu` lines will potentially
    reveal other operating systems, past versions of other operating systems, and
    other setup/diagnostic options. For each of the menu options, the parameters passed
    to the kernel are defined, including current and past root UUIDs and the location
    of hibernation images (`resume=`). These are of interest in a Linux forensic examination
    because they provide a reconstruction of OS installation activity on the drive.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, Linux users would dual-boot their machines into different operating
    systems, but it is becoming more common to use virtual machines inside one host
    operating system. As a result, not all installed operating systems will be detected
    by the GRUB configuration scripts and visible in the *grub.cfg* file.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to loading the kernel and initramfs binary images (described in
    the next section), GRUB can also load CPU firmware updates (from the same directory),
    which are typically *ucode.img* for Intel and *amd-ucode.img* for AMD.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, a GRUB password may be found. If this password is only to control
    access during boot, it won’t affect our ability to image or analyze the system
    in a forensic context. The following example (as generated by SUSE scripts) shows
    a password-protected *grub.cfg* entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another feature of GRUB is the ability to request a password to unlock a LUKS-encrypted
    root filesystem during the bootloading process (see the section on LUKS encryption
    in [Chapter 3](ch03.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the grub scripting language used in *grub.cfg*, file formats, design
    details, and much more in the online manual (*[https://www.gnu.org/software/grub/manual/grub/](https://www.gnu.org/software/grub/manual/grub/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Bootloaders***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SYSLINUX is a bootloader designed to boot from a DOS/Windows filesystem making
    it easier for new Linux users to install Linux or test a live system. It is also
    sometimes used for booting Linux rescue images. A SYSLINUX image can be identified
    by the existence of the *LDLINUX.SYS* file in the root directory. In addition,
    a *syslinux.cfg* configuration file may be located in the root (/) directory or
    the */boot/* or */syslinux/* subdirectories. This file determines how SYSLINUX
    behaves and may include (using the `INCLUDE` configuration parameter) other configuration
    files. These files contain information like menu options, the location of the
    kernel image and initial ramdisk, the kernel command line, and other defined variables.
  prefs: []
  type: TYPE_NORMAL
- en: SYSLINUX files are located on a FAT filesystem that can be analyzed with regular
    filesystem forensic tools. Within the same software project, the ISOLINUX, EXTLINUX,
    and PXELINUX variants are also available for booting from optical discs, Linux
    filesystems, and network booting with PXE (using DHCP and TFTP). See the project’s
    website (*[https://www.syslinux.org/](https://www.syslinux.org/)*) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The systemd developers created an alternative UEFI bootloader and manager called
    systemd-boot (formerly known as Gummiboot), which was designed to provide a simple
    menu system, basic configuration files, and other features. One characteristic
    of systemd-boot is the expectation that the kernel and initial ramdisk images
    reside in the EFI system partition. The mainboard’s NVRAM stores a number of systemd-boot-related
    EFI variables. The UEFI firmware executes `systemd-bootx64.efi`, an EFI binary
    that looks for the default configuration file *loader/loader.conf*. Further configuration
    for booting multiple operating systems is found in *loader/entries/** (typically
    one directory per operating system boot option). From a digital forensics perspective,
    the entire bootloading process and files are all contained within a single FAT
    filesystem that can be analyzed using common FAT filesystem forensic tools to
    identify timestamps and evidence of deleted files. For more information, see the
    systemd-boot(7) man page and the Boot Loader Specification document (*[https://systemd.io/BOOT_LOADER_SPECIFICATION/](https://systemd.io/BOOT_LOADER_SPECIFICATION/)*).
  prefs: []
  type: TYPE_NORMAL
- en: Diskless systems may use the Preboot eXecution Environment (PXE) to boot the
    operating system over the network. Here the mainboard firmware makes DHCP requests
    to the local network segment and then fetches the bootloader, kernel, and initramfs.
    The root filesystem is then mounted via NFS or other network file-sharing protocol.
    A netbooting machine might still have a local drive for caching or swap, which
    can be analyzed. If no physical drive is installed, all forensic evidence (operating
    system filesystem tree, home directories, and so on) will reside on the PXE server.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi does not use MBR, UEFI, or even GRUB for booting, relying instead
    on its own multistage boot process.^([7](footnotes.xhtml#ch06foot_07)) The first
    stage of the bootloader is code in the ROM, which loads the second stage *bootcode.bin*
    file (this file is stored in the EEPROM of Raspberry Pi 4 models). The third stage
    (*start*.elf* ) is a binary firmware image that finds and starts the kernel. Potentially
    interesting artifacts are the user configurable settings in several files in the
    */boot/* directory. The *cmdline.txt* file specifies parameters that are passed
    to the kernel. The *settings.conf* file specifies the parameters for the bootloaders
    to configure the Raspberry Pi during startup. A *wpa_supplicant.conf* file that
    contains a Wi-Fi network and password may also exist. If an *ssh* or *ssh.txt*
    file existed during the first boot, a systemd unit (*/lib/systemd/system/sshswitch.service*)
    would enable SSH and remove the file. These are documented at the official Raspberry
    Pi website (*[https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/)*).
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning Linux containers and how they boot. Because containers
    are started from within a running Linux host system and share the same kernel
    as the host, they don’t need a bootloader. A Linux system can be booted in a container
    with a separate filesystem tree using commands provided by the container manager
    (LXC, systemd-nspawn, and so on). Forensic analysis here may involve the examination
    of both the hosting system and the container’s file tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis of Kernel Initialization**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux kernel is modular and configurable. Kernel modules can be built into
    the kernel at compile time, dynamically loaded at boot or during operation, or
    manually loaded by the user. The configuration of the core kernel and modules
    can be done during boot, when loading a module (`modprobe`) or manually by the
    user. In this section, I describe how to identify which modules were loaded and
    how the kernel is configured.
  prefs: []
  type: TYPE_NORMAL
- en: The modules loaded and the configured state of the kernel change dynamically
    during operation and are visible only while the machine is running. Postmortem
    forensic analysis must be done through induction or inference because we can’t
    observe the running kernel (unless we have a memory image). This section focuses
    on the modules and configuration defined at boot time and attempts to find traces
    of other changes during operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a forensic context, knowing the kernel’s configuration and loaded modules
    helps us reconstruct the state of the machine under analysis, which helps us answer
    various questions and identify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-default kernel modules loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default kernel modules prevented from being loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel configuration explicitly defined or changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit changes manually made by a system administrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes introduced by malicious actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are especially interested in the modules and configuration that deviate from
    the defaults of the distribution or installed software packages. If we can identify
    non-default, explicit, or deliberate activity, we can try to determine why and
    how these changes happened.
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel Command Line and Runtime Parameters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The kernel is just a program, albeit a unique and special one. Like most programs,
    it can be started with parameters to provide some initial configuration. These
    parameters, sometimes called the *kernel command line*, are provided by the bootloader
    and passed to the kernel at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel command line parameters configure several parts of the system during
    boot, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Core kernel parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters for modules built in to the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Init system parameters (`systemd pid 1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel understands multiple parameters that allow it to configure itself
    when executed. Built-in kernel modules can be configured using a dot (`.`) separating
    the module name and the module parameter; for example, `libata.allow_tpm=1`. Parameters
    specified for loadable modules may be handled by the startup scripts and units
    of the init process. Parameters that the kernel is unable to understand are passed
    on to the init system, either as command parameters or as environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: On a running system, the command line is found in */proc/cmdline*; however,
    for a postmortem investigation, we must find evidence in persistent storage. Because
    the bootloader passes the command line to the kernel, the parameters are likely
    stored in the bootloader configuration (which we covered in the previous section).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the GRUB bootloader, the kernel command parameters are typically found
    in the */boot/grub/grub.cfg* file (some distros use a *grub2* directory). Look
    for a line (possibly indented) that starts with `linux` followed by the path to
    a kernel image. The parameters are listed after the kernel image filename, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the root filesystem is defined (`root=UUID=...`), the hibernate
    partition is defined (`resume=UUID=...`), a parameter for the built-in `libata`
    module is configured (`libata.allow_tpm=1`), a core kernel parameter is configured
    (`intel_iommu=on`), and network configuration is passed on to systemd init (`net.ifnames=0`).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the *grub.cfg* file is typically generated with scripts.
    These scripts read the */etc/default/grub* file for additional kernel parameters
    defined in `GRUB_CMDLINE_*` variables. For systemd-boot, the kernel parameters
    are defined in the *loader/entries/** files. On Raspberry Pi systems, the user-configurable
    kernel command line is stored in */boot/cmdline.txt* (the boot process may add
    additional parameters before starting the kernel). The kernel-command-line(7)
    man page describes additional parameters that are interpreted by the systemd initialization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Potentially interesting forensic artifacts on the kernel command line are:'
  prefs: []
  type: TYPE_NORMAL
- en: The name and location of the kernel image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location (and possible UUID) of the root filesystem (`root=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location of a potential hibernation memory dump (`resume=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration of modules to be loaded (`module.parameter=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible alternative init^([8](footnotes.xhtml#ch06foot_08)) program (`init=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other kernel configuration indicating the use of certain hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible indicators of manipulation or abuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the kernel command line gives the investigator a more complete
    understanding of the Linux system under examination. See the bootparam(7) man
    page and the Linux kernel documentation (*[https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)*)
    for a list of commands and further information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modules add kernel functionality to manage filesystems, network protocols, hardware
    devices, and other kernel subsystems. Modules can be statically built in to the
    kernel at compile time or dynamically added to a running kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the modules statically compiled into the kernel, we can view the */lib/modules/*/modules.builtin*
    file for the installed kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because these modules are static on the filesystem, they are easy to identify
    and examine in a postmortem forensic analysis. There may also be multiple kernels
    installed that can be compared to one another as well as with the original files
    in the distribution’s release.
  prefs: []
  type: TYPE_NORMAL
- en: Modules inserted and removed dynamically can be identified from the boot configuration
    and available logs. To determine the modules loaded at boot time, we can examine
    configuration files in several places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The systemd initialization process provides the `systemd-modules-load` `.service`
    to load kernel modules during boot. A local user (or system administrator) can
    explicitly load modules at boot by placing configuration files in */etc/modules-load.d/*.conf*.
    Software packages that provide their own configuration to load modules explicitly
    can be found in */usr/lib/modules -load.d/*.conf*. Here is an example of a configuration
    file to load modules for the CUPS printing system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See the systemd-modules-load(8) and modules-load.d(5) man pages for more information.
  prefs: []
  type: TYPE_NORMAL
- en: There are other places to look for evidence of kernel module loading/ unloading
    activity. Some distributions (Debian-based, for example) may have an */etc/modules*
    file containing a list of additional modules to be loaded at boot time. The shell
    history files (for both root and non-root users possibly using `sudo`) can be
    searched for evidence of commands, such as `modprobe`, `insmod`, or `rmmod` to
    identify modules inserted or removed by a user. The kernel command line may be
    used to load modules during the early boot process (by systemd). These command
    line options are `modules_load=<modulename>` or `rd.modules_load=<modulename>`;
    the latter refers to the initial RAM disk (rd).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inserting and removing modules in the kernel may or may not generate log entries.
    The amount of logging is up to the module’s developer. For example, the `i2c_dev`
    driver prints nothing when removed from the kernel, and prints only minimal information
    when inserted. Here’s the log entry in dmesg:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If kernel module log information is generated (via the kernel ring buffer),
    it will typically be passed to dmesg, syslog, or the systemd journal. See [Chapter
    5](ch05.xhtml) for more information about examining kernel messages.
  prefs: []
  type: TYPE_NORMAL
- en: During a forensic examination, these module configuration files and directories
    should be reviewed for unusual or unexplained kernel modules. In particular, modules
    that deviate from the distribution and software package defaults should be examined.
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel Parameters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The initial kernel configuration is set during system startup, with dynamic
    reconfiguration occurring later based on the needs of the system over time. Some
    examples of dynamically changing configuration might include adding, removing,
    or modifying hardware; changing network settings; mounting filesystems; and so
    on. Even the hostname is a kernel configuration setting that is set during system
    boot. Forensic analysis here involves reconstructing the kernel’s configuration
    at boot time and determining changes that happened over time during system operation.
    In particular, we’re interested in configuration that deviates from normal defaults,
    possibly introduced by the user or a malicious actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel parameters can also be specified manually at runtime. On a running system,
    the system administrator can read and write kernel parameters with the `sysctl`
    command or by redirecting text to/from the appropriate pseudo-files in the */proc/sys/*
    directory. In a postmortem forensic investigation, we can search for evidence
    of the `sysctl` command in the shell history files or in logs indicating that
    `sysctl` was used with privilege escalation. The following example shows a non-privileged
    user (Sam) setting a kernel parameter with the sysctl `-w` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This user enabled IPv6 packet forwarding. If an organization focused only on
    managing IPv4 security, this action could be a malicious attempt to bypass network
    controls or reduce the chances of detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel parameters can also be set at boot time by adding them to configuration
    files. These follow the typical Linux convention of a configuration file in */etc/*
    and directories for additional configuration files and are located in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/sysctl.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/sysctl.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/usr/lib/sysctl.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system administrator will typically make changes to *sysctl.conf* or create
    files in the */etc/sysctl.d/* directory. Installed packages requiring kernel configuration
    may also place configuration files in the */usr/lib/sysctl.d/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: During a forensic investigation, files and directories providing sysctl configuration
    should be reviewed for unusual or unexplained kernel settings. Custom modifications
    and deviations from the distribution defaults can be found by comparing them to
    the original files. The creation and last modified timestamp on the files is a
    potential indicator of when the changes took place. Manual kernel setting changes
    may provide additional insight into an investigation (for example, changes could
    indicate the manual installation of a particular hardware device at some point
    in the past).
  prefs: []
  type: TYPE_NORMAL
- en: See the sysctl(8), sysctl.conf(5), and sysctl.d(5) man pages for more information
    about sysctl.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing initrd and initramfs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The kernel binary executable is typically called vmlinuz^([9](footnotes.xhtml#ch06foot_09))
    and is usually found in the */boot/* directory. It may also be a symlink to a
    filename with version information (for example, *vmlinuz-5.4.0-21-generic*). You
    will typically find a companion file called *initrd* or *initramfs* (sometimes
    with the **.img* extension). These files may also be symlinks to filenames with
    version information (for example, *initrd.img-5.4.0-21-generic* or *initramfs-5.4-x86_64.img*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *initrd* and *initramfs* files solve a chicken-or-egg problem when the
    kernel boots. The kernel needs various files, utilities, and modules to mount
    the root filesystem, but those items are located on the root filesystem that can’t
    be mounted yet. To solve this problem, the bootloader loads a temporary minimal
    root filesystem containing all the required files into memory and provides it
    to the kernel as a RAM disk. This is called the *initial RAM disk*, and it comes
    in two forms: initrd and initramfs (see the initrd(4) man page for more information).
    The initial RAM disk file is created with scripts, usually run by bootloader tools
    (mkinitramfs, mkinitcpio, or dracut) during installation or when the kernel is
    changed or upgraded.'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel runs the init program found inside the initramfs (parameters can
    be passed on the kernel command line), and the initial setup begins. Some distros
    use busybox^([10](footnotes.xhtml#ch06foot_010)) as the init program within the
    initramfs. Others, often dracut-based,^([11](footnotes.xhtml#ch06foot_011)) use
    systemd init. When finished, there is a switch to the main root filesystem and
    execution is passed to the main init system to begin the full system startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a forensics perspective, the contents of the initial RAM disks may contain
    interesting information about the system and the boot process, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Possible file timestamps (though some systems set files to the Unix epoch, January
    1, 1970)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of executables and kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files (like */etc/fstab*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts (startup, custom, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about RAID configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about encrypted filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kiosk and IoT device custom startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For cases involving encrypted filesystems, the initial RAM disk may be the only
    unencrypted data available to analyze. There could also be information about the
    decryption process and location of keys.
  prefs: []
  type: TYPE_NORMAL
- en: If commercial forensic tools cannot access the contents of initial RAM disk
    files, an investigator can copy the file to a similar Linux distribution and use
    Linux commands to perform the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, listing the contents of an Arch Linux *initramfs* file using `lsinitcpio`,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `lsinitcpio` command also provides a useful analysis summary with the `-a`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing the contents of a Debian *initrd* file using `lsinitramfs` looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Fedora and SUSE have a similar tool called `lsinitrd` to list the contents of
    the initial RAM disk files.
  prefs: []
  type: TYPE_NORMAL
- en: 'After listing the contents of the files, it may be useful to extract files
    for further analysis. One easy way to do this is to extract everything into a
    separate directory using the `unmkinitramfs` or `lsinitcpio` tools, depending
    on the Linux distribution. Here is an example of extracting an *initrd* file on
    a Debian system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On an Arch system, the same `lsinitcpio` command can be used, but with the
    `-x` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, `unmkinitramfs` and `lsinitcpio` will extract the contents
    into the current directory and thus expect to have write permission. For a postmortem
    examination, the file being analyzed can be copied to a separate analysis system.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be possible to analyze these files with regular commercial forensic
    tools without a Linux system. The files are typically compressed CPIO archives
    using gzip or zstd. The file can be decompressed first and then handled as a normal
    CPIO archive (a standard Unix format, similar to tar). These two examples list
    an *initramfs*’s contents by piping from a compression program (`gunzip` or `zstcat`)
    into the `cpio` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Removing the `t` flag from the `cpio` flags will extract the contents into the
    current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bootloader can also load CPU microcode updates in a similar way to *initrd*
    files. These may also be packaged as CPIO files (but not compressed), and the
    contents can be listed with the `cpio` command. Two examples with Intel and AMD
    processors are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The timestamps in these files may vary. They can be from the original packaging
    process or from the local install process.
  prefs: []
  type: TYPE_NORMAL
- en: Some *initramfs* files (Red Hat, for example) contain a single archive for firmware
    and initramfs (appended to each other). To extract the second one, use the `skipcpio`
    tool from the dracut software package.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi operates differently and doesn’t need an initial RAM disk.
    Because the hardware is standard, Raspberry Pi developers can create a specific
    kernel with all the necessary drivers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis of Systemd**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a digital forensics perspective, we want to understand what the system
    was doing during startup, how it appears in a fully booted target state, and what
    activity has taken place over time. In particular, we are reconstructing configuration
    and activity that deviates from the default distro behavior. This includes configuration
    explicitly created by a system administrator, installed software packages, or
    possibly a malicious process or attacker.
  prefs: []
  type: TYPE_NORMAL
- en: The most common Linux initialization system is systemd. Since its original announcement
    in 2010, systemd has been adopted by every major Linux distribution, replacing
    the traditional Unix sysvinit and other distro-specific alternatives like Upstart
    from Ubuntu. Systemd is fundamentally different from traditional Unix and Linux
    init systems, and its introduction was not without controversy.
  prefs: []
  type: TYPE_NORMAL
- en: This section focuses on the systemd system initialization process. When performing
    a postmortem forensic analysis, we want to reconstruct essentially the same information
    provided by systemd commands on a running system (like `systemctl`, for example),
    which we can do by examining the systemd files and directories on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd is very well documented. The systemd.index(7) man page has a list of
    all the systemd man pages (more than 350). For forensic investigators unfamiliar
    with Linux, these man pages are the best and most authoritative source of information
    on systemd.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Warning: systemd makes extensive use of symlinks. If you mount a suspect Linux
    filesystem on your examination Linux machine, the symlinks may point to your own
    installation and not the suspect drive. Make sure you are analyzing the right
    files on the suspect filesystem during a forensic examination.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Systemd Unit Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Systemd uses configuration files to initialize the system and manage services.
    This is a fundamental change from traditional Unix and Linux init systems that
    used shell scripts to achieve similar goals.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd uses the concept of *units* to control how a system is started or services
    are run. Units have associated text files called *unit configuration files*. Unit
    file content is organized into sections, with each section containing directives
    or options that are set by the system administrator, package maintainer, or distro
    vendor. Unit files are not only used for system startup, but also for operational
    maintenance (start, stop, restart, reload, and so on) and system shutdown. More
    information can be found in the systemd(1) and bootup(7) man pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows systemd’s 11 different unit types, listed with the
    objects they control and the man page describing the unit file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service** For programs or daemons; systemd.service(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket** For IPC and sockets; systemd.socket(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target** Groups of units; systemd.target(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Device** For kernel devices; systemd.device(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mount** Filesystem mount points; systemd.mount(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automount** Filesystem on-demand mounting; systemd.automount(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timer** Time-based unit activation; systemd.timer(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swap** Swap partitions or files; systemd.swap(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Path** Unit activation based on file changes; systemd.path(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slice** Units grouped for resource management; systemd.slice(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope** Units grouped by process parent; systemd.scope(5)'
  prefs: []
  type: TYPE_NORMAL
- en: Unit files are normal text files with a filename describing the unit and extension
    matching the type (*httpd.service* or *syslog.socket*, for example). A unit may
    also have an associated **.d* directory containing **.conf* files that provide
    additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Unit files can have `[Unit]` and `[Install]` sections with options that describe
    the unit’s basic behavior and provide generic unit settings (see the systemd.unit(5)
    man page). All unit files except *target* and *device* have a self-titled section
    name with additional options that are specific to that unit type. For example,
    *service* has a `[Service]` section, *socket* has `[Socket]`, and so on. The *service*,
    *socket*, *swap*, and *mount* units have additional options that specify paths,
    users, groups, permissions, and other options relevant to the execution environment
    (see the systemd.exec(5) man page). The *service*, *socket*, *swap*, *mount*,
    and *scope* units have additional kill options that describe how processes belonging
    to a unit are terminated (see the systemd.kill(5) man page). The *slice*, *scope*,
    *service*, *socket*, *mount*, and *swap* units have additional resource control
    options that specify CPU and memory usage, IP network access control,^([12](footnotes.xhtml#ch06foot_012))
    and other limits (see the systemd.resource-control(5) man page). All available
    systemd options, variables, and directives (more than 5,000!) are listed together
    on the systemd.directives(7) man page. When examining unit files, this index should
    provide you with the documentation needed to understand the individual options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a typical service unit file. It was installed from
    the xorg-xdm package provided by the distro and provides a graphical login screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `[Unit]` section provides a description and dependency information. The
    `[Service]` section defines the command to run and other options described in
    the systemd.service(5) man page. The `[Install]` section provides information
    needed to enable or disable the unit.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd can operate as a *system* instance (during init and system operation)
    or as a *user* instance (during a user login session). Users can create and manage
    their own systemd unit files. System administrators with privileged access can
    manage the systemd system unit files. When forensically examining a Linux system,
    you need to know where to look for unit files. These are created and saved in
    several common locations.
  prefs: []
  type: TYPE_NORMAL
- en: Unit files installed by a distro’s packaging system are located in the */usr/lib/systemd/system/*
    directory (some distros may use */lib/systemd/system/*). Unit files installed
    by a system administrator or those created during system configuration are typically
    installed in */etc/systemd/system/*. Files created by the system administrator
    in the */etc/systemd/system/* directory take precedence over those in the */usr/lib/systemd/system/*
    directory. Unit files that are not part of any installed package are interesting
    because they were explicitly added by an administrator or potentially malicious
    privileged process.
  prefs: []
  type: TYPE_NORMAL
- en: User unit files can be created by the distro’s packaging system, a system administrator,
    or the users themselves. The distro’s user unit files are found in the */usr/lib/systemd/user/*
    directory, and the system administrator’s user unit files are found in the */etc/systemd/user/*
    directory. Users may place their own unit files in *~/.config/systemd/user/* of
    their home directory. User unit files are used during a user’s login session.
  prefs: []
  type: TYPE_NORMAL
- en: From a forensics perspective, a user’s own unit files are interesting, as they
    could have been created from a running program, explicitly by hand, or from malicious
    activity targeting the user. See the systemd.unit(5) man page for a full list
    of where systemd searches for unit files.
  prefs: []
  type: TYPE_NORMAL
- en: If a unit file is empty (zero bytes) or symlinked to */dev/null*, it is considered
    to be *masked*, which means it cannot be started or enabled. On a running system,
    unit directories can be found in the */run/systemd/* pseudo-directory; however,
    they exist only in the running system’s memory, so they won’t be available during
    a postmortem forensic examination.
  prefs: []
  type: TYPE_NORMAL
- en: '***Systemd Initialization Process***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the kernel has started and mounted the root filesystem, it looks for the
    init program (typically symlinked to */lib/systemd/systemd*) to initialize the
    system’s userspace. When systemd starts, it reads the */etc/systemd/system.conf*
    file to configure itself. This file provides various options to change how systemd
    behaves. Here is part of a *system.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The default file lists all the compile time default entries, but they’re commented
    out (using the `#`). A system administrator may deviate from these defaults by
    modifying or adding entries. This file configures logging, crashing, various limits,
    accounting, and other settings. See the systemd-system.conf(5) man page for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'When other systemd daemons start (or reload), they also read various */etc/systemd/*.conf*
    configuration files. Some examples of these files are listed here by their man
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: systemd-user.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: logind.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: journald.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: journal-remote.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: journal-upload.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: systemd-sleep.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: timesyncd.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: homed.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: coredump.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: resolved.conf(5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The systemd.syntax(7) man page calls these *daemon config files*, which shouldn’t
    be confused with unit files. Typically, these config files (including *system.conf*
    ) will also have a list of default options, which are commented out (with `#`).
    In a forensic examination, look for `*.conf` entries that have been uncommented
    or added. These indicate explicit changes made by the system owner.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Unix and Linux systems have *run levels*, where a system can be
    brought up into different states of operation (single user, multiuser, and so
    on). Systemd has a similar concept called *targets*. A target is reached when
    a defined group of units have successfully become active. The primary purpose
    of targets is to manage dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When systemd boots, it starts all the units needed to achieve the default target
    state. The default target is the *default.target* unit file, which is usually
    a symlink to another target such as *graphical.target* or *multi-user.target*.
    Some common target states that Linux systems have include:'
  prefs: []
  type: TYPE_NORMAL
- en: '***rescue.target*** Single-user mode, for sysadmins, no users, minimal services'
  prefs: []
  type: TYPE_NORMAL
- en: '***sysinit.target*** **and** ***basic.target*** Set up swap, local mount points,
    sockets, timers, and so on'
  prefs: []
  type: TYPE_NORMAL
- en: '***multi-user.target*** A fully booted system without the graphical interface
    (typical for servers)'
  prefs: []
  type: TYPE_NORMAL
- en: '***graphical.target*** A fully booted graphical system'
  prefs: []
  type: TYPE_NORMAL
- en: '***default.target*** The default, usually a symbolic link to multiuser or graphical
    targets'
  prefs: []
  type: TYPE_NORMAL
- en: '***shutdown.target*** Cleanly brings the system down'
  prefs: []
  type: TYPE_NORMAL
- en: The systemd standard targets are described in the systemd.special(7) and bootup(7)
    man pages. The traditional Unix-style boot is described in the boot(7) man page.
    The default target can be overridden by explicitly providing another target name
    on the kernel command line (`systemd.unit=`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit files contain information about dependency relationships to other unit
    files or targets. These are defined in the `[Unit]` and `[Install]` sections.
    During startup, the `[Unit]` section defines the dependencies and how a unit behaves
    if those dependencies have failed. The following list shows some common dependency
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Wants= | Other units wanted by this unit (continue if they failed) |'
  prefs: []
  type: TYPE_TB
- en: '| Requires= | Other units required by this unit (fail if they failed) |'
  prefs: []
  type: TYPE_TB
- en: '| Requisite= | Fail if other units are not already active |'
  prefs: []
  type: TYPE_TB
- en: '| Before= | This unit must be activated before these others |'
  prefs: []
  type: TYPE_TB
- en: '| After= | This unit must be activated after these others |'
  prefs: []
  type: TYPE_TB
- en: An alternative to the `Wants=` and `Requires=` options is to place unit files
    or symlinks to unit files in the **.wants/* or **.requires/* directories.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the *default.target* unit file, it is possible to work backward
    and build a list of all started unit files based on the `Requires=` and `Wants=`
    configuration entries or **.wants/* and **.requires/* directories. This approach
    requires an exhaustive manual examination, which may be necessary in some investigations.
    If you want to assess only what services have been created or enabled by the system
    administrator under normal circumstances, analyze the */etc/systemd/system/* directory
    for the existence of unit files (or symlinks to unit files).
  prefs: []
  type: TYPE_NORMAL
- en: Options in the `[Install]` section of a unit file are used to enable or disable
    a unit with the `systemctl` command. This section is not used by systemd during
    startup. The `[Install]` dependencies can be defined with `WantedBy=` or `RequiredBy=`
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '***Systemd Services and Daemons***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *daemon* (pronounced either dee-men or day-mon) originates from Unix and describes
    a process running in the background. Systemd starts daemons using a **.service*
    unit file that includes a `[Service]` section to configure how the daemon is started.
    Daemons can also be started on demand using various forms of activation (described
    in the next section). The words *service* and *daemon* are often used interchangeably,
    but in the context of systemd, there are differences. A systemd service is more
    abstract, can start one or more daemons, and has different service types.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Starting and stopping a service is not the same as enabling and disabling
    a service. If a service is* enabled*, it will automatically start at boot time.
    If* disabled*, it will not start at boot time. Services can be started and stopped
    by a system administrator during system operation, independent of the enabled/disabled
    state. A* masked *service can’t be started or enabled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Daemons under systemd are slightly different from traditional Unix daemons because
    their terminal output (`stdout` and `stderr`) is captured by the systemd journal.
    See *[https://www.freedesktop.org/software/systemd/man/daemon.html](https://www.freedesktop.org/software/systemd/man/daemon.html)*
    for a detailed comparison between systemd and traditional daemons.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example unit file (`sshd.service`) manages the secure shell daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This file describes how to start, stop, and reload the daemon, and also when
    it should be started.
  prefs: []
  type: TYPE_NORMAL
- en: On a live system, units can be active or inactive (that is, started or stopped),
    and their status can be checked with the `systemctl status` command. On a forensic
    image, we can determine only whether a unit is enabled or disabled at startup
    (obviously, nothing is active on a dead system). When a system administrator explicitly
    enables a service, a symlink is created in */etc/systemd/ system/* or in a **.target.wants/*
    directory. Examining all the symlinks in these directories will indicate which
    services are started for each target.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example *sshd.service* unit file in the preceding code block, we can
    determine that the secure shell daemon is enabled by observing the symlink created
    in the multi-user target’s **.wants/* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can also see from the timestamps when the symlink was created, indicating
    when the service was last enabled. The timestamps on the original file */usr/lib/systemd/system/sshd.service*
    indicate when the service file was last installed or upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting and stopping of services is logged. The following example shows
    the secure shell daemon being stopped and started (restarted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The systemd journal does not log information about enabling or disabling services
    aside from a simple `systemd[1]: Reloading` message. An examination of the file
    timestamps on the symlink will determine when services were enabled. If services
    were enabled with `systemctl`, the timestamps should correlate with the systemd
    reloading log entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Activation and On-Demand Services***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The concept behind on-demand services is simply that a background process or
    daemon is not started until the moment it is needed. Services and daemons can
    be triggered in various ways, including by D-Bus, socket, path, and device activation.
    Service activation can be used in a system context or be specific to individual
    users. Activation is typically logged and can be examined in a forensic investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket Activation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Socket activation is the starting of services based on incoming FIFO, IPC,
    or network connection attempts. Traditional Unix-style activation used a daemon
    called inetd (or the xinetd alternative) to listen on multiple incoming TCP and
    UDP ports and start the appropriate daemon when a network connection was attempted.
    Today, systemd’s **.socket* unit files provide the same functionality. In the
    following example, PipeWire^([13](footnotes.xhtml#ch06foot_013)) is configured
    to be socket activated if a user needs it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the user’s runtime directory (`%t`) is selected as the location of the
    `pipewire-0` listening pipe. If it is accessed, a service with the same name is
    activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ExecStart` option then runs the `pipewire` program. Notice how two unit
    files are used, one for the socket activation and one for the actual service.
    See the systemd.socket(5) man page for more information, and see [Chapter 8](ch08.xhtml)
    for network service examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**D-Bus Activation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The D-Bus^([14](footnotes.xhtml#ch06foot_014)) is both a library and daemon
    (`dbus-daemon`) that facilitates communication between processes. The D-Bus daemon
    can run as a system-wide instance or as part of a user login session. Several
    common directories are associated with D-Bus configuration that can be examined
    on a suspect drive image:'
  prefs: []
  type: TYPE_NORMAL
- en: '***/usr/share/dbus-1/*** Package default configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '***/etc/dbus-1/*** Sysadmin-specified configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '***~******/.local/share/dbus-1/*** User-specified configuration'
  prefs: []
  type: TYPE_NORMAL
- en: These directories (if they exist) may contain system and session configuration
    files, XML definition files, and service files specifying activation details.
  prefs: []
  type: TYPE_NORMAL
- en: The `dbus-daemon` manages D-Bus activity, activates services on request, and
    logs activity to the systemd journal. Once a D-Bus service is requested, the service
    is activated either directly or via systemd. See the dbus-daemon(1) man page for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logging of D-Bus activation shows several items that are interesting in
    reconstructing past events. In this example, a D-Bus request is made to activate
    the PolicyKit service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the D-Bus daemon (shown with its PID) ➊ generates the log and asks systemd
    ➋ to start the policykit service ➌. The originator of the activation request is
    also logged ➍ (`systemd-logind` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Services that are D-Bus aware may also shut down after a period of inactivity.
    In this example, the GeoClue service is started by D-Bus activation, and the service
    terminates itself after 60 seconds of inactivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Path-Based Activation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Path-based activation uses a kernel feature called inotify that allows the
    monitoring of files and directories. The **.path* unit files define which files
    to monitor (see the systemd.path(5) man page). A **.service* file with the same
    name is activated when the path unit file’s conditions are met. In this example,
    a *canary.txt* file is monitored to detect possible ransomware. The canary file,
    path unit, and service unit are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Two unit files, *canary.path* and *canary.service*, are located in the user’s
    *~/.config/systemd/user/* directory and define the path-activated service. If
    the file is modified, the service is started and the command executed, which is
    shown in the journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, the logs show the canary service starting, executing (the logger command
    output), and finishing (`Succeeded`). A user must be logged in for their own unit
    files to be active.
  prefs: []
  type: TYPE_NORMAL
- en: '**Device Activation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Device activation uses the udev dynamic device management system (the `systemd-udevd`
    daemon). The appearance of new devices observed by the kernel can be configured
    to activate service unit files. The **.device* unit files described in the systemd.device(5)
    man page are created dynamically on a running kernel and aren’t available during
    a postmortem forensic examination. However, we can still examine systemd device
    activation configured in the udev rule files and the journal. For example, a rule
    file (*60-gpsd.rules*) defines a systemd service to run when a particular GPS
    device (pl2303) is plugged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the udev rule is tagged with systemd ➊ and the `SYSTEMD_WANTS`
    ➋ environment variable specifies the `gpsdctl@.service` template with `%k` representing
    the kernel name of the device (it will become `ttyUSB0`). The service template
    file ➌ describes how and what program to run. The journal shows the insertion
    of the device and subsequent activation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The kernel detects the device as `ttyUSB0`, and the systemd unit is activated
    and runs the `gpsdctl` commands with the device name. The systemd.device(5), udev(7),
    and systemd-udevd(8) man pages have more information.
  prefs: []
  type: TYPE_NORMAL
- en: In a forensic examination, these activation logs may be useful to help reconstruct
    past device activity. In addition, investigators should analyze the logs immediately
    before and after activation to see whether anything related or suspicious can
    be found.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scheduled Commands and Timers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every modern operating system allows scheduling of programs to run in the future,
    either once or on a repeating basis. On Linux systems, scheduling is done with
    traditional Unix-style `at` and `cron` jobs, or with systemd timers. From a forensics
    perspective, we want to answer several questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What jobs are currently scheduled?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When are they scheduled to execute?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When was the job created?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who created the job?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is scheduled to be executed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other jobs have been run in the past?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log entries and files found in the */var/spool/* directory often reveal more
    information to help answer these questions.
  prefs: []
  type: TYPE_NORMAL
- en: '**at**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `at` program is used to create jobs that are run once at a specific time
    by the `atd` daemon. One example of malicious activity using `at` jobs is to execute
    a logic bomb at some point in the future. A scheduled `at` job is identified by
    a file located in the */var/spool/at/* or */var/spool/cron/atjobs/* directory;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, the filename encodes information about the job. The first character is
    the queue state (`a` is pending and `=` is executing), the next five characters
    are the job number (in hexadecimal), and the last eight characters are the number
    of minutes since the epoch, January 1, 1970 (also in hexadecimal).
  prefs: []
  type: TYPE_NORMAL
- en: Converting the last eight characters into decimal and multiplying by 60 will
    reveal the timestamp (in seconds) of pending execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The job file is a script created by the `at` command that contains information
    about how to run the program, where to email the output, environment variables,
    and the contents of the user’s script. Here is an example of an `at` job shell
    script header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The header information is embedded in the shell script using comments. The
    owner of the `at` job can be determined from the filesystem ownership or the uid
    comments in the shell job’s header. The job’s filesystem creation timestamp indicates
    when the user submitted the job. A hidden file *.SEQ* contains the number of the
    last job run on the system. A spool directory (*/var/spool/at/spool/* or */var/spool/cron/atspool/*)
    saves the output of running jobs into email messages that are sent to the owner
    on completion. Investigators can check email logs and mailboxes for `at` job output
    email (for example, `Subject: Output from your job 27`). The timestamps of these
    emails will indicate when the job completed. Once an `at` job is completed, the
    spool files are deleted. The execution and completion of the `at` job may appear
    in the journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The submission of an at job is not logged, but it might be found in the user’s
    shell history. Shell histories can be searched for the existence of the at command
    being run.
  prefs: []
  type: TYPE_NORMAL
- en: '**cron**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The cron system is traditionally configured in the */etc/crontab* file. The
    file format consists of one line per scheduled job. Each line begins with fields
    specifying the minute, hour, day of month, month of year, and day of week. If
    a field contains an asterisk (*), the command is run every time (every hour, every
    day, and so on). The last two fields specify the user under which to run the job
    as well as the command to be executed. The following is a sample *crontab* file
    with some helpful comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, every day at one minute before midnight, a backup script starts
    running as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Linux distros have a crontab and also run hourly, daily, weekly, and monthly
    scripts that are stored in various directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Installed packages can place files in these directories for periodic tasks.
    Individual users may also have *crontab* files in the */var/spool/cron/* directory.
    The format is almost the same as */etc/crontab*, but without the username field
    because the filename indicates the name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: A forensic investigator can examine the *crontab* files and directories for
    signs of malicious scheduled activity (exfiltrating data, deleting files, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: '**Systemd Timers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Systemd timers are starting to replace cron on modern Linux systems. Timers
    are systemd unit files that specify when and how corresponding unit files (with
    the same name but different extensions) are activated. This is also a form of
    activation as discussed in the previous section, but it is timer based. Timers
    have a **.timer* extension and are normal systemd units with an additional `[Timer]`
    section, as illustrated in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The *logrotate.timer* unit specifies that the *logrotate.service* unit be activated
    every day. The *logrotate.service* unit file contains the information about how
    to run the `logrotate` program. Timer execution information is logged in the journal
    with the `Description=` string, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Timers are typically found in the same locations as other systemd unit files
    installed by software packages or by system administrators. Users can also create
    timers in their own home directories (*./config/systemd/user/*.timer*), but the
    timers will not remain active after logout.^([15](footnotes.xhtml#ch06foot_015))
    See the systemd.timer(5) man page for more information. Systemd provides a flexible
    notation for specifying time periods used in the `OnCalendar=` directive. The
    systemd.time(7) man page has more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Power and Physical Environment Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux kernel interacts directly with hardware that is part of the physical
    environment. Changes to this physical environment may leave digital traces in
    the logs that are interesting to forensic investigators. These digital traces
    may provide useful information about electrical power or temperature or indicate
    the physical proximity of people near the computer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Power and Physical Environment Analysis***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most server installations have backup power with uninterruptible power supply
    (UPS) devices. These devices contain batteries able to provide power continuity
    during an outage. They usually have a serial or USB cable connected to a server
    responsible for taking action (clean shutdown, notification, and so on) when power
    fails. In a Linux environment, a daemon listens for alerts from the UPS. Common
    UPS software packages include PowerPanel/Cyber-Power with the `pwrstatd` daemon,
    Network UPS Tools (NUT) with the `upsd` daemon, and the `apcupsd` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows a server losing and then regaining power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These logs may be useful in enterprise computing environments where accidental
    failure or intentional sabotage are being investigated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log messages related to laptop power may come from several sources (or not
    at all), depending on the Linux distro and the configuration. An ACPI daemon (`acpid`)
    could be running and logging to syslog, systemd or the window environment may
    be reacting to ACPI messages and taking actions, and there may be other daemons
    configured to react to ACPI changes. Linux may not fully support the implemented
    ACPI interface of some hardware, and certain error messages may appear. For example,
    in this log, the laptop noticed a change when the power cable was unplugged, but
    didn’t recognize what it was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This usually happens with a buggy or unsupported ACPI BIOS.
  prefs: []
  type: TYPE_NORMAL
- en: Temperature issues may result from being in a high temperature environment,
    blocked ventilation, fan failure, explicit overclocking by the owner, or other
    factors. Depending on how the system was installed and configured, the logs may
    have traces of temperature readings.
  prefs: []
  type: TYPE_NORMAL
- en: The ACPI interface may provide some temperature information, the `lm_sensors`
    software package provides temperature information, and other temperature programs
    may be plug-ins for a graphical environment. Enterprise systems may run monitoring
    software like Icinga/Nagios that checks and reports temperature. Daemons like
    `thermald` also log temperature information. Daemons like `hddtemp` read Self-Monitoring
    Analysis and Reporting Technology (SMART) data on drives to monitor the temperature
    (and log thresholds).
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the kernel detects temperature changes. This example shows the
    system reacting to high load on a CPU and changing its speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Reactions to hitting temperature thresholds depend on the software configured
    and may include reporting to a sysadmin, logging, slowing down a device, shutting
    down a device, or even shutting down the entire system. Depending on the context
    of an investigation, temperature indicators may be of forensic interest. Examples
    of this include correlating potential high CPU activity from an unexpected process
    or changes in the physical environment in which the machine is located.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sleep, Shutdown, and Reboot Evidence***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on the investigation, knowing when a computer was online, offline,
    suspended, or rebooted can be important for building a forensic timeline. For
    example, knowing when a computer was suspended may conflict with someone’s claim
    that a machine was online and working, or the unplanned reboot of a server could
    be the result of malicious activity. The state of a machine can be deduced from
    a timeline analysis and also determined from log analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ACPI specification defines multiple sleep states (“S” states) for a computer
    and the Linux kernel implements variations of these sleep states (*[https://www.kernel.org/doc/html/latest/admin-guide/pm/sleep-states.html](https://www.kernel.org/doc/html/latest/admin-guide/pm/sleep-states.html)*).
    Each state listed here provides an increasing level of power savings through various
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suspend-to-Idle (S0 Idle)** Freeze userspace, devices in low power, CPU idle'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standby (S1)** In addition to S0 Idle, non-boot CPUs offline, low-level system
    functions suspended'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suspend-to-Ram (S3)** RAM has power; other hardware is off or in low power
    mode'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hibernation (S4 or S5)** RAM is suspended to disk and system is powered off'
  prefs: []
  type: TYPE_NORMAL
- en: The ACPI specification also defines S0 as normal operation and S5 as powered
    off. Under Linux, these states are changed by explicit user requests, idle timeouts,
    or low-battery threshold conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these sleep changes can be seen in the logs when systemd manages the
    suspension process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, individual daemons aware of the changes may also log messages
    about going to sleep or waking up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hibernation process suspends everything to disk and shuts the system down
    (analysis of this hibernation area is described in [Chapter 3](ch03.xhtml)), which
    can be observed in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how systemd begins the hibernate process and then hands it
    over to the kernel to finish writing memory to disk. On resume, the kernel reads
    memory back from disk and hands it back over to systemd to complete the wakeup.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd manages both the initialization and shutdown of a Linux system and logs
    the activity to the journal. Downtime from a halt or power-off depends on the
    system administrator. The shutdown and bootup times can be deduced from a filesystem
    timeline analysis, but the information should also be available in various logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebooting a Linux system causes a clean shutdown and immediately restarts the
    system. A reboot is initiated by systemd and shown in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The downtime from a reboot is limited to the time needed to shut down fully
    and then fully restart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Halting a Linux system performs a clean shutdown and then halts the kernel,
    but without rebooting or powering off. The initiation of a halt process can be
    observed in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The final kernel logs are shown on the console (but not in the journal, as systemd
    logging is already stopped).
  prefs: []
  type: TYPE_NORMAL
- en: 'The power-off of a Linux system begins the same way as a reboot or halt, but
    the hardware is instructed to power off after the Linux shutdown is complete.
    A power-off can be observed in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Rebooting, halting, and powering off a system have similar shutdown processes.
    The only difference is what happens after kernel execution stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The journal keeps a list of boot periods, which you can view by copying the
    journal file(s) to an analysis machine and running journalctl with the --list-boots
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This command produces a list of each boot period from start to end. Other logs,
    such as *lastlog* and *wtmp*, will also log reboots and shutdowns. Daemons may
    log shutdown information showing that they are terminating themselves due to a
    pending shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: '***Human Proximity Indicators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Determining whether a person was within physical proximity of a computer is
    often useful in investigations. Although Linux has flexible remote access capabilities,
    with secure shell and remote desktop, investigators can still determine when some
    activity was likely done by a person sitting at (or near) the computer or performing
    some interaction with the local hardware. I call these *human proximity indicators*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Laptop Lids**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One human proximity indicator is interaction with a laptop lid. If a lid was
    opened or closed, someone likely made physical contact with the machine to do
    it. Knowing the difference between a lid opening and a lid closing is also interesting,
    as it may indicate an intention to start working or stop working at a certain
    point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laptop lid activity is logged in the systemd journal. The following example
    shows a laptop lid being closed and then opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Typically, closing a laptop lid will trigger a screen-locking program, and when
    the lid is opened, authentication is required. Successful authentication and continued
    user activity (as observed from the timeline and other indicators) suggests that
    the machine’s owner was nearby at that time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Power Cables**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The power cable on a laptop can also be interesting from an investigative perspective.
    If a laptop power cable was physically unplugged or plugged in, it may leave traces
    in the logs. Unless there was a power outage, this indicates that someone was
    in physical proximity of the laptop. Many laptop systems use the `upowerd` daemon
    for power management. This daemon keeps several logs of power-related events,
    including a history of battery charging/discharging states, times, and power consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'The */var/lib/upower/* directory contains the power historical data reported
    via ACPI^([16](footnotes.xhtml#ch06foot_016)) from battery-operated peripherals
    and laptop batteries. A battery has four history files (* is a string identifying
    the battery):'
  prefs: []
  type: TYPE_NORMAL
- en: '***history-charge-*.dat*** Log of percentage charged'
  prefs: []
  type: TYPE_NORMAL
- en: '***history-rate-*.dat*** Log of energy consumption rate (in watts)'
  prefs: []
  type: TYPE_NORMAL
- en: '***history-time-empty-*.dat*** When unplugged, log of time (in seconds) until
    empty'
  prefs: []
  type: TYPE_NORMAL
- en: '***history-time-full-*.dat*** When charging, log of time (in seconds) until
    full'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three charging states found in the logs that may be interesting in
    a forensic investigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Charging** Battery is being charged; cable is plugged in'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discharging** Battery is discharging; cable is unplugged'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully charged** Battery is charged to its maximum; cable attached'
  prefs: []
  type: TYPE_NORMAL
- en: For a list of all the supported charging states, see the project documentation
    (*[https://upower.freedesktop.org/docs/](https://upower.freedesktop.org/docs/)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The charging and discharging of the battery correlates to the plugged and unplugged
    state of the power cable. Changes to this state are logged with a timestamp and
    shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, the charging history contains timestamps (Unix epoch), power consumption,
    and the charging state. In a forensic examination, the transitions between `charging`,
    `discharging`, and `fully-charged` may indicate when a power cable was physically
    plugged in or unplugged (or a power outage occurred). These state transitions
    may be observed in one or more of the four *upower* history files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethernet Cables**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An Ethernet cable link status can also be interesting from an investigative
    perspective. In server environments, if an Ethernet cable is physically plugged
    in or unplugged from a machine, the kernel will notice and log the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This activity may include unused Ethernet ports suddenly becoming active or
    configured interfaces suddenly going down. These actions can indicate human proximity
    (people plugging in and unplugging cables), but they can also indicate other infrastructure
    situations, such as a switch going down, an administrator disabling a port, a
    severed cable, or the machine itself deactivating a port (with the `ip link set`
    command, for example). Possible malicious reasons for unexpected Ethernet port
    activity may include disruption, creating a side channel for data exfiltration,
    bypassing perimeter security, or performing some other unauthorized network activity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugged-In Peripheral Devices and Removable Media**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another indicator of a person’s physical proximity is the record of USB devices
    being plugged in or removed from a machine. [Chapter 11](ch11.xhtml) discusses
    the detection of attached USB devices, but the following example shows a physically
    attached (and later removed) USB thumb drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to determine the physical plug used to attach the USB device
    by examining the bus and port numbers (for example, to determine whether the activity
    happened in front of or behind a PC).
  prefs: []
  type: TYPE_NORMAL
- en: Other indicators of human proximity include the insertion or removal of physical
    removable media (CD-ROM, tape, SD card, and so on). Depending on the media and
    drive, this action may leave traces in the logs indicating that a person was present
    to perform the action.
  prefs: []
  type: TYPE_NORMAL
- en: '**Console Logins and Other Indicators**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Logging in to a machine from the physical console (local keyboard, screen, and
    so on) is the most obvious example of human proximity. If a login session is bound
    to a systemd “seat” (which is not the case with remote access like SSH), it indicates
    a local physical login. The `last` log output (described in [Chapter 10](ch10.xhtml))
    provides a history of local and remote logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'A login to a local physical console will use a `tty`, whereas a remote SSH
    session will use a pseudoterminal (`pts`). The following example is from the `last`
    output showing logins from user Sam:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here `tty7` represents the local physical device where a login was made (`:0`
    is the X11 server), and `pts/3` shows a remote login (from the given IP address).
  prefs: []
  type: TYPE_NORMAL
- en: When a physical keyboard/video/mouse (KVM) device is attached to a PC and accessed
    remotely, physical proximity can’t be determined (unless the KVM device retains
    its own logs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other indicators of human proximity are physical key presses on a locally attached
    keyboard.^([17](footnotes.xhtml#ch06foot_017)) These are not typically logged,
    but certain keys (power, brightness, function keys, and so on) may be associated
    with an action performed by the operating system. Logs may exist depending on
    the key or the daemon configured to take action. Some of these keyboard actions
    may also trigger scripts or programs that leave traces in the logs when run, such
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the power button was pressed on a computer, triggering a suspend
    action. The physical button press is logged, indicating that someone was in proximity
    of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: The use of fingerprint readers for biometric authentication can also help determine
    human proximity. If a person scanned in a fingerprint on a local fingerprint reader,
    it’s an indicator that they were in physical contact with the system at a particular
    point in time. The advantage here is the combined determination of proximity together
    with biometric identification of the person. More information about Linux fingerprint
    authentication is explained in [Chapter 10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The absence of human proximity indicators does not mean nobody was near the
    computer. Also, just knowing that a person was in physical proximity of a computer
    and performing some action does not identify that person. This must be deduced
    from corroborating timestamps from other logs or the filesystem (or even logs
    from remote servers). If a laptop lid was opened and passwords were subsequently
    entered to log in or unlock a physical system, those actions point to anyone with
    knowledge of the password, not necessarily the user observed in the logs (in other
    words, the password may have been stolen or known by someone else).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you have learned how a Linux system boots, runs, and shuts
    down. You have seen examples of systemd unit files and more examples of logs that
    we can use to reconstruct past events. You have also been introduced to the concept
    of human proximity indicators and Linux power management. This chapter provides
    the background knowledge an investigator needs to analyze the system layer activity
    of a Linux machine.
  prefs: []
  type: TYPE_NORMAL
