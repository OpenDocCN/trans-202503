<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label="37"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch3">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">3</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">ABSTRACT DATA TYPES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">An <i>abstract data type (ADT)</i> is defined by the <i>operations</i> it supports and the <i>behavior</i> it provides. Throughout this book, we’ll study data structures insofar as they allow the implementation of specific ADTs; in a very practical sense, you could say that an ADT specifies needs and requirements in general. This book won’t study data structures just for the sake of it; we’ll always see them in the context of an ADT and the operations we need the data structure (and associated algorithms) to support. In this chapter, you’ll learn more about what ADTs are and how to implement them in JavaScript.</p>&#13;
<p class="TX">An ADT may be implemented in many ways, possibly with varying performance (a topic we’ll discuss in the next chapter) by using alternative <span role="doc-pagebreak" epub:type="pagebreak" id="pg_38" aria-label="38"/>data structures and algorithms. For example, you could implement a set with an array, or with a list, or with a tree, but the performance won’t be the same in all cases. An actual implementation (meaning some data structure plus the algorithms that work with it) may be called a <i>concrete data type (CDT)</i>, but you won’t see that term here.</p>&#13;
<p class="TX">How a data type is implemented is not abstract; it’s a concrete aspect that affects the developer. The definition of a data type requires no coding, but the implementation certainly does. Let’s first review some basic concepts about data types, abstraction, and operations, and then we’ll move to defining ADTs in detail.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-11"/><span class="SANS_Futura_Std_Bold_B_11">The Theory</span></h3>&#13;
<p class="TNI1">What are data types, and how do we work with them? Can they be defined abstractly, or must we always resort to actual implementations? What can we do with data types, what operations do they provide, and what effects do they have? Before starting with ADTs, let’s take a closer look at some basic software concepts that motivate the focus for this chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-19"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Data Types</span></h4>&#13;
<p class="TNI1">Programming languages originally included only a few built-in data types, such as characters, strings, booleans, and numbers (either integer or floating point), and developers couldn’t add any new ones; the given options were all they had to work with. After concepts like <i>classes</i> were added to programming languages, developers were able to add new, more complex data types. A data type in general (both those provided by the language and any you create) is defined by the set of possible values it may represent and the operations that can be performed on it; for example, it’s possible to concatenate two strings, perform logical operations with booleans, do arithmetic with integer numbers, or compare floating point numbers.</p>&#13;
<p class="TX">When using a data type, the details of its internal representation don’t usually matter—only what you can do with it and how you can use it to get results. Input and output are all that matter. The basic idea of an ADT is specifying the operations that can be done, leaving aside the internal aspects. (If languages provide bit operations or some low-level features, you might need to learn internal representation details, but for most programming tasks, you won’t need to do that.)</p>&#13;
<p class="TX">Modern languages, JavaScript included, allow users to define their own data types. At first, developers had only simple records (such as representing a date with three numeric fields for day, month, and year), but now you can go further and use classes to hide implementation details, so users need to care only about using the newly defined data type and nothing else.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>ADT can also stand for algebraic data type, which is a different concept representing a type formed by combining other types.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label="39"/>&#13;
<h4 class="H2" id="sec3"><span id="h2-20"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Abstraction</span></h4>&#13;
<p class="TNI1">We have been bandying about the concept of abstraction, so now let’s consider more specifically what that term means. Basically, <i>abstraction</i> implies hiding or omitting details and reaching instead for an overarching higher-level idea. When we talk about abstraction, we are purposefully ignoring implementation aspects, at least for the time being, to concentrate on our needs, no matter how we’ll get around to code solutions for them. For example, do you need to store and retrieve strings? A dictionary ADT would be your solution; you’ll see how to implement it later, but no matter how you do it, that’s the data type you need.</p>&#13;
<p class="TX">Software engineering has three similar and related concepts:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Encapsulation </b>Designing modules as if they had a “shell” or “capsule” around them, so only the module is responsible for handling its data. The idea is to wrap together data and the methods that work on that data in a single place for a more coherent, cohesive design.</p>&#13;
<p class="RunInPara"><b>Data hiding </b>Hiding inner details of a module’s implementation from the rest of the system, ensuring that they can be changed without affecting any other parts of the code. This mechanism ensures that no one can access internal details from the outside. In other words, encapsulation brings everything together, and data hiding ensures that nobody can mess with internals from “outside.”</p>&#13;
<p class="RunInPara"><b>Modularity </b>Dividing a system into separate modules that can be designed and developed independently from the rest of the system. Using modules correctly provides both encapsulation and data hiding.</p>&#13;
</div>&#13;
<p class="TX">An ADT defines only what operations it can perform; it doesn’t go into detail about how those operations will be implemented. In other words, with an ADT, you describe what you can do “in the abstract” rather than going into concrete detail. Let’s consider some different types of operations we can perform on an ADT.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-21"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Operations and Mutations</span></h4>&#13;
<p class="TNI1">A common way to classify data types is by <i>mutable</i> versus <i>immutable</i> values. For example, in JavaScript, objects and arrays are mutable. After creating an object or array, you can modify its values without creating a new object or array. On the other hand, numbers and strings are immutable; if you apply an operation to either of those data types, a new, different, and distinct value is produced.</p>&#13;
<p class="TX">When designing a new date type (such as an object with three separate integer values, like the date example mentioned earlier in this chapter), you could opt to provide operations to set the day, month, or year, which would mean that date objects are mutable. On the other hand, if those operations returned a new date object instead of modifying the existing one, date objects would be immutable.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label="40"/><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>React Redux developers are well aware of immutability and what it requires. If you want to modify the state of a React application that uses Redux, you cannot just modify it directly; you must generate a new state with whatever changes you want. Redux assumes that you manage your state data in an immutable way. (We’ll discuss immutability further in <a href="chapter18.xhtml">Chapter 18</a>.)</i></p>&#13;
<p class="TX">The following list shows the categories of operations that apply to an ADT:</p>&#13;
<p class="RunInHead"><b>Creators </b>Functions that produce a new object of the given type, possibly taking some values as arguments. Using the date ADT example, a creator could build a new date out of day, month, and year values.</p>&#13;
<p class="RunInHead"><b>Observers </b>Functions that take objects of a given type and produce some values of a different type. For the date ADT, a <span class="SANS_TheSansMonoCd_W5Regular_11">getMonth()</span> operation might produce the month as an integer, or an <span class="SANS_TheSansMonoCd_W5Regular_11">isSunday()</span> predicate could determine whether the given date falls on a Sunday.</p>&#13;
<p class="RunInHead"><b>Producers </b>Functions that take an object of a given type, and possibly some extra arguments, and produce a new object of the given type. With the date ADT, you could have a function that added an integer number of days to a date, producing a new date.</p>&#13;
<p class="RunInHead"><b>Mutators </b>Functions that directly modify an object of a given type. A <span class="SANS_TheSansMonoCd_W5Regular_11">setMonth()</span> method could modify an object (change its month) instead of producing a new one.</p>&#13;
<p class="TX">With an immutable data type, only the first three types of operations apply; for mutable data types, mutators also apply.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-12"/><span class="SANS_Futura_Std_Bold_B_11">Implementing an ADT</span></h3>&#13;
<p class="TNI1">Consider a situation where you want to implement a <i>bag</i> or <i>multiset</i>, which is a container like a set, but it allows for repeated elements. (Sets cannot have repeated elements by definition.) We’ll also add an extra operation (“greatest”) to make it more interesting. <a href="chapter3.xhtml#tab3-1">Table 3-1</a> provides an example of how ADTs are described throughout the book.</p>&#13;
&#13;
<table class="NSP-Standard-Table">&#13;
<caption><p class="TT" id="tab3-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 3-1:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Bags</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a bag, determine whether it’s empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a new value, add it to the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a value, remove it from the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a value, check whether it exists in the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greatest</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value | undefined</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a bag, find the greatest value in it.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label="41"/>Ignore the middle column for now and focus on the other two. The Operation column names each operation that is provided, and the Description column provides a simple explanation of what the operation is supposed to achieve. You want to be able to create a new (empty) bag and also test whether the bag is empty. You need to be able to add new values to the bag and remove previously entered values from it, and both of those operations will change the bag’s contents. Finally, you want to be able to find whether a given value is in the bag and also determine the greatest value in the bag.</p>&#13;
<p class="TX">You could also have a column specifying the type of the operation— creator, observer, producer, and so on—but that’s usually understood from the operation’s description and not explicitly included.</p>&#13;
<p class="TX">What’s the operation’s Signature, the middle column in <a href="chapter3.xhtml#tab3-1">Table 3-1</a>? Unless using TypeScript or Flow (as mentioned in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>), JavaScript doesn’t let developers specify types for functions and variables, but adding that information (even if only in comments or a table like this one) helps users better understand what the function expects and returns.</p>&#13;
<p class="TX">Specifying a function’s parameters and the returned result is called a <i>signature</i>, and it’s based on a <i>type system</i> called <i>Hindley-Milner</i>. You start with the types of the function’s parameters, in order, separated by ×, followed by an arrow, and then the types of the function’s results.</p>&#13;
<p class="TX">Let’s consider some examples. <a href="chapter3.xhtml#tab3-1">Table 3-1</a> shows that the <span class="SANS_TheSansMonoCd_W5Regular_11">create()</span> function doesn’t take any parameters and returns a bag-type result. Similarly, <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> takes two parameters, a bag and a value, and it returns a bag as a result. Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">greatest()</span> function takes a bag parameter and returns either a value or <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>.</p>&#13;
<p class="TX">The complete Hindley-Milner system includes several more details, such as constraints on the types, generic types, undetermined number of parameters, class methods, and so on, but for our needs, the definitions shown in <a href="chapter3.xhtml#tab3-1">Table 3-1</a> will suffice.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-22"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Implementing ADTs Using Classes</span></h4>&#13;
<p class="TNI1">Let’s use a class to start implementing a bag ADT. The objects will have two attributes: <span class="SANS_TheSansMonoCd_W5Regular_11">count</span>, which counts how many elements are in the bag, and <span class="SANS_TheSansMonoCd_W5Regular_11">data</span>, which is an object with a key for each element and a value that represents how many times that key appears in the bag. Keep in mind, we’re not looking for an especially performant way to implement a bag (we’ll get to that in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>). For now, we’re just looking at an example of using classes.</p>&#13;
<p class="TX">For instance, if you add the strings <span class="SANS_TheSansMonoCd_W5Regular_11">HOME</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">SWEET</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">HOME</span> to a bag, the object would look like the following:</p>&#13;
<pre id="pre-46"><code>{&#13;
  count: 3,&#13;
  data: {&#13;
    <b>HOME</b>: 2,&#13;
    <b>SWEET</b>: 1,&#13;
  },&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label="42"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> attribute has a value of <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> to reflect that three strings were added to the bag. The <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> part includes a <span class="SANS_TheSansMonoCd_W5Regular_11">HOME</span> attribute with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> (since <span class="SANS_TheSansMonoCd_W5Regular_11">HOME</span> was added twice) and a <span class="SANS_TheSansMonoCd_W5Regular_11">SWEET</span> attribute with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>&#13;
<p class="TX"><a href="#Lis3-1">Listing 3-1</a> shows the complete <span class="SANS_TheSansMonoCd_W5Regular_11">Bag</span> class.</p>&#13;
<span id="Lis3-1"/>&#13;
<pre id="pre-47"><code>class Bag {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> count = 0;&#13;
  data = {};&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> isEmpty() {&#13;
    return this.count === 0;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> find(value) {&#13;
    return value in this.data;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> greatest() {&#13;
    return this.isEmpty() ? undefined : Object.keys(this.data).sort().pop();&#13;
  }&#13;
&#13;
  add(value) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> this.count++;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> if (this.find(value)) {&#13;
      this.data[value]++;&#13;
    } else {&#13;
      this.data[value] = 1;&#13;
    }&#13;
  }&#13;
&#13;
  remove(value) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> if (this.find(value)) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> this.count--;&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> if (this.data[value] &gt; 1) {&#13;
        this.data[value]--;&#13;
      } else {&#13;
        delete this.data[value];&#13;
      }&#13;
    }&#13;
  }&#13;
}</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-1: A possible implementation for the bag ADT</span></p>&#13;
<p class="TX">A new object is initialized with a zero <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> and an empty set of values <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You can tell whether the object is empty by checking whether the <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> is zero <span class="CodeAnnotation" aria-label="annotation2">❷</span>. To see whether the bag contains a given key <span class="CodeAnnotation" aria-label="annotation3">❸</span>, check whether it appears in the <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> object with the <span class="SANS_TheSansMonoCd_W5Regular_11">in</span> operator. Finding the greatest key <span class="CodeAnnotation" aria-label="annotation4">❹</span> is not hard because of JavaScript’s functionality. You first get an array with all the keys in <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> (all the values that were added to the bag), and after sorting it, you <span class="SANS_TheSansMonoCd_W5Regular_11">pop()</span> its last element, which will be the greatest key in the bag.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label="43"/>To add a key to the bag, increment the <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> by 1 <span class="CodeAnnotation" aria-label="annotation5">❺</span> and then check whether the key is already in the bag <span class="CodeAnnotation" aria-label="annotation6">❻</span>; if it is, increment its <span class="SANS_TheSansMonoCd_W5Regular_11">count</span>; if it isn’t, add it with a <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> of 1.</p>&#13;
<p class="TX">To remove a key from the bag, first verify that the key actually is in the bag <span class="CodeAnnotation" aria-label="annotation7">❼</span>. If it isn’t, don’t do anything at all. If you find the key, decrement the <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> <span class="CodeAnnotation" aria-label="annotation8">❽</span> and then see how many times the key appears in the bag <span class="CodeAnnotation" aria-label="annotation9">❾</span>. If its <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> is greater than 1, decrement it by 1. If it’s exactly 1, just remove the key from the data object.</p>&#13;
<p class="TX">How can you use this object? Taking a few words from the song “Home, Sweet Home” (the original song from 1823, not the newer one by M<span class="accent">ö</span>tley Cr<span class="accent">ü</span>e), you can do something like the code shown in <a href="#Lis3-2">Listing 3-2</a> that adds part of the lyrics to the bag.</p>&#13;
<span id="Lis3-2"/>&#13;
<pre id="pre-48"><code>const b = new Bag();&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> console.log(b.isEmpty());   // true&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> b.add("HOME");&#13;
b.add("HOME");&#13;
b.add("SWEET");&#13;
b.add("SWEET");&#13;
b.add("HOME");&#13;
&#13;
b.add("THERE'S");&#13;
b.add("NO");&#13;
b.add("PLACE");&#13;
b.add("LIKE");&#13;
b.add("HOME");&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> console.log(b.isEmpty());   // false&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> console.log(b.find("YES")); // false&#13;
console.log(b.find("NO"));  // true&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> console.log(b.greatest());  // THERE'S&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> b.remove("THERE'S");&#13;
console.log(b.greatest());  // SWEET</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-2: A test for the bag implementation</span></p>&#13;
<p class="TX">The newly created bag is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as expected. You can add several keys to it <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and the bag will obviously no longer be empty <span class="CodeAnnotation" aria-label="annotation3">❸</span>. (See question 3.1 for a more compact way of chaining similar operations.) The <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> operation <span class="CodeAnnotation" aria-label="annotation4">❹</span> works as expected; <span class="SANS_TheSansMonoCd_W5Regular_11">"YES"</span> isn’t in the bag, but <span class="SANS_TheSansMonoCd_W5Regular_11">"NO"</span> is. Finally, the greatest key in the bag is <span class="SANS_TheSansMonoCd_W5Regular_11">"THERE'S"</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, but after removing it <span class="CodeAnnotation" aria-label="annotation6">❻</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">"SWEET"</span> is the new greatest value.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-23"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Implementing ADTs Using Functions (Mutable Version)</span></h4>&#13;
<p class="TNI1">Now that you’ve created a concrete implementation of an ADT, how would it change if you were using functions instead of classes? <a href="#Lis3-3">Listing 3-3</a> uses the same representation based on an object with <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> attributes. The <span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label="44"/>differences essentially will be syntactical, like passing the <span class="SANS_TheSansMonoCd_W5Regular_11">bag</span> object as an argument to a function, instead of referring to it as <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> in a method.</p>&#13;
<span id="Lis3-3"/>&#13;
<pre id="pre-49"><code>  const newBag = () =&gt; ({count: 0, data: {}});&#13;
&#13;
  const isEmpty = (bag) =&gt; bag.count === 0;&#13;
&#13;
  const find = (bag, value) =&gt; value in bag.data;&#13;
&#13;
  const greatest = (bag) =&gt;&#13;
  isEmpty(bag)&#13;
    ? undefined&#13;
    : Object.keys(bag.data).sort().pop();&#13;
&#13;
  const add = (bag, value) =&gt; {&#13;
  bag.count++;&#13;
  if (find(bag, value)) {&#13;
    bag.data[value]++;&#13;
  } else {&#13;
    bag.data[value] = 1;&#13;
  }&#13;
  return bag;&#13;
};&#13;
&#13;
  const remove = (bag, value) =&gt; {&#13;
  if (find(bag, value)) {&#13;
    bag.count--;&#13;
    if (bag.data[value] &gt; 1) {&#13;
      bag.data[value]--;&#13;
    } else {&#13;
      delete bag.data[value];&#13;
    }&#13;
  }&#13;
  return bag;&#13;
};</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-3: An alternative (mutable) implementation of the</span> <span class="SANS_Futura_Std_Book_Oblique_11">bag ADT</span></p>&#13;
<p class="TX">The code in <a href="#Lis3-3">Listing 3-3</a> is similar to <a href="#Lis3-1">Listing 3-1</a> that used classes. The <span class="SANS_TheSansMonoCd_W5Regular_11">newBag()</span> function returns an object with the <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> fields, like the constructor in the <span class="SANS_TheSansMonoCd_W5Regular_11">Bag</span> class did. For the other five functions (<span class="SANS_TheSansMonoCd_W5Regular_11">isEmpty</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">find</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">greatest</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">remove</span>), there are only two differences in comparison with the classes-based code: you access the object using the <span class="SANS_TheSansMonoCd_W5Regular_11">bag</span> parameters instead of using <span class="SANS_TheSansMonoCd_W5Regular_11">this</span>, and you expressly return <span class="SANS_TheSansMonoCd_W5Regular_11">bag</span> at the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> mutator methods. In this case, however, you don’t really need to do this, because you are actually modifying the <span class="SANS_TheSansMonoCd_W5Regular_11">bag</span> parameter, which was passed by reference to the functions. (That’s the standard way JavaScript passes objects as arguments.) However, if you were to implement this ADT in some other way that didn’t use an object, returning the new concrete data type would be mandatory. Since you don’t want external dependencies on internal aspects of an implementation, the simplest (and safest) way to work is by always returning the new updated object, whatever its type.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label="45"/>The code to use this ADT implementation, shown in <a href="#Lis3-4">Listing 3-4</a>, is quite similar to the class-based version in <a href="#Lis3-2">Listing 3-2</a>.</p>&#13;
<span id="Lis3-4"/>&#13;
<pre id="pre-50"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> let b = newBag();&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> console.log(isEmpty(b));     // true&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> b = add(b, "HOME");&#13;
b = add(b, "HOME");&#13;
b = add(b, "SWEET");&#13;
b = add(b, "SWEET");&#13;
b = add(b, "HOME");&#13;
&#13;
b = add(b, "THERE'S");&#13;
b = add(b, "NO");&#13;
b = add(b, "PLACE");&#13;
b = add(b, "LIKE");&#13;
b = add(b, "HOME");&#13;
&#13;
console.log(isEmpty(b));     // false&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> console.log(greatest(b));    // THERE'S&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> console.log(find(b, "YES")); // false&#13;
console.log(find(b, "NO"));  // true&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> b = remove(b, "THERE'S");&#13;
console.log(greatest(b));    // SWEET</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-4: A test for the mutable implementation of bags</span></p>&#13;
<p class="TX">The simple differences are in object creation <span class="CodeAnnotation" aria-label="annotation1">❶</span>, testing whether the bag is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, adding <span class="CodeAnnotation" aria-label="annotation3">❸</span> and removing <span class="CodeAnnotation" aria-label="annotation6">❻</span> elements, getting the greatest value <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and finding whether a value is in the bag <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Instead of writing <span class="SANS_TheSansMonoCd_W5Regular_11">b.something(...)</span>, you would write <span class="SANS_TheSansMonoCd_W5Regular_11">something(b, . . .)</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-24"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Implementing ADTs Using Functions (Immutable Version)</span></h4>&#13;
<p class="TNI1">Finally, let’s consider an immutable implementation of our ADT. (In <span class="Xref"><a href="chapter18.xhtml">Chapter 18</a></span>, we’ll see immutable data structures in more detail, with several more cases.) There’s no particular reason here for immutability, other than wanting to work in a more functional way and avoiding side effects, as described in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.</p>&#13;
<p class="TX">In this situation, as you want to develop an immutable bag, you may not modify the bag object directly, so you need to change the implementation of the mutator methods; the rest will stay the same. The solution just requires creating and returning a new object if the bag needs any changes. To add a new value, use the following code:</p>&#13;
<pre id="pre-51"><code>const add = (bag, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> bag = {count: bag.count - 1, data: {...bag.data}};&#13;
  if (find(bag, value)) {&#13;
    bag.data[value]++;&#13;
  } else {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label="46"/>    bag.data[value] = 1;&#13;
  }&#13;
  return bag;&#13;
};</code></pre>&#13;
<p class="Continued">Since adding a new value to a bag can never fail, you always need to produce a new object, so you actually do that <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">To remove a value from a bag, first check whether the value to remove is in it before proceeding to remove it:</p>&#13;
<pre id="pre-52"><code>const remove = (bag, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (find(bag, value)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> bag = {count: bag.count - 1, data: {...bag.data}};&#13;
    if (bag.data[value] &gt; 1) {&#13;
      bag.data[value]--;&#13;
    } else {&#13;
      delete bag.data[value];&#13;
    }&#13;
  }&#13;
  return bag;&#13;
};</code></pre>&#13;
<p class="TX">As before, start by checking whether the value is in the bag <span class="CodeAnnotation" aria-label="annotation1">❶</span>; if it is <span class="CodeAnnotation" aria-label="annotation2">❷</span>, create a new object, which you’ll return.</p>&#13;
<p class="TX">In this case, the code modifications are minimal, but with more complex data structures (as we’ll see later in this book), creating a new copy of an existing structure may not be so easy or quick, and you’ll need to do extra processing or structuring.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-13"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter, we introduced the concept of abstract data types, which you’ll see in the rest of the book when analyzing the pros and cons of competing data structures and algorithms. Defining an ADT is the first step when deciding what structure should be used and how algorithms should be implemented. Understanding the concept of ADTs will help you get the best possible performance for your code.</p>&#13;
<p class="TX">In the next chapter, we’ll study a complementary concept: How can we compare concrete implementations of ADTs, or in other words, how can we tell whether one algorithm is actually better or worse than another? We’ll also introduce analysis of algorithms and concepts related to classes of performance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-14"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>3.1  Chaining Calls</b></p>&#13;
<p class="ListPlainFirst">Modify the <span class="SANS_TheSansMonoCd_W5Regular_11">Bag</span> methods so you can chain additions in the following fashion:</p>&#13;
<pre class="pre" id="pre-53"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label="47"/>const b = new Bag();&#13;
b.add("HOME").add("HOME");&#13;
b.add("SWEET").add("SWEET").add("HOME");</code></pre>&#13;
<p class="ListBody1">You should also be able to chain removals and other operations, such as the following, that would remove two values and then test whether the bag becomes empty:</p>&#13;
<pre class="pre" id="pre-54"><code>b.remove("NO").remove("HOME").isEmpty();</code></pre>&#13;
<p class="ListHead"><b>3.2  Arrays, Not Objects</b></p>&#13;
<p class="ListPlainFirst">Can you implement the bag ADT using arrays instead of objects? You could represent the bag with an ordered array to make the <span class="SANS_TheSansMonoCd_W5Regular_11">greatest()</span> function implementation really speedy. Of course, <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> should take care of maintaining the order of the array.</p>&#13;
<p class="ListHead"><b>3.3  Extra Operations</b></p>&#13;
<p class="ListPlainFirst">Only a few extra operations for a bag were described in this chapter, but for some applications, you might need added or changed operations; can you think of any?</p>&#13;
<p class="ListHead"><b>3.4  Wrong Operations</b></p>&#13;
<p class="ListPlainFirst">When defining an ADT, how could you specify error results, such as possibly throwing an exception or returning some kind of special value?</p>&#13;
<p class="ListHead"><b>3.5  Ready, Set ...</b></p>&#13;
<p class="ListPlainFirst">In this chapter, we discussed a bag, but in later chapters, we’ll work with sets, which don’t allow repeated values. Can you think ahead and whip up an appropriate ADT?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>