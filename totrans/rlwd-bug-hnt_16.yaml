- en: '**16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INSECURE DIRECT OBJECT REFERENCES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An *insecure direct object reference (IDOR)* vulnerability occurs when an attacker
    can access or modify a reference to an object, such as a file, database record,
    account, and so on, that should be inaccessible to them. For example, let’s say
    the website *www.<example>.com* has private user profiles that should be accessible
    only to the profile owner through the URL *www.<example>.com/user?id=1*. The `id`
    parameter would determine which profile you’re viewing. If you can access someone
    else’s profile by changing the `id` parameter to 2, that would be an IDOR vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Simple IDORs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some IDOR vulnerabilities are easier to find than others. The easiest IDOR
    vulnerability you’ll find is similar to the previous example: it’s one in which
    the identifier is a simple integer that automatically increments as new records
    are created. To test for this kind of IDOR, you just add or subtract 1 from an
    `id` parameter and confirm you can access records you shouldn’t have access to.'
  prefs: []
  type: TYPE_NORMAL
- en: You can perform this testing using the web proxy tool Burp Suite, discussed
    in [Appendix A](app01.xhtml#app01). A *web proxy* captures the traffic your browser
    sends to a website. Burp allows you to monitor HTTP requests, modify them on the
    fly, and replay requests. To test for IDORs, you can send your request to Burp’s
    Intruder, set a payload on the `id` parameter, and choose a numerical payload
    to increment or decrement.
  prefs: []
  type: TYPE_NORMAL
- en: After starting a Burp Intruder attack, you can see whether you have access to
    data by checking the content lengths and HTTP response codes Burp receives. For
    example, if a site you’re testing always returns status code 403 responses that
    are all the same content length, the site is likely not vulnerable. Status code
    403 means access has been denied, so uniform content lengths indicate you’re receiving
    a standard access denied message. But if you receive a status code 200 response
    and a variable content length, you might have accessed private records.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding More Complex IDORs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complex IDORs can occur when the `id` parameter is buried in a `POST` body or
    is not readily identifiable through the parameter name. You’ll likely encounter
    unobvious parameters, such as `ref`, `user`, or `column` being used as IDs. Even
    when you can’t easily pick out the ID by its parameter name, you might identify
    the parameter if it takes integer values. When you find a parameter that takes
    an integer value, test it to see how the site behavior changes when the ID is
    modified. Again, you can use Burp to help make this easy by intercepting HTTP
    requests, changing the ID, and using the Repeater tool to replay the request.
  prefs: []
  type: TYPE_NORMAL
- en: IDORs are even harder to identify when sites use randomized identifiers, such
    *universal unique identifiers (UUIDs)*. UUIDs are 36-character alphanumeric strings
    that don’t follow a pattern. If you discover a site that uses UUIDs, it will be
    nearly impossible to find a valid record or object by testing random values. Instead,
    you can create two records and switch between them during your testing. For example,
    let’s say you’re trying to access user profiles that are identified using a UUID.
    Create your profile with user A; then log in as user B to try to access user A’s
    profile using its UUID.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you’ll be able to access objects that use UUIDs. But a site might
    not consider this a vulnerability because UUIDs are made to be unguessable. In
    those cases, you’ll need to look for opportunities where the site is disclosing
    the random identifier in question. Let’s say you’re on a team-based site and the
    users are identified by UUIDs. When you invite a user to your team, the HTTP response
    to the invitation might disclose their UUID. In other situations, you might be
    able to search for a record on a website and get a returned result that includes
    the UUID. When you can’t find obvious places where UUIDs are being leaked, review
    the HTML page source code included in HTTP responses, which might disclose information
    that isn’t readily visible on the site. You can do this by monitoring requests
    in Burp or by right-clicking in your web browser and selecting View Page Source.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you can’t find a leaked UUID, some sites will reward the vulnerability
    if the information is sensitive and clearly violates their permission model. It’s
    your responsibility to explain to the company why you believe you’ve found an
    issue they should address and what impact you’ve determined the vulnerability
    has. The following examples demonstrate the range of difficulty in finding IDOR
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Binary.com](http://Binary.com) Privilege Escalation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[www.binary.com](http://www.binary.com)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/98247/](https://hackerone.com/reports/98247/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** November 6, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $300'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re testing web applications that use accounts, you should register
    two different accounts and test them simultaneously. Doing so allows you to test
    for IDORs between two different accounts you control and know what to expect from.
    This is the approach Mahmoud Gamal took when discovering an IDOR in *[binary.com](http://binary.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: The website *[binary.com](http://binary.com)* is a trading platform that allows
    users to trade currencies, indices, stocks, and commodities. At the time of this
    report, the URL *www.binary.com/cashier* would render an iFrame with a `src` attribute
    that referenced the subdomain *cashier.binary.com* and passed URL parameters,
    such as `pin`, `password`, and `secret`, to the website. These parameters were
    likely intended to authenticate users. Because the browser was accessing *www.binary.com/cashier*,
    the information being passed to *cashier.binary.com* wouldn’t be visible without
    viewing the HTTP requests being sent by the website.
  prefs: []
  type: TYPE_NORMAL
- en: Gamal noticed that the `pin` parameter was being used as an account identifier
    and that it appeared to be an easily guessed numerically incremented integer.
    Using two different accounts, which we’ll refer to as account A and account B,
    he visited the */cashier* path on account A, noted the `pin` parameter, and then
    logged into account B. When he modified account B’s iFrame to use account A’s
    pin, he was able to access account A’s information and request withdrawals while
    authenticated as account B.
  prefs: []
  type: TYPE_NORMAL
- en: The team at *[binary.com](http://binary.com)* resolved the report within a day
    of receiving it. They claimed that they manually reviewed and approved withdrawals,
    and so they would have noticed suspicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, a hacker easily tested the bug manually by using a customer pin
    from one account while logged in as a different account. You can also use Burp
    plug-ins, such as Autorize and Authmatrix, to automate this type of testing.
  prefs: []
  type: TYPE_NORMAL
- en: But finding obscure IDORs can be more difficult. This site was using an iFrame,
    which can make the vulnerable URL and its parameters easy to miss because you
    wouldn’t see them in your browser without viewing the HTML page source. The best
    way to track iFrames and cases where multiple URLs might be accessed by a single
    web page is to use a proxy like Burp. Burp will record any `GET` requests to other
    URLs, like *cashier.binary.com*, in the proxy history, making catching requests
    easier for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moneybird App Creation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://moneybird.com/user/applications/](https://moneybird.com/user/applications/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/135989/](https://hackerone.com/reports/135989/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** May 3, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $100'
  prefs: []
  type: TYPE_NORMAL
- en: In May 2016, I began testing Moneybird for vulnerabilities, focusing on its
    user account permissions. To do this, I created a business with account A and
    then invited a second user, account B, to join with limited permissions. Moneybird
    defines permissions that it assigns to added users, such as the ability to use
    invoices, estimates, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user with full permissions could create apps and enable API access. For example,
    a user could submit a `POST` request to create an app with full permissions, which
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `POST` body includes the `administration_id` ➊ parameter.
    This is the account ID that users are added to. Although the length and randomness
    of the ID make it difficult to guess, the ID was immediately disclosed to added
    users when they visited the account that invited them. For example, when account
    B logged in and visited account A, they would be redirected to the URL *https://moneybird.com/ABCDEFGHIJKLMNOP/*,
    where `ABCDEFGHIJKLMNOP` would be the `administration_id` for account A.
  prefs: []
  type: TYPE_NORMAL
- en: I tested to see if account B could create an application for account A’s business
    without the proper permission to do so. I logged in as account B and created a
    second business, which account B was the sole member of. This would give account
    B full permissions on the second business, even though account B should have had
    limited permissions to account A and no ability to create apps for it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I visited account B’s settings page, created an app, and using Burp Suite,
    intercepted the `POST` call to replace `administration_id` with account A’s ID.
    Forwarding the modified request confirmed that the vulnerability worked. As account
    B, I had an app with full permissions to account A. This allowed account B to
    bypass the limited permissions of their account and use the newly created app
    to perform any action they otherwise shouldn’t have had access to.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look for parameters that could contain ID values, such as any parameter names
    that include the characters `id`. Especially be on the lookout for parameter values
    that only include numbers, because those IDs are likely to be generated in some
    guessable way. If you can’t guess an ID, determine whether it’s being leaked somewhere.
    I noticed the `administrator_id` given the ID reference in its name. Although
    the ID values didn’t follow a guessable pattern, the value was being disclosed
    in the URL whenever a user was invited to a company.
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter Mopub API Token Theft**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://mopub.com/api/v3/organizations/ID/mopub/activate/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/95552/](https://hackerone.com/reports/95552/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** October 24, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $5,040'
  prefs: []
  type: TYPE_NORMAL
- en: After discovering any vulnerability, make sure to consider the impact it would
    have if an attacker abused it. In October 2015, Akhil Reni reported that Twitter’s
    Mopub application (a 2013 acquisition) was vulnerable to an IDOR that leaked API
    keys and a secret. But several weeks later, Reni realized the vulnerability was
    more severe than he initially reported and submitted an update. Luckily, he made
    his update before Twitter paid a bounty for his vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Reni initially submitted his report, he found that a Mopub endpoint hadn’t
    properly authorized users and would leak an account’s API key and `build_secret`
    in a `POST` response. Here’s what the `POST` request looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And the response to the request was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Mopub’s `POST` response provides the `api_key` ➋ and `build_secret` ➌, which
    Reni reported to Twitter in his initial report. But accessing the information
    also requires knowing an `organization_id` ➊, which is an unguessable 24-digit
    string. Reni noticed that users could share application crash issues publicly
    via a URL, such as *http://crashes.to/s/<11 CHARACTERS>*. Visiting one of these
    URLs would return the unguessable `organization_id` in the response body. Reni
    was able to enumerate `organization_id` values by visiting the URLs returned using
    the Google dork *site:http://crashes.to/s/*. With the `api_key`, `build_secret`,
    and `organization_id`, an attacker could steal API tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter resolved the vulnerability and asked Reni to confirm he could no longer
    access the vulnerable information. It was at that point that Reni realized the
    `build_secret` returned in the HTTP response was also used in the URL *https://app.mopub.com/complete/htsdk/?code=*<*BUILDSECRET>&amp;next=%2d*.
    This URL authenticated a user and redirected them to the associated Mopub account,
    which would have allowed a malicious user to log into the account of any other
    user. The malicious user would have had access to the target account’s apps and
    organizations from Twitter’s mobile development platform. Twitter responded to
    Reni’s comment requesting additional information and the steps to reproduce the
    attack, which Reni provided.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Always be sure to confirm the full impact of your bugs, especially when it comes
    to IDORs. In this case, Reni found he could obtain secret values by accessing
    `POST` requests and using a single Google dork. Reni initially reported that Twitter
    was leaking sensitive information, but only later did he realize how these values
    were used on the platform. If Reni hadn’t provided additional information after
    submitting his report, Twitter likely wouldn’t have realized that they were vulnerable
    to account takeovers and they might have paid Reni less.
  prefs: []
  type: TYPE_NORMAL
- en: '**ACME Customer Information Disclosure**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://www.<acme>.com/customer_summary?customer_id=abeZMloJyUovapiXqrHyi0DshH*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** February 20, 2017'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $3,000'
  prefs: []
  type: TYPE_NORMAL
- en: This bug is part of a private program on HackerOne. This vulnerability remains
    undisclosed, and all information in it has been anonymized.
  prefs: []
  type: TYPE_NORMAL
- en: A company, which I’ll refer to as ACME Corp for the sake of this example, created
    software that allows administrators to create users and assign permissions to
    those users. When I started testing the software for vulnerabilities, I used my
    administrator account to create a second user with no permissions. Using the second
    user account, I began visiting URLs the administrator was able to access that
    shouldn’t have been accessible to the second user.
  prefs: []
  type: TYPE_NORMAL
- en: Using my unprivileged account, I visited a customer details page through the
    URL *www.<acme>.com/customization/customer_summary?customer_id=abeZMloJyUovapiXqrHyi0DshH*.
    This URL returns customer information based on the ID passed to the `customer_id`
    parameter. I was surprised to see that customer details were being returned to
    the second user account.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `customer_id` appeared to be unguessable, it might be mistakenly
    disclosed on the site somewhere. Alternatively, if a user had their permission
    revoked, they would still be able to access customer information if they knew
    the `customer_id`. I reported the bug with this reasoning. In hindsight, I should
    have looked for the leaked `customer_id` before reporting.
  prefs: []
  type: TYPE_NORMAL
- en: The program closed my report as informative on the grounds that the `customer_id`
    was unguessable. Informative reports don’t result in a bounty and can negatively
    impact your HackerOne stats. Undeterred, I started looking for places where the
    ID could be leaked by testing all the endpoints I could find. Two days later,
    I found a vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'I began accessing URLs with a user that only had permission to search orders
    and shouldn’t have had any access to customer or product information. But I found
    a response from an order search that produced the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the JSON includes a `customer_id` ➊, which was the same as the ID
    being used in the URL that would display customer information. This meant that
    the customer ID was being leaked, and an unprivileged user could find and access
    customer information they shouldn’t have had the permissions to see.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to finding the `customer_id`, I continued to investigate the extent
    of the vulnerability. I discovered other IDs that could also be used in URLs to
    return information that should have been inaccessible. My second report was accepted
    and paid a bounty.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you find a vulnerability, make sure you understand the extent to which
    an attacker can use it. Try to find leaked identifiers or other IDs that could
    have a similar vulnerability. Additionally, don’t be discouraged if a program
    disagrees with your report. You can keep looking for other places in which you
    might be able to use the vulnerability and can submit another report if you find
    any further information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IDORs occur when an attacker can access or modify a reference to an object
    that they shouldn’t be able to access. IDORs can be simple: they might require
    exploiting numerically incremented integers by adding and subtracting 1\. For
    more complex IDORs that make use of UUIDs or random identifiers, you might need
    to test the platform thoroughly for leaks. You can check for leaks in a variety
    of places, such as in JSON responses, in HTML content, through Google dorks, and
    through URLs. When you’re reporting, be sure to detail how an attacker can abuse
    the vulnerability. For example, the bounty for a vulnerability where an attacker
    could bypass platform permissions will be less than the bounty for a bug that
    results in a full account takeover.'
  prefs: []
  type: TYPE_NORMAL
