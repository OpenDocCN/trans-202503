<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_165"/><span class="big">11</span><br/>CREATING GRAPHS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">When you make a graph for a formal report, you want to have titles, axis labels, and perhaps other features that will help the reader understand what you are trying to say. In this chapter, we’ll show you how to create such a graph using Haskell. We’ll look at titles, axis labels, and other labels. We’ll see how to plot data given in the form of a list of pairs. Then we’ll show how to plot multiple functions or multiple datasets on the same set of axes, how to control the axis ranges, and how to produce your graph as a file that can be imported into some other document.</p>&#13;
<h3 class="h3" id="ch11lev1"><span epub:type="pagebreak" id="page_166"/>Title and Axis Labels</h3>&#13;
<p class="noindent">The following code produces a graph with a title and axis labels:</p>&#13;
<pre>{-# OPTIONS_GHC -Wall #-}&#13;
&#13;
import Graphics.Gnuplot.Simple&#13;
&#13;
type R = Double&#13;
&#13;
tRange :: [R]&#13;
tRange = [0,0.01..5]&#13;
&#13;
yPos :: R  -- y0&#13;
     -&gt; R  -- vy0&#13;
     -&gt; R  -- ay&#13;
     -&gt; R  -- t&#13;
     -&gt; R  -- y&#13;
yPos y0 vy0 ay t = y0 + vy0 * t + ay * t**2 / 2&#13;
&#13;
plot1 :: IO ()&#13;
plot1 = plotFunc [Title "Projectile Motion"&#13;
                 ,XLabel "Time (s)"&#13;
                 ,YLabel "Height of projectile (m)"&#13;
                 ,PNG "projectile.png"&#13;
                 ,Key Nothing&#13;
                 ] tRange (yPos 0 20 (-9.8))</pre>&#13;
<p class="indent">As in the last chapter, we turn on warnings to catch any poor programming we might not have intended. Then we import the <code>Graphics.Gnuplot.Simple</code> module, which we use to make plots. Next, we set up <code>R</code> as a <em>type synonym</em> for <code>Double</code>. This lets us think of <code>Double</code>s as real numbers and call them by the short name <code>R</code>. We then define a list tRange of time values that we will use in our plot, and we define a function yPos for the height of a projectile.</p>&#13;
<p class="indent">Finally, we define plot1 to make a plot. Recall that plotFunc has type</p>&#13;
<pre>[Attribute] -&gt; [a] -&gt; (a -&gt; a) -&gt; IO ()</pre>&#13;
<p class="noindent">where <code>a</code> is a type in some specialized type classes. The <code>Attribute</code> type is defined in the <code>Graphics.Gnuplot.Simple</code> module. If you type <code>:i Attribute</code> at the GHCi prompt (:i is short for :info), you’ll see some options for what you can do with these <code>Attribute</code>s. In <code>plot1</code>, we pass a list of five <code>Attribute</code>s to <code>plotFunc</code>. The first creates the title, the second and third produce axis labels, the fourth specifies the filename to use for the output, and the last requests that a legend not appear.</p>&#13;
<p class="indent">Notice the type <code>IO ()</code> (pronounced “eye oh unit”) of plot1. <code>IO</code> is a type constructor, like <code>Maybe</code>, but it’s a special type constructor that’s designed to <span epub:type="pagebreak" id="page_167"/>signal an effect, which is a computation that is not purely functional. An effect changes the world in some way (for example, changing a file on the hard drive or showing a picture on the screen).</p>&#13;
<p class="indent">The type <code>()</code>, called <em>unit</em>, is a type that contains only one value, which is also written <code>()</code> and also called unit. A type with only one value can’t convey any information because there is no choice about what the value might be. Since it cannot convey any information, the unit type by itself is not too useful. However, coupled with the <code>IO</code> type constructor, the type <code>IO ()</code> comes to represent an effect without a value, which is a very useful type.</p>&#13;
<p class="indent">The <code>Attribute</code> of <code>Key Nothing</code> omits the key that is included with the graph by default. Since the key makes reference to a temporary file that we don’t care about, it is generally uninformative to include the default key. The reader should be warned that the <code>Graphics.Gnuplot.Simple</code> module is not merely simple, but a bit simple-minded. In particular, if an invalid <code>gnuplot</code> keyword is passed through a Haskell <code>String</code>, the result is no output at all, not even an error. (For example, if you want to move the legend key to the bottom of the plot instead of the top, the attribute <code>Key (Just ["bottom"])</code> works, but <code>Key (Just ["Bottom"])</code> fails with no output because <code>gnuplot</code> keywords are case sensitive.) The reader is encouraged to consult the online documentation for the <code>Graphics.Gnuplot.Simple</code> module as well as the documentation for the <code>gnuplot</code> program itself.</p>&#13;
<p class="indent">If you load the code just shown into GHCi and enter plot1 at the prompt, it will produce a file called <em>projectile.png</em> on your hard drive that you can include in a document. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> shows what it looks like.</p>&#13;
<div class="imagel" id="ch11fig1"><img src="Images/167fig01.jpg" alt="Image" width="527" height="394"/></div>&#13;
<p class="figcap"><em>Figure 11-1: Graph produced by the function <span class="codeitalic1">plot1</span></em></p>&#13;
<h3 class="h3" id="ch11lev2"><span epub:type="pagebreak" id="page_168"/>Other Labels</h3>&#13;
<p class="noindent">You may want to put other labels on a plot. Here is how you can do so:</p>&#13;
<pre>plot1Custom :: IO ()&#13;
plot1Custom&#13;
    = plotFunc [Title "Projectile Motion"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Height of projectile (m)"&#13;
               ,PNG "CustomLabel.png"&#13;
               ,Key Nothing&#13;
               ,Custom "label" ["\"Peak Height\" at 1.5,22"]&#13;
               ] tRange (yPos 0 20 (-9.8))</pre>&#13;
<p class="indent">Note the <code>Custom</code> attribute we added. The backslash in front of the quotes is because we need to pass quotes inside of quotes. The coordinates <code>1.5,22</code> are the horizontal and vertical coordinates on the graph where we want the label to appear. <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> shows what this looks like.</p>&#13;
<div class="imagel" id="ch11fig2"><img src="Images/168fig01.jpg" alt="Image" width="527" height="394"/></div>&#13;
<p class="figcap"><em>Figure 11-2: Graph produced by the function <span class="codeitalic1">plot1Custom</span></em></p>&#13;
<p class="indent">The syntax for including a custom label is sufficiently awkward and difficult to remember that it makes sense to write a new function that takes its arguments in a simpler way.</p>&#13;
<pre>customLabel :: (R,R) -&gt; String -&gt; Attribute&#13;
customLabel (x,y) label&#13;
     = Custom "label" ["\"" ++ label ++ "\"" ++ " at "&#13;
                                ++ show x ++ "," ++ show y]</pre>&#13;
<p class="indent">We are passing two pieces of information to the custom label function: the coordinates of the location of the label and the name of the label. The first piece of information has type <code>(R,R)</code>, and the second has type <code>String</code>. Our <span epub:type="pagebreak" id="page_169"/>function <code>customLabel</code> will produce an <code>Attribute</code> that can be included in the attribute list of the function <code>plotFunc</code>. We use the <code>show</code> function to convert an <code>R</code> to a <code>String</code>, and we use the <code>++</code> operator to concatenate strings.</p>&#13;
<p class="indent">We refer to the double-quote character in Haskell by prefixing it with a backslash. The backslash tells the compiler that we mean to write the double-quote character itself rather than to signal the beginning of a string. Having done this, we can treat the double quote character as any other character.</p>&#13;
<pre>Prelude&gt;  <span class="codestrong1">:t 'c'</span>&#13;
'c' :: Char&#13;
Prelude&gt;  <span class="codestrong1">:t '\"'</span>&#13;
'\"' :: Char&#13;
Prelude&gt;  <span class="codestrong1">:t "c"</span>&#13;
"c" :: [Char]&#13;
Prelude&gt;  <span class="codestrong1">:t "\""</span>&#13;
"\"" :: [Char]</pre>&#13;
<p class="indent">Having defined the function <code>customLabel</code>, we can use the following nicer syntax to make our graph:</p>&#13;
<pre>plot2Custom :: IO ()&#13;
plot2Custom&#13;
    = plotFunc [Title "Projectile Motion"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Height of projectile (m)"&#13;
               ,Key Nothing&#13;
               ,customLabel (1.5,22) "Peak Height"&#13;
               ] tRange (yPos 0 20 (-9.8))</pre>&#13;
<h3 class="h3" id="ch11lev3">Plotting Data</h3>&#13;
<p class="noindent">There will be times when we want to plot points of (x, y) pairs rather than functions. We can use the plotPath function for this (also defined in the package <code>Graphics.Gnuplot.Simple</code>). Let’s take a look at the type of the plotPath function to better understand its use.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gnuplot.Simple</span>&#13;
Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t plotPath</span>&#13;
plotPath&#13;
  :: Graphics.Gnuplot.Value.Tuple.C a =&gt;&#13;
     [Attribute] -&gt; [(a, a)] -&gt; IO ()</pre>&#13;
<p class="indent">After a list of attributes, <code>plotPath</code> takes a list of pairs containing the data we want to plot. Here is code to produce the same graph as in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> but using <code>plotPath</code> instead of <code>plotFunc</code>:</p>&#13;
<pre>plot3Custom :: IO ()&#13;
plot3Custom&#13;
    = plotPath [Title "Projectile Motion"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Height of projectile (m)"&#13;
               ,Key Nothing&#13;
               ,customLabel (1.5,22) "Peak Height"&#13;
               ] [(t, yPos 0 20 (-9.8) t) | t &lt;- tRange]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>We used a list comprehension to produce the list of pairs that <code>plotPath</code> requires.</p>&#13;
<h3 class="h3" id="ch11lev4">Multiple Curves on One Set of Axes</h3>&#13;
<p class="noindent">You can plot multiple curves on a single set of axes. This is particularly useful if you want to compare two functions that have the same independent and dependent variables. The function <code>plotFuncs</code> from <code>Graphics.Gnuplot.Simple</code> enables us to plot a list of functions.</p>&#13;
<pre>Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t plotFuncs</span>&#13;
plotFuncs&#13;
   :: (Graphics.Gnuplot.Value.Atom.C a,&#13;
       Graphics.Gnuplot.Value.Tuple.C a) =&gt;&#13;
      [Attribute] -&gt; [a] -&gt; [a -&gt; a] -&gt; IO ()</pre>&#13;
<p class="indent">Notice that the plotFuncs function takes a list of functions as one of its arguments. We promised back in <a href="ch05.xhtml">Chapter 5</a> that we would find a use for a list of functions, and now we have! Here is an example of how to use <code>plotFuncs</code>:</p>&#13;
<pre>xRange :: [R]&#13;
xRange = [0,0.02..10]&#13;
&#13;
f3 :: R -&gt; R&#13;
f3 x = exp (-x)&#13;
&#13;
usePlotFuncs :: IO ()&#13;
usePlotFuncs = plotFuncs [] xRange [cos,sin,f3]</pre>&#13;
<p class="indent">The range of x-values does not have to be the same for the two plots. Consider the following example, which introduces the new function plotPaths.</p>&#13;
<pre>xs1, xs2 :: [R]&#13;
xs1 = [0,0.1..10]&#13;
xs2 = [-5,-4.9..5]&#13;
&#13;
xys1, xys2 :: [(R,R)]&#13;
xys1 = [(x,cos x) | x &lt;- xs1]&#13;
xys2 = [(x,sin x) | x &lt;- xs2]&#13;
&#13;
usePlotPaths :: IO ()&#13;
usePlotPaths = plotPaths [] [xys1,xys2]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>The <code>plotPaths</code> function takes a list of lists of pairs where the <code>plotPath</code> function takes a list of pairs.</p>&#13;
<h3 class="h3" id="ch11lev5">Controlling the Plot Ranges</h3>&#13;
<p class="noindent">By default, <code>gnuplot</code> (the program that is making the graphs behind the scenes) will make plots based on the x-ranges you provide and the corresponding calculated y-ranges. Sometimes, you may want more control over the x-range or the y-range.</p>&#13;
<p class="indent">Revisiting the previous example of three plots, try the following:</p>&#13;
<pre>usePlotFuncs' :: IO ()&#13;
usePlotFuncs' = plotFuncs [ XRange (-2,8)&#13;
                          , YRange (-0.2,1)&#13;
                          ] xRange [cos,sin,f3]</pre>&#13;
<p class="indent">By specifying <code>XRange (-2,8)</code>, we produce a graph that runs from <em>x</em> = –2 to <em>x</em> = 8. Since <code>xRange</code> runs from 0 to 10, no data is calculated in the region from <em>x</em> = –2 to <em>x</em> = 0, so this region is blank on the graph. Although we ask for data to be calculated up to <em>x</em> = 10, it is only shown up to <em>x</em> = 8. Because we specify <code>YRange (-0.2,1)</code>, values of the cosine and sine functions that fall in the region from <em>y</em> = –1 to <em>y</em> = –0.2 are not shown.</p>&#13;
<p class="indent">Notice the funny stylistic way in which I made the list [XRange (-2,8), YRange (-0.2,1)]. People who code in Haskell sometimes put the comma first on the second line of the list, but you don’t have to. You could put this all on one line, or put the comma at the end of the first line. It’s a matter of style.</p>&#13;
<h3 class="h3" id="ch11lev6">Making a Key</h3>&#13;
<p class="noindent">The default key that <code>gnuplot</code> provides with a graph is not very useful. It gives the name of a temporary file we are not interested in. It is not a trivial thing to produce a handsome key, but it can be done. The following code gives an example:</p>&#13;
<pre>xRange' :: [R]&#13;
xRange' = [-10.0, -9.99 .. 10.0]&#13;
&#13;
sinPath :: [(R,R)]&#13;
sinPath = [(x, sin x) | x &lt;- xRange' ]&#13;
&#13;
cosPath :: [(R,R)]&#13;
cosPath = [(x, cos x) | x &lt;- xRange' ]&#13;
&#13;
plot4 :: IO ()&#13;
plot4 = plotPathsStyle [ Title "Sine and Cosine"&#13;
                       , XLabel "x"&#13;
                       , YLabel "Function Value"&#13;
                       , YRange (-1.2,1.5)&#13;
                       ] [ (defaultStyle {lineSpec = CustomStyle&#13;
                                          [LineTitle "sin x"]}, sinPath)&#13;
                         , (defaultStyle {lineSpec = CustomStyle&#13;
                                          [LineTitle "cos x"]}, cosPath) ]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_172"/>Here we use the function <code>plotPathsStyle</code>, which is an extended version of <code>plotPaths</code> that allows stylistic alterations. Instead of the list of lists of pairs that <code>plotPaths</code> requires, <code>plotPathsStyle</code> requires a list of pairs, with each pair consisting of a <code>PlotStyle</code> and a list of pairs with the data to be plotted. In this way, we can give a title to each curve that shows up in the key.</p>&#13;
<h3 class="h3" id="ch11lev7">Summary</h3>&#13;
<p class="noindent">In this chapter, we added plotting tools to our toolkit. We learned how to provide a title, axis labels, and other labels to a graph. We learned how to plot data given in the form of a list of pairs. We saw how to plot multiple functions or multiple lists of pairs on a single set of axes. We learned how to manually control the axis ranges and how to produce the graph as a file that can be imported into another document. In the next chapter, we’ll learn how to make stand-alone programs in Haskell.</p>&#13;
<h3 class="h3" id="ch11lev8">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 11.1.</strong> Make a plot of <em>y</em> = <em>x</em><sup>2</sup> from <em>x</em> = –3 to <em>x</em> = 3 with a title and axis labels.</p>&#13;
<p class="noindentts"><strong>Exercise 11.2.</strong> Make a plot of the cosine and sine functions, together on a single set of axes, from <em>x</em> = 0 to <em>x</em> = 10.</p>&#13;
<p class="noindentts"><strong>Exercise 11.3.</strong> Take a look at the type signature for <code>plotPath</code>, and figure out how to plot the list of points <code>txPairs</code> below:</p>&#13;
<pre>ts :: [R]&#13;
ts = [0,0.1..6]&#13;
&#13;
txPairs :: [(R,R)]&#13;
txPairs = [(t,30 * t - 4.9 * t**2) | t &lt;- ts]</pre>&#13;
<p class="indent">Make a plot with a title and axis labels (with units).</p>&#13;
<p class="noindentts"><strong>Exercise 11.4.</strong> Write a function</p>&#13;
<pre>approxsin :: R -&gt; R&#13;
approxsin = undefined</pre>&#13;
<p class="noindentts">that approximates the sine function by the first four terms in its Taylor expansion.</p>&#13;
<div class="imagec"><img src="Images/172equ01.jpg" alt="Image" width="138" height="49"/></div>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_173"/>(Depending on how you do this, you may or may not run into the issue that you cannot divide an <code>R</code> by an <code>Int</code> or an <code>Integer</code> in Haskell. You can only divide a numeric type by the same numeric type. If you run into this problem, you can use the function <code>fromIntegral</code> to convert an <code>Int</code> or an <code>Integer</code> to some other type, like <code>R</code>.)</p>&#13;
<p class="indent">Test your function by trying the following command in GHCi:</p>&#13;
<pre>plotFuncs [] [-4,-3.99..4] [sin,approxsin]</pre>&#13;
<p class="indent">Make a nice version of this plot (with a title, axis labels, labels to indicate which curve is which, and so on).<span epub:type="pagebreak" id="page_174"/></p>&#13;
</div></body></html>