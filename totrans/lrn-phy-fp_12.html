<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_165"/><span class="big">11</span><br/>CREATING GRAPHS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">When you make a graph for a formal report, you want to have titles, axis labels, and perhaps other features that will help the reader understand what you are trying to say. In this chapter, we’ll show you how to create such a graph using Haskell. We’ll look at titles, axis labels, and other labels. We’ll see how to plot data given in the form of a list of pairs. Then we’ll show how to plot multiple functions or multiple datasets on the same set of axes, how to control the axis ranges, and how to produce your graph as a file that can be imported into some other document.</p>&#13;
<h3 class="h3" id="ch11lev1"><span epub:type="pagebreak" id="page_166"/>Title and Axis Labels</h3>&#13;
<p class="noindent">The following code produces a graph with a title and axis labels:</p>&#13;
<pre>{-# OPTIONS_GHC -Wall #-}&#13;
&#13;
import Graphics.Gnuplot.Simple&#13;
&#13;
type R = Double&#13;
&#13;
tRange :: [R]&#13;
tRange = [0,0.01..5]&#13;
&#13;
yPos :: R  -- y0&#13;
     -&gt; R  -- vy0&#13;
     -&gt; R  -- ay&#13;
     -&gt; R  -- t&#13;
     -&gt; R  -- y&#13;
yPos y0 vy0 ay t = y0 + vy0 * t + ay * t**2 / 2&#13;
&#13;
plot1 :: IO ()&#13;
plot1 = plotFunc [Title "Projectile Motion"&#13;
                 ,XLabel "Time (s)"&#13;
                 ,YLabel "Height of projectile (m)"&#13;
                 ,PNG "projectile.png"&#13;
                 ,Key Nothing&#13;
                 ] tRange (yPos 0 20 (-9.8))</pre>&#13;
<p class="indent">As in the last chapter, we turn on warnings to catch any poor programming we might not have intended. Then we import the <span class="literal">Graphics.Gnuplot.Simple</span> module, which we use to make plots. Next, we set up <span class="literal">R</span> as a <em>type synonym</em> for <span class="literal">Double</span>. This lets us think of <span class="literal">Double</span>s as real numbers and call them by the short name <span class="literal">R</span>. We then define a list tRange of time values that we will use in our plot, and we define a function yPos for the height of a projectile.</p>&#13;
<p class="indent">Finally, we define plot1 to make a plot. Recall that plotFunc has type</p>&#13;
<pre>[Attribute] -&gt; [a] -&gt; (a -&gt; a) -&gt; IO ()</pre>&#13;
<p class="noindent">where <span class="literal">a</span> is a type in some specialized type classes. The <span class="literal">Attribute</span> type is defined in the <span class="literal">Graphics.Gnuplot.Simple</span> module. If you type <span class="literal">:i Attribute</span> at the GHCi prompt (:i is short for :info), you’ll see some options for what you can do with these <span class="literal">Attribute</span>s. In <span class="literal">plot1</span>, we pass a list of five <span class="literal">Attribute</span>s to <span class="literal">plotFunc</span>. The first creates the title, the second and third produce axis labels, the fourth specifies the filename to use for the output, and the last requests that a legend not appear.</p>&#13;
<p class="indent">Notice the type <span class="literal">IO ()</span> (pronounced “eye oh unit”) of plot1. <span class="literal">IO</span> is a type constructor, like <span class="literal">Maybe</span>, but it’s a special type constructor that’s designed to <span epub:type="pagebreak" id="page_167"/>signal an effect, which is a computation that is not purely functional. An effect changes the world in some way (for example, changing a file on the hard drive or showing a picture on the screen).</p>&#13;
<p class="indent">The type <span class="literal">()</span>, called <em>unit</em>, is a type that contains only one value, which is also written <span class="literal">()</span> and also called unit. A type with only one value can’t convey any information because there is no choice about what the value might be. Since it cannot convey any information, the unit type by itself is not too useful. However, coupled with the <span class="literal">IO</span> type constructor, the type <span class="literal">IO ()</span> comes to represent an effect without a value, which is a very useful type.</p>&#13;
<p class="indent">The <span class="literal">Attribute</span> of <span class="literal">Key Nothing</span> omits the key that is included with the graph by default. Since the key makes reference to a temporary file that we don’t care about, it is generally uninformative to include the default key. The reader should be warned that the <span class="literal">Graphics.Gnuplot.Simple</span> module is not merely simple, but a bit simple-minded. In particular, if an invalid <span class="literal">gnuplot</span> keyword is passed through a Haskell <span class="literal">String</span>, the result is no output at all, not even an error. (For example, if you want to move the legend key to the bottom of the plot instead of the top, the attribute <span class="literal">Key (Just ["bottom"])</span> works, but <span class="literal">Key (Just ["Bottom"])</span> fails with no output because <span class="literal">gnuplot</span> keywords are case sensitive.) The reader is encouraged to consult the online documentation for the <span class="literal">Graphics.Gnuplot.Simple</span> module as well as the documentation for the <span class="literal">gnuplot</span> program itself.</p>&#13;
<p class="indent">If you load the code just shown into GHCi and enter plot1 at the prompt, it will produce a file called <em>projectile.png</em> on your hard drive that you can include in a document. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> shows what it looks like.</p>&#13;
<div class="imagel" id="ch11fig1"><img src="Images/167fig01.jpg" alt="Image" width="527" height="394"/></div>&#13;
<p class="figcap"><em>Figure 11-1: Graph produced by the function <span class="codeitalic1">plot1</span></em></p>&#13;
<h3 class="h3" id="ch11lev2"><span epub:type="pagebreak" id="page_168"/>Other Labels</h3>&#13;
<p class="noindent">You may want to put other labels on a plot. Here is how you can do so:</p>&#13;
<pre>plot1Custom :: IO ()&#13;
plot1Custom&#13;
    = plotFunc [Title "Projectile Motion"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Height of projectile (m)"&#13;
               ,PNG "CustomLabel.png"&#13;
               ,Key Nothing&#13;
               ,Custom "label" ["\"Peak Height\" at 1.5,22"]&#13;
               ] tRange (yPos 0 20 (-9.8))</pre>&#13;
<p class="indent">Note the <span class="literal">Custom</span> attribute we added. The backslash in front of the quotes is because we need to pass quotes inside of quotes. The coordinates <span class="literal">1.5,22</span> are the horizontal and vertical coordinates on the graph where we want the label to appear. <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> shows what this looks like.</p>&#13;
<div class="imagel" id="ch11fig2"><img src="Images/168fig01.jpg" alt="Image" width="527" height="394"/></div>&#13;
<p class="figcap"><em>Figure 11-2: Graph produced by the function <span class="codeitalic1">plot1Custom</span></em></p>&#13;
<p class="indent">The syntax for including a custom label is sufficiently awkward and difficult to remember that it makes sense to write a new function that takes its arguments in a simpler way.</p>&#13;
<pre>customLabel :: (R,R) -&gt; String -&gt; Attribute&#13;
customLabel (x,y) label&#13;
     = Custom "label" ["\"" ++ label ++ "\"" ++ " at "&#13;
                                ++ show x ++ "," ++ show y]</pre>&#13;
<p class="indent">We are passing two pieces of information to the custom label function: the coordinates of the location of the label and the name of the label. The first piece of information has type <span class="literal">(R,R)</span>, and the second has type <span class="literal">String</span>. Our <span epub:type="pagebreak" id="page_169"/>function <span class="literal">customLabel</span> will produce an <span class="literal">Attribute</span> that can be included in the attribute list of the function <span class="literal">plotFunc</span>. We use the <span class="literal">show</span> function to convert an <span class="literal">R</span> to a <span class="literal">String</span>, and we use the <span class="literal">++</span> operator to concatenate strings.</p>&#13;
<p class="indent">We refer to the double-quote character in Haskell by prefixing it with a backslash. The backslash tells the compiler that we mean to write the double-quote character itself rather than to signal the beginning of a string. Having done this, we can treat the double quote character as any other character.</p>&#13;
<pre>Prelude&gt;  <span class="codestrong1">:t 'c'</span>&#13;
'c' :: Char&#13;
Prelude&gt;  <span class="codestrong1">:t '\"'</span>&#13;
'\"' :: Char&#13;
Prelude&gt;  <span class="codestrong1">:t "c"</span>&#13;
"c" :: [Char]&#13;
Prelude&gt;  <span class="codestrong1">:t "\""</span>&#13;
"\"" :: [Char]</pre>&#13;
<p class="indent">Having defined the function <span class="literal">customLabel</span>, we can use the following nicer syntax to make our graph:</p>&#13;
<pre>plot2Custom :: IO ()&#13;
plot2Custom&#13;
    = plotFunc [Title "Projectile Motion"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Height of projectile (m)"&#13;
               ,Key Nothing&#13;
               ,customLabel (1.5,22) "Peak Height"&#13;
               ] tRange (yPos 0 20 (-9.8))</pre>&#13;
<h3 class="h3" id="ch11lev3">Plotting Data</h3>&#13;
<p class="noindent">There will be times when we want to plot points of (x, y) pairs rather than functions. We can use the plotPath function for this (also defined in the package <span class="literal">Graphics.Gnuplot.Simple</span>). Let’s take a look at the type of the plotPath function to better understand its use.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gnuplot.Simple</span>&#13;
Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t plotPath</span>&#13;
plotPath&#13;
  :: Graphics.Gnuplot.Value.Tuple.C a =&gt;&#13;
     [Attribute] -&gt; [(a, a)] -&gt; IO ()</pre>&#13;
<p class="indent">After a list of attributes, <span class="literal">plotPath</span> takes a list of pairs containing the data we want to plot. Here is code to produce the same graph as in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> but using <span class="literal">plotPath</span> instead of <span class="literal">plotFunc</span>:</p>&#13;
<pre>plot3Custom :: IO ()&#13;
plot3Custom&#13;
    = plotPath [Title "Projectile Motion"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Height of projectile (m)"&#13;
               ,Key Nothing&#13;
               ,customLabel (1.5,22) "Peak Height"&#13;
               ] [(t, yPos 0 20 (-9.8) t) | t &lt;- tRange]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>We used a list comprehension to produce the list of pairs that <span class="literal">plotPath</span> requires.</p>&#13;
<h3 class="h3" id="ch11lev4">Multiple Curves on One Set of Axes</h3>&#13;
<p class="noindent">You can plot multiple curves on a single set of axes. This is particularly useful if you want to compare two functions that have the same independent and dependent variables. The function <span class="literal">plotFuncs</span> from <span class="literal">Graphics.Gnuplot.Simple</span> enables us to plot a list of functions.</p>&#13;
<pre>Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t plotFuncs</span>&#13;
plotFuncs&#13;
   :: (Graphics.Gnuplot.Value.Atom.C a,&#13;
       Graphics.Gnuplot.Value.Tuple.C a) =&gt;&#13;
      [Attribute] -&gt; [a] -&gt; [a -&gt; a] -&gt; IO ()</pre>&#13;
<p class="indent">Notice that the plotFuncs function takes a list of functions as one of its arguments. We promised back in <a href="ch05.xhtml">Chapter 5</a> that we would find a use for a list of functions, and now we have! Here is an example of how to use <span class="literal">plotFuncs</span>:</p>&#13;
<pre>xRange :: [R]&#13;
xRange = [0,0.02..10]&#13;
&#13;
f3 :: R -&gt; R&#13;
f3 x = exp (-x)&#13;
&#13;
usePlotFuncs :: IO ()&#13;
usePlotFuncs = plotFuncs [] xRange [cos,sin,f3]</pre>&#13;
<p class="indent">The range of x-values does not have to be the same for the two plots. Consider the following example, which introduces the new function plotPaths.</p>&#13;
<pre>xs1, xs2 :: [R]&#13;
xs1 = [0,0.1..10]&#13;
xs2 = [-5,-4.9..5]&#13;
&#13;
xys1, xys2 :: [(R,R)]&#13;
xys1 = [(x,cos x) | x &lt;- xs1]&#13;
xys2 = [(x,sin x) | x &lt;- xs2]&#13;
&#13;
usePlotPaths :: IO ()&#13;
usePlotPaths = plotPaths [] [xys1,xys2]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>The <span class="literal">plotPaths</span> function takes a list of lists of pairs where the <span class="literal">plotPath</span> function takes a list of pairs.</p>&#13;
<h3 class="h3" id="ch11lev5">Controlling the Plot Ranges</h3>&#13;
<p class="noindent">By default, <span class="literal">gnuplot</span> (the program that is making the graphs behind the scenes) will make plots based on the x-ranges you provide and the corresponding calculated y-ranges. Sometimes, you may want more control over the x-range or the y-range.</p>&#13;
<p class="indent">Revisiting the previous example of three plots, try the following:</p>&#13;
<pre>usePlotFuncs' :: IO ()&#13;
usePlotFuncs' = plotFuncs [ XRange (-2,8)&#13;
                          , YRange (-0.2,1)&#13;
                          ] xRange [cos,sin,f3]</pre>&#13;
<p class="indent">By specifying <span class="literal">XRange (-2,8)</span>, we produce a graph that runs from <em>x</em> = –2 to <em>x</em> = 8. Since <span class="literal">xRange</span> runs from 0 to 10, no data is calculated in the region from <em>x</em> = –2 to <em>x</em> = 0, so this region is blank on the graph. Although we ask for data to be calculated up to <em>x</em> = 10, it is only shown up to <em>x</em> = 8. Because we specify <span class="literal">YRange (-0.2,1)</span>, values of the cosine and sine functions that fall in the region from <em>y</em> = –1 to <em>y</em> = –0.2 are not shown.</p>&#13;
<p class="indent">Notice the funny stylistic way in which I made the list [XRange (-2,8), YRange (-0.2,1)]. People who code in Haskell sometimes put the comma first on the second line of the list, but you don’t have to. You could put this all on one line, or put the comma at the end of the first line. It’s a matter of style.</p>&#13;
<h3 class="h3" id="ch11lev6">Making a Key</h3>&#13;
<p class="noindent">The default key that <span class="literal">gnuplot</span> provides with a graph is not very useful. It gives the name of a temporary file we are not interested in. It is not a trivial thing to produce a handsome key, but it can be done. The following code gives an example:</p>&#13;
<pre>xRange' :: [R]&#13;
xRange' = [-10.0, -9.99 .. 10.0]&#13;
&#13;
sinPath :: [(R,R)]&#13;
sinPath = [(x, sin x) | x &lt;- xRange' ]&#13;
&#13;
cosPath :: [(R,R)]&#13;
cosPath = [(x, cos x) | x &lt;- xRange' ]&#13;
&#13;
plot4 :: IO ()&#13;
plot4 = plotPathsStyle [ Title "Sine and Cosine"&#13;
                       , XLabel "x"&#13;
                       , YLabel "Function Value"&#13;
                       , YRange (-1.2,1.5)&#13;
                       ] [ (defaultStyle {lineSpec = CustomStyle&#13;
                                          [LineTitle "sin x"]}, sinPath)&#13;
                         , (defaultStyle {lineSpec = CustomStyle&#13;
                                          [LineTitle "cos x"]}, cosPath) ]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_172"/>Here we use the function <span class="literal">plotPathsStyle</span>, which is an extended version of <span class="literal">plotPaths</span> that allows stylistic alterations. Instead of the list of lists of pairs that <span class="literal">plotPaths</span> requires, <span class="literal">plotPathsStyle</span> requires a list of pairs, with each pair consisting of a <span class="literal">PlotStyle</span> and a list of pairs with the data to be plotted. In this way, we can give a title to each curve that shows up in the key.</p>&#13;
<h3 class="h3" id="ch11lev7">Summary</h3>&#13;
<p class="noindent">In this chapter, we added plotting tools to our toolkit. We learned how to provide a title, axis labels, and other labels to a graph. We learned how to plot data given in the form of a list of pairs. We saw how to plot multiple functions or multiple lists of pairs on a single set of axes. We learned how to manually control the axis ranges and how to produce the graph as a file that can be imported into another document. In the next chapter, we’ll learn how to make stand-alone programs in Haskell.</p>&#13;
<h3 class="h3" id="ch11lev8">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 11.1.</strong> Make a plot of <em>y</em> = <em>x</em><sup>2</sup> from <em>x</em> = –3 to <em>x</em> = 3 with a title and axis labels.</p>&#13;
<p class="noindentts"><strong>Exercise 11.2.</strong> Make a plot of the cosine and sine functions, together on a single set of axes, from <em>x</em> = 0 to <em>x</em> = 10.</p>&#13;
<p class="noindentts"><strong>Exercise 11.3.</strong> Take a look at the type signature for <span class="literal">plotPath</span>, and figure out how to plot the list of points <span class="literal">txPairs</span> below:</p>&#13;
<pre>ts :: [R]&#13;
ts = [0,0.1..6]&#13;
&#13;
txPairs :: [(R,R)]&#13;
txPairs = [(t,30 * t - 4.9 * t**2) | t &lt;- ts]</pre>&#13;
<p class="indent">Make a plot with a title and axis labels (with units).</p>&#13;
<p class="noindentts"><strong>Exercise 11.4.</strong> Write a function</p>&#13;
<pre>approxsin :: R -&gt; R&#13;
approxsin = undefined</pre>&#13;
<p class="noindentts">that approximates the sine function by the first four terms in its Taylor expansion.</p>&#13;
<div class="imagec"><img src="Images/172equ01.jpg" alt="Image" width="138" height="49"/></div>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_173"/>(Depending on how you do this, you may or may not run into the issue that you cannot divide an <span class="literal">R</span> by an <span class="literal">Int</span> or an <span class="literal">Integer</span> in Haskell. You can only divide a numeric type by the same numeric type. If you run into this problem, you can use the function <span class="literal">fromIntegral</span> to convert an <span class="literal">Int</span> or an <span class="literal">Integer</span> to some other type, like <span class="literal">R</span>.)</p>&#13;
<p class="indent">Test your function by trying the following command in GHCi:</p>&#13;
<pre>plotFuncs [] [-4,-3.99..4] [sin,approxsin]</pre>&#13;
<p class="indent">Make a nice version of this plot (with a title, axis labels, labels to indicate which curve is which, and so on).<span epub:type="pagebreak" id="page_174"/></p>&#13;
</div></body></html>