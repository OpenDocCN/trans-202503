<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2s" id="ch00"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">0</span> <span class="float">Randomness</span></strong></h2>&#13;
<p class="bq"><em>The generation of random numbers is too important to be left to chance.</em></p>&#13;
<p class="att">—Robert R. Coveyou</p>&#13;
<div class="image"><img src="../images/pg41_Image_7.jpg" alt="Image" width="938" height="605"/></div>&#13;
<p class="caption"><strong>Random number tables from <em>A Million Random Digits with 100,000 Normal Deviates</em> by the RAND Corporation</strong></p>&#13;
<p class="noindent7">In 1947, the RAND Corporation produced a peculiar book titled <em>A Million Random Digits with 100,000 Normal Deviates</em>. The book wasn’t a work of literature or a philosophical treatise on randomness. Rather, it was a table of random numbers generated using an electronic simulation of a roulette wheel. This book was one of the last in a series of random-number tables produced from the mid-1920s to the 1950s. With the development of high-speed computers, it became faster to generate pseudorandom numbers than to read them from tables, and so this era of printed random-number tables ultimately came to an end.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_2"/>Here we are: the beginning. If it’s been a while since you’ve programmed in JavaScript (or done any math, for that matter), this chapter will reacquaint your mind with computational thinking. To start your coding-of-nature journey, I’ll introduce you to some foundational tools for programming simulations: random numbers, random distributions, and noise. Think of this as the first (zeroth!) element of the array that makes up this book—a refresher and a gateway to the possibilities that lie ahead.</p>&#13;
<div class="imagel"><img src="../images/pg42_Image_8.jpg" alt="Image" width="1125" height="733"/></div>&#13;
<p class="noindent">In <a href="ch01.xhtml#ch01">Chapter 1</a>, I’m going to talk about the concept of a vector and how it will serve as the building block for simulating motion throughout this book. But before I take that step, let’s think about what it means for something to move around a digital canvas. I’ll begin with one of the best-known and simplest simulations of motion: the random walk.</p>&#13;
<h3 class="h3" id="ch00lev1sec10"><strong>Random Walks</strong></h3>&#13;
<p class="noindent">Imagine you’re standing in the middle of a balance beam. Every 10 seconds, you flip a coin. Heads, take a step forward. Tails, take a step backward. This is a <strong>random walk</strong>, a path defined as a series of random steps. Stepping (carefully) off that balance beam and onto the floor, you could expand your random walk from one dimension (moving only forward and back) to two dimensions (moving forward, back, left, and right). Now that there are four possibilities, you’d have to flip the same coin twice to determine each next step.</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td class="borderb"><span epub:type="pagebreak" id="page_3"/><p class="tab-para"><strong>Flip 1</strong></p></td>&#13;
<td class="borderb"><p class="tab-para"><strong>Flip 2</strong></p></td>&#13;
<td class="borderb"><p class="tab-para"><strong>Result</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Heads</p></td>&#13;
<td class="borderb"><p class="tab-para">Heads</p></td>&#13;
<td class="borderb"><p class="tab-para">Step forward.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Heads</p></td>&#13;
<td class="borderb"><p class="tab-para">Tails</p></td>&#13;
<td class="borderb"><p class="tab-para">Step right.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Tails</p></td>&#13;
<td class="borderb"><p class="tab-para">Heads</p></td>&#13;
<td class="borderb"><p class="tab-para">Step left.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Tails</p></td>&#13;
<td><p class="tab-para">Tails</p></td>&#13;
<td><p class="tab-para">Step backward.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">This may seem like an unsophisticated algorithm, but you can use random walks to model all sorts of phenomena that occur in the real world, from the movements of molecules in a gas, to the foraging of an animal, to the behavior of a gambler spending a day at the casino. For our purposes, the random walk is the perfect place to start for three reasons:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">I’d like to review a programming concept central to this book: object-oriented programming (OOP). The random walker I’m about to create will serve as a template for using object-oriented design to make things that move around a computer graphics canvas.</li>&#13;
<li class="noindent">The random walk instigates the two questions that I’ll ask over and over again throughout this book: “How do you define the rules that govern the behavior of your objects?” and then, “How do you implement these rules in code?”</li>&#13;
<li class="noindent">You’ll periodically need a basic understanding of randomness, probability, and Perlin noise for this book’s projects. The random walk will allow me to demonstrate key points that will come in handy later.</li>&#13;
</ul>&#13;
<p class="noindent">I’ll first review a bit of OOP by coding a <span class="literal">Walker</span> class to create <span class="literal">Walker</span> objects that can go for a random walk. This will be only a cursory review. If you’ve never worked with OOP before, you may want something more comprehensive; I’d suggest stopping here and reviewing the “Objects” section of my “Code! Programming with p5.js” video course at the Coding Train website (<em><a href="https://thecodingtrain.com/objects">https://thecodingtrain.com/objects</a></em>).</p>&#13;
<h3 class="h3" id="ch00lev1sec11"><strong>The Random Walker Class</strong></h3>&#13;
<p class="noindent">An <strong>object</strong> in JavaScript is an entity that has both data and functionality. In this case, a <span class="literal">Walker</span> object should have data about its position on the canvas and functionality such as the capability to draw itself or take a step.</p>&#13;
<p class="noindent">A <strong>class</strong> is the template for building actual instances of objects. Think of a class as the cookie cutter and objects as the cookies themselves. To create a <span class="literal">Walker</span> object, I’ll begin by defining the <span class="literal">Walker</span> class—what it means to be a walker.</p>&#13;
<p class="noindent">A walker needs only two pieces of data: a number for its x-position and a number for its y-position. I’ll initialize them to the center of the canvas to set the object’s starting position. I can do this in the <span epub:type="pagebreak" id="page_4"/>class’s <strong>constructor</strong> function, appropriately named <span class="literal">constructor()</span>. You can think of the constructor as the object’s <span class="literal">setup()</span> function. It’s responsible for defining the initial properties of an object, much like <span class="literal">setup()</span> does for the entire sketch:</p>&#13;
<div class="imagel"><img src="../images/pg44_Image_9.jpg" alt="Image" width="1138" height="242"/></div>&#13;
<p class="noindent">Notice the use of the keyword <span class="literal">this</span> to attach the properties to the newly created object itself: <span class="literal">this.x</span> and <span class="literal">this.y</span>.</p>&#13;
<p class="noindent">In addition to data, classes can be defined with functionality. In this example, a <span class="literal">Walker</span> object has two functions, known as <strong>methods</strong> in an OOP context. While methods are essentially functions, the distinction is that methods are defined inside a class and therefore are associated with an object or class, whereas functions aren’t. The <span class="literal">function</span> keyword is a nice clue: you’ll see it when defining stand-alone functions, but it won’t appear inside a class. I’ll try my best to use the terms consistently in this book, but it’s common for programmers to use the terms <em>function</em> and <em>method</em> interchangeably.</p>&#13;
<p class="noindent">The first method, <span class="literal">show()</span>, includes the code to draw the object (as a black dot). Once again, never forget the <span class="literal">this.</span> when referencing the properties (variables) of that object:</p>&#13;
<div class="imagel"><img src="../images/pg44_Image_10.jpg" alt="Image" width="1139" height="189"/></div>&#13;
<p class="noindent">The next method, <span class="literal">step()</span>, directs the <span class="literal">Walker</span> object to take a step. This is where things get a bit more interesting. Remember taking steps in random directions on a floor? Now I’ll use a p5.js canvas to represent that floor. There are four possible steps. A step to the right can be simulated by incrementing <span class="literal">x</span> with <span class="literal">x++</span>; to the left by decrementing <span class="literal">x</span> with <span class="literal">x--</span>; forward by going up a pixel ( <span class="literal">y--</span> ); and backward by going down a pixel ( <span class="literal">y++</span> ). But how can the code pick from these four choices?</p>&#13;
<p class="noindent">Earlier I stated that you could flip two coins. In p5.js, however, when you want to randomly choose from a list of options, you can simply generate a random number with the <span class="literal">random()</span> function. It picks a random floating-point (decimal) value within any range you want. Here, I use 4 to indicate a range of 0 to 4:</p>&#13;
<pre class="pre">let choice = floor(random(4));</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_5"/>I declare a variable <span class="literal">choice</span> and assign it a random integer (whole number) by using <span class="literal">floor()</span> to remove the decimal places from the random floating-point number. Technically speaking, the number generated by <span class="literal">random(4)</span> lies within the range of 0 (inclusive) to 4 (exclusive), meaning it can never actually be 4.0. The highest possible number it could generate is just below 4—3.999999999 (with as many 9s as JavaScript will allow), which <span class="literal">floor()</span> then truncates down to 3, removing the decimal part. Therefore, I’ve effectively assigned <span class="literal">choice</span> a value of 0, 1, 2, or 3.</p>&#13;
<div class="box">&#13;
<p class="box-title"><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>Coding Conventions</strong></p>&#13;
<p class="noindent">In JavaScript, variables can be declared using either <span class="literal">let</span> or <span class="literal">const</span>. A typical approach is to declare all variables with <span class="literal">const</span> and change to <span class="literal">let</span> when needed. In this first example, <span class="literal">const</span> would be appropriate for declaring <span class="literal">choice</span> as it’s never reassigned a new value over the course of its life inside each call to <span class="literal">step()</span>. While this differentiation is important, I’m choosing to follow the p5.js example convention and declare all variables with <span class="literal">let</span>.</p>&#13;
<p class="noindent">I recognize that JavaScript has both <span class="literal">const</span> and <span class="literal">let</span> for important reasons. However, the distinction can be a distraction and confusing for beginners. I encourage you to explore the topic further and make your own decisions about how to best declare variables in your own sketches. For more, you can read the discussion surrounding issue #3877 in the p5.js GitHub repository (<em><a href="https://github.com/processing/p5.js/issues/3877">https://github.com/processing/p5.js/issues/3877</a></em>).</p>&#13;
<p class="noindent">I’m also choosing to use JavaScript’s strict equality ( <span class="literal">===</span> ) operator (and its inequality counterpart, <span class="literal">!==</span>). This Boolean operator tests both value and type equality. For example, <span class="literal">3 === '3'</span> will evaluate to <span class="literal">false</span> because the types are different (number versus string), even though they look similar. On the other hand, using the loose equality ( <span class="literal">==</span> ) operator in <span class="literal">3 == '3'</span> would result in <span class="literal">true</span> because the two different types are converted to be comparable. Although the loose comparison often works fine, it can sometimes lead to unexpected results, so <span class="literal">===</span> is probably the safer choice.</p>&#13;
</div>&#13;
<p class="noindent">Next, the walker takes the appropriate step (left, right, up, or down), depending on which random number was picked. Here’s the full <span class="literal">step()</span> method closing out the <span class="literal">Walker</span> class:</p>&#13;
<div class="imagel"><img src="../images/pg45_Image_12.jpg" alt="Image" width="1138" height="525"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_6"/>Now that I’ve written the class, it’s time to make an actual <span class="literal">Walker</span> object in the sketch itself. Assuming you’re looking to model a single random walk, start with a single global variable:</p>&#13;
<div class="imagel"><img src="../images/pg46_Image_14.jpg" alt="Image" width="1125" height="59"/></div>&#13;
<p class="noindent">Then create the object in <span class="literal">setup()</span> by referencing the class name with the <span class="literal">new</span> operator:</p>&#13;
<div class="imagel"><img src="../images/pg46_Image_15.jpg" alt="Image" width="1125" height="253"/></div>&#13;
<p class="noindent">Finally, during each cycle through <span class="literal">draw()</span>, the walker takes a step and draws a dot.</p>&#13;
<div class="imagel" id="ch0ex1"><img src="../images/pg46_Image_16.jpg" alt="Image" width="1126" height="762"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_7"/>Since the background is drawn once in <span class="literal">setup()</span>, rather than clearing it continually each time through <span class="literal">draw()</span>, the trail of the random walk is visible in the canvas.</p>&#13;
<p class="noindent">I could make a couple of adjustments to the random walker. For one, this <span class="literal">Walker</span> object’s steps are limited to four options: up, down, left, and right. But any given pixel in the canvas could have eight possible neighbors, including diagonals (see <a href="ch00.xhtml#ch0fig1">Figure 0.1</a>). A ninth possibility, to stay in the same place, could also be an option.</p>&#13;
<div class="image"><img id="ch0fig1" src="../images/pg47_Image_17.jpg" alt="Image" width="1009" height="509"/></div>&#13;
<p class="figcap">Figure 0.1: The steps of a random walker, with and without diagonals</p>&#13;
<p class="noindent">To implement a <span class="literal">Walker</span> object that can step to any neighboring pixel (or stay put), I could pick a number from 0 to 8 (nine possible choices). However, another way to write the code would be to pick from three possible steps along the x-axis (–1, 0, or 1) and three possible steps along the y-axis:</p>&#13;
<div class="imagel"><img src="../images/pg47_Image_18.jpg" alt="Image" width="1125" height="239"/></div>&#13;
<p class="noindent">Taking this further, I could get rid of <span class="literal">floor()</span> and use the <span class="literal">random()</span> function’s original floating-point numbers to create a continuous range of possible step lengths from –1 to 1, as shown next.</p>&#13;
<div class="imagel"><img src="../images/pg47_Image_19.jpg" alt="Image" width="1125" height="237"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_8"/>All of these variations on the traditional random walk have one thing in common: at any moment in time, the probability that the walker will take a step in a given direction is equal to the probability that the walker will take a step in any other direction. In other words, if there are four possible steps, there is a 1 in 4 (or 25 percent) chance the walker will take any given step. With nine possible steps, it’s a 1 in 9 chance (about 11.1 percent).</p>&#13;
<p class="noindent">Conveniently, this is how the <span class="literal">random()</span> function works. p5.js’s random-number generator (which operates behind the scenes) produces a <strong>uniform distribution</strong> of numbers. You can test this distribution by counting each time a random number is picked and graphing those values.</p>&#13;
<div class="imagel" id="ch0ex2"><img src="../images/pg48_Image_21.jpg" alt="Image" width="1125" height="1360"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_9"/>Notice that each bar of the graph differs slightly in height. The sample size (the number of random numbers picked) is small, so occasional discrepancies emerge as certain numbers are picked more often than others. Over time, with a good random-number generator, this distribution would even out.</p>&#13;
<div class="box">&#13;
<p class="box-title"><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>Pseudorandom Numbers</strong></p>&#13;
<p class="noindent">The random numbers from the <span class="literal">random()</span> function aren’t truly random; instead, they’re <strong>pseudorandom</strong> because they’re the result of a mathematical function that merely simulates randomness. This function would yield a pattern over time and thus stop seeming to be random. That time period is so long, however, that <span class="literal">random()</span> is random enough for the examples in this book.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe1"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.1</strong></p>&#13;
<p class="noindent">Create a random walker that has a greater tendency to move down and to the right. (The solution follows in the next section.)</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec12"><strong>Probability and Nonuniform Distributions</strong></h3>&#13;
<p class="noindent">Uniform randomness often isn’t the most thoughtful solution to a design problem—in particular, the kind of problem that involves building an organic or natural-looking simulation. With a few tricks, however, the <span class="literal">random()</span> function can instead produce <strong>nonuniform distributions</strong> of random numbers, where some outcomes are more likely than others. This type of distribution can yield more interesting, seemingly natural results.</p>&#13;
<p class="noindent">Think about when you first started programming with p5.js. Perhaps you wanted to draw a lot of circles on the screen, so you said to yourself, “Oh, I know! I’ll draw all these circles at random positions, with random sizes and random colors.” Seeding a system with randomness is a perfectly reasonable starting point when you’re learning the basics of computer graphics, but in this book, I’m looking to build systems modeled on what we see in nature, and uniform randomness won’t always cut it. Sometimes you have to put your thumb on the scales a little bit.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_10"/>Creating a nonuniform distribution of random numbers will come in handy throughout the book. In <a href="ch09.xhtml#ch09">Chapter 9</a>’s genetic algorithms, for example, I’ll need a methodology for performing selection—which members of the population should be selected to pass their DNA to the next generation? This is akin to the Darwinian concept of survival of the fittest. Say you have an evolving population of monkeys. Not every monkey has an equal chance of reproducing. To simulate Darwinian natural selection, you can’t simply pick two random monkeys to be parents. The more “fit” ones should be more likely to be chosen. This could be considered the <em>probability of the fittest</em>.</p>&#13;
<p class="noindent">Let me pause here and take a look at probability’s basic principles so I can apply more precise words to the coding examples to come. I’ll start with <strong>single-event probability</strong>—the likelihood that a given event will occur. In probability, <strong>outcomes</strong> refer to all the possible results of a random process, and an <strong>event</strong> is the specific outcome or combination of outcomes being considered.</p>&#13;
<p class="noindent">If you have a scenario where each outcome is just as likely as the others, the probability of a given event occurring equals the number of outcomes that match that event divided by the total number of all potential outcomes. A coin toss is a simple example: it has only two possible outcomes, heads or tails. There’s only one heads, so the probability that the coin will turn up heads is 1 divided by 2: 1/2, or 50 percent.</p>&#13;
<p class="noindent">Take a deck of 52 cards. The probability of drawing an ace from that deck is as follows:</p>&#13;
<p class="hang">number of aces / number of cards = 4/52 = 0.077 ≈ 8%</p>&#13;
<p class="noindent">The probability of drawing a diamond is shown here:</p>&#13;
<p class="hang">number of diamonds / number of cards = 13/52 = 0.25 = 25%</p>&#13;
<p class="noindent">You can also calculate the probability of multiple events occurring in sequence by multiplying the individual probabilities of each event. For example, here’s the probability of a coin turning up heads three times in a row:</p>&#13;
<p class="hang">(1/2) × (1/2) × (1/2) = 1/8 = 0.125 = 12.5%</p>&#13;
<p class="noindent">This indicates a coin will turn up heads three times in a row one out of eight times on average. If you flip a coin three times in a row 500 times, you would expect to see an outcome of three consecutive heads an average of one-eighth of the time, or about 63 times.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe2"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.2</strong></p>&#13;
<p class="noindent">What is the probability of drawing two aces in a row from a deck of 52 cards, if you reshuffle your first draw back into the deck before making your second draw? What would that probability be if you didn’t reshuffle after your first draw?</p>&#13;
</div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_11"/>You can use the <span class="literal">random()</span> function in a couple of ways to apply the concepts of probability in your code for a nonuniform distribution. One technique is to fill an array with numbers—some of which are repeated—and then choose random elements from that array and generate events based on those choices:</p>&#13;
<div class="imagel"><img src="../images/pg51_Image_24.jpg" alt="Image" width="1125" height="209"/></div>&#13;
<p class="noindent">The five-member array has two 1s, so running this code will produce a two-out-of-five chance, or 40 percent chance, of printing the value 1. Likewise, there’s a 20 percent chance of printing 2 and a 40 percent chance of printing 3.</p>&#13;
<p class="noindent">You can also ask for a random number (let’s make it simple and just consider random floating-point values from 0 to 1) and allow an event to occur only if the random number is within a certain range. For example:</p>&#13;
<div class="imagel"><img src="../images/pg51_Image_25.jpg" alt="Image" width="1125" height="234"/></div>&#13;
<p class="noindent">One-tenth of the floating-point numbers from 0 to 1 are less than 0.1, so this code will lead to singing only 10 percent of the time.</p>&#13;
<p class="noindent">You can use the same approach to apply unequal weights to multiple outcomes. Let’s say you want singing to have a 60 percent chance of happening; dancing, a 10 percent chance; and sleeping, a 30 percent chance. Again, you can pick a random number from 0 to 1 and see where it falls:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">From 0.0 to 0.6 (60 percent) → Singing</li>&#13;
<li class="noindent">From 0.6 to 0.7 (10 percent) → Dancing</li>&#13;
<li class="noindent">From 0.7 to 1.0 (30 percent) → Sleeping</li>&#13;
</ul>&#13;
<div class="imagel"><img src="../images/pg51_Image_26.jpg" alt="Image" width="1125" height="317"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_12"/>Now let’s apply this methodology to the random walker so it tends to move in a particular direction. Here’s an example of a <span class="literal">Walker</span> object with the following probabilities:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">Chance of moving up: 20 percent</li>&#13;
<li class="noindent">Chance of moving down: 20 percent</li>&#13;
<li class="noindent">Chance of moving left: 20 percent</li>&#13;
<li class="noindent">Chance of moving right: 40 percent</li>&#13;
</ul>&#13;
<div class="imagel" id="ch0ex3"><img src="../images/pg52_Image_28.jpg" alt="Image" width="1126" height="945"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_13"/>Another common use of this technique is to control the probability of an event that you want to occur sporadically in your code. For example, let’s say you create a sketch that starts a new random walker at regular time intervals (every 100 frames). With <span class="literal">random()</span>, you could instead assign a 1 percent chance of a new walker starting. The end result is the same (a new walker every 1 out of 100 frames on average), but the latter incorporates chance and feels more dynamic and unpredictable.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe3"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.3</strong></p>&#13;
<p class="noindent">Create a random walker with dynamic probabilities. For example, can you give it a 50 percent chance of moving in the direction of the mouse? Remember, you can use <span class="literal">mouseX</span> and <span class="literal">mouseY</span> to get the current mouse position in p5.js!</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec13"><strong>A Normal Distribution of Random Numbers</strong></h3>&#13;
<p class="noindent">Another way to create a nonuniform distribution of random numbers is to use a <strong>normal distribution</strong>, where the numbers cluster around an average value. To see why this is useful, let’s go back to that population of simulated monkeys and assume your sketch generates a thousand <span class="literal">Monkey</span> objects, each with a random height value of 200 to 300 (as this is a world of monkeys that have heights of 200 to 300 pixels):</p>&#13;
<pre class="pre">let h = random(200, 300);</pre>&#13;
<p class="noindent">Is this an accurate algorithm for creating a population of monkey heights? Think of a crowded sidewalk in New York City. Pick any person off the street, and it may appear that their height is random. Nevertheless, it’s not the kind of random that <span class="literal">random()</span> produces by default. People’s heights aren’t uniformly distributed; there are many more people of about average height than there are very tall or very short ones. To accurately reflect this population, random heights close to the <strong>mean</strong> (another word for <em>average</em>) should be more likely to be chosen, while outlying heights (very short or very tall) should be rarer.</p>&#13;
<p class="noindent">That’s exactly how a normal distribution (sometimes called a Gaussian distribution, after mathematician Carl Friedrich Gauss) works. A graph of this distribution is informally known as a <strong>bell curve</strong>. The curve is generated by a mathematical function that defines the probability of any given value occurring as a function of the mean (often written as µ, the Greek letter mu) and standard deviation (σ, the Greek letter sigma).</p>&#13;
<p class="noindent">In the case of height values from 200 to 300, you probably have an intuitive sense of the mean (average) as 250. However, what if I were to say that the standard deviation is 3? Or 15? What does this mean for the numbers? The graphs depicted in <a href="ch00.xhtml#ch0fig2">Figure 0.2</a> should give you a hint.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_14"/><img id="ch0fig2" src="../images/pg54_Image_29.jpg" alt="Image" width="1125" height="451"/></div>&#13;
<p class="figcap">Figure 0.2: Two example bell curves of a normal distribution, with a low (left) and high (right) standard deviation</p>&#13;
<p class="noindent">On the left is a distribution with a very low standard deviation, with the majority of the values piling up around the mean (they don’t deviate much from the standard). The version on the right has a higher standard deviation, so the values are more evenly spread out from the average (they deviate more).</p>&#13;
<p class="noindent">The numbers work out as follows: given a population, 68 percent of its members will have values in the range of one standard deviation from the mean, 95 percent within two standard deviations, and 99.7 percent within three standard deviations. Given a standard deviation of 5 pixels, only 0.3 percent of the monkey heights will be less than 235 pixels (three standard deviations below the mean of 250) or greater than 265 pixels (three standard deviations above the mean of 250). Meanwhile, 68 percent of the monkey heights will be from 245 to 255 pixels.</p>&#13;
<p class="noindent">Luckily, to use a normal distribution of random numbers in a p5.js sketch, you don’t have to do any of these calculations manually. Instead, the <span class="literal">randomGaussian()</span> function takes care of the math and returns random numbers with a normal distribution:</p>&#13;
<div class="imagel"><img src="../images/pg54_Image_30.jpg" alt="Image" width="1125" height="156"/></div>&#13;
<div class="box">&#13;
<p class="box-title"><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>Calculating Mean and Standard Deviation</strong></p>&#13;
<p class="noindent">Consider a class of 10 students who receive the following scores (out of 100) on a test: 85, 82, 88, 86, 85, 93, 98, 40, 73, and 83.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_15"/>The mean is the average: 81.3.</p>&#13;
<p class="noindent">The standard deviation is calculated as the square root of the average of the squares of deviations around the mean. In other words, take the difference between the mean and each person’s grade, and square it, giving you that person’s squared deviation. Next, calculate the average of all these values to get the average variance. Then, take the square root of the average variance, and you have the standard deviation.</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para"><strong>Score</strong></p></td>&#13;
<td class="borderb"><p class="tab-para"><strong>Difference from Mean</strong></p></td>&#13;
<td class="borderb"><p class="tab-para"><strong>Variance</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">85</p></td>&#13;
<td class="borderb"><p class="tab-para">85 − 81.3 = 3.7</p></td>&#13;
<td class="borderb"><p class="tab-para">(3.7)<sup>2</sup> = 13.69</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">40</p></td>&#13;
<td class="borderb"><p class="tab-para">40 - 81.3 = -41.3</p></td>&#13;
<td class="borderb"><p class="tab-para">(-41.3)<sup>2</sup> = 1,705.69</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">. . .</p></td>&#13;
<td class="borderb"><p class="tab-para"> </p></td>&#13;
<td class="borderb"><p class="tab-para"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"> </p></td>&#13;
<td><p class="tab-para"><strong>Average Variance:</strong></p></td>&#13;
<td><p class="tab-para">228.21</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">The standard deviation is the square root of the variance: 15.13.</p>&#13;
</div>&#13;
<p class="noindent">What next? What if, for example, the goal is to assign the x-position of a shape drawn?</p>&#13;
<p class="noindent">By default, the <span class="literal">randomGaussian()</span> function returns a normal distribution of random positive and negative numbers with a mean of 0 and a standard deviation of 1. This is also known as the <strong>standard normal distribution</strong>. Often, however, these default parameters won’t work. For example, say you want to randomly assign the x-position of a shape by using a normal distribution with a mean of 320 (the center horizontal pixel in a window of width 640) and a standard deviation of 60 pixels. In this case, you can adjust the parameters by passing the <span class="literal">randomGaussian()</span> function two arguments: the mean followed by the standard deviation.</p>&#13;
<div class="imagel" id="ch0ex4"><img src="../images/pg55_Image_31.jpg" alt="Image" width="1125" height="779"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_16"/>Here I’ve used arguments to customize the call to <span class="literal">randomGaussian()</span>, but note that the math to implement this customization is quite simple: all you have to do is multiply the value from the standard normal distribution by the standard deviation and then add the mean. In other words, assigning <span class="literal">x</span> to <span class="literal">randomGaussian(320, 60)</span> is the same as the following:</p>&#13;
<pre class="pre">let x = 60 * randomGaussian() + 320;</pre>&#13;
<p class="noindent">By drawing the circles on top of one another with transparency, you can begin to see the distribution. The darkest spot is near the center, where most of the values cluster, but every so often circles are drawn farther to the right or left of the center.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe4"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.4</strong></p>&#13;
<p class="noindent">Consider a simulation of paint splatter drawn as a collection of colored dots. Most of the paint clusters around a central position, but some dots splatter out toward the edges. Can you use a normal distribution of random numbers to generate the positions of the dots? Can you also use a normal distribution of random numbers to generate a color palette? Try creating a slider to adjust the standard deviation.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe5"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.5</strong></p>&#13;
<p class="noindent">A Gaussian random walk is defined as one in which the step size (how far the object moves in a given direction) is generated with a normal distribution. Implement this variation of the <span class="literal">Walker</span> class.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec14"><strong>A Custom Distribution of Random Numbers</strong></h3>&#13;
<p class="noindent">There will come a time in your life when you don’t want a uniform distribution of random values, or even a Gaussian one. Imagine for a moment that you’re a random walker in search of food. Moving randomly around a space seems like a reasonable strategy for finding something to eat. After all, you don’t know where the food is, so you might as well search randomly until you find it. However, there’s a problem. As you may have noticed while watching your <span class="literal">Walker</span> object in action, random walkers <span epub:type="pagebreak" id="page_17"/>return to previously visited positions many times, a phenomenon known as <strong>oversampling</strong>. This could make your search for food fruitless, or at least inefficient.</p>&#13;
<p class="noindent">One strategy to avoid such a problem is to take a very large step every so often. This allows the walker to forage randomly around a specific position while periodically jumping far away to reduce the amount of oversampling. This variation on the random walk, known as a <strong>Lévy flight</strong>, requires a custom set of probabilities. Though it’s not an exact implementation of a Lévy flight, you could state the probability distribution as follows: the longer the step, the less likely it is to be picked; the shorter the step, the more likely.</p>&#13;
<p class="noindent">Earlier I wrote that you could generate custom probability distributions by filling an array with values (some duplicated so as to be picked more frequently) or by testing the result of <span class="literal">random()</span>. One way to implement a Lévy flight might be to specify a 1 percent chance of the walker taking a large step:</p>&#13;
<div class="imagel"><img src="../images/pg57_Image_33.jpg" alt="Image" width="1125" height="312"/></div>&#13;
<p class="noindent">However, this reduces the probabilities to a fixed number of options: 99 percent of the time, a small step; 1 percent of the time, a large step. What if you instead wanted to make a more general rule, such as the higher a number, the more likely it is to be picked? For example, 0.8791 would be more likely to be picked than 0.8532, even if that likelihood is just a tiny bit greater. In other words, if <em>x</em> is the random number, the likelihood of it being picked could be mapped to the y-axis with the function <em>y</em> = <em>x</em> (<a href="ch00.xhtml#ch0fig3">Figure 0.3</a>).</p>&#13;
<div class="image"><img id="ch0fig3" src="../images/pg57_Image_34.jpg" alt="Image" width="519" height="367"/></div>&#13;
<p class="figcap">Figure 0.3: A graph of <em>y</em> = <em>x</em>, where <em>y</em> is the probability that a value <em>x</em> will be picked</p>&#13;
<p class="noindent">If a distribution of random numbers can be generated according to the graph in <a href="ch00.xhtml#ch0fig3">Figure 0.3</a>, you should also be able to generate a random distribution that follows any other curve you can define with a formula.</p>&#13;
<p class="noindent">One solution for a custom distribution is to pick two random numbers instead of one. The first random number is just that, a random number. The second one, however, is what I’ll call a <strong>qualifying random value</strong>. This value is used by the program to decide whether to use that first number or throw it away and pick <span epub:type="pagebreak" id="page_18"/>another. Numbers that have an easier time qualifying will be picked more often, and numbers that rarely qualify will be picked infrequently. Here are the steps (for now, I’ll consider only random values from 0 to 1):</p>&#13;
<ol class="order">&#13;
<li class="noindent">Pick a random number: <span class="literal">r1</span>.</li>&#13;
<li class="noindent">Compute a probability <span class="literal">p</span> that <span class="literal">r1</span> should qualify. Let’s try: <span class="literal">p = r1</span>.</li>&#13;
<li class="noindent">Pick another random number: <span class="literal">r2</span>.</li>&#13;
<li class="noindent">If <span class="literal">r2</span> is less than <span class="literal">p</span>, you’ve found your number: <span class="literal">r1</span>!</li>&#13;
<li class="noindent">If <span class="literal">r2</span> isn’t less than <span class="literal">p</span>, go back to step 1 and start over.</li>&#13;
</ol>&#13;
<p class="noindent">Here, the likelihood that a random value will qualify is equal to the random number itself, just as you saw in <a href="ch00.xhtml#ch0fig3">Figure 0.3</a>. If <span class="literal">r1</span> equals 0.1, for example, <span class="literal">r1</span> will have a 10 percent chance of qualifying. If <span class="literal">r1</span> equals 0.83, it will have an 83 percent chance of qualifying. The higher the number, the greater the likelihood that it gets used.</p>&#13;
<p class="noindent">This process is called the <strong>accept-reject algorithm</strong>, a type of Monte Carlo method (named for the Monte Carlo Casino). The following example features a function that implements the accept-reject algorithm, returning a random value from 0 to 1.</p>&#13;
<div class="imagel" id="ch0ex5"><img src="../images/pg58_Image_35.jpg" alt="Image" width="1125" height="932"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_19"/>While the accept-reject algorithm does work for generating custom distributions of random numbers, this technique is not particularly efficient. It can lead to a considerable amount of wasted computation when a large number of random values are rejected, especially when the qualifying probability is very low. When I get to genetic algorithms in <a href="ch09.xhtml#ch09">Chapter 9</a>, I’ll take a different, more optimal approach.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe6"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.6</strong></p>&#13;
<p class="noindent">Use a custom probability distribution to vary the size of the random walker’s steps. The step size can be determined by influencing the range of values picked with a qualifying random value. Can you map the probability to a quadratic function by making the likelihood that a value is picked equal to the value squared?</p>&#13;
<div class="imagel"><img src="../images/pg59_Image_37.jpg" alt="Image" width="1044" height="203"/></div>&#13;
<p class="noindent">(In <a href="ch01.xhtml#ch01">Chapter 1</a>, I’ll show how to vary the step sizes more efficiently with vectors.)</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec15"><strong>A Smoother Approach with Perlin Noise</strong></h3>&#13;
<p class="noindent">A good random-number generator produces numbers that have no relationship to one another and show no discernible pattern. As I’ve hinted, however, while a little bit of randomness can be a good thing when programming organic, lifelike behaviors, uniform randomness as the single guiding principle isn’t necessarily natural. An algorithm known as <strong>Perlin noise</strong>, named for its inventor, Ken Perlin, takes this concept into account by producing a naturally ordered sequence of pseudorandom numbers, where each number in the sequence is quite close in value to the one before it. This creates a “smooth” transition between the random numbers and a more organic appearance than pure noise, making Perlin noise well suited for generating various effects with natural qualities, such as clouds, landscapes, and patterned textures like marble.</p>&#13;
<p class="noindent">To illustrate the difference between Perlin noise and uniform randomness, consider <a href="ch00.xhtml#ch0fig4">Figure 0.4</a>. The graph on the left shows Perlin noise over time, with the x-axis representing time; note the smoothness of the curve. The graph on the right shows noise in the form of purely random numbers over time; the result is much more jagged. (The code for generating these graphs is available on the book’s website.)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_20"/><img id="ch0fig4" src="../images/pg60_Image_38.jpg" alt="Image" width="1125" height="407"/></div>&#13;
<p class="figcap">Figure 0.4: A graph of Perlin noise values over time (left) and of random noise values over time (right)</p>&#13;
<p class="noindent">Ken Perlin developed the original Perlin noise algorithm while working on the movie <em>Tron</em> in the early 1980s; he later received an Academy Award in technical achievement for this work. The algorithm was designed to create procedural textures for computer-generated effects. (<em>Procedural</em> refers to generating the visual elements algorithmically, rather than an artist manually designing them.) Over the years, a variety of other flavors of noise have been developed by different authors. Some notable ones are value noise, Worley noise, and simplex noise (developed by Perlin himself in 2001). You can learn more about the history of Perlin noise at Ken Perlin’s website (<em><a href="https://mrl.nyu.edu/~perlin/doc/oscar.html">https://mrl.nyu.edu/~perlin/doc/oscar.html</a></em>) and its variations over the years in my “What Is OpenSimplex Noise?” video on the Coding Train website (<em><a href="https://thecodingtrain.com/opensimplexnoise">https://thecodingtrain.com/opensimplexnoise</a></em>).</p>&#13;
<p class="noindent">The p5.js library incorporates an implementation of the classic 1983 Perlin noise algorithm in a function called <span class="literal">noise()</span>. It can take one, two, or three arguments, as noise is computed in one, two, or three dimensions. I’ll start by showing you one-dimensional (1D) noise.</p>&#13;
<p class="noindent">Say you want to draw a circle on a canvas at a random x-position. Out of habit, you might use the <span class="literal">random()</span> function:</p>&#13;
<div class="imagel"><img src="../images/pg60_Image_39.jpg" alt="Image" width="1125" height="95"/></div>&#13;
<p class="noindent">Now, instead of a random x-position, you want a smoother Perlin noise x-position. You might think that all you need to do is replace <span class="literal">random()</span> with an identical call to <span class="literal">noise()</span>, like so:</p>&#13;
<div class="imagel"><img src="../images/pg60_Image_40.jpg" alt="Image" width="1125" height="159"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_21"/>Conceptually, this is exactly what you want to do—calculate an x-value that ranges from 0 to the width according to Perlin noise—but this isn’t the correct implementation. While the arguments to the <span class="literal">random()</span> function specify a range of values between a minimum and a maximum, <span class="literal">noise()</span> doesn’t work this way. Instead, its output range is fixed: it always returns a value from 0 to 1. You’ll see in a moment that you can get around this easily with p5.js’s <span class="literal">map()</span> function, but first let’s examine what exactly <span class="literal">noise()</span> expects you to pass in as an argument.</p>&#13;
<p class="noindent">One-dimensional Perlin noise can be thought of as a linear sequence of values over time. For example:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para"><strong>Time</strong></p></td>&#13;
<td class="borderb"><p class="tab-para"><strong>Noise Value</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">0</p></td>&#13;
<td class="borderb"><p class="tab-para">0.365</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">1</p></td>&#13;
<td class="borderb"><p class="tab-para">0.363</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">2</p></td>&#13;
<td class="borderb"><p class="tab-para">0.363</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">3</p></td>&#13;
<td class="borderb"><p class="tab-para">0.364</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">4</p></td>&#13;
<td><p class="tab-para">0.366</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">To access a particular noise value, you have to choose a “moment in time” and pass it to the <span class="literal">noise()</span> function. For example:</p>&#13;
<pre class="pre">let n = noise(3);</pre>&#13;
<p class="noindent">According to the preceding table, <span class="literal">noise(3)</span> returns 0.364. The next step is to use a variable for time and ask for a noise value continuously in <span class="literal">draw()</span>:</p>&#13;
<div class="imagel"><img src="../images/pg61_Image_41.jpg" alt="Image" width="1125" height="265"/></div>&#13;
<p class="noindent">Close, but not quite. This code just prints the same value over and over because it keeps asking for the result of the <span class="literal">noise()</span> function at the same point in time, 3. If the time variable <span class="literal">t</span> increments, however, you’ll get a different noise value each time you call the function:</p>&#13;
<div class="imagel"><img src="../images/pg61_Image_42.jpg" alt="Image" width="1125" height="349"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_22"/>I’ve chosen to increment <span class="literal">t</span> by 0.01, but using a different increment value will affect the smoothness of the noise. Larger jumps in time that skip ahead through the noise space produce values that are less smooth and more random (<a href="ch00.xhtml#ch0fig5">Figure 0.5</a>).</p>&#13;
<div class="image"><img id="ch0fig5" src="../images/pg62_Image_44.jpg" alt="Image" width="979" height="465"/></div>&#13;
<p class="figcap">Figure 0.5: Demonstrating short and long jumps in time in Perlin noise</p>&#13;
<p class="noindent">In the upcoming code examples that utilize Perlin noise, pay attention to how the animation changes with varying values of <span class="literal">t</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec12"><strong>Noise Ranges</strong></h4>&#13;
<p class="noindent">Once you have noise values that range from 0 to 1, it’s up to you to map that range to whatever size suits your purpose. The easiest way to do this is with p5.js’s <span class="literal">map()</span> function (<a href="ch00.xhtml#ch0fig6">Figure 0.6</a>). It takes five arguments. First is the value you want to map—in this case, <span class="literal">n</span>. This is followed by the value’s current range (minimum and maximum), followed by the desired range.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_23"/><img id="ch0fig6" src="../images/pg63_Image_45.jpg" alt="Image" width="993" height="536"/></div>&#13;
<p class="figcap">Figure 0.6: Mapping a value from one range to another</p>&#13;
<p class="noindent">In this case, while noise has a range from 0 to 1, I’d like to draw a circle with an x-position ranging from 0 to the canvas’s width:</p>&#13;
<div class="imagel"><img src="../images/pg63_Image_46.jpg" alt="Image" width="1125" height="337"/></div>&#13;
<p class="noindent">The same logic can be applied to the random walker, assigning both its x- and y-values according to Perlin noise. This creates a smoother, more organic random walk.</p>&#13;
<div class="imagel" id="ch0ex6"><span epub:type="pagebreak" id="page_24"/><img src="../images/pg64_Image_47.jpg" alt="Image" width="1126" height="1063"/></div>&#13;
<p class="noindent">Notice that this example requires a new pair of variables: <span class="literal">tx</span> and <span class="literal">ty</span>. This is because I need to keep track of two time variables, one for the x-position of the <span class="literal">Walker</span> object and one for the y-position. But something is a bit odd about these variables. Why does <span class="literal">tx</span> start at 0 and <span class="literal">ty</span> at 10,000?</p>&#13;
<p class="noindent">While these numbers are arbitrary choices, I’ve intentionally initialized the two time variables this way because the noise function is deterministic: it always gives you the same result for a specific time <span class="literal">t</span>. If I asked for the noise value at the same time <span class="literal">t</span> for both <span class="literal">x</span> and <span class="literal">y</span>, then <span class="literal">x</span> and <span class="literal">y</span> would always be equal, meaning that the <span class="literal">Walker</span> object would move only along a diagonal. Instead, I use two different parts of the noise space, starting at 0 for <span class="literal">x</span> and 10,000 for <span class="literal">y</span> so that <span class="literal">x</span> and <span class="literal">y</span> appear to act independently of each other (<a href="ch00.xhtml#ch0fig7">Figure 0.7</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_25"/><img id="ch0fig7" src="../images/pg65_Image_48.jpg" alt="Image" width="1033" height="447"/></div>&#13;
<p class="figcap">Figure 0.7: Using different offsets along the x-axis to vary Perlin noise values</p>&#13;
<p class="noindent">In truth, no actual concept of time is at play here. It’s a useful metaphor to help describe how the noise function works, but really, what you have is space, rather than time. The graph in <a href="ch00.xhtml#ch0fig7">Figure 0.7</a> depicts a linear sequence of noise values in a 1D space—that is, arranged along a line. Values are retrieved at a specific x-position, which is why you’ll often see a variable named <span class="literal">xoff</span> in examples to indicate the x-offset along the noise graph, rather than <span class="literal">t</span> for time.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe7"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.7</strong></p>&#13;
<p class="noindent">In the Perlin noise random walker, the result of the <span class="literal">noise()</span> function is mapped directly to the walker’s position. Create a random walker, but map the result of the <span class="literal">noise()</span> function to the walker’s step size instead.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec13"><strong>Two-Dimensional Noise</strong></h4>&#13;
<p class="noindent">Having explored the concept of noise values in one dimension, let’s consider how they can also exist in a two-dimensional (2D) space. With 1D noise, there’s a sequence of values in which any given value is similar to its neighbor. Imagine a piece of graph paper (or a spreadsheet!) with the values for 1D noise written across a single row, one value per cell. Because these values live in one dimension, each has only two neighbors: a value that comes before it (to the left) and one that comes after it (to the right), as shown on the left in <a href="ch00.xhtml#ch0fig8">Figure 0.8</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_26"/><img id="ch0fig8" src="../images/pg66_Image_49.jpg" alt="Image" width="1071" height="329"/></div>&#13;
<p class="figcap">Figure 0.8: Comparing neighboring Perlin noise values in one (left) and two (right) dimensions. The cells are shaded according to their Perlin noise value.</p>&#13;
<p class="noindent">Two-dimensional noise works exactly the same way conceptually. The difference, of course, is that the values aren’t written in a linear path along just one row of the graph paper, but rather fill the whole grid. A given value will be similar to all its neighbors: above, below, to the right, to the left, and along any diagonal, as in the right half of <a href="ch00.xhtml#ch0fig8">Figure 0.8</a>.</p>&#13;
<p class="noindent">If you were to visualize this graph paper with each value mapped to the brightness of a color, you would get something that looks like clouds. White sits next to light gray, which sits next to gray, which sits next to dark gray, which sits next to black, which sits next to dark gray, and so on (<a href="ch00.xhtml#ch0fig9">Figure 0.9</a>).</p>&#13;
<div class="image"><img id="ch0fig9" src="../images/pg66_Image_50.jpg" alt="Image" width="1125" height="469"/></div>&#13;
<p class="figcap">Figure 0.9: In this output of a p5.js sketch visualizing 2D noise, each pixel represents a noise value as a grayscale color.</p>&#13;
<p class="noindent">This effect is why noise was originally invented. If you tweak the parameters and play with color, the resulting images look more like marble, wood, or any other organic texture.</p>&#13;
<div class="box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_27"/><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>Noise Detail</strong></p>&#13;
<p class="noindent">The p5.js noise reference explains that noise is calculated over several octaves (<em><a href="https://p5js.org/reference/#/p5/noise">https://p5js.org/reference/#/p5/noise</a></em>). Calling the <span class="literal">noiseDetail()</span> function (<em><a href="https://p5js.org/reference/#/p5/noiseDetail">https://p5js.org/reference/#/p5/noiseDetail</a></em>) changes both the number of octaves and their importance relative to one another. This, in turn, changes the quality of the noise values produced.</p>&#13;
</div>&#13;
<p class="noindent">If you wanted to color every pixel of a canvas randomly using the <span class="literal">random()</span> function, you would need a nested loop to cycle through the rows and columns of pixels and pick a random brightness for each. Note that in p5.js, the pixels are arranged in an array with four spots for each: red, green, blue, and alpha. For details, see the pixel array video in the “Pixels” track on the Coding Train website (<em><a href="https://thecodingtrain.com/pixels">https://thecodingtrain.com/pixels</a></em>).</p>&#13;
<div class="imagel"><img src="../images/pg67_Image_51.jpg" alt="Image" width="1125" height="487"/></div>&#13;
<p class="noindent">To color each pixel more smoothly according to the <span class="literal">noise()</span> function, you can do the same thing, only instead of calling <span class="literal">random()</span>, you’d call <span class="literal">noise()</span>:</p>&#13;
<div class="imagel"><img src="../images/pg67_Image_52.jpg" alt="Image" width="1125" height="59"/></div>&#13;
<p class="noindent">This is a nice start conceptually—the code calculates a noise value for every (<em>x</em>, <em>y</em>) position in a 2D space. The problem is that this won’t have the smooth, cloudy quality you want. Incrementing by 1 through the noise space from one pixel to the next is too large a jump. Remember, with 1D noise, I incremented the time variable by 0.01 each frame, not by 1!</p>&#13;
<p class="noindent">A pretty good solution to this problem is to just use different variables for the noise arguments than those you’re using to access the pixels on the canvas. For example, you can increment a variable called <span class="literal">xoff</span> by 0.01 each time <span class="literal">x</span> increases horizontally by 1, and a <span class="literal">yoff</span> variable by 0.01 each time <span class="literal">y</span> increases vertically by 1 through the nested loops, as shown next.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_28"/><img src="../images/pg68_Image_53.jpg" alt="Image" width="1125" height="659"/></div>&#13;
<p class="noindent">I have to confess, I’ve done something rather confusing. I used <em>1D</em> noise to set <em>two</em> variables ( <span class="literal">this.x</span> and <span class="literal">this.y</span> ) controlling the 2D motion of a walker. Then, I promptly moved on to using <em>2D</em> noise to set <em>one</em> variable ( <span class="literal">bright</span> ) controlling the brightness of each pixel in the canvas.</p>&#13;
<p class="noindent">The key difference here is that for the walker, my goal is to have two independent <em>1D</em> noise values; it’s just a coincidence that I’m using them to move an object through <em>2D</em> space. The way to accomplish this is to use two offsets ( <span class="literal">this.tx</span> and <span class="literal">this.ty</span> ) to pull values from different parts of the same 1D noise space. Meanwhile, in the 2D noise example, both <span class="literal">xoff</span> and <span class="literal">yoff</span> start at 0 because I’m looking for a single value (a pixel brightness) for a given point in a 2D noise space. The walker is actually navigating two separate 1D noise <em>paths</em>, whereas the pixels are single values in a 2D space.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe8"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.8</strong></p>&#13;
<p class="noindent">Play with color, <span class="literal">noiseDetail()</span>, and the rate at which <span class="literal">xoff</span> and <span class="literal">yoff</span> are incremented to achieve different visual effects.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe9"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.9</strong></p>&#13;
<p class="noindent">Add a third argument to noise that increments once per cycle through <span class="literal">draw()</span> to animate the 2D noise.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch0exe10"><span epub:type="pagebreak" id="page_29"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 0.10</strong></p>&#13;
<p class="noindent">Use the noise values as the elevations of a landscape.</p>&#13;
<div class="imagel"><img src="../images/pg69_Image_54.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<p class="noindent">I’ve suggested several traditional uses of Perlin noise in this section. I assigned the smooth values of 1D noise to the position of an object to give the appearance of wandering. With 2D noise, I generated a cloudy pattern by using smoothed values on a plane of pixels. It’s important to remember, however, that Perlin noise values are just that—values. They aren’t inherently tied to pixel positions or color.</p>&#13;
<p class="noindent">Any example in this book that has a variable could be controlled via Perlin noise. When I model a wind force, for instance, its strength could be controlled by Perlin noise. The same goes for the angles between the branches in a fractal tree pattern, or the speed and direction of objects moving along a grid in a flow-field simulation (see <a href="ch00.xhtml#ch0fig10">Figure 0.10</a>).</p>&#13;
<div class="image"><img id="ch0fig10" src="../images/pg69_Image_55.jpg" alt="Image" width="1125" height="407"/></div>&#13;
<p class="figcap">Figure 0.10: A tree with Perlin noise (left) and a flow field with Perlin noise (right)</p>&#13;
<p class="noindent">Just as you can overuse randomness, however, it’s easy to fall into the trap of overusing Perlin noise. How should an object move? Perlin noise! What color should it be? Perlin noise! How fast should it grow? Perlin noise! If that becomes your answer to every question, keep reading. My goal here is to introduce you to a universe of new possibilities for defining the rules of your systems. After all, those <span epub:type="pagebreak" id="page_30"/>rules are yours to define, and the more possibilities at your disposal, the more you’ll be able to make thoughtful, informed choices. Randomness and Perlin noise are just the first stars in a vast creative cosmos that I’ll explore in this book.</p>&#13;
<p class="noindent">As mentioned in the introduction, one way to use this book is to build a single project over the course of reading it, incorporating elements from each chapter as you go. One such possible project is a simulation of an ecosystem. Imagine a population of computational creatures living in and around a digital pond, interacting with one another according to various rules. At the end of each chapter, you will find this same prompt. My goal is to provide ideas on how to incrementally expand your own simulated ecosystem using the concepts explored in that chapter. But feel free to invent your own!</p>&#13;
<div class="box">&#13;
<p class="box-title" id="ch00end1"><span epub:type="pagebreak" id="page_31"/><img class="inline" src="../images/bird.jpg" alt="Image" width="30" height="33"/> <strong>The Ecosystem Project</strong></p>&#13;
<p class="noindent">For your first step, develop a set of rules for simulating the real-world behavior of a creature, building on top of principles from the random walk or other noise-driven motions. Can you simulate a jittery bug that flies in unpredictable ways, or perhaps a floating leaf carried by an inconsistent breeze? Start by exploring how much you can express a creature’s personality purely through its behavior. Then you can think about its visual characteristics.</p>&#13;
<p class="noindent">Here’s an illustration to help you generate ideas for building an ecosystem based on the topics covered in this book. Watch how the illustration evolves in each subsequent chapter as new concepts and techniques are introduced.</p>&#13;
<div class="imagel"><img src="../images/pg71_Image_57.jpg" alt="Image" width="1041" height="641"/></div>&#13;
<p class="noindent">The goal of this book is to demonstrate algorithms and behaviors, so my examples will almost always include only a single primitive shape, such as a circle. However, I fully expect that you have creative sparks within you, and I encourage you to challenge yourself with the designs of the elements you draw on the canvas. If translating designs into code is new to you, the book’s illustrator, Zannah Marsh, has written a helpful guide on drawing for code, which you can find in the appendix.<span epub:type="pagebreak" id="page_32"/></p>&#13;
</div>&#13;
</div>
</div>
</body></html>