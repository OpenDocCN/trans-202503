- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 7 REVERSE SHELLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You’ve practiced gaining initial access to a target by establishing web shells
    that provide temporary, one-way network channels. In this chapter, we’ll explore
    a more stable initial access technique: using *reverse shells*, which swap the
    direction of the network communication. Attackers use these reverse connections
    *from* a compromised target machine *to* their own machine to gain reliable control
    over the compromised system and execute commands remotely in a more synchronized
    fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to create a reverse shell, then make your communications with
    remote environments more robust. As a bonus, you’ll also learn how to brute-force
    your way into SSH servers by using bash as your battering ram.
  prefs: []
  type: TYPE_NORMAL
- en: How Reverse Shells Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often used for post-exploitation activities, reverse shells enable attackers
    to maintain control over a compromised system without directly connecting to it
    from their own machine, evading firewall restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: The term *reverse* refers to the direction of the initial network traffic. In
    a traditional shell or command execution flow, the attacker’s machine would typically
    be the one to connect to the compromised system to issue commands and control
    it. However, in the case of a reverse shell, the target is the one to reach out
    to the attacker. Let’s explore some principles of reverse shells.
  prefs: []
  type: TYPE_NORMAL
- en: Ingress vs. Egress Controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reverse shell communications help us bypass firewall rules, network restrictions,
    and other security measures designed to block incoming (*ingress*) connections,
    including those used in the OS command injection and web shell attacks we covered
    in [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: However, firewalls and network security devices are often configured to allow
    the outbound (*egress*) connections necessary for performing normal internet activity.
    When establishing a reverse shell, the compromised system initiates an egress
    connection to the attacker’s machine that is usually allowed by default. The firewall
    may perceive this egress connection as a legitimate action and won’t trigger alarms
    or security alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Once the reverse shell connection is established, it should allow the attacker
    to maintain control over the compromised system. Mature environments may block
    outbound traffic to untrusted network addresses, but implementing this kind of
    restriction often isn’t a straightforward task, especially when certain machines
    on a network need access to wide ranges of network addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Shell Payloads and Listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need two tools to set up a reverse shell: a payload and a listener.
    The *payload* runs on the target machine. You’ll use different reverse shell payloads
    depending on the technologies and programming languages available on your target,
    as well as the type of platform it runs on. In this chapter, we’ll create a reverse
    shell payload with bash, but you can find a list of different reverse shell payloads
    at *[https://github.com/nicholasaleks/reverse-shells](https://github.com/nicholasaleks/reverse-shells)*.'
  prefs: []
  type: TYPE_NORMAL
- en: A *shell listener* is a program that runs on the attacker machine to receive
    incoming reverse shell connections from compromised target systems. When a reverse
    shell payload is executed on a target system, the payload attempts to connect
    to the attacker’s machine. The shell listener program acts as the handler for
    these incoming connections; it listens on a specific port, waiting for the connection
    to be established, and provides an interactive shell session in which the attacker
    can enter commands to send to the compromised server, letting the attacker control
    the compromised server as if they were directly accessing the machine’s shell.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular shell listeners used in penetration tests is Netcat.
    We used it in [Chapter 4](chapter4.xhtml) to perform port scanning, but this versatile
    command line utility can read from and write to network connections in many other
    ways. We’ll discuss it in this chapter, along with alternative tools such as Socket
    Cat (socat) and pwncat.
  prefs: []
  type: TYPE_NORMAL
- en: The Communication Sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 7-1](chapter7.xhtml#fig7-1) describes the sequence of network communications
    involved in the use of reverse shells.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg145.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: The communication sequence of a reverse shell'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a reverse shell involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  Setting up a shell listener: The attacker machine initializes a shell listener
    running on a specific port that is accessible from the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Exploiting the target server: The attacker compromises the target system
    through a vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: '3.  Uploading a reverse shell payload: The attacker crafts a reverse shell
    payload and delivers it by exploiting the underlying vulnerability in the target
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.  Executing the payload: The payload is executed on the target server.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.  Requesting a reverse connection: The payload attempts to connect to the
    attacker’s machine, acting as the client.'
  prefs: []
  type: TYPE_NORMAL
- en: '6.  Accepting the shell connection: The listener receives the incoming connection
    and establishes a bidirectional communication channel with the target machine
    over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '7.  Executing commands and gaining server control: With the reverse shell connection
    established, the attacker gains control over the compromised target system and
    may execute shell commands remotely.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll see these steps in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a Connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use bash to establish a reverse shell connection between the Kali attacker
    machine and a target, the *p-web-02* web application server (172.16.10.12).
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Netcat Listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we must use Netcat to set up a shell listener on the Kali machine. Execute
    the following command in a brand-new terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The -l option instructs Netcat to listen for incoming connections. The -p 1337
    option specifies the port number to listen on, and the -vv option enables verbose
    mode, providing more detailed output for monitoring and debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In real-life scenarios, choose a port that will blend in with the environment
    so it’s harder to notice. For example, outbound connections on port 1337 could
    raise alerts, whereas blue team analysts might overlook traffic on common ports
    such as 80 or 443, which are often used by HTTP.*'
  prefs: []
  type: TYPE_NORMAL
- en: When the command executes, Netcat should start listening for incoming connections
    on the port specified.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting a Payload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll craft an interactive reverse shell payload by using the single line
    of bash in [Listing 7-1](chapter7.xhtml#Lis7-1). We’ll submit this line as user
    input to the target application in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: A reverse shell payload'
  prefs: []
  type: TYPE_NORMAL
- en: 'The -i option makes the bash shell interactive, allowing it to receive input
    and produce output. The */dev/tcp* path is a special *pseudo-device file* in Linux
    that provides access to TCP sockets. A similar file, */dev/udp*, exists for UDP.
    We add to the filepath the IP address of the Kali machine and the port on which
    the Kali shell is waiting for incoming connections: */dev/ tcp/172.16.10.1/1337*.'
  prefs: []
  type: TYPE_NORMAL
- en: The >& syntax combines the standard output (stdout) and standard error (stderr)
    streams into a single stream. By combining these streams, we ensure that both
    the regular command outputs and any error messages generated by the reverse shell
    payload get redirected to our listener.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we use bash -c to wrap the entire payload in single
    quotes. This specialized wrapping allows us to explicitly invoke a new instance
    of the bash shell while specifying a command string to execute with the -c option.
    It also ensures that the subsequent command is executed using bash, regardless
    of the default shell set on the target system. You could even specify the bash
    shell’s full executable path (using /bin/bash -c) to further ensure that the payload
    executes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering and Initializing the Payload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To deliver the single-line reverse shell payload we created, we’ll exploit the
    OS command injection vulnerability we identified in *p-web-02* (172.16.10.12)
    in [Chapter 6](chapter6.xhtml). Note that [Figure 7-2](chapter7.xhtml#fig7-2)
    includes the full reverse shell payload, as well as the pipe metacharacter | used
    to exploit the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg147.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: The successful injection of a reverse shell payload into p-web-02'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **Donate** button should instantly trigger the reverse shell connection.
    In the Kali terminal window running the shell listener, you should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Success! We’ve popped yet another shell and compromised the *p-web-02* server.
    In the prompt on the final line, we can see confirmation that we’ve gained an
    active shell on the *p-web-02* host by using the *www-data* user and that the
    present working directory is */var/www/html*.
  prefs: []
  type: TYPE_NORMAL
- en: Executing Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now use the Kali shell listener terminal just as we would any other
    shell. Let’s remotely execute a bash command on *p-web-02* through the reverse
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we remotely execute the uname -a command on the server and
    automatically return its output stream back to the Kali listener.
  prefs: []
  type: TYPE_NORMAL
- en: We can even do some introspection on the connection by entering the process
    snapshot command ps aux and reviewing the currently running reverse shell process
    ([Listing 7-2](chapter7.xhtml#Lis7-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Viewing process information'
  prefs: []
  type: TYPE_NORMAL
- en: In the process output, we can clearly see how the reverse shell payload gets
    executed on the remote server, starting with the process whose ID is 131\. (Process
    IDs may differ on your machine.)
  prefs: []
  type: TYPE_NORMAL
- en: To break it down further, the initial command, sh ❶, calls upon the bash -c
    command ❷. This command allows us to execute the desired shell instance, which
    in this case is bash, identified by process ID 134 ❸. By leveraging this chain
    of processes and accessing the network capabilities provided by */dev/tcp*, we
    elevate our reverse shell capabilities from a limited sh shell to a fully functional
    bash shell. This upgrade provides us with a wider range of advanced reverse shell
    techniques, allowing for sophisticated post-exploitation activities and the ability
    to maintain control over compromised systems.
  prefs: []
  type: TYPE_NORMAL
- en: Listening with pwncat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pwncat is another useful utility for capturing and interacting with reverse
    shells. It lets us create a reverse shell listener, then use its built-in modules
    for a variety of purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s use it to send commands through the reverse shell. Later
    in this chapter, we’ll use it for file uploads as well. Start a pwncat reverse
    shell listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that pwncat is actively listening for any incoming connections
    made by compromised machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can inject the command that will give us a reverse shell, as we did
    earlier in this chapter. Once pwncat receives the shell, you’ll see a message
    in the terminal, and you’ll be able to run commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The message (local) pwncat$ is pwncat’s prompt, at which you enter commands.
    Enter help to see existing options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Many options are available. To run a few shell commands, you must first use
    the back command. This command will return to the compromised host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run commands on the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, pwncat is able to send commands and retrieve the results.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Security Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When performing penetration tests, you may run into environments in which the
    shell you’ve established is hard to use. The shell itself might be limited, for
    instance, or the environment might reduce the number of packages available in
    an attempt to harden the system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Table 7-1](chapter7.xhtml#tab7-1) shows the differences between
    commands run in the Kali shell environment and in the *p-web-02* reverse shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-1: Commands Run in Kali vs. p-web-02'
  prefs: []
  type: TYPE_NORMAL
- en: '| Kali shell | p-web-02 reverse shell |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| $ echo $SHELL | $ echo $SHELL |'
  prefs: []
  type: TYPE_TB
- en: '| /bin/bash | /usr/sbin/nologin |'
  prefs: []
  type: TYPE_TB
- en: '| $ whoami | $ whoami |'
  prefs: []
  type: TYPE_TB
- en: '| Kali | www-data |'
  prefs: []
  type: TYPE_TB
- en: '| $ ls /bin &#124; wc -l | $ ls /bin &#124; wc -l |'
  prefs: []
  type: TYPE_TB
- en: '| 3249 | 89 |'
  prefs: []
  type: TYPE_TB
- en: '| $ wget | $ wget |'
  prefs: []
  type: TYPE_TB
- en: '| wget: missing URL | Bash: wget: command not found |'
  prefs: []
  type: TYPE_TB
- en: '| Usage: wget [Option] ... |  |'
  prefs: []
  type: TYPE_TB
- en: The *p-web-02* environment lacks many of the user privileges of the Kali shell
    and even has a drastically different number of available binaries. This makes
    sense because Kali is a full-fledged operating system with a graphical interface,
    whereas *p-web-02* is a slim container with the bare minimum amount of software
    required to function.
  prefs: []
  type: TYPE_NORMAL
- en: A lack of installed or built-in binaries is normal in cloud-hosted web application
    servers like the one *p-web-02* is mimicking. This is due to performance, security,
    and resource optimization requirements. A slim system image requires less maintenance
    overhead and provides faster deployment times.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party tools are even tailored to remove excessive packages from an image
    (a process called *minification*). For example, the SlimToolkit project at *[https://github.com/slimtoolkit/slim](https://github.com/slimtoolkit/slim)*
    runs several analysis techniques on an image to identify unused packages, then
    optimizes the operating system size by removing them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll highlight a few high-level techniques used to hide reverse
    shell communications or bypass security restrictions in hardened environments.
    These techniques can evade initial access security measures and allow us to maintain
    control over compromised systems.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and Encapsulating Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To evade detection, reverse shells can use encryption and encapsulation techniques
    to hide the malicious traffic within legitimate protocols or connections. By *encrypting*
    the communication, we can render the contents of the reverse shell traffic unreadable,
    making it challenging for security devices to identify any malicious payload or
    commands being sent.
  prefs: []
  type: TYPE_NORMAL
- en: '*Encapsulation* conceals the reverse shell traffic within innocuous protocols
    or already encrypted connections. This technique disguises the reverse shell communication
    as legitimate traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-3](chapter7.xhtml#fig7-3) shows how an encrypted tunnel between a
    compromised server and the attacker machine could work. As you can see, the reverse
    shell connection occurs within the encrypted connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: A reverse shell over an encrypted communication channel'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a reverse shell over an encrypted transport protocol in multiple
    ways. One way is by using *Ncat* (not to be confused with Netcat), a network utility
    that is packaged with Nmap and allows the redirection, writing, reading, and encryption
    of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command sequence between the attacker and target
    machine to establish a reverse shell connection that is encapsulated by an encrypted
    tunnel. On the attacker machine, start a Secure Sockets Layer (SSL) listener with
    Ncat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Use the -v (verbose) flag, specify the port to the -l (listen) flag, and then
    use --ssl for encryption. Ncat should generate temporary asymmetric keys (Rivest-Shamir-Adleman,
    or RSA) by default unless you specify otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the compromised machine, the following command will establish an encrypted
    reverse shell. However, the compromised machine must have Ncat available for this
    command to work, and it often isn’t available by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we run Ncat to connect to the attacker’s listener. We use --ssl
    to encrypt the traffic, followed by -e /bin/bash to execute the bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: pwncat can also establish a connection over SSL by using the same command style
    as Ncat. Refer to pwncat’s documentation at *[https://pwncat.readthedocs.io/en/latest/usage.html](https://pwncat.readthedocs.io/en/latest/usage.html)*
    to learn how to use it for establishing SSL-based reverse shell connections.
  prefs: []
  type: TYPE_NORMAL
- en: Alternating Between Destination Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Port hopping*, or dynamically switching network ports during the communication
    process, is used for both defensive and offensive activities. On the offensive
    side, this technique can ensure the stability of a reverse shell and make it more
    challenging for security monitoring systems to block malicious traffic. By constantly
    changing ports, attackers can bypass simple port-based filtering mechanisms and
    intrusion detection systems that monitor specific ports for suspicious activities.
    Port hopping also makes it more difficult for defenders to thwart the reverse
    shell connection; if a network port becomes unreachable, a port hop will reestablish
    the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07).'
  prefs: []
  type: TYPE_NORMAL
- en: Attackers typically implement port hopping by using a predefined range of ports.
    [Listing 7-3](chapter7.xhtml#Lis7-3) performs a reverse shell connection to the
    attacker machine by using a variety of ports, depending on their availability.
  prefs: []
  type: TYPE_NORMAL
- en: port-hopper.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Attempting reverse shell connections using a variety of ports'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script sets a few predefined ports in an array: 34455, 34456, 34457, 34458,
    and 34459 ❶. At ❸, an infinite while loop continuously attempts to connect to
    the listener. We then iterate through the ports by using a for loop and check
    whether each port is reachable by using the listener_is_reachable() function ❹,
    which uses the special */dev/tcp* device. Notice that we prepend the reachability
    check ❷ with the timeout command to ensure that the command exits at a set interval
    of 0.5 seconds. If the port is reachable, we call the connect_reverse_shell()
    function, passing the open port as an argument, and send an interactive shell
    to it using */dev/tcp*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’re performing multiple network connections consecutively (one for the
    connectivity check and another to establish the reverse shell), some versions
    of Netcat may not support keeping the listener alive. To overcome this, we can
    use socat to set up a TCP listener on the Kali box. This tool will ensure that
    the listener remains alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the script on one of the compromised hosts, such as *p-web-01* (172.16.10.10),
    it should yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll discuss a few methods we can use to stage new binaries
    into a target environment without the superuser privileges necessary to download
    official packages from public repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning TTY Shells with Pseudo-terminal Devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s another scenario you might encounter in future shell-popping adventures:
    the limited shell you have access to might not provide full TTY (terminal) support.
    Non-TTY shells have limited command line editing, no job control, incomplete output
    formatting, and missing signal handling, and they may not work in interactive
    applications such as text editors.'
  prefs: []
  type: TYPE_NORMAL
- en: One common approach to upgrading a shell to a feature-rich TTY one is by using
    pseudo-terminals. A *pseudo-terminal* provides an interface through which processes
    can interact with a terminal-like device, allowing terminal-based applications,
    shells, and other programs to operate as if they were connected to a physical
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s pty Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python pty module emulates the functionality of a physical terminal device.
    In the following example, we upgrade a Python shell to a fully interactive TTY
    bash shell by using the pty.spawn() function. Try running this on the Kali host
    to see what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To exit the Python console, enter exit().
  prefs: []
  type: TYPE_NORMAL
- en: 'On a compromised host with Python installed, you could elevate your shell by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that Python must be available on the compromised host for this
    technique to work.
  prefs: []
  type: TYPE_NORMAL
- en: socat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use socat to spawn a TTY shell if the tool exists on the target and
    in your local hacking system. We generally use socat for bidirectional communications
    between two data channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Kali, run the socat command to spawn a TTY shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The file: parameter uses the value of the $(tty) command, which expands to
    /dev/pts/#. Raw mode (raw) ensures that socat won’t process input and output data,
    echo=0 disables socat’s local echoing, and tcp-listen:1337 defines the local TCP
    listening port.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, by using the OS command injection vulnerability on *p-web-02* (172.16.10.12),
    execute the following command. Note the use of the pipe character to trigger the
    injection vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we call socat with the exec parameter 'bash -li', which will
    execute bash interactively as if it had been invoked as a login shell. We also
    pass pty,stderr to generate a pseudo-terminal and capture the standard error stream,
    followed by tcp:172.16.10.1:1337 to set the connection address using TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Post-exploitation Binary Staging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss a few ways to upgrade from a limited shell environment without
    needing root-level access. In this section, we’ll assume we weren’t able to use
    bash alone to establish a reverse shell connection to *p-web-02* through the */dev/tcp*
    special pseudo-device file.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the *www-data* user lacks permissions and the ability to install software
    on the server, we can use bash alone to execute many attacks. However, missing
    certain core binaries, especially those used for networking, can make our hacker
    lives especially tough.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we noted in [Table 7-1](chapter7.xhtml#tab7-1), *p-web-02* doesn’t have
    the wget binary available for downloading files from remote servers. Let’s try
    to execute a few other common network utility commands to see whether they exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Wow, this host really has no way to establish an outbound connection. We do
    have curl, but it isn’t possible to use curl to make direct reverse shell connections.
  prefs: []
  type: TYPE_NORMAL
- en: In cases such as these, downloading a Netcat binary to the target server would
    come in handy. By taking advantage of application vulnerabilities such as code
    execution, we could potentially install such a networking utility, then use it
    to establish an upgraded reverse shell connection.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we cover helpful commands we could use to pull network binaries
    into our target environments and execute them. Note that we’ll use our reverse
    shell connection with *p-web-02* to cheat a little here, but the following techniques
    could very well be executed using the OS command injection vulnerability we uncovered.
    We’ll demonstrate its use in a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Serving Netcat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your Kali machine, navigate to the directory of the payload you want to
    transfer, then enter the following Python command to stand up an HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On *p-web-02* (172.16.10.12), you should now be able to access the filesystem
    of your Kali machine through the Python HTTP server and execute a download command
    by using curl. Place a copy of the Kali nc binary into the same directory as the
    HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now download it to *p-web-02* by using a remote curl command and set
    it as an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the Kali machine, we can now establish a secondary reverse shell connection
    in a new terminal on a different port. Let’s choose 1234 (as our first reverse
    shell uses port 1337):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can execute the new nc binary from within the first reverse shell
    to establish a second one via nc. We can also send this process to the background
    by using &:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we simply call the Netcat binary in *p-web-02* from within a
    new Kali terminal by using curl to exploit the OS command injection vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This approach bypasses the need for the first reverse shell.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading Files with pwncat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we use pwncat to establish a shell, we can leverage its upload command
    to transfer files between the attacker and compromised target machines. The upload
    command accepts two arguments, the source file and its destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to remember that, unless pwncat is using SSL, the traffic between
    the attacker’s machine and the target will be in cleartext. (The same is true
    for Netcat and Ncat.)
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Binaries from Trusted Sites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, environments won’t block egress traffic made to commonly used websites
    such as GitHub, GitLab, Google Drive, and Microsoft OneDrive, as well as to cloud
    services like Amazon Simple Storage Service (S3) and Google Cloud Storage (GCS).
    Thus, these are great places to host malicious files.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations with less security maturity frequently use the same outbound filtering
    policies for their entire network (including users and servers alike), and there
    is often no great way to block one part of a website while allowing others. In
    addition, if a company uses Amazon Web Services (AWS) or any other cloud provider
    to host its infrastructure, there is a good chance it allows all traffic to and
    from the cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: As a penetration tester, you should explore any third-party services used by
    your target and look for ways to host your malicious files from them. For instance,
    if your target has a public marketing website and offers a chatbot feature for
    speaking with an agent, there might be a way to anonymously attach files through
    the chat. If this is the case, you could copy and paste that link and use it to
    pull malicious files onto compromised hosts down the road.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit to the trusted-site hosting approach is that if a website is served
    over HyperText Transfer Protocol Secure (HTTPS), communications between the compromised
    machine and the trusted site will be encrypted automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: Maintaining a Continuous Reverse Shell Connection'
  prefs: []
  type: TYPE_NORMAL
- en: You might want to strengthen your initial foothold on your target by executing
    a script that continuously reestablishes a reverse shell connection. If the reverse
    shell process is ever interrupted or disconnected, your script could reestablish
    a connection with the Kali machine by using the IP address and port you provide.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) will run locally as a background process
    on the compromised server and attempt to reestablish the reverse shell connection
    at a certain interval we set.'
  prefs: []
  type: TYPE_NORMAL
- en: reverse_shell _monitor.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: Monitoring and reestablishing a reverse shell'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script itself is simple: we call the restart_reverse_shell() function every
    10 seconds. Regardless of the status of the network or reverse shell process,
    this function will attempt to reestablish a connection with our Kali host. The
    Kali machine will refuse any additional connections if a current reverse shell
    connection is ongoing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the script something generic, like *donation-monitor.sh*, to avoid suspicion,
    as the script should run in the background indefinitely. Next, save the script
    to a file on *p-web-02* (172.16.10.12) and set the appropriate execution permission,
    then run the script as a background job, redirecting its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To test the script, all you need to do is run the Netcat listener command to
    serve the reverse shell. Attempt to stop and start the listener multiple times,
    and notice that the reverse shell is reestablished every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Initial Access with Brute Force
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more traditional way of entering a remote system is by using the same services
    an IT administrator would use. By leveraging stolen credentials or exploiting
    weaknesses such as misconfigurations or poor passwords, we can brute-force a path
    through a system’s front door.
  prefs: []
  type: TYPE_NORMAL
- en: One common service to target is SSH. While generally considered a secure protocol,
    SSH implementations may have security weaknesses that attackers could exploit,
    such as poor or reused passwords, insecure authentication methods, and key management
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: We can use bash scripting to perform complex brute-force attacks across numerous
    service protocols, including SSH. While we could run individual brute-forcing
    tools in isolation, combining them in a bash script provides numerous benefits.
    Our scripts can automate host detection, generate wordlists, and integrate with
    tools to stuff credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to break into a new target, the *p-jumbox-01* server (172.16.10.13).
    To execute an SSH connection, open a new terminal from within the Kali machine
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The warning message you see after attempting to SSH into *p-jumpbox-01* indicates
    that the SSH client does not have the host’s public key stored in its *known_hosts*
    file. This file is used to verify the authenticity of the host you are connecting
    to, and the *ED25519 key fingerprint* represents the server’s public key. By entering
    yes, we proceed with the SSH connection and place the host’s public key into our
    *known_hosts* file.
  prefs: []
  type: TYPE_NORMAL
- en: SSH allows both password-based and key-based authentication. In *password-based
    authentication*, a user provides their username and password to authenticate themselves
    to the remote server. In *key-based authentication* (also known as *public-key
    authentication*), a user supplies a cryptographic key to authenticate to a server.
    Before attempting to brute-force an SSH server, it’s important to verify that
    the server accepts password-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: To test whether a server allows password-based authentication, simply observe
    the server’s response after attempting an initial connection. For example, you
    can see that our initial connection attempt yielded a prompt for the user’s password.
    Alternatively, you can use Nmap’s built-in NSE script *ssh-auth-methods.nse* located
    at */usr/share/nmap/scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: If the server immediately rejects the connection or provides a generic error
    message without prompting you for a password, password-based authentication may
    not be allowed or isn’t the server’s primary authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11: Brute-Forcing an SSH Server'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ll use bash to conduct a dictionary-based brute-force
    attack against the SSH service running on the *p-jumpbox-01* (172.16.10.13) server.
    Your script should iterate through a list of common usernames and passwords, attempt
    to authenticate to the server, and log any successful credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Before writing the SSH brute-forcing script, you’ll need two things. First,
    you must either identify a single target username or generate a list of usernames
    to iterate through. You didn’t identify any usernames during reconnaissance, so
    try a list of common Linux usernames, such as *root*, *guest*, *backup*, *ubuntu*,
    and *centos*. Of course, you’re merely guessing that these users exist on the
    target server.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you’ll need a list of potential passwords. Kali contains a great password
    list in the */usr/share/wordlist* directory, but we suggest instead using the
    *common-credentials/passwords.txt* password file from the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with your username and password lists, you can write some bash to test
    the strength of the *p-jumpbox-01* server’s authentication. [Listing 7-5](chapter7.xhtml#Lis7-5)
    provides an example.
  prefs: []
  type: TYPE_NORMAL
- en: ssh-bruteforce.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: Brute-forcing SSH'
  prefs: []
  type: TYPE_NORMAL
- en: 'This SSH brute-force bash script starts much like our other scripts: by defining
    the target IP address and port. Next, we specify a list of usernames ❶ and a file
    that contains passwords that we’ll use ❷. At ❸, we then iterate through each username
    and use sshpass to inject passwords ❺, which we read in line by line ❹. We print
    any successful output ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For the following script to work, we need to install sshpass, a special utility
    that allows managing SSH connections in scripts. Install sshpass using the following
    command:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Download and run the script to see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve identified that the username *backup* uses a weak password (also *backup*)
    on the *p-jumpbox-01* server. We can validate that these credentials work by using
    this command to log in to the *p-jumpbox-01* server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When prompted for credentials, use the password *backup*, and you should be
    granted access.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take this script further, attempt the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the brute-forcing process more efficient by using a dictionary to attack
    multiple hosts in parallel so that you’re not limited to targeting a single IP
    address at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a notification component to the script so that once a host is compromised,
    you’ll get a notification via your favorite messaging media.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a reverse shell on a target and uncovered
    strategies for enhancing the interactivity and longevity of your remote shell
    interfaces, laying the groundwork for future exploits. You also learned how to
    transfer files between the attacking and compromised machines. Then you used bash
    to perform an SSH brute-force attack.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve compromised three machines, we highly recommend you start roaming
    around the compromised hosts to set the stage for what’s coming in the next chapter.
  prefs: []
  type: TYPE_NORMAL
