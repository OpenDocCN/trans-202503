- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">READING
    AND ASSIGNING SECURITY DESCRIPTORS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">读取与分配安全描述符</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In the previous chapter, we discussed the various structures that make up a
    security descriptor. You also learned how to manipulate security descriptors in
    PowerShell and how to represent them using the SDDL format. In this chapter, we’ll
    discuss how to read security descriptors from kernel objects, as well as the more
    complex process of assigning security descriptors to these objects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了构成安全描述符的各种结构。你还学习了如何在PowerShell中操作安全描述符，以及如何使用SDDL格式表示它们。在本章中，我们将讨论如何从内核对象中读取安全描述符，以及将安全描述符分配给这些对象的更复杂过程。
- en: We’ll focus our discussion on the security descriptors assigned to kernel objects.
    However, as mentioned in “Absolute and Relative Security Descriptors” on page
    149, it’s also possible to store a security descriptor in persistent storage,
    such as in a file or as a registry key value. In this case, the security descriptor
    must be stored in the relative format and read as a stream of bytes before we
    can convert it into a format we can inspect.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点讨论分配给内核对象的安全描述符。然而，如第149页“绝对与相对安全描述符”中所述，安全描述符也可以存储在持久存储中，例如文件或注册表项值中。在这种情况下，安全描述符必须以相对格式存储，并作为字节流读取，然后才能将其转换为可以检查的格式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading Security Descriptors</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">读取安全描述符</samp>
- en: To access a kernel object’s security descriptor, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    system call. This system call accepts a handle to the kernel object, as well as
    a set of flags that describe the components of the security descriptor you want
    to access. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    enumeration represents these flags.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问内核对象的安全描述符，可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>系统调用。此系统调用接受一个指向内核对象的句柄，以及一组描述要访问的安全描述符组件的标志。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>枚举表示这些标志。
- en: '[Table 6-1](chapter6.xhtml#tab6-1) shows the list of available flags in the
    latest versions of Windows, as well as the location of the information in the
    security descriptor and the handle access required to query it.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-1](chapter6.xhtml#tab6-1)显示了最新版本Windows中可用标志的列表，以及安全描述符中信息的位置和查询所需的句柄访问权限。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">The</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> <samp
    class="SANS_Futura_Std_Book_11">Flags and Their Required Access</samp>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表6-1：</samp> <samp class="SANS_Futura_Std_Book_11">安全信息</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> <samp
    class="SANS_Futura_Std_Book_11">标志及其所需访问权限</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Location</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Handle
    access required</samp> |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标志名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">位置</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">所需句柄访问权限</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the owner SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Owner</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">所有者</samp> | <samp class="SANS_Futura_Std_Book_11">查询所有者SID。</samp>
    | <samp class="SANS_Futura_Std_Book_11">所有者</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the group SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Group</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">组</samp> | <samp class="SANS_Futura_Std_Book_11">查询组SID。</samp>
    | <samp class="SANS_Futura_Std_Book_11">组</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the DACL.</samp> | <samp class="SANS_Futura_Std_Book_11">DACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> | <samp class="SANS_Futura_Std_Book_11">查询
    DACL。</samp> | <samp class="SANS_Futura_Std_Book_11">DACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sacl</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the SACL (auditing ACEs only).</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sacl</samp> | <samp class="SANS_Futura_Std_Book_11">查询安全审计（仅审核ACE）。</samp>
    | <samp class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the mandatory label.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> | <samp class="SANS_Futura_Std_Book_11">查询强制标签。</samp>
    | <samp class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the system resource attribute.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp> | <samp class="SANS_Futura_Std_Book_11">查询系统资源属性。</samp>
    | <samp class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the scoped policy ID.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp> | <samp class="SANS_Futura_Std_Book_11">查询范围策略
    ID。</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTrustLabel</samp> |
    <samp class="SANS_Futura_Std_Book_11">Query the process trust label.</samp> |
    <samp class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTrustLabel</samp> |
    <samp class="SANS_Futura_Std_Book_11">查询进程信任标签。</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessFilter</samp> | <samp
    class="SANS_Futura_Std_Book_11">Query the access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessFilter</samp> | <samp
    class="SANS_Futura_Std_Book_11">查询访问过滤器。</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    everything except the process trust label and access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">All</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> <samp class="SANS_Futura_Std_Book_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup</samp> | <samp class="SANS_Futura_Std_Book_11">查询除了处理信任标签和访问过滤器之外的所有内容。</samp>
    | <samp class="SANS_Futura_Std_Book_11">All</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    <samp class="SANS_Futura_Std_Book_11">和</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    |'
- en: You only need <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access to read most of this information, except for the auditing ACEs from the
    SACL, which require <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access. (<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access
    is sufficient for other ACEs stored in the SACL.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 只需 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> 访问权限即可读取大部分信息，除了
    SACL 中的审计 ACE，这些需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    访问权限。（对于 SACL 中存储的其他 ACE，<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    访问权限是足够的。
- en: The only way to get <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access is to first enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    privilege, then explicitly request the access when opening a kernel object. [Listing
    6-1](chapter6.xhtml#Lis6-1) shows this behavior. You must run these commands as
    an administrator.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    访问权限的唯一方法是首先启用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    特权，然后在打开内核对象时显式请求该访问权限。[列表 6-1](chapter6.xhtml#Lis6-1) 显示了这种行为。你必须以管理员身份运行这些命令。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: Requesting AccessSystemSecurity access and enabling SeSecurityPrivilege'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-1：请求 AccessSystemSecurity 访问并启用 SeSecurityPrivilege
- en: Our first attempt to open the BNO directory with <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access fails, because we don’t have the required <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    privilege. Next, we enable that privilege and try again. This time we are able
    to open the directory, and printing its <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp>
    parameter confirms we’ve been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次尝试以 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    访问权限打开 BNO 目录失败，因为我们没有所需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    特权。接下来，我们启用该特权并重新尝试。这次我们成功打开了目录，打印其 <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp>
    参数确认我们已经获得了 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    访问权限。
- en: It’s not entirely clear why the designers of Windows made the decision to guard
    the reading of audit information with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>.
    While we should consider modifying and removing audit information to be privileged
    actions, there is no obvious reason that reading that information should be. Unfortunately,
    we’re stuck with this design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全清楚为什么 Windows 的设计者决定使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    来保护审计信息的读取。虽然我们应该将修改和删除审计信息视为特权操作，但没有明显的理由说明读取这些信息也应该是特权操作。不幸的是，我们只能接受这种设计。
- en: You can query an object’s security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    PowerShell command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>.
    The system call returns the security descriptor in the relative format as a byte
    array, which the PowerShell command parses into a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object and returns to the caller. The command accepts either an object or a path
    to the resource you want to query, as shown in [Listing 6-2](chapter6.xhtml#Lis6-2),
    which displays the security descriptor for the BNO directory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    PowerShell 命令查询对象的安全描述符，该命令会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>。系统调用会以字节数组的相对格式返回安全描述符，PowerShell
    命令将其解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    对象并返回给调用者。该命令接受对象或你要查询的资源路径，如 [列表 6-2](chapter6.xhtml#Lis6-2) 所示，展示了 BNO 目录的安全描述符。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: Querying the security descriptor for the BNO directory'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-2：查询 BNO 目录的安全描述符
- en: Here, we open the BNO directory with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access, then use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    to query the security descriptor from the open <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> 访问权限打开
    BNO 目录，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    从打开的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> 对象中查询安全描述符。
- en: By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    command queries for the owner, group, DACL, mandatory label, and process trust
    label. If you want to query any other field (or omit some of the returned information),
    you need to specify this through the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    parameter, which accepts the values in [Table 6-1](chapter6.xhtml#tab6-1). For
    example, [Listing 6-3](chapter6.xhtml#Lis6-3) uses a path instead of an object
    and requests only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    field.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    命令查询所有者、组、DACL、强制标签和进程信任标签。如果你想查询其他字段（或省略某些返回的信息），需要通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    参数指定，接受 [表格6-1](chapter6.xhtml#tab6-1) 中的值。例如，[清单6-3](chapter6.xhtml#Lis6-3) 使用路径而非对象，并仅请求
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> 字段。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: Querying the owner of the BNO directory'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-3：查询BNO目录的所有者
- en: In the output, you can see that only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    column contains valid information; all other columns now have the value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NONE</samp>, which indicates that no value
    is present, because we haven’t requested that information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，可以看到只有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> 列包含有效信息；所有其他列现在的值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NONE</samp>，表示没有值，因为我们没有请求该信息。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assigning Security Descriptors</samp>
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">分配安全描述符</samp>
- en: 'Reading a security descriptor is easy; you just need the correct access to
    a kernel resource and the ability to parse the relative security descriptor format
    returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    system call. Assigning a security descriptor is a more complex operation. The
    security descriptor assigned to a resource depends on multiple factors:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读安全描述符很简单；只需要对内核资源具有正确的访问权限，并能够解析从 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    系统调用返回的相对安全描述符格式。分配安全描述符则是一个更复杂的操作。分配给资源的安全描述符依赖于多个因素：
- en: Is the resource being created?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源是正在创建吗？
- en: Did the creator specify a security descriptor during creation?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建者在创建时是否指定了安全描述符？
- en: Is the new resource stored in a container, such as a directory or registry key?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新资源是否存储在容器中，如目录或注册表项？
- en: Is the new resource a container or an object?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新资源是容器还是对象？
- en: What control flags are set on the parent or current security descriptor?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父级或当前安全描述符上设置了哪些控制标志？
- en: What user is assigning the security descriptor?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是哪个用户正在分配安全描述符？
- en: What ACEs does the existing security descriptor contain?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有安全描述符包含哪些ACE？
- en: What kernel object type is being assigned?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在分配的是哪种内核对象类型？
- en: As you can see from the list, this process involves many variables and is one
    of the big reasons Windows security can be so complex.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中可以看到，这个过程涉及许多变量，是Windows安全性如此复杂的主要原因之一。
- en: 'We can assign a resource’s security at creation time or via an open handle.
    Let’s start with the more complex case first: assignment at creation time.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在创建时或通过打开句柄来分配资源的安全性。我们先从更复杂的情况开始：在创建时分配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Security
    Descriptor During Resource Creation</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在资源创建期间分配安全描述符</samp>
- en: When creating a new resource, the kernel needs to assign it a security descriptor.
    Also, it must store the security descriptor differently depending on the kind
    of resource being created. For example, object manager resources are ephemeral,
    so the kernel will store their security descriptors in memory. In contrast, a
    filesystem driver’s security descriptor must be persisted to disk; otherwise,
    it will disappear when you reboot your computer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新资源时，内核需要为其分配安全描述符。此外，根据创建的资源类型，安全描述符的存储方式也不同。例如，对象管理器资源是临时的，因此内核会将其安全描述符存储在内存中。相比之下，文件系统驱动程序的安全描述符必须持久化存储到磁盘，否则在重启计算机后它会消失。
- en: 'While the mechanism to store the security descriptor might differ, the kernel
    must still follow many common procedures when handling it, such as enforcing the
    rules of inheritance. To provide a consistent implementation, the kernel exports
    a couple of APIs that calculate the security descriptor to assign to a new resource.
    The most used of these APIs is <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>,
    which takes the following seven parameters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存储安全描述符的机制可能不同，但内核在处理它时必须遵循许多共同的程序，例如执行继承规则。为了提供一致的实现，内核导出了几个 API，用于计算分配给新资源的安全描述符。这些
    API 中最常用的是 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>，它接受以下七个参数：
- en: '**Creator security descriptor    **An optional security descriptor on which
    to base the new assigned security descriptor'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建者安全描述符** 一个可选的安全描述符，用于作为新分配的安全描述符的基础'
- en: '**Parent security descriptor    **An optional security descriptor for the new
    resource’s parent object'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**父级安全描述符** 一个可选的安全描述符，表示新资源的父对象'
- en: '**Object type    **An optional GUID that represents the type of object being
    created'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象类型** 一个可选的 GUID，表示正在创建的对象类型'
- en: '**Container    **A Boolean value indicating whether the new resource is a container'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器** 一个布尔值，表示新资源是否是一个容器'
- en: '**Auto-inherit    **A set of bit flags that define the automatic inheritance
    behavior'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动继承** 一组位标志，定义自动继承行为'
- en: '**Token    **A handle to the token to use as the creator’s identity'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**令牌** 用作创建者身份的令牌句柄'
- en: '**Generic mapping    **A mapping from generic access to specific access rights
    for the kernel type'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用映射** 将通用访问映射到内核类型的特定访问权限'
- en: Based on these parameters, the API calculates a new security descriptor and
    returns it to the caller. By investigating how these parameters interact, we can
    understand how the kernel assigns security descriptors to new objects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些参数，API 会计算一个新的安全描述符并将其返回给调用者。通过研究这些参数之间的相互作用，我们可以了解内核如何为新对象分配安全描述符。
- en: Let’s consider this assignment process for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object. (This object will be deleted once the PowerShell instance closes, ensuring
    that we don’t accidentally leave unnecessary files or registry keys lying around.)
    [Table 6-2](chapter6.xhtml#tab6-2) provides an example of how we might set the
    parameters when creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object with <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">突变体</samp> 对象执行此分配过程。（该对象将在
    PowerShell 实例关闭后删除，确保不会意外留下不必要的文件或注册表项。）[表 6-2](chapter6.xhtml#tab6-2) 提供了我们在使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> 创建新 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">突变体</samp> 对象时可能设置参数的示例。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp> <samp class="SANS_Futura_Std_Book_11">Example
    Parameters for a New</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    <samp class="SANS_Futura_Std_Book_11">Object</samp>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 6-2：</samp> <samp class="SANS_Futura_Std_Book_11">新</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">突变体</samp> <samp class="SANS_Futura_Std_Book_11">对象的示例参数</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Setting
    value</samp> |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">参数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">设置值</samp>
    |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Creator security descriptor</samp>
    | <samp class="SANS_Futura_Std_Book_11">The value of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    <samp class="SANS_Futura_Std_Book_11">field in the object attributes structure.</samp>
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">创建者安全描述符</samp> | <samp class="SANS_Futura_Std_Book_11">对象属性结构中的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> <samp
    class="SANS_Futura_Std_Book_11">字段的值。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Parent security descriptor</samp> |
    <samp class="SANS_Futura_Std_Book_11">The security descriptor of the parent</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp><samp class="SANS_Futura_Std_Book_11">;
    not set for an unnamed</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">父级安全描述符</samp> | <samp class="SANS_Futura_Std_Book_11">父级的安全描述符</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">目录</samp><samp class="SANS_Futura_Std_Book_11">；未为未命名的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">突变体</samp><samp class="SANS_Futura_Std_Book_11">设置。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Object type</samp> | <samp class="SANS_Futura_Std_Book_11">Not
    set.</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">对象类型</samp> | <samp class="SANS_Futura_Std_Book_11">未设置。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Container</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp><samp class="SANS_Futura_Std_Book_11">,
    as a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> <samp
    class="SANS_Futura_Std_Book_11">isn’t a container.</samp> |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">容器</samp> | <samp class="SANS_Futura_Std_Book_11">设置为</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp><samp class="SANS_Futura_Std_Book_11">，因为</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> <samp class="SANS_Futura_Std_Book_11">不是一个容器。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Auto-inherit</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritDacl</samp>
    <samp class="SANS_Futura_Std_Book_11">if the parent security descriptor’s control
    flags include the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    <samp class="SANS_Futura_Std_Book_11">flag and the creator DACL is missing or
    there is no creator</samp> <samp class="SANS_Futura_Std_Book_11">security descriptor;
    set to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritSacl</samp>
    <samp class="SANS_Futura_Std_Book_11">if the</samp> <samp class="SANS_Futura_Std_Book_11">parent
    security descriptor’s control flags include the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherited</samp>
    <samp class="SANS_Futura_Std_Book_11">flag and the creator SACL is missing or
    there is no creator security descriptor.</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">自动继承</samp> | <samp class="SANS_Futura_Std_Book_11">如果父级安全描述符的控制标志包含</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> <samp class="SANS_Futura_Std_Book_11">标志并且创建者
    DACL 丢失或没有创建者安全描述符，则设置为</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritDacl</samp>
    <samp class="SANS_Futura_Std_Book_11">；如果父级安全描述符的控制标志包含</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherited</samp>
    <samp class="SANS_Futura_Std_Book_11">标志并且创建者 SACL 丢失或没有创建者安全描述符，则设置为</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritSacl</samp>。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Token</samp> | <samp class="SANS_Futura_Std_Book_11">If
    the caller is impersonating, set to an impersonation token; otherwise, set to
    the primary token of the caller’s process.</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">令牌</samp> | <samp class="SANS_Futura_Std_Book_11">如果调用者正在
    impersonate（模拟身份），则设置为模拟令牌；否则，设置为调用者进程的主令牌。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Generic mapping</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    to the generic mapping for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    <samp class="SANS_Futura_Std_Book_11">type.</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">通用映射</samp> | <samp class="SANS_Futura_Std_Book_11">设置为</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> <samp class="SANS_Futura_Std_Book_11">类型的通用映射。</samp>
    |'
- en: You might be wondering why the object type isn’t set in [Table 6-2](chapter6.xhtml#tab6-2).
    The API supports the parameter, but neither the object manager nor the I/O manager
    uses it. Its primary purpose is to let Active Directory control inheritance, so
    we’ll discuss it separately in “Determining Object Inheritance” on page 203.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么在[表 6-2](chapter6.xhtml#tab6-2)中对象类型没有设置。API 支持该参数，但对象管理器和 I/O 管理器都没有使用它。它的主要目的是让
    Active Directory 控制继承，因此我们将在第 203 页的“确定对象继承”部分单独讨论它。
- en: '[Table 6-2](chapter6.xhtml#tab6-2) shows only two possible auto-inherit flags,
    but we can pass many others to the API. [Table 6-3](chapter6.xhtml#tab6-3) lists
    the available auto-inherit flags, some of which we’ll encounter in this chapter’s
    examples.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-2](chapter6.xhtml#tab6-2) 显示了仅有的两个可能的自动继承标志，但我们可以将更多的标志传递给 API。[表 6-3](chapter6.xhtml#tab6-3)
    列出了可用的自动继承标志，其中一些将在本章的示例中遇到。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Auto-inherit Flags</samp>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 6-3:</samp> <samp class="SANS_Futura_Std_Book_11">自动继承标志</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标志名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the DACL.</samp> |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">自动继承 DACL。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the SACL.</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">自动继承SACL。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultDescriptorForObject</samp>
    | <samp class="SANS_Futura_Std_Book_11">Use the default security descriptor for
    the new security descriptor.</samp> |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultDescriptorForObject</samp>
    | <samp class="SANS_Futura_Std_Book_11">为新安全描述符使用默认的安全描述符。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp>
    | <samp class="SANS_Futura_Std_Book_11">Don’t check for privileges when setting
    the mandatory label or SACL.</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp>
    | <samp class="SANS_Futura_Std_Book_11">设置强制标签或SACL时不进行权限检查。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</samp> | <samp
    class="SANS_Futura_Std_Book_11">Avoid checking whether the owner is valid for
    the current token.</samp> |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</samp> | <samp
    class="SANS_Futura_Std_Book_11">避免检查当前令牌的所有者是否有效。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultOwnerFromParent</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copy the owner SID from the parent security
    descriptor.</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultOwnerFromParent</samp>
    | <samp class="SANS_Futura_Std_Book_11">从父安全描述符复制所有者SID。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultGroupFromParent</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copy the group SID from the parent security
    descriptor.</samp> |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultGroupFromParent</samp>
    | <samp class="SANS_Futura_Std_Book_11">从父安全描述符复制组SID。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">自动继承强制标签，使用</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>
    <samp class="SANS_Futura_Std_Book_11">策略。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp>
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">自动继承强制标签，使用</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>
    <samp class="SANS_Futura_Std_Book_11">策略。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoExecuteUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp>
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoExecuteUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">自动继承强制标签，使用</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp>
    <samp class="SANS_Futura_Std_Book_11">策略。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerRestriction</samp>
    | <samp class="SANS_Futura_Std_Book_11">Ignore restrictions placed on the new
    DACL by the parent security descriptor.</samp> |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerRestriction</samp>
    | <samp class="SANS_Futura_Std_Book_11">忽略父安全描述符对新DACL施加的限制。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceUserMode</samp> | <samp
    class="SANS_Futura_Std_Book_11">Enforce all checks as if called from user mode
    (only applicable for kernel callers).</samp> |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceUserMode</samp> | <samp
    class="SANS_Futura_Std_Book_11">强制所有检查都像从用户模式调用一样进行（仅适用于内核调用者）。</samp> |'
- en: The most important <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    parameters to consider are the values assigned to the parent and creator security
    descriptors. Let’s go through a few configurations of these two security descriptor
    parameters to understand the different outcomes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的<samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>参数是考虑分配给父安全描述符和创建者安全描述符的值。我们将通过这些两个安全描述符参数的一些配置，了解不同的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Only the Creator Security
    Descriptor</samp>
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">仅设置创建者安全描述符</samp>
- en: In the first configuration we’ll consider, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    with the object attribute’s <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field set to a valid security descriptor. If the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object is not given a name, it will be created without a parent directory, and
    the corresponding parent security descriptor won’t be set. If there is no parent
    security descriptor, the auto-inherit flags won’t be set, either.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑的第一个配置中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>，并将对象属性的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> 字段设置为有效的安全描述符。如果新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 对象没有指定名称，它将被创建时没有父目录，且相应的父安全描述符不会被设置。如果没有父安全描述符，则自动继承标志也不会被设置。
- en: Let’s test this behavior to see the security descriptor generated when we create
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object. Rather
    than creating the object itself, we’ll use the user-mode implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>, which *NTDLL*
    exports as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>.
    We can access <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    PowerShell command, as shown in [Listing 6-4](chapter6.xhtml#Lis6-4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个行为，看看在创建一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    对象时生成的安全描述符。我们不会直接创建对象，而是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    的用户模式实现，它被 *NTDLL* 导出为 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>。我们可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    PowerShell 命令访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>，如
    [列表 6-4](chapter6.xhtml#Lis6-4) 所示。
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Creating a new security descriptor from a creator security descriptor'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-4：从创建者安全描述符创建新的安全描述符
- en: We first build a creator security descriptor with only a single ACE, granting
    the *Everyone* group <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    access ❶. By formatting the security descriptor ❷, we can confirm that only the
    DACL is present in the formatted output. Next, using the creator security descriptor,
    we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    command ❸, passing the current effective token and specifying the final object
    type as <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>. This object
    type determines the generic mapping. Finally, we format the new security descriptor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建一个仅包含一个 ACE 的创建者安全描述符，授予 *Everyone* 组 <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    访问权限 ❶。通过格式化安全描述符 ❷，我们可以确认在格式化输出中只有 DACL 被包含。接下来，使用创建者安全描述符，我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    命令 ❸，传递当前有效的令牌并指定最终对象类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>。这个对象类型决定了通用映射。最后，我们格式化新的安全描述符。
- en: 'You might notice that the security descriptor has changed during the creation
    process: it has gained <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    ❹ and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> values ❺, and
    the specified access mask has changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp>
    ❻.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在创建过程中，安全描述符发生了变化：它增加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    ❹ 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> 值 ❺，并且指定的访问掩码从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> 变更为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp>
    ❻。
- en: Let’s start by considering where those new owner and group values come from.
    When we don’t specify an <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> value, the creation
    process copies these from the supplied token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PrimaryGroup</samp> SIDs. We
    can confirm this by checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s properties using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp>
    PowerShell command, as shown in [Listing 6-5](chapter6.xhtml#Lis6-5).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑这些新的所有者和组值来自哪里。当我们没有指定<sup class="SANS_TheSansMonoCd_W5Regular_11">Owner</sup>或<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Group</sup>值时，创建过程会将这些值从提供的令牌的<sup class="SANS_TheSansMonoCd_W5Regular_11">Owner</sup>和<sup
    class="SANS_TheSansMonoCd_W5Regular_11">PrimaryGroup</sup> SID中复制。我们可以通过检查<Token>对象的属性，使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</sup> PowerShell命令来确认这一点，如[清单6-5](chapter6.xhtml#Lis6-5)所示。
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: Displaying the Owner and PrimaryGroup SIDs for the current effective
    token'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-5：显示当前有效令牌的所有者和主组SID
- en: If you compare the output in [Listing 6-5](chapter6.xhtml#Lis6-5) with the security
    descriptor values in [Listing 6-4](chapter6.xhtml#Lis6-4), you can see that the
    owner and group SIDs match.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将[清单6-5](chapter6.xhtml#Lis6-5)中的输出与[清单6-4](chapter6.xhtml#Lis6-4)中的安全描述符值进行比较，你会发现所有者和组SID是匹配的。
- en: 'In [Chapter 4](chapter4.xhtml), you learned that it’s not possible to set an
    arbitrary owner SID on a token; this value must be either the user’s SID or a
    SID marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag. You might wonder: As the token’s SID is being used to set the security descriptor’s
    default owner, can we use this behavior to specify an arbitrary owner SID in the
    security descriptor? Let’s check. In [Listing 6-6](chapter6.xhtml#Lis6-6), we
    first set the security descriptor to the *SYSTEM* user’s SID, then try to create
    the security descriptor again.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，你学习到无法在令牌上设置任意的所有者SID；此值必须是用户的SID或标记为<sup class="SANS_TheSansMonoCd_W5Regular_11">Owner</sup>标志的SID。你可能会想：由于令牌的SID用于设置安全描述符的默认所有者，我们能否利用这种行为在安全描述符中指定任意的所有者SID？让我们来检查一下。在[清单6-6](chapter6.xhtml#Lis6-6)中，我们首先将安全描述符设置为*SYSTEM*用户的SID，然后再次尝试创建安全描述符。
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: Setting the <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp>
    user as the Mutant object’s security descriptor owner'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-6：将<SAMP class="SANS_Futura_Std_Book_11">SYSTEM</SAMP>用户设置为突变体对象的安全描述符所有者
- en: This time, the creation fails with an exception and the status code <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_OWNER</samp>.
    This is because the API checks whether the owner SID being assigned is valid for
    the supplied token. It doesn’t have to be the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s owner SID, but it must be either the user’s SID or a group SID with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> flag set.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，创建失败并抛出异常，状态码为<SAMP class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_OWNER</SAMP>。这是因为API会检查所分配的所有者SID是否对提供的令牌有效。它不一定是<Token>对象的所有者SID，但它必须是用户的SID或设置了<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</sup>标志的组SID。
- en: You can set an arbitrary owner SID only when the token used to create the security
    descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
    privilege enabled. Note that this token doesn’t necessarily have to belong to
    the caller of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    API. You can also disable the owner check by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</samp>
    auto-inherit flag; however, the kernel will never specify this flag when creating
    a new object, so it will always enforce the owner check.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当用于创建安全描述符的令牌启用了<sup class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</sup>特权时，你才能设置任意的所有者SID。请注意，这个令牌不一定要属于调用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</sup> API的用户。你还可以通过指定<sup
    class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</sup>自动继承标志来禁用所有者检查；然而，内核在创建新对象时永远不会指定此标志，因此它将始终执行所有者检查。
- en: This is not to say that there’s no way to set a different owner as a normal
    user. However, any method of setting an arbitrary owner that you discover is a
    security vulnerability that Microsoft will likely fix. An example of such a bug
    is CVE-2018-0748, which allowed users to set an arbitrary owner when creating
    a file. The user had to create the file via a local filesystem share, causing
    the owner check to be bypassed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说作为普通用户就没有方法设置不同的所有者。然而，任何你发现的设置任意所有者的方法，都可能是一个安全漏洞，微软很可能会修复。此类漏洞的一个例子是CVE-2018-0748，它允许用户在创建文件时设置任意所有者。用户必须通过本地文件系统共享来创建文件，从而绕过了所有者检查。
- en: There are no restrictions on the value of the group SID, as the group doesn’t
    contribute to the access check. However, restrictions apply to the SACL. If you
    specify any audit ACEs in the SACL as part of the creator security descriptor,
    the kernel will require <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组SID的值没有限制，因为组不会参与访问检查。然而，SACL有一些限制。如果你在SACL中指定了任何审核ACE作为创建者安全描述符的一部分，内核将要求<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>权限。
- en: 'Remember that when we created the security descriptor, the access mask changed?
    This is because the security descriptor assignment process maps all generic access
    rights in the access mask to type-specific access rights using the object type’s
    generic mapping information. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> mapping
    converts the access mask to <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp>.
    There is one exception to this rule: if the ACE has the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag set, then generic access rights won’t be mapped. You’ll understand why the
    exception exists shortly, when we discuss inheritance.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在创建安全描述符时，访问掩码发生了变化吗？这是因为安全描述符分配过程将所有通用访问权限映射到特定类型的访问权限，使用对象类型的通用映射信息。在这种情况下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>类型的<samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>映射将访问掩码转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp>。有一个例外：如果ACE设置了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>标志，那么通用访问权限就不会被映射。你很快会理解为什么会有这个例外，当我们讨论继承时。
- en: We can confirm this mapping behavior by using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    to create an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, as shown in [Listing 6-7](chapter6.xhtml#Lis6-7).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>创建一个没有名称的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象来确认这种映射行为，如[清单 6-7](chapter6.xhtml#Lis6-7)所示。
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: Verifying security descriptor assignment rules by creating a Mutant
    object'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-7：通过创建一个Mutant对象来验证安全描述符分配规则
- en: As you can see, the output security descriptor is the same as the one created
    in [Listing 6-4](chapter6.xhtml#Lis6-4).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出的安全描述符与[清单 6-4](chapter6.xhtml#Lis6-4)中创建的安全描述符相同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Neither the Creator
    nor the Parent Security Descriptor</samp>
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">既不设置创建者也不设置父级安全描述符</samp>
- en: Let’s explore another simple case. In this scenario, neither the creator nor
    the parent security descriptor is set. This case corresponds to calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> without a name or
    a specified <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field. The script to test it is even simpler than the previous one, as shown in
    [Listing 6-8](chapter6.xhtml#Lis6-8).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再探讨一个简单的例子。在这个场景中，既没有设置创建者，也没有设置父级安全描述符。这个例子对应于调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>时没有提供名称或指定的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>字段。用于测试的脚本比前一个更简单，如[清单
    6-8](chapter6.xhtml#Lis6-8)所示。
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-8: Creating a new security descriptor with no creator or parent security
    descriptor'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-8：创建一个没有创建者或父级安全描述符的新安全描述符
- en: This call to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    requires only the token and kernel object type ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields in the final
    security descriptor are set to default values based on the token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PrimaryGroup</samp> properties
    ❷.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: But where did the DACL ❸ come from? We haven’t specified either a parent or
    a creator security descriptor, so it couldn’t have come from either of those.
    Instead, it’s based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s *default DACL*, an ACL stored in the token that acts as a fallback when
    there is no other DACL specified. You can display a token’s default DACL by passing
    the token to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultDacl</samp> parameter,
    as in [Listing 6-9](chapter6.xhtml#Lis6-9).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-9: Displaying a token’s default DACL'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Other than its <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>-specific
    access rights, the DACL in [Listing 6-9](chapter6.xhtml#Lis6-9) matches the one
    in [Listing 6-8](chapter6.xhtml#Lis6-8). We can conclude that, if we specify neither
    the parent nor the creator security descriptor during creation, we’ll create a
    new security descriptor based on the token’s owner, primary group, and default
    DACL. However, just to be certain, let’s verify this behavior by creating an unnamed
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> with no security descriptor
    ([Listing 6-10](chapter6.xhtml#Lis6-10)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-10: Creating an unnamed Mutant to verify the default security descriptor
    creation behavior'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Wait—the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object
    has no security information at all! That’s not what we expected.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The issue here is that the kernel allows certain object types to have no security
    when the object doesn’t have a name. You can learn whether an object requires
    security by querying its <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityRequired</samp>
    property, as shown in [Listing 6-11](chapter6.xhtml#Lis6-11).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-11: Querying for the Mutant type’s SecurityRequired property'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    type doesn’t require security. So, if we specify neither the creator nor the parent
    security descriptor when creating an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, the kernel won’t generate a default security descriptor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Why would the kernel support the ability to create an object without a security
    descriptor? Well, if applications won’t share that object with each other, the
    security descriptor would serve no purpose; it would only use up additional kernel
    memory. Only if you created an object with a name, so that it can be shared, would
    the kernel require security.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么内核会支持创建没有安全描述符的对象呢？嗯，如果应用程序之间不会共享该对象，那么安全描述符就没有意义；它只会消耗额外的内核内存。只有在你创建了一个具有名称的对象，以便可以共享时，内核才会要求安全性。
- en: To verify the generation of a default security descriptor, let’s now create
    an object that requires security, such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object ([Listing 6-12](chapter6.xhtml#Lis6-12)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证默认安全描述符的生成，现在让我们创建一个需要安全的对象，例如一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">目录</samp>
    对象（[列表 6-12](chapter6.xhtml#Lis6-12)）。
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-12: Creating an unnamed Directory to verify the default security
    descriptor'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-12：创建一个没有名称的目录对象以验证默认安全描述符
- en: '[Listing 6-12](chapter6.xhtml#Lis6-12) shows that the default security descriptor
    matches our assumptions.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-12](chapter6.xhtml#Lis6-12) 显示默认安全描述符符合我们的假设。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Only the Parent Security
    Descriptor</samp>
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">仅设置父级安全描述符</samp>
- en: The next case we’ll consider is much more complex. Say we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    with a name but without specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field. Because a named <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    must be created within a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object (which, as we’ve just seen, requires security), the parent security descriptor
    will be set.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们考虑的情况要复杂得多。假设我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    并指定一个名称，但未指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    字段。由于必须在一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">目录</samp> 对象中创建一个命名的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">突变体</samp>（正如我们刚才看到的，这需要安全性），因此将设置父级安全描述符。
- en: 'Yet when we specify a parent security descriptor, we also bring something else
    into play: *inheritance*, a process by which the new security descriptor copies
    a part of the parent security descriptor. Inheritance rules determine which parts
    of the parent get passed to the new security descriptor, and we call a parent
    security descriptor *inheritable* if its parts can be inherited.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们指定父级安全描述符时，我们也引入了其他内容：*继承*，即新安全描述符复制父级安全描述符的一部分的过程。继承规则决定了父级的哪些部分会传递给新安全描述符，如果父级的某些部分可以继承，我们就称父级安全描述符为*可继承的*。
- en: The purpose of inheritance is to define a hierarchical security configuration
    for a tree of resources. Without inheritance, we would have to explicitly assign
    a security descriptor for each new object in the hierarchy, which would become
    unmanageable rather quickly. It would also make the resource tree impossible to
    manage, as each application might choose to behave differently.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的目的是为一棵资源树定义分层的安全配置。如果没有继承，我们就必须为层次结构中的每个新对象显式地分配一个安全描述符，这会很快变得无法管理。它还会使资源树变得无法管理，因为每个应用程序可能选择不同的行为方式。
- en: Let’s test the inheritance rules that apply when we create new kernel resources.
    We’ll focus on the DACL, but these concepts apply to the SACL, as well. To minimize
    code duplication, [Listing 6-13](chapter6.xhtml#Lis6-13) defines a few functions
    that run a test with the parent security descriptor and implement various options.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试创建新内核资源时应用的继承规则。我们将重点关注 DACL，但这些概念同样适用于 SACL。为了最小化代码重复，[列表 6-13](chapter6.xhtml#Lis6-13)
    定义了几个函数，这些函数通过父级安全描述符运行测试并实现各种选项。
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-13: Test function definitions for New-ParentSD and Test-NewSD'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-13：新父级安全描述符和测试新安全描述符的测试函数定义
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ParentSD</samp> function
    creates a new security descriptor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields set to the
    *Administrators* group ❶. This will allow us to check for inheritance of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp>
    field in any new security descriptor we create from this parent. We also set the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>,
    as expected for the object manager. Next, we add two <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACEs, one for the *Everyone* group and one for the *Users* group ❷, differentiated
    by their SIDs. We assign both ACEs <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access and add some extra flags for the *Users* ACE.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The function then sets some optional security descriptor control flags ❸. Normally,
    when we assign a security descriptor to a parent the generic access rights get
    mapped to type-specific access rights. Here, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGeneric</samp> parameter
    to do this mapping for us ❹.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp> function,
    we create the parent security descriptor ❺ and calculate any auto-inherit flags
    ❻. Then we create a new security descriptor, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp>
    property if required, as well as the auto-inherit flags we calculated ❼. You can
    specify a creator security descriptor for this function to use to create the new
    security descriptor. For now, we’ll leave this value as <samp class="SANS_TheSansMonoCd_W5Regular_11">$null</samp>,
    but we’ll come back to it in the next section. Finally, we print the parent, the
    creator (if specified), and the new security descriptors to the console to verify
    the input and output ❽.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by testing the default case: running the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp>
    command with no additional parameters. The command will create a parent security
    descriptor with no control flags set, so there should be no auto-inherit flags
    present in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    ([Listing 6-14](chapter6.xhtml#Lis6-14)).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-14: Creating a new security descriptor with a parent security descriptor
    and no creator security descriptor'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> do not derive from
    the parent security descriptor ❶; instead, they’re the defaults we observed earlier
    in this chapter. This makes sense: the caller, and not the user who created the
    parent object, should own the new resource.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> 并没有从父安全描述符继承❶；相反，它们是我们在本章早些时候看到的默认值。这是有道理的：应该由调用者而不是创建父对象的用户拥有新资源。
- en: However, the new DACL doesn’t look as we might have expected ❷. It’s set to
    the default DACL we saw earlier, and it bears no relation to the DACL we built
    in the parent security descriptor. The reason we didn’t get any ACEs from the
    parent’s DACL is that we did not specify the ACEs as inheritable. To do so, we
    need to set one or both of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> ACE
    flags. The former applies only to non-container objects such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    objects, while the latter applies to container objects such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects. The distinction between the two types is important, because they affect
    how the inherited ACEs propagate to child objects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，新的 DACL 看起来并不像我们预期的那样❷。它被设置为我们之前看到的默认 DACL，并且与我们在父安全描述符中构建的 DACL 无关。我们没有从父
    DACL 中获得任何 ACE 的原因是，我们没有将 ACE 指定为可继承的。为了做到这一点，我们需要设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> 这两个 ACE
    标志中的一个或两个。前者仅适用于像 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    这样的非容器对象，而后者适用于像 <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    这样的容器对象。两者之间的区别很重要，因为它们会影响继承的 ACE 如何传播到子对象。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object is a
    non-container, so let’s add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    flag to the ACE in the parent security descriptor ([Listing 6-15](chapter6.xhtml#Lis6-15)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 对象是一个非容器对象，因此我们需要向父安全描述符中的
    ACE 添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> 标志（[列表
    6-15](chapter6.xhtml#Lis6-15)）。
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-15: Adding an ObjectInherit ACE to the parent security descriptor'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-15：向父安全描述符添加一个 ObjectInherit ACE
- en: In this listing, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    ACE flag to the test function ❶. Observe that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields have not
    changed ❷, but the DACL is no longer the default ❸. Instead, it contains a single
    ACE that grants the *Users* group <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|Delete|ReadControl|WriteDac|WriteOwner</samp>
    access. This is the ACE that we set to be inherited.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，我们向测试函数指定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    ACE 标志❶。请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> 字段没有发生变化❷，但是 DACL 不再是默认值❸。相反，它包含一个
    ACE，授予 *Users* 组 <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|Delete|ReadControl|WriteDac|WriteOwner</samp>
    权限。这是我们设置为继承的 ACE。
- en: 'However, you might notice a problem: the parent security descriptor’s ACE was
    granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>, while
    the new security descriptor’s ACE is not. Why has the access mask changed? In
    fact, it hasn’t; the inheritance process has merely taken the raw <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    access mask for the parent security descriptor’s ACE (the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000F000F</samp>)
    and copied it to the inherited ACE. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object’s valid access bits are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x001F0001</samp>.
    Therefore, the inheritance process uses the closest mapping, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000F0001</samp>,
    as shown in [Listing 6-16](chapter6.xhtml#Lis6-16).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会注意到一个问题：父安全描述符的 ACE 被授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">完全访问</samp>
    权限，而新安全描述符的 ACE 并没有。为什么访问掩码发生了变化？事实上，它并没有变化；继承过程仅仅将父安全描述符 ACE 的原始 <samp class="SANS_TheSansMonoCd_W5Regular_11">目录</samp>
    访问掩码（值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000F000F</samp>）复制到了继承的
    ACE 中。<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 对象的有效访问位是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x001F0001</samp>。因此，继承过程使用最接近的映射 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x000F0001</samp>，如 [列表 6-16](chapter6.xhtml#Lis6-16)
    所示。
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-16: Checking the inherited access mask'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-16：检查继承的访问掩码
- en: This is a pretty serious issue. Notice, for example, that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    type is missing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Synchronize</samp>
    access right, which it needs for a caller to wait on the lock. Without this access,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object would be
    useless to an application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当严重的问题。例如，注意到 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    类型缺少 <samp class="SANS_TheSansMonoCd_W5Regular_11">Synchronize</samp> 访问权限，而该权限是调用者等待锁定所必需的。如果没有这个访问权限，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 对象对于应用程序来说将毫无用处。
- en: 'We can solve this access mask problem by specifying a generic access mask in
    the ACE. This will map to a type-specific access mask when the new security descriptor
    is created. There is only one complication: we’ve taken the parent security descriptor
    from an existing object, so the generic access was already mapped when the security
    descriptor was assigned. We simulated this behavior in our test function with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    call.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 ACE 中指定一个通用访问掩码来解决这个访问掩码问题。这将在创建新安全描述符时映射到类型特定的访问掩码。只有一个复杂之处：我们已经从现有对象中获取了父安全描述符，因此在分配安全描述符时通用访问已经映射。我们在测试函数中使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    调用模拟了这一行为。
- en: To resolve this issue, the ACE can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag. As a result, any generic access will remain untouched during the initial
    assignment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag marks the ACE for inheritance only, which prevents the generic access from
    being an issue for access checking. In [Listing 6-17](chapter6.xhtml#Lis6-17),
    we check this behavior by modifying the call to the test function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可以在 ACE 中设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    标志。结果，任何通用访问在初始分配过程中都不会被触及。<samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    标志标记 ACE 仅供继承使用，这防止了通用访问在访问检查中成为问题。在 [列表 6-17](chapter6.xhtml#Lis6-17) 中，我们通过修改对测试函数的调用来检查此行为。
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 6-17: Adding an InheritOnly ACE'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-17：添加一个 InheritOnly ACE
- en: In this listing, we change the ACE flags to <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ❶. In the
    parent security descriptor’s output, we can see that the access mask is no longer
    mapped from <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> ❷.
    As a result, the inherited ACE is now granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full
    Access</samp>, as we require ❸.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们将 ACE 标志更改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ❶。在父安全描述符的输出中，我们可以看到访问掩码不再从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> ❷ 映射出来。结果，继承的
    ACE 现在授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">完全访问</samp> 权限，正如我们要求的那样
    ❸。
- en: Presumably, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp>
    flag works in the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>,
    right? Not quite. We test its behavior in [Listing 6-18](chapter6.xhtml#Lis6-18).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-18: Creating a new security descriptor with the ContainerInherit
    flag'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Here, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flags to
    the ACE and then pass the function the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp>
    parameter ❶. Unlike in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    case, we now end up with two ACEs in the DACL. The first ACE ❷ grants access to
    the new resource based on the inheritable ACE. The second ❸ is a copy of the inheritable
    ACE, with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You might wonder how we can create a security descriptor for a container type
    when we’re using the Mutant type. The answer is that the API doesn’t care about
    the final type, as it uses only the generic mapping; when creating a real Mutant
    object, however, the kernel would never specify the Container flag.*'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The ACE’s automatic propagation is useful, as it allows you to build a hierarchy
    of containers without needing to manually grant them access rights. However, you
    might sometimes want to disable this automatic propagation by specifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp> ACE flag, as
    shown in [Listing 6-19](chapter6.xhtml#Lis6-19).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-19: Using NoPropagateInherit to prevent the automatic inheritance
    of ACEs'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: When we specify this flag, the ACE that grants access to the resource remains
    present, but the inheritable ACE disappears ❶.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try another ACE flag configuration to see what happens to <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    ACEs when they’re inherited by a container ([Listing 6-20](chapter6.xhtml#Lis6-20)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 6-20: Testing the ObjectInherit flag on a container'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: You might not expect the container to inherit the ACE at all, but in fact, it
    receives the ACE with the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag automatically set ❶. This allows the container to pass the ACE to non-container
    child objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-4](chapter6.xhtml#tab6-4) summarizes the inheritance rules for container
    and non-container objects based on the parent ACE flags. Objects are bolded where
    no inheritance occurs.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-4:</samp> <samp class="SANS_Futura_Std_Book_11">Parent
    ACE Flags and Flags Set on the Inherited ACEs</samp>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parent ACE flags</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Non-container object</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Container
    object</samp> |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No
    inheritance</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp>
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp>
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp>
    | <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No
    inheritance</samp> |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No
    inheritance</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp> |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp>
    | <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: Finally, consider *auto-inherit flags*. If you return to [Table 6-3](chapter6.xhtml#tab6-3),
    you can see that if the DACL has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    control flag set, the kernel will pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>,
    as there is no creator security descriptor. (The SACL has a corresponding <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flag, but we’ll
    focus on the DACL here.) What does the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    flag do? In [Listing 6-21](chapter6.xhtml#Lis6-21), we perform a test to find
    out.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6-21: Setting the DaclAutoInherited control flag in the parent security
    descriptor'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: We set the parent security descriptor’s control flags to contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    flag ❶, and we confirm that it’s set by looking at the formatted DACL ❷. We can
    see that the new security descriptor contains the flag as well ❸; also, the inherited
    ACE has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag
    ❹.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: How do the auto-inherit flags differ from the inheritance flags we discussed
    earlier? Microsoft conserves both inheritance types for compatibility reasons
    (as it didn’t introduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag until Windows 2000). From the kernel’s perspective, the two types of inheritance
    are not very different other than determining whether the new security has the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> flag set
    and whether any inherited ACE gets the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag. But from a user-mode perspective, this inheritance model indicates which
    parts of the DACL were inherited from a parent security descriptor. That’s important
    information, and various Win32 APIs use it, as we’ll discuss in “Win32 Security
    APIs” on page 208.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Both the Creator and
    Parent Security Descriptors</samp>
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the final case, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    with a name and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field, setting both the creator and parent security descriptor parameters. To
    witness the resulting behavior, let’s define some test code. [Listing 6-22](chapter6.xhtml#Lis6-22)
    writes a function to generate a creator security descriptor. We’ll reuse the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp> function we wrote earlier
    to run the test.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 6-22: The New-CreatorSD test function'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'This function differs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ParentSD</samp>
    function created in [Listing 6-13](chapter6.xhtml#Lis6-13) in the following ways:
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> type when
    creating the security descriptor ❶, we allow the caller to not specify a DACL
    ❷, and we set a different SID for the DACL if it is used ❸. These changes will
    allow us to distinguish the parts of a new security descriptor that come from
    the parent and those that come from the creator.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In some simple cases, the parent security descriptor has no inheritable DACL,
    and the API follows the same rules it uses when only the creator security descriptor
    is set. In other words, if the creator specifies the DACL, the new security descriptor
    will use it. Otherwise, it will use the default DACL.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If the parent security descriptor contains an inheritable DACL, the new security
    descriptor will inherit it, unless the creator security descriptor also has a
    DACL. Even an empty or NULL DACL will override the inheritance from the parent.
    In [Listing 6-23](chapter6.xhtml#Lis6-23), we verify this behavior.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 6-23: Testing parent DACL inheritance with no creator DACL'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We first build a creator security descriptor with no DACL ❶, then run the test
    with an inheritable parent security descriptor ❷. In the output, we confirm the
    inheritable ACE for the *Users* group ❸ and that the creator has no DACL set ❹.
    When we create the new security descriptor, it receives the inheritable ACE ❺.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also check what happens when we set a creator DACL ([Listing 6-24](chapter6.xhtml#Lis6-24)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 6-24: Testing the overriding of parent DACL inheritance by the creator
    DACL'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Here, we build the creator security descriptor with a DACL ❶ and keep the same
    inheritable parent security descriptor as in [Listing 6-23](chapter6.xhtml#Lis6-23)
    ❷. In the output, we see that the ACEs from the creator’s DACL have been copied
    to the new security descriptor ❸.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The previous two tests haven’t specified any auto-inherit flags. If we specify
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> control
    flag on the parent security descriptor but include no creator DACL, then the inheritance
    proceeds in the same way as in [Listing 6-24](chapter6.xhtml#Lis6-24), except
    that it sets the inherited ACE flags.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: However, something interesting happens if we specify both a creator DACL and
    the control flag ([Listing 6-25](chapter6.xhtml#Lis6-25)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 6-25: Testing parent DACL inheritance when the creator DACL and the
    DaclAutoInherited control flag are set'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we build a creator security descriptor and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">INTERACTIVE</samp>
    SID ACE to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag ❶. Next, we run the test with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    control flag on the parent security descriptor ❷. In the output, notice that there
    are two ACEs. The first ACE was copied from the creator ❸, while the second is
    the inherited ACE from the parent ❹. [Figure 6-1](chapter6.xhtml#fig6-1) shows
    this auto-inheritance behavior.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-1.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The auto-inheritance
    behavior when the parent and creator security descriptors are both set</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> is
    set, the new security descriptor’s DACL merges the non-inherited ACEs from the
    creator security descriptor with the inheritable ACEs from the parent. This auto-inheritance
    behavior allows you to rebuild a child’s security descriptor based on its parent
    without losing any ACEs that the user has explicitly added to the DACL. Additionally,
    the automatic setting of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    ACE flag lets us differentiate between these explicit and inherited ACEs.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Note that normal operations in the kernel do not set the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    flag, which is enabled only if the parent security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    control flag set and the DACL isn’t present. In our test, we specified a DACL,
    so the auto-inherit flag was not set. The Win32 APIs use this behavior, as we’ll
    discuss later in this chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: If you want to suppress the merging of the explicit ACEs and the parent’s inheritable
    ACEs, you can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    and/or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> security
    descriptor control flags. If a protected control flag is set, the inheritance
    rules leave the respective ACL alone, other than setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInherited</samp>
    control flag for the ACL and clearing any inherited ACE flags. In [Listing 6-26](chapter6.xhtml#Lis6-26),
    we test this behavior for the DACL.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 6-26: Testing the DaclProtected control flag'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We start by generating a creator security descriptor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    flag, and setting one of the ACE’s flags to <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    ❶. We then create a new security descriptor with an auto-inherited parent ❷. Without
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> flag, the
    new security descriptor’s DACL would have been a merged version of the creator
    DACL and the inheritable ACEs from the parent. Instead, we see only the creator
    DACL’s ACEs. Also, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag on the second ACE has been cleared ❸.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: What if we don’t know whether the parent security descriptor will have inheritable
    ACEs, and we don’t want to end up with the default DACL? This might be important
    for permanent objects, such as files or keys, as the default DACL contains the
    ephemeral logon SID, which shouldn’t really be persisted to disk. After all, reusing
    the logon SID could end up granting access to an unrelated user.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can’t set a DACL in the creator security descriptor; according
    to inheritance rules, this would overwrite any inherited ACEs. Instead, we can
    handle this scenario using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclDefaulted</samp>
    security descriptor control flag, which indicates that the provided DACL is a
    default. [Listing 6-27](chapter6.xhtml#Lis6-27) demonstrates its use.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 6-27: Testing the DaclDefaulted flag'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: If the parent does not contain any inheritable DACL ACEs, the new security descriptor
    will use the creator’s DACL instead of the default. If the parent does contain
    inheritable ACEs, the inheritance process will overwrite the DACL, following the
    rules outlined previously.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: To implement similar behavior for the SACL, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclDefaulted</samp>
    control flag. However, tokens don’t contain a default SACL, so this flag is somewhat
    less important.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Replacing the CREATOR OWNER
    and CREATOR GROUP SIDs</samp>
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve seen that, during inheritance, an inherited ACE retains the same SID as
    the original. In some scenarios, this isn’t desirable. For example, you might
    have a shared directory that allows any user to create a child directory. What
    security descriptor could you set on this shared directory so that only the creator
    of the child directory has access to it?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: One solution would be to remove all inheritable ACEs. As a result, the new directory
    would use the default DACL. This would almost certainly secure the directory to
    prevent other users from accessing it. However, as mentioned in the previous section,
    the default DACL is designed for ephemeral resources, such as those in the object
    manager; persistent security descriptors shouldn’t use it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate features such as shared directories, the inheritance implementation
    supports four special creator SIDs. When a security descriptor inherits an ACE
    with any of these SIDs, the inheritance implementation will replace the creator
    SID with a specific SID from the creator’s token:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR OWNER*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-0)  </samp>Replaced
    by the token’s owner'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR GROUP*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-1)  </samp>Replaced
    by the token’s primary group'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR OWNER SERVER*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">S-1-3-2)  </samp>Replaced by the server’s
    owner'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR GROUP SERVER*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-3)  </samp>Replaced
    by the server’s primary group'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the server SIDs only when creating a server security descriptor, which
    we’ll discuss in “Server Security Descriptors and Compound ACEs” on page 213.
    The conversion from the creator SID to a specific SID is a one-way process: once
    the SID has been replaced, you can’t tell it apart from a SID you set explicitly.
    However, if a container has inherited the ACE, it will keep the creator SID in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACE. [Listing
    6-28](chapter6.xhtml#Lis6-28) provides an example.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 6-28: Testing creator SIDs during inheritance'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We first add two ACEs with the *CREATOR OWNER* and *CREATOR GROUP* SIDs to a
    parent security descriptor, giving the ACEs different levels of access to make
    them easy to distinguish ❶. We then create a new security descriptor based on
    the parent, specifying that we’ll use it for a container ❷. In the formatted output,
    we see that the user’s SID has replaced the *CREATOR OWNER* SID. This SID is based
    on the owner SID in the token ❸. We also can see that the *CREATOR GROUP* SID
    has been replaced with the group SID from the token ❹.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve created the security descriptor for a container, we also see that there
    are two <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACEs
    whose creator SID has not been changed. This behavior allows the creator SID to
    propagate to any future children.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Assigning Mandatory Labels</samp>
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The mandatory label ACE contains the integrity level of a resource. But when
    we create a new security descriptor using a token whose integrity level is greater
    than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>,
    the new security descriptor won’t receive a mandatory label by default. This behavior
    explains why we haven’t seen any mandatory label ACEs in our tests so far.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: If the token’s integrity level is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>,
    on the other hand, this label is automatically assigned to the new security descriptor,
    as shown in [Listing 6-29](chapter6.xhtml#Lis6-29).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 6-29: Assigning the mandatory label of the creator’s token'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we duplicate the current token and assign it a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level. When we create a new security descriptor based on the token,
    we see that it has a mandatory label with the same integrity level.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: An application can set a mandatory label ACE explicitly when creating a new
    resource through the creator security descriptor. However, the integrity level
    in the mandatory label ACE must be less than or equal to the token’s integrity
    level; otherwise, the creation will fail, as shown in [Listing 6-30](chapter6.xhtml#Lis6-30).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 6-30: Assigning a mandatory label based on the creator security descriptor'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new creator security descriptor and add a mandatory label
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> integrity
    level to it. We then get the caller’s token and set its integrity level to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    integrity level is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>,
    if we attempt to use the creator security descriptor to create a new security
    descriptor, the operation fails with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp>
    error ❶.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: To set a higher integrity level, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    privilege must be enabled on the creator token, or you must specify the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp> auto-inherit
    flag. In this example, we set the auto-inherit flag when creating the new security
    descriptor ❷. With this addition the creation succeeds, and we can see the mandatory
    label in the formatted output ❸.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We can make the mandatory label ACE inheritable by setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> flag.
    It’s also possible to specify its <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag, which prevents the integrity level from being used as part of an access
    check, reserving it for inheritance only.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, though, that integrity-level restrictions apply to inherited mandatory
    label ACEs too. The inherited ACE must have an integrity level that is less than
    or equal to the token’s; otherwise, the security descriptor assignment will fail.
    Again, we can bypass this restriction with either the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    privilege or the <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp>
    auto-inherit flag. [Listing 6-31](chapter6.xhtml#Lis6-31) shows an example in
    which a security descriptor inherits the mandatory label ACE.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 6-31: Assigning a mandatory label from a parent security descriptor
    through inheritance'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a parent security descriptor and assign it a mandatory label
    ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity
    level and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    flag set ❶. We then create a new security descriptor using the parent. The new
    security descriptor inherits the mandatory label, as indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag ❷.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Certain kernel object types might receive the mandatory label automatically,
    even if the caller’s token has an integrity level greater than or equal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>. By specifying certain auto-inherit
    flags, you can always assign the caller’s integrity level when creating a new
    security descriptor for the resource. These flags include <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoExecuteUp</samp>,
    which auto-inherit the token’s integrity level and set the mandatory policy to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp>, respectively.
    By combining these flags, you can get the desired mandatory policy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In the latest versions of Windows, only four types are registered to use these
    auto-inherit flags, as shown in [Table 6-5](chapter6.xhtml#tab6-5).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-5:</samp> <samp class="SANS_Futura_Std_Book_11">Types
    with Integrity Level Auto-inherit Flags Enabled</samp>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Type name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit
    flags</samp> |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Job</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp>
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp>
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: We can test the behavior of these auto-inherit flags by specifying them when
    we create a security descriptor. In [Listing 6-32](chapter6.xhtml#Lis6-32), we
    specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp> auto-inherit
    flags.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 6-32: Assigning a mandatory label by specifying auto-inherit flags'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see a mandatory label ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    integrity level, even though I mentioned at the start of this section that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> level wouldn’t normally
    be assigned. We can also see that the mandatory policy has been set to <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp|NoReadUp</samp>,
    which matches the auto-inherit flags we specified.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Determining Object Inheritance</samp>
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When we specify an object ACE type, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp>,
    in a parent security descriptor, the inheritance rules change slightly. This is
    because each object ACE can contain two optional GUIDs: <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>,
    used for access checking, and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>,
    used for inheritance.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    API uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    GUID in an ACE to calculate whether a new security descriptor should inherit that
    ACE. If this GUID exists and its value matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID, the new security descriptor will inherit the ACE. By contrast, if the values
    don’t match, the ACE won’t be copied. [Table 6-6](chapter6.xhtml#tab6-6) shows
    the possible combinations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    parameter and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    and whether the ACE is inherited.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-6:</samp> <samp class="SANS_Futura_Std_Book_11">Whether
    to Inherit the ACE Based on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> <samp class="SANS_Futura_Std_Heavy_B_11">parameter
    specified?</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">in ACE?</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Inherited</samp>
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">No</samp> | <samp class="SANS_Futura_Std_Book_11">No</samp>
    | <samp class="SANS_Futura_Std_Book_11">Yes</samp> |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">No</samp> | <samp class="SANS_Futura_Std_Book_11">Yes</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">No</samp> |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Yes</samp> | <samp class="SANS_Futura_Std_Book_11">No</samp>
    | <samp class="SANS_Futura_Std_Book_11">Yes</samp> |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Yes</samp> | <samp class="SANS_Futura_Std_Book_11">Yes
    (and the values match)</samp> | <samp class="SANS_Futura_Std_Book_11">Yes</samp>
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Yes</samp> | <samp class="SANS_Futura_Std_Book_11">Yes
    (and the values don’t match)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No</samp>
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: 'I’ve bolded the cases in [Table 6-6](chapter6.xhtml#tab6-6) where inheritance
    doesn’t happen. Note that this doesn’t supersede any other inheritance decision:
    the ACE must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    and/or <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> flag
    set to be considered for inheritance.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-33](chapter6.xhtml#Lis6-33), we verify this behavior by adding
    some object ACEs to a security descriptor and using it as the parent.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 6-33: Verifying the behavior of the InheritedObjectType GUID'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We first generate a couple of random GUIDs to act as our object types ❶. Next,
    we add three inheritable <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp>
    ACEs to the parent security descriptor. In the first ACE, we set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    to the first GUID we created ❷. This ACE demonstrates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID is not considered when inheriting the ACE. The second ACE sets the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> to the first
    GUID ❸. The final ACE uses the second GUID ❹.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new security descriptor, passing the second GUID to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> parameter ❺. When we
    check the new security descriptor, we can see that it inherited the ACE without
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> ❻.
    The second ACE in the output is a copy of the ACE with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    GUID that matches ❼. Notice that, based on the output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    has been removed, as the ACE is no longer inheritable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a single <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID parameter is somewhat inflexible, so Windows also provides two APIs that
    take a list of GUIDs rather than a single GUID: the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx2</samp>
    kernel API and the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectWithMultipleInheritance</samp>
    user-mode API. Any ACE in the list with the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    will be inherited; otherwise, the inheritance rules are basically the same as
    those covered here.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on assigning security descriptors during creation.
    As you’ve seen, the assignment process is complex, especially with regard to inheritance.
    We’ll now discuss assigning a security descriptor to an existing resource, a considerably
    simpler process.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Security
    Descriptor to an Existing Resource</samp>
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a resource already exists, it’s not possible to set the security descriptor
    by calling a creation system call such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    and specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field in the object attributes. Instead, you need to open a handle to the resource
    with one of three access rights, depending on what part of the security descriptor
    you want to modify. Once you have this handle, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>
    system call to set specific security descriptor information. [Table 6-7](chapter6.xhtml#tab6-7)
    shows the access rights needed to set each security descriptor field based on
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> enumeration.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-7:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    <samp class="SANS_Futura_Std_Book_11">Flags and Required Access for Security Descriptor
    Creation</samp>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Location</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Handle
    access required</samp> |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the owner SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Owner</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the group SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Group</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the DACL.</samp> | <samp class="SANS_Futura_Std_Book_11">DACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sacl</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the SACL (for auditing ACEs only).</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the mandatory label.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a system resource attribute.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a scoped policy ID.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTrustLabel</samp> |
    <samp class="SANS_Futura_Std_Book_11">Set the process trust label.</samp> | <samp
    class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessFilter</samp> | <samp
    class="SANS_Futura_Std_Book_11">Set an access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    everything except the process trust label and access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">All</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp><samp class="SANS_Futura_Std_Book_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp><samp class="SANS_Futura_Std_Book_11">,
    and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: You might notice that the handle access required for setting this information
    is more complex than the access needed to merely query it (covered in [Table 6-1](chapter6.xhtml#tab6-1)),
    as it is split across three access rights instead of two. Rather than trying to
    memorize these access rights, you can retrieve them using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp>
    PowerShell command, specifying the parts of the security descriptor you want to
    set with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    parameter, as shown in [Listing 6-34](chapter6.xhtml#Lis6-34).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 6-34: Discovering the access mask needed to query or set specific security
    descriptor information'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: To set a security descriptor, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>
    system call invokes a type-specific security function. This type-specific function
    allows the kernel to support the different storage requirements for security descriptors;
    for example, a file must persist its security descriptor to disk, while the object
    manager can store a security descriptor in memory.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: These type-specific functions eventually call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp>
    kernel API to build the updated security descriptor. User mode exports this kernel
    API as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>.
    Once the security descriptor has been updated, the type-specific function can
    store it using its preferred mechanism.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp>
    API accepts the following five parameters and returns a new security descriptor:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Modification security descriptor    **The new security descriptor passed
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**Object security descriptor    **The current security descriptor for the object
    being updated'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Security information    **Flags to specify what parts of the security descriptor
    to update, described in [Table 6-7](chapter6.xhtml#tab6-7)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto-inherit    **A set of bit flags that define the auto-inheritance behavior'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic mapping    **The generic mapping for the type being created'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: No kernel code uses the auto-inherit flags; therefore, the behavior of this
    API is simple. It merely copies the parts of the security descriptor specified
    in the security information parameter to the new security descriptor. It also
    maps any generic access to the type-specific access using the generic mapping,
    excluding <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACEs.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Some security descriptor control flags introduce special behavior. For example,
    it’s not possible to explicitly set <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>,
    but you can specify it along with <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInheritReq</samp>
    to set it on the new security descriptor.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: We can test out the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>
    API using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    command, as shown in [Listing 6-35](chapter6.xhtml#Lis6-35).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 6-35: Using Edit-NtSecurityDescriptor to modify an existing security
    descriptor'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the security for a kernel object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp>
    command. The command can accept either an object handle with the required access
    or an OMNS path to the resource. For example, you could use the following commands
    to try to modify the object *\BaseNamedObjects\ABC* by setting a new DACL:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note the “try to”: even if you can open a resource with the required access
    to set a security descriptor component, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access, this doesn’t mean the kernel will let you do it. The same rules regarding
    owner SIDs and mandatory labels apply here as when assigning a security descriptor
    at creation time.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp>
    API enforces these rules. If no object security descriptor is specified, then
    the API returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SECURITY
    _ON_OBJECT</samp> status code. Therefore, you can’t set the security descriptor
    for a type with <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityRequired</samp>
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>; that object
    won’t have a security descriptor, so any attempt to modify it causes the error.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*One ACE flag I haven’t mentioned yet is Critical. The Windows kernel contains
    code to check the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp>
    flag and block the removal of ACEs that have the flag set. However, which ACEs
    to deem <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp>
    is up to the code assigning the new security descriptor, and APIs such as <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeSetSecurityInformationEx</samp>
    do not enforce it. Therefore, do not rely on the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp>
    flag to do anything specific. If you’re using security descriptors in user mode,
    you can handle the flag any way you like.*'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you change the inheritable ACEs on a container? Will the changes
    in the security descriptor propagate to all existing children? In a word, no.
    Technically, a type could implement this automatic propagation behavior, but none
    do. Instead, it’s up to the user-mode components to handle it. Next, we’ll look
    at the user-mode Win32 APIs that implement this propagation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Win32 Security APIs</samp>
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most applications don’t directly call the kernel system calls to read or set
    security descriptors. Instead, they use a range of Win32 APIs. While we won’t
    discuss every API you could use here, we’ll cover some of the additional functionality
    the APIs add to the underlying system calls.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Win32 implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKernelObjectSecurity</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetKernelObjectSecurity</samp>
    APIs, which wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>.
    Likewise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatePrivateObjectSecurityEx</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPrivateObjectSecurityEx</samp>
    Win32 APIs wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>,
    respectively. Every property of the native APIs discussed in this chapter applies
    equally to these Win32 APIs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Win32 also provides some higher-level APIs: most notably, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>.
    These APIs allow an application to query or set a security descriptor by providing
    a path and the type of resource that path refers to, rather than a handle. The
    use of a path and type allows the functions to be more general; for example, these
    APIs support getting and setting the security of not only files and registry keys
    but also services, printers, and Active Directory Domain Services (DS) entries.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: To query or set the security descriptor, the API must open the specified resource
    and then call the appropriate API to perform the operation. For example, to query
    a file’s security descriptor, the API would open the file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>
    Win32 API and then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    system call. However, to query a printer’s security descriptor, the Win32 API
    needs to open the printer using the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenPrinter</samp>
    print spooler API and then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetPrinter</samp>
    API on the opened printer handle (as a printer is not a kernel object).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell already uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp>
    API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command;
    however, the built-in command doesn’t support reading certain security descriptor
    ACEs, such as mandatory labels. Therefore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module implements <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32SecurityDescriptor</samp>,
    which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp>
    and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: If you merely want to display the security descriptor, you can use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32SecurityDescriptor</samp>
    command, which takes the same parameters but doesn’t return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object. [Listing 6-36](chapter6.xhtml#Lis6-36) provides a couple of examples of
    commands that leverage the underlying Win32 security APIs.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 6-36: An example usage of Get-Win32SecurityDescriptor and Format-Win32SecurityDescriptor'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: We start by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32SecurityDescriptor</samp>
    to query the security descriptor for the *Windows* directory, in this case <samp
    class="SANS_TheSansMonoCd_W5Regular_11">$env:WinDir</samp>. Note that we don’t
    specify the type of resource we want to query, as it defaults to a file. In the
    second example, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32Security
    Descriptor</samp> to display the security descriptor for the *MACHINE\SOFTWARE*
    key. This key path corresponds to the Win32 *HKEY_LOCAL_MACHINE\SOFTWARE* key
    path. We need to indicate that we’re querying a registry key by specifying the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> parameter; otherwise,
    the command will try to open the path as a file, which is unlikely to work.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To find the path format for every supported type of object, consult the API
    documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SE_OBJECT_TYPE</samp>
    enumeration, which is used to specify the type of resource in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GetNamedSecurityInfo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SetNamedSecurityInfo</samp>
    APIs.*'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    API is more complex, as it implements auto-inheritance across hierarchies (for
    example, across a file directory tree). As we discussed earlier, if you use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp> system
    call to set a file’s security descriptor, any new inheritable ACEs won’t get propagated
    to any existing children. If you set a security descriptor on a file directory
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>,
    the API will enumerate all child files and directories and attempt to update each
    child’s security descriptor.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    API generates the new security descriptor by querying the child security descriptor
    and using it as the creator security descriptor in a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>,
    taking the parent security descriptor from the parent directory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flags
    are always set, to merge any explicit ACEs in the creator security descriptor
    into the new security descriptor.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell exposes the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp>
    command, as shown in [Listing 6-37](chapter6.xhtml#Lis6-37).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 6-37: Testing auto-inheritance with Set-Win32SecurityDescriptor'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-37](chapter6.xhtml#Lis6-37) demonstrates the auto-inheritance behavior
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> for
    files. We first create the *TestFolder* directory in the root of the system drive,
    then set the security descriptor so that it contains one inheritable ACE for the
    *Everyone* group and has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> flags set
    ❶. Next, we create a text file inside the directory and print its security descriptor.
    The DACL contains the single ACE inherited from the parent by the text file ❷.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We then get the security descriptor from the directory and add a new inheritable
    ACE to it for the anonymous user. We use this security descriptor to set the DACL
    of the parent using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp>
    ❸. Printing the text file’s security descriptor again, we now see that it has
    two ACEs, as the anonymous user ACE has been added ❹. If we had used <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp>
    to set the parent directory’s security descriptor, this inheritance would not
    have taken place.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    always uses auto-inheritance, applying a protected security descriptor control
    flag, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp>, becomes
    an important way to block the automatic propagation of ACEs.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Oddly, the API doesn’t allow you to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> control
    flags directly in the security descriptor. Instead, it introduces some additional
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> flags
    to handle setting and unsetting the control flags. To set a protected security
    descriptor control flag, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedDacl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedSacl</samp> flags for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>. To unset
    a flag, use <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedSacl</samp>. [Listing
    6-38](chapter6.xhtml#Lis6-38) provides examples of setting and unsetting the protected
    control flag for the DACL.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 6-38: Testing the ProtectedDacl and UnprotectedDacl SecurityInformation
    flags'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: This script assumes you’ve run [Listing 6-37](chapter6.xhtml#Lis6-37) already,
    as it reuses the file created there. We create a new security descriptor with
    a single ACE for the *Authenticated Users* group and assign it to the file with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedDacl</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> flags ❶. As a result, the
    protected control flag for the DACL is now set on the file ❷. Note that the inherited
    ACEs from [Listing 6-37](chapter6.xhtml#Lis6-37) have been removed; only the new,
    explicit ACE is left.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: We then assign the security descriptor again with the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp>
    flag ❸. This time, when we print the security descriptor we can see that it no
    longer has the protected control flag set ❹. Also, the API restores the inherited
    ACEs from the parent directory and merges them with the explicit ACE for the *Authenticated
    Users* group.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of the command when we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp>
    flag shows you how you can restore the inherited ACEs for any file. If you specify
    an empty DACL so no explicit ACEs will be merged, and additionally specify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp> flag, you’ll
    reset the security descriptor to the version based on its parent. To simplify
    this operation, the PowerShell module contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset-Win32SecurityDescriptor</samp>
    command ([Listing 6-39](chapter6.xhtml#Lis6-39)).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 6-39: Resetting the security of a directory using Reset-Win32SecurityDescriptor'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset-Win32SecurityDescriptor</samp>
    with the path to the file and request that the DACL be reset. When we display
    the security descriptor of the file, we now find that it matches the parent directory’s
    security descriptor, shown in [Listing 6-37](chapter6.xhtml#Lis6-37).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: One final API to cover is <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp>,
    which allows you to identify the source of a resource’s inherited ACEs. One reason
    ACEs are marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag is to facilitate the analysis of inherited ACEs. Without the flag, the API
    would have no way of distinguishing between inherited and non-inherited ACEs.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: For each ACE with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag set, the API works its way up the parent hierarchy until it finds an inheritable
    ACE that doesn’t have this flag set but contains the same SID and access mask.
    Of course, there is no guarantee that the found ACE is the actual source of the
    inherited ACE, which could potentially live further up the hierarchy. Thus, treat
    the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp>
    as purely informational, and don’t use it for security-critical decisions.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Like the other Win32 APIs, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp>
    supports different types. However, it’s limited to resources that have a child-parent
    relationship, such as files, registry keys, and DS objects. You can access the
    API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp>
    command, as shown in [Listing 6-40](chapter6.xhtml#Lis6-40).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 6-40: Enumerating inherited ACEs using Search-Win32SecurityDescriptor'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: We first call <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp>
    with the path to the directory we created in [Listing 6-38](chapter6.xhtml#Lis6-38).
    The output is a list of the ACEs in the resource’s DACL, including the name of
    the resource from which each ACE was inherited and the depth of the hierarchy.
    We set two explicit ACEs on the directory. The output reflects this as a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    which indicates that the ACE wasn’t inherited. You can also see that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column is empty.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new file in the directory and rerun the command. In this case,
    as you might have expected, the ACEs show that they were both inherited from the
    parent folder, with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: This section covered the basics of the Win32 APIs. Keep in mind that there are
    clear differences in behavior between these APIs and the low-level system calls,
    especially regarding inheritance. When you interact with the security of resources
    via a GUI, it’s almost certainly calling one of the Win32 APIs.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Server Security Descriptors and Compound
    ACEs</samp>
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s finish this chapter with a topic I briefly mentioned when we discussed
    creator SIDs: server security descriptors. The kernel supports two very poorly
    documented security descriptor control flags for servers: <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp>. We use
    these flags only when generating a new security descriptor, either at object creation
    time or when assigning a security descriptor explicitly. The main control flag,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>, indicates
    to the security descriptor generation code that the caller is expecting to impersonate
    another user.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: When a new security descriptor is created during impersonation, the owner and
    group SIDs will default to the values from the impersonation token. This might
    not be desirable, as being the owner of a resource can grant a caller additional
    access to it. However, the caller can’t set the owner to an arbitrary SID, because
    the SID must be able to pass the owner check, which is based on the impersonation
    token.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: This is where the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    control flag comes in. If you set the flag on the creator security descriptor
    when creating a new security descriptor, the owner and group SIDs default to the
    primary token of the caller, and not to the impersonation token. This flag also
    replaces all <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs
    in the DACL with <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedCompound</samp>
    ACEs, the structure of which we defined back in [Chapter 5](chapter5.xhtml). In
    the compound ACE, the server SID is set to the owner SID from the primary token.
    [Listing 6-41](chapter6.xhtml#Lis6-41) shows an example.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 6-41: Testing the ServerSecurity security descriptor control flag'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: We first create a new security descriptor using the anonymous user token ❶.
    This initial test doesn’t set the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    flag. As expected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> default to values
    based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> user
    token, and the single ACE we added remains intact ❷. Next, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    control flag to the creator security descriptor ❸. After calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    again, we now find that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> are set to the
    defaults for the primary token, not to those of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp>
    user token ❹. Also, the single ACE has been replaced with a compound ACE, whose
    server SID is set to the primary token’s owner SID ❺. We’ll discuss how changes
    to compound ACEs impact access checking in [Chapter 7](chapter7.xhtml).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp> control
    flag works in combination with <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>.
    By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    assumes that any compound ACE in the DACL is trusted and will copy it verbatim
    into the output. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp>
    control flag is set, all compound ACEs instead have their server SID values set
    to the primary token’s owner SID.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> control
    flag is set on the creator security descriptor and the new security descriptor
    inherits ACEs from a parent, we can convert the *CREATOR OWNER SERVER* and *CREATOR
    GROUP SERVER* SIDs to their respective primary token values. Also, any inherited
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs will be converted
    to compound ACEs, except for those of the default DACL.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Summary of Inheritance Behavior</samp>
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance is a very important topic to understand. [Table 6-8](chapter6.xhtml#tab6-8)
    summarizes the ACL inheritance rules we’ve discussed in this chapter, to help
    you make sense of them.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-8:</samp> <samp class="SANS_Futura_Std_Book_11">Summary
    of Inheritance Rules for the DACL</samp>
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parent ACL</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Creator
    ACL</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit set</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit not set</samp> |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_Futura_Std_Book_11">Default</samp> | <samp class="SANS_Futura_Std_Book_11">Default</samp>
    |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Book_11">Present</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_Futura_Std_Book_11">Default</samp> | <samp class="SANS_Futura_Std_Book_11">Default</samp>
    |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_Futura_Std_Book_11">Parent</samp> | <samp class="SANS_Futura_Std_Book_11">Parent</samp>
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Present</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Present</samp>
    | <samp class="SANS_Futura_Std_Book_11">Parent and creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Protected</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Protected</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Defaulted</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Defaulted</samp>
    | <samp class="SANS_Futura_Std_Book_11">Parent</samp> | <samp class="SANS_Futura_Std_Book_11">Parent</samp>
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: 'The first two columns in this table describe the state of the parent ACL and
    the creator ACL; the last two describe the resulting ACL, depending on whether
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> and/or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flag was
    set. There are six ACL types to consider:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '**None    **The ACL isn’t present in the security descriptor.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Present    **The ACL is present in the security descriptor (even if it is
    a NULL or empty ACL).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-inheritable    **The ACL has no inheritable ACEs.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritable    **The ACL has one or more inheritable ACEs.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected    **The security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> control
    flag set.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '**Defaulted    **The security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclDefaulted</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclDefaulted</samp> control
    flag set.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there are four possible resulting ACLs:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '**Default    **The default DACL from the token, or nothing in the case of a
    SACL'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '**Creator    **All ACEs from the creator ACL'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent    **The inheritable ACEs from the parent ACL'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent and creator    **The inheritable ACEs from the parent and explicit
    ACEs from the creator'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: When an auto-inherit flag is set, the new security descriptor will have the
    corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherited</samp> control
    flag set. Also, all ACEs that were inherited from the parent ACL will have the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> ACE flag set. Note
    that this table doesn’t consider the behavioral changes due to object ACEs, mandatory
    labels, server security, and creator SIDs, which add more complexity.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some worked examples that use the commands you’ve learned
    about in this chapter.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Object Manager
    Resource Owners</samp>
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter, the owner of a resource’s security descriptor
    is usually the user who created the resource. For administrators, however, it’s
    typically the built-in *Administrators* group. The only way to set a different
    owner SID is to use another token group SID that has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag set, or to enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>.
    Neither option is available to non-administrator users.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Thus, knowing the owner of a resource can indicate whether a more privileged
    user created and used the resource. This could help you identify potential misuses
    of the Win32 security APIs in privileged applications, or find shared resources
    that a lower-privileged user might write to; a privileged user could mishandle
    these, causing a security issue.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-42](chapter6.xhtml#Lis6-42) shows a simple example: finding object
    manager resources whose owner SID differs from the caller’s.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 6-42: Finding objects in <samp class="SANS_Futura_Std_Book_11">BaseNamedObjects</samp>
    that are owned by a different user'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: We first define a function to query the name and owner of an object manager
    directory entry ❶. The function initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">$curr_owner</samp>
    variable with the owner SID of the caller’s token ❷. We’ll compare this SID with
    the owner of a resource to return only resources owned by a different user.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: For each directory entry, we query its security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    command ❸. We can specify a path and a root <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object to the command to avoid having to manually open the resource. If we successfully
    query the security descriptor, and if the owner SID does not match the current
    user’s owner SID, we return the resource’s name, object type, and owner SID.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: To test the new function, we open a directory (in this case, the global *BaseNamedObjects*
    directory ❹) and use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectoryEntry</samp>
    to query for all entries, piping them through the function we defined. We receive
    a list of resources not owned by the current user.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: For example, the output includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">WAMACAPO;8_Mem</samp>
    object, which is a shared memory <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object. If a normal user can write to this <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object, we should investigate it further, as it might be possible to trick a privileged
    application into performing an operation that would elevate a normal user’s privileges.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: We can test our ability to get write access on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    property of the object, as shown in [Listing 6-43](chapter6.xhtml#Lis6-43).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 6-43: Getting the granted access for a Section object'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">$entry</samp> variable contains
    the object we want to inspect. We pass its security descriptor to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command to return the maximum granted access for that resource. In this case,
    we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    is present, which indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object could be mapped as writable.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: The example I’ve shown in [Listing 6-42](chapter6.xhtml#Lis6-42) should provide
    you with an understanding of how to query for any resource. You can replace the
    directory with a file or registry key, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    with the path and the root object to query the owner for each of these resource
    types.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'For the object manager and registry, however, there is a much simpler way of
    finding the owner SID. For the registry, we can look up the security descriptor
    for the entries returned from the *NtObject* drive provider using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    property. For example, we can select the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> SID fields for
    the root registry key using the following script:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can also specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp>
    parameter to perform the check recursively.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to query the owner SIDs of files, you can’t use this technique,
    as the file provider does not return the security provider in its entries. Instead,
    you need to use the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp>
    command. Here, for example, we query a file’s ACL:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command returns
    the owner as a username, not a SID. You’ll have to look up the SID manually using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> command and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> parameter if you
    need it. Alternatively, you can convert the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp>
    command to a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module, as shown in [Listing 6-44](chapter6.xhtml#Lis6-44).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 6-44: Converting Get-Acl output to a SecurityDescriptor object'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertTo-NtSecurityDescriptor</samp>
    PowerShell command to perform the conversion.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Changing the Ownership
    of a Resource</samp>
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Administrators commonly take ownership of resources. This allows them to easily
    modify a resource’s security descriptor and gain full access to it. Windows comes
    with several tools for doing this, such as *takeown.exe*, which sets the owner
    of a file to the current user. However, you’ll find it instructive to go through
    the process of changing the owner manually, so you can understand exactly how
    it works. Run the commands in [Listing 6-45](chapter6.xhtml#Lis6-45) as an administrator.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 6-45: Setting an arbitrary owner for a Directory object'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object on which to perform the operations. (We’ll avoid modifying an existing
    resource, which might risk breaking your system.) We then query the resource’s
    current owner SID. In this case, because we’re running this script as an administrator,
    it’s set to the *Administrators* group.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Next, we enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
    privilege. We need to do this only if we want to set an arbitrary owner SID. If
    we want to set a permitted SID, we can skip this line. We then open the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> again, but only for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a security descriptor with just the owner SID set to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">World</samp> SID. To do this, we call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp>
    PowerShell command, specifying only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag. If you haven’t enabled <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>,
    this operation will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_OWNER</samp>
    status code. To confirm that we’ve changed the owner SID, we query it again, which
    confirms that it’s now set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Everyone</samp>
    (the name of the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> SID).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply this same set of operations to any resource type, including registry
    keys and files: simply change the command used to open the resource. Whether you’ll
    be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access
    depends on the specifics of the access check process. In [Chapter 7](chapter7.xhtml),
    you’ll learn about a few cases in which the access check automatically grants
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access based on
    certain criteria.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began with an overview of how to read the security descriptor of
    an existing kernel resource using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectSecurity</samp>
    command. We covered the security information flags that define what parts of the
    security descriptors the command should read and outlined the special rules for
    accessing audit information stored in the SACL.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed how we can assign security descriptors to resources, either
    during the resource creation process or by modifying an existing resource. In
    the process, you learned about ACL inheritance and auto-inheritance. We also discussed
    the behavior of the Win32 APIs, specifically <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>,
    and how that API implements auto-inheritance even though the kernel doesn’t explicitly
    implement it. We concluded with an overview of the poorly documented server security
    descriptor and compound ACEs. In the next chapter, we’ll (finally) discuss how
    Windows combines the token and security descriptor to check whether a user can
    access a resource.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
