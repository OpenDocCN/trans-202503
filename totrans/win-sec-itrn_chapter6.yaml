- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">READING
    AND ASSIGNING SECURITY DESCRIPTORS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we discussed the various structures that make up a
    security descriptor. You also learned how to manipulate security descriptors in
    PowerShell and how to represent them using the SDDL format. In this chapter, we’ll
    discuss how to read security descriptors from kernel objects, as well as the more
    complex process of assigning security descriptors to these objects.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll focus our discussion on the security descriptors assigned to kernel objects.
    However, as mentioned in “Absolute and Relative Security Descriptors” on page
    149, it’s also possible to store a security descriptor in persistent storage,
    such as in a file or as a registry key value. In this case, the security descriptor
    must be stored in the relative format and read as a stream of bytes before we
    can convert it into a format we can inspect.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading Security Descriptors</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To access a kernel object’s security descriptor, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    system call. This system call accepts a handle to the kernel object, as well as
    a set of flags that describe the components of the security descriptor you want
    to access. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    enumeration represents these flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-1](chapter6.xhtml#tab6-1) shows the list of available flags in the
    latest versions of Windows, as well as the location of the information in the
    security descriptor and the handle access required to query it.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">The</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> <samp
    class="SANS_Futura_Std_Book_11">Flags and Their Required Access</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Location</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Handle
    access required</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the owner SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Owner</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the group SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Group</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the DACL.</samp> | <samp class="SANS_Futura_Std_Book_11">DACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sacl</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the SACL (auditing ACEs only).</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the mandatory label.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the system resource attribute.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    the scoped policy ID.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTrustLabel</samp> |
    <samp class="SANS_Futura_Std_Book_11">Query the process trust label.</samp> |
    <samp class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessFilter</samp> | <samp
    class="SANS_Futura_Std_Book_11">Query the access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup</samp> | <samp class="SANS_Futura_Std_Book_11">Query
    everything except the process trust label and access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">All</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> <samp class="SANS_Futura_Std_Book_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  prefs: []
  type: TYPE_TB
- en: You only need <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access to read most of this information, except for the auditing ACEs from the
    SACL, which require <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access. (<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access
    is sufficient for other ACEs stored in the SACL.)
  prefs: []
  type: TYPE_NORMAL
- en: The only way to get <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access is to first enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    privilege, then explicitly request the access when opening a kernel object. [Listing
    6-1](chapter6.xhtml#Lis6-1) shows this behavior. You must run these commands as
    an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: Requesting AccessSystemSecurity access and enabling SeSecurityPrivilege'
  prefs: []
  type: TYPE_NORMAL
- en: Our first attempt to open the BNO directory with <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access fails, because we don’t have the required <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    privilege. Next, we enable that privilege and try again. This time we are able
    to open the directory, and printing its <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp>
    parameter confirms we’ve been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not entirely clear why the designers of Windows made the decision to guard
    the reading of audit information with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>.
    While we should consider modifying and removing audit information to be privileged
    actions, there is no obvious reason that reading that information should be. Unfortunately,
    we’re stuck with this design.
  prefs: []
  type: TYPE_NORMAL
- en: You can query an object’s security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    PowerShell command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>.
    The system call returns the security descriptor in the relative format as a byte
    array, which the PowerShell command parses into a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object and returns to the caller. The command accepts either an object or a path
    to the resource you want to query, as shown in [Listing 6-2](chapter6.xhtml#Lis6-2),
    which displays the security descriptor for the BNO directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Querying the security descriptor for the BNO directory'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we open the BNO directory with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access, then use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    to query the security descriptor from the open <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    command queries for the owner, group, DACL, mandatory label, and process trust
    label. If you want to query any other field (or omit some of the returned information),
    you need to specify this through the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    parameter, which accepts the values in [Table 6-1](chapter6.xhtml#tab6-1). For
    example, [Listing 6-3](chapter6.xhtml#Lis6-3) uses a path instead of an object
    and requests only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: Querying the owner of the BNO directory'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, you can see that only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    column contains valid information; all other columns now have the value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NONE</samp>, which indicates that no value
    is present, because we haven’t requested that information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assigning Security Descriptors</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reading a security descriptor is easy; you just need the correct access to
    a kernel resource and the ability to parse the relative security descriptor format
    returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    system call. Assigning a security descriptor is a more complex operation. The
    security descriptor assigned to a resource depends on multiple factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the resource being created?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did the creator specify a security descriptor during creation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the new resource stored in a container, such as a directory or registry key?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the new resource a container or an object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What control flags are set on the parent or current security descriptor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What user is assigning the security descriptor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What ACEs does the existing security descriptor contain?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kernel object type is being assigned?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the list, this process involves many variables and is one
    of the big reasons Windows security can be so complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign a resource’s security at creation time or via an open handle.
    Let’s start with the more complex case first: assignment at creation time.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Security
    Descriptor During Resource Creation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When creating a new resource, the kernel needs to assign it a security descriptor.
    Also, it must store the security descriptor differently depending on the kind
    of resource being created. For example, object manager resources are ephemeral,
    so the kernel will store their security descriptors in memory. In contrast, a
    filesystem driver’s security descriptor must be persisted to disk; otherwise,
    it will disappear when you reboot your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the mechanism to store the security descriptor might differ, the kernel
    must still follow many common procedures when handling it, such as enforcing the
    rules of inheritance. To provide a consistent implementation, the kernel exports
    a couple of APIs that calculate the security descriptor to assign to a new resource.
    The most used of these APIs is <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>,
    which takes the following seven parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creator security descriptor    **An optional security descriptor on which
    to base the new assigned security descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent security descriptor    **An optional security descriptor for the new
    resource’s parent object'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object type    **An optional GUID that represents the type of object being
    created'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container    **A Boolean value indicating whether the new resource is a container'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto-inherit    **A set of bit flags that define the automatic inheritance
    behavior'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token    **A handle to the token to use as the creator’s identity'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic mapping    **A mapping from generic access to specific access rights
    for the kernel type'
  prefs: []
  type: TYPE_NORMAL
- en: Based on these parameters, the API calculates a new security descriptor and
    returns it to the caller. By investigating how these parameters interact, we can
    understand how the kernel assigns security descriptors to new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider this assignment process for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object. (This object will be deleted once the PowerShell instance closes, ensuring
    that we don’t accidentally leave unnecessary files or registry keys lying around.)
    [Table 6-2](chapter6.xhtml#tab6-2) provides an example of how we might set the
    parameters when creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object with <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp> <samp class="SANS_Futura_Std_Book_11">Example
    Parameters for a New</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    <samp class="SANS_Futura_Std_Book_11">Object</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Setting
    value</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Creator security descriptor</samp>
    | <samp class="SANS_Futura_Std_Book_11">The value of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    <samp class="SANS_Futura_Std_Book_11">field in the object attributes structure.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Parent security descriptor</samp> |
    <samp class="SANS_Futura_Std_Book_11">The security descriptor of the parent</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp><samp class="SANS_Futura_Std_Book_11">;
    not set for an unnamed</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Object type</samp> | <samp class="SANS_Futura_Std_Book_11">Not
    set.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Container</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp><samp class="SANS_Futura_Std_Book_11">,
    as a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> <samp
    class="SANS_Futura_Std_Book_11">isn’t a container.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Auto-inherit</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritDacl</samp>
    <samp class="SANS_Futura_Std_Book_11">if the parent security descriptor’s control
    flags include the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    <samp class="SANS_Futura_Std_Book_11">flag and the creator DACL is missing or
    there is no creator</samp> <samp class="SANS_Futura_Std_Book_11">security descriptor;
    set to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritSacl</samp>
    <samp class="SANS_Futura_Std_Book_11">if the</samp> <samp class="SANS_Futura_Std_Book_11">parent
    security descriptor’s control flags include the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherited</samp>
    <samp class="SANS_Futura_Std_Book_11">flag and the creator SACL is missing or
    there is no creator security descriptor.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Token</samp> | <samp class="SANS_Futura_Std_Book_11">If
    the caller is impersonating, set to an impersonation token; otherwise, set to
    the primary token of the caller’s process.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Generic mapping</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    to the generic mapping for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    <samp class="SANS_Futura_Std_Book_11">type.</samp> |'
  prefs: []
  type: TYPE_TB
- en: You might be wondering why the object type isn’t set in [Table 6-2](chapter6.xhtml#tab6-2).
    The API supports the parameter, but neither the object manager nor the I/O manager
    uses it. Its primary purpose is to let Active Directory control inheritance, so
    we’ll discuss it separately in “Determining Object Inheritance” on page 203.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-2](chapter6.xhtml#tab6-2) shows only two possible auto-inherit flags,
    but we can pass many others to the API. [Table 6-3](chapter6.xhtml#tab6-3) lists
    the available auto-inherit flags, some of which we’ll encounter in this chapter’s
    examples.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Auto-inherit Flags</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the DACL.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the SACL.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultDescriptorForObject</samp>
    | <samp class="SANS_Futura_Std_Book_11">Use the default security descriptor for
    the new security descriptor.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp>
    | <samp class="SANS_Futura_Std_Book_11">Don’t check for privileges when setting
    the mandatory label or SACL.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</samp> | <samp
    class="SANS_Futura_Std_Book_11">Avoid checking whether the owner is valid for
    the current token.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultOwnerFromParent</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copy the owner SID from the parent security
    descriptor.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultGroupFromParent</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copy the group SID from the parent security
    descriptor.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoExecuteUp</samp> | <samp
    class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerRestriction</samp>
    | <samp class="SANS_Futura_Std_Book_11">Ignore restrictions placed on the new
    DACL by the parent security descriptor.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceUserMode</samp> | <samp
    class="SANS_Futura_Std_Book_11">Enforce all checks as if called from user mode
    (only applicable for kernel callers).</samp> |'
  prefs: []
  type: TYPE_TB
- en: The most important <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    parameters to consider are the values assigned to the parent and creator security
    descriptors. Let’s go through a few configurations of these two security descriptor
    parameters to understand the different outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Only the Creator Security
    Descriptor</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the first configuration we’ll consider, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    with the object attribute’s <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field set to a valid security descriptor. If the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object is not given a name, it will be created without a parent directory, and
    the corresponding parent security descriptor won’t be set. If there is no parent
    security descriptor, the auto-inherit flags won’t be set, either.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test this behavior to see the security descriptor generated when we create
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object. Rather
    than creating the object itself, we’ll use the user-mode implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>, which *NTDLL*
    exports as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>.
    We can access <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    PowerShell command, as shown in [Listing 6-4](chapter6.xhtml#Lis6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: Creating a new security descriptor from a creator security descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: We first build a creator security descriptor with only a single ACE, granting
    the *Everyone* group <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    access ❶. By formatting the security descriptor ❷, we can confirm that only the
    DACL is present in the formatted output. Next, using the creator security descriptor,
    we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    command ❸, passing the current effective token and specifying the final object
    type as <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>. This object
    type determines the generic mapping. Finally, we format the new security descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that the security descriptor has changed during the creation
    process: it has gained <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    ❹ and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> values ❺, and
    the specified access mask has changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp>
    ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by considering where those new owner and group values come from.
    When we don’t specify an <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> value, the creation
    process copies these from the supplied token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PrimaryGroup</samp> SIDs. We
    can confirm this by checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s properties using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp>
    PowerShell command, as shown in [Listing 6-5](chapter6.xhtml#Lis6-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: Displaying the Owner and PrimaryGroup SIDs for the current effective
    token'
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the output in [Listing 6-5](chapter6.xhtml#Lis6-5) with the security
    descriptor values in [Listing 6-4](chapter6.xhtml#Lis6-4), you can see that the
    owner and group SIDs match.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 4](chapter4.xhtml), you learned that it’s not possible to set an
    arbitrary owner SID on a token; this value must be either the user’s SID or a
    SID marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag. You might wonder: As the token’s SID is being used to set the security descriptor’s
    default owner, can we use this behavior to specify an arbitrary owner SID in the
    security descriptor? Let’s check. In [Listing 6-6](chapter6.xhtml#Lis6-6), we
    first set the security descriptor to the *SYSTEM* user’s SID, then try to create
    the security descriptor again.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: Setting the <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp>
    user as the Mutant object’s security descriptor owner'
  prefs: []
  type: TYPE_NORMAL
- en: This time, the creation fails with an exception and the status code <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_OWNER</samp>.
    This is because the API checks whether the owner SID being assigned is valid for
    the supplied token. It doesn’t have to be the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s owner SID, but it must be either the user’s SID or a group SID with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> flag set.
  prefs: []
  type: TYPE_NORMAL
- en: You can set an arbitrary owner SID only when the token used to create the security
    descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
    privilege enabled. Note that this token doesn’t necessarily have to belong to
    the caller of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    API. You can also disable the owner check by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</samp>
    auto-inherit flag; however, the kernel will never specify this flag when creating
    a new object, so it will always enforce the owner check.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that there’s no way to set a different owner as a normal
    user. However, any method of setting an arbitrary owner that you discover is a
    security vulnerability that Microsoft will likely fix. An example of such a bug
    is CVE-2018-0748, which allowed users to set an arbitrary owner when creating
    a file. The user had to create the file via a local filesystem share, causing
    the owner check to be bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: There are no restrictions on the value of the group SID, as the group doesn’t
    contribute to the access check. However, restrictions apply to the SACL. If you
    specify any audit ACEs in the SACL as part of the creator security descriptor,
    the kernel will require <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that when we created the security descriptor, the access mask changed?
    This is because the security descriptor assignment process maps all generic access
    rights in the access mask to type-specific access rights using the object type’s
    generic mapping information. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> mapping
    converts the access mask to <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp>.
    There is one exception to this rule: if the ACE has the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag set, then generic access rights won’t be mapped. You’ll understand why the
    exception exists shortly, when we discuss inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm this mapping behavior by using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    to create an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, as shown in [Listing 6-7](chapter6.xhtml#Lis6-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: Verifying security descriptor assignment rules by creating a Mutant
    object'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output security descriptor is the same as the one created
    in [Listing 6-4](chapter6.xhtml#Lis6-4).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Neither the Creator
    nor the Parent Security Descriptor</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s explore another simple case. In this scenario, neither the creator nor
    the parent security descriptor is set. This case corresponds to calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> without a name or
    a specified <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field. The script to test it is even simpler than the previous one, as shown in
    [Listing 6-8](chapter6.xhtml#Lis6-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: Creating a new security descriptor with no creator or parent security
    descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: This call to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    requires only the token and kernel object type ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields in the final
    security descriptor are set to default values based on the token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PrimaryGroup</samp> properties
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: But where did the DACL ❸ come from? We haven’t specified either a parent or
    a creator security descriptor, so it couldn’t have come from either of those.
    Instead, it’s based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s *default DACL*, an ACL stored in the token that acts as a fallback when
    there is no other DACL specified. You can display a token’s default DACL by passing
    the token to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultDacl</samp> parameter,
    as in [Listing 6-9](chapter6.xhtml#Lis6-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-9: Displaying a token’s default DACL'
  prefs: []
  type: TYPE_NORMAL
- en: Other than its <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>-specific
    access rights, the DACL in [Listing 6-9](chapter6.xhtml#Lis6-9) matches the one
    in [Listing 6-8](chapter6.xhtml#Lis6-8). We can conclude that, if we specify neither
    the parent nor the creator security descriptor during creation, we’ll create a
    new security descriptor based on the token’s owner, primary group, and default
    DACL. However, just to be certain, let’s verify this behavior by creating an unnamed
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> with no security descriptor
    ([Listing 6-10](chapter6.xhtml#Lis6-10)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-10: Creating an unnamed Mutant to verify the default security descriptor
    creation behavior'
  prefs: []
  type: TYPE_NORMAL
- en: Wait—the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object
    has no security information at all! That’s not what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: The issue here is that the kernel allows certain object types to have no security
    when the object doesn’t have a name. You can learn whether an object requires
    security by querying its <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityRequired</samp>
    property, as shown in [Listing 6-11](chapter6.xhtml#Lis6-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-11: Querying for the Mutant type’s SecurityRequired property'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    type doesn’t require security. So, if we specify neither the creator nor the parent
    security descriptor when creating an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, the kernel won’t generate a default security descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Why would the kernel support the ability to create an object without a security
    descriptor? Well, if applications won’t share that object with each other, the
    security descriptor would serve no purpose; it would only use up additional kernel
    memory. Only if you created an object with a name, so that it can be shared, would
    the kernel require security.
  prefs: []
  type: TYPE_NORMAL
- en: To verify the generation of a default security descriptor, let’s now create
    an object that requires security, such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object ([Listing 6-12](chapter6.xhtml#Lis6-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-12: Creating an unnamed Directory to verify the default security
    descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-12](chapter6.xhtml#Lis6-12) shows that the default security descriptor
    matches our assumptions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Only the Parent Security
    Descriptor</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next case we’ll consider is much more complex. Say we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    with a name but without specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field. Because a named <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    must be created within a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object (which, as we’ve just seen, requires security), the parent security descriptor
    will be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet when we specify a parent security descriptor, we also bring something else
    into play: *inheritance*, a process by which the new security descriptor copies
    a part of the parent security descriptor. Inheritance rules determine which parts
    of the parent get passed to the new security descriptor, and we call a parent
    security descriptor *inheritable* if its parts can be inherited.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of inheritance is to define a hierarchical security configuration
    for a tree of resources. Without inheritance, we would have to explicitly assign
    a security descriptor for each new object in the hierarchy, which would become
    unmanageable rather quickly. It would also make the resource tree impossible to
    manage, as each application might choose to behave differently.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test the inheritance rules that apply when we create new kernel resources.
    We’ll focus on the DACL, but these concepts apply to the SACL, as well. To minimize
    code duplication, [Listing 6-13](chapter6.xhtml#Lis6-13) defines a few functions
    that run a test with the parent security descriptor and implement various options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-13: Test function definitions for New-ParentSD and Test-NewSD'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ParentSD</samp> function
    creates a new security descriptor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields set to the
    *Administrators* group ❶. This will allow us to check for inheritance of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp>
    field in any new security descriptor we create from this parent. We also set the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>,
    as expected for the object manager. Next, we add two <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACEs, one for the *Everyone* group and one for the *Users* group ❷, differentiated
    by their SIDs. We assign both ACEs <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access and add some extra flags for the *Users* ACE.
  prefs: []
  type: TYPE_NORMAL
- en: The function then sets some optional security descriptor control flags ❸. Normally,
    when we assign a security descriptor to a parent the generic access rights get
    mapped to type-specific access rights. Here, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGeneric</samp> parameter
    to do this mapping for us ❹.
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp> function,
    we create the parent security descriptor ❺ and calculate any auto-inherit flags
    ❻. Then we create a new security descriptor, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp>
    property if required, as well as the auto-inherit flags we calculated ❼. You can
    specify a creator security descriptor for this function to use to create the new
    security descriptor. For now, we’ll leave this value as <samp class="SANS_TheSansMonoCd_W5Regular_11">$null</samp>,
    but we’ll come back to it in the next section. Finally, we print the parent, the
    creator (if specified), and the new security descriptors to the console to verify
    the input and output ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by testing the default case: running the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp>
    command with no additional parameters. The command will create a parent security
    descriptor with no control flags set, so there should be no auto-inherit flags
    present in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    ([Listing 6-14](chapter6.xhtml#Lis6-14)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-14: Creating a new security descriptor with a parent security descriptor
    and no creator security descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> do not derive from
    the parent security descriptor ❶; instead, they’re the defaults we observed earlier
    in this chapter. This makes sense: the caller, and not the user who created the
    parent object, should own the new resource.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the new DACL doesn’t look as we might have expected ❷. It’s set to
    the default DACL we saw earlier, and it bears no relation to the DACL we built
    in the parent security descriptor. The reason we didn’t get any ACEs from the
    parent’s DACL is that we did not specify the ACEs as inheritable. To do so, we
    need to set one or both of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> ACE
    flags. The former applies only to non-container objects such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    objects, while the latter applies to container objects such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects. The distinction between the two types is important, because they affect
    how the inherited ACEs propagate to child objects.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object is a
    non-container, so let’s add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    flag to the ACE in the parent security descriptor ([Listing 6-15](chapter6.xhtml#Lis6-15)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-15: Adding an ObjectInherit ACE to the parent security descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    ACE flag to the test function ❶. Observe that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields have not
    changed ❷, but the DACL is no longer the default ❸. Instead, it contains a single
    ACE that grants the *Users* group <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|Delete|ReadControl|WriteDac|WriteOwner</samp>
    access. This is the ACE that we set to be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you might notice a problem: the parent security descriptor’s ACE was
    granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>, while
    the new security descriptor’s ACE is not. Why has the access mask changed? In
    fact, it hasn’t; the inheritance process has merely taken the raw <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    access mask for the parent security descriptor’s ACE (the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000F000F</samp>)
    and copied it to the inherited ACE. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object’s valid access bits are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x001F0001</samp>.
    Therefore, the inheritance process uses the closest mapping, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000F0001</samp>,
    as shown in [Listing 6-16](chapter6.xhtml#Lis6-16).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-16: Checking the inherited access mask'
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty serious issue. Notice, for example, that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    type is missing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Synchronize</samp>
    access right, which it needs for a caller to wait on the lock. Without this access,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object would be
    useless to an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this access mask problem by specifying a generic access mask in
    the ACE. This will map to a type-specific access mask when the new security descriptor
    is created. There is only one complication: we’ve taken the parent security descriptor
    from an existing object, so the generic access was already mapped when the security
    descriptor was assigned. We simulated this behavior in our test function with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    call.'
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue, the ACE can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag. As a result, any generic access will remain untouched during the initial
    assignment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag marks the ACE for inheritance only, which prevents the generic access from
    being an issue for access checking. In [Listing 6-17](chapter6.xhtml#Lis6-17),
    we check this behavior by modifying the call to the test function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-17: Adding an InheritOnly ACE'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we change the ACE flags to <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ❶. In the
    parent security descriptor’s output, we can see that the access mask is no longer
    mapped from <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> ❷.
    As a result, the inherited ACE is now granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full
    Access</samp>, as we require ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Presumably, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp>
    flag works in the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>,
    right? Not quite. We test its behavior in [Listing 6-18](chapter6.xhtml#Lis6-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-18: Creating a new security descriptor with the ContainerInherit
    flag'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flags to
    the ACE and then pass the function the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp>
    parameter ❶. Unlike in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    case, we now end up with two ACEs in the DACL. The first ACE ❷ grants access to
    the new resource based on the inheritable ACE. The second ❸ is a copy of the inheritable
    ACE, with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You might wonder how we can create a security descriptor for a container type
    when we’re using the Mutant type. The answer is that the API doesn’t care about
    the final type, as it uses only the generic mapping; when creating a real Mutant
    object, however, the kernel would never specify the Container flag.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The ACE’s automatic propagation is useful, as it allows you to build a hierarchy
    of containers without needing to manually grant them access rights. However, you
    might sometimes want to disable this automatic propagation by specifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp> ACE flag, as
    shown in [Listing 6-19](chapter6.xhtml#Lis6-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-19: Using NoPropagateInherit to prevent the automatic inheritance
    of ACEs'
  prefs: []
  type: TYPE_NORMAL
- en: When we specify this flag, the ACE that grants access to the resource remains
    present, but the inheritable ACE disappears ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try another ACE flag configuration to see what happens to <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    ACEs when they’re inherited by a container ([Listing 6-20](chapter6.xhtml#Lis6-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-20: Testing the ObjectInherit flag on a container'
  prefs: []
  type: TYPE_NORMAL
- en: You might not expect the container to inherit the ACE at all, but in fact, it
    receives the ACE with the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag automatically set ❶. This allows the container to pass the ACE to non-container
    child objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-4](chapter6.xhtml#tab6-4) summarizes the inheritance rules for container
    and non-container objects based on the parent ACE flags. Objects are bolded where
    no inheritance occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-4:</samp> <samp class="SANS_Futura_Std_Book_11">Parent
    ACE Flags and Flags Set on the Inherited ACEs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parent ACE flags</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Non-container object</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Container
    object</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No
    inheritance</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> | <samp
    class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp>
    | <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No
    inheritance</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No
    inheritance</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp>
    | <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Finally, consider *auto-inherit flags*. If you return to [Table 6-3](chapter6.xhtml#tab6-3),
    you can see that if the DACL has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    control flag set, the kernel will pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>,
    as there is no creator security descriptor. (The SACL has a corresponding <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flag, but we’ll
    focus on the DACL here.) What does the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    flag do? In [Listing 6-21](chapter6.xhtml#Lis6-21), we perform a test to find
    out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-21: Setting the DaclAutoInherited control flag in the parent security
    descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: We set the parent security descriptor’s control flags to contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    flag ❶, and we confirm that it’s set by looking at the formatted DACL ❷. We can
    see that the new security descriptor contains the flag as well ❸; also, the inherited
    ACE has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: How do the auto-inherit flags differ from the inheritance flags we discussed
    earlier? Microsoft conserves both inheritance types for compatibility reasons
    (as it didn’t introduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag until Windows 2000). From the kernel’s perspective, the two types of inheritance
    are not very different other than determining whether the new security has the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> flag set
    and whether any inherited ACE gets the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag. But from a user-mode perspective, this inheritance model indicates which
    parts of the DACL were inherited from a parent security descriptor. That’s important
    information, and various Win32 APIs use it, as we’ll discuss in “Win32 Security
    APIs” on page 208.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Both the Creator and
    Parent Security Descriptors</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the final case, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    with a name and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field, setting both the creator and parent security descriptor parameters. To
    witness the resulting behavior, let’s define some test code. [Listing 6-22](chapter6.xhtml#Lis6-22)
    writes a function to generate a creator security descriptor. We’ll reuse the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp> function we wrote earlier
    to run the test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-22: The New-CreatorSD test function'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function differs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ParentSD</samp>
    function created in [Listing 6-13](chapter6.xhtml#Lis6-13) in the following ways:
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> type when
    creating the security descriptor ❶, we allow the caller to not specify a DACL
    ❷, and we set a different SID for the DACL if it is used ❸. These changes will
    allow us to distinguish the parts of a new security descriptor that come from
    the parent and those that come from the creator.'
  prefs: []
  type: TYPE_NORMAL
- en: In some simple cases, the parent security descriptor has no inheritable DACL,
    and the API follows the same rules it uses when only the creator security descriptor
    is set. In other words, if the creator specifies the DACL, the new security descriptor
    will use it. Otherwise, it will use the default DACL.
  prefs: []
  type: TYPE_NORMAL
- en: If the parent security descriptor contains an inheritable DACL, the new security
    descriptor will inherit it, unless the creator security descriptor also has a
    DACL. Even an empty or NULL DACL will override the inheritance from the parent.
    In [Listing 6-23](chapter6.xhtml#Lis6-23), we verify this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-23: Testing parent DACL inheritance with no creator DACL'
  prefs: []
  type: TYPE_NORMAL
- en: We first build a creator security descriptor with no DACL ❶, then run the test
    with an inheritable parent security descriptor ❷. In the output, we confirm the
    inheritable ACE for the *Users* group ❸ and that the creator has no DACL set ❹.
    When we create the new security descriptor, it receives the inheritable ACE ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also check what happens when we set a creator DACL ([Listing 6-24](chapter6.xhtml#Lis6-24)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-24: Testing the overriding of parent DACL inheritance by the creator
    DACL'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we build the creator security descriptor with a DACL ❶ and keep the same
    inheritable parent security descriptor as in [Listing 6-23](chapter6.xhtml#Lis6-23)
    ❷. In the output, we see that the ACEs from the creator’s DACL have been copied
    to the new security descriptor ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The previous two tests haven’t specified any auto-inherit flags. If we specify
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> control
    flag on the parent security descriptor but include no creator DACL, then the inheritance
    proceeds in the same way as in [Listing 6-24](chapter6.xhtml#Lis6-24), except
    that it sets the inherited ACE flags.
  prefs: []
  type: TYPE_NORMAL
- en: However, something interesting happens if we specify both a creator DACL and
    the control flag ([Listing 6-25](chapter6.xhtml#Lis6-25)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-25: Testing parent DACL inheritance when the creator DACL and the
    DaclAutoInherited control flag are set'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we build a creator security descriptor and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">INTERACTIVE</samp>
    SID ACE to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag ❶. Next, we run the test with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    control flag on the parent security descriptor ❷. In the output, notice that there
    are two ACEs. The first ACE was copied from the creator ❸, while the second is
    the inherited ACE from the parent ❹. [Figure 6-1](chapter6.xhtml#fig6-1) shows
    this auto-inheritance behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The auto-inheritance
    behavior when the parent and creator security descriptors are both set</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> is
    set, the new security descriptor’s DACL merges the non-inherited ACEs from the
    creator security descriptor with the inheritable ACEs from the parent. This auto-inheritance
    behavior allows you to rebuild a child’s security descriptor based on its parent
    without losing any ACEs that the user has explicitly added to the DACL. Additionally,
    the automatic setting of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    ACE flag lets us differentiate between these explicit and inherited ACEs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that normal operations in the kernel do not set the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    flag, which is enabled only if the parent security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    control flag set and the DACL isn’t present. In our test, we specified a DACL,
    so the auto-inherit flag was not set. The Win32 APIs use this behavior, as we’ll
    discuss later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to suppress the merging of the explicit ACEs and the parent’s inheritable
    ACEs, you can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    and/or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> security
    descriptor control flags. If a protected control flag is set, the inheritance
    rules leave the respective ACL alone, other than setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInherited</samp>
    control flag for the ACL and clearing any inherited ACE flags. In [Listing 6-26](chapter6.xhtml#Lis6-26),
    we test this behavior for the DACL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-26: Testing the DaclProtected control flag'
  prefs: []
  type: TYPE_NORMAL
- en: We start by generating a creator security descriptor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    flag, and setting one of the ACE’s flags to <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    ❶. We then create a new security descriptor with an auto-inherited parent ❷. Without
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> flag, the
    new security descriptor’s DACL would have been a merged version of the creator
    DACL and the inheritable ACEs from the parent. Instead, we see only the creator
    DACL’s ACEs. Also, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag on the second ACE has been cleared ❸.
  prefs: []
  type: TYPE_NORMAL
- en: What if we don’t know whether the parent security descriptor will have inheritable
    ACEs, and we don’t want to end up with the default DACL? This might be important
    for permanent objects, such as files or keys, as the default DACL contains the
    ephemeral logon SID, which shouldn’t really be persisted to disk. After all, reusing
    the logon SID could end up granting access to an unrelated user.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can’t set a DACL in the creator security descriptor; according
    to inheritance rules, this would overwrite any inherited ACEs. Instead, we can
    handle this scenario using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclDefaulted</samp>
    security descriptor control flag, which indicates that the provided DACL is a
    default. [Listing 6-27](chapter6.xhtml#Lis6-27) demonstrates its use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-27: Testing the DaclDefaulted flag'
  prefs: []
  type: TYPE_NORMAL
- en: If the parent does not contain any inheritable DACL ACEs, the new security descriptor
    will use the creator’s DACL instead of the default. If the parent does contain
    inheritable ACEs, the inheritance process will overwrite the DACL, following the
    rules outlined previously.
  prefs: []
  type: TYPE_NORMAL
- en: To implement similar behavior for the SACL, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclDefaulted</samp>
    control flag. However, tokens don’t contain a default SACL, so this flag is somewhat
    less important.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Replacing the CREATOR OWNER
    and CREATOR GROUP SIDs</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve seen that, during inheritance, an inherited ACE retains the same SID as
    the original. In some scenarios, this isn’t desirable. For example, you might
    have a shared directory that allows any user to create a child directory. What
    security descriptor could you set on this shared directory so that only the creator
    of the child directory has access to it?
  prefs: []
  type: TYPE_NORMAL
- en: One solution would be to remove all inheritable ACEs. As a result, the new directory
    would use the default DACL. This would almost certainly secure the directory to
    prevent other users from accessing it. However, as mentioned in the previous section,
    the default DACL is designed for ephemeral resources, such as those in the object
    manager; persistent security descriptors shouldn’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate features such as shared directories, the inheritance implementation
    supports four special creator SIDs. When a security descriptor inherits an ACE
    with any of these SIDs, the inheritance implementation will replace the creator
    SID with a specific SID from the creator’s token:'
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR OWNER*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-0)  </samp>Replaced
    by the token’s owner'
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR GROUP*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-1)  </samp>Replaced
    by the token’s primary group'
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR OWNER SERVER*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">S-1-3-2)  </samp>Replaced by the server’s
    owner'
  prefs: []
  type: TYPE_NORMAL
- en: '***CREATOR GROUP SERVER*** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-3)  </samp>Replaced
    by the server’s primary group'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the server SIDs only when creating a server security descriptor, which
    we’ll discuss in “Server Security Descriptors and Compound ACEs” on page 213.
    The conversion from the creator SID to a specific SID is a one-way process: once
    the SID has been replaced, you can’t tell it apart from a SID you set explicitly.
    However, if a container has inherited the ACE, it will keep the creator SID in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACE. [Listing
    6-28](chapter6.xhtml#Lis6-28) provides an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-28: Testing creator SIDs during inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: We first add two ACEs with the *CREATOR OWNER* and *CREATOR GROUP* SIDs to a
    parent security descriptor, giving the ACEs different levels of access to make
    them easy to distinguish ❶. We then create a new security descriptor based on
    the parent, specifying that we’ll use it for a container ❷. In the formatted output,
    we see that the user’s SID has replaced the *CREATOR OWNER* SID. This SID is based
    on the owner SID in the token ❸. We also can see that the *CREATOR GROUP* SID
    has been replaced with the group SID from the token ❹.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve created the security descriptor for a container, we also see that there
    are two <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACEs
    whose creator SID has not been changed. This behavior allows the creator SID to
    propagate to any future children.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Assigning Mandatory Labels</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The mandatory label ACE contains the integrity level of a resource. But when
    we create a new security descriptor using a token whose integrity level is greater
    than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>,
    the new security descriptor won’t receive a mandatory label by default. This behavior
    explains why we haven’t seen any mandatory label ACEs in our tests so far.
  prefs: []
  type: TYPE_NORMAL
- en: If the token’s integrity level is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>,
    on the other hand, this label is automatically assigned to the new security descriptor,
    as shown in [Listing 6-29](chapter6.xhtml#Lis6-29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-29: Assigning the mandatory label of the creator’s token'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we duplicate the current token and assign it a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level. When we create a new security descriptor based on the token,
    we see that it has a mandatory label with the same integrity level.
  prefs: []
  type: TYPE_NORMAL
- en: An application can set a mandatory label ACE explicitly when creating a new
    resource through the creator security descriptor. However, the integrity level
    in the mandatory label ACE must be less than or equal to the token’s integrity
    level; otherwise, the creation will fail, as shown in [Listing 6-30](chapter6.xhtml#Lis6-30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-30: Assigning a mandatory label based on the creator security descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new creator security descriptor and add a mandatory label
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> integrity
    level to it. We then get the caller’s token and set its integrity level to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    integrity level is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>,
    if we attempt to use the creator security descriptor to create a new security
    descriptor, the operation fails with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp>
    error ❶.
  prefs: []
  type: TYPE_NORMAL
- en: To set a higher integrity level, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    privilege must be enabled on the creator token, or you must specify the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp> auto-inherit
    flag. In this example, we set the auto-inherit flag when creating the new security
    descriptor ❷. With this addition the creation succeeds, and we can see the mandatory
    label in the formatted output ❸.
  prefs: []
  type: TYPE_NORMAL
- en: We can make the mandatory label ACE inheritable by setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> flag.
    It’s also possible to specify its <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>
    flag, which prevents the integrity level from being used as part of an access
    check, reserving it for inheritance only.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, though, that integrity-level restrictions apply to inherited mandatory
    label ACEs too. The inherited ACE must have an integrity level that is less than
    or equal to the token’s; otherwise, the security descriptor assignment will fail.
    Again, we can bypass this restriction with either the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    privilege or the <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp>
    auto-inherit flag. [Listing 6-31](chapter6.xhtml#Lis6-31) shows an example in
    which a security descriptor inherits the mandatory label ACE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-31: Assigning a mandatory label from a parent security descriptor
    through inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a parent security descriptor and assign it a mandatory label
    ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity
    level and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    flag set ❶. We then create a new security descriptor using the parent. The new
    security descriptor inherits the mandatory label, as indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Certain kernel object types might receive the mandatory label automatically,
    even if the caller’s token has an integrity level greater than or equal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>. By specifying certain auto-inherit
    flags, you can always assign the caller’s integrity level when creating a new
    security descriptor for the resource. These flags include <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoExecuteUp</samp>,
    which auto-inherit the token’s integrity level and set the mandatory policy to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp>, respectively.
    By combining these flags, you can get the desired mandatory policy.
  prefs: []
  type: TYPE_NORMAL
- en: In the latest versions of Windows, only four types are registered to use these
    auto-inherit flags, as shown in [Table 6-5](chapter6.xhtml#tab6-5).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-5:</samp> <samp class="SANS_Futura_Std_Book_11">Types
    with Integrity Level Auto-inherit Flags Enabled</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Type name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit
    flags</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Job</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We can test the behavior of these auto-inherit flags by specifying them when
    we create a security descriptor. In [Listing 6-32](chapter6.xhtml#Lis6-32), we
    specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp> auto-inherit
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-32: Assigning a mandatory label by specifying auto-inherit flags'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see a mandatory label ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    integrity level, even though I mentioned at the start of this section that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> level wouldn’t normally
    be assigned. We can also see that the mandatory policy has been set to <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp|NoReadUp</samp>,
    which matches the auto-inherit flags we specified.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Determining Object Inheritance</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When we specify an object ACE type, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp>,
    in a parent security descriptor, the inheritance rules change slightly. This is
    because each object ACE can contain two optional GUIDs: <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>,
    used for access checking, and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>,
    used for inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>
    API uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    GUID in an ACE to calculate whether a new security descriptor should inherit that
    ACE. If this GUID exists and its value matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID, the new security descriptor will inherit the ACE. By contrast, if the values
    don’t match, the ACE won’t be copied. [Table 6-6](chapter6.xhtml#tab6-6) shows
    the possible combinations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    parameter and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    and whether the ACE is inherited.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-6:</samp> <samp class="SANS_Futura_Std_Book_11">Whether
    to Inherit the ACE Based on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> <samp class="SANS_Futura_Std_Heavy_B_11">parameter
    specified?</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">in ACE?</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Inherited</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">No</samp> | <samp class="SANS_Futura_Std_Book_11">No</samp>
    | <samp class="SANS_Futura_Std_Book_11">Yes</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">No</samp> | <samp class="SANS_Futura_Std_Book_11">Yes</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">No</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Yes</samp> | <samp class="SANS_Futura_Std_Book_11">No</samp>
    | <samp class="SANS_Futura_Std_Book_11">Yes</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Yes</samp> | <samp class="SANS_Futura_Std_Book_11">Yes
    (and the values match)</samp> | <samp class="SANS_Futura_Std_Book_11">Yes</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Yes</samp> | <samp class="SANS_Futura_Std_Book_11">Yes
    (and the values don’t match)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">No</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'I’ve bolded the cases in [Table 6-6](chapter6.xhtml#tab6-6) where inheritance
    doesn’t happen. Note that this doesn’t supersede any other inheritance decision:
    the ACE must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>
    and/or <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> flag
    set to be considered for inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-33](chapter6.xhtml#Lis6-33), we verify this behavior by adding
    some object ACEs to a security descriptor and using it as the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-33: Verifying the behavior of the InheritedObjectType GUID'
  prefs: []
  type: TYPE_NORMAL
- en: We first generate a couple of random GUIDs to act as our object types ❶. Next,
    we add three inheritable <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp>
    ACEs to the parent security descriptor. In the first ACE, we set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    to the first GUID we created ❷. This ACE demonstrates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID is not considered when inheriting the ACE. The second ACE sets the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> to the first
    GUID ❸. The final ACE uses the second GUID ❹.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new security descriptor, passing the second GUID to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> parameter ❺. When we
    check the new security descriptor, we can see that it inherited the ACE without
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> ❻.
    The second ACE in the output is a copy of the ACE with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    GUID that matches ❼. Notice that, based on the output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    has been removed, as the ACE is no longer inheritable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a single <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID parameter is somewhat inflexible, so Windows also provides two APIs that
    take a list of GUIDs rather than a single GUID: the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx2</samp>
    kernel API and the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectWithMultipleInheritance</samp>
    user-mode API. Any ACE in the list with the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    will be inherited; otherwise, the inheritance rules are basically the same as
    those covered here.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on assigning security descriptors during creation.
    As you’ve seen, the assignment process is complex, especially with regard to inheritance.
    We’ll now discuss assigning a security descriptor to an existing resource, a considerably
    simpler process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Security
    Descriptor to an Existing Resource</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a resource already exists, it’s not possible to set the security descriptor
    by calling a creation system call such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    and specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    field in the object attributes. Instead, you need to open a handle to the resource
    with one of three access rights, depending on what part of the security descriptor
    you want to modify. Once you have this handle, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>
    system call to set specific security descriptor information. [Table 6-7](chapter6.xhtml#tab6-7)
    shows the access rights needed to set each security descriptor field based on
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-7:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    <samp class="SANS_Futura_Std_Book_11">Flags and Required Access for Security Descriptor
    Creation</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Location</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Handle
    access required</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the owner SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Owner</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the group SID.</samp> | <samp class="SANS_Futura_Std_Book_11">Group</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the DACL.</samp> | <samp class="SANS_Futura_Std_Book_11">DACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sacl</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the SACL (for auditing ACEs only).</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    the mandatory label.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a system resource attribute.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a scoped policy ID.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTrustLabel</samp> |
    <samp class="SANS_Futura_Std_Book_11">Set the process trust label.</samp> | <samp
    class="SANS_Futura_Std_Book_11">SACL</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessFilter</samp> | <samp
    class="SANS_Futura_Std_Book_11">Set an access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">SACL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    everything except the process trust label and access filter.</samp> | <samp class="SANS_Futura_Std_Book_11">All</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp><samp class="SANS_Futura_Std_Book_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp><samp class="SANS_Futura_Std_Book_11">,
    and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: You might notice that the handle access required for setting this information
    is more complex than the access needed to merely query it (covered in [Table 6-1](chapter6.xhtml#tab6-1)),
    as it is split across three access rights instead of two. Rather than trying to
    memorize these access rights, you can retrieve them using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp>
    PowerShell command, specifying the parts of the security descriptor you want to
    set with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    parameter, as shown in [Listing 6-34](chapter6.xhtml#Lis6-34).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-34: Discovering the access mask needed to query or set specific security
    descriptor information'
  prefs: []
  type: TYPE_NORMAL
- en: To set a security descriptor, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>
    system call invokes a type-specific security function. This type-specific function
    allows the kernel to support the different storage requirements for security descriptors;
    for example, a file must persist its security descriptor to disk, while the object
    manager can store a security descriptor in memory.
  prefs: []
  type: TYPE_NORMAL
- en: These type-specific functions eventually call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp>
    kernel API to build the updated security descriptor. User mode exports this kernel
    API as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>.
    Once the security descriptor has been updated, the type-specific function can
    store it using its preferred mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp>
    API accepts the following five parameters and returns a new security descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modification security descriptor    **The new security descriptor passed
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object security descriptor    **The current security descriptor for the object
    being updated'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security information    **Flags to specify what parts of the security descriptor
    to update, described in [Table 6-7](chapter6.xhtml#tab6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto-inherit    **A set of bit flags that define the auto-inheritance behavior'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic mapping    **The generic mapping for the type being created'
  prefs: []
  type: TYPE_NORMAL
- en: No kernel code uses the auto-inherit flags; therefore, the behavior of this
    API is simple. It merely copies the parts of the security descriptor specified
    in the security information parameter to the new security descriptor. It also
    maps any generic access to the type-specific access using the generic mapping,
    excluding <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACEs.
  prefs: []
  type: TYPE_NORMAL
- en: Some security descriptor control flags introduce special behavior. For example,
    it’s not possible to explicitly set <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>,
    but you can specify it along with <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInheritReq</samp>
    to set it on the new security descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: We can test out the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>
    API using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    command, as shown in [Listing 6-35](chapter6.xhtml#Lis6-35).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-35: Using Edit-NtSecurityDescriptor to modify an existing security
    descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the security for a kernel object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp>
    command. The command can accept either an object handle with the required access
    or an OMNS path to the resource. For example, you could use the following commands
    to try to modify the object *\BaseNamedObjects\ABC* by setting a new DACL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the “try to”: even if you can open a resource with the required access
    to set a security descriptor component, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access, this doesn’t mean the kernel will let you do it. The same rules regarding
    owner SIDs and mandatory labels apply here as when assigning a security descriptor
    at creation time.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp>
    API enforces these rules. If no object security descriptor is specified, then
    the API returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SECURITY
    _ON_OBJECT</samp> status code. Therefore, you can’t set the security descriptor
    for a type with <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityRequired</samp>
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>; that object
    won’t have a security descriptor, so any attempt to modify it causes the error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*One ACE flag I haven’t mentioned yet is Critical. The Windows kernel contains
    code to check the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp>
    flag and block the removal of ACEs that have the flag set. However, which ACEs
    to deem <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp>
    is up to the code assigning the new security descriptor, and APIs such as <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeSetSecurityInformationEx</samp>
    do not enforce it. Therefore, do not rely on the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp>
    flag to do anything specific. If you’re using security descriptors in user mode,
    you can handle the flag any way you like.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you change the inheritable ACEs on a container? Will the changes
    in the security descriptor propagate to all existing children? In a word, no.
    Technically, a type could implement this automatic propagation behavior, but none
    do. Instead, it’s up to the user-mode components to handle it. Next, we’ll look
    at the user-mode Win32 APIs that implement this propagation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Win32 Security APIs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most applications don’t directly call the kernel system calls to read or set
    security descriptors. Instead, they use a range of Win32 APIs. While we won’t
    discuss every API you could use here, we’ll cover some of the additional functionality
    the APIs add to the underlying system calls.
  prefs: []
  type: TYPE_NORMAL
- en: Win32 implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKernelObjectSecurity</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetKernelObjectSecurity</samp>
    APIs, which wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>.
    Likewise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatePrivateObjectSecurityEx</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPrivateObjectSecurityEx</samp>
    Win32 APIs wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>,
    respectively. Every property of the native APIs discussed in this chapter applies
    equally to these Win32 APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Win32 also provides some higher-level APIs: most notably, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>.
    These APIs allow an application to query or set a security descriptor by providing
    a path and the type of resource that path refers to, rather than a handle. The
    use of a path and type allows the functions to be more general; for example, these
    APIs support getting and setting the security of not only files and registry keys
    but also services, printers, and Active Directory Domain Services (DS) entries.'
  prefs: []
  type: TYPE_NORMAL
- en: To query or set the security descriptor, the API must open the specified resource
    and then call the appropriate API to perform the operation. For example, to query
    a file’s security descriptor, the API would open the file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>
    Win32 API and then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>
    system call. However, to query a printer’s security descriptor, the Win32 API
    needs to open the printer using the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenPrinter</samp>
    print spooler API and then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetPrinter</samp>
    API on the opened printer handle (as a printer is not a kernel object).
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell already uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp>
    API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command;
    however, the built-in command doesn’t support reading certain security descriptor
    ACEs, such as mandatory labels. Therefore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module implements <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32SecurityDescriptor</samp>,
    which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp>
    and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: If you merely want to display the security descriptor, you can use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32SecurityDescriptor</samp>
    command, which takes the same parameters but doesn’t return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object. [Listing 6-36](chapter6.xhtml#Lis6-36) provides a couple of examples of
    commands that leverage the underlying Win32 security APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-36: An example usage of Get-Win32SecurityDescriptor and Format-Win32SecurityDescriptor'
  prefs: []
  type: TYPE_NORMAL
- en: We start by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32SecurityDescriptor</samp>
    to query the security descriptor for the *Windows* directory, in this case <samp
    class="SANS_TheSansMonoCd_W5Regular_11">$env:WinDir</samp>. Note that we don’t
    specify the type of resource we want to query, as it defaults to a file. In the
    second example, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32Security
    Descriptor</samp> to display the security descriptor for the *MACHINE\SOFTWARE*
    key. This key path corresponds to the Win32 *HKEY_LOCAL_MACHINE\SOFTWARE* key
    path. We need to indicate that we’re querying a registry key by specifying the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> parameter; otherwise,
    the command will try to open the path as a file, which is unlikely to work.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To find the path format for every supported type of object, consult the API
    documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SE_OBJECT_TYPE</samp>
    enumeration, which is used to specify the type of resource in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GetNamedSecurityInfo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SetNamedSecurityInfo</samp>
    APIs.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    API is more complex, as it implements auto-inheritance across hierarchies (for
    example, across a file directory tree). As we discussed earlier, if you use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp> system
    call to set a file’s security descriptor, any new inheritable ACEs won’t get propagated
    to any existing children. If you set a security descriptor on a file directory
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>,
    the API will enumerate all child files and directories and attempt to update each
    child’s security descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    API generates the new security descriptor by querying the child security descriptor
    and using it as the creator security descriptor in a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>,
    taking the parent security descriptor from the parent directory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flags
    are always set, to merge any explicit ACEs in the creator security descriptor
    into the new security descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell exposes the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp>
    command, as shown in [Listing 6-37](chapter6.xhtml#Lis6-37).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-37: Testing auto-inheritance with Set-Win32SecurityDescriptor'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-37](chapter6.xhtml#Lis6-37) demonstrates the auto-inheritance behavior
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> for
    files. We first create the *TestFolder* directory in the root of the system drive,
    then set the security descriptor so that it contains one inheritable ACE for the
    *Everyone* group and has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> flags set
    ❶. Next, we create a text file inside the directory and print its security descriptor.
    The DACL contains the single ACE inherited from the parent by the text file ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: We then get the security descriptor from the directory and add a new inheritable
    ACE to it for the anonymous user. We use this security descriptor to set the DACL
    of the parent using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp>
    ❸. Printing the text file’s security descriptor again, we now see that it has
    two ACEs, as the anonymous user ACE has been added ❹. If we had used <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp>
    to set the parent directory’s security descriptor, this inheritance would not
    have taken place.
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>
    always uses auto-inheritance, applying a protected security descriptor control
    flag, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp>, becomes
    an important way to block the automatic propagation of ACEs.
  prefs: []
  type: TYPE_NORMAL
- en: Oddly, the API doesn’t allow you to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> control
    flags directly in the security descriptor. Instead, it introduces some additional
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> flags
    to handle setting and unsetting the control flags. To set a protected security
    descriptor control flag, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedDacl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedSacl</samp> flags for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>. To unset
    a flag, use <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedSacl</samp>. [Listing
    6-38](chapter6.xhtml#Lis6-38) provides examples of setting and unsetting the protected
    control flag for the DACL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-38: Testing the ProtectedDacl and UnprotectedDacl SecurityInformation
    flags'
  prefs: []
  type: TYPE_NORMAL
- en: This script assumes you’ve run [Listing 6-37](chapter6.xhtml#Lis6-37) already,
    as it reuses the file created there. We create a new security descriptor with
    a single ACE for the *Authenticated Users* group and assign it to the file with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedDacl</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> flags ❶. As a result, the
    protected control flag for the DACL is now set on the file ❷. Note that the inherited
    ACEs from [Listing 6-37](chapter6.xhtml#Lis6-37) have been removed; only the new,
    explicit ACE is left.
  prefs: []
  type: TYPE_NORMAL
- en: We then assign the security descriptor again with the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp>
    flag ❸. This time, when we print the security descriptor we can see that it no
    longer has the protected control flag set ❹. Also, the API restores the inherited
    ACEs from the parent directory and merges them with the explicit ACE for the *Authenticated
    Users* group.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of the command when we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp>
    flag shows you how you can restore the inherited ACEs for any file. If you specify
    an empty DACL so no explicit ACEs will be merged, and additionally specify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp> flag, you’ll
    reset the security descriptor to the version based on its parent. To simplify
    this operation, the PowerShell module contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset-Win32SecurityDescriptor</samp>
    command ([Listing 6-39](chapter6.xhtml#Lis6-39)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-39: Resetting the security of a directory using Reset-Win32SecurityDescriptor'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset-Win32SecurityDescriptor</samp>
    with the path to the file and request that the DACL be reset. When we display
    the security descriptor of the file, we now find that it matches the parent directory’s
    security descriptor, shown in [Listing 6-37](chapter6.xhtml#Lis6-37).
  prefs: []
  type: TYPE_NORMAL
- en: One final API to cover is <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp>,
    which allows you to identify the source of a resource’s inherited ACEs. One reason
    ACEs are marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag is to facilitate the analysis of inherited ACEs. Without the flag, the API
    would have no way of distinguishing between inherited and non-inherited ACEs.
  prefs: []
  type: TYPE_NORMAL
- en: For each ACE with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp>
    flag set, the API works its way up the parent hierarchy until it finds an inheritable
    ACE that doesn’t have this flag set but contains the same SID and access mask.
    Of course, there is no guarantee that the found ACE is the actual source of the
    inherited ACE, which could potentially live further up the hierarchy. Thus, treat
    the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp>
    as purely informational, and don’t use it for security-critical decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Like the other Win32 APIs, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp>
    supports different types. However, it’s limited to resources that have a child-parent
    relationship, such as files, registry keys, and DS objects. You can access the
    API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp>
    command, as shown in [Listing 6-40](chapter6.xhtml#Lis6-40).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-40: Enumerating inherited ACEs using Search-Win32SecurityDescriptor'
  prefs: []
  type: TYPE_NORMAL
- en: We first call <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp>
    with the path to the directory we created in [Listing 6-38](chapter6.xhtml#Lis6-38).
    The output is a list of the ACEs in the resource’s DACL, including the name of
    the resource from which each ACE was inherited and the depth of the hierarchy.
    We set two explicit ACEs on the directory. The output reflects this as a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    which indicates that the ACE wasn’t inherited. You can also see that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column is empty.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new file in the directory and rerun the command. In this case,
    as you might have expected, the ACEs show that they were both inherited from the
    parent folder, with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: This section covered the basics of the Win32 APIs. Keep in mind that there are
    clear differences in behavior between these APIs and the low-level system calls,
    especially regarding inheritance. When you interact with the security of resources
    via a GUI, it’s almost certainly calling one of the Win32 APIs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Server Security Descriptors and Compound
    ACEs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s finish this chapter with a topic I briefly mentioned when we discussed
    creator SIDs: server security descriptors. The kernel supports two very poorly
    documented security descriptor control flags for servers: <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp>. We use
    these flags only when generating a new security descriptor, either at object creation
    time or when assigning a security descriptor explicitly. The main control flag,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>, indicates
    to the security descriptor generation code that the caller is expecting to impersonate
    another user.'
  prefs: []
  type: TYPE_NORMAL
- en: When a new security descriptor is created during impersonation, the owner and
    group SIDs will default to the values from the impersonation token. This might
    not be desirable, as being the owner of a resource can grant a caller additional
    access to it. However, the caller can’t set the owner to an arbitrary SID, because
    the SID must be able to pass the owner check, which is based on the impersonation
    token.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    control flag comes in. If you set the flag on the creator security descriptor
    when creating a new security descriptor, the owner and group SIDs default to the
    primary token of the caller, and not to the impersonation token. This flag also
    replaces all <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs
    in the DACL with <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedCompound</samp>
    ACEs, the structure of which we defined back in [Chapter 5](chapter5.xhtml). In
    the compound ACE, the server SID is set to the owner SID from the primary token.
    [Listing 6-41](chapter6.xhtml#Lis6-41) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-41: Testing the ServerSecurity security descriptor control flag'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a new security descriptor using the anonymous user token ❶.
    This initial test doesn’t set the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    flag. As expected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> default to values
    based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> user
    token, and the single ACE we added remains intact ❷. Next, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    control flag to the creator security descriptor ❸. After calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>
    again, we now find that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> are set to the
    defaults for the primary token, not to those of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp>
    user token ❹. Also, the single ACE has been replaced with a compound ACE, whose
    server SID is set to the primary token’s owner SID ❺. We’ll discuss how changes
    to compound ACEs impact access checking in [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp> control
    flag works in combination with <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>.
    By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>
    assumes that any compound ACE in the DACL is trusted and will copy it verbatim
    into the output. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp>
    control flag is set, all compound ACEs instead have their server SID values set
    to the primary token’s owner SID.
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> control
    flag is set on the creator security descriptor and the new security descriptor
    inherits ACEs from a parent, we can convert the *CREATOR OWNER SERVER* and *CREATOR
    GROUP SERVER* SIDs to their respective primary token values. Also, any inherited
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs will be converted
    to compound ACEs, except for those of the default DACL.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Summary of Inheritance Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance is a very important topic to understand. [Table 6-8](chapter6.xhtml#tab6-8)
    summarizes the ACL inheritance rules we’ve discussed in this chapter, to help
    you make sense of them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-8:</samp> <samp class="SANS_Futura_Std_Book_11">Summary
    of Inheritance Rules for the DACL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parent ACL</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Creator
    ACL</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit set</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit not set</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_Futura_Std_Book_11">Default</samp> | <samp class="SANS_Futura_Std_Book_11">Default</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_Futura_Std_Book_11">Present</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_Futura_Std_Book_11">Default</samp> | <samp class="SANS_Futura_Std_Book_11">Default</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">None</samp>
    | <samp class="SANS_Futura_Std_Book_11">Parent</samp> | <samp class="SANS_Futura_Std_Book_11">Parent</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Present</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Present</samp>
    | <samp class="SANS_Futura_Std_Book_11">Parent and creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Protected</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Protected</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Defaulted</samp>
    | <samp class="SANS_Futura_Std_Book_11">Creator</samp> | <samp class="SANS_Futura_Std_Book_11">Creator</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Inheritable</samp> | <samp class="SANS_Futura_Std_Book_11">Defaulted</samp>
    | <samp class="SANS_Futura_Std_Book_11">Parent</samp> | <samp class="SANS_Futura_Std_Book_11">Parent</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'The first two columns in this table describe the state of the parent ACL and
    the creator ACL; the last two describe the resulting ACL, depending on whether
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> and/or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flag was
    set. There are six ACL types to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**None    **The ACL isn’t present in the security descriptor.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Present    **The ACL is present in the security descriptor (even if it is
    a NULL or empty ACL).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-inheritable    **The ACL has no inheritable ACEs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritable    **The ACL has one or more inheritable ACEs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected    **The security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> control
    flag set.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defaulted    **The security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclDefaulted</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclDefaulted</samp> control
    flag set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there are four possible resulting ACLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default    **The default DACL from the token, or nothing in the case of a
    SACL'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creator    **All ACEs from the creator ACL'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent    **The inheritable ACEs from the parent ACL'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent and creator    **The inheritable ACEs from the parent and explicit
    ACEs from the creator'
  prefs: []
  type: TYPE_NORMAL
- en: When an auto-inherit flag is set, the new security descriptor will have the
    corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherited</samp> control
    flag set. Also, all ACEs that were inherited from the parent ACL will have the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> ACE flag set. Note
    that this table doesn’t consider the behavioral changes due to object ACEs, mandatory
    labels, server security, and creator SIDs, which add more complexity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some worked examples that use the commands you’ve learned
    about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Object Manager
    Resource Owners</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter, the owner of a resource’s security descriptor
    is usually the user who created the resource. For administrators, however, it’s
    typically the built-in *Administrators* group. The only way to set a different
    owner SID is to use another token group SID that has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag set, or to enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>.
    Neither option is available to non-administrator users.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, knowing the owner of a resource can indicate whether a more privileged
    user created and used the resource. This could help you identify potential misuses
    of the Win32 security APIs in privileged applications, or find shared resources
    that a lower-privileged user might write to; a privileged user could mishandle
    these, causing a security issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-42](chapter6.xhtml#Lis6-42) shows a simple example: finding object
    manager resources whose owner SID differs from the caller’s.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-42: Finding objects in <samp class="SANS_Futura_Std_Book_11">BaseNamedObjects</samp>
    that are owned by a different user'
  prefs: []
  type: TYPE_NORMAL
- en: We first define a function to query the name and owner of an object manager
    directory entry ❶. The function initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">$curr_owner</samp>
    variable with the owner SID of the caller’s token ❷. We’ll compare this SID with
    the owner of a resource to return only resources owned by a different user.
  prefs: []
  type: TYPE_NORMAL
- en: For each directory entry, we query its security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    command ❸. We can specify a path and a root <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object to the command to avoid having to manually open the resource. If we successfully
    query the security descriptor, and if the owner SID does not match the current
    user’s owner SID, we return the resource’s name, object type, and owner SID.
  prefs: []
  type: TYPE_NORMAL
- en: To test the new function, we open a directory (in this case, the global *BaseNamedObjects*
    directory ❹) and use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectoryEntry</samp>
    to query for all entries, piping them through the function we defined. We receive
    a list of resources not owned by the current user.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the output includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">WAMACAPO;8_Mem</samp>
    object, which is a shared memory <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object. If a normal user can write to this <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object, we should investigate it further, as it might be possible to trick a privileged
    application into performing an operation that would elevate a normal user’s privileges.
  prefs: []
  type: TYPE_NORMAL
- en: We can test our ability to get write access on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    property of the object, as shown in [Listing 6-43](chapter6.xhtml#Lis6-43).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-43: Getting the granted access for a Section object'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">$entry</samp> variable contains
    the object we want to inspect. We pass its security descriptor to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command to return the maximum granted access for that resource. In this case,
    we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    is present, which indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object could be mapped as writable.
  prefs: []
  type: TYPE_NORMAL
- en: The example I’ve shown in [Listing 6-42](chapter6.xhtml#Lis6-42) should provide
    you with an understanding of how to query for any resource. You can replace the
    directory with a file or registry key, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp>
    with the path and the root object to query the owner for each of these resource
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the object manager and registry, however, there is a much simpler way of
    finding the owner SID. For the registry, we can look up the security descriptor
    for the entries returned from the *NtObject* drive provider using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    property. For example, we can select the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> SID fields for
    the root registry key using the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can also specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp>
    parameter to perform the check recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to query the owner SIDs of files, you can’t use this technique,
    as the file provider does not return the security provider in its entries. Instead,
    you need to use the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp>
    command. Here, for example, we query a file’s ACL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command returns
    the owner as a username, not a SID. You’ll have to look up the SID manually using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> command and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> parameter if you
    need it. Alternatively, you can convert the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp>
    command to a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp>
    object used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module, as shown in [Listing 6-44](chapter6.xhtml#Lis6-44).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-44: Converting Get-Acl output to a SecurityDescriptor object'
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertTo-NtSecurityDescriptor</samp>
    PowerShell command to perform the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Changing the Ownership
    of a Resource</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Administrators commonly take ownership of resources. This allows them to easily
    modify a resource’s security descriptor and gain full access to it. Windows comes
    with several tools for doing this, such as *takeown.exe*, which sets the owner
    of a file to the current user. However, you’ll find it instructive to go through
    the process of changing the owner manually, so you can understand exactly how
    it works. Run the commands in [Listing 6-45](chapter6.xhtml#Lis6-45) as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-45: Setting an arbitrary owner for a Directory object'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object on which to perform the operations. (We’ll avoid modifying an existing
    resource, which might risk breaking your system.) We then query the resource’s
    current owner SID. In this case, because we’re running this script as an administrator,
    it’s set to the *Administrators* group.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
    privilege. We need to do this only if we want to set an arbitrary owner SID. If
    we want to set a permitted SID, we can skip this line. We then open the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> again, but only for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a security descriptor with just the owner SID set to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">World</samp> SID. To do this, we call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp>
    PowerShell command, specifying only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag. If you haven’t enabled <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>,
    this operation will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_OWNER</samp>
    status code. To confirm that we’ve changed the owner SID, we query it again, which
    confirms that it’s now set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Everyone</samp>
    (the name of the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> SID).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply this same set of operations to any resource type, including registry
    keys and files: simply change the command used to open the resource. Whether you’ll
    be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access
    depends on the specifics of the access check process. In [Chapter 7](chapter7.xhtml),
    you’ll learn about a few cases in which the access check automatically grants
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access based on
    certain criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began with an overview of how to read the security descriptor of
    an existing kernel resource using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectSecurity</samp>
    command. We covered the security information flags that define what parts of the
    security descriptors the command should read and outlined the special rules for
    accessing audit information stored in the SACL.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed how we can assign security descriptors to resources, either
    during the resource creation process or by modifying an existing resource. In
    the process, you learned about ACL inheritance and auto-inheritance. We also discussed
    the behavior of the Win32 APIs, specifically <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>,
    and how that API implements auto-inheritance even though the kernel doesn’t explicitly
    implement it. We concluded with an overview of the poorly documented server security
    descriptor and compound ACEs. In the next chapter, we’ll (finally) discuss how
    Windows combines the token and security descriptor to check whether a user can
    access a resource.
  prefs: []
  type: TYPE_NORMAL
