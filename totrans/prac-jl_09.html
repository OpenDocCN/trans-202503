<html><head></head><body>
<h2 class="h" id="ch08"><span epub:type="pagebreak" id="page_213" class="calibre1"/><strong class="calibre2"><span class="big">8</span><br class="calibre3"/>THE TYPE SYSTEM</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">Object-oriented programming is an exceptionally bad idea which could only have originated in California.</em></p>
<p class="center1">—Edsger Dijkstra</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">Up to now we’ve been using and creating a lot of functions. We can think of functions as the verbs of the Julia language. And just as in natural languages, verbs act on nouns. The nouns in Julia are numbers, collections, strings, and other instances of types.</p>
<p class="indent">We’ve encountered many data types in our journey up to this point: different varieties of numbers, strings, characters, and collections such as arrays and maps. Although our focus hasn’t been on types, it’s impossible to talk much about Julia programming without making some reference to them. Julia is unusual in that it allows us to create very fast code without having to specify the types of variables, unlike other fast languages such as Fortran (where the specifications can be implicit) and C. However, effective Julia programming requires some knowledge of its type system. The main reason for this is that Julia programs are organized around functions and methods through its dispatch system, which relies on argument types. A secondary reason has to do with those occasions where an awareness of types <span epub:type="pagebreak" id="page_214"/>allows us to write more efficient programs. This chapter covers both of these concerns.</p>
<h3 class="h2" id="ch08lev1"><strong class="calibre2">Types in Practice</strong></h3>
<p class="noindent">Rather than delve into the abstract theory of type systems, let’s approach types from a practical point of view.</p>
<p class="indent">To find the type of any value, Julia provides the <span class="literal">typeof()</span> function:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">typeof(17)</span>
   Int64

   julia&gt; <span class="codestrong">typeof(17.0)</span>
   Float64

   julia&gt; <span class="codestrong">typeof(17//1)</span>
<span class="ent">➊</span> Rational{Int64}

   julia&gt; <span class="codestrong">typeof("7")</span>
   String

   julia&gt; <span class="codestrong">typeof('7')</span>
   Char</pre>
<p class="noindent">We’ve already considered the difference between strings and characters, and the related difference between single and double quotes; however, it’s important to have some understanding of the various numeric types. Although, for example, <span class="literal">17</span>, <span class="literal">17//1</span>, and <span class="literal">17.0</span> have the same values, they are different types of objects, and their behavior is potentially different. The difference in their types reflects this reality.</p>
<p class="indent">The curly brackets used in reporting the type of a rational number <span class="ent">➊</span> indicate that this is a <em class="calibre11">parametric type</em>, a topic we’ll return to in “Parametric Types” on <a href="ch08.xhtml#ch08lev6" class="calibre10">page 248</a>. For now, it’s sufficient to understand that this is a <span class="literal">Rational</span> made up of <span class="literal">Int64</span> pieces.</p>
<p class="indent">The type reported for the floating-point literal is <span class="literal">Float64</span>, which means it’s a floating-point number, or a number with a decimal point, and that it’s stored in a 64-bit segment of memory. The 64 bits are apportioned as follows: 1 for the sign, 11 for the exponent, and 52 for the “fraction.” The maximum absolute value of a <span class="literal">Float64</span> is about 10<sup class="calibre23">300</sup>, and it has 17 significant digits, or 16 digits of precision beyond the decimal point. (This agrees with the observation that it takes three binary digits to represent a decimal digit.) We can see this using the <span class="literal">@printf</span> macro, supplied by the <span class="literal">Printf</span> package:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Printf</span>

julia&gt; <span class="codestrong">@printf "%.16f" 1/3</span>
0.3333333333333333

julia&gt; <span class="codestrong">@printf "%.17f" 1/3</span>
0.33333333333333331

julia&gt; <span class="codestrong">@printf "%.18f" 1/3</span>
0.333333333333333315</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_215"/>This shows incorrect digits appearing if we ask for more than 16.</p>
<p class="indent">We’ll see more incorrect digits if we use floating-point types with lower precision:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">@printf "%.16f" Float32(1/3)</span>
0.3333333432674408
julia&gt; <span class="codestrong">@printf "%.16f" Float16(1/3)</span>
0.3332519531250000</pre>
<p class="noindent">Here we used the names of the types as functions to cast their arguments to the named types. Without the cast, expressions like <span class="literal">1/3</span> are <span class="literal">Float64</span> by default on most systems.</p>
<p class="indent">The default integer type on typical systems, <span class="literal">Int64</span>, ranges between <em class="calibre11">−</em>2<sup class="calibre23">63</sup> and 2<sup class="calibre23">63</sup> <em class="calibre11">−</em> 1, with one bit used for the sign.</p>
<p class="indent">Julia supplies built-in functions for finding the maximum and minimum values representable with each numeric type:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">typemax(Int32)</span>
2147483647

julia&gt; <span class="codestrong">typemin(Int32)</span>
-2147483648

julia&gt; <span class="codestrong">typemax(Int16)</span>
32767

julia&gt; <span class="codestrong">typemin(Int16)</span>
-32768</pre>
<p class="indent">But <span class="literal">typemax()</span> and <span class="literal">typemin()</span> aren’t very helpful if we ask them about floats:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">typemax(Float64)</span>
Inf

julia&gt; <span class="codestrong">typemax(Float16)</span>
Inf16

julia&gt; <span class="codestrong">Inf64 === Inf</span>
true</pre>
<p class="indent">Apparently infinity is a floating-point number, and Julia has infinities for each size float. This is consistent: since nothing is larger than infinity, if <span class="literal">Inf16</span> is a <span class="literal">Float16</span> it must be the largest possible <span class="literal">Float16</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_216"/>Julia has another function that comes to the rescue here:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">floatmax(Float64)</span>
1.7976931348623157e308

julia&gt; <span class="codestrong">floatmin(Float64)</span>
2.2250738585072014e-308

julia&gt; <span class="codestrong">floatmax(Float16)</span>
Float16(6.55e4)

julia&gt; <span class="codestrong">floatmin(Float16)</span>
Float16(6.104e-5)</pre>
<p class="indent">The functions <span class="literal">floatmax()</span> and <span class="literal">floatmin()</span> return the maximum <em class="calibre11">finite</em> float and the minimum positive float of the requested type.</p>
<p class="indent">Usually we should perform arithmetic in our programs using these <em class="calibre11">native types</em>, which are the most efficient choices. If needed, and if possible, we can use smaller numbers to save space—for example, <span class="literal">Int16</span>—and we can get larger integers using <span class="literal">Int128</span>. However, if the native types are not adequate for our purposes, it’s usually because we need a lot of precision—in other words, many digits—in our computation. This is the subject of the next section.</p>
<p class="indent">To check whether a particular value has a certain type, use the <span class="literal">isa()</span> function. We can use it as a normal function or in infix position:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">isa(17, Int64)</span>
true

julia&gt; <span class="codestrong">17 isa Number</span>
true

julia&gt; <span class="codestrong">17 isa String</span>
false</pre>
<p class="noindent">This function returns a Boolean value. The first two calls return <span class="literal">true</span> because <span class="literal">17</span> is both an <span class="literal">Int64</span> and a <span class="literal">Number</span>. The former implies the latter (see “The Type Hierarchy” on <a href="ch08.xhtml#ch08lev1sec4" class="calibre10">page 222</a>).</p>
<h4 class="h3" id="ch08lev1sec1"><strong class="calibre2"><em class="calibre4">“Big” and Irrational Types</em></strong></h4>
<p class="noindent">Julia makes it easy to perform <em class="calibre11">arbitrary precision arithmetic</em> using types whose precision grows as needed: where the number of digits can grow without bound. Arithmetic with these types is slower than normal computation with native types, but for some jobs it’s the only choice.</p>
<h5 class="h4" id="ch08sec1sec1"><strong class="calibre2">Arbitrary Precision</strong></h5>
<p class="noindent">As a simple example of where we would need arbitrary precision types, suppose we want to graph the factorial function. This is the function usually spelled with an exclamation mark:</p>


<div class="image"><span epub:type="pagebreak" id="page_217"/><img alt="Image" src="../images/math217.jpg" class="calibre6"/></div>
<p class="indent">The corresponding Julia function is <span class="literal">factorial(n)</span>. The function grows extremely quickly:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">factorial(20)</span>
2432902008176640000

julia&gt; <span class="codestrong">factorial(21)</span>
ERROR: OverflowError: 21 is too large to look up in the table;
       consider using `factorial(big(21))` instead</pre>
<p class="noindent">This shows that 20 is the largest factorial that fits in an <span class="literal">Int64</span>. We can go up to 33! if we use <span class="literal">Int128</span>, but what if we want to go bigger?</p>
<p class="indent">The error message provides a hint. The <span class="literal">big()</span> function converts its argument to a corresponding type with unlimited size and precision. For integers, this is called <span class="literal">BigInt</span>, and for floats it’s <span class="literal">BigFloat</span>.</p>
<p class="indent">Let’s use <span class="literal">BigInt</span> to make a plot of the factorial function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">plot(factorial.(big.(1:50)), yscale=:log10,</span>
               <span class="codestrong">legend=:topleft, label="Factorial")</span></pre>
<p class="noindent">Here we’re plotting up to 50!, which is far beyond what can fit in a native integer. <a href="ch08.xhtml#ch8fig1" class="calibre10">Figure 8-1</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch8fig1" src="../images/ch08fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-1: The factorial function calculated using <span class="codeitalic">BigInt</span></em></p>
<p class="indent">We’ll revisit the factorial in “Factorials” on <a href="ch10.xhtml#ch10lev1sec1" class="calibre10">page 312</a>, where it appears as the number of ways to permute <em class="calibre11">n</em> objects.</p>
<p class="indent"><span epub:type="pagebreak" id="page_218"/>The <span class="literal">BigFloat</span> type also offers unlimited magnitude. Its default precision is 256, giving us about 80 significant digits. We can set the <span class="literal">BigFloat</span> precision to be anything we need, using the <span class="literal">setprecision()</span> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">big(1.0)/3</span>
0.333333333333333333333333333333333333333333333333
  3333333333333333333333333333348

julia&gt; <span class="codestrong">setprecision(512);</span>

julia&gt; <span class="codestrong">big(1.0)/3</span>
0.3333333333333333333333333333333333333333333333333
  3333333333333333333333333333333333333333333333333
  3333333333333333333333333333333333333333333333333
  333333346</pre>
<p class="indent">To retrieve the precision, we have the <span class="literal">precision()</span> function, which accepts the type that we’re asking about:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">precision(big(1.0))</span>
512

julia&gt; <span class="codestrong">precision(float(1.0))</span>
53</pre>
<p class="noindent">The number of digits used for a <span class="literal">BigInt</span> grows as needed, so it doesn’t come with the concept of a fixed precision applicable to the floating-point numbers.</p>
<h5 class="h4" id="ch08sec1sec2"><strong class="calibre2">Irrationals</strong></h5>
<p class="noindent">An unusual attribute of Julia is the existence of the <em class="calibre11">irrational type</em>:</p>
<pre class="calibre13">julia&gt; π
π = 3.1415926535897...

julia&gt; <span class="codestrong">typeof</span>(π)
Irrational{:π}</pre>
<p class="noindent">The number represented by the Greek letter π is printed with three dots appended to suggest that there is more to the story. Although it appears to be a floating-point number, its type is not given as <span class="literal">Float64</span>, but as something new: <span class="literal">Irrational</span>. That’s because in Julia, π represents <em class="calibre11">not</em> a floating-point number, but the <em class="calibre11">exact value</em> of the ratio of a circle’s circumference to its diameter. The three dots remind us that the digits presented are simply the first few in an endless, nonrepeating series.</p>
<p class="indent">Julia calculates and presents more digits as and when needed:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">big(</span>π<span class="codestrong">)</span>
3.1415926535897932384626433832795028841971693993751
  05820974944592307816406286198</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_219"/>The number is not printed with trailing dots, as it’s no longer a representation of an exact value, but an approximation to it.</p>
<p class="indent">Several other irrational numbers are built into Julia; the most important of these for general purposes is <em class="calibre11">e</em>, the base of the natural logarithms. To insert this character, which is the Unicode codepoint 212F (Script Small E), enter <span class="codestrong1">\euler</span> and press <small class="calibre5">TAB</small> in the REPL:</p>
<pre class="calibre13">   julia&gt; <span class="codestrongitalic1">e</span>
   <span class="codeitalic">e</span> = 2.7182818284590...

   julia&gt; <span class="codestrong">big(</span><span class="codestrongitalic1">e</span><span class="codestrong">)</span>
<span class="ent">➊</span> 2.7182818284590452353602874713526624977572470936999
     59574966967627724076630353555

   julia&gt; <span class="codestrong">log(</span><span class="codestrongitalic1">e</span><span class="codestrong">)</span>
<span class="ent">➋</span> <span class="codestrong">1</span>

   julia&gt; <span class="codestrong">log(2.71828182845904)</span>
   0.9999999999999981

   julia&gt; <span class="codestrong">log(2.718281828459045)</span>
   1.0</pre>
<p class="noindent">As with π, Julia displays the value of <em class="calibre11">e</em> with three trailing dots to indicate that it’s showing us a few digits of an exact value.</p>
<p class="indent">We can see an approximation to <em class="calibre11">e</em> <span class="ent">➊</span> to any desired number of digits by converting it to a <span class="literal">BigFloat</span>. By definition, the value of the natural logarithm of <em class="calibre11">e</em> is exactly the integer 1 <span class="ent">➋</span>, but if we take the logarithms of approximations to <em class="calibre11">e</em>, we get an approximate, or floating-point, result.</p>
<h4 class="h3" id="ch08lev1sec2"><strong class="calibre2"><em class="calibre4">Type Promotion</em></strong></h4>
<p class="noindent">When performing arithmetic on a mixture of different numerical types, Julia will silently <em class="calibre11">promote</em> types as needed:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">1 + 1</span>
2

julia&gt; <span class="codestrong">1 + 1.0</span>
2.0</pre>
<p class="noindent">The addition of two integers provides no reason to leave integer land, so the result is also an <span class="literal">Int64</span>. But if one of the numbers is a <span class="literal">Float64</span>, the other is promoted to that type, which is also the type of the result.</p>
<p class="indent">Julia will not promote nonnumerical types to numbers:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">1 + "1"</span>
ERROR: MethodError: no method matching +(::Int64, ::String)</pre>
<p class="indent"><span epub:type="pagebreak" id="page_220"/>Its treatment of types and promotion is therefore similar to Python and dissimilar from JavaScript.</p>
<p class="indent">The <span class="literal">promote()</span> function takes any number of numerical arguments and returns a tuple with (possibly) some of them promoted as necessary to give them all a common type so they can be used in subsequent calculations without further promotion. It performs the same promotions as would be performed automatically when doing arithmetic:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">promote(big(2.0), 3.5, 3.4)</span>
(2.0, 3.5, 3.3999999999999999111821580299874767661
 09466552734375)

julia&gt; <span class="codestrong">typeof(promote(big(2.0), 3.5, 3.4))</span>
Tuple{BigFloat, BigFloat, BigFloat}

julia&gt; <span class="codestrong">typeof(promote(2, 3.5, 3.4))</span>
Tuple{Float64, Float64, Float64}</pre>
<p class="noindent">The promotion in the first line shows how some numbers (2.0, 3.5) have an exact binary representation, but others (3.4) do not. The two following commands provide examples of how <span class="literal">promote()</span> converts its arguments to a common type.</p>
<h4 class="h3" id="ch08lev1sec3"><strong class="calibre2"><em class="calibre4">Collections</em></strong></h4>
<p class="noindent">Julia prints the types of collections in the REPL when printing their values more often than it announces simple numerical types, so we’ve seen more of the former:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">[1 2]</span>
   1×2 Matrix{Int64}:
    1  2

   julia&gt; <span class="codestrong">[1.0; 2]</span>
   2-element Vector{Float64}:
    1.0
    2.0

   julia&gt; <span class="codestrong">[[1 2];;; [3 4]]</span>
<span class="ent">➊</span> 1×2×2 Array{Int64, 3}:
   [:, :, 1] =
    1  2

   [:, :, 2] =
    3  4</pre>
<p class="indent"><span epub:type="pagebreak" id="page_221"/>Julia prints the type of collection (<span class="literal">Matrix</span>, <span class="literal">Vector</span>, or <span class="literal">Array</span>) and its dimensions. A <span class="literal">Vector</span> is one-dimensional, and a <span class="literal">Matrix</span> is two-dimensional. For the more general <span class="literal">Array</span> type, Julia prints an integer showing the number of dimensions: here it’s a three-dimensional array <span class="ent">➊</span>.</p>
<p class="indent">It also indicates the types of the collection’s elements inside curly brackets. We can extract this information separately using the <span class="literal">eltype()</span> function:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">eltype([1 2])</span>
   Int64

   julia&gt; <span class="codestrong">eltype([1.0 2])</span>
   Float64

   julia&gt; <span class="codestrong">eltype([1.0 "2"])</span>
<span class="ent">➊</span> Any

   julia&gt; <span class="codestrong">[1.0 "2"]</span>
   1×2 Matrix{Any}:
    1.0  "2"</pre>
<p class="indent">In the first example, the result, <span class="literal">Int64</span>, is the type of both elements of the array. The second example shows how Julia promotes numerical types when possible to create homogeneous arrays, which are more efficient to calculate with. However, when confronted with types where no promotion is possible <span class="ent">➊</span>, the element type becomes <span class="literal">Any</span>: a type that literally means any type.</p>
<p class="indent">These results follow the behavior of the <span class="literal">promote()</span> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">promote(1.0, 2)</span>
(1.0, 2.0)

julia&gt; <span class="codestrong">promote(1.0, "2")</span>
ERROR: promotion of types Float64 and String failed to change any arguments</pre>
<p class="indent">If elements can be promoted to a common type, that type is used for the <span class="literal">eltype</span> of the collection; otherwise, the <span class="literal">Any</span> type is used.</p>
<p class="indent">The collection types <span class="literal">Vector</span>, <span class="literal">Matrix</span>, and <span class="literal">Array</span> have some behaviors in common: for example, they can all be indexed. This is not true of all collections, however. The <span class="literal">Set</span> type has no ordering, hence no ability to be indexed. These three collection types share certain behaviors because they’re special cases of a more general type, a concept that we’ll explore in the next section.<span epub:type="pagebreak" id="page_222"/></p>
<h4 class="h3" id="ch08lev1sec4"><strong class="calibre2"><em class="calibre4">The Type Hierarchy</em></strong></h4>
<p class="noindent">All types in Julia are <em class="calibre11">subtypes</em> of types that are their <em class="calibre11">supertypes.</em> The one type that has no strict supertype is the <span class="literal">Any</span> type, which is its own supertype. The concepts of supertypes and subtypes are connected with the inheritance of behaviors, and the configuration of the type hierarchy is usually intuitive when applied to particular cases. For example, we expect that any kind of number will support some notion of addition. Exactly what addition means may vary among various species of numbers—addition of complex numbers is a generalization of addition of real numbers, for example—but when we encounter a type that is a subtype of the <span class="literal">Number</span> type, we can be confident that, at least, the <span class="literal">+</span> operator is defined for it.</p>
<p class="indent">As shown in <a href="ch08.xhtml#ch8lis1" class="calibre10">Listing 8-1</a>, the <span class="literal">supertype()</span> function, when supplied a type, returns its supertype.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">typeof(17)</span>
Int64

julia&gt; <span class="codestrong">supertype(Int64)</span>
Signed

julia&gt; <span class="codestrong">supertype(Signed)</span>
Integer

julia&gt; <span class="codestrong">supertype(Integer)</span>
Real

julia&gt; <span class="codestrong">supertype(Real)</span>
Number

julia&gt; <span class="codestrong">supertype(Number)</span>
Any

julia&gt; <span class="codestrong">supertype(Any)</span>
Any</pre>
<p class="list" id="ch8lis1"><em class="calibre11">Listing 8-1: Walking up the type hierarchy</em></p>
<p class="indent">The <span class="literal">typeof()</span> function returns the type of a literal value or variable. The types that we actually compute with, such as <span class="literal">Float64</span> and <span class="literal">Int64</span>, are called <em class="calibre11">concrete types</em>. Concrete types are leaves at the tips of the tree of types; they can not subtype each other.</p>
<p class="indent"><a href="ch08.xhtml#ch8lis1" class="calibre10">Listing 8-1</a> shows a series of calls to <span class="literal">supertype()</span> to find where the default integer type, <span class="literal">Int64</span>, lies in the type hierarchy. All of the types that concrete types such as <span class="literal">Int64</span> inherit from are <em class="calibre11">abstract types</em>. The purpose of abstract <span epub:type="pagebreak" id="page_223"/>types, such as <span class="literal">Number</span>, is simply to create nodes in the tree of types to enable the definition of methods. The function of these abstract types, and the type hierarchy that they constitute, is not to make things more complicated, but to make the life of the Julia programmer easier. Because of the tree of types, we can define functions and methods that operate at the ideal level of abstraction, as we’ll see in “Functions and Methods: Multiple Dispatch” on <a href="ch08.xhtml#ch08lev2" class="calibre10">page 229</a>.</p>
<p class="indent">The final two lines in <a href="ch08.xhtml#ch8lis1" class="calibre10">Listing 8-1</a> show that <span class="literal">Number</span> is at the top of the hierarchy of numerical types, and its supertype, <span class="literal">Any</span>, is the root of the entire hierarchy, and, as the last line shows, is its own supertype.</p>
<p class="indent">By making more calls to <span class="literal">supertype()</span>, we can explore more of the type tree. <a href="ch08.xhtml#ch8lis2" class="calibre10">Listing 8-2</a> shows a modification of the program in <a href="ch07.xhtml#ch7lis3" class="calibre10">Listing 7-3</a> to visualize a section of it.</p>
<pre class="calibre13">using Plots
using Graphs
using GraphRecipes

sometypes = [Any, Complex, Float64, Int64, Number, Signed,
             Irrational, AbstractFloat, Real,
             AbstractIrrational, Integer, String, Char,
             AbstractString, AbstractChar, Rational,
             Int32, Vector, DenseVector, AbstractVector,
             Array, DenseArray, AbstractArray]

type_tree = SimpleDiGraph(length(sometypes))

for t in sometypes[2:end]
 <span class="ent">➊</span> add_edge!(type_tree, indexin([supertype(t)], sometypes)[1],
              indexin([t], sometypes)[1])
end

graphplot(type_tree; names=[string(t) for t in sometypes], nodeshape=:rect,
          fontsize=4, nodesize=0.17, nodecolor=:white, method=:buchheim)</pre>
<p class="list" id="ch8lis2"><em class="calibre11">Listing 8-2: Visualizing part of the type hierarchy</em></p>
<p class="noindent">We’ve collected a handful of mostly numeric types in the <span class="literal">sometypes</span> vector. These are a subset of the total number of types that come with Julia and its standard library, and many more are defined in various packages.</p>
<p class="indent"><a href="ch08.xhtml#ch8lis2" class="calibre10">Listing 8-2</a> uses the <span class="literal">supertype()</span> function to create the edges <span class="ent">➊</span> of the tree graph, connecting each type to its supertype. <a href="ch08.xhtml#ch8fig2" class="calibre10">Figure 8-2</a> shows the result.</p>
<div class="image1"><span epub:type="pagebreak" id="page_224"/><img alt="Image" id="ch8fig2" src="../images/ch08fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-2: The relationships among a few types</em></p>
<p class="indent"><a href="ch08.xhtml#ch8fig2" class="calibre10">Figure 8-2</a> makes it clear that <span class="literal">Any</span> is the root of the tree and reminds us that, for example, characters and strings are distinct types. But it also obscures certain relationships, such as that some types are aliases of others. This is a topic we’ll explore later in this chapter (see “Type Aliases” on <a href="ch08.xhtml#ch08lev5" class="calibre10">page 247</a>).</p>
<p class="indent">Two additional functions that are handy for exploring the type hierarchy are <span class="literal">subtypes()</span>, which returns a vector of all the <em class="calibre11">immediate</em> subtypes of the type supplied as an argument, and <span class="literal">supertypes()</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">supertypes(Irrational)</span>
(Irrational, AbstractIrrational, Real, Number, Any)</pre>
<p class="noindent">This example shows that <span class="literal">supertypes()</span> returns a tuple containing the type supplied and all of its supertypes.</p>
<h4 class="h3" id="ch08lev1sec5"><strong class="calibre2"><em class="calibre4">Type Assertions and Declarations</em></strong></h4>
<p class="noindent">Now we know how to discover the type of any variable and the supertype of any type. On occasion, we also need to tell Julia that a variable is of a particular type (a <em class="calibre11">type declaration</em>), or that the value of an expression should have a <span epub:type="pagebreak" id="page_225"/>specified type (a <em class="calibre11">type assertion</em>). The <span class="literal">::</span> operator performs either operation, depending on where it occurs.</p>
<h5 class="h4" id="ch08sec1sec3"><strong class="calibre2">Type Assertions</strong></h5>
<p class="noindent">Sometimes in our programs we reach a point where it is important to ensure that the value of a particular expression has a certain type. If it does not, we want to generate an error, which we can either handle or allow to halt the program.</p>
<p class="indent">The simplest expression in Julia is a literal value. Let’s use <span class="literal">17</span> as our first example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">17::Number</span>
17

julia&gt; <span class="codestrong">17::Integer</span>
17

julia&gt; <span class="codestrong">17::Int64</span>
17

julia&gt; <span class="codestrong">17::String</span>
ERROR: TypeError: in typeassert, expected String, got a value of type Int64</pre>
<p class="noindent">The first line is an assertion that <span class="literal">17</span> has the <span class="literal">Number</span> type, which of course it does. An expression with a type assertion attached returns the value of the expression if the assertion is true, so here Julia simply returns <span class="literal">17</span>. The following two lines are also true assertions. A type assertion is true if it specifies any supertype of the type of the expression.</p>
<p class="indent">The final type assertion returns an error because <span class="literal">17</span> is neither a <span class="literal">String</span> nor a subtype of the <span class="literal">String</span> type.</p>
<p class="indent">Here’s an example of how we might use a type assertion in a program:</p>
<pre class="calibre13">function greetings()
    println("Who are you?")
    yourname = readline();
    greeting = ("Hello, " * yourname * ".")
 <span class="ent">➊</span> return greeting::String
end</pre>
<p class="noindent">The program asks the user a question, receives the reply using <span class="literal">readline()</span>, and joins it with two other strings to construct a greeting, which it returns. We used a type assertion <span class="ent">➊</span> to ensure that the type returned by the function is what is expected.</p>
<h5 class="h4" id="ch08sec1sec4"><strong class="calibre2">Type Declarations</strong></h5>
<p class="noindent">We also use the <span class="literal">::</span> operator for type declarations. Its meaning is determined from its position within a statement.</p>
<p class="indent"><span epub:type="pagebreak" id="page_226"/>We can declare that a variable has a particular type in two ways. One way is to supplement the usual assignment statement with a declaration, as in this example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a::Int16 = 17</span>
17

julia&gt; <span class="codestrong">typeof(a)</span>
Int16</pre>
<p class="noindent">Here the assignment and the type declaration happen simultaneously.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Julia v1.8 was the first version that allowed type declarations of global variables; this makes working in the REPL more convenient. In earlier versions, all type declarations must occur in a local scope.</em></p>
</div>
<p class="indent">Once we declare the type of a variable, we are committed:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = "Paris"</span>
ERROR: MethodError: Cannot `convert` an object
  of type String to an object of type Int16

julia&gt; <span class="codestrong">a::Int32 = 17</span>
ERROR: cannot set type for global a. It already
  has a value or is already set to a different type.</pre>
<p class="noindent">As this example shows, an attempt to assign a value of the wrong type to a declared variable, or to explicitly change its type, results in an error.</p>
<p class="indent">Any value assigned to <span class="literal">a</span> must be convertible to <span class="literal">a</span>’s type, <span class="literal">Int16</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = 32767</span>
32767

julia&gt; <span class="codestrong">a = 32768</span>
ERROR: InexactError: trunc(Int16, 32768)</pre>
<p class="noindent">The second assignment failed because 32,768 is larger than the largest value that an <span class="literal">Int16</span> can hold, which is 2<sup class="calibre23">15</sup>−1 = 32,767, returned by <span class="literal">typemax(Int16)</span>.</p>
<p class="indent"><a href="ch08.xhtml#ch8lis3" class="calibre10">Listing 8-3</a> shows the other way to declare a type: as part of a <span class="literal">local</span> or <span class="literal">global</span> definition.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">global gf::Float64</span>

julia&gt; <span class="codestrong">gf = 17</span>
17

julia&gt; <span class="codestrong">gf</span>
17.0 <span class="ent">➊</span>

julia&gt; <span class="codestrong">typeof(gf)</span>
Float64

julia&gt; <span class="codestrong">gf = "London"</span>
ERROR: MethodError: Cannot `convert` an object
  of type String to an object of type Float64 <span class="ent">➋</span>

<span epub:type="pagebreak" id="page_227"/>julia&gt; <span class="codestrong">function weather_report(raining)
           if !(raining isa Bool) <span class="ent">➌</span>
               println("Please tell us if it's raining with \"true\" or \"false\".")
               return
           else
               if raining
                   n = ""
               else
                   n = "not "
               end
               local gf::String <span class="ent">➍</span>
               gf = "London"
               return("It is $(n)raining in $gf today.")
           end
        end</span>
weather_report (generic function with 1 method)</pre>
<p class="list" id="ch8lis3"><em class="calibre11">Listing 8-3: Type declarations</em></p>
<p class="noindent">We define <span class="literal">gf</span> to be global and to have the <span class="literal">Float64</span> type. Julia seems happy to let us assign a literal integer to it, but it has converted the value to a <span class="literal">Float64</span> as part of the assignment <span class="ent">➊</span>. Because there is no way to convert a literal string to a <span class="literal">Float64</span>, our attempt to assign a string to the variable failed <span class="ent">➋</span>.</p>
<p class="indent">We can use a variable of the same name, declared to be local, inside a function <span class="ent">➍</span> ; this local variable has no relationship with the global <span class="literal">gf</span>. The function <span class="literal">weather_report()</span> expects a <span class="literal">Bool</span> from the user (<span class="literal">true</span> or <span class="literal">false</span>), and uses it to construct a sentence about the weather. It uses the <span class="literal">isa</span> operator to check that it’s received the correct type <span class="ent">➌</span>.</p>
<p class="indent">The following short program illustrates an important behavior of type declarations:</p>
<pre class="calibre13">function type_dec_demo()
    a = 17
    println("a = $a and has the type $(typeof(a)).")
    local a::Int16
end</pre>
<p class="indent">Running this function produces the output:</p>
<pre class="calibre13">a = 17 and has the type Int16.</pre>
<p class="indent"><span epub:type="pagebreak" id="page_228"/>The line that prints the type of <span class="literal">a</span> comes <em class="calibre11">before</em> the type declaration; so why is <span class="literal">a</span> already an <span class="literal">Int16</span>? After all, this is what happens in the REPL:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = 17</span>
17

julia&gt; <span class="codestrong">typeof(a)</span>
Int64</pre>
<p class="noindent">This output is what we expect, as the concrete type <span class="literal">Int64</span> is the native integer on a 64-bit machine, which is the most common architecture. The explanation is that a type declaration within a scope block, in this case a function definition, enforces an unchangeable type for the entire block. The declaration can occur anywhere within the block.</p>
<p class="indent">In the absence of a declaration, a variable <em class="calibre11">can</em> change type within a block as a consequence of arithmetic operations:</p>
<pre class="calibre13">function changing_type_demo()
    a = 17
    println("a = $a and has the type $(typeof(a)).")
    a = a + 1.0
    println("a = $a and has the type $(typeof(a)).")
end</pre>
<p class="indent">This function produces the output:</p>
<pre class="calibre13">a = 17 and has the type Int64.
a = 18.0 and has the type Float64.</pre>
<p class="indent">Allowing this to happen can interfere with performance, a topic we return to in “Vanquish Type Instability” on <a href="ch08.xhtml#ch08lev1sec13" class="calibre10">page 242</a>.</p>
<p class="indent">The <span class="literal">::</span> operator can also declare the type of the value returned by a function. For example, we can change the first line of the definition of <span class="literal">weather_report()</span> in <a href="ch08.xhtml#ch8lis3" class="calibre10">Listing 8-3</a> as follows:</p>
<pre class="calibre13">function weather_report(raining)::String</pre>
<p class="noindent">This asserts that the function must return a <span class="literal">String</span> value.</p>
<p class="indent">The purpose of such declarations is the same as type declarations for variables: they are never required, and usually not needed, but in some cases they can provide extra information to the compiler that helps with performance. We’ll see some examples of this in “Performance Tips” on <a href="ch08.xhtml#ch08lev4" class="calibre10">page 242</a>. When we construct expressions using functions, it’s helpful to know the types returned by each function call; using type declarations in function definitions assists in writing correct and efficient programs.<span epub:type="pagebreak" id="page_229"/></p>
<h3 class="h2" id="ch08lev2"><strong class="calibre2">Functions and Methods: Multiple Dispatch</strong></h3>
<p class="noindent">When we define a function in the REPL, if there are no errors, we’ll see a message like the one we saw after the definition of <span class="literal">weather_report()</span> in <a href="ch08.xhtml#ch8lis3" class="calibre10">Listing 8-3</a>:</p>
<pre class="calibre13">weather_report (generic function with 1 method)</pre>
<p class="indent">A generic function is defined by its name, in this case <span class="literal">weather_report()</span>. Each generic function can have any number of <em class="calibre11">methods</em> associated with it, which are distinguished by their method <em class="calibre11">signatures</em>. The signature is the part that goes inside the parentheses when you define the method. Up until now, these signatures have included the names of positional and keyword arguments and their default values, if any. If we make a second definition of <span class="literal">weather_report()</span> with a different set of arguments in its signature, we will have created a second method.</p>
<p class="indent">A further use of the <span class="literal">::</span> operator is within method signatures, to specify the types that the arguments therein are supposed to have. Two definitions, both with the same arguments, define different methods if any of these type specifications are different, even if the signatures are otherwise the same.</p>
<p class="indent">When the compiler sees a function call, it invokes the method with the most specific definition that matches the arguments supplied in the call. Here is where we see the real purpose of the abstract types that we learned about in “The Type Hierarchy” on <a href="ch08.xhtml#ch08lev1sec4" class="calibre10">page 222</a>. With all else being equal, a method defined using a particular type for one of its arguments is more specific than one defined for a supertype for the same argument.</p>
<p class="indent">To determine which method to call, the compiler examines <em class="calibre11">all</em> of the arguments. This procedure for method selection, or <em class="calibre11">dispatch</em>, is called <em class="calibre11">multiple dispatch</em> for this reason. It is an unusual, but not unique, feature in the landscape of programming languages, and it’s a major reason for Julia’s power and success.</p>
<p class="indent">In contrast, object-oriented languages dispatch solely on the first argument of a method, often supplied implicitly as the object the method is part of and represented within the procedure with variables such as <span class="literal">this</span> or <span class="literal">self</span>.</p>
<p class="indent">Functional languages have no real dispatch mechanism at all. All specialization must take the form of alternative code paths within one large function.</p>
<p class="indent">Julia’s multiple dispatch paradigm means that it is neither an object-oriented nor a functional language, but something more general and flexible than either of them.<span epub:type="pagebreak" id="page_230"/></p>
<h4 class="h3" id="ch08lev1sec6"><strong class="calibre2"><em class="calibre4">Creating Multiple Methods</em></strong></h4>
<p class="noindent">Our definition of <span class="literal">weather_report()</span> included a check that the supplied argument was the correct type and a measure to take in case it wasn’t, implemented in an <span class="literal">if</span> block. We can eliminate that check by restarting the REPL and replacing the definition of <span class="literal">weather_report()</span> with two other methods with different signatures:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function weather_report(raining::Bool)</span>
           <span class="codestrong">if raining
               n = ""
           else
               n = "not "
           end
           gf = "London"
           println("It is $(n)raining in $gf today.")
        end</span>

weather_report (generic function with 1 method)

julia&gt; <span class="codestrong">function weather_report(raining)
           println("Please tell us if it's raining with \"true\" or \"false\".")
           return
       end</span>

weather_report (generic function with 2 methods)</pre>
<p class="indent">After the first definition, the REPL replies with the same message as before, but after the second, we are informed that <span class="literal">weather_report()</span> now has two methods. The only difference between our two methods is that the first has a type specification for the single argument, <span class="literal">raining</span>, in its signature, whereas the second does not. The absence of a type specification means that the compiler will accept an argument with any type, or, said another way, with the <span class="literal">Any</span> type. The rule is that the compiler will always select the most specific method for the arguments supplied. If we supply a <span class="literal">Bool</span> (<span class="literal">true</span> or <span class="literal">false</span>), the first method is selected, because it’s more specific than the second, as <span class="literal">Bool</span> is a subtype of <span class="literal">Any</span>. Any other type dispatches the second method, and the request to supply <span class="literal">true</span> or <span class="literal">false</span>.</p>
<p class="indent">Let’s verify that the two methods work the way we expect:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">weather_report(true)</span>
It is raining in London today.

julia&gt; <span class="codestrong">weather_report(17)</span>
"Please tell us if it's raining with "true" or "false"."</pre>
<p class="indent">This technique of creating a collection of methods rather than cramming a bunch of type-checking code into one larger function is more idiomatic to <span epub:type="pagebreak" id="page_231"/>Julia and leads to better-organized projects that are easier to maintain and extend.</p>
<p class="indent">Suppose we wanted to extend the function by giving it the ability to comment on the weather in a city supplied by the user. The power of multiple dispatch allows us to simply add another method without changing anything we’ve already written:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function weather_report(raining::Bool, city::String)</span>
           <span class="codestrong">if raining
               n = ""
           else
               n = "not "
           end
               println("It is $(n)raining in $city today.")
       end</span>

weather_report (generic function with 3 methods)

julia&gt; <span class="codestrong">weather_report(true, "Tegucigalpa")</span>
It is raining in Tegucigalpa today.</pre>
<p class="indent">If we try to call <span class="literal">weather_report()</span> with arguments that don’t match the signature of any existing method, we get an error message:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">weather_report(true, 17)</span>
ERROR: MethodError: no method matching weather_report(::Bool, ::Int64)
Closest candidates are:
  weather_report(::Bool) at REPL[1]:1
  weather_report(::Bool, ::String) at REPL[7]:1
  weather_report(::Any) at REPL[4]:1</pre>
<p class="indent">The error message tells us that none of the methods of <span class="literal">weather_report()</span> have the right signature and lists some of the available methods, showing the types we can use for their arguments. We’ll get a similar error if we, for instance, try to add two things that can’t be added, such as <span class="literal">1 + "1"</span>, but the three or so possible methods mentioned in the error message will be a small fraction of the over 200 methods defined for the <span class="literal">+</span> operator. To see a list of all the methods defined for any function, call <span class="literal">methods()</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">methods(weather_report)</span>
# 3 methods for generic function "weather_report":
[1] weather_report(raining::Bool) in Main at REPL[1]:1
[2] weather_report(raining::Bool, city::String) in Main at REPL[7]:1
[3] weather_report(raining) in Main at REPL[4]:1</pre>
<p class="noindent">Here we see the list of methods we’ve defined for <span class="literal">weather_report()</span> with their method signatures.<span epub:type="pagebreak" id="page_232"/></p>
<h4 class="h3" id="ch08lev1sec7"><strong class="calibre2"><em class="calibre4">Extending Built-in Functions with New Methods</em></strong></h4>
<p class="noindent">Suppose we had a program that reads numbers from a file, or from user input, and adds them to an existing number. The read-in values would be strings, and the program would have to convert them to numbers before performing the addition. <a href="ch08.xhtml#ch8lis4" class="calibre10">Listing 8-4</a> shows a case like this, where we might decide to eliminate the explicit conversion step from the program by adding a method to <span class="literal">+</span> that does the conversion automatically.</p>
<pre class="calibre13">import Base.+
function +(a::Number, b::String)
    if Meta.parse(b) isa Number
        return a + Meta.parse(b)
    else
        return a
    end
end</pre>
<p class="list" id="ch8lis4"><em class="calibre11">Listing 8-4: Extending addition with a new method</em></p>
<p class="indent">We’re not allowed to extend certain basic functions, such as <span class="literal">+</span>, unless we first explicitly import them, which is accomplished in the first line. After defining this method, it will be dispatched on any attempt to add a string to a number, something that normally results in a <span class="literal">MethodError</span>. If the <span class="literal">String</span> argument can be parsed as a <span class="literal">Number</span>, that number is added to the first argument and the method returns the result. If it can’t, the method simply returns the first argument. This method definition is an example of the use of abstract types in signatures. It will work for any type of number in the first argument, without the need to write definitions for each subtype of <span class="literal">Number</span>.</p>
<p class="indent">Let’s check that this method works as intended:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">1 + "16"</span>
17

julia&gt; <span class="codestrong">1 + "16.0"</span>
17.0

julia&gt; <span class="codestrong">1 + "sixteen"</span>
1

julia&gt; <span class="codestrong">1//2 + "3"</span>
7//2

julia&gt; π <span class="codestrong">+ "1"</span>
4.141592653589793</pre>
<p class="indent">We’ve added to the language by extending the behavior of one of its basic operators. Multiple dispatch gives us the power to do this without altering any existing methods.<span epub:type="pagebreak" id="page_233"/></p>
<div class="box">
<p class="boxtitle-d"><strong class="calibre2">DON’T BE A PIRATE</strong></p>
<p class="noindent">We would never place methods such as the one defined in <a href="ch08.xhtml#ch8lis4" class="calibre10">Listing 8-4</a> in a public package. That’s because we are responsible neither for the “+” function nor the data types in our new method definition. Someone importing our package may suffer conflicts or unexpected behavior. With the great power to extend the language comes great responsibility: transgressing this expectation is called <em class="calibre11">type piracy</em>. If we want to make our method public, we have three choices: name it something besides “+”; have it operate on our own string-like data type; or make a pull request on GitHub for inclusion in <span class="literal">Base</span>. The last option will endow “+” with a new method in addition to its current paltry 207, and all Julia users will automatically have the benefit of our creation.</p>
</div>
<p class="indent">Specialized methods are not only useful for creating new behaviors, they’re sometimes created for efficiency. For example, operations such as matrix multiplication or matrix inverse produce mathematically well-defined results (when they exist); however, for matrices with certain properties, specialized algorithms for computing that result may be more efficient than a general algorithm. The <span class="literal">SparseArrays</span> package (see “The Adjacency Matrix” on <a href="ch07.xhtml#ch07lev1sec1" class="calibre10">page 196</a>) provides methods for these matrix operations that are more efficient when one or both of the arguments is a sparse array. Multiple dispatch will automatically select the ideal method when a matrix operator is passed a sparse array, without any intervention needed on the part of the user.</p>
<p class="indent">Although we can create new methods to do anything we want, it makes sense that their behavior be conceptually related to the purpose or meaning of the generic function that they are a part of. Each of the over 200 methods for <span class="literal">+</span> has something to do with the idea of addition, as does the new method that we’ve defined here. Multiple dispatch should be seen as a paradigm for code organization rather than a license for chaos. The language does nothing to enforce this principle, which depends on the discipline of the programmer.</p>
<h4 class="h3" id="ch08lev1sec8"><strong class="calibre2"><em class="calibre4">Understanding Union Types and the &lt;: Operator</em></strong></h4>
<p class="noindent">Sometimes, when constructing a method, a single abstract type is not general enough for our purposes. In such cases, we can declare an argument to have any one of several types using <span class="literal">Union{}</span>. This is an operator that accepts a list of types and constructs a new type that includes all of them. A value that has the type of anything in the list belongs to the new union type. Also, a type that is a subtype of any of the types in the list is a subtype of the union.</p>
<p class="indent">The <span class="literal">&lt;:</span> infix operator is a test that acts on types and returns <span class="literal">true</span> if the type on its left is a subtype of the type on its right. This example illustrates the creation of a union type and the use of the <span class="literal">&lt;:</span> operator:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">17 isa Union{Number, String}</span>
true



julia&gt; <span class="codestrong">Real &lt;: Union{Number, String}</span>
true</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_234"/>Because <span class="literal">17</span> is a <span class="literal">Number</span>, the first expression returns <span class="literal">true</span>.</p>
<p class="indent">Suppose we want to write a function that acts on real numbers other than integers: numbers with a decimal point. We might consider using a type declaration in the function signature such as <span class="literal">n::AbstractFloat</span>, which would include all the concrete floating types, such as <span class="literal">Float64</span> and <span class="literal">Float32</span>. However, examining <a href="ch08.xhtml#ch8fig2" class="calibre10">Figure 8-2</a> reminds us that this declaration would exclude any number supplied as an <span class="literal">Irrational</span>. If the user stuck in a literal <span class="codeitalic1">π</span> as an argument, a <span class="literal">MethodError</span> would be the result. We can use a union type to handle this scenario: <span class="literal">n::Union{AbstractFloat, Irrational}</span>. We might also consider adding <span class="literal">Rational</span> to the union, depending on the purpose of the function.</p>
<h3 class="h2" id="ch08lev3"><strong class="calibre2">User-Defined Types</strong></h3>
<p class="noindent">Just as we can create our own verbs (functions and methods) for our own purposes, we can create our own nouns (data types) as well. The purpose of user-defined types in Julia is the same as the main purpose of types in general: to organize projects around methods that can be dispatched based on the types of their arguments.</p>
<h4 class="h3" id="ch08lev1sec9"><strong class="calibre2"><em class="calibre4">Creating Abstract Types</em></strong></h4>
<p class="noindent">Sometimes, rather than simply adding a leaf to the tree of types we will want to add a branch and then create types as leaves attached to that branch. As we mentioned earlier, these branches are <em class="calibre11">abstract</em> types, and we can make our own with the <span class="literal">abstract type</span> declaration. As an example of its use, here is how to create a new abstract type descended from the <span class="literal">Number</span> type:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">abstract type MyNumber &lt;: Number end</span></pre>
<p class="noindent">After executing this statement, the new type <span class="literal">MyNumber</span> will be a subtype of the existing abstract type <span class="literal">Number</span> (recall that concrete types cannot be subtyped).</p>
<p class="indent">If the new type is something really new that won’t share methods with existing types, there’s no need for it to inherit from any existing type. However, if it is a new type of number, string, or other existing type, it makes sense to place it appropriately in the type hierarchy. This way, existing methods that act on the <span class="literal">Number</span> type, for example, will be able to handle the new subtype of number.</p>
<h4 class="h3" id="ch08lev1sec10"><strong class="calibre2"><em class="calibre4">Creating Composite Types</em></strong></h4>
<p class="noindent">The purpose of creating a new abstract type is to be able to define new types as its subtypes, types that actually hold values and that we manipulate in calculations. These new types can either descend directly from <span class="literal">Any</span> or descend from an abstract type that we create.</p>
<p class="indent"><span epub:type="pagebreak" id="page_235"/>In almost all cases, these new types will be <em class="calibre11">composite types</em>, defined in a <span class="literal">struct</span> block:</p>
<pre class="calibre13">struct EarthLocation
    latitude::Float64
    longitude::Float64
    timezone::String
end</pre>
<p class="indent">Composite types typically have several fields (but may have only one). The new <span class="literal">EarthLocation</span> type is intended to represent a location on Earth by its latitude and longitude and includes a field for the location’s time zone. The type declarations on the fields are optional; a field without a declaration will be of the <span class="literal">Any</span> type.</p>
<p class="indent">The following creates a variable with this type:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">NYC = EarthLocation(40.7128, -74.006, "ET")</span>

julia&gt; <span class="codestrong">typeof(NYC)</span>
EarthLocation</pre>
<p class="noindent">This function, created by Julia using the same name as the type, is called a <em class="calibre11">constructor</em>. As the second interaction shows, it creates values with the <span class="literal">EarthLocation</span> type.</p>
<p class="indent">We can access a composite type’s field values using property notation:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">NYC.latitude</span>
40.7128

julia&gt; <span class="codestrong">NYC.timezone</span>
"ET"</pre>
<p class="indent">The fields are assigned in the order in which they appear in the type’s definition.</p>
<p class="indent">Since a constructor is a function, we can define multiple methods for it. Here is one that handles the case where the caller supplies coordinates but no time zone:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">EarthLocation(a, b) = EarthLocation(a, b, "Unknown")</span>
EarthLocation

julia&gt; <span class="codestrong">someplace = EarthLocation(59.45607, -135.316681)</span>
EarthLocation(59.45607, -135.316681, "Unknown")

julia&gt; <span class="codestrong">someplace.timezone</span>
"Unknown"</pre>
<p class="indent">The method dispatched when the caller uses only two arguments calls the original method with <span class="literal">"Unknown"</span> as the time zone. This method could have done anything, but naming it the same as the constructor for <span class="literal">EarthLocation</span> <span epub:type="pagebreak" id="page_236"/>types and having it return something other than an instance of that type would be confusing. As mentioned in “Parametric Types” on <a href="ch08.xhtml#ch08lev6" class="calibre10">page 248</a>, we should exploit the type system and multiple dispatch to make our code easier to understand, rather than the opposite.</p>
<p class="indent">Suppose we decide to use a different convention for recording time zones, and try to make some changes to existing variables:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">NYC.timezone = "America/New_York"</span>
ERROR: setfield!: immutable struct of type EarthLocation cannot be changed</pre>
<p class="noindent">Julia objects to what seems like a reasonable attempt to assign a new value to one of the fields of <span class="literal">NYC</span>. By default, composite types are immutable, which permits the compiler to generate more efficient code in some circumstances. If a program requires types whose field values can be changed, we need to explicitly define our type using the <span class="literal">mutable</span> keyword:</p>
<pre class="calibre13">mutable struct MutableEarthLocation
    latitude::Float64
    longitude::Float64
    timezone::String
end</pre>
<p class="noindent">With this definition, we can alter variables with the <span class="literal">MutableEarthLocation</span> type:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">NYC = MutableEarthLocation(40.7128, -74.006, "ET")</span>
MutableEarthLocation(40.7128, -74.006, "ET")

julia&gt; <span class="codestrong">NYC.timezone = "US/Eastern"</span>
"US/Eastern"

julia&gt; <span class="codestrong">NYC</span>
MutableEarthLocation(40.7128, -74.006, "US/Eastern")</pre>
<p class="indent">We can change the values of fields of mutable composite types at will. However, when this isn’t necessary, such as when the type represents a permanent object that should not be mutated, it’s generally better to define it without the <span class="literal">mutable</span> keyword.</p>
<h4 class="h3" id="ch08lev1sec11"><strong class="calibre2"><em class="calibre4">Using Composite Types</em></strong></h4>
<p class="noindent">Let’s explore a simple example that shows the usefulness of creating our own types, along with methods designed to operate on them. The idea is to define a couple of types representing circles. They’ll be somewhat different from each other, but since they both represent circles, they will have some commonality. We plan to write some methods that are specialized to our two circle types, and at least one that should be applicable to both (or more, if we extend the project in the future). This situation calls for the creation of <span epub:type="pagebreak" id="page_237"/>an abstract type to represent circles in general, from which we’ll derive each composite circle type:</p>
<pre class="calibre13">abstract type Circle end</pre>
<p class="indent">If we’re not concerned <em class="calibre11">where</em> a circle is, we can define it completely by its radius. With this in mind, let’s define our first composite circle type to have only one field:</p>
<pre class="calibre13">struct FloatingCircle &lt;: Circle
    r::Real
end</pre>
<p class="noindent">Here <span class="literal">r</span> represents the circle’s radius, which can be any <span class="literal">Real</span> number. The type <span class="literal">FloatingCircle</span> is a subtype of our abstract <span class="literal">Circle</span> type:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">supertypes(FloatingCircle)</span>
(FloatingCircle, Circle, Any)</pre>
<p class="indent">Our next circle type also contains information about the shape’s position in space:</p>
<pre class="calibre13">struct PositionedCircle &lt;: Circle
    x::Real
    y::Real
    r::Real
end</pre>
<p class="noindent">Of course, <span class="literal">PositionedCircle</span> is also defined as a subtype of <span class="literal">Circle</span>. The real numbers <span class="literal">x</span> and <span class="literal">y</span> are intended to hold the coordinates of its center. The abstract <span class="literal">Circle</span> type now has two subtypes:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">subtypes(Circle)</span>
2-element Vector{Any}:
 FloatingCircle
 PositionedCircle</pre>
<p class="noindent">What we have so far might be the beginnings of a package to perform some geometrical calculations.</p>
<p class="indent">Suppose the next step is to write a function that calculates the area of a circle. This area doesn’t depend on where the circle happens to be, only on its radius. Therefore, it should accept either subtype of the abstract <span class="literal">Circle</span> type and any future subtype that we might come up with:</p>
<pre class="calibre13">function circle_area(c::Circle)
    return π * c.r^2
end</pre>
<p class="indent"><span epub:type="pagebreak" id="page_238"/>The <span class="literal">circle_area()</span> function’s signature demands that the type of its argument is a subtype of <span class="literal">Circle</span>. If it is, it will have a radius, which, by convention, we call <span class="literal">r</span> in all of our circular composite types:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">c1 = FloatingCircle(1)</span>
   FloatingCircle(1)

   julia&gt; <span class="codestrong">c1.r</span>
   1

<span class="ent">➊</span> julia&gt; <span class="codestrong">circle_area(c1)</span>
   3.141592653589793

   julia&gt; <span class="codestrong">c2 = PositionedCircle(2, 2, 1)</span>
   PositionedCircle(2, 2, 1)

   julia&gt; <span class="codestrong">c2.x, c2.y</span>
   (2, 2)

   julia&gt; <span class="codestrong">c2.r</span>
   1

<span class="ent">➋</span> julia&gt; <span class="codestrong">circle_area(c2)</span>
   3.141592653589793

   julia&gt; <span class="codestrong">circle_area(17)</span>
   ERROR: MethodError: no method matching circle_area(::Int64)</pre>
<p class="indent">After confirming that the new function calculates areas correctly for both <span class="literal">FloatingCircle</span>s <span class="ent">➊</span> and <span class="literal">PositionedCircle</span>s <span class="ent">➋</span>, we forget that <span class="literal">circle_area()</span> deals only with subtypes of <span class="literal">Circle</span> and try to hand it a number, which results in a <span class="literal">MethodError</span>.</p>
<p class="indent">Let’s add one more function to this geometry project: a routine that takes two circles and tells us if the second circle is entirely within the first.</p>
<pre class="calibre13">function is_inside(c1::PositionedCircle, c2::PositionedCircle)
    d = sqrt((c2.x - c1.x)^2 + (c2.y - c1.y)^2)
    return d + c2.r &lt; c1.r # true if c2 is inside c1
end</pre>
<p class="indent">The function calculates the distance between the centers of the two circles using their x- and y-coordinates, and then checks whether one lies inside the other by referring to their radii. Of course, the concept of a circle being “inside” another makes sense only if we can say where the circles are, so the new function accepts only <span class="literal">PositionedCircle</span>s and will have only one method.</p>
<p class="indent"><span epub:type="pagebreak" id="page_239"/>Let’s try it:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = PositionedCircle(2, 2, 2)</span>
PositionedCircle(2, 2, 2)

julia&gt; <span class="codestrong">b = PositionedCircle(1, 1, 0.5)</span>
PositionedCircle(1, 1, 0.5)

julia&gt; <span class="codestrong">is_inside(a, b)</span>
true

julia&gt; <span class="codestrong">c = PositionedCircle(3, 3, 1)</span>
PositionedCircle(3, 3, 1)

julia&gt; <span class="codestrong">is_inside(a, c)</span>
false</pre>
<p class="indent">It seems to be working, but to be sure, it will help to make a diagram. We can draw our three circles using <span class="literal">Luxor</span> in a program similar to the one in <a href="ch07.xhtml#ch7lis1" class="calibre10">Listing 7-1</a>:</p>
<pre class="calibre13">using Luxor
@pdf begin
    origin(Point(30, 30))
 <span class="ent">➊</span> scale(100, 100)
    fontsize(0.32)
    fontface("Liberation Sans")
    setdash("solid")
    setcolor("black")
    circle(Point(2, 2), 2, :stroke)
    text("a", Point(1, 3))
    setcolor("blue")
    circle(Point(1, 1), 0.5, :stroke)
    text("b", Point(1, 1))
    setcolor("green")
    circle(Point(3, 3), 1, :stroke)
    text("c", Point(3, 3))
end 500 500 "circles.pdf"</pre>
<p class="indent">The <span class="literal">Luxor</span> package uses points as its unit of length, so we expand our dimensions <span class="ent">➊</span> to make a reasonably sized illustration. The labels on the circles are the same as the names we gave them before. <a href="ch08.xhtml#ch8fig3" class="calibre10">Figure 8-3</a> shows the diagram that this program creates, where we can see that the <span class="literal">is_inside()</span> function calculates the “inside” relationship correctly.<span epub:type="pagebreak" id="page_240"/></p>
<div class="image1"><img alt="Image" id="ch8fig3" src="../images/ch08fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-3: Circle b is inside a, but c is not.</em></p>
<p class="indent">We know how to enforce types used in constructors for user-defined types. But what if we want to constrain the allowed values passed to the constructors? Here’s how to make a type like our <span class="literal">FloatingCircle</span> that demands a positive radius:</p>
<pre class="calibre13">struct ReasonableCircle &lt;: Circle
    r::Real
 <span class="ent">➊</span> ReasonableCircle(r) =
        if r &gt;= 0
            new(r)
        else
            @error("It's not reasonable to make a circle with a negative radius.")
        end
end

julia&gt; <span class="codestrong">ReasonableCircle(-12)</span>
 Error: It's not reasonable to make a circle with a negative radius.
 @ Main REPL[4]:7

julia&gt; <span class="codestrong">ReasonableCircle(12).r</span>
12</pre>
<p class="indent">As with functions, constraints on the values passed as arguments must be enforced in the body. The method inside the body <span class="ent">➊</span> is called an <em class="calibre11">inner constructor</em>; the other constructors we’ve been using up to now are <em class="calibre11">outer constructors</em>. The function <span class="literal">new()</span> creates the instance. It’s used only inside inner constructors.</p>
<p class="indent">Those who have experience with a class-based object-oriented language, such as Python, are sometimes at a temporary disadvantage when trying to absorb the concept of a user-defined composite type in Julia. We all have a tendency, when confronting a new concept, to relate it to concepts that are <span epub:type="pagebreak" id="page_241"/>familiar to us. Composite types in Julia are not classes; Julia has no classes and, obviously, no class inheritance. In an object-oriented language, the next step would be to define methods as part of the class: the nouns and verbs are bound together. The more flexible multiple dispatch paradigm decouples nouns and verbs. Julia programmers are free to write methods that act upon any combination of types and to create new types at will, without friction.</p>
<h4 class="h3" id="ch08lev1sec12"><strong class="calibre2"><em class="calibre4">Defining structs with Base.@kwdef</em></strong></h4>
<p class="noindent">The default method for defining composite types leaves a bit to be desired. Its main deficiency is that the constructor it creates requires the programmer to remember the order in which a type’s fields appear in its definition. The <span class="literal">Base.@kwdef</span> macro improves on this limitation by creating constructors that we can use with field names. For repeated use, it’s convenient to import this macro and rename it: <span class="literal">import Base.@kwdef as @kwdef</span>.</p>
<p class="indent">Let’s expand our geometry package with a new type representing ellipses as shown in <a href="ch08.xhtml#ch8lis5" class="calibre10">Listing 8-5</a>. This time we’ll use <span class="literal">@kwdef</span>.</p>
<pre class="calibre13">@kwdef struct Ellipse
    axis1::Real = 1
    axis2::Real = 1
end</pre>
<p class="list" id="ch8lis5"><em class="calibre11">Listing 8-5: Defining an</em> <span class="codeitalic">Ellipse</span> <em class="calibre11">type with</em> <span class="codeitalic">@kwdef</span></p>
<p class="noindent">This definition shows the second convenient feature of <span class="literal">@kwdef</span>: we can supply default values for fields. We also have the option to define a mutable struct with <span class="literal">@kwdef mutable struct</span>.</p>
<p class="indent">Let’s make an ellipse and assign it to a variable:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">oval = Ellipse(axis2=2.6)</span>
Ellipse(1, 2.6)

julia&gt; <span class="codestrong">oval.axis1, oval.axis2</span>
(1, 2.6)</pre>
<p class="indent">This example shows how we can supply a subset of the type’s keyword arguments, and the ones we omit will get their default arguments. As with functions, any keyword argument without a default in the type definition must be supplied when using the constructor. Also, similarly to functions, we may not mix positional and keyword forms:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">Ellipse(2, 3)</span>
Ellipse(2, 3)

julia&gt; <span class="codestrong">Ellipse(2, axis2=3)</span>
ERROR: MethodError: no method matching Ellipse(::Int64; axis2=3)</pre>
<p class="indent"><span epub:type="pagebreak" id="page_242"/>As there is no drawback to using <span class="literal">@kwdef</span> when defining composite types, it’s convenient to use it routinely.</p>
<p class="indent">Because of the way Julia’s JIT compiler works with the type system, computing with user-defined types is as fast as using native types. We can work at a higher level of abstraction, creating a set of types that naturally conform to the objects in our problem, without any compromise in performance.</p>
<h3 class="h2" id="ch08lev4"><strong class="calibre2">Performance Tips</strong></h3>
<p class="noindent">Speed and efficiency are often of great concern in scientific programming. While Julia generally produces performant code without requiring extreme expertise or knowledge of internals, good performance does sometimes depend on an awareness of the compilation process.</p>
<p class="indent">I’ve included topics related to performance in various places throughout this book. Here we’ll learn about several such issues specifically related to types.</p>
<h4 class="h3" id="ch08lev1sec13"><strong class="calibre2"><em class="calibre4">Vanquish Type Instability</em></strong></h4>
<p class="noindent"><em class="calibre11">Type stability</em> is perhaps the single most important performance-related concept in Julia. Its central principle is that the return values of functions should have types we can predict based on the types of the arguments supplied to the function. The returned type should not depend on the <em class="calibre11">values</em> of the arguments. A secondary issue is that the local variables used within a function should not change type.</p>
<p class="indent">Suppose we want to have a function for dividing two numbers that would return <span class="literal">0</span> when the denominator is <span class="literal">0</span>, rather than <span class="literal">Inf</span>. <a href="ch08.xhtml#ch8lis6" class="calibre10">Listing 8-6</a> shows one way to write such a function.</p>
<pre class="calibre13">function safe_divide(a, b)
    if b == 0
        return 0
    else
        return a/b
    end
end</pre>
<p class="list" id="ch8lis6"><em class="calibre11">Listing 8-6: This function needs improving.</em></p>
<p class="indent">It certainly seems to work as intended:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">safe_divide(1, 2)</span>
0.5

julia&gt; <span class="codestrong">safe_divide(1, 0)</span>
0</pre>
<p class="indent"><span epub:type="pagebreak" id="page_243"/>However, the sharp-eyed programmer may notice that in the first case, the function returns a <span class="literal">Float64</span>, whereas in the second case it returns an <span class="literal">Int64</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">typeof(safe_divide(1, 2))</span>
Float64

julia&gt; <span class="codestrong">typeof(safe_divide(1, 0))</span>
Int64</pre>
<p class="indent">The types of the arguments in both cases are integers, but the types of the results depend on their values. This type instability may not matter. However, an insidious problem is lurking, as one day we may pull out our <span class="literal">safe_divide()</span> function to use within some other program where its varying return type affects performance.</p>
<p class="indent">In more complicated functions, the type instability may not be so obvious. In situations where performance or memory consumption makes us wonder whether one of our functions may have such an issue, Julia provides a convenient tool for ferreting out type instability: the <span class="literal">@code_warntype</span> macro. Let’s use it on our <span class="literal">safe_divide()</span> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">@code_warntype safe_divide(1, 2)</span>
MethodInstance for safe_divide(::Int64, ::Int64)
  from safe_divide(a, b) in Main at REPL[7]:1
Arguments
  #self#::Core.Const(safe_divide)
  a::Int64
  b::Int64
Body<span class="codestrong">::Union{Float64, Int64}</span>
1 - %1 = (b == 0)::Bool
--      goto #3 if not %1
2 -      return 0
3 - %4 = (a / b)::Float64
--      return %4</pre>
<p class="indent">This is one of several macros and functions available for use in the REPL that display a translated version of a Julia function. The <span class="literal">@code_warntype</span> macro prints a <em class="calibre11">lowered form</em> of the code: a representation of the computation in terms of a smaller set of operations. It is one of four stages of code transformation beginning with our Julia source and ending with machine code specific to the processor we’re running on. This lowered form is similar to the version that is sent to the compiler, but it contains the type information that we can examine when debugging performance issues. Other than that, it’s not particularly useful and not intended for routine human consumption.</p>
<p class="indent">When printed in the REPL, type information that indicates a possible type stability issue is displayed in red type, which I’ve converted to bold for printing in the book. The bold fragment indicates that the return type can <span epub:type="pagebreak" id="page_244"/>be either a <span class="literal">Float64</span> or an <span class="literal">Int64</span>: in other words, it’s not determined from the types of the input arguments. This is the signature of a type-unstable function.</p>
<p class="indent">Fortunately, this case has a simple fix:</p>
<pre class="calibre13">function safe_divide2(a, b)
    if b == 0
     <span class="ent">➊</span> return 0.0
    else
        return a/b
    end
end</pre>
<p class="indent">Since <span class="literal">a/b</span> is always a float, even if <span class="literal">a</span> and <span class="literal">b</span> are integers, we can ensure that the function always returns a float by replacing the integer <span class="literal">0</span> with <span class="literal">0.0</span> <span class="ent">➊</span>.</p>
<p class="indent">To confirm whether we’ve fixed the type instability problem, let’s turn to <span class="literal">@code_warntype</span> again:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">@code_warntype safe_divide2(1, 2)</span>
   MethodInstance for safe_divide2(::Int64, ::Int64)
     from safe_divide2(a, b) in Main at REPL[5]:1
   Arguments
     #self#::Core.Const(safe_divide2)
     a::Int64
     b::Int64
<span class="ent">➊</span> Body::Float64
   1 - %1 = (b == 0)::Bool
   --      goto #3 if not %1
   2 -      return 0.0
   3 - %4 = (a / b)::Float64
   --      return %4</pre>
<p class="indent">This time, there are no red (bold) warnings, and the macro confirms <span class="ent">➊</span> that the return type is always a <span class="literal">Float64</span>.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The output from</em> <span class="codeitalic1">@code_warntype</span> <em class="calibre11">often also includes yellow warnings involving unions with the</em> <span class="codeitalic1">Nothing</span> <em class="calibre11">type, which is used when a function does not return a result. These are not usually considered type instabilities.</em></p>
</div>
<p class="indent">We can also correct this type stability problem by defining the function using a type declaration:</p>
<pre class="calibre13">function safe_divide_typed(a, b)::Float64
    if b == 0
        return 0
    else
        return a/b
    end
end</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_245"/>This version, when called with <span class="literal">b = 0</span>, will convert its return value to <span class="literal">0.0</span>. It will always return a <span class="literal">Float64</span>; <span class="literal">@code_warntype</span> will verify its type stability.</p>
<p class="indent">Although the form of the code returned by <span class="literal">@code_warntype</span> can be difficult to parse, it’s fairly simple to use it to scan for type stability problems.</p>
<h4 class="h3" id="ch08lev1sec14"><strong class="calibre2"><em class="calibre4">Avoid Changing the Types of Variables</em></strong></h4>
<p class="noindent">Let’s write a function to approximate π using the Leibniz sum:</p>
<div class="image"><img alt="Image" src="../images/math245.jpg" class="calibre6"/></div>
<p class="indent">This is not a good way to get the digits of π, as it converges quite slowly, but it’ll be useful for our demonstration. One version of the function might be:</p>
<pre class="calibre13">function leibπ(N)
    s = 0
    for n in 1:N
        s += (-1)^(n+1) * 1/(2n-1)
    end
    return 4.0s
end</pre>
<p class="indent">This works as intended; <a href="ch08.xhtml#ch8fig4" class="calibre10">Figure 8-4</a> shows its output gradually converging to the correct value for π.</p>
<div class="image1"><img alt="Image" id="ch8fig4" src="../images/ch08fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-4: The Leibniz sum approximation to π</em></p>
<p class="indent">This function is clearly not type-unstable in the sense used earlier: the output is always a <span class="literal">Float64</span>, regardless of the number supplied as an argument.</p>
<p class="indent"><span epub:type="pagebreak" id="page_246"/>Nevertheless, taking a look at the output of <span class="literal">@code_warntype</span> indicates a problem:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">@code_warntype leibπ(100)</span>
MethodInstance for leibπ(::Int64)
  from leibπ(N) in Main at REPL[33]:1
Arguments
  #self#::Core.Const(leibπ)
  N::Int64
Locals
  @_3::Union{Nothing, Tuple{Int64, Int64}}
  <span class="codestrong">s::Union{Float64, Int64}</span>
  n::Int64
Body::Float64
1 -       (s = 0)
|   %2  = (1:N)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])
|         (@_3 = Base.iterate(%2))
|   %4  = (@_3 === nothing)::Bool
|   %5  = Base.not_int(%4)::Bool
--       goto #4 if not %5
2   %7  = @_3::Tuple{Int64, Int64}
|         (n = Core.getfield(%7, 1))
|   %9  = Core.getfield(%7, 2)::Int64
|   %10 = <span class="codestrong">s::Union{Float64, Int64}</span>
|   %11 = (n + 1)::Int64
|   %12 = ((-1) ^ %11)::Int64
|   %13 = (%12 * 1)::Int64
|   %14 = (2 * n)::Int64
|   %15 = (%14 - 1)::Int64
|   %16 = (%13 / %15)::Float64
|         (s = %10 + %16)
|         (@_3 = Base.iterate(%2, %9))
|   %19 = (@_3 === nothing)::Bool
|   %20 = Base.not_int(%19)::Bool
--       goto #4 if not %20
3 -       goto #2
4   %23 = (4.0 * s)::Float64
--       return %23</pre>
<p class="indent">Once again, the warnings are rendered in bold. They inform us that the local variable <span class="literal">s</span> is a union of the types <span class="literal">Float64</span> and <span class="literal">Int64</span>, rather than a single numerical type. This happens because we initialize it as a literal integer, <span class="literal">0</span>, but then use it in a loop that causes Julia to promote it to a float.</p>
<p class="indent">Changing the type of a local variable may prevent the compiler from optimizing our code as well as it could otherwise. This is a common mistake, as the pattern of initializing variables and then using them in a <span class="literal">for</span> loop is routine. When doing so, we should take care to initialize them with types appropriate to the arithmetic in the loop.</p>
<p class="indent"><span epub:type="pagebreak" id="page_247"/>This case is also easy to fix:</p>
<pre class="calibre13">function leibπ2(N)
 <span class="ent">➊</span> s = 0.0
    for n in 1:N
        s += (-1)^(n+1) * 1/(2n-1)
    end
    return 4.0s
end</pre>
<p class="noindent">As before, we simply have to replace <span class="literal">0</span> with <span class="literal">0.0</span> <span class="ent">➊</span>. I won’t reproduce the (mostly redundant) output here, but checking with <span class="literal">@code_warntype</span> shows that the warnings are gone.</p>
<h3 class="h2" id="ch08lev5"><strong class="calibre2">Type Aliases</strong></h3>
<p class="noindent">Several types have alternative names, called <em class="calibre11">type aliases</em>. The use of aliases is for convenience; they are typically shorter names or dispense with the indication of the machine’s pointer size. For example, on a 64-bit computer, <span class="literal">Int</span> is another name, or alias, for <span class="literal">Int64</span>, but on a 32-bit machine, <span class="literal">Int</span> means <span class="literal">Int32</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">typeof(17)</span>
Int64

julia&gt; <span class="codestrong">17 isa Int</span>
true

julia&gt; <span class="codestrong">Int === Int64</span>
true</pre>
<p class="noindent">This shows that, at least on my computer, <span class="literal">Int</span> is another name for <span class="literal">Int64</span>.</p>
<p class="indent">We can create our own type aliases:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">const F64 = Float64</span>
Float64

julia&gt; <span class="codestrong">typeof(3.14)</span>
Float64

julia&gt; <span class="codestrong">3.14 isa F64</span>
true</pre>
<p class="noindent">Here we’ve created an alternative name for the default floating-point type. After this definition, we can use <span class="literal">F64</span> and <span class="literal">Float64</span> interchangeably.</p>
<p class="indent">Defining type aliases as <span class="literal">const</span> is not required, but it makes sense, as they are additional names for something that will not change.<span epub:type="pagebreak" id="page_248"/></p>
<h3 class="h2" id="ch08lev6"><strong class="calibre2">Parametric Types</strong></h3>
<p class="noindent">A parametric type is a type made from pieces that themselves can be of several possible types. The parameters are variables that vary with the types of the pieces.</p>
<p class="indent"><a href="ch08.xhtml#ch8lis7" class="calibre10">Listing 8-7</a> shows an example of a parametric type that we’ve already encountered, the type used for complex numbers.</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">typeof(2 + 2im)</span>
   Complex{Int64}

   julia&gt; <span class="codestrong">typeof(2.0 + 2.0im)</span>
   ComplexF64 (alias for Complex{Float64})

   julia&gt; <span class="codestrong">typeof(2.0 + 2im)</span>
<span class="ent">➊</span> ComplexF64 (alias for Complex{Float64})

   julia&gt; <span class="codestrong">typeof(1//2 + 1//2im)</span>
   Complex{Rational{Int64}}</pre>
<p class="list" id="ch8lis7"><em class="calibre11">Listing 8-7: The types of some complex numbers</em></p>
<p class="indent">The curly brackets (<span class="literal">{}</span>) in the type names indicate that we’re dealing with <em class="calibre11">parametric types</em>. In the first line, we’ve asked for the type of a complex number that’s written using integer literals for each coefficient. The response indicates that the number is <span class="literal">Complex</span> with an <span class="literal">Int64</span> parameter; this parameter is the type of the coefficients.</p>
<p class="indent">The second line tells us something similar, but this time the complex number has floating-point coefficients. In addition, we learn about an alias for the type.</p>
<p class="indent">The fact that there is only one parameter within the curly brackets suggests that both coefficients must have the same type. This is indeed true; mixing literal floats and integers causes an automatic conversion of the integer coefficient to a <span class="literal">Float64</span> coefficient <span class="ent">➊</span>.</p>
<p class="indent">In the final example, we’ve created a complex number with <span class="literal">Rational</span> coefficients. This time the parameter is itself a parametric type. Rational numbers can be composed of any integers. The <span class="literal">Rational{Int64}</span> notation means that the numerator and denominator are <span class="literal">Int64</span>s rather than, for example, <span class="literal">Int32</span>s.</p>
<p class="indent">Collection types, such as <span class="literal">Array</span>, are defined as parametric types because they can hold elements of various types:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">typeof([1,2])</span>
   Vector{Int64} (alias for Array{Int64, 1})

   julia&gt; <span class="codestrong">supertype(Vector)</span>
<span class="ent">➊</span> DenseVector (alias for DenseArray{T, 1} where T)

   julia&gt; <span class="codestrong">supertype(DenseVector)</span>
   AbstractVector (alias for AbstractArray{T, 1} where T)</pre>
<p class="indent"><span epub:type="pagebreak" id="page_249"/>The use of aliases is common for collection types, as in these examples. We see here that <span class="literal">Array</span> is a parametric type with two parameters: the first is the type of the array’s elements, and the second is the number of dimensions.</p>
<p class="indent">The <span class="literal">where</span> keyword creates a <span class="literal">UnionAll</span> type, a union of many types, each defined by assigning a particular type to the type variable <span class="literal">T</span>. One example of this is the notation <span class="literal">AbstractArray{T, 1}</span>, where <span class="literal">T</span> denotes an abstract type that is the union of <span class="literal">AbstractArray{Int64, 1}</span>, <span class="literal">AbstractArray{Float64, 1}</span>, and so on.</p>
<p class="indent">We can create our own parametric types for the same reason we create any type: to organize our methods with the help of the type system and multiple dispatch.</p>
<p class="indent">Let’s revisit our <span class="literal">Ellipse</span> type from <a href="ch08.xhtml#ch8lis5" class="calibre10">Listing 8-5</a> and make a parametric version of it:</p>
<pre class="calibre13">@kwdef struct CEllipse{T}
    axis1::T
    axis2::T
end</pre>
<p class="indent">Now the fields can be any type, as long as they are both the same type:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">e1 = CEllipse(12.0, 17.0)</span>
CEllipse{Float64}(12.0, 17.0)

julia&gt; <span class="codestrong">e2 = CEllipse(12.0, "Snails")</span>
ERROR: MethodError: no method matching CEllipse(::Float64, ::String)
Closest candidates are:
  CEllipse(::T, ::T) where T at REPL[67]:2

julia&gt; <span class="codestrong">e2 = CEllipse("Clams", "Snails")</span>
CEllipse{String}("Clams", "Snails")</pre>
<p class="indent">After defining a new <span class="literal">CEllipse</span>, the REPL tells us the type, with <span class="literal">Float64</span> substituted in place of the parameter <span class="literal">T</span>. Our attempt to give the fields two different types failed because they are both <span class="literal">T</span> in the type definition. <span class="literal">T</span> can be anything, but the definition requires that both axes have the same type, so the final example is accepted. But what does it mean to have an ellipse with arbitrary strings for the axes? It’s up to us. We are creating types for our own purposes, to organize our projects. If we prefer to limit the <span class="literal">CEllipse</span> type to have numerical values for the axes, we can use the subtyping operator:</p>
<pre class="calibre13">@kwdef struct CEllipse{T&lt;:Number}
    axis1::T
    axis2::T
end</pre>
<p class="noindent">Before defining this struct, if we’re working in the REPL, we’re obligated to begin a new session if the previous definition of <span class="literal">CEllipse</span> is still active. Another option would be to name it differently.</p>
<p class="indent"><span epub:type="pagebreak" id="page_250"/>Now a <span class="literal">CEllipse</span> can have two axes of the same type, and that type can be anything, as long as it’s a subtype of <span class="literal">Number</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">e2 = CEllipse("Clams", "Snails")</span>
ERROR: MethodError: no method matching CEllipse(::String, ::String)

julia&gt; <span class="codestrong">e2 = CEllipse(1//3, 1//5)</span>
CEllipse{Rational{Int64}}(1//3, 1//5)</pre>
<p class="indent">Since we make <span class="literal">T</span> a subtype of <span class="literal">Number</span>, rather than a subtype of the more specific <span class="literal">Real</span>, we are allowing the possibility of ellipses with complex-valued axes. In some cases, our functions for calculating properties of ellipses will need methods specialized for this case. For an example, let’s write a function that returns the eccentricity of an ellipse. This is a measure of how elongated the ellipse is, where an eccentricity of 0 is a circle. If <em class="calibre11">a</em> is the longer of the two axes and <em class="calibre11">b</em> is the shorter, the eccentricity is given by:</p>
<div class="image"><img alt="Image" src="../images/250math.jpg" class="calibre6"/></div>
<p class="indent">Here’s a direct translation of this formula into a Julia function:</p>
<pre class="calibre13">function eccentricity(e::CEllipse{&lt;:Real})
    a = max(e.axis1, e.axis2)
    b = min(e.axis1, e.axis2)
    return sqrt(a^2 - b^2)/a
end</pre>
<p class="indent">This definition works for real-valued axes, so to ensure that the function accepts only such ellipses, its type parameter specifies subtypes of <span class="literal">Real</span>.</p>
<p class="indent">We can visualize an ellipse with complex-valued axes as lying in the complex plane. We can define ellipses this way as long as we ensure that their axes are perpendicular.</p>
<p class="indent">Let’s make a method of our eccentricity function that handles these ellipses:</p>
<pre class="calibre13">function eccentricity(e::CEllipse{&lt;:Complex})
    a = max(abs(e.axis1), abs(e.axis2))
    b = min(abs(e.axis1), abs(e.axis2))
    return sqrt(abs(a)^2 - abs(b)^2)/abs(a)
end</pre>
<p class="noindent">The <span class="literal">abs()</span> function, when handed a complex number, returns its length. We use the <span class="literal">&lt;:</span> operator in the type parameter slot to include every possible kind of complex number.</p>
<p class="indent">We know a bit more about ellipses with complex axes: not merely their eccentricities, but their orientations. <a href="ch08.xhtml#ch8fig5" class="calibre10">Figure 8-5</a> shows an ellipse in the complex plane.</p>
<div class="image1"><span epub:type="pagebreak" id="page_251"/><img alt="Image" id="ch8fig5" src="../images/ch08fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-5: An ellipse in the complex plane</em></p>
<p class="indent">Its axes, represented by dotted lines, are 2 + 2<em class="calibre11">i</em> and <em class="calibre11">−</em>1 + <em class="calibre11">i</em>. We’ll define the orientation as the angle that its major (longer) axis makes with the real axis, shown in the figure by <em class="calibre11">α</em>.</p>
<p class="indent">Here’s the program that created the illustration in <a href="ch08.xhtml#ch8fig5" class="calibre10">Figure 8-5</a>:</p>
<pre class="calibre13">using Luxor
@pdf begin
    scale(100, 100)
    fontsize(0.22)
    fontface("Liberation Sans")
    setdash("dash") # Coordinate axes
    line(Point(-2, 0), Point(2, 0), :stroke)
    line(Point(0, -2), Point(0, 2), :stroke)
    text("Re", Point(1.6, -0.1))
    text("Im", Point(0.1, -1.8))
    setdash("dot") # Ellipse axes
    line(Point(0, 0), Point(sqrt(2), -sqrt(2)), :stroke)
    line(Point(0, 0), Point(-1/sqrt(2), -1/sqrt(2)), :stroke)
    text("α", Point(0.25, -0.08))
    setdash("solid") # The ellipse
    rotate(-π/4)
    ellipse(0, 0, 4, 2, :stroke)
end 500 500 "ellipse.pdf"</pre>
<p class="indent">Remember, in <span class="literal">Luxor</span> the vertical coordinate goes from the top down, opposite to the conventional direction in mathematical diagrams.</p>
<p class="indent">This function calculates the orientation of an ellipse with complex axes:<span epub:type="pagebreak" id="page_252"/></p>
<pre class="calibre13">function orientation(e::CEllipse{&lt;:Complex})
    if abs(e.axis1) &gt; abs(e.axis2)
        a = e.axis1
    else
        a = e.axis2
    end
    return angle(a)
end</pre>
<p class="noindent">Since no orientation can be defined for an ellipse with axes given only by real-number lengths, <span class="literal">orientation()</span> will have just this one method. The <span class="literal">angle()</span> function returns a complex number’s phase angle; it’s equivalent to <span class="literal">atan(imag(a)/real(a))</span>.</p>
<p class="indent">Let’s define an ellipse with complex axes and calculate its eccentricity and orientation:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">e45 = CEllipse(2 + 2im, -1 + im)</span>
CEllipse{Complex{Int64}}(2 + 2im, -1 + 1im)

julia&gt; <span class="codestrong">eccentricity(e45)</span>
0.8660254037844387

julia&gt; <span class="codestrong">orientation(e45)</span>
0.7853981633974483

julia&gt; <span class="codestrong">orientation(e45) |&gt; rad2deg</span>
45.0</pre>
<p class="noindent">This ellipse corresponds to <a href="ch08.xhtml#ch8fig5" class="calibre10">Figure 8-5</a>. The <span class="literal">orientation()</span> function returns its result in radians, so for good measure, we’ve converted that to degrees in the final expression.</p>
<p class="indent">Parametric types make Julia’s rich type system even more flexible and expressive. Like the other parts of the type system, we’re not required to use any of it in our own programs, but a little bit can go a long way in helping with code organization, reuse, and efficiency. Finally, a basic knowledge of parametric types is essential in understanding the messages and information that Julia sends to us, and in reading language and package documentation.</p>
<h3 class="h2" id="ch08lev7"><strong class="calibre2">Plot Recipes</strong></h3>
<p class="noindent">As authors of programs, modules, and perhaps packages, we should expect to create our own data types routinely. There is no performance penalty for using custom data types in Julia, and they are essential for writing concise, well-organized code and for taking the best advantage of multiple dispatch.</p>
<p class="indent">In <a href="part2.xhtml" class="calibre10">Part II</a> of this book we’ll explore various packages from the Julia scientific ecosystem. Many of these packages define one or a variety of data types that describe the objects they manipulate. These objects include audio signals, solutions to differential equations, images, measurements with uncertainties, entire environments housing interacting creatures, the creatures themselves, and much more. We’ll discover that we can use the plotting <span epub:type="pagebreak" id="page_253"/>commands from <a href="ch04.xhtml" class="calibre10">Chapter 4</a> to visualize these data structures directly, with no preprocessing needed on our part. How is it possible that <span class="literal">Plots</span> knows what to do with all these different data types?</p>
<p class="indent">Visualization is an essential part of scientific computation. The plot <em class="calibre11">recipe</em> system is how we hook our data types into Julia’s plotting system, that is, how we teach it to handle and display our custom objects. The authors of the scientific packages that we use in <a href="part2.xhtml" class="calibre10">Part II</a> did not have to touch the code in the <span class="literal">Plots</span> package, which in turn doesn’t need to know anything about the new data types. Plot recipes insert data transformations into the plotting <em class="calibre11">pipeline</em>, so existing plotting functions can handle our data types as if they were the familiar arrays of numbers.</p>
<p class="indent">The result is that users of our programs need simply call <span class="literal">plot()</span>, <span class="literal">scatter()</span>, or another plotting function on the new data type to get a reasonable visual representation. We can also define entirely new plotting functions for more elaborate visualizations.</p>
<p class="indent">We need a specific application in mind to make the operation of plot recipes clear. Let’s imagine that we’re creating a program that has something to do with the weather, and create some simple data types for representing daily temperature and rainfall data:</p>
<pre class="calibre13">import Base.@kwdef as @kwdef
using Dates

@kwdef struct TempExtremes
    tempunit::String = "°C"
 <span class="ent">➊</span> temps::Vector{Tuple{Float64, Float64}}
end

@kwdef struct WeatherData
    temps::TempExtremes
    rainfall::Vector{Float64}
end

@kwdef struct WeatherReport
    notes::String
    location::Tuple{Float64, Float64}
    data::WeatherData
    start::Dates.Date
end</pre>
<p class="indent">Our temperature data, we’ll suppose, comes to us as two measurements per day, representing that day’s minimum and maximum temperatures. We’ll store these measurements in a vector of tuples <span class="ent">➊</span>, one tuple per day, containing the temperature extrema. That vector of tuples, along with a string holding the temperature unit, are packaged together in the <span class="codeitalic1">TempExtremes</span> data type.</p>
<p class="indent">That data type is put next to a vector of rainfall measurements in another data type called <span class="literal">WeatherData</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_254"/>A third data type, <span class="literal">WeatherReport</span>, contains the <span class="literal">WeatherData</span> along with some notes, a pair of numbers (latitude and longitude) for the location of the measurements, and the date recording when the series of measurements begin.</p>
<p class="indent">Next we make instances of these three data types to have something to plot:</p>
<pre class="calibre13">tmin = randn(60) .+ 15.0
tmax = tmin .+ abs.(randn(60) .+ 3.0)
td = TempExtremes(temps=collect(zip(tmin, tmax)))
wd = WeatherData(rainfall=abs.(randn(60) .* 5.0 .+ 4), temps=td)
wr = WeatherReport(notes="Rainfall and temperature extremes",
                   location=(-72.03, 45.47),
                   data=wd, start=Date(1856, 12, 31))</pre>
<p class="indent">The <span class="literal">randn()</span> function produces normally distributed (see “The Normal Distribution” on <a href="ch10.xhtml#ch10lev1sec3" class="calibre10">page 323</a>) fake random temperature and rain data. Earlier we imported the <span class="literal">Date</span> module so we can use one of its data types to define a starting date.</p>
<h4 class="h3" id="ch08lev1sec15"><strong class="calibre2"><em class="calibre4">The Plotting Pipeline</em></strong></h4>
<p class="noindent">The recipe system consists of a series of four recipe varieties that get processed in order in the plotting pipeline, as shown in <a href="ch08.xhtml#ch8lis8" class="calibre10">Listing 8-8</a>.</p>
<pre class="calibre13">user recipes:
    user types =&gt; user types, numerical arrays

type recipes:
    user types =&gt; numerical arrays

plot recipes:
    numerical arrays =&gt; series
        and
    series =&gt; series

series recipes:
    numerical arrays =&gt; series
        and
    series =&gt; series</pre>
<p class="list" id="ch8lis8"><em class="calibre11">Listing 8-8: The plotting pipeline</em></p>
<p class="indent">Each recipe type transforms its input and passes it to the next stage in the pipeline; these transformations are indicated after the recipe names. The built-in plotting functions generally know how to plot arrays of numbers, so the plotting recipes have to transform our custom types into ordinary arrays. The first two recipe types, user recipes and type recipes, can do this. The final two recipe types take numerical arrays and produce <em class="calibre11">series</em>, <span epub:type="pagebreak" id="page_255"/>which are the components of plots that represent individual vectors, which may be extracted from matrix columns (in one dimension).</p>
<p class="indent">The user and plot recipes can also create layouts and set overall plot properties. We don’t need to define every one of these recipes, and generally won’t require all of them for any particular plotting task. Any that we <em class="calibre11">have</em> defined we can use separately, or as part of the pipeline, for different purposes. In this discussion, we’ll start at the end of the pipeline and work our way toward the beginning, defining recipes as we go. In this way, each example recipe will do something when we call it directly, passing information along to the previously defined recipes to produce a plot.</p>
<h4 class="h3" id="ch08lev1sec16"><strong class="calibre2"><em class="calibre4">The Series Recipe</em></strong></h4>
<p class="noindent">We define recipes with the <span class="literal">@recipe</span> macro, exported by the <span class="literal">RecipesBase</span> package. The macro decorates a function definition where the name of the function is arbitrary. The function’s signature determines the type of recipe created. In the following listing, we create two series recipes. The signature, a type followed by three additional positional arguments <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span>, tells the pipeline that these are series recipes. As always, the keyword arguments are not part of the function signature for dispatch. Referring to <a href="ch08.xhtml#ch8lis8" class="calibre10">Listing 8-8</a>, we see that these recipes will accept numerical arrays and create series:</p>
<pre class="calibre13">using RecipesBase

@recipe function f(::Type{Val{:ebxbox}}, x, y, z; cycle=7)
    if cycle &lt;= 2; cycle = 7; end
    ymin = similar(y)
    ymax = similar(y)
    yave = similar(y)
 <span class="ent">➊</span> seriestype := :line
    for m = 1:cycle:length(y)
        nxt = min(m+cycle-1, length(y))
        ymin[m] = ymax[m] = yave[m] = NaN
        ymin[m+1:nxt] .= minimum(y[m:nxt])
        ymax[m+1:nxt] .= maximum(y[m:nxt])
        yave[m+1:nxt] .= sum(y[m:nxt]) / (nxt - m + 1)
    end
 <span class="ent">➋</span> @series begin
        y := ymax
     <span class="ent">➌</span> linecolor --&gt; "#ff000049"
        linewidth --&gt; 6
    end
    @series begin
        y := ymin
        linecolor --&gt; "#0000ff49"
        linewidth --&gt; 6
    end


    <span epub:type="pagebreak" id="page_256"/>@series begin
        y := yave
        linecolor --&gt; "#66666649"
        linewidth --&gt; 6
    end
end

@recipe function f(::Type{Val{:temprange}}, x, y, z)
    seriestype := :line
    legend := false
    if plotattributes[:series_plotindex] == 1
     <span class="ent">➍</span> merge!(plotattributes[:extra_kwargs], Dict(:nextfr =&gt; y[:]))
        linecolor := :blue
        linewidth := 3
    elseif plotattributes[:series_plotindex] == 2
        fillrange := plotattributes[:extra_kwargs][:nextfr]
        linecolor := :red
        linewidth := 3
        fillcolor := "#45f19655"
    else
        x := []
        y := []
    end
    ()
end</pre>
<p class="indent">To define recipes, we need only import <span class="literal">RecipesBase</span>. This is important because it means that packages can define plotting behaviors without a dependence on the large <span class="literal">Plots</span> package. <span class="literal">RecipesBase</span> is tiny, containing only about 400 lines of Julia.</p>
<p class="indent">Plot recipes defined using the <span class="literal">@recipe</span> macro use several special-purpose syntax conveniences. The <span class="literal">:=</span> operator <span class="ent">➊</span> makes a setting in the <span class="literal">plotattributes</span> dictionary, which holds attributes such as line color—all the options for the plot. Here we set the <span class="literal">seriestype</span> in the attribute dictionary to <span class="literal">:line</span>. This is the default series type, which creates a continuous line through the plotted points. Another option is <span class="literal">:scatter</span>, for plotting individual marks. In fact, the familiar <span class="literal">scatter()</span> function is a shorthand for <span class="literal">plot(; seriestype=:scatter)</span>.</p>
<p class="indent">The <span class="literal">--&gt;</span> operator <span class="ent">➌</span> also makes settings in the <span class="literal">plotattributes</span> dictionary, but, in this case, defers to settings made in keyword arguments previously in the pipeline. In a sense, these are optional, whereas settings we make with <span class="literal">:=</span> are important for the series under construction.</p>
<p class="indent"><span epub:type="pagebreak" id="page_257"/>Next we have a <span class="literal">for</span> loop that divides the input <span class="literal">y</span> vector into segments of <span class="literal">cycle</span> elements and calculates extrema and an average for each segment. It inserts <span class="literal">NaN</span>s after each segment to separate them in the plot.</p>
<p class="indent">Next come three blocks preceded by the <span class="literal">@series</span> macro <span class="ent">➋</span>. Each <span class="literal">@series</span> block creates a new series for the plot. In this case, each will be a <span class="literal">:line</span> series, since we make that setting outside the blocks, but in general, they can be of different types. They can also create a series type unknown to <span class="literal">Plots</span>, in which case the pipeline will pass the data on to the recipe where the new series is defined. There can be a chain of series recipes of any length. The data will pass through each in turn until a recipe creates a series type known to the backend in use.</p>
<p class="indent">The next recipe is designed to accept an <em class="calibre11">N</em>×2 matrix. It will plot each of the two columns as lines, the first in blue and the second in red. It will fill the space between the two lines using the <span class="literal">fillrange</span> attribute. This presents a small problem, as we need to refer to the first column to define the <span class="literal">fillrange</span> when plotting the second, but the pipeline starts afresh for each column in the input data. However, we know which column we’re on by referring to the <span class="literal">:series_plotindex</span> key in the attribute dictionary. One way to pass information between different columns is to stuff it into the <span class="literal">:extra_kwargs</span> entry in the attribute dictionary <span class="ent">➍</span>. We call our new attribute <span class="literal">:nextfr</span>.</p>
<p class="indent">Although we have in mind the weather data types defined previously, these recipes don’t know anything about that. Like all series recipes, they can plot any arrays of numbers. For actual plotting, we need to import <span class="literal">Plots</span>:</p>
<pre class="calibre13">using Plots

@shorthands temprange
@shorthands ebxbox

tl = [t[1] for t in wd.temps.temps]
th = [t[2] for t in wd.temps.temps]

temprange([tl th])

ebxbox(wd.rainfall)
plot!(wd.rainfall)</pre>
<p class="indent">The <span class="literal">@shorthands</span> macro, provided by <span class="literal">RecipesBase</span>, takes the names in the function signatures of recipes and makes function names that we can call directly to make plots. For each one, it makes two functions, one for creating a new plot and one for adding to an existing plot, just like <span class="literal">plot()</span> and <span class="literal">plot!()</span>.</p>
<p class="indent">After transforming the temperature data in <span class="literal">wd</span> to a matrix, we can use the shorthand on it directly, creating <a href="ch08.xhtml#ch8fig6" class="calibre10">Figure 8-6</a>.<span epub:type="pagebreak" id="page_258"/></p>
<div class="image1"><img alt="Image" id="ch8fig6" src="../images/ch08fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-6: A</em> <span class="codeitalic">fillrange</span> <em class="calibre11">plot created by a series recipe</em></p>
<p class="indent">For <a href="ch08.xhtml#ch8fig7" class="calibre10">Figure 8-7</a>, we call <span class="literal">ebxbox()</span> on the rainfall vector. It only plots the extrema and mean bars, so we add a normal plot of the vector using <span class="literal">plot!()</span>.</p>
<div class="image1"><img alt="Image" id="ch8fig7" src="../images/ch08fig07.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-7: A plot using the</em> <span class="codeitalic">ebxbox</span> <em class="calibre11">series recipe</em></p>
<p class="indent">We can use these series recipes in other programs and as components within other pipelines.<span epub:type="pagebreak" id="page_259"/></p>
<h4 class="h3" id="ch08lev1sec17"><strong class="calibre2"><em class="calibre4">The Plot Recipe</em></strong></h4>
<p class="noindent">The type of recipe called a <em class="calibre11">plot recipe</em> (not to be confused with the general concept) also transforms series into other series or numerical data into series, as do series recipes, but can create complete visualizations containing subplots and other elements as well. Like all recipes, it’s identified by its particular function signature:</p>
<pre class="calibre13">@recipe function f(::Type{Val{:weatherplot}}, plt::AbstractPlot; cycle=7)
    frames = get(plotattributes, :frames, 1)
    if frames &gt; 1 layout := (2, 1) end
 <span class="ent">➊</span> cycle := cycle
    legend := false
    @series begin
     <span class="ent">➋</span> if frames &gt; 1
            subplot := 1
            xguide := ""
            ylabel := "Temperature (°C)"
        end
     <span class="ent">➌</span> seriestype := :temprange
    end
    if plotattributes[:series_plotindex] == 3
        @series begin
            if frames &gt; 1 subplot := 2 end
            seriestype := :ebxbox
        end
        @series begin
            if frames &gt; 1
                subplot := 2
                title := ""
                ylabel := "Rainfall (mm)"
            else
                ylabel := "Rainfall (mm) / Temperature (°C)"
            end
            seriestype := :line
            linecolor := :aqua
            linewidth := 3
            linestyle := :dot
        end
    end
end</pre>
<p class="indent">The recipe takes input data in the form of an <em class="calibre11">N</em>×3 matrix. It uses a <span class="literal">frames</span> attribute, which we invented for the purpose, to decide whether to place all the series in one plot or to use two subplots <span class="ent">➋</span>, one with temperature and the other with rainfall. (As in the case of the series recipes, this recipe knows nothing of our weather-related data types, so we can repurpose it to plot other types of data as well.)</p>
<p class="indent"><span epub:type="pagebreak" id="page_260"/>The <span class="literal">cycle</span> variable sets the length of the segments used for calculating extrema and averages in the third column of the input data, which we intend to use for the rainfall data. We use 7 as a default value for this keyword argument, for weekly summaries. If, however, we supply the parameter when calling the recipe directly or upstream in the pipeline, we override the default by reading its value from the <span class="literal">plotattributes</span> dictionary <span class="ent">➊</span>.</p>
<p class="indent">The three <span class="literal">@series</span> blocks handle the first two columns, containing temperature minimums and maximums, and the rainfall in the third column. The temperature <span class="literal">@series</span> block sets the series type to <span class="literal">temprange</span> <span class="ent">➌</span>, which won’t work unless we’ve already defined a series recipe for it, as we did previously.</p>
<p class="indent">The purpose of this recipe, then, is to use the visualizations defined in our series recipes to create a graph with either one or two subplots, with labels appropriate for either case. We can also call it directly, as shown in <a href="ch08.xhtml#ch8lis9" class="calibre10">Listing 8-9</a>.</p>
<pre class="calibre13">@shorthands weatherplot

weatherplot([tl th wd.rainfall])</pre>
<p class="list" id="ch8lis9"><em class="calibre11">Listing 8-9: Calling the plot recipe with array data</em></p>
<p class="noindent">But we’ll defer this for now.</p>
<h4 class="h3" id="ch08lev1sec18"><strong class="calibre2"><em class="calibre4">Type Recipes</em></strong></h4>
<p class="noindent">Referring back to <a href="ch08.xhtml#ch8lis8" class="calibre10">Listing 8-8</a>, we can see that <em class="calibre11">type recipes</em> are the first recipes in the pipeline that can accept user-defined types. They’re the simplest class of recipe. They have one job: to transform user types into numerical arrays that the functions from <span class="literal">Plots</span> can plot directly, or that can be fed into the following steps in the pipeline.</p>
<p class="indent">The following listing defines two type recipes; they’re recognized as such by their particular function signatures:</p>
<pre class="calibre13">@recipe function f(::Type{TempExtremes}, v::TempExtremes)
    tmin = [t[1] for t in v.temps]
    tmax = [t[2] for t in v.temps]
    [tmin tmax]
end

@recipe function f(::Type{WeatherData}, wdt::WeatherData)
    tmin = [t[1] for t in wdt.temps.temps]
    tmax = [t[2] for t in wdt.temps.temps]
    [tmin tmax wdt.rainfall]
end</pre>
<p class="indent">The first recipe takes instances of the <span class="literal"><em class="calibre11">TempExtremes</em></span> type defined previously and returns a matrix with two columns; the second transforms <span class="literal">WeatherData</span> into a three-column matrix.</p>
<p class="indent"><span epub:type="pagebreak" id="page_261"/>After defining these recipes, we can now plot either of these types directly by calling <span class="literal">plot(td)</span> or <span class="literal">plot(wd)</span>. If we do so, we’ll get simple line plots of the columns: two from the first call and three from the second, as in <a href="ch08.xhtml#ch8fig8" class="calibre10">Figure 8-8</a>.</p>
<div class="image1"><img alt="Image" id="ch8fig8" src="../images/ch08fig08.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-8: Plotting directly from a type recipe</em></p>
<p class="indent">We call <span class="literal">plot(wd)</span> to produce <a href="ch08.xhtml#ch8fig8" class="calibre10">Figure 8-8</a>. The top two lines are the temperature extrema and the bottom line is the rainfall.</p>
<p class="indent">If, instead, we call <span class="literal">weatherplot(wd)</span>, we get the exact same plot that would result from the call in <a href="ch08.xhtml#ch8lis9" class="calibre10">Listing 8-9</a> because the type recipe transforms <span class="literal">wd</span> into a three-column matrix. <a href="ch08.xhtml#ch8fig9" class="calibre10">Figure 8-9</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch8fig9" src="../images/ch08fig09.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-9: A plot recipe called on user data transformed by a type recipe</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_262"/>Here the plot recipe assembles the two types of visualizations, defined in series recipes, onto a single plot, and adds a label on the vertical axis. Since we don’t define <span class="literal">frames</span>, we get the default single frame.</p>
<h4 class="h3" id="ch08lev1sec19"><strong class="calibre2"><em class="calibre4">User Recipes</em></strong></h4>
<p class="noindent">Now we’ve ascended to the top of the pipeline. The <em class="calibre11">user recipes</em> accept not only single user types, but any combination of types, with each different signature creating a new method for dispatch. They can emit array data or other types, but if they emit types other than array data we must have defined a type recipe to transform them.</p>
<p class="indent">Such is the case with the following user recipe:</p>
<pre class="calibre13">@recipe function f(wr::WeatherReport; frames=1)
    title := wr.notes
    frames := frames
    xlabel --&gt; "Days from $(wr.start)"
    @series begin
        seriestype := :weatherplot
        wr.data
    end
end</pre>
<p class="indent">The pipeline will see this as a user recipe because of its signature. It takes an instance of the <span class="literal">WeatherReport</span> data type, creates a title from its <span class="literal">notes</span> field, and constructs a useful label for the x-axis by referring to the <span class="literal">start</span> field. It has a single <span class="literal">@series</span> block, to which it passes the <span class="literal">data</span> field. The series invoked is the plot recipe <span class="literal">weatherplot</span>, but the <span class="literal">data</span> field is not an array, it’s <span class="literal">WeatherData</span>. The next step in the pipeline, the type recipes, handles any type conversions. Here the <span class="literal">WeatherData</span> instance is transformed into a three-column matrix that is handed off to the <span class="literal">weatherplot</span> recipe, which optionally sets up the subplots and passes the matrix columns to the series recipes. Calling <span class="literal">plot(wr; frames=2)</span> invokes this recipe and creates <a href="ch08.xhtml#ch8fig10" class="calibre10">Figure 8-10</a>.<span epub:type="pagebreak" id="page_263"/></p>
<div class="image1"><img alt="Image" id="ch8fig10" src="../images/ch08fig10.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-10: The result of calling the user recipe</em></p>
<p class="indent">Defining the user recipe teaches the <span class="literal">plot()</span> function how to handle a new data type. As we’ve seen throughout this section, we can enter the plotting pipeline at any point for a different result, or reuse any of these recipes as part of different pipelines for handling different types of data.</p>
<h4 class="h3" id="ch08lev1sec20"><strong class="calibre2"><em class="calibre4">The @userplot Macro</em></strong></h4>
<p class="noindent">The <span class="literal">RecipesBase</span> package also exports the <span class="literal">@userplot</span> macro, which is convenient for defining a visualization without having to define a new data type:</p>
<pre class="calibre13">using SpecialFunctions

@userplot Risep

@recipe function f(carray::Risep)
    seriestype := :line
 <span class="ent">➊</span> x, y = carray.args
    @series begin
        label := "Real part"
        linestyle := :solid
        x, real.(y)
    end
    @series begin
        label := "Imaginary part"
        linestyle := :dot
        x, imag.(y)
    end
end

xc = 0.01:0.001:0.1
risep(xc, expint.(1im, xc); lw=2)</pre>
<p class="indent"><span epub:type="pagebreak" id="page_264"/>The first line after the import creates a new type and a shorthand using its lowercase name. The user recipe that we define using the name of the type is invoked using the shorthand name. Inside the recipe, we can access plot data using the <span class="literal">args</span> property <span class="ent">➊</span>. The <span class="literal">@userplot</span> is useful when we want a shorthand name for a particular visualization for an existing type. In this case, we want to plot complex numbers by separating their real and imaginary parts, which may be more useful than the default treatment given them by <span class="literal">plot()</span>. After defining the recipe, we can invoke it directly using its name as in the last line. The <span class="literal">expint()</span> function is an exponential integral from the <span class="literal">SpecialFunctions</span> package, parameterized by its first argument. With the parameter here, it maps real numbers to complex numbers. The result appears in <a href="ch08.xhtml#ch8fig11" class="calibre10">Figure 8-11</a>.</p>
<div class="image1"><img alt="Image" id="ch8fig11" src="../images/ch08fig11.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 8-11: Using <span class="codeitalic">@userplot</span> to render a vector of complex numbers</em></p>
<p class="indent">We can also use the <span class="literal">@userplot</span> macro to create alternative visualizations for user-defined types by using type aliases or subtyping.</p>
<h3 class="h2" id="ch08lev8"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">With this survey of the most important practical aspects of the type system, our introduction to the Julia language is complete. The ideas in this chapter and the preceding ones will find concrete application in the chapters of <span epub:type="pagebreak" id="page_265"/><a href="part2.xhtml" class="calibre10">Part II</a>, where we’ll put Julia to work to solve real problems in a variety of fields.</p>
<p class="indent">This book’s division into language learning and application sections isn’t a strict one, however. We’ve seen several useful applications in the preceding chapters, and the chapters in <a href="part2.xhtml" class="calibre10">Part II</a> will introduce various programming techniques and Julia features in places where they can be immediately applied and more readily appreciated in the context of solving problems.</p>
<div class="box">
<p class="boxtitle-d"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">Details on performance implications of one form of type instability are available at <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable" class="calibre10"><em class="calibre11">https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable</em></a>.</li>
<li class="noindent1">Dr. Chris Rackauckas gives an example of when dynamic dispatch is a net win here: <a href="https://discourse.julialang.org/t/why-type-instability/4013/8" class="calibre10"><em class="calibre11">https://discourse.julialang.org/t/why-type-instability/4013/8</em></a>. This is a case where type instability is beneficial.</li>
<li class="noindent1">Interesting information about π in Julia is available at <a href="https://julialang.org/blog/2017/03/piday/" class="calibre10"><em class="calibre11">https://julialang.org/blog/2017/03/piday/</em></a>.</li>
<li class="noindent1">My attempt to explain multiple dispatch using an extended recipe analogy is available at <a href="https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/" class="calibre10"><em class="calibre11">https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/</em></a>.</li>
<li class="noindent1">For a detailed tutorial about optimization and the type system, visit <a href="https://huijzer.xyz/posts/inference/" class="calibre10"><em class="calibre11">https://huijzer.xyz/posts/inference/</em></a>.</li>
<li class="noindent1">Here is a package for nice visualization of type hierarchies: <a href="https://github.com/claytonpbarrows/D3TypeTrees.jl" class="calibre10"><em class="calibre11">https://github.com/claytonpbarrows/D3TypeTrees.jl</em></a>.</li>
<li class="noindent1">Another approach to finding and fixing type instabilities is offered by the <span class="literal">Cthulhu</span> package: <a href="https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/" class="calibre10"><em class="calibre11">https://docs.juliahub.com/Cthulhu/Dqimq/2.7.5/</em></a>.<span epub:type="pagebreak" id="page_266"/></li></ul>
</div>
</body></html>