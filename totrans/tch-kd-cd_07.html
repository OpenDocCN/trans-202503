<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Functions: There&#x2019;s a Name for That"><div class="titlepage"><div><div><h1 class="title"><a id="functions_thereapostrophes_a_name_for_th"/>Chapter 7. Functions: There’s a Name for That</h1></div></div></div><p><a id="iddle1342" class="indexterm"/>We’ve made use of a number of <span class="emphasis"><em>functions</em></span> so far— everything from <code class="literal">print()</code> to <code class="literal">input()</code> to <code class="literal">turtle.forward()</code>. But all of these functions have been either built-in or imported from Python modules and libraries. In this chapter, we’ll write our <span class="emphasis"><em>own</em></span> functions to do anything we want, including responding to user actions like mouse-clicking and keypresses.</p><p><a id="iddle1330" class="indexterm"/><a id="iddle1337" class="indexterm"/><a id="iddle1353" class="indexterm"/><a id="iddle1452" class="indexterm"/><a id="iddle1534" class="indexterm"/><a id="iddle1789" class="indexterm"/><a id="iddle1805" class="indexterm"/><a id="iddle1989" class="indexterm"/>Functions are helpful because they give us the ability to organize pieces of reusable code, then refer to those pieces later in our programs by a single short name or command. Take <code class="literal">input()</code> as an example: it prints a text prompt to ask a user for input, collects what the user types, and passes it to our program as a string that we can store in a variable. We reuse the <code class="literal">input()</code> function anytime we want to know something more from the user. If we didn’t have this function, we might have to do all that work ourselves every time we wanted to ask the user for information.</p><p>The <code class="literal">turtle.forward()</code> function is another great visual example: every time we move the turtle forward to draw one of the sides of our spirals, Python draws one pixel at a time in the direction our turtle is currently heading on the screen, to the exact length we ask for. If we didn’t have the <code class="literal">turtle.forward()</code> function, we would have to figure out how to color pixels on the screen, keep track of locations and angles, and do some fairly complex math to draw a certain distance every time.</p><div class="informalfigure"><a id="med_id00088a"/><div class="mediaobject"><a id="med_id00088"/><img src="httpatomoreillycomsourcenostarchimages2188945.png.jpg" alt="image with no caption"/></div></div><p>Without these functions, our programs would be longer, harder to read, and harder to write. Functions let us take advantage of the previous programming work of lots of fellow coders. The good news is that we can also write our own functions to make our code shorter, easier to read, and more reusable.</p><p>In <a class="xref" href="ch06.html" title="Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!">Chapter 6</a>, we built programs that drew random spirals and a kaleidoscope pattern. We can use functions to make the code in these programs easier to read and to make parts of the code more reusable.</p><div class="sect1" title="Putting Things Together with Functions"><div class="titlepage"><div><div><h1 class="title"><a id="putting_things_together_with_functions"/>Putting Things Together with Functions</h1></div></div></div><p>Look back at <a class="xref" href="ch06.html#randomspiralsdotpy" title="RandomSpirals.py">RandomSpirals.py</a>. Everything in the first <code class="literal">for</code> loop is the code to create just one random spiral. The <code class="literal">for</code> loop uses that code to draw 50 spirals of random color, size, and location.</p><p><a id="iddle1239" class="indexterm"/><a id="iddle1242" class="indexterm"/><a id="iddle1347" class="indexterm"/><a id="iddle1783" class="indexterm"/><a id="iddle1784" class="indexterm"/>Say we want to use that random spiral code in another program, like a game or a screensaver app. In <span class="emphasis"><em>RandomSpirals.py</em></span>, it’s not easy to tell where the actual spiral drawing starts or stops, and we just wrote that code a few pages ago. Imagine coming back to this program in three months! We would have a hard time figuring out what the app is supposed to do and which lines we need to copy over into a new program if we want to draw random spirals again.</p><p>To make a piece of code reusable later, or just easier to read now, we can <span class="emphasis"><em>define a function</em></span> and give it an easy-to-understand name, just like <code class="literal">input()</code> or <code class="literal">turtle.forward()</code>. Defining a function is also called <a class="firstterm" href="apd.html#gloss01_016"><em class="firstterm">declaring</em></a> the function, and it just means that we’re telling the computer what we want the function to do. Let’s create a function to draw a random spiral on the screen; we’ll call it <code class="literal">random_spiral()</code>. We can reuse this function anytime we want to draw random spirals, in any program.</p><div class="sect2" title="Defining Random_Spiral()"><div class="titlepage"><div><div><h2 class="title"><a id="defining_randomunderscorespiralleft_pare"/>Defining Random_Spiral()</h2></div></div></div><p>Open <span class="emphasis"><em>RandomSpirals.py</em></span> (<a class="xref" href="ch06.html" title="Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!">Chapter 6</a>), save it as a new file called <span class="emphasis"><em>RandomSpiralsFunction.py</em></span>, and begin this function definition <span class="emphasis"><em>after</em></span> setting up the turtle’s pen, speed, and colors but <span class="emphasis"><em>before</em></span> the <code class="literal">for</code> loop. (You can refer to the final program in <a class="xref" href="ch07.html#randomspiralsfunctiondotpy" title="RandomSpiralsFunction.py">RandomSpiralsFunction.py</a> to see how this should look.) Our definition of <code class="literal">random_spiral()</code> should go after the turtle setup because the function will need to use the turtle pen <code class="literal">t</code> and the list of colors. The definition should go before the <code class="literal">for</code> loop because we’ll be using <code class="literal">random_spiral()</code> in the <code class="literal">for</code> loop, and you have to define a function before you can use it. Now that we’ve found the right place in our program, let’s start defining the <code class="literal">random_spiral()</code> function.</p><p>We define a function in Python using the keyword <code class="literal">def</code> (short for <span class="emphasis"><em>definition</em></span>), followed by the name of the function, parentheses <code class="literal">()</code>, and a colon (<code class="literal">:</code>). Here’s the first line of the <code class="literal">random_spiral()</code> function we’ll build:</p><a id="pro_id00090"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">random_spiral</span>():</pre><p>The rest of the function definition will be one or more statements, indented from the left, just like when we grouped statements in our <code class="literal">for</code> loops. To draw a random spiral, we need to set a random color, a random size, and a random (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location <a id="iddle1127" class="indexterm"/><a id="iddle1331" class="indexterm"/><a id="iddle1344" class="indexterm"/><a id="iddle1535" class="indexterm"/><a id="iddle1782" class="indexterm"/>on the screen, and then move the pen there and draw the spiral. Here’s the code to complete our <code class="literal">random_spiral()</code> function:</p><a id="pro_id00091"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">random_spiral</span>():
    t.pencolor(random.choice(colors))
    size = random.randint(10,40)
    x = random.randrange(-turtle.window_width()//2,
                         turtle.window_width()//2)
    y = random.randrange(-turtle.window_height()//2,
                         turtle.window_height()//2)
    t.penup()
    t.setpos(x,y)
    t.pendown()
    <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
        t.forward(m*2)
        t.left(91)</pre><p>Note that the computer doesn’t actually <span class="emphasis"><em>run</em></span> the code when the function is being defined. If we type the function definition into IDLE, we won’t get a spiral—yet. To actually draw a spiral, we need to call the <code class="literal">random_spiral()</code> function.</p></div><div class="sect2" title="Calling Random_Spiral()"><div class="titlepage"><div><div><h2 class="title"><a id="calling_randomunderscorespiralleft_paren"/>Calling Random_Spiral()</h2></div></div></div><p>A function definition tells the computer what we want to do when someone actually calls the function. After defining a function, we <span class="emphasis"><em>call</em></span> it in our program using the function’s name followed by parentheses:</p><a id="pro_id00092"/><pre class="programlisting">random_spiral()</pre><p>You’ve got to remember the parentheses, because that tells the computer you want to run the function. Now that we’ve defined <code class="literal">random_spiral()</code> as a function, when we call <code class="literal">random_spiral()</code> like this in our program, we’ll get a random spiral drawn on a turtle screen.</p><p>Now, to draw 50 random spirals, instead of using all the code in <span class="emphasis"><em>RandomSpirals.py</em></span>, we can shorten our <code class="literal">for</code> loop to this:</p><a id="pro_id00093"/><pre class="programlisting"><span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(50):
    random_spiral()</pre><p>This loop is easier to read, thanks to our use of a function that we built all by ourselves. We’ve made our code easier to understand, and we can easily move the random spiral code over into another program by copying and pasting the function definition.</p><p><a id="iddle1670" class="indexterm"/><a id="iddle1806" class="indexterm"/>Here’s the whole program together; type this into IDLE and save it as <span class="emphasis"><em>RandomSpiralsFunction.py</em></span> or download it from <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>.</p></div><div class="sect2" title="RandomSpiralsFunction.py"><div class="titlepage"><div><div><h2 class="title"><a id="randomspiralsfunctiondotpy"/>RandomSpiralsFunction.py</h2></div></div></div><a id="pro_id00094"/><pre class="programlisting"><span class="orange">import</span> random
<span class="orange">import</span> turtle
t = turtle.Pen()
t.speed(0)
turtle.bgcolor(<span class="green">"black"</span>)
colors = [<span class="green">"red"</span>, <span class="green">"yellow"</span>, <span class="green">"blue"</span>, <span class="green">"green"</span>, <span class="green">"orange"</span>, <span class="green">"purple"</span>,
          <span class="green">"white"</span>, <span class="green">"gray"</span>]
<span class="orange">def</span> <span class="blue">random_spiral</span>():
    t.pencolor(random.choice(colors))
    size = random.randint(10,40)
    x = random.randrange(-turtle.window_width()//2,
                         turtle.window_width()//2)
    y = random.randrange(-turtle.window_height()//2,
                         turtle.window_height()//2)
    t.penup()
    t.setpos(x,y)
    t.pendown()
    <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
        t.forward(m*2)
        t.left(91)

<span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(50):
    random_spiral()</pre><p>In addition to a more readable program, we also get a reusable <code class="literal">random_spiral()</code> function that we can copy, modify, and easily use in other programs.</p><p>If you find yourself reusing a chunk of code again and again, convert it into a function like we did with <code class="literal">random_spiral()</code> using <code class="literal">def</code>, and you’ll find it much easier to <span class="emphasis"><em>port</em></span> the code—that is, carry it over and reuse it—into new applications.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="emphasis"><em>You can even create your own module full of functions and import your module just like we’ve imported <code class="literal">turtle</code> and <code class="literal">random</code> in our programs (see Appendix C on how to create a module in Python). That way you can share your code with friends.</em></span></p></div><div class="informalfigure"><a id="med_id00089a"/><div class="mediaobject"><a id="med_id00089"/><img src="httpatomoreillycomsourcenostarchimages2188947.png.jpg" alt="image with no caption"/></div></div></div></div><div class="sect1" title="Parameters: Feeding Your Function"><div class="titlepage"><div><div><h1 class="title"><a id="parameters_feeding_your_function"/>Parameters: Feeding Your Function</h1></div></div></div><p><a id="iddle1085" class="indexterm"/><a id="iddle1265" class="indexterm"/><a id="iddle1350" class="indexterm"/><a id="iddle1637" class="indexterm"/><a id="iddle1777" class="indexterm"/><a id="iddle1778" class="indexterm"/>When creating a function, we can define <a class="firstterm" href="apd.html#gloss01_037"><em class="firstterm">parameters</em></a> for that function. Parameters allow us to send information to the function by passing values to it as <span class="emphasis"><em>arguments</em></span> inside its parentheses. We’ve been passing arguments to functions since our first <code class="literal">print()</code> statement. When we code <code class="literal">print("Hello")</code>, <code class="literal">"Hello"</code> is an argument representing the string value that we want printed to the screen. When we call the turtle function <code class="literal">t.left(90)</code>, we’re passing the value <code class="literal">90</code> as the number of degrees we want our turtle to turn left.</p><p>The <code class="literal">random_spiral()</code> function didn’t need parameters. All the information it needed was in the code inside the function. But if we want, functions that we build can take information in the form of parameters. Let’s define a function, <code class="literal">draw_smiley()</code>, to draw a smiley face at a random location on the screen. This function will take a pair of random coordinates and draw the smiley face at those coordinates. We’ll define and call <code class="literal">draw_smiley()</code> in a program called <span class="emphasis"><em>RandomSmileys.py</em></span>. The complete program is shown in <a class="xref" href="ch07.html#putting_it_all_together-id00013" title="Putting it all together">Putting it all together</a>— but let’s build it step by step.</p><div class="sect2" title="Smileys at Random Locations"><div class="titlepage"><div><div><h2 class="title"><a id="smileys_at_random_locations"/>Smileys at Random Locations</h2></div></div></div><p>We want to write a program that, rather than drawing random spirals, draws smiley faces. It’ll take a bit more planning to draw a smiley face than it did to randomly pick a color and size and draw a spiral. Let’s go back to our friend from <a class="xref" href="ch06.html" title="Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!">Chapter 6</a>, a piece of graph paper. Because we haven’t drawn something as complicated as a smiley face in our programs before, it’s best to draw this on paper first and then translate it into code, one part at a time. <a class="xref" href="ch07.html#weapostrophere_planning_our_program_by_d" title="Figure 7-1. We’re planning our program by drawing a smiley face on graph paper first.">Figure 7-1</a> shows a smiley face on a graph-paper grid that we can use to plan our drawing.</p><p>Our program will draw smileys like this one all over the screen at random (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates. The function definition for <code class="literal">draw_smiley()</code> will take two parameters, <code class="literal">x</code> and <code class="literal">y</code>, for the location where the smiley is to be drawn. As shown in <a class="xref" href="ch07.html#weapostrophere_planning_our_program_by_d" title="Figure 7-1. We’re planning our program by drawing a smiley face on graph paper first.">Figure 7-1</a>, we will draw the smiley face as if it were <a id="iddle1988" class="indexterm"/>sitting on the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location, so picture moving this smiley face template around by placing its origin (0, 0) over any other point (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) on the screen. Let’s figure out how to draw each smiley face starting from a given point.</p><div class="figure"><a id="weapostrophere_planning_our_program_by_d"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00090"/><img src="httpatomoreillycomsourcenostarchimages2188949.png.jpg" alt="We’re planning our program by drawing a smiley face on graph paper first."/></div></div><p class="title">Figure 7-1. We’re planning our program by drawing a smiley face on graph paper first.</p></div><div class="sect3" title="Drawing a head"><div class="titlepage"><div><div><h3 class="title"><a id="drawing_a_head"/>Drawing a head</h3></div></div></div><p>Each smiley face has a yellow circle for the head, two small blue circles for eyes, and some black lines for the mouth. Given a point on the screen, our <code class="literal">draw_smiley()</code> function will need to draw a head, eyes, and a mouth at the correct positions relative to the given point. To figure out the code that will go in our function definition, let’s plan the head, eyes, and mouth separately, starting with the head. We’ll draw the head first so that it doesn’t cover the eyes and mouth we’ll draw next.</p><p>We’ll count each grid line in <a class="xref" href="ch07.html#weapostrophere_planning_our_program_by_d" title="Figure 7-1. We’re planning our program by drawing a smiley face on graph paper first.">Figure 7-1</a> as 10 pixels, so the smiley we’ve drawn would measure 100 pixels tall; that will equal around an inch, give or take, on most computer screens. Since the <span class="emphasis"><em>diameter</em></span>, or height and width, of the circle is 100 pixels, that means it has a <span class="emphasis"><em>radius</em></span> (one-half the diameter) of 50 pixels. We need the radius because the <code class="literal">turtle</code> module’s <code class="literal">circle()</code> command takes the radius as its parameter. The command to draw a circle with a radius of 50 (which makes a diameter of 100) is <code class="literal">t.circle(50)</code>. The <code class="literal">circle()</code> function draws a circle directly above the turtle’s current (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location. We’ll need to know this to correctly place the eyes and mouth, so I’ve drawn my smiley face with the bottom edge resting on the origin, (0, 0). We can figure out where we need to draw everything else by adding the coordinates of each part to that starting (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location of (0, 0).</p><p>To draw the big yellow head, we’ll make the pen color yellow, make the fill color yellow, turn on the paint fill for our shape, draw the circle (which gets filled with yellow because we turned on the paint fill), and turn off the paint fill when we’re done. Assuming we have a turtle pen named <code class="literal">t</code> defined earlier in the program, the code to draw the yellow circle as the head of our smiley face at the current (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location looks like this:</p><a id="pro_id00095"/><pre class="programlisting"><span class="red"># Head</span>
t.pencolor(<span class="green">"yellow"</span>)
t.fillcolor(<span class="green">"yellow"</span>)
t.begin_fill()
t.circle(50)
t.end_fill()</pre><p><a id="iddle1144" class="indexterm"/><a id="iddle1278" class="indexterm"/><a id="iddle1314" class="indexterm"/><a id="iddle1315" class="indexterm"/><a id="iddle1643" class="indexterm"/><a id="iddle1853" class="indexterm"/>To fill the circle with yellow, we add four lines of code around our <code class="literal">t.circle(50)</code> command. First, we set the pen color to yellow with <code class="literal">t.pencolor("yellow")</code>. Second, we set the fill color with <code class="literal">t.fillcolor("yellow")</code>. Third, before we call the <code class="literal">t.circle(50)</code> command to draw the face of our smiley, we tell the computer that we want to fill the circle we’re drawing. We do this with the <code class="literal">t.begin_ fill()</code> function. Finally, after we draw our circle, we call the <code class="literal">t.end_fill()</code> function to tell the computer that we’re done with the shape that we want to fill with color.</p></div><div class="sect3" title="Drawing eyes"><div class="titlepage"><div><div><h3 class="title"><a id="drawing_eyes"/>Drawing eyes</h3></div></div></div><p>First, we need to figure out where to position the turtle to draw the left eye in the correct place, then set the fill color to blue, and finally draw a circle of the correct size. The eyes are about 20 pixels (two grid lines) tall, and we know that a diameter of 20 means that we need a radius of half that amount, or 10, so we’ll use the <code class="literal">t.circle(10)</code> command to draw each eye. The tricky part is deciding where to draw them.</p><p>Our (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) starting point will be the local origin of each smiley face, and you can locate the left eye in <a class="xref" href="ch07.html#weapostrophere_planning_our_program_by_d" title="Figure 7-1. We’re planning our program by drawing a smiley face on graph paper first.">Figure 7-1</a>. It looks like it starts about 6 grid lines above the origin (60 pixels up, in the positive y-direction), and it’s sitting about 1.5 grid lines to the left of the y-axis (or about 15 pixels left, in the negative x-direction).</p><p>To tell our program how to get to the right place to draw the left eye, starting from the bottom of the big yellow circle at a given (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) passed to our function as a pair of arguments, we need to start at <span class="emphasis"><em>x</em></span> and move left 15 pixels, start at <span class="emphasis"><em>y</em></span> and move up 60 pixels, or move to <code class="literal">(x-15, y+60)</code>. So, calling <code class="literal">t.setpos(x-15, y+60)</code> should put the turtle where we need to start drawing our left eye. Here’s the code for the left eye:</p><a id="pro_id00096"/><pre class="programlisting"><span class="red"># Left eye</span>
t.setpos(x-15, y+60)
t.fillcolor(<span class="green">"blue"</span>)
t.begin_fill()
t.circle(10)
t.end_fill()</pre><p>An easy mistake might be writing the <code class="literal">setpos</code> command with just (–15, 60) as arguments, but remember that we want to draw lots of smiley faces at various (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) positions on the screen; not all the faces will begin at (0, 0). The command <code class="literal">t.setpos(x-15, y+60)</code> will make sure that wherever our yellow face is being drawn, our left eye will be in the upper left of that face.</p><p>The code to draw the right eye is almost identical to the code for drawing the left eye. We can see that the right eye is 15 pixels (1.5 grid lines) to the right of our (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location, and still 60 pixels up. The command <code class="literal">t.setpos(x+15, y+60)</code> should place the eye symmetrically. Here’s the code for the right eye:</p><a id="pro_id00097"/><pre class="programlisting"><span class="red"># Right eye</span>
t.setpos(x+15, y+60)
t.begin_fill()
t.circle(10)
t.end_fill()</pre><p>The fill color is still blue from the left eye, so we just have to set the turtle to the correct position <code class="literal">(x+15, y+60)</code>, turn the fill on, draw the eye, and finish filling it.</p><div class="informalfigure"><a id="med_id00091a"/><div class="mediaobject"><a id="med_id00091"/><img src="httpatomoreillycomsourcenostarchimages2188951.png.jpg" alt="image with no caption"/></div></div></div><div class="sect3" title="Drawing a mouth"><div class="titlepage"><div><div><h3 class="title"><a id="drawing_a_mouth"/>Drawing a mouth</h3></div></div></div><p>Now let’s plan the most important part of the smiley face: the smile. To make the smile simpler, we’re going to draw the mouth with just three thick, black lines. The left side of the mouth looks like it starts about 2.5 grid lines to the left of and 4 grid lines above our point (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>), so we’ll position the turtle at <code class="literal">(x-25, y+40)</code> to start drawing the smile. We’ll set the pen color to black and the width to 10 so that the smile is thick and easy to see. From the upper-left corner of the smile, we need to go to <code class="literal">(x-10, y+20)</code>, then to <code class="literal">(x+10, y+20)</code>, and finally to the upper-right corner of the smile at <code class="literal">(x+25, y+40)</code>. Notice that <a id="iddle1240" class="indexterm"/><a id="iddle1266" class="indexterm"/><a id="iddle1348" class="indexterm"/><a id="iddle1389" class="indexterm"/><a id="iddle2053" class="indexterm"/>these pairs of points are mirror images of one another across the y-axis; this makes our smiley face nice and even.</p><p>Here’s the code for the mouth:</p><a id="pro_id00098"/><pre class="programlisting">   <span class="red"># Mouth</span>
   t.setpos(x-25, y+40)
   t.pencolor(<span class="green">"black"</span>)
   t.width(10)
   t.goto(x-10, y+20)
   t.goto(x+10, y+20)
   t.goto(x+25, y+40)
➊ t.width(1)</pre><p>After we set the turtle at the upper-left corner of the mouth, we change the pen color to black and the width to 10. We start drawing by telling the turtle to go to each of the other three points of the smile. The <code class="literal">turtle</code> module’s <code class="literal">goto()</code> function does the same thing as <code class="literal">setpos()</code>: it moves the turtle to a given point. I’m using it here just so you can see there’s an alternative to <code class="literal">setpos()</code>. Finally, at ➊, <code class="literal">t.width(1)</code> sets the pen width back down to 1 so that our shapes aren’t too thick when the next face is drawn.</p></div><div class="sect3" title="Defining and Calling Draw_Smiley()"><div class="titlepage"><div><div><h3 class="title"><a id="defining_and_calling_drawunderscoresmile"/>Defining and Calling Draw_Smiley()</h3></div></div></div><p>All that remains is to define the <code class="literal">draw_smiley()</code> function with all the code to draw a smiley face, set up a loop to generate 50 random (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) locations on the screen, and call the <code class="literal">draw_smiley(x,y)</code> function to draw smileys at all 50 locations.</p><p>The function definition for <code class="literal">draw_smiley()</code> will need to take two parameters, <code class="literal">x</code> and <code class="literal">y</code>, for the location where the smiley is to be drawn, and it will need to lift the turtle’s pen, move the turtle to that (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) position, and then put the pen back down to get ready to draw. After that, we just need to add our code snippets for drawing the big yellow face, the left and right eyes, and the mouth.</p><a id="pro_id00099"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">draw_smiley</span>(x,y):
    t.penup()
    t.setpos(x,y)
    t.pendown()
    <span class="red"># All of your drawing code goes here...</span></pre><p>The final piece will be our <code class="literal">for</code> loop to generate 50 random locations for the smiley faces and call the <code class="literal">draw_smiley()</code> function to draw each face. It will look like this:</p><a id="pro_id00100"/><pre class="programlisting"><span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(50):
    x = random.randrange(-turtle.window_width()//2,
                         turtle.window_width()//2)
    y = random.randrange(-turtle.window_height()//2,
                         turtle.window_height()//2)
    draw_smiley(x,y)</pre><p>Our random x- and y-coordinate values are just like those we saw in <a class="xref" href="ch06.html" title="Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!">Chapter 6</a>, generating random points from the left half to the right half of the screen, and from the bottom half to the top half. With <code class="literal">draw_smiley(x,y)</code>, we’re passing these random coordinates as arguments to the <code class="literal">draw_smiley()</code> function, which will draw a smiley at that random spot.</p></div></div><div class="sect2" title="Putting it all together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00013"/>Putting it all together</h2></div></div></div><p>Put the program together, and it looks something like this:</p></div><div class="sect2" title="RandomSmileys.py"><div class="titlepage"><div><div><h2 class="title"><a id="randomsmileysdotpy"/>RandomSmileys.py</h2></div></div></div><a id="pro_id00101"/><pre class="programlisting">   <span class="orange">import</span> random
   <span class="orange">import</span> turtle
   t = turtle.Pen()
   t.speed(0)
   t.hideturtle()
   turtle.bgcolor(<span class="green">"black"</span>)
➊ <span class="orange">def</span> <span class="blue">draw_smiley</span>(x,y):
       t.penup()
       t.setpos(x,y)
       t.pendown()
       <span class="red"># Head</span>
       t.pencolor("y<span class="green">ellow")</span>
       t.fillcolor("y<span class="green">ellow")</span>
       t.begin_fill()
       t.circle(50)
       t.end_fill()
       <span class="red"># Left eye</span>
       t.setpos(x-15, y+60)
       t.fillcolor("b<span class="green">lue")</span>
       t.begin_fill()
       t.circle(10)
       t.end_fill()
       <span class="red"># Right eye</span>
       t.setpos(x+15, y+60)
       t.begin_fill()
       t.circle(10)
       t.end_fill()
       <span class="red"># Mouth</span>
       t.setpos(x-25, y+40)
       t.pencolor("b<span class="green">lack")</span>
       t.width(10)
       t.goto(x-10, y+20)
       t.goto(x+10, y+20)
       t.goto(x+25, y+40)
       t.width(1)
➋ <span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(50):
       x = random.randrange(-turtle.window_width()//2,
                            turtle.window_width()//2)
       y = random.randrange(-turtle.window_height()//2,
                            turtle.window_height()//2)
       draw_smiley(x,y)</pre><p><a id="iddle1408" class="indexterm"/><a id="iddle1757" class="indexterm"/><a id="iddle1791" class="indexterm"/>As usual, we import the modules we need and set up our turtle, setting its speed to <code class="literal">0</code> (the fastest). We use <code class="literal">hideturtle()</code> so the turtle itself doesn’t show up on the screen; this speeds up drawing too.</p><p>At ➊, we define our <code class="literal">draw_smiley()</code> function so that its job is to draw the smiley’s face, left eye, right eye, and smile, using all that code we wrote before. All it needs to do its job is an x-coordinate and a y-coordinate.</p><p>In our <code class="literal">for</code> loop at ➋, a random <code class="literal">x</code> and <code class="literal">y</code> are chosen and passed to <code class="literal">draw_smiley()</code>, which then draws a smiley with all features in the correct locations relative to that random point.</p><p>The <span class="emphasis"><em>RandomSmileys.py</em></span> program will draw 50 smiley faces at random positions on the drawing screen, as shown in <a class="xref" href="ch07.html#randomsmileysdotpy_program_produces_a_ha" title="Figure 7-2. The RandomSmileys.py program produces a happy result.">Figure 7-2</a>.</p><p>You can customize the program to draw just about any shape you want, as long as you design a function to draw that shape starting from any (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location. Start with graph paper like we did in this example to make it easier to find the important points. If it bothers you that some of the smiley faces are halfway off the screen on the left and right, or almost all the way off the screen at the top, you can use a bit of math in the <code class="literal">x</code> and <code class="literal">y randrange()</code> statements to keep your smileys completely on the screen. Go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> for a sample answer to this challenge.</p><div class="figure"><a id="randomsmileysdotpy_program_produces_a_ha"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00092"/><img src="httpatomoreillycomsourcenostarchimages2188953.png.jpg" alt="The RandomSmileys.py program produces a happy result."/></div></div><p class="title">Figure 7-2. The <span class="emphasis"><em>RandomSmileys.py</em></span> program produces a happy result.</p></div></div></div><div class="sect1" title="Return: It’s What You Give Back That Counts"><div class="titlepage"><div><div><h1 class="title"><a id="return_itapostrophes_what_you_give_back"/>Return: It’s What You Give Back That Counts</h1></div></div></div><p><a id="iddle1234" class="indexterm"/><a id="iddle1351" class="indexterm"/><a id="iddle1779" class="indexterm"/><a id="iddle1803" class="indexterm"/>We can send information to a function using arguments, but what if we want to <span class="emphasis"><em>receive</em></span> information back <span class="emphasis"><em>from</em></span> a function? For example, what if we build a function to convert inches to centimeters, and we want to store the converted number to use in further calculations, rather than just printing it directly to the screen? To pass information from a function back to the rest of our program, we use a <code class="literal">return</code> statement.</p><div class="sect2" title="Returning a Value from a Function"><div class="titlepage"><div><div><h2 class="title"><a id="returning_a_value_from_a_function"/>Returning a Value from a Function</h2></div></div></div><p>There are lots of times when we want to get information back from a function. For example, let’s actually build the function to convert inches to centimeters and call it <code class="literal">convert_in2cm()</code>. We can imagine the parameter that we might want to accept in the function: a measurement in inches. But this function is a perfect candidate for giving information back to the rest of our program—namely, the converted measurement in centimeters.</p><p><a id="iddle1235" class="indexterm"/><a id="iddle1352" class="indexterm"/><a id="iddle1660" class="indexterm"/><a id="iddle1802" class="indexterm"/>To convert a length in inches to its equivalent in centimeters, we multiply the number of inches by 2.54—the approximate number of centimeters in an inch. To pass that calculation back to the rest of the program, we would use a <code class="literal">return</code> statement. The value after the keyword <code class="literal">return</code> will be passed back to the program as the function’s <span class="emphasis"><em>return value</em></span>, or result. Let’s define our function:</p><a id="pro_id00102"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">convert_in2cm</span>(inches):
    <span class="orange">return</span> inches * 2.54</pre><p>If you type these two lines into the Python shell and then type <code class="literal">convert_in2cm(72)</code> and press ENTER, Python will respond with <code class="literal">182.88</code>. There are about 182.88 centimeters in 72 inches (or 6 feet—my height). The value 182.88 is returned by the function, and in the command line shell, we see the return value printed on the next line after we call a function.</p><p>We could also perform another useful conversion: pounds to kilograms. To convert pounds to kilograms, we divide the weight in pounds by 2.2, the approximate number of pounds in 1 kilogram. Let’s create a function called <code class="literal">convert_lb2kg()</code> that will take a value in pounds as its parameter and return the converted value in kilograms:</p><div class="informalfigure"><a id="med_id00093a"/><div class="mediaobject"><a id="med_id00093"/><img src="httpatomoreillycomsourcenostarchimages2188955.png.jpg" alt="image with no caption"/></div></div><a id="pro_id00103"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">convert_lb2kg</span>(pounds):
    <span class="orange">return</span> pounds / 2.2</pre><p>The <code class="literal">return</code> statement is sort of like using parameters in reverse, except that we can return only <span class="emphasis"><em>one</em></span> value, not a set of values like the parameters we take in. (That one value can be a list, however, so with some work you can pass multiple values back in a single return variable.)</p></div><div class="sect2" title="Using Return Values in a Program"><div class="titlepage"><div><div><h2 class="title"><a id="using_return_values_in_a_program"/>Using Return Values in a Program</h2></div></div></div><p>Using these two conversion functions, let’s build a silly application: a Ping-Pong-ball height and weight calculator. This program will answer the questions “How many Ping-Pong balls tall am I?” and “What is my weight in Ping-Pong balls?”</p><p>An official Ping-Pong ball weighs 2.7 grams (0.095 ounces) and measures 40 millimeters (4 centimeters, or 1.57 inches) in diameter. To calculate how many Ping-Pong balls it would take to match our height and weight, we need to divide our height in centimeters by 4 and divide our weight in grams by 2.7. But not everyone knows their weight in grams or height in centimeters: in the United States, we usually measure our weight in pounds and our height in feet and inches. Fortunately, the two conversion functions we just developed will help us convert those measurements to their equivalents in the metric system. We can then use these numbers to perform the conversion to Ping-Pong-ball units.</p><p>Our program will define the two conversion functions <code class="literal">convert_in2cm()</code> and <code class="literal">convert_lb2kg()</code>. Then it will ask the user for their height and weight, calculate the user’s height and weight in Ping-Pong balls, and display the calculations on the screen. Type and run the following code:</p><div class="sect3" title="PingPongCalculator.py"><div class="titlepage"><div><div><h3 class="title"><a id="pingpongcalculatordotpy"/>PingPongCalculator.py</h3></div></div></div><a id="pro_id00104"/><pre class="programlisting">➊ <span class="orange">def</span> <span class="blue">convert_in2cm</span>(inches):
       <span class="orange">return</span> inches * 2.54

   <span class="orange">def</span> <span class="blue">convert_lb2kg</span>(pounds):
       <span class="orange">return</span> pounds / 2.2

➋ height_in = <span class="violet">int</span>(<span class="violet">input</span>(<span class="green">"Enter your height in inches: "</span>))
   weight_lb = <span class="violet">int</span>(<span class="violet">input</span>(<span class="green">"Enter your weight in pounds: "</span>))

➌ height_cm = convert_in2cm(height_in)
➍ weight_kg = convert_lb2kg(weight_lb)

➎ ping_pong_tall = <span class="violet">round</span>(height_cm / 4)
➏ ping_pong_heavy = <span class="violet">round</span>(weight_kg * 1000 / 2.7)

➐ feet = height_in // 12
➑ inch = height_in % 12

➒ <span class="violet">print</span>(<span class="green">"At"</span>, feet, <span class="green">"feet"</span>, inch, <span class="green">"inches tall, and"</span>, weight_lb,
         <span class="green">"pounds,"</span>)
   <span class="violet">print</span>(<span class="green">"you measure"</span>, ping_pong_tall, <span class="green">"Ping-Pong balls tall, and "</span>)
   <span class="violet">print</span>(<span class="green">"you weigh the same as"</span>, ping_pong_heavy, <span class="green">"Ping-Pong balls!"</span>)</pre><p><a id="iddle1024" class="indexterm"/><a id="iddle1033" class="indexterm"/><a id="iddle1405" class="indexterm"/><a id="iddle1406" class="indexterm"/><a id="iddle1462" class="indexterm"/><a id="iddle1572" class="indexterm"/><a id="iddle1662" class="indexterm"/><a id="iddle1663" class="indexterm"/><a id="iddle1677" class="indexterm"/><a id="iddle1832" class="indexterm"/><a id="iddle2039" class="indexterm"/>At ➊, we enter the two conversion formulas we developed. Both functions take an input parameter (<code class="literal">inches</code> and <code class="literal">pounds</code>), and each function returns a value. At ➋, we ask the user for a height and weight and store those values in <code class="literal">height_in</code> and <code class="literal">weight_lb</code>. At ➌, we call the <code class="literal">convert_in2cm()</code> function, passing <code class="literal">height_in</code> as the value we want to convert, and we store the converted answer in the variable <code class="literal">height_cm</code>. We perform another conversion calculation at ➍ using the <code class="literal">convert_lb2kg()</code> function to convert the person’s weight in pounds (abbreviated as <span class="emphasis"><em>lbs</em></span>) into the equivalent in kilograms (<span class="emphasis"><em>kg</em></span>).</p><p>The equation at ➎ does two things: first, it divides the user’s height in centimeters by 4 to find their height in Ping-Pong balls; then, it rounds that answer to the nearest whole number with the <code class="literal">round()</code> function and stores the result in the variable <code class="literal">ping_pong_tall</code>. At ➏, we do something similar by converting the user’s weight in kilograms to grams by multiplying by 1,000 and then dividing that amount by 2.7—the mass in grams of a standard Ping-Pong ball. That number is rounded to the nearest whole number and stored in the variable <code class="literal">ping_pong_heavy</code>.</p><p>At ➐ and ➑, we do just a little more math by figuring out the person’s height in feet and inches. As I mentioned previously, this is normally how we express our height in the United States, and it will be a nice finishing touch as well as a way for the person to check that they entered the correct information. The <code class="literal">//</code> operator does integer division, so 66 inches, or 5.5 feet, would result in just <code class="literal">5</code> being stored in the variable <code class="literal">feet</code>, and the <code class="literal">%</code> operator (modulo) would store the remainder, <code class="literal">6</code> inches. The <code class="literal">print</code> statements at ➒ print out the user’s height and weight, both in standard units and in Ping-Pong balls.</p><p>Here are the results from a few sample runs of the Ping-Pong calculator program, with Ping-Pong-ball measurements for my sons, Max and Alex, and me. (The only downside is that now my kids want to get 31,000 Ping-Pong balls.)</p><a id="pro_id00105"/><pre class="programlisting"><span class="brown">&gt;&gt;&gt;</span> ================================ RESTART ================================
&gt;&gt;&gt;
<span class="blue">Enter your height in inches:</span> 42
<span class="blue">Enter your weight in pounds:</span> 45
<span class="blue">At 3 feet 6 inches tall, and 45 pounds,</span>
<span class="blue">you measure 27 Ping-Pong balls tall, and</span>
<span class="blue">you weigh the same as 7576 Ping-Pong balls!</span>
&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt;
<span class="blue">Enter your height in inches:</span> 47
<span class="blue">Enter your weight in pounds:</span> 55
<span class="blue">At 3 feet 11 inches tall, and 55 pounds,</span>
<span class="blue">you measure 30 Ping-Pong balls tall, and</span>
<span class="blue">you weigh the same as 9259 Ping-Pong balls!</span>
&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt;
<span class="blue">Enter your height in inches:</span> 72
<span class="blue">Enter your weight in pounds:</span> 185
<span class="blue">At 6 feet 0 inches tall, and 185 pounds,</span>
<span class="blue">you measure 46 Ping-Pong balls tall, and</span>
<span class="blue">you weigh the same as 31145 Ping-Pong balls!</span>
<span class="brown">&gt;&gt;&gt;</span></pre><p><a id="iddle1291" class="indexterm"/><a id="iddle1295" class="indexterm"/><a id="iddle1349" class="indexterm"/><a id="iddle1514" class="indexterm"/>Any function we create can return a value, just like any function that we define can take parameters as input. Depending on what you want your function to do, use one or both of these features to write exactly the code for the function you need.</p></div></div></div><div class="sect1" title="A Touch of Interaction"><div class="titlepage"><div><div><h1 class="title"><a id="touch_of_interaction"/>A Touch of Interaction</h1></div></div></div><p>We’ve coded some nice-looking graphical apps, but we’re still a step or two away from building the next video game or mobile app. One of the remaining skills we need to learn is coding for user interaction: making our programs respond to mouse clicks, keypresses, and so on.</p><div class="informalfigure"><a id="med_id00094a"/><div class="mediaobject"><a id="med_id00094"/><img src="httpatomoreillycomsourcenostarchimages2188957.png.jpg" alt="image with no caption"/></div></div><p>Most apps are <span class="emphasis"><em>interactive</em></span>—they allow the user to touch, click, drag, press buttons, and feel in control of the program. We call these <span class="emphasis"><em>event-driven</em></span> apps because they wait for the user to perform an action, or <a class="firstterm" href="apd.html#gloss01_018"><em class="firstterm">event</em></a>. The code that responds to a user event, like opening a window when the user clicks an icon or starting a game when they touch a button, is referred to as an <span class="emphasis"><em>event handler</em></span> because it handles or responds to an event from the user. It’s also called an event <span class="emphasis"><em>listener</em></span> because it’s as if the computer is sitting patiently, listening <a id="iddle1126" class="indexterm"/><a id="iddle1298" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle1576" class="indexterm"/><a id="iddle1617" class="indexterm"/><a id="iddle1854" class="indexterm"/><a id="iddle1971" class="indexterm"/><a id="iddle1995" class="indexterm"/>for the user to tell it what to do. We’re going to learn to handle user events and make our programs even more engaging and interactive.</p><div class="sect2" title="Handling Events: TurtleDraw"><div class="titlepage"><div><div><h2 class="title"><a id="handling_events_turtledraw"/>Handling Events: TurtleDraw</h2></div></div></div><p>There are lots of ways to make apps handle user events. Python’s <code class="literal">turtle</code> module includes some functions for handling user events, including mouse clicks and keypresses. The first one we’ll try is the <code class="literal">turtle.onscreenclick()</code> function. As the name suggests, this function allows us to handle events created by the user clicking on the turtle’s screen.</p><p>There’s a difference between this function and the ones we’ve used and built before: the argument that we send to <code class="literal">turtle.onscreenclick()</code> isn’t a value—it’s the name of another function:</p><a id="pro_id00106"/><pre class="programlisting">turtle.onscreenclick(t.setpos)</pre><p>Remember the <code class="literal">setpos()</code> function that we’ve used to move the mouse to a certain (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location on the screen? Now we’re telling the computer that when the turtle screen gets a mouse click, it should set the turtle to the position of that click on the screen. A function we pass as an argument to another function is sometimes called a <span class="emphasis"><em>callback</em></span> function (because it gets <span class="emphasis"><em>called back</em></span> by the other function). Notice that when we send a function as an argument to another function, the inside function doesn’t need the parentheses after its name.</p><p>By sending the function name <code class="literal">t.setpos</code> to <code class="literal">turtle.onscreenclick()</code>, we’re telling the computer what we want screen clicks to do: we want to set the position of the turtle to wherever the user clicked. Let’s try it in a short program:</p><div class="sect3" title="TurtleDraw.py"><div class="titlepage"><div><div><h3 class="title"><a id="turtledrawdotpy"/>TurtleDraw.py</h3></div></div></div><a id="pro_id00107"/><pre class="programlisting"><span class="orange">import</span> turtle
t = turtle.Pen()
t.speed(0)
turtle.onscreenclick(t.setpos)</pre><p>Type these four lines into IDLE, run the program, and then click different places around the screen. You just created a drawing program in four lines of code! <a class="xref" href="ch07.html#turtledrawdotpy_sketch_left_parenthesist" title="Figure 7-3. A TurtleDraw.py sketch (there’s a reason I’m an author and not an artist)">Figure 7-3</a> shows a sample sketch I drew.</p><div class="figure"><a id="turtledrawdotpy_sketch_left_parenthesist"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00095"/><img src="httpatomoreillycomsourcenostarchimages2188959.png.jpg" alt="A TurtleDraw.py sketch (there’s a reason I’m an author and not an artist)"/></div></div><p class="title">Figure 7-3. A <span class="emphasis"><em>TurtleDraw.py</em></span> sketch (there’s a reason I’m an author and not an artist)</p></div><p><a id="iddle1104" class="indexterm"/><a id="iddle1644" class="indexterm"/><a id="iddle1969" class="indexterm"/><a id="iddle1972" class="indexterm"/><a id="iddle2054" class="indexterm"/>The reason this works is that we’ve told the computer to do something when the user clicks the mouse on the screen: set the position of the turtle to that location. The turtle’s pen is down by default, so when the user clicks on the drawing window, the turtle moves there and draws a line from its old location to the location where the user clicked.</p><p>You can customize <span class="emphasis"><em>TurtleDraw.py</em></span> by changing the background color of the screen, the turtle’s pen color, the width of the pen, and more. Check out the version my four-year-old son created (with some help from his dad):</p></div><div class="sect3" title="TurtleDrawMax.py"><div class="titlepage"><div><div><h3 class="title"><a id="turtledrawmaxdotpy"/>TurtleDrawMax.py</h3></div></div></div><a id="pro_id00108"/><pre class="programlisting"><span class="orange">import</span> turtle
t = turtle.Pen()
t.speed(0)
turtle.onscreenclick(t.setpos)
turtle.bgcolor(<span class="green">"blue"</span>)
t.pencolor(<span class="green">"green"</span>)
t.width(99)</pre><p>Max liked the drawing program (a lot), but he wanted the screen to be blue and the pen to be green and really thick, so we set the <code class="literal">bgcolor()</code>, <code class="literal">pencolor()</code>, and <code class="literal">width()</code> to <code class="literal">blue</code>, <code class="literal">green</code>, and <code class="literal">99</code>, respectively. We made an arbitrary choice to set these <span class="emphasis"><em>after</em></span> we told the computer what to do with mouse clicks on the screen (<code class="literal">t.setpos</code>).</p><p><a id="iddle1292" class="indexterm"/><a id="iddle1296" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1618" class="indexterm"/><a id="iddle1970" class="indexterm"/><a id="iddle1996" class="indexterm"/>This is fine, because the program keeps running even while it’s listening for mouse clicks, so by the time the user clicks for the first time, the screen and pen are correctly colored and sized, as shown in <a class="xref" href="ch07.html#drawing_i_produced_by_clicking_a_few_tim" title="Figure 7-4. A drawing I produced by clicking a few times with TurtleDrawMax.py">Figure 7-4</a>.</p><div class="figure"><a id="drawing_i_produced_by_clicking_a_few_tim"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00096"/><img src="httpatomoreillycomsourcenostarchimages2188961.png.jpg" alt="A drawing I produced by clicking a few times with TurtleDrawMax.py"/></div></div><p class="title">Figure 7-4. A drawing I produced by clicking a few times with <span class="emphasis"><em>TurtleDrawMax.py</em></span></p></div><p>Using the <code class="literal">setpos()</code> function as the callback for <code class="literal">turtle.onscreenclick()</code>, we’ve built a fun paint program that interacts with the user when they click the mouse by drawing lines to wherever they click. Try customizing the app with different colors, widths, or anything else you can think of to make it your own.</p></div></div><div class="sect2" title="Listening for Keyboard Events: ArrowDraw"><div class="titlepage"><div><div><h2 class="title"><a id="listening_for_keyboard_events_arrowdraw"/>Listening for Keyboard Events: ArrowDraw</h2></div></div></div><p>With our turtle drawing program, we saw how listening for mouse clicks can make the user feel like they’re more in control of the program. In this section, we’ll learn to use keyboard interaction to give the user even more options. We’ll also define our own functions to use as event handlers.</p><p>In the <span class="emphasis"><em>TurtleDraw.py</em></span> program, we passed <code class="literal">t.setpos</code> as the callback function to tell the computer what to do when an <code class="literal">onscreenclick()</code> event happened; we wanted to set the turtle’s <a id="iddle1092" class="indexterm"/><a id="iddle1503" class="indexterm"/><a id="iddle1616" class="indexterm"/><a id="iddle1814" class="indexterm"/><a id="iddle1994" class="indexterm"/><a id="iddle2016" class="indexterm"/>position to the location of that mouse click on the screen. The <code class="literal">setpos()</code> function is already given to us in the <code class="literal">turtle</code> module, but what if we want to create our own functions to handle events? Say we want to build a program that lets the user move the turtle on their screen by pressing the arrow keys instead of clicking the mouse button. How would we do that?</p><p>First, we have to build functions for moving the turtle for each arrow keypress on the keyboard, and then we have to tell the computer to listen for those keys to be pressed. Let’s write a program that will listen for the up (↑), left (←), and right (→) keyboard arrow keys and let the user move the turtle forward or turn left or right with those keys.</p><p>Let’s define some functions—<code class="literal">up()</code>, <code class="literal">left()</code>, and <code class="literal">right()</code>—that will move and turn the turtle:</p><a id="pro_id00109"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">up</span>():
    t.forward(50)
<span class="orange">def</span> <span class="blue">left</span>():
    t.left(90)
<span class="orange">def</span> <span class="blue">right</span>():
    t.right(90)</pre><p>Our first function, <code class="literal">up()</code>, moves the turtle forward 50 pixels. The second, <code class="literal">left()</code>, turns the turtle left 90 degrees. Finally, <code class="literal">right()</code> turns the turtle right 90 degrees.</p><p>To run each of these functions when the user presses the correct arrow key, we have to tell the computer which function goes with which key and tell it to start listening for keypresses. To set the callback function for a keypress event, we use <code class="literal">turtle.onkeypress()</code>. This function usually takes two parameters: the name of the callback function (the event handler functions we created) and the specific key to listen for. To connect each of the three functions to its corresponding arrow key, we would write:</p><a id="pro_id00110"/><pre class="programlisting">turtle.onkeypress(up,  <span class="green">"Up"</span>)
turtle.onkeypress(left,   <span class="green">"Left"</span>)
turtle.onkeypress(right,  <span class="green">"Right"</span>)</pre><p>The first line sets the <code class="literal">up()</code> function as the event handler for <code class="literal">"Up"</code> arrow keypresses; the function (<code class="literal">up</code>) goes first, and <code class="literal">"Up"</code> is the name of the up arrow key, ↑. The same goes for the left and right <a id="iddle1323" class="indexterm"/><a id="iddle1513" class="indexterm"/><a id="iddle1990" class="indexterm"/><a id="iddle2007" class="indexterm"/>arrow keypresses. The final step is telling the computer to begin listening for keypresses, which we do with this command:</p><a id="pro_id00111"/><pre class="programlisting">turtle.listen()</pre><p>We need this last line for a couple of reasons. First, unlike with mouse clicks, simply pressing a key doesn’t ensure that our turtle window will receive the keypress. When you click a window on your desktop, that window moves to the front and receives the <span class="emphasis"><em>focus</em></span>, meaning that window will receive input from the user. When you click the mouse on the turtle window, it automatically makes that window the focus of the screen and of any mouse events that follow. With the keyboard, though, just pressing keys doesn’t make a window receive those keypresses; the <code class="literal">turtle.listen()</code> command makes sure our turtle’s window is the focus of the desktop so that it will be able to hear keypresses. Second, the <code class="literal">listen()</code> command tells the computer to start handling keypress events for all keys that we connected to functions with the <code class="literal">onkeypress()</code> function.</p><p>Here’s the complete <span class="emphasis"><em>ArrowDraw.py</em></span> program:</p><div class="sect3" title="ArrowDraw.py"><div class="titlepage"><div><div><h3 class="title"><a id="arrowdrawdotpy"/>ArrowDraw.py</h3></div></div></div><a id="pro_id00112"/><pre class="programlisting">   <span class="orange">import</span> turtle
   t = turtle.Pen()
   t.speed(0)
➊ t.turtlesize(2,2,2)
   <span class="orange">def</span> <span class="blue">up</span>():
       t.forward(50)
   <span class="orange">def</span> <span class="blue">left</span>():
       t.left(90)
   <span class="orange">def</span> <span class="blue">right</span>():
       t.right(90)
   turtle.onkeypress(up, <span class="green">"Up"</span>)
   turtle.onkeypress(left, <span class="green">"Left"</span>)
   turtle.onkeypress(right, <span class="green">"Right"</span>)
   turtle.listen()</pre><p>At ➊, the only new line in <span class="emphasis"><em>ArrowDraw.py</em></span>, we make the turtle arrow twice as big, and give it a thicker outline with <code class="literal">t.turtlesize(2,2,2)</code>. The three parameters are the horizontal stretch (<code class="literal">2</code> means to make it twice as wide), the vertical stretch (<code class="literal">2</code> times as tall), and the outline thickness (<code class="literal">2</code> pixels thick). <a class="xref" href="ch07.html#arrowdrawdotpy_program_lets_the_user_dra" title="Figure 7-5. The ArrowDraw.py program lets the user draw using the up, right, and left arrow keys. The larger turtle arrow makes it easier to see where the turtle is headed.">Figure 7-5</a> shows the result.</p><div class="figure"><a id="arrowdrawdotpy_program_lets_the_user_dra"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00097"/><img src="httpatomoreillycomsourcenostarchimages2188963.png.jpg" alt="The ArrowDraw.py program lets the user draw using the up, right, and left arrow keys. The larger turtle arrow makes it easier to see where the turtle is headed."/></div></div><p class="title">Figure 7-5. The <span class="emphasis"><em>ArrowDraw.py</em></span> program lets the user draw using the up, right, and left arrow keys. The larger turtle arrow makes it easier to see where the turtle is headed.</p></div><p><a id="iddle1093" class="indexterm"/><a id="iddle1164" class="indexterm"/><a id="iddle1299" class="indexterm"/><a id="iddle1302" class="indexterm"/><a id="iddle1577" class="indexterm"/><a id="iddle1619" class="indexterm"/><a id="iddle1639" class="indexterm"/><a id="iddle1855" class="indexterm"/><a id="iddle1973" class="indexterm"/><a id="iddle1997" class="indexterm"/>This app is a bit like the old Etch-A-Sketch toy: you can draw fun shapes using just those three arrow keys, and you can retrace your steps. Feel free to customize the app with your own colors, pen width, and any other features you’d like to add. One extra feature you could add, which is included as a challenge at the end of this chapter, is the ability to click to move the turtle to a new location. Dream up new features and give them a try—that’s the best way to learn something new!</p></div></div><div class="sect2" title="Handling Events with Parameters: Clickspiral"><div class="titlepage"><div><div><h2 class="title"><a id="handling_events_with_parameters_clickspi"/>Handling Events with Parameters: Clickspiral</h2></div></div></div><p>In <span class="emphasis"><em>TurtleDraw.py</em></span>, we let the user click to draw by telling the <code class="literal">turtle.onscreenclick()</code> listener to call the <code class="literal">t.setpos</code> function anytime the user clicked the screen. Let’s build a new program named <span class="emphasis"><em>ClickSpiral.py</em></span> that will draw spirals wherever the user clicks, as shown in <a class="xref" href="ch07.html#smiley_face_drawn_using_the_clickspirald" title="Figure 7-6. A smiley face drawn using the ClickSpiral.py app">Figure 7-6</a>.</p><p>The <code class="literal">onscreenclick()</code> listener passes the x- and y-coordinates of every mouse click as arguments to the callback function we specify. When we want to handle mouse click events with a function of our own, we simply write a function that accepts those values—the x- and y-coordinates of the mouse click—as a pair of parameters.</p><div class="figure"><a id="smiley_face_drawn_using_the_clickspirald"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00098"/><img src="httpatomoreillycomsourcenostarchimages2188965.png.jpg" alt="A smiley face drawn using the ClickSpiral.py app"/></div></div><p class="title">Figure 7-6. A smiley face drawn using the <span class="emphasis"><em>ClickSpiral.py</em></span> app</p></div><p><a id="iddle1165" class="indexterm"/><a id="iddle1781" class="indexterm"/><a id="iddle1785" class="indexterm"/><span class="emphasis"><em>RandomSpiralsFunction.py</em></span> (<a class="xref" href="ch07.html#randomspiralsfunctiondotpy" title="RandomSpiralsFunction.py">RandomSpiralsFunction.py</a>) contained a function called <code class="literal">random_spiral()</code> that drew colorful spirals in random places on the screen. Now, however, instead of spirals at random locations, we want a spiral to appear where the user clicks the mouse. To do this, we can rewrite the <code class="literal">random_spiral()</code> function to take two parameters, <code class="literal">x</code> and <code class="literal">y</code>, from the <code class="literal">turtle.onscreenclick()</code> listener. We’ll rename the function <code class="literal">spiral(x,y)</code>:</p><a id="pro_id00113"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">spiral</span>(x,y):
    t.pencolor(random.choice(colors))
    size = random.randint(10,40)
    t.penup()
    t.setpos(x,y)
    t.pendown()
    <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
        t.forward(m*2)
        t.left(91)</pre><p><a id="iddle1914" class="indexterm"/><a id="iddle1974" class="indexterm"/>In this new version, we change the function’s definition to reflect the new name and the two parameters that we will receive to draw at chosen positions on the screen as <code class="literal">spiral(x,y)</code>. We still choose a random color and size for each spiral, but we have removed the two lines that generate a random <code class="literal">x</code> and <code class="literal">y</code>, because we will get the <code class="literal">x</code> and <code class="literal">y</code> as arguments from the <code class="literal">onscreenclick()</code> listener. Just as with the <code class="literal">random_spiral()</code> function, we move the pen to the correct (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) position and then draw the spiral.</p><p>The only step left is to set up our turtle window and the list of colors, and then tell our <code class="literal">turtle.onscreenclick()</code> listener to call the spiral function whenever the user clicks the mouse button over the drawing window. Here’s the complete program:</p><div class="sect3" title="ClickSpiral.py"><div class="titlepage"><div><div><h3 class="title"><a id="clickspiraldotpy"/>ClickSpiral.py</h3></div></div></div><a id="pro_id00114"/><pre class="programlisting">   <span class="orange">import</span> random
   <span class="orange">import</span> turtle
   t = turtle.Pen()
   t.speed(0) turtle.bgcolor(<span class="green">"black"</span>)
   colors = [<span class="green">"red"</span>, <span class="green">"yellow"</span>, <span class="green">"blue"</span>, <span class="green">"green"</span>, <span class="green">"orange"</span>, <span class="green">"purple"</span>,
             <span class="green">"white"</span>, <span class="green">"gray"</span>]
   <span class="orange">def</span> <span class="blue">spiral</span>(x,y):
       t.pencolor(random.choice(colors))
       size = random.randint(10,40)
       t.penup()
       t.setpos(x,y)
       t.pendown()
       <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
           t.forward(m*2)
           t.left(91)
➊ turtle.onscreenclick(spiral)</pre><p>As in <span class="emphasis"><em>TurtleDraw.py</em></span>, we leave out the parentheses and parameters for our callback function ➊: <code class="literal">turtle.onscreenclick(spiral)</code> tells our program that it should call our <code class="literal">spiral(x,y)</code> function every time the user clicks the mouse on the screen, and the event listener automatically sends two arguments—the x-position and y-position of that click—to the <code class="literal">spiral</code> callback function. The same thing happened in <span class="emphasis"><em>TurtleDraw.py</em></span> with the <code class="literal">t.setpos</code> callback, but this time, we created our own function to draw a spiral of a random color and size at the location of the mouse button click.</p></div></div><div class="sect2" title="Taking It One Step Further: Clickandsmile"><div class="titlepage"><div><div><h2 class="title"><a id="taking_it_one_step_further_clickandsmile"/>Taking It One Step Further: Clickandsmile</h2></div></div></div><p><a id="iddle1156" class="indexterm"/><a id="iddle1267" class="indexterm"/><a id="iddle1780" class="indexterm"/><a id="iddle1856" class="indexterm"/>Let’s extend this interactive app by making one more change. Instead of drawing a spiral, say we want to draw a smiley face wherever the user clicks the mouse on the drawing screen. The code will look a lot like our <span class="emphasis"><em>RandomSmileys.py</em></span> program from <a class="xref" href="ch07.html#putting_it_all_together-id00013" title="Putting it all together">Putting it all together</a>, but instead of a loop that draws 50 smiley faces at random locations on the screen, this program will handle the mouse click event by drawing a smiley at the location the user chooses, as many or as few times as the user wishes to click.</p><p>In fact, because our <code class="literal">draw_smiley()</code> function already takes two parameters (the x- and y-coordinates of the location where we wish to draw the smiley face), the code for <span class="emphasis"><em>ClickAndSmile.py</em></span> is identical to <span class="emphasis"><em>RandomSmileys.py</em></span>, except for the last section. Just replace the <code class="literal">for</code> loop that draws 50 random smileys with a call to <code class="literal">turtle.onscreenclick(draw_smiley)</code>. Remember how the <code class="literal">turtle.onscreenclick()</code> function allows us to pass the name of a function (like <code class="literal">setpos</code>) as the event handler for mouse clicks? We can pass it <code class="literal">draw_smiley</code> so that when the user clicks, our <code class="literal">draw_smiley()</code> function will do its work at the location of the click. We do not include <code class="literal">draw_smiley</code>’s parentheses, or any arguments, inside the parentheses for <code class="literal">turtle.onscreenclick()</code>.</p><div class="sect3" title="ClickAndSmile.py"><div class="titlepage"><div><div><h3 class="title"><a id="clickandsmiledotpy"/>ClickAndSmile.py</h3></div></div></div><a id="pro_id00115"/><pre class="programlisting"><span class="orange">import</span> random
<span class="orange">import</span> turtle
t = turtle.Pen()
t.speed(0)
t.hideturtle()
turtle.bgcolor(<span class="green">"black"</span>)
<span class="orange">def</span> <span class="blue">draw_smiley</span>(x,y):
    t.penup()
    t.setpos(x,y)
    t.pendown()
    <span class="red"># Face</span>
    t.pencolor("y<span class="green">ellow")</span>
    t.fillcolor("y<span class="green">ellow")</span>
    t.begin_fill()
    t.circle(50)
    t.end_fill()
    <span class="red"># Left eye</span>
    t.setpos(x-15, y+60)
    t.fillcolor("b<span class="green">lue")</span>
    t.begin_fill()
    t.circle(10)
    t.end_fill()
    <span class="red"># Right eye</span>
    t.setpos(x+15, y+60)
    t.begin_fill()
    t.circle(10)
    t.end_fill()
    <span class="red"># Mouth</span>
    t.setpos(x-25, y+40)
    t.pencolor("b<span class="green">lack")</span>
    t.width(10)
    t.goto(x-10, y+20)
    t.goto(x+10, y+20)
    t.goto(x+25, y+40)
    t.width(1)
turtle.onscreenclick(draw_smiley)</pre><p><a id="iddle1157" class="indexterm"/>Now, instead of drawing random smiley faces all over the screen, the user can draw a smiley face wherever they click the mouse; they can even draw a big smiley face out of little smiley faces, as shown in <a class="xref" href="ch07.html#weapostropheve_made_our_smiley_program_m" title="Figure 7-7. We’ve made our smiley program more interactive, drawing wherever the user clicks.">Figure 7-7</a>.</p><div class="figure"><a id="weapostropheve_made_our_smiley_program_m"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00099"/><img src="httpatomoreillycomsourcenostarchimages2188967.png.jpg" alt="We’ve made our smiley program more interactive, drawing wherever the user clicks."/></div></div><p class="title">Figure 7-7. We’ve made our smiley program more interactive, drawing wherever the user clicks.</p></div><p><a id="iddle1263" class="indexterm"/><a id="iddle1486" class="indexterm"/><a id="iddle1620" class="indexterm"/><a id="iddle1998" class="indexterm"/>Whatever kinds of apps you want to build, you’re probably going to rely on user interaction to drive the experience. Think of the games or other apps that you spend the most time playing: what they all have in common is that you have some kind of control over what happens and when. Whether you’re moving a paddle to hit a ball; pressing the mouse button or touching and dragging to fire something through the air; or clicking, swiping, and tapping to clear a screen, you’re generating user events—and the programs you love handle those events by doing something cool. Let’s build one more interactive app for practice, and then we’ll build even more of the kinds of apps we play with every day.</p></div></div></div><div class="sect1" title="ClickKaleidoscope"><div class="titlepage"><div><div><h1 class="title"><a id="clickkaleidoscope"/>ClickKaleidoscope</h1></div></div></div><p>Let’s combine our ability to create functions and our ability to handle interactive clicks to create an interactive kaleidoscope. The user will be able to click anywhere on the screen, and four reflected spirals of a random shape and color will be drawn starting from the point where the user clicked. The result will look like our <span class="emphasis"><em>Kaleidoscope.py</em></span> program from <a class="xref" href="ch06.html#kaleidoscopedotpy" title="Kaleidoscope.py">Kaleidoscope.py</a>, but the user will be able to create their own unique patterns using this kaleidoscope.</p><div class="sect2" title="The Draw_Kaleido() Function"><div class="titlepage"><div><div><h2 class="title"><a id="drawunderscorekaleidoleft_parenthesisrig"/>The Draw_Kaleido() Function</h2></div></div></div><p>Let’s talk about the challenges in building a customized kaleidoscope program. We know we want to allow the user to click the screen to begin the drawing process, so we’ll use the <code class="literal">turtle.onscreenclick()</code> function from the previous section. We know that this function will give us an (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location on the screen that we can use in our callback function. And we can look back at our original kaleidoscope program to see that all we have to do is draw a spiral at each of the four points (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>), (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>y</em></span>), (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>–y</em></span>), and (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>–y</em></span>) to achieve the desired reflection effect.</p><p>Each of our four reflected spirals should be the same color and size to create the mirror illusion. We will call our function <code class="literal">draw_ kaleido()</code> and define it as follows:</p><a id="pro_id00116"/><pre class="programlisting">➊ <span class="orange">def</span> <span class="blue">draw_kaleido</span>(x,y):
➋     t.pencolor(random.choice(colors))
➌     size = random.randint(10,40)
       draw_spiral(x,y, size)
       draw_spiral(-x,y, size)
       draw_spiral(-x,-y, size)
       draw_spiral(x,-y, size)</pre><p><a id="iddle1268" class="indexterm"/>At ➊, we name our function <code class="literal">draw_kaleido</code>, and we allow it to take the two parameters, <code class="literal">x</code> and <code class="literal">y</code>, from the <code class="literal">turtle.onscreenclick()</code> event handler so that our four reflected spirals will start at the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location where the user clicked the mouse. Then, at ➋, we randomly choose a pen color for all four reflected spirals in a set from our usual list of colors, <code class="literal">colors</code>.</p><p>At ➌, we pick a random size for all four reflected spirals and store it in <code class="literal">size</code>. Finally, we draw all of the four spirals at their (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>), (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>y</em></span>), (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>–y</em></span>), and (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>–y</em></span>) locations with a new function we’ve yet to actually write, called <code class="literal">draw_spiral()</code>.</p><div class="informalfigure"><a id="med_id00100a"/><div class="mediaobject"><a id="med_id00100"/><img src="httpatomoreillycomsourcenostarchimages2188969.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="The Draw_Spiral() Function"><div class="titlepage"><div><div><h2 class="title"><a id="drawunderscorespiralleft_parenthesisrigh"/>The Draw_Spiral() Function</h2></div></div></div><p>Our <code class="literal">draw_spiral()</code> function will need to draw a spiral starting at a custom (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location on the screen. Python’s turtle pen will remember the color once it’s set, so we don’t have to pass that information as a parameter to our <code class="literal">draw_spiral()</code> function, but we do need the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location and the <code class="literal">size</code> of the spiral that we want to draw. So we’ll define our <code class="literal">draw_spiral()</code> function to take three parameters:</p><a id="pro_id00117"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">draw_spiral</span>(x,y, size):
    t.penup()
    t.setpos(x,y)
    t.pendown()
    <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
        t.forward(m*2)
        t.left(92)</pre><p><a id="iddle1161" class="indexterm"/>This function takes the parameters <code class="literal">x</code> and <code class="literal">y</code> for the location to start drawing each spiral, and the parameter <code class="literal">size</code> to tell us how big to make the spiral. Inside the function, we lift the turtle’s pen so that we can move without leaving a trail, we move the pen to the given (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location, and we put the pen back down to prepare for the spiral. Our <code class="literal">for</code> loop will iterate <code class="literal">m</code> over the values from <code class="literal">0</code> to <code class="literal">size</code>, drawing a square spiral up to that side length.</p><p>All we’ll have to do in our program, besides importing <code class="literal">random</code> and <code class="literal">turtle</code> and setting up our screen and list of colors, is tell the computer to listen for clicks on the turtle screen and call the <code class="literal">draw_ kaleido()</code> function whenever a click event happens. We can do that with the command <code class="literal">turtle.onscreenclick(draw_kaleido)</code>.</p></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00014"/>Putting It All Together</h2></div></div></div><p>Here’s the full <span class="emphasis"><em>ClickKaleidoscope.py</em></span> program. Type it in IDLE or download it from <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> and run it.</p><div class="sect3" title="ClickKaleidoscope.py"><div class="titlepage"><div><div><h3 class="title"><a id="clickkaleidoscopedotpy"/>ClickKaleidoscope.py</h3></div></div></div><a id="pro_id00118"/><pre class="programlisting"><span class="orange">import</span> random
<span class="orange">import</span> turtle
t = turtle.Pen()
t.speed(0)
t.hideturtle()
turtle.bgcolor(<span class="green">"black"</span>)
colors = [<span class="green">"red"</span>, <span class="green">"yellow"</span>, <span class="green">"blue"</span>, <span class="green">"green"</span>, <span class="green">"orange"</span>, <span class="green">"purple"</span>,
          <span class="green">"white"</span>, <span class="green">"gray"</span>]
<span class="orange">def</span> <span class="blue">draw_kaleido</span>(x,y):
    t.pencolor(random.choice(colors))
    size = random.randint(10,40)
    draw_spiral(x,y, size)
    draw_spiral(-x,y, size)
    draw_spiral(-x,-y, size)
    draw_spiral(x,-y, size)
<span class="orange">def</span> <span class="blue">draw_spiral</span>(x,y, size):
    t.penup()
    t.setpos(x,y)
    t.pendown()
    <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
        t.forward(m*2)
        t.left(92)
turtle.onscreenclick(draw_kaleido)</pre><p>We begin with our normal <code class="literal">import</code> statements and then set up our turtle environment and list of colors. Next, we define our <a id="iddle1162" class="indexterm"/><a id="iddle1264" class="indexterm"/><a id="iddle1845" class="indexterm"/><code class="literal">draw_spiral()</code> function, followed by <code class="literal">draw_kaleido()</code>, and we finish by telling the computer to listen for clicks on the turtle screen and call <code class="literal">draw_kaleido()</code> when click events occur. Now, whenever the user clicks a location on the drawing window, a spiral will be drawn there and reflected across the x- and y-axes for a total of four spirals of the same random shape and size.</p><p>The result is a fully interactive version of our spiral kaleidoscope program that allows the user to control the reflected pattern by clicking only in parts of the screen where they want spirals to appear. <a class="xref" href="ch07.html#with_our_interactive_kaleidoscope_progra" title="Figure 7-8. With our interactive kaleidoscope program, you can create any reflected pattern you wish!">Figure 7-8</a> shows a sample run of the program with reflected patterns made of spirals.</p><div class="figure"><a id="with_our_interactive_kaleidoscope_progra"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00101"/><img src="httpatomoreillycomsourcenostarchimages2188971.png.jpg" alt="With our interactive kaleidoscope program, you can create any reflected pattern you wish!"/></div></div><p class="title">Figure 7-8. With our interactive kaleidoscope program, you can create any reflected pattern you wish!</p></div><p>Try your own patterns (like your first initial!) and take a screenshot of your results (in Windows, hold down the ALT and PRINT SCREEN keys to copy the turtle window and then paste into Word or your favorite drawing program; on a Mac, press and hold the COMMAND [<span class="inlinemediaobject"><a id="inline_id00004"/><img src="httpatomoreillycomsourcenostarchimages2188973.png.jpg" alt=""/></span>], SHIFT, and 4 keys, then press the spacebar, and then click the turtle drawing window to save a copy of the picture to your desktop as <span class="emphasis"><em>Screenshot &lt;date and time&gt;.png</em></span>). Tweet your best screenshots to me at @brysonpayne on Twitter with the hashtag #kidscodebook, and I’ll do my best to respond!</p></div></div></div><div class="sect1" title="What You Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_learned-id00015"/>What You Learned</h1></div></div></div><p>In this chapter, you learned how to organize chunks of reusable code into functions, call your own functions from anywhere in your programs, pass information as parameters to those functions, and get information back from functions as return values. We wrote our first event-driven programs by telling the computer to listen for mouse clicks and keypresses, and you learned how to write your own callback functions to respond to user events.</p><p>We’ve developed our first fully interactive programs. Using the skills you’ve gained in this chapter, you’re ready to begin writing even more advanced apps. The apps we frequently enjoy give users the experience of being in control of the program by responding to clicks, touches, keypresses, and more.</p><p>After mastering the concepts in this chapter, you should be able to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Make code more reusable using functions.</p></li><li class="listitem"><p>Organize and group code into functions.</p></li><li class="listitem"><p>Define functions in Python using the <code class="literal">def</code> keyword.</p></li><li class="listitem"><p>Call your own functions from programs that you write.</p></li><li class="listitem"><p>Define and use functions that accept parameters as input values.</p></li><li class="listitem"><p>Write functions that return values when called.</p></li><li class="listitem"><p>Convert a mathematical formula into a function that returns the function’s value.</p></li><li class="listitem"><p>Explain some features of event-driven programs.</p></li><li class="listitem"><p>Write a basic event-driven app that uses an event handler.</p></li><li class="listitem"><p>Write an app that accepts mouse clicks and draws on the screen.</p></li><li class="listitem"><p>Code event handlers for keyboard events.</p></li><li class="listitem"><p>Program event handler functions that take parameters.</p></li><li class="listitem"><p>Use x- and y-coordinates on the screen to draw specific patterns, such as kaleidoscopes.</p></li></ul></div><div class="sidebar"><a id="programming_challenges-id00016"/><p class="title">Programming Challenges</p><p><a id="iddle1094" class="indexterm"/><a id="iddle1158" class="indexterm"/><a id="iddle1163" class="indexterm"/><a id="iddle1621" class="indexterm"/><a id="iddle1661" class="indexterm"/>Here are three challenges to extend what you learned in this chapter. For sample answers to these challenges, go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>.</p><p><span class="strong"><strong><span class="orange">#1: Mirrored Smileys</span></strong></span></p><p>Create a mashup of the programs <span class="emphasis"><em>ClickAndSmile.py</em></span> and <span class="emphasis"><em>ClickKaleidoscope.py</em></span> to draw a smiley face in four mirrored corners of the screen when you click, just like the kaleidoscope program did with spirals. If you’d like an advanced challenge, draw two of the smiley faces flipped upside down so that they really look mirrored across the x-axis.</p><p><span class="strong"><strong><span class="orange">#2: More Ping-Pong Calculations</span></strong></span></p><p>Modify the Ping-Pong calculator so it asks the user for a number of Ping-Pong balls as input. Have it tell the user both how tall those Ping-Pong balls would be if stacked on top of one another and how much that number of Ping-Pong balls would weigh.</p><p><span class="strong"><strong><span class="orange">#3: A Better Drawing Program</span></strong></span></p><p>Change the <span class="emphasis"><em>ArrowDraw.py</em></span> program to allow the user to turn the turtle in smaller increments—say 45 degrees (or even 30 or 15)—to give them finer control of the turtle. Then, add more key options, like allowing the user to press the greater-than symbol (&gt;) to make the drawing length longer, the less-than symbol (&lt;) to shorten the drawing length, the W key to make the pen wider, and the T key to make the pen thinner. To make it a great drawing program, add feedback in the form of drawing a string on the screen to show the pen width, segment length, and turtle’s direction after every change.</p><p>For a finishing touch, add the ability to click to reposition the turtle. (Hint: create a function that accepts two parameters (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>), lifts the turtle’s pen, moves to (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>), then puts the pen back down. Then, pass the name of this function to <code class="literal">turtle.onscreenclick()</code> to complete the app.)</p></div></div></div></body></html>