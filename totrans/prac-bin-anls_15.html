<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_309"/><span class="big">12</span><br/>PRINCIPLES OF SYMBOLIC EXECUTION</h2>&#13;
<p class="startpara"><em>Symbolic execution</em> tracks metadata about the program state, just as taint analysis does. But unlike taint information, which only lets you infer <em>that</em> part of the program state affects another, symbolic execution allows you to reason about <em>how</em> the program state came to be and how to reach different program states. As you’ll see, symbolic execution enables many powerful analyses not possible with other techniques.</p>&#13;
<p class="indent">I’ll start this chapter with an overview of the basics of symbolic execution. Then, you’ll learn more about <em>constraint solving</em> (specifically, <em>SMT solving</em> ), which is a fundamental building block of symbolic execution. In <a href="ch13.xhtml#ch13">Chapter 13</a>, you’ll use Triton, a binary-level symbolic execution library, to build practical tools that demonstrate what symbolic execution can do.</p>&#13;
<h3 class="h3" id="ch12_1">12.1 An Overview of Symbolic Execution</h3>&#13;
<p class="noindent">Symbolic execution, or <em>symbex</em> for short, is a software analysis technique that expresses program state in terms of logical formulas that you can automatically reason about to answer complex questions about a program’s <span epub:type="pagebreak" id="page_310"/>behavior. For example, NASA uses symbolic execution to generate test cases for mission-critical code, and hardware manufacturers use it to test code written in hardware description languages like Verilog and VHDL. You can also use symbolic execution to automatically increase the <em>code coverage</em> of dynamic analyses by generating new inputs that lead to unexplored program paths, which is useful for software testing and malware analysis. In <a href="ch13.xhtml#ch13">Chapter 13</a>, you’ll see practical examples that use symbex to implement code coverage, implement backward slicing, and even automatically generate exploits for vulnerabilities!</p>&#13;
<p class="indent">Unfortunately, although symbolic execution is a powerful technique, you have to apply it sparingly and carefully because of scalability issues. For example, depending on the type of symbolic execution problem you’re solving, the complexity may increase exponentially to the point where computing a solution becomes completely intractable. You’ll learn how to minimize these scalability issues in <a href="ch12.xhtml#ch12_2_3">Section 12.1.3</a>, but first let’s review the basic workings of symbolic execution.</p>&#13;
<h4 class="h4" id="ch12_1_1"><em>12.1.1 Symbolic vs. Concrete Execution</em></h4>&#13;
<p class="noindent">Symbex executes (or emulates) an application with <em>symbolic values</em> instead of the concrete values used when you normally run a program. This means that variables don’t contain specific values like <span class="literal">42</span> or <span class="literal">foobar</span> as they would in a normal execution. Instead, some or all variables (or in the context of binary analysis, registers or memory locations) are represented by a symbol that stands in for any possible value the variable could take. As the execution proceeds, symbolic execution computes logical formulas over these symbols. These formulas represent the operations performed on the symbols during execution and describe limits for the range of values the symbols can represent.</p>&#13;
<p class="indent">As I’ll explain, many symbex engines maintain the symbols and formulas as metadata <em>in addition to</em> concrete values rather than replacing the concrete values, similar to how taint analysis tracks taint metadata. The collection of symbolic values and formulas that a symbex engine maintains is called the <em>symbolic state</em>. Let’s look at how the symbolic state is organized and then look at a concrete example of how the state evolves in a symbolic execution.</p>&#13;
<h5 class="h5">The Symbolic State</h5>&#13;
<p class="noindent">Symbolic execution operates on symbolic values that represent any possible concrete value. I’ll denote symbolic values as <em>α</em><sub>i</sub>, where <em>i</em> is an integer (<em>i</em> ∈ <em>N</em>). The symbex engine computes two different kinds of formulas over these symbolic values: a set of <em>symbolic expressions</em> and a <em>path constraint</em>. In addition, it maintains a mapping of variables (or in the case of binary symbex, registers and memory locations) to symbolic expressions. I refer to the combination of the path constraint and all symbolic expressions and mappings as the <em>symbolic state</em>.</p>&#13;
<p class="li"><strong>Symbolic expressions</strong> A symbolic expression <em>ϕ</em><sub>j</sub>, with <em>j</em> ∈ <em>N</em>, corresponds either to a symbolic value <em>α</em><sub>i</sub> or to some mathematical combination of symbolic expressions, such as <em>ϕ</em><sub>3</sub> = <em>ϕ</em><sub>1</sub> + <em>ϕ</em><sub>2</sub>. I’ll use σ to denote the <span epub:type="pagebreak" id="page_311"/><em>symbolic expression store</em>, which is the set of all the symbolic expressions used in the symbolic execution. As I mentioned, binary-level symbex maps all or some of the registers and memory locations to an expression in σ.</p>&#13;
<p class="li"><strong>Path constraint</strong> The path constraint encodes the limitations imposed on the symbolic expressions by the branches taken during execution. For instance, if the symbolic execution takes a branch <span class="literal">if(x &lt; 5)</span> and then another branch <span class="literal">if(y &gt;= 4)</span>, where <em>x</em> and <em>y</em> are mapped to the symbolic expressions <em>ϕ</em><sub>1</sub> and <em>ϕ</em><sub>2</sub>, respectively, the path constraint formula becomes <em>ϕ</em><sub>1</sub> &lt; 5 ∧ <em>ϕ</em><sub>2</sub> ≥ 4. I’ll denote the path constraint as the symbol <em>π</em>.</p>&#13;
<p class="indent">In the literature on symbolic execution, path constraints are sometimes referred to as <em>branch constraints</em>. In this book, I’ll use the term <em>branch constraint</em> to refer to the constraint imposed by an individual branch and the term <em>path constraint</em> to refer to the conjunction of all the branch constraints accumulated along a program path.</p>&#13;
<h5 class="h5">Symbolically Executing an Example Program</h5>&#13;
<p class="noindent">Let’s make the concept of symbolic execution more concrete using the pseudocode in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>.</p>&#13;
<p class="listing1" id="ch12list1"><em>Listing 12-1: Pseudocode example to illustrate symbolic execution</em></p>&#13;
<p class="programs"><span class="ent">➊</span> x = int(argv[0])<br/>   y = int(argv[1])<br/><br/><span class="ent">➋</span> z = x + y<br/><span class="ent">➌</span> if(x &gt;= 5)<br/>      foo(x, y, z)<br/>      y = y + z<br/>      if(y &lt; x)<br/>          baz(x, y, z)<br/>      else<br/>          qux(x, y, z)<br/><span class="ent">➍</span> else<br/>      bar(x, y, z)</p>&#13;
<p class="indent">This pseudocode program takes two integers called <em>x</em> and <em>y</em> from user input. The example explored in this section uses symbolic execution to find user inputs that would cover paths through the code leading to the <span class="literal">foo</span> and <span class="literal">bar</span> functions, respectively. To achieve this, you represent <em>x</em> and <em>y</em> as symbolic values and then symbolically execute the program to compute the path constraint and symbolic expressions imposed on <em>x</em> and <em>y</em> by the program’s operations. Finally, you solve these formulas to find concrete values (if they exist) for <em>x</em> and <em>y</em> that lead the program to traverse each path. <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> shows how the symbolic state evolves for all possible paths through the example function.</p>&#13;
<div class="image"><a id="ch12fig1"/><img src="Images/f312-01.jpg" alt="image" width="609" height="1170"/></div>&#13;
<p class="fig-caption"><em>Figure 12-1: <span epub:type="pagebreak" id="page_312"/>Path constraints and symbolic state for all paths in the example function</em></p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list1">Listing 12-1</a> <span epub:type="pagebreak" id="page_313"/>starts by reading <em>x</em> and <em>y</em> from user input <span class="ent">➊</span>. As you can see in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>, the path constraint <em>π</em> is initially set to ┬, the tautology symbol. This shows that no branches have yet been executed, so no constraints are imposed. Similarly, the symbolic expression store is initially the empty set. After reading <em>x</em>, the symbex engine creates a new symbolic expression <em>ϕ</em><sub>1</sub> = <em>α</em><sub>1</sub>, which corresponds to an <em>unconstrained</em> symbolic value that can represent any concrete value, and maps <em>x</em> to that expression. Reading <em>y</em> causes an analogous effect, mapping <em>y</em> to <em>ϕ</em><sub>2</sub> = <em>α</em><sub>2</sub>. Next, the operation <em>z</em> = <em>x</em> + <em>y</em> <span class="ent">➋</span> causes the symbex engine to map <em>z</em> to a new symbolic expression, <em>ϕ</em><sub>3</sub> = <em>ϕ</em><sub>1</sub> + <em>ϕ</em><sub>2</sub>.</p>&#13;
<p class="indent">Let’s assume the symbolic execution engine first explores the <span class="literal">true</span> branch of the conditional <span class="literal">if(x &gt;= 5)</span> <span class="ent">➌</span>. To do that, the engine adds the branch constraint <em>ϕ</em><sub>1</sub> ≥ 5 to <em>π</em> and continues the symbolic execution at the branch target, which is the call to <span class="literal">foo</span>. Recall that the goal was to find concrete user inputs that lead to the <span class="literal">foo</span> or <span class="literal">bar</span> function. Because you’ve now reached a call to <span class="literal">foo</span>, you can solve the expressions and branch constraints to find concrete values for <em>x</em> and <em>y</em> that lead to this <span class="literal">foo</span> invocation.</p>&#13;
<p class="indent">At this point in the execution, <em>x</em> and <em>y</em> map to the symbolic expressions <em>ϕ</em><sub>1</sub> = <em>α</em><sub>1</sub> and <em>ϕ</em><sub>2</sub> = <em>α</em><sub>2</sub>, respectively, and <em>α</em><sub>1</sub> and <em>α</em><sub>2</sub> are the only symbolic values. Moreover, you have only one branch constraint: <em>ϕ</em><sub>1</sub> ≥ 5. Thus, one possible solution to reach this call to <span class="literal">foo</span> is <em>α</em><sub>1</sub> = 5 ∧ <em>α</em><sub>2</sub> = 0. This means that if you run the program normally (a concrete execution) with user inputs <em>x</em> = 5 and <em>y</em> = 0, you’ll reach the call to <span class="literal">foo</span>. Note that <em>α</em><sub>2</sub> could take any value because it doesn’t occur in any of the symbolic expressions that appear in the path constraint.</p>&#13;
<p class="indent">A solution like the one you just saw is called a <em>model</em>. You usually compute models automatically with a special program called a <em>constraint solver</em>, which is capable of solving for the symbolic values such that all constraints and symbolic expressions are satisfied, as you’ll learn shortly in <a href="ch12.xhtml#ch12_2">Section 12.2</a>.</p>&#13;
<p class="indent">Now let’s say you want to find out how to reach the call to <span class="literal">bar</span> instead. To do this, you have to avoid the <span class="literal">if(x &gt;= 5)</span> branch and take the <span class="literal">else</span> branch instead <span class="ent">➍</span>. So you change the old path constraint <em>ϕ</em><sub>1</sub> ≥ 5 to <em>ϕ</em><sub>1</sub> &lt; 5 and ask the constraint solver for a new model. In this case, a possible model would be <em>α</em><sub>1</sub> = 4 ∧ <em>α</em><sub>2</sub> = 0. In some cases, the solver might also report that no solution exists, meaning that the path is unreachable.</p>&#13;
<p class="indent">In general, it’s not feasible to cover all paths through a nontrivial program since the number of possible paths increases exponentially with the number of branches. In <a href="ch12.xhtml#ch12_1_3">Section 12.1.3</a>, you’ll learn how to use heuristics to decide which paths to explore.</p>&#13;
<p class="indent">As I mentioned, there are several variants of symbolic execution, some of which work slightly differently from the example just covered. Let’s take a look at these other variants of symbolic execution and explore their trade-offs.</p>&#13;
<h4 class="h4" id="ch12_1_2"><em>12.1.2 Variants and Limitations of Symbolic Execution</em></h4>&#13;
<p class="noindent">Like taint analysis engines, symbex engines are often designed as a framework that you can use to build your own symbex tools. Many symbex engines <span epub:type="pagebreak" id="page_314"/>implement aspects from multiple symbolic execution variants and allow you to choose between them. Therefore, it’s important to be familiar with the trade-offs of these design decisions.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12fig2">Figure 12-2</a> illustrates the most important design dimensions for symbex implementations, showing one dimension per level of the tree.</p>&#13;
<p class="li"><strong>Static vs. dynamic</strong> Is the symbex implementation based on static or dynamic analysis?</p>&#13;
<p class="li"><strong>Online vs. offline</strong> Does the symbex engine explore multiple paths in parallel (<em>online</em>) or not (<em>offline</em>)?</p>&#13;
<p class="li"><strong>Symbolic state</strong> Which parts of the program state are represented symbolically, and which are concrete? How are symbolic memory accesses handled?</p>&#13;
<p class="li"><strong>Path coverage</strong> Which (and how many) program paths does the symbolic analysis explore?</p>&#13;
<div class="image"><a id="ch12fig2"/><img src="Images/f314-01.jpg" alt="image" width="694" height="393"/></div>&#13;
<p class="fig-caption"><em>Figure 12-2: Symbolic execution design dimensions</em></p>&#13;
<p class="indent">Let’s discuss each of these design decisions and their trade-offs in performance, limitations, and completeness.</p>&#13;
<h5 class="h5">Static Symbolic Execution (SSE)</h5>&#13;
<p class="noindent">Like most software and binary analysis techniques, symbolic execution exists in static and dynamic variants with different trade-offs in scalability and completeness. Traditionally, symbolic execution is a static analysis technique that emulates part of a program, propagating symbolic state with each emulated instruction. This type of symbolic execution is also known as <em>static symbolic execution (SSE)</em>. It either analyzes all possible paths exhaustively or uses heuristics to decide which paths to traverse.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_315"/>An advantage of SSE is that it enables you to analyze programs that can’t run on your CPU. For example, you can analyze ARM binaries on an x86 machine. Another benefit is that it’s easy to emulate only part of a binary (for instance, just one function) instead of the whole program.</p>&#13;
<p class="indent">The disadvantage is that exploring both directions at every branch isn’t always possible because of scalability issues. While you can use heuristics to limit the number of explored branches, it’s far from trivial to come up with effective heuristics that capture all the interesting paths.</p>&#13;
<p class="indent">Moreover, some parts of an application’s behavior are hard to model correctly with SSE, specifically when control flows outside the application to software components that the symbolic execution engine doesn’t control, such as the kernel or a library. This happens when a program issues a system call or library call, receives a signal, tries to read an environment variable, and so on. To get around this problem, you can use the following solutions, although each comes with its own disadvantages:</p>&#13;
<p class="li"><strong>Effect modeling</strong> A common approach is for the SSE engine to model the effects of external interactions like system calls and library calls. These models are a sort of “summary” of the effects that a system or library call has on the symbolic state. (Note that the word <em>model</em> in this sense has nothing to do with the models returned by the constraint solver.)</p>&#13;
<p class="li-indent">Performance-wise, effect modeling is a relatively cheap solution. However, creating accurate models for all possible environment interactions—including with the network, the filesystem, and other processes—is a monumental task, which may involve creating a simulated symbolic filesystem, symbolic network stack, and so on. To make matters worse, the models have to be rewritten if you want to simulate a different operating system or kernel. Models are therefore often incomplete or inaccurate in practice.</p>&#13;
<p class="li"><strong>Direct external interactions</strong> Alternatively, the symbolic execution engine may directly perform external interactions. For instance, instead of modeling the effects of a system call, the symbex engine may actually make the system call and incorporate the concrete return value and side effects into the symbolic state.</p>&#13;
<p class="li-indent">Although this approach is simple, it leads to problems when multiple paths that perform competing external interactions are explored in parallel. For instance, if multiple paths operate on the same physical file in parallel, this may lead to consistency issues if the changes conflict.</p>&#13;
<p class="li-indent">You can get around this by cloning the complete system state for each explored path, but that solution is extremely memory intensive. Moreover, because external software components cannot handle symbolic state, interacting directly with the environment means an expensive call to the constraint solver to compute suitable concrete values that you can pass to the system or library call you want to invoke.</p>&#13;
<p class="indentt">Because of these difficulties with static symbolic execution, more recent research has explored alternative symbex implementations based on dynamic analysis.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_316"/>Dynamic Symbolic Execution (Concolic Execution)</h5>&#13;
<p class="noindent"><em>Dynamic symbolic execution (DSE)</em> runs the application with concrete inputs and keeps the symbolic state <em>in addition to</em> the concrete state, rather than replacing it completely. In other words, this approach uses concrete state to drive the execution while maintaining symbolic state as metadata, just like how taint analysis engines maintain taint information. Because of this, dynamic symbolic execution is also known as <em>concolic execution</em>, as in “con-crete symbolic execution.”</p>&#13;
<p class="indent">In contrast to traditional static symbolic execution, which explores many program paths in parallel, concolic execution runs only one path at once, as determined by the concrete inputs. To explore different paths, concolic execution “flips” path constraints, as you saw in the example of <a href="ch12.xhtml#ch12list1">Listing 12-1</a>, and then uses the constraint solver to compute concrete inputs that lead to the alternative branch. You can then use these concrete inputs to start a new concolic execution that explores the alternative path.</p>&#13;
<p class="indent">Concolic execution has many advantages. It’s much more scalable since you don’t need to maintain multiple parallel execution states. You can also solve SSE’s problems with external interactions by simply running these interactions concretely. This doesn’t lead to consistency issues because concolic execution doesn’t run different paths in parallel. Because concolic execution symbolizes only “interesting” parts of the program state, such as user inputs, the constraints it computes tend to involve fewer variables than those computed by classic SSE engines, making the constraints easier and far faster to solve.</p>&#13;
<p class="indent">The main downside is that the code coverage achieved by concolic execution depends on the initial concrete inputs. Since concolic execution “flips” only a small number of branch constraints at once, it can take a long time to reach interesting paths if these are separated by many flips from the initial path. It’s also less trivial to symbolically execute only part of a program, although it can be implemented by dynamically enabling or disabling the symbolic engine at runtime.</p>&#13;
<h5 class="h5">Online vs. Offline Symbolic Execution</h5>&#13;
<p class="noindent">Another important consideration is whether the symbex engine explores multiple paths in parallel. Symbex engines that explore multiple program paths in parallel are called <em>online</em>, while engines that explore only one path at a time are called <em>offline</em>. For example, classic static symbolic execution is online because it forks off a new symbex instance at each branch and explores both directions in parallel. In contrast, concolic execution is usually offline, exploring only a single concrete run at once. However, offline SSE and online concolic execution implementations do exist.</p>&#13;
<p class="indent">The advantage of online symbex is that it doesn’t require you to execute the same instruction multiple times. In contrast, offline implementations often analyze the same chunk of code multiple times, having to run the entire program from the start for every program path. In this sense, online symbolic implementations are more efficient, but keeping track of all those <span epub:type="pagebreak" id="page_317"/>states in parallel can cost a lot of memory, which you don’t have to worry about with offline symbolic execution.</p>&#13;
<p class="indent">Online symbex implementations attempt to keep the memory overhead to a minimum by merging identical parts of program states together, splitting them only when they diverge. This optimization is known as <em>copy on write</em> because it copies merged states when a write causes them to diverge, creating a fresh private copy of the state for the path issuing the write.</p>&#13;
<h5 class="h5">Symbolic State</h5>&#13;
<p class="noindent">The next consideration is determining which parts of the program state are represented symbolically and which are concrete, as well as figuring out how symbolic memory accesses are handled. Many SSE and concolic execution engines provide the option of omitting symbolic state for some registers and memory locations. By tracking symbolic information only for the selected state while keeping the rest of the state concrete, you can reduce the size of the state and the complexity of the path constraints and symbolic expressions.</p>&#13;
<p class="indent">This approach is more memory efficient and faster because the constraints are easier to solve. The trade-off is that you have to choose which state to make symbolic and which to make concrete only, and this decision is not always trivial. If you choose incorrectly, your symbex tool may report unexpected results.</p>&#13;
<p class="indent">Another important aspect of how symbex engines maintain symbolic state is how they represent symbolic memory accesses. Like other variables, pointers can be symbolic, meaning that their value is not concrete but partly undetermined. This introduces a difficult problem when memory loads or stores use a symbolic address. For instance, if a value is written to an array using a symbolic index, how should the symbolic state be updated? Let’s discuss several ways to approach this issue.</p>&#13;
<p class="li"><strong>Fully symbolic memory</strong> Solutions based on fully symbolic memory attempt to model all the possible outcomes of a memory load or store operation. One way to achieve this is to fork the state into multiple copies, one to reflect each possible outcome of the memory operation. For instance, let’s suppose we’re reading from an array <em>a</em> using a symbolic index <em>ϕ</em><sub>i</sub>, with the constraint that <em>ϕ</em><sub>i</sub> &lt; 5. The state-forking approach would then fork the state into five copies: one for the situation where <em>ϕ</em><sub>i</sub> = 0 (so that <em>a</em>[0] is read), another one for <em>ϕ</em><sub>i</sub> = 1, and so on.</p>&#13;
<p class="li-indent">Another way to achieve the same effect is to use constraints with <em>if-then-else</em> expressions supported by some constraint solvers. These expressions are analogous to if-then-else conditionals used in programming languages. In this approach, the same array read is modeled as a conditional constraint that evaluates to the symbolic expression of <em>a</em>[<em>i</em>] if <em>ϕ</em><sub>i</sub> = <em>i</em>.</p>&#13;
<p class="li-indent">While fully symbolic memory solutions accurately model program behavior, they suffer from state explosion or extremely complicated constraints if any memory accesses use unbounded addresses. These <span epub:type="pagebreak" id="page_318"/>problems are more prevalent in binary-level symbex than source-level symbex because bounds information is not readily available in binaries.</p>&#13;
<p class="li"><strong>Address concretization</strong> To avoid the state explosion of fully symbolic memory, you can replace unbounded symbolic addresses with concrete ones. In concolic execution, the symbex engine can simply use the real concrete address. In static symbolic execution, the engine will have to use a heuristic to decide on a suitable concrete address. The advantage of this approach is that it reduces the state space and complexity of constraints considerably, but the downside is that it doesn’t fully capture all possible program behaviors, which may lead the symbex engine to miss some possible outcomes.</p>&#13;
<p class="indentt">In practice, many symbex engines employ a combination of these solutions. For instance, they may symbolically model memory accesses if the access is limited to a sufficiently small range by the constraints, while concretizing unbounded accesses.</p>&#13;
<h5 class="h5">Path Coverage</h5>&#13;
<p class="noindent">Finally, you will need to know which program paths the symbolic analysis explores. Classic symbolic execution explores <em>all</em> program paths, forking off a new symbolic state at every branch. This approach doesn’t scale because the number of possible paths increases exponentially with the number of branches in the program; this is the well-known <em>path explosion problem</em>. In fact, the number of paths may be infinite if there are unbounded loops or recursive calls. For nontrivial programs, you need a different approach to make symbolic execution more practical.</p>&#13;
<p class="indent">An alternative approach for SSE is using heuristics to decide which paths to explore. For instance, in an automatic bug discovery tool, you might focus on analyzing loops that index arrays, as these are relatively likely to contain bugs like buffer overflows.</p>&#13;
<p class="indent">Another common heuristic is <em>depth-first search (DFS)</em>, which explores one complete program path entirely before moving on to another path, under the assumption that deeply nested code is likely more “interesting” than superficial code. <em>Breadth-first search (BFS)</em> does the opposite, exploring all paths in parallel but taking longer to reach deeply nested code. Which heuristics to use depends on the goal of your symbex tool, and finding suitable heuristics can be a major challenge.</p>&#13;
<p class="indent">Concolic execution explores only one path at a time, as driven by concrete inputs. But you can also combine it with the heuristic path exploration approach or even with the approach of exploring all paths. For concolic execution, the easiest way to explore multiple paths is to run the application repeatedly, each time with new inputs discovered by “flipping” branch constraints in the previous run. A more sophisticated approach is to take snapshots of the program state so that after you’re done exploring one path, you can restore the snapshot to an earlier point in the execution and explore another path from there.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_319"/>In sum, symbolic execution has many parameters that you can tweak to balance the performance and limitations of the analysis. The optimal configuration will depend on your goals, and different symbex engines make different configuration choices.</p>&#13;
<p class="indent">For example, Triton (which you’ll see again in <a href="ch13.xhtml#ch13">Chapter 13</a>) and angr<sup><a id="ch12fn_1a" href="footnote.xhtml#ch12fn_1">1</a></sup> are binary-level symbex engines that support application-level SSE and concolic execution. S2E<sup><a id="ch12fn_2a" href="footnote.xhtml#ch12fn_2">2</a></sup> also operates on binaries but uses a system-wide virtual machine–based approach that can apply symbex not only to applications but also to the kernel, libraries, and drivers running in the VM. In contrast, KLEE<sup><a id="ch12fn_3a" href="footnote.xhtml#ch12fn_3">3</a></sup> does classic online SSE on LLVM bitcode rather than directly on binary, supporting multiple search heuristics to optimize path coverage. There are even higher-level symbex engines that run directly on C, Java, or Python code.</p>&#13;
<p class="indent">Now that you’re familiar with the workings of various symbex techniques, let’s discuss some common optimizations you can use to increase the scalability of your symbex tools.</p>&#13;
<h4 class="h4" id="ch12_1_3"><em>12.1.3 Increasing the Scalability of Symbolic Execution</em></h4>&#13;
<p class="noindent">As you’ve seen, symbolic execution suffers from two major factors of performance and memory overhead that undermine its scalability. These are the infeasibility of covering all possible program paths as well as the computational complexity of solving huge constraints covering hundreds or even thousands of symbolic variables.</p>&#13;
<p class="indent">You’ve already seen ways to reduce the impact of the path explosion problem, such as heuristically selecting which paths to execute, merging symbolic states to reduce memory usage, and using program snapshots to avoid repeated analysis of the same instructions. Next I’ll discuss several ways to minimize the cost of constraint solving.</p>&#13;
<h5 class="h5">Simplifying Constraints</h5>&#13;
<p class="noindent">Because constraint solving is one of the most computationally expensive aspects of symbex, it makes sense to simplify constraints as much as possible and to keep usage of the constraint solver to an absolute minimum. First, let’s look at some ways to simplify the path constraints and symbolic expressions. By simplifying these formulas, you can reduce the complexity of the constraint solver’s task, thereby speeding up the symbolic execution. Of course, the trick is to do this without significantly affecting the accuracy of the analysis.</p>&#13;
<p class="li"><strong>Limiting the number of symbolic variables</strong> An obvious way to simplify constraints is to reduce the number of symbolic variables and make the rest of the program state concrete only. However, you can’t just randomly concretize state because if you concretize the wrong state, <span epub:type="pagebreak" id="page_320"/>your symbex tool may miss possible solutions to the problem you’re trying to solve.</p>&#13;
<p class="li-indent">For example, if you’re using symbex to find network inputs that allow you to exploit a program but you concretize all the network inputs, your tool will consider only those concrete inputs and therefore fail to find an exploit. On the other hand, if you symbolize every byte received from the network, the constraints and symbolic expressions may become too complex to solve in a reasonable amount of time. The key is to symbolize only those parts of the input that stand a chance of being useful in an exploit.</p>&#13;
<p class="li-indent">One way to achieve this for concolic execution tools is to use a preprocessing pass that employs taint analysis and fuzzing to find inputs that cause dangerous effects, such as a corrupted return address, and then use symbex to find out whether there are any inputs that corrupt that return address such that it allows exploitation. This way, you can use relatively cheap techniques such as DTA and fuzzing to find out <em>whether</em> there’s a potential vulnerability and use symbolic execution only in potentially vulnerable program paths to find out <em>how</em> to exploit that vulnerability in practice. Not only does this approach allow you to focus the symbex on the most promising paths, but it also reduces the complexity of the constraints by symbolizing only those inputs that the taint analysis shows to be relevant.</p>&#13;
<p class="li"><strong>Limiting the number of symbolic operations</strong> Another way to simplify constraints is to symbolically execute only those instructions that are relevant. For instance, if you’re trying to exploit an indirect call through the <span class="literal">rax</span> register, then you’re interested only in the instructions that contribute to <span class="literal">rax</span>’s value. Thus, you could first compute a backward slice to find the instructions contributing to <span class="literal">rax</span> and then symbolically emulate the instructions in the slice. Alternatively, some symbex engines (including Triton, which I use for the examples in <a href="ch13.xhtml#ch13">Chapter 13</a>) offer the possibility of symbolically executing only instructions that operate on tainted data or on symbolized expressions.</p>&#13;
<p class="li"><strong>Simplifying symbolic memory</strong> As I explained previously, full symbolic memory can cause an explosion in the number of states or the size of the constraints if there are any unbounded symbolic memory accesses. You can reduce the impact of such memory accesses on constraint complexity by concretizing them. Alternatively, symbex engines like Triton allow you to make simplifying assumptions on memory accesses, such as that they can only access word-aligned addresses.</p>&#13;
<h5 class="h5">Avoiding the Constraint Solver</h5>&#13;
<p class="noindent">The most effective way to get around the complexity of constraint solving is to avoid the need for a constraint solver altogether. Although this may sound like an unhelpful statement, there are practical ways to limit the need for constraint solving in your symbex tools.</p>&#13;
<p class="indent">First, you can use the preprocessing passes I discussed to find potentially interesting paths and inputs to explore with symbex and pinpoint the <span epub:type="pagebreak" id="page_321"/>instructions affected by these inputs. This helps you to avoid needless constraint solver invocations for uninteresting paths or instructions. Symbex engines and constraint solvers may also cache the results of previously evaluated (sub)formulas, thereby avoiding the need to solve the same formula twice.</p>&#13;
<p class="indent">Because constraint solving is a crucial part of symbolic execution, let’s explore how it works in more detail.</p>&#13;
<h3 class="h3" id="ch12_2">12.2 Constraint Solving with Z3</h3>&#13;
<p class="noindent">Symbolic execution describes a program’s operations in terms of symbolic formulas and uses a constraint solver to automatically solve these formulas and answer questions about the program. To understand symbolic execution and its limitations, you’ll need to be familiar with the process of constraint solving.</p>&#13;
<p class="indent">In this section, I’ll explain the most important aspects of constraint solving using a popular constraint solver called <em>Z3</em>. Z3 is developed by Microsoft Research and is freely available at <em><a href="https://github.com/Z3Prover/z3/">https://github.com/Z3Prover/z3/</a></em>.</p>&#13;
<p class="indent">Z3 is a so-called <em>satisfiability modulo theories (SMT)</em> solver, which means it’s specialized to solve satisfiability problems for formulas with respect to specific mathematical theories, such as the theory of integer arithmetic.<sup><a id="ch12fn_4a" href="footnote.xhtml#ch12fn_4">4</a></sup> This is in contrast to solvers for pure <em>Boolean satisfiability (SAT)</em> problems, which have no built-in knowledge of theory-specific operations such as integer operations like + or &lt;. Z3 has built-in knowledge of how to solve formulas involving integer operations and operations on <em>bitvectors</em> (representations of binary-level data), among others. This domain-specific knowledge is useful when solving formulas produced by symbex, which involve exactly such operations.</p>&#13;
<p class="indent">Note that constraint solvers like Z3 are separate programs from symbolic execution engines, and their purpose isn’t limited to symbex alone. Some symbex engines even offer you the possibility of plugging in multiple different constraint solvers, depending on which one you prefer. Z3 is a popular choice because its features are ideally suited to symbex and it offers easy-touse APIs in C/C++ and Python, among others. It also comes with a command line tool that you can use to solve formulas, which you’ll see shortly.</p>&#13;
<p class="indent">It’s also important to realize that Z3 is not a magic cure-all. Although Z3 and other similar solvers are useful for solving certain classes of decidable formulas, they may not be able to solve formulas outside those classes. And even formulas in the supported classes may take a long time to solve, especially if they contain lots of variables. This is why it’s important to keep your constraints as simple as possible.</p>&#13;
<p class="indent">I’ll only cover Z3’s most important features here, but if you’re interested, check out more comprehensive tutorials online.<sup><a id="ch12fn_5a" href="footnote.xhtml#ch12fn_5">5</a></sup></p>&#13;
<h4 class="h4" id="ch12_2_1"><em>12.2.1 <span epub:type="pagebreak" id="page_322"/>Proving Reachability of an Instruction</em></h4>&#13;
<p class="noindent">Let’s begin by using the Z3 command line tool, which is preinstalled on the VM, to express and solve a simple set of formulas. Start the command line tool with the <span class="literal">z3 -in</span> command to read from standard input or <span class="literal">z3</span> <em>file</em> to read from a script file.</p>&#13;
<p class="indent">Z3’s input format is an extension of <em>SMT-LIB 2.0</em>, a language standard for SMT solvers. In the next examples, you’ll learn the most important commands supported by this language; these will help you debug your symbex tools because you can use them to make sense of the input your symbex tool is passing to the constraint solver. For more details on a particular command, type <span class="literal">(help)</span> into the <span class="literal">z3</span> tool.</p>&#13;
<p class="indent">Internally, Z3 maintains a <em>stack</em> of the formulas and declarations you provide. In Z3-speak, a formula is called an <em>assertion</em>. Z3 allows you to check whether the set of assertions you’ve provided is <em>satisfiable</em>, which means there’s a way to make all the assertions simultaneously true.</p>&#13;
<p class="indent">Let’s clarify this by returning to the pseudocode from <a href="ch12.xhtml#ch12list1">Listing 12-1</a>. The following example will use Z3 to prove that the call to function <span class="literal">baz</span> is reachable. <a href="ch12.xhtml#ch12list2">Listing 12-2</a> repeats the example code, with the call to <span class="literal">baz</span> marked <span class="ent">➊</span>.</p>&#13;
<p class="listing1" id="ch12list2"><em>Listing 12-2: Pseudocode example to illustrate constraint solving</em></p>&#13;
<p class="programs">x = int(argv[0])<br/>y = int(argv[1])<br/><br/>z = x + y<br/>if(x &gt;= 5)<br/>    foo(x, y, z)<br/>    y = y + z<br/>    if(y &lt; x)<br/>        <span class="ent">➊</span>baz(x, y, z)<br/>    else<br/>         qux(x, y, z)<br/>else<br/>    bar(x, y, z)</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list3">Listing 12-3</a> shows how to model the symbolic expressions and path constraints, similarly to how a symbex engine would do it, to prove that <span class="literal">baz</span> is reachable. For simplicity, I assume that the call to <span class="literal">foo</span> has no side effects, so you can ignore what happens in <span class="literal">foo</span> when modeling the path to <span class="literal">baz</span>.</p>&#13;
<p class="listing1" id="ch12list3"><em>Listing 12-3: Using Z3 to prove that</em> <span class="codeitalic">baz</span> <em>is reachable</em></p>&#13;
<p class="programs">   $ <span class="codestrong1">z3 -in</span><br/><span class="ent">➊</span> (declare-const x Int)<br/>   (declare-const y Int)<br/>   (declare-const z Int)<br/><span class="ent">➋</span> (declare-const y2 Int)<br/><span class="ent">➌</span> (assert (= z (+ x y)))<br/><span epub:type="pagebreak" id="page_323"/><span class="ent">➍</span> (assert (&gt;= x   5))<br/><span class="ent">➎</span> (assert (= y2   (+ y z)))<br/><span class="ent">➏</span> (assert (&lt; y2   x))<br/><span class="ent">➐</span> (check-sat)<br/>   sat<br/><span class="ent">➑</span> (get-model)<br/>   (model<br/>     (define-fun y () Int<br/>       (- 1))<br/>     (define-fun x () Int<br/>       5)<br/>     (define-fun y2 () Int<br/>       3)<br/>     (define-fun z () Int<br/>       4)<br/>   )</p>&#13;
<p class="indent">Two things immediately stand out in <a href="ch12.xhtml#ch12list3">Listing 12-3</a>: all commands are enclosed in parentheses, and all operations are written in Polish notation, with the operator first and then the operands (+ <em>x</em> <em>y</em> instead of <em>x</em> + <em>y</em>).</p>&#13;
<h5 class="h5">Declaring Variables</h5>&#13;
<p class="noindent"><a href="ch12.xhtml#ch12list3">Listing 12-3</a> starts by declaring the variables (<span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span>) that occur on the path to <span class="literal">baz</span> <span class="ent">➊</span>. From Z3’s perspective, these are modeled as <em>constants</em> rather than variables. To declare a constant, you use the command <span class="literal">declare-const</span>, giving the name and type of the constant. In this case, all constants are of type <span class="literal">Int</span>.</p>&#13;
<p class="indent">The reason for modeling <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span> as constants is that there’s a fundamental difference between executing a program path and modeling it in Z3. When you execute a program, all operations are executed one by one, but when you model a program path in Z3, you represent those same operations as a system of formulas to be solved simultaneously. When Z3 solves these formulas, it assigns concrete values to <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span>, effectively finding the appropriate constants to satisfy the formulas.</p>&#13;
<p class="indent">In addition to <span class="literal">Int</span>, Z3 supports other common data types like <span class="literal">Real</span> (for floating-point numbers) and <span class="literal">Bool</span>, as well as more complex types like <span class="literal">Array</span>.</p>&#13;
<p class="indent"><span class="literal">Int</span> and <span class="literal">Real</span> both support arbitrary precision, which is not representative of machine code operations that operate on fixed-width numbers. That’s why Z3 also offers special bitvector types, which I’ll cover in <a href="ch12.xhtml#ch12_2_5">Section 12.2.5</a>.</p>&#13;
<h5 class="h5">Static Single Assignment Form</h5>&#13;
<p class="noindent">The fact that Z3 solves all formulas in unison without regard for the order of operations in the program path has another important implication. Suppose that the same variable, say <em>y</em>, is assigned multiple times in the same program path, once as <em>y</em> = 5 and then later as <em>y</em> = 10. When solving, Z3 then sees two conflicting constraints stating that <em>y</em> must be simultaneously equal to 5 and 10, which is of course impossible.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_324"/>Many symbex engines solve this problem by emitting symbolic expressions in <em>static single assignment (SSA)</em> form, which mandates that each variable be assigned exactly once. That means that on <em>y</em>’s second assignment, it’s split into two versions, <em>y</em><sub>1</sub> and <em>y</em><sub>2</sub>, removing any ambiguity and resolving the contradicting constraints from Z3’s perspective. This is exactly why there’s an additional declaration of a constant named <span class="literal">y2</span> in <a href="ch12.xhtml#ch12list3">Listing 12-3</a> <span class="ent">➋</span>: the variable <span class="literal">y</span> in <a href="ch12.xhtml#ch12list2">Listing 12-2</a> is assigned twice on the path to <span class="literal">baz</span>, so it must be split up using the SSA trick. You can also observe this in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>, where you can see <span class="literal">y</span> being mapped to a new symbolic expression <em>ϕ</em><sub>4</sub>, representing the new version of <span class="literal">y</span>.</p>&#13;
<h5 class="h5">Adding Constraints</h5>&#13;
<p class="noindent">After declaring all the constants, you can add constraint formulas (assertions) to Z3’s formula stack using the <span class="literal">assert</span> command. As I mentioned, you express formulas in Polish notation with operators before their operands. Z3 supports common mathematical operators like +, −, =, &lt;, and so on, with their usual meanings. As you’ll see in later examples, Z3 also supports logical operators and operators that deal with bitvectors.</p>&#13;
<p class="indent">The first assertion in <a href="ch12.xhtml#ch12list3">Listing 12-3</a> is a symbolic expression for <span class="literal">z</span> stating that it must equal <span class="literal">x + y</span> <span class="ent">➌</span>, modeling the assignment <span class="literal">z = x + y</span> in the pseudocode program from <a href="ch12.xhtml#ch12list2">Listing 12-2</a>. Next, there’s an assertion that adds the branch constraint <span class="literal">x &gt;= 5</span> <span class="ent">➍</span> (to model the branch <span class="literal">if(x &gt;= 5)</span>), followed by a symbolic expression <span class="literal">y2 = y + z</span> <span class="ent">➎</span>. Note that <span class="literal">y2</span> depends on the original <span class="literal">y</span> assigned from user input, clearly showing the need for SSA form to disambiguate the assertions and prevent circular dependencies. The final assertion adds the second branch constraint, <span class="literal">y2 &lt; x</span> <span class="ent">➏</span>. Note that I’ve omitted modeling the call to <span class="literal">foo</span> because it has no side effects and therefore doesn’t affect the reachability of <span class="literal">baz</span>.</p>&#13;
<h5 class="h5">Checking Satisfiability and Getting a Model</h5>&#13;
<p class="noindent">After adding all the assertions needed to model the path to <span class="literal">baz</span>, you can check the stack of assertions for satisfiability using Z3’s <span class="literal">check-sat</span> command <span class="ent">➐</span>. In this case, <span class="literal">check-sat</span> prints <span class="literal">sat</span>, meaning that the system of assertions is satisfiable. This tells you that <span class="literal">baz</span> is reachable along the modeled program path. If a system of assertions is not satisfiable, <span class="literal">check-sat</span> prints <span class="literal">unsat</span> instead.</p>&#13;
<p class="indent">Once you know that the assertions are satisfiable, you can ask Z3 for a <em>model</em>: a concrete assignment of all the constants that satisfies all the assertions. To ask for a model, you use the command <span class="literal">get-model</span> <span class="ent">➑</span>. The returned model expresses each constant assignment as a <em>function</em> (defined with the command <span class="literal">define-fun</span>) that returns a constant value. That’s because in Z3, constants are really just functions that take no arguments, and the command <span class="literal">declare-const</span> is just syntactic sugar that <span class="literal">get-model</span> omits. For instance, the line <span class="literal">define-fun y () Int (-1)</span> in the model in <a href="ch12.xhtml#ch12list3">Listing 12-3</a> defines a function called <span class="literal">y</span> that takes no parameters and returns an <span class="literal">Int</span> with the value <span class="literal">-1</span>. This just means that in this model, the constant <span class="literal">y</span> has the value <span class="literal">-1</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_325"/>As you can see, in the case of <a href="ch12.xhtml#ch12list3">Listing 12-3</a>, Z3 finds the solution <span class="literal">x = 5</span>, <span class="literal">y = -1</span>, <span class="literal">z = 4</span> (since <span class="literal">z = x + y = 5 - 1</span>), and <span class="literal">y2 = 3</span> (since <span class="literal">y2 = y + z = -1 + 4</span>). This means that if you use the input values <span class="literal">x = 5</span> and <span class="literal">y = -1</span> for the pseudo-code program in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>, you’ll reach the call to <span class="literal">baz</span>. Note that there are often multiple possible models, and the specific one that <span class="literal">get-model</span> returns here is chosen arbitrarily.</p>&#13;
<h4 class="h4" id="ch12_2_2"><em>12.2.2 Proving Unreachability of an Instruction</em></h4>&#13;
<p class="noindent">Note that in the model from <a href="ch12.xhtml#ch12list3">Listing 12-3</a>, the value assigned for <span class="literal">y</span> is negative. As it happens, <span class="literal">baz</span> is reachable if <span class="literal">x</span> and <span class="literal">y</span> are signed, but not if they’re unsigned. Let’s prove this so that you can see an example of an unsatisfiable system of assertions. <a href="ch12.xhtml#ch12list4">Listing 12-4</a> models the path to <span class="literal">baz</span> again, this time with the added constraint that <span class="literal">x</span> and <span class="literal">y</span> must both be non-negative.</p>&#13;
<p class="listing1" id="ch12list4"><em>Listing 12-4: Proving that</em> <span class="codeitalic">baz</span> <em>is unreachable if the inputs are unsigned</em></p>&#13;
<p class="programs">   <span class="codestrong1">$ z3 -in</span><br/>   (declare-const x Int)<br/>   (declare-const y Int)<br/>   (declare-const z Int)<br/>   (declare-const y2 Int)<br/><span class="ent">➊</span> (assert (&gt;= x 0))<br/><span class="ent">➋</span> (assert (&gt;= y 0))<br/>   (assert (= z (+ x y)))<br/>   (assert (&gt;= x 5))<br/>   (assert (= y2 (+ y z)))<br/>   (assert (&lt; y2 x))<br/><span class="ent">➌</span> (check-sat)<br/>   unsat</p>&#13;
<p class="indent">As you can see, <a href="ch12.xhtml#ch12list4">Listing 12-4</a> is exactly the same as <a href="ch12.xhtml#ch12list3">Listing 12-3</a> except for the added assertions that <span class="literal">x &gt;= 0</span> <span class="ent">➊</span> and <span class="literal">y &gt;= 0</span> <span class="ent">➋</span>. This time, <span class="literal">check-sat</span> returns <span class="literal">unsat</span> <span class="ent">➌</span>, proving that <span class="literal">baz</span> is unreachable if <span class="literal">x</span> and <span class="literal">y</span> are unsigned. For an unsatisfiable problem, you cannot get a model, as none exists.</p>&#13;
<h4 class="h4" id="ch12_2_3"><em>12.2.3 Proving Validity of a Formula</em></h4>&#13;
<p class="noindent">You can also use Z3 to prove that a set of assertions is not only satisfiable but <em>valid</em>, which means that it’s always true regardless of the concrete values you plug into it. Proving that a formula or set of formulas is valid is equivalent to proving that its negation is unsatisfiable, which you already know how to do with Z3. If the negation turns out to be satisfiable, that means the set of formulas is not valid, and you can ask Z3 for a model as a counterexample.</p>&#13;
<p class="indent">Let’s use this idea to prove the validity of the <em>bidirectional lemma</em>, a well-known valid formula in propositional logic. This will also allow you to see Z3’s propositional logic operators in action, as well as Z3’s Boolean data type <span class="literal">Bool</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_326"/>The bidirectional lemma states that ((<em>p</em> → <em>q</em>) ∧ (<em>r</em> → <em>s</em>) ∧ (<em>p</em> ∨ ¬ <em>s</em>)) ├ (<em>q</em> ∨ ¬ <em>r</em>). <a href="ch12.xhtml#ch12list5">Listing 12-5</a> models the lemma in Z3 and proves its validity.</p>&#13;
<p class="listing1" id="ch12list5"><em>Listing 12-5: Proving the bidirectional lemma with Z3</em></p>&#13;
<p class="programs">   <span class="codestrong1">$ z3 -in</span><br/><span class="ent">➊</span> (declare-const p Bool)<br/>   (declare-const q Bool)<br/>   (declare-const r Bool)<br/>   (declare-const s Bool)<br/><span class="ent">➋</span> (assert (=&gt; (and (and (=&gt; p q) (=&gt; r s)) (or p (not s))) (or q (not r))))<br/><span class="ent">➌</span> (check-sat)<br/>   sat<br/><span class="ent">➍</span> (get-model)<br/>   (model<br/>     (define-fun r () Bool<br/>      true)<br/>   )<br/><span class="ent">➎</span> (reset)<br/><span class="ent">➏</span> (declare-const p Bool)<br/>   (declare-const q Bool)<br/>   (declare-const r Bool)<br/>   (declare-const s Bool)<br/><span class="ent">➐</span> (assert (not (=&gt; (and (and (=&gt; p q) (=&gt; r s)) (or p (not s))) (or q (not r)))))<br/><span class="ent">➑</span> (check-sat)<br/>   unsat</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list5">Listing 12-5</a> declares four <span class="literal">Bool</span> constants named <span class="literal">p</span>, <span class="literal">q</span>, <span class="literal">r</span>, and <span class="literal">s</span> <span class="ent">➊</span>, one for each variable in the bidirectional lemma. It then asserts the bidirectional lemma itself using Z3’s logical operators <span class="ent">➋</span>. As you can see, Z3 supports all the usual logical operators, including <span class="literal">and</span> (∧), <span class="literal">or</span> (∨), <span class="literal">xor</span> (⊕), <span class="literal">not</span> (¬), and the logical implication operator <span class="literal">=&gt;</span> (→). Z3 expresses bi-implication (↔) using the equality symbol (<span class="literal">=</span>). Moreover, Z3 supports an <em>if-then-else</em> operator called <span class="literal">ite</span>, with the syntax <span class="literal">ite</span> <em>condition value-if-true value-if-false</em>. I’ve modeled the “entails” symbol ⊢ as an implication (<span class="literal">=&gt;</span>) in the listing.</p>&#13;
<p class="indent">First, let’s prove that the bidirectional lemma is satisfiable. You can easily confirm that with <span class="literal">check-sat</span> <span class="ent">➌</span> and use <span class="literal">get-model</span> to get a model <span class="ent">➍</span>. In this case, the model only assigns the value <span class="literal">true</span> to <span class="literal">r</span> since that’s enough to make the assertion true regardless of the values of <span class="literal">p</span>, <span class="literal">q</span>, and <span class="literal">s</span>. This tells you the bidirectional lemma is satisfiable but doesn’t prove that it’s valid.</p>&#13;
<p class="indent">To prove that the lemma is valid, you reset Z3’s stack of assertions <span class="ent">➎</span>, declare the same constants as before <span class="ent">➏</span>, and then assert the negation of the bidirectional lemma <span class="ent">➐</span>. Using <span class="literal">check-sat</span>, you confirm that the negation of the lemma is unsatisfiable <span class="ent">➑</span>, proving that the bidirectional lemma is valid.</p>&#13;
<p class="indent">In addition to propositional logic, Z3 can also solve <em>effectively propositional</em> formulas, which are a decidable subset of formulas from predicate logic. I won’t go over the details of effectively propositional formulas here since you won’t need to use predicate logic for the symbex purposes in this book.</p>&#13;
<h4 class="h4" id="ch12_2_4"><em>12.2.4 <span epub:type="pagebreak" id="page_327"/>Simplifying Expressions</em></h4>&#13;
<p class="noindent">Z3 can also simplify expressions, as shown in <a href="ch12.xhtml#ch12list6">Listing 12-6</a>.</p>&#13;
<p class="listing1" id="ch12list6"><em>Listing 12-6: Simplifying a formula with Z3</em></p>&#13;
<p class="programs">   <span class="codestrong1">$ z3 -in</span><br/><span class="ent">➊</span> (declare-const x Int)<br/>   (declare-const y Int)<br/><span class="ent">➋</span> (simplify (+ (* 3 x) (* 2 y) 5 x y))<br/>   (+ 5 (* 4 x) (* 3 y))</p>&#13;
<p class="indent">This example declares two integers called <span class="literal">x</span> and <span class="literal">y</span> <span class="ent">➊</span> and then calls Z3’s <span class="literal">simplify</span> command to simplify the formula <span class="literal">3x + 2y + 5 + x + y</span> <span class="ent">➋</span>. Z3 simplifies this to <span class="literal">5 + 4x + 3y</span>. Note that in this example, I’ve used Z3’s ability to take more than two operands for the + operator and add them all together in one go. In simple examples like this, Z3’s <span class="literal">simplify</span> command works well, but it may not work as well in more complex cases. Z3’s simplification is primarily meant to benefit programs like symbex engines that process formulas automatically, not to improve human readability.</p>&#13;
<h4 class="h4" id="ch12_2_5"><em>12.2.5 Modeling Constraints for Machine Code with Bitvectors</em></h4>&#13;
<p class="noindent">So far, all the examples have used Z3’s arbitrary precision <span class="literal">Int</span> data type. If you use arbitrary precision data types to model a binary, the result may not be representative of reality because binaries operate on fixed-width integers that offer only limited precision. That’s why Z3 also offers <em>bitvectors</em>, which are fixed-width integers perfectly suited for use in symbolic execution.</p>&#13;
<p class="indent">To manipulate bitvectors, you use dedicated operators like <span class="literal">bvadd</span>, <span class="literal">bvsub</span>, and <span class="literal">bvmul</span> instead of the usual integers operators like +, −, and ×. <a href="ch12.xhtml#ch12tab1">Table 12-1</a> shows an overview of the most common bitvector operators. You’ll see a lot of these if you inspect the constraints and symbolic expressions that symbex engines like Triton pass to the constraint solver. Moreover, knowledge of these operators comes in handy when building your own symbex tools, as you’ll do in <a href="ch13.xhtml#ch13">Chapter 13</a>. Let’s discuss how to use the operators listed in <a href="ch12.xhtml#ch12tab1">Table 12-1</a> in practice.</p>&#13;
<p class="indent">Z3 allows you to create bitvectors of any desired bit width. There are several ways to achieve this, as you can see in the first part of <a href="ch12.xhtml#ch12tab1">Table 12-1</a> <span class="ent">➊</span>. First, you can create a 4-bit-wide bitvector constant containing the bits <span class="literal">1101</span> using the notation <span class="literal">#b1101</span>. Similarly, the notation <span class="literal">#xda</span> creates an 8-bit-wide bitvector containing the value <span class="literal">0xda</span>.</p>&#13;
<p class="indent">As you can see, for binary or hexadecimal constants, Z3 automatically infers the minimum size the bitvector needs to have. To declare decimal constants, you need to state both the bitvector’s value and its width explicitly. For instance, the notation <span class="literal">(_ bv10 32)</span> creates a 32-bit-wide bitvector containing the value 10. You can also declare bitvector constants with an undetermined value using the notation <span class="literal">(declare-const x (_ BitVec 32))</span>, where <span class="literal">x</span> is the constant’s name and <span class="literal">32</span> is its bit width.</p>&#13;
<p class="tab-caption" id="ch12tab1"><strong>Table 12-1:</strong> <span epub:type="pagebreak" id="page_328"/>Common Z3 Bitvector Operators</p>&#13;
<table class="topbot-d">&#13;
<tbody>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Operation</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Description</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Example</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;" colspan="3" class="tab-center"><span class="ent">➊</span> <strong>Bitvector creation</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">#b&lt;value&gt;</span></td>&#13;
<td>Binary bitvector constant</td>&#13;
<td><span class="literal">#b1101        ; 1101</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">#x&lt;value&gt;</span></td>&#13;
<td>Hexadecimal bitvector constant</td>&#13;
<td><span class="literal">#xda           ; 0xda</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">(_ bv&lt;value&gt; &lt;width&gt;)</span></td>&#13;
<td>Decimal bitvector constant</td>&#13;
<td><span class="literal">(_ bv10 32) ; 10 (32 bits wide)</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">(_ BitVec &lt;width&gt;)</span></td>&#13;
<td>Type for <span class="literal">&lt;width&gt;</span>-bit bitvector</td>&#13;
<td><span class="literal">(declare-const x (_ BitVec 32))</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.1em;" colspan="3" class="tab-center"><span class="ent">➋</span> <strong>Arithmetic operators</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvadd</span></td>&#13;
<td>Addition</td>&#13;
<td><span class="literal">(bvadd x #x10)          ; x + 0x10</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvsub</span></td>&#13;
<td>Subtraction</td>&#13;
<td><span class="literal">(bvsub #x20 y)          ; 0x20 - y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvmul</span></td>&#13;
<td>Multiplication</td>&#13;
<td><span class="literal">(bvmul #x2 #x3)         ; 6</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvsdiv</span></td>&#13;
<td>Signed division</td>&#13;
<td><span class="literal">(bvsdiv x y)            ; x/y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvudiv</span></td>&#13;
<td>Unsigned division</td>&#13;
<td><span class="literal">(bvudiv y x)            ; y/x</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvsmod</span></td>&#13;
<td>Signed modulo</td>&#13;
<td><span class="literal">(bvsmod x y)            ; x % y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvneg</span></td>&#13;
<td>Two's complement</td>&#13;
<td><span class="literal">(bvneg #b1101)          ; 0011</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvshl</span></td>&#13;
<td>Left shift</td>&#13;
<td><span class="literal">(bvshl #b0011 #x1)      ; 0110</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvlshr</span></td>&#13;
<td>Logical (unsigned) right shift</td>&#13;
<td><span class="literal">(bvlshr #b1000 #x1)     ; 0100</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvashr</span></td>&#13;
<td>Arithmetic (signed) right shift</td>&#13;
<td><span class="literal">(bvashr #b1000 #x1)     ; 1100</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.1em;" colspan="3" class="tab-center"><span class="ent">➌</span> <strong>Bitwise operators</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvor</span></td>&#13;
<td>Bitwise OR</td>&#13;
<td><span class="literal">(bvor #x1 #x2)              ; 3</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvand</span></td>&#13;
<td>Bitwise AND</td>&#13;
<td><span class="literal">(bvand #xffff #x0001)       ; 1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvxor</span></td>&#13;
<td>Bitwise XOR</td>&#13;
<td><span class="literal">(bvxor #x3 #x5)             ; 6</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvnot</span></td>&#13;
<td>Bitwise NOT (one's complement)</td>&#13;
<td><span class="literal">(bvnot x);                  ∼x</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.1em;" colspan="3" class="tab-center"><span class="ent">➍</span> <strong>Comparison operators</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">=</span></td>&#13;
<td>Equality</td>&#13;
<td><span class="literal">(= x y)           ; x == y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvult</span></td>&#13;
<td>Unsigned less than</td>&#13;
<td><span class="literal">(bvult x #x1a) ; x &lt; 0x1a</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvslt</span></td>&#13;
<td>Signed less than</td>&#13;
<td><span class="literal">(bvslt x #x1a) ; x &lt; 0x1a</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvugt</span></td>&#13;
<td>Unsigned greater than</td>&#13;
<td><span class="literal">(bvugt x y)       ; x &gt; y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvsgt</span></td>&#13;
<td>Signed greater than</td>&#13;
<td><span class="literal">(bvsgt x y)       ; x &gt; y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvule</span></td>&#13;
<td>Unsigned less than or equal</td>&#13;
<td><span class="literal">(bvule x #x55) ; x &lt;= 0x55</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvsle</span></td>&#13;
<td>Signed less than or equal</td>&#13;
<td><span class="literal">(bvsle x #x55) ; x &lt;= 0x55</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvuge</span></td>&#13;
<td>Unsigned greater than or equal</td>&#13;
<td><span class="literal">(bvuge x y)       ; x &gt;= y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">bvsge</span></td>&#13;
<td>Signed greater than or equal</td>&#13;
<td><span class="literal">(bvsge x y)       ; x &gt;= y</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.1em;" colspan="3" class="tab-center"><span class="ent">➎</span> <strong>Bitvector concatenation and extraction</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">concat</span></td>&#13;
<td>Concatenate bitvectors</td>&#13;
<td><span class="literal">(concat #x4 #x8)       ; 0x48</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal">(_ extract &lt;hi&gt; &lt;lo&gt;)</span></td>&#13;
<td style="border-bottom: solid 0.2em;">Extract bits &lt;lo&gt; through &lt;hi&gt;</td>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal">((_ extract 3 0) #x48) ; 0x8</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indentt">Z3 also supports arithmetic bitvector operators to mirror all the primitive operations supported in languages like C/C++ and instruction sets like x86 <span class="ent">➋</span>. For instance, the Z3 command <span class="literal">(assert (= y (bvadd x #x10)))</span> <span epub:type="pagebreak" id="page_329"/>asserts that the bitvector <span class="literal">y</span> must be equal to the bitvector <span class="literal">x + 0x10</span>. For many operations, Z3 includes both signed and unsigned variants. For example, <span class="literal">(bvsdiv x y)</span> performs a signed division <span class="literal">x/y</span>, while <span class="literal">(bvudiv x y)</span> does an unsigned division. Also note that Z3 demands that both operands in an arithmetic bitvector operation have the same bit width.</p>&#13;
<p class="indent">In the “Example” column of <a href="ch12.xhtml#ch12tab1">Table 12-1</a>, I’ve listed examples of all of Z3’s common bitvector operations. The semicolons denote comments that show the C/C++ equivalent or arithmetic outcome of the Z3 operation.</p>&#13;
<p class="indent">In addition to arithmetic operators, Z3 also implements common bitwise operators such as OR (equivalent to C’s <span class="literal">|</span>), AND (<span class="literal">&amp;</span>), XOR (<span class="literal">^</span>), and NOT (<span class="literal">~</span>) <span class="ent">➌</span>. It also implements comparisons like <span class="literal">=</span> to check for equality between bitvectors, <span class="literal">bvult</span> to perform an unsigned “less than” comparison, and so on <span class="ent">➍</span>. The supported comparisons are quite similar to those supported by x86’s conditional jumps and are especially useful in combination with Z3’s <span class="literal">ite</span> operator. For instance, <span class="literal">(ite (bvsge x y) 22 44)</span> evaluates to <span class="literal">22</span> if <span class="literal">x &gt;= y</span>, or <span class="literal">44</span> otherwise.</p>&#13;
<p class="indent">You can also concatenate two bitvectors or extract part of a bitvector <span class="ent">➎</span>. This is useful when you have to equalize the size of two bitvectors to allow a certain operation or when you’re interested in only part of the bitvector.</p>&#13;
<p class="indent">Now that you’re familiar with Z3’s bitvector operators, let’s take a look at a practical example that uses these operators.</p>&#13;
<h4 class="h4" id="ch12_2_6"><em>12.2.6 Solving an Opaque Predicate Over Bitvectors</em></h4>&#13;
<p class="noindent">Let’s solve an opaque predicate with Z3 to see how to use bitvector operations in practice. Opaque predicates are branch conditions that always evaluate to true or false, without this being obvious to a reverse engineer. They’re used as code obfuscations to make code harder for reverse engineers to understand, for instance by inserting dead code that’s never reached in practice.</p>&#13;
<p class="indent">In some cases, you can use a constraint solver like Z3 to prove that a branch is opaquely true or false. For example, consider an opaquely false branch that makes use of the fact that ∀<em>x</em> ∈ ℤ,2 | (<em>x</em> + <em>x</em><sup>2</sup>). In other words, for any integer <em>x</em>, the result of <em>x</em> + <em>x</em><sup>2</sup> is zero modulo two. You can use this to construct a branch <span class="literal">if((x + x*x) % 2 != 0)</span> that will never be taken, no matter the value of <span class="literal">x</span>, without that being immediately obvious. You can then insert confusing bogus code in the “taken” path of the branch to lead reverse engineers astray.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list7">Listing 12-7</a> shows how to model this branch in Z3 and prove that it can never be taken.</p>&#13;
<p class="listing1" id="ch12list7"><em>Listing 12-7: Solving an opaque predicate with Z3</em></p>&#13;
<p class="programs">   <span class="codestrong1">$ z3 -in</span><br/><span class="ent">➊</span> (declare-const x (_ BitVec 64))<br/><span class="ent">➋</span> (assert (not (= (bvsmod (bvadd (bvmul x x) x) (_ bv2 64)) (_ bv0 64))))<br/><span class="ent">➌</span> (check-sat)<br/>   unsat</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_330"/>First, you declare a 64-bit bitvector called <span class="literal">x</span> <span class="ent">➊</span> to use in the branch condition. You then assert the branch condition itself <span class="ent">➋</span>, and finally you check its satisfiability with <span class="literal">check-sat</span> <span class="ent">➌</span>. Because <span class="literal">check-sat</span> returns <span class="literal">unsat</span>, you know the branch condition can never be true, so you can safely ignore any code inside the branch when reverse engineering.</p>&#13;
<p class="indent">As you can see, manually modeling and proving even a simple opaque predicate like this is tedious. But with symbolic execution, you can solve problems like this automatically.</p>&#13;
<h3 class="h3" id="ch12_3">12.3 Summary</h3>&#13;
<p class="noindent">In this chapter, you learned the principles of symbolic execution and constraint solving. Symbolic execution is a powerful but unscalable technique that should be used with care. For that reason, there are several ways of optimizing symbex tools, most of which rely on minimizing the amount of code to analyze and the load on the constraint solver. In <a href="ch13.xhtml#ch13">Chapter 13</a>, you’ll learn how to use symbex in practice by building practical symbex tools with Triton.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch12_4">Exercises</p>&#13;
<p class="boxhead1">1. Tracking Symbolic State</p>&#13;
<p class="noindent">Consider the following code:</p>&#13;
<p class="programs">x = int(argv[0])<br/>y = int(argv[1])<br/><br/>z = x*x<br/>w = y*y<br/>if(z &lt;= 1)<br/>  if( ((z + w) % 7 == 0) &amp;&amp; (x % 7 != 0) )<br/>     foo(z, w)<br/>else<br/>  if((2**z - 1) % z != 0)<br/>     bar(x, y, z)<br/><br/>  else<br/>    z = z + w<br/>    baz(z, y, x)<br/>z = z*z<br/>qux(x, y, z)</p>&#13;
<p class="indent">Create a tree diagram that shows how the symbolic state evolves for every path through this code (similar to <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>). The statement <span class="literal">2**z</span> stands for 2<sup>z</sup>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_331"/>Note that the last two statements in this code are executed at the end of each code path, regardless of which branches were taken. However, the value of <span class="literal">z</span> in these last statements depends on which path was taken before. To capture this behavior in the tree, you have these two options:</p>&#13;
<p class="number">1. Create a private copy of the last two statements for each path in your diagram.</p>&#13;
<p class="number">2. Merge all paths back together at these last statements and model the symbolic value of <span class="literal">z</span> with a conditional <em>if-then-else</em> expression that depends on the taken path.</p>&#13;
<p class="boxhead1">2. Proving Reachability</p>&#13;
<p class="noindent">Use Z3 to figure out which of the calls to <span class="literal">foo</span>, <span class="literal">bar</span>, and <span class="literal">baz</span> are reachable in the listing from the previous exercise. Model the relevant operations and branches using bitvectors.</p>&#13;
<p class="boxhead1">3. Finding Opaque Predicates</p>&#13;
<p class="noindent">Use Z3 to check whether any of the conditionals in the previous listing are opaque predicates. If so, are they opaquely true or false? Which code is unreachable and therefore safe to eliminate from the listing?<span epub:type="pagebreak" id="page_332"/></p>&#13;
</div>&#13;
</div></body></html>