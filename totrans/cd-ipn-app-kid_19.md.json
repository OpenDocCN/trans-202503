["```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    anchorPoint = CGPoint.zero\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n➊\n let\n ballBody = SKPhysicsBody\n (circleOfRadius: 30.0\n )\n\n➋\n let\n boxBody = SKPhysicsBody\n (rectangleOf: box\n .size\n )\n\n➌\n let\n skaterBody = SKPhysicsBody\n (texture: skaterTexture, size: skater\n .size)\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  let\n bowlingBall = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n➊\n bowlingBall.mass\n = 100.0\n\n➋\n bowlingBall.friction\n = 0.3\n\n➌\n bowlingBall.restitution\n = 0.1\n\n➍\n bowlingBall.affectedByGravity\n = true\n\n➎\n bowlingBall.allowsRotation\n = true\n\n  let\n basketball = SKPhysicsBody\n (circleOfRadius: 10.0\n )\n\n  basketball.mass\n = 12.0\n\n  basketball.friction\n = 0.5\n\n  basketball.restitution\n = 0.7\n\n  basketball.affectedByGravity\n = true\n\n  basketball.allowsRotation\n = true\n\n  let\n iceCube = SKPhysicsBody\n (rectangleOf: CGSize\n (width: 1.0\n , height: 1.0\n ))\n\n  iceCube.mass\n = 7.0\n\n  iceCube.friction\n = 0.1\n\n  iceCube.restitution\n = 0.2\n\n  iceCube.affectedByGravity\n = true\n\n  iceCube.allowsRotation\n = false\n\n  let\n cloud = SKPhysicsBody\n (texture: cloudTexture, size: cloudSize)\n\n  cloud.mass\n = 1.0\n\n  cloud.friction\n = 0.0\n\n  cloud.restitution\n = 0.0\n\n➏\n cloud.affectedByGravity\n = false\n\n  cloud.allowsRotation\n = false\n\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass Skater: SKSpriteNode {\n\n    --\n *snip* \n --\n\n    var isOnGround = true\n\n    func\n setupPhysicsBody() {\n\n     ➊\n if\n let\n skaterTexture = texture\n {\n\n        ➋\n physicsBody\n = SKPhysicsBody\n (texture: skaterTexture, size: size\n )\n\n        ➌\n physicsBody\n ?.isDynamic\n = true\n\n        ➍\n physicsBody\n ?.density\n = 6.0\n\n        ➎\n physicsBody\n ?.allowsRotation\n = true\n\n        ➏\n physicsBody\n ?.angularDamping\n = 1.0\n\n       }\n\n    }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    resetSkater()\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    bricks.append(brick)\n\n    // Set up the brick's physics body\n\n  ➊\n let\n center = brick.centerRect\n .origin\n\n  ➋\n brick.physicsBody\n = SKPhysicsBody\n (rectangleOf: brick.size\n , center: center)\n\n  ➌\n brick.physicsBody\n ?.affectedByGravity\n = false\n\n    // Return this new brick to the caller\n\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nimport SpriteKit\n\n/// This struct holds various physics categories, so we can define\n\n/// which object types collide or have contact with each other\n\nstruct\n PhysicsCategory {\n\n    static\n let\n skater: UInt32\n = 0x1\n << 0\n\n    static\n let\n brick: UInt32\n = 0x1\n << 1\n\n    static\n let\n gem: UInt32\n = 0x1\n << 2\n\n}\n\nclass GameScene: SKScene {\n\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n    --\n *snip* \n --\n\n    brick.physicsBody?.affectedByGravity = false\n\n ➊\n brick.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .brick\n\n  ➋\n brick.physicsBody\n ?.collisionBitMask\n = 0\n\n    // Return this new brick to the caller\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc setupPhysicsBody() {\n\n    --\n *snip* \n --\n\n         physicsBody?.angularDamping = 1.0\n\n     ➊\n physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .skater\n\n     ➋\n physicsBody\n ?.collisionBitMask\n = PhysicsCategory\n .brick\n\n     ➌\n physicsBody\n ?.contactTestBitMask\n = PhysicsCategory\n .brick\n |\n\n           PhysicsCategory\n .gem\n\n    }\n\n}\n\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nclass GameScene: SKScene\n , SKPhysicsContactDelegate\n {\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    physicsWorld.gravity = CGVector(dx: 0.0, dy: -6.0)\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint = CGPoint.zero\n\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n  func handleTap(tapGesture: UITapGestureRecognizer) {\n\n    --\n *snip* \n --\n\n  }\n\n  // MARK:- SKPhysicsContactDelegate Methods\n\n➊\n func\n didBegin(_\n contact: SKPhysicsContact\n ) {\n\n     // Check if the contact is between the skater and a brick\n\n  ➋\n if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .brick\n {\n\n      ➌\n skater\n .isOnGround\n = true\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    // Make the skater jump if player taps while she is on the ground\n\n    if\n skater\n .isOnGround\n {\n\n     ➊\n skater\n .physicsBody\n ?.applyImpulse\n (CGVector\n (dx: 0.0\n , dy: 260.0\n ))\n\n    }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\nlet\n startingScrollSpeed: CGFloat\n = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n  ➊\n resetSkater\n ()\n\n  ➋\n scrollSpeed\n = startingScrollSpeed\n\n  ➌\n lastUpdateTime\n = nil\n\n  ➍\n for\n brick in\n bricks\n {\n\n        brick.removeFromParent()\n\n    }\n\n  ➎\n bricks\n .removeAll\n (keepingCapacity: true\n )\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n ()\n\n}\n\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\n\n     // Set up the skater and add her to the scene\n\n    skater.setupPhysicsBody()\n\n    resetSkater() // ← Remove this line of code\n\n    addChild(skater)\n\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\noverride\n func\n didMove(to view: SKView\n ) {\n\n    physicsWorld\n .gravity\n = CGVector\n (dx: 0.0\n , dy: -6.0\n )\n\n    physicsWorld\n .contactDelegate\n = self\n\n    anchorPoint\n = CGPoint\n .zero\n\n    let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n    let\n xMid = frame\n .midX\n\n    let\n yMid = frame\n .midY\n\n    background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n    addChild\n (background)\n\n    // Set up the skater and add her to the scene\n\n    skater\n .setupPhysicsBody\n ()\n\n    addChild\n (skater\n )\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n    let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n    let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n    view.addGestureRecognizer(t\n apGesture)\n\n    startGame\n ()\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n    skater.minimumY = skaterY\n\n  ➊\n skater\n .zRotation\n = 0.0\n\n  ➋\n skater\n .physicsBody\n ?.velocity\n = CGVector\n (dx: 0.0\n , dy: 0.0\n )\n\n  ➌\n skater\n .physicsBody\n ?.angularVelocity\n = 0.0\n\n}\n\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc\n gameOver() {\n\n    startGame\n ()\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```", "```\nfunc\n updateSkater() {\n\n    // Determine if the skater is currently on the ground\n\n  ➊\n if\n let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n     ➋\n if\n velocityY < -100.0\n || velocityY > 100.0\n {\n\n         skater\n .isOnGround\n = false\n\n       }\n\n    }\n\n    // Check if the game should end\n\n  ➌\n let\n isOffScreen = skater\n .position\n .y\n < 0.0\n || skater\n .position\n .x\n < 0.0\n\n  ➍\n let\n maxRotation = CGFloat\n (GLKMathDegreesToRadians\n (85.0\n ))\n\n  ➎\n let\n isTippedOver = skater\n .zRotation\n > maxRotation || \n\n        skater\n .zRotation\n < -maxRotation\n\n  ➏\n if\n isOffScreen || isTippedOver {\n\n        gameOver\n ()\n\n    }\n\n}\n```"]