- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Project Structure
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter provides some ideas for structuring your Rust projects. For simple
    projects, the structure set up by `cargo new` is likely to be something you think
    little about. You may add some modules to split up the code, and some dependencies
    for additional functionality, but that’s about it. However, as a project grows
    in size and complexity, you’ll find that you need to go beyond that. Maybe the
    compilation time for your crate is getting out of hand, or you need conditional
    dependencies, or you need a better strategy for continuous integration. In this
    chapter, we will look at some of the tools that the Rust language, and Cargo in
    particular, provide that make it easier to manage such things.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一些关于如何构建 Rust 项目的思路。对于简单的项目，`cargo new` 创建的结构可能是你几乎不需要考虑的。你可能会添加一些模块来拆分代码，添加一些依赖项以获得额外的功能，但大致就是这样。然而，随着项目规模和复杂度的增长，你会发现你需要超越这一点。也许你的
    crate 的编译时间失控了，或者你需要条件依赖，或者你需要更好的持续集成策略。在本章中，我们将看看 Rust 语言以及 Cargo 特别提供的一些工具，这些工具使得管理这些问题变得更加容易。
- en: Features
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性
- en: '*Features* are Rust’s primary tool for customizing projects. At its core, a
    feature is just a build flag that crates can pass to their dependencies in order
    to add optional functionality. Features carry no semantic meaning in and of themselves—instead,
    *you* choose what a feature means for *your* crate.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*特性*是 Rust 自定义项目的主要工具。从本质上讲，特性只是一个构建标志，crate 可以将其传递给依赖项，以便添加可选功能。特性本身没有语义意义——相反，*你*决定特性对*你的*
    crate 意味着什么。'
- en: 'Generally, we use features in three ways: to enable optional dependencies,
    to conditionally include additional components of a crate, and to augment the
    behavior of the code. Note that all of these uses are *additive*; features can
    add to the functionality of the crate, but they shouldn’t generally do things
    like remove modules or replace types or function signatures. This stems from the
    principle that if a developer makes a simple change to their *Cargo.toml*, such
    as adding a new dependency or enabling a feature, that shouldn’t make their crate
    stop compiling. If a crate has mutually exclusive features, that principle quickly
    falls by the wayside—if crate A depends on one feature of crate C, and crate B
    on another mutually exclusive feature of C, adding a dependency on crate B would
    then break crate A! For that reason, we generally follow the principle that if
    crate A compiles against crate C with some set of features, it should also compile
    if all features are enabled on crate C.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们以三种方式使用特性：启用可选依赖项、根据条件包含 crate 的额外组件以及增强代码的行为。请注意，这些用途都是*增量*的；特性可以增强 crate
    的功能，但通常不应做诸如移除模块或替换类型或函数签名之类的事情。这源于这样一个原则：如果开发者对自己的 *Cargo.toml* 做了一个简单的更改，例如添加一个新依赖或启用一个特性，这不应该导致他们的
    crate 无法编译。如果一个 crate 具有互斥的特性，这个原则将很快失效——如果 crate A 依赖于 crate C 的某个特性，而 crate
    B 依赖于 crate C 的另一个互斥特性，那么添加对 crate B 的依赖将会破坏 crate A！因此，我们通常遵循一个原则，即如果 crate A
    在 crate C 上编译时启用了某些特性，它也应该在 crate C 启用所有特性时成功编译。
- en: Cargo leans into this principle quite hard. For example, if two crates (A and
    B) both depend on crate C, but they each enable different features on C, Cargo
    will compile crate C only once, with *all* the features that either A or B requires.
    That is, it’ll take the union of the requested features for C across A and B.
    Because of this, it’s generally hard to add mutually exclusive features to Rust
    crates; chances are that some two dependents will depend on the crate with different
    features, and if those features are mutually exclusive, the downstream crate will
    fail to build.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 在这一原则上非常坚持。例如，如果两个 crate（A 和 B）都依赖于 crate C，但它们分别启用了 C 上的不同特性，Cargo 只会编译一次
    crate C，包含 A 或 B 所需的*所有*特性。也就是说，它会合并 A 和 B 中对 C 请求的特性。因此，一般来说，很难向 Rust crate 添加互斥特性；因为有可能两个依赖项会依赖于具有不同特性的
    crate，如果这些特性是互斥的，下游 crate 将无法编译。
- en: Defining and Including Features
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和包含特性
- en: Features are defined in *Cargo.toml*. [Listing 5-1](#listing5-1) shows an example
    of a crate named `foo` with a simple feature that enables the optional dependency
    `syn`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 特性在 *Cargo.toml* 中定义。[示例 5-1](#listing5-1) 展示了一个名为 `foo` 的 crate 的例子，该 crate
    启用了一个简单的特性，用于启用可选依赖项 `syn`。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: A feature that enables an optional dependency'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1：启用可选依赖项的特性
- en: When Cargo compiles this crate, it will not compile the `syn` crate by default,
    which reduces compile time (often significantly). The `syn` crate will be compiled
    only if a downstream crate needs to use the APIs enabled by the `derive` feature
    and explicitly opts in to it. [Listing 5-2](#listing5-2) shows how such a downstream
    crate `bar` would enable the `derive` feature, and thus include the `syn` dependency.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当Cargo编译这个crate时，默认情况下不会编译`syn` crate，这样可以减少编译时间（通常是显著减少）。只有当下游crate需要使用由`derive`特性启用的API，并且明确选择启用该特性时，`syn`
    crate才会被编译。[列表 5-2](#listing5-2)展示了如何让下游crate `bar`启用`derive`特性，从而包含`syn`依赖。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: Enabling a feature of a dependency'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-2：启用依赖的特性
- en: Some features are used so frequently that it makes more sense to have a crate
    opt out of them rather than in to them. To support this, Cargo allows you to define
    a set of default features for a crate. And similarly, it allows you to opt out
    of the default features of a dependency. [Listing 5-3](#listing5-3) shows how
    `foo` can make its `derive` feature enabled by default, while also opting out
    of some of `syn`’s default features and instead enabling only the ones it needs
    for the `derive` feature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有些特性使用得非常频繁，以至于让crate选择退出这些特性比选择启用它们更为合理。为了支持这一点，Cargo允许你为一个crate定义一组默认特性。同样，它也允许你选择退出依赖的默认特性。[列表
    5-3](#listing5-3)展示了`foo`如何使其`derive`特性默认启用，同时选择退出`syn`的某些默认特性，仅启用`derive`特性所需的特性。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: Adding and opting out of default features, and thus optional dependencies'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-3：添加并选择退出默认特性，从而管理可选依赖
- en: Here, if a crate depends on `foo` and does not explicitly opt out of the default
    features, it will also compile `foo`’s `syn` dependency. In turn, `syn` will be
    built with only the three listed features, and no others. Opting out of default
    features this way, and opting in to only what you need, is a great way to cut
    down on your compile times!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果一个crate依赖于`foo`并且没有明确选择退出默认特性，它也会编译`foo`的`syn`依赖。反过来，`syn`将仅使用列出的三个特性进行构建，不会包含其他特性。以这种方式退出默认特性，并仅选择所需的特性，是减少编译时间的好方法！
- en: Using Features in Your Crate
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在你的crate中使用特性
- en: When using features, you need to make sure your code uses a dependency only
    if it is available. And if your feature enables a particular component, you need
    to make sure that if the feature isn’t enabled, the component is not included.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用特性时，你需要确保只有在依赖可用时才使用它。而且，如果你的特性启用了某个特定组件，你需要确保如果该特性没有启用，那么该组件不会被包含。
- en: You achieve this using *conditional compilation*, which lets you use annotations
    to give conditions under which a particular piece of code should or should not
    be compiled. Conditional compilation is primarily expressed using the `#[cfg]`
    attribute. There is also the closely related `cfg!` macro, which lets you change
    runtime behavior based on similar conditions. You can do all sorts of neat things
    with conditional compilation, as we’ll see later in this chapter, but the most
    basic form is `#[cfg(feature = "some-feature")]`, which makes it so that the next
    “thing” in the source code is compiled only if the `some-feature` feature is enabled.
    Similarly, `if cfg!(feature = "some-feature")` is equivalent to `if true` only
    if the `derive` feature is enabled (and `if false` otherwise).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用*条件编译*来实现这一点，它让你使用注释来指定在特定条件下某段代码是否应该被编译。条件编译主要通过`#[cfg]`属性来表示。同时，还有一个紧密相关的`cfg!`宏，它让你根据类似的条件来改变运行时行为。通过条件编译，你可以做很多有趣的事情，正如我们在本章稍后会看到的，但最基本的形式是`#[cfg(feature
    = "some-feature")]`，它的作用是仅在启用了`some-feature`特性时，才会编译源代码中的下一项内容。类似地，`if cfg!(feature
    = "some-feature")`仅在启用了`derive`特性时，相当于`if true`（否则为`if false`）。
- en: The `#[cfg]` attribute is used more often than the `cfg!` macro, because the
    macro modifies runtime behavior based on the feature, which can make it difficult
    to ensure that features are additive. You can place `#[cfg]` in front of certain
    Rust *items*—such as functions and type definitions, `impl` blocks, modules, and
    `use` statements—as well as on certain other constructs like struct fields, function
    arguments, and statements. The `#[cfg]` attribute can’t go just anywhere, though;
    where it can appear is carefully restricted by the Rust language team so that
    conditional compilation can’t cause situations that are too strange and hard to
    debug.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[cfg]` 属性比 `cfg!` 宏使用得更多，因为宏基于功能修改运行时行为，这可能使得确保功能是可添加的变得困难。您可以将 `#[cfg]`
    放置在某些 Rust *项* 前面—例如函数和类型定义、`impl` 块、模块和 `use` 语句，也可以放置在其他一些结构上，如结构体字段、函数参数和语句上。不过，`#[cfg]`
    属性不能随便放置；其出现位置受到 Rust 语言团队的严格限制，以避免条件编译导致过于奇怪且难以调试的情况。'
- en: Remember that modifying certain public parts of your API may inadvertently make
    a feature nonadditive, which in turn may make it impossible for some users to
    compile your crate. You can often use the rules for backward compatible changes
    as a rule of thumb here—for example, if you make an enum variant or a public struct
    field conditional upon a feature, then that type must also be annotated with `#[non_exhaustive]`.
    Otherwise, a dependent crate that does not have the feature enabled may no longer
    compile if the feature is added due to some second crate in the dependency tree.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，修改 API 的某些公共部分可能会无意中使某个功能变得不可添加，这可能会导致某些用户无法编译您的 crate。您通常可以将向后兼容性更改的规则作为一个经验法则—例如，如果您使一个枚举变体或公共结构体字段依赖于某个功能，那么该类型也必须使用`#[non_exhaustive]`进行注解。否则，如果由于依赖树中的另一个
    crate 添加了该功能，那么没有启用该功能的依赖 crate 可能将无法再编译。
- en: Workspaces
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作区
- en: Crates play many roles in Rust—they are the vertices in the dependency graph,
    the boundaries for trait coherence, and the scopes for compilation features. Because
    of this, each crate is managed as a single compilation unit; the Rust compiler
    treats a crate more or less as one big source file compiled as one chunk that
    is ultimately turned into a single binary output (either a binary or a library).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Crate 在 Rust 中扮演着多种角色——它们是依赖图中的顶点，是特性一致性的边界，也是编译特性的作用域。因此，每个 crate 都作为一个单独的编译单元进行管理；Rust
    编译器将 crate 视为一个大的源文件，将其作为一个整体编译，最终生成一个单一的二进制输出（可以是二进制文件或库）。
- en: While this simplifies many aspects of the compiler, it also means that large
    crates can be painful to work with. If you change a unit test, a comment, or a
    type in one part of your application, the compiler must re-evaluate the entire
    crate to determine what, if anything, changed. Internally, the compiler implements
    a number of mechanisms to speed up this process, like incremental recompilation
    and parallel code generation, but ultimately the size of your crate is a big factor
    in how long your project takes to compile.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这简化了编译器的许多方面，但也意味着大型 crate 的使用可能会变得十分麻烦。如果您更改了应用程序中某个部分的单元测试、注释或类型，编译器必须重新评估整个
    crate，以确定是否发生了变化。编译器内部实现了许多加速这一过程的机制，如增量重编译和并行代码生成，但最终 crate 的大小是影响项目编译时间的一个重要因素。
- en: 'For this reason, as your project grows, you may want to split it into multiple
    crates that internally depend on one another. Cargo has just the feature you need
    to make this convenient: workspaces. A *workspace* is a collection of crates (often
    called *subcrates*) that are tied together by a top-level *Cargo.toml* file like
    the one shown in [Listing 5-4](#listing5-4).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着项目的增长，您可能希望将其拆分为多个相互依赖的 crate。Cargo 提供了一个非常方便的功能来实现这一点：工作区（workspaces）。一个*工作区*是由多个
    crate（通常称为*子 crate*）组成的集合，它们通过一个顶级的*Cargo.toml* 文件相互关联，就像在[清单 5-4](#listing5-4)中展示的那样。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-4: A workspace *Cargo.toml*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-4：一个工作区 *Cargo.toml*
- en: The `members` array is a list of directories that each contain a crate in the
    workspace. Those crates all have their own *Cargo.toml* files in their own subdirectories,
    but they share a single *Cargo.lock* file and a single output directory. The crate
    names don’t need to match the entry in `members`. It is common, but not required,
    that crates in a workspace share a name prefix, usually chosen as the name of
    the “main” crate. For example, in the `tokio` crate, the members are called `tokio`,
    `tokio-test`, `tokio-macros`, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`members`数组是一个包含工作区中每个crate所在目录的列表。这些crate各自有自己子目录中的*Cargo.toml*文件，但它们共享一个*Cargo.lock*文件和一个输出目录。crate的名称不需要与`members`中的条目匹配。虽然不是强制要求，但工作区中的crate通常共享一个名称前缀，通常选择“主”crate的名称。例如，在`tokio`
    crate中，成员分别是`tokio`、`tokio-test`、`tokio-macros`，等等。'
- en: Perhaps the most important feature of workspaces is that you can interact with
    all of the workspace’s members by invoking `cargo` in the root of the workspace.
    Want to check that they all compile? `cargo check` will check them all. Want to
    run all your tests? `cargo test` will test them all. It’s not quite as convenient
    as having everything in one crate, so don’t go splitting everything into minuscule
    crates, but it’s a pretty good approximation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 也许工作区最重要的功能是，你可以通过在工作区根目录下调用`cargo`与工作区的所有成员交互。想检查它们是否都能编译？`cargo check`会检查它们所有的情况。想运行所有测试？`cargo
    test`会测试所有的。虽然这不像将所有内容放在一个crate中那么方便，所以不要将一切拆分成极小的crate，但这是一个相当不错的近似。
- en: Once you have a workspace-level *Cargo.toml* with the array of workspace members,
    you can set your crates to depend on one another using path dependencies, as shown
    in [Listing 5-5](#listing5-5).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有一个包含工作区成员数组的工作区级别的*Cargo.toml*，你可以通过路径依赖将你的crate彼此依赖，如[示例 5-5](#listing5-5)所示。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-5: Intercrate dependencies among workspace crates'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-5：工作区crate之间的互依赖
- en: Now if you make a change to the crate in *bar/two*, then only that crate is
    re-compiled, since `foo` and *bar/one* did not change. It may even be faster to
    compile your project from scratch, since the compiler does not need to evaluate
    your entire project source for optimization opportunities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你对*bar/two*中的crate进行修改，那么只有这个crate会重新编译，因为`foo`和*bar/one*没有发生变化。从头开始编译你的项目可能会更快，因为编译器不需要评估整个项目源代码来寻找优化机会。
- en: Project Configuration
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目配置
- en: Running `cargo new` sets you up with a minimal *Cargo.toml* that has the crate’s
    name, its version number, some author information, and an empty list of dependencies.
    That will take you pretty far, but as your project matures, there are a number
    of useful things you may want to add to your *Cargo.toml*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo new`会为你创建一个最小的*Cargo.toml*，其中包含crate的名称、版本号、一些作者信息和一个空的依赖列表。这会让你走得很远，但随着项目的成熟，你可能会想在*Cargo.toml*中添加一些有用的内容。
- en: Crate Metadata
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建元数据
- en: The first and most obvious thing to add to your *Cargo.toml* is all the metadata
    directives that Cargo supports. In addition to obvious fields like `description`
    and `homepage`, it can be useful to include information such as the path to a
    *README* for the crate (`readme`), the default binary to run with `cargo run`
    (`default-run`), and additional `keywords` and `categories` to help *crates.io*
    categorize your crate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到你的*Cargo.toml*文件中最先且最明显的事情是所有Cargo支持的元数据指令。除了像`description`和`homepage`这样的明显字段外，包含一些信息也很有用，比如
    crate 的*README*路径（`readme`）、与`cargo run`一起运行的默认二进制文件（`default-run`），以及额外的`keywords`和`categories`，这些有助于*crates.io*对你的crate进行分类。
- en: For crates with a more convoluted project layout, it’s also useful to set the
    `include` and `exclude` metadata fields. These dictate which files should be included
    and published in your package. By default, Cargo includes all files in a crate’s
    directory except any listed in your *.gitignore* file, but this may not be what
    you want if you also have large test fixtures, unrelated scripts, or other auxiliary
    data in the same directory that you *do* want under version control. As their
    names suggest, `include` and `exclude` allow you to include only a specific set
    of files or exclude files matching a given set of patterns, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有更复杂项目布局的crate，设置`include`和`exclude`元数据字段也很有用。这些字段决定了哪些文件应该包含在你的包中并发布。默认情况下，Cargo会包含crate目录中的所有文件，除了任何在*.gitignore*文件中列出的文件，但如果你在同一目录中有大型测试夹具、不相关的脚本或其他辅助数据，并且这些数据确实需要版本控制，那么这可能不是你想要的。正如它们的名称所示，`include`和`exclude`分别允许你仅包含特定的文件集或排除符合给定模式的文件。
- en: The list of metadata directives you can use continues to grow, so make sure
    to periodically check in on the Manifest Format page of the Cargo reference ([https://doc.rust-lang.org/cargo/reference/manifest.html](https://doc.rust-lang.org/cargo/reference/manifest.html)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的元数据指令列表不断增长，所以请定期查看 Cargo 文档中的 Manifest 格式页面（[https://doc.rust-lang.org/cargo/reference/manifest.html](https://doc.rust-lang.org/cargo/reference/manifest.html)）。
- en: Build Configuration
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建配置
- en: '*Cargo.toml* can also give you control over how Cargo builds your crate. The
    most obvious tool for this is the `build` parameter, which allows you to write
    a completely custom build program for your crate (we’ll revisit this in Chapter
    11). However, Cargo also provides two smaller, but very useful, mechanisms that
    we’ll explore here: patches and profiles.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cargo.toml* 还可以让你控制 Cargo 如何构建你的 crate。最明显的工具是 `build` 参数，它允许你为 crate 编写完全自定义的构建程序（我们将在第
    11 章中回顾这一点）。然而，Cargo 还提供了两个较小但非常有用的机制，我们将在这里探讨：补丁和配置文件。'
- en: '[patch]'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[patch]'
- en: The `[patch]` section of *Cargo.toml* allows you to specify a different source
    for a dependency that you can use temporarily, no matter where in your dependencies
    the patched dependency appears. This is invaluable when you need to compile your
    crate against a modified version of some transitive dependency to test a bug fix,
    a performance improvement, or a new minor release you’re about to publish. [Listing
    5-6](#listing5-6) shows an example of how you might temporarily use a variant
    of a set of dependencies.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cargo.toml* 中的 `[patch]` 部分允许你为依赖项指定一个不同的源，可以临时使用，无论这个补丁依赖项在你的依赖链中出现的位置在哪里。当你需要编译你的
    crate 以测试某个修复的 bug、性能提升或即将发布的新小版本时，这一点尤为重要。[列表 5-6](#listing5-6) 展示了如何临时使用一组依赖项的变体。'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-6: Overriding dependency sources in *Cargo.toml* using `[patch]`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-6：使用 `[patch]` 在 *Cargo.toml* 中覆盖依赖源
- en: Even if you patch a dependency, Cargo takes care to check the crate versions
    so that you don’t accidentally end up patching the wrong major version of a crate.
    If you for some reason transitively depend on multiple major versions of the same
    crate, you can patch each one by giving them distinct identifiers, as shown in
    [Listing 5-7](#listing5-7).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对某个依赖项进行了补丁，Cargo 也会仔细检查 crate 版本，以确保你不会不小心补丁错误的主版本。如果出于某种原因，你的 crate 依赖于同一个
    crate 的多个主版本，你可以通过为它们分配不同的标识符来为每个版本打补丁，就像在 [列表 5-7](#listing5-7) 中展示的那样。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-7: Overriding multiple versions of the same crate in *Cargo.toml*
    using `[patch]`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：使用 `[patch]` 在 *Cargo.toml* 中覆盖同一 crate 的多个版本
- en: Cargo will look at the *Cargo.toml* inside each path, realize that `/nom4` contains
    major version 4 and that `/nom5` contains major version 5, and patch the two versions
    appropriately. The `package` keyword tells Cargo to look for a crate by the name
    `nom` in both cases instead of using the dependency identifiers (the part on the
    left) as it does by default. You can use `package` this way in your regular dependencies
    as well to rename a dependency!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 会查看每个路径中的 *Cargo.toml*，识别出 `/nom4` 包含主版本 4，而 `/nom5` 包含主版本 5，并相应地对这两个版本进行补丁。`package`
    关键字告诉 Cargo 查找名为 `nom` 的 crate，而不是像默认那样使用依赖标识符（左侧部分）。你也可以在常规依赖项中以这种方式使用 `package`
    来重命名依赖项！
- en: Keep in mind that patches are not taken into account in the package that’s uploaded
    when you publish a crate. A crate that depends on your crate will use only its
    own `[patch]` section (which may be empty), not that of your crate!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在发布 crate 时上传的包不会考虑补丁。依赖于你 crate 的 crate 将只使用它自己 `[patch]` 部分（可能为空），而不会使用你
    crate 的 `[patch]` 部分！
- en: '[profile]'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[profile]'
- en: 'The `[profile]` section lets you pass additional options to the Rust compiler
    in order to change the way it compiles your crate. These options fall primarily
    into three categories: performance options, debugging options, and options that
    change code behavior in user-defined ways. They all have different defaults depending
    on whether you are compiling in debug mode or in release mode (other modes also
    exist).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`[profile]` 部分允许你传递额外的选项给 Rust 编译器，以改变编译 crate 的方式。这些选项主要分为三类：性能选项、调试选项和改变代码行为的用户自定义选项。根据你是以调试模式还是发布模式进行编译（当然还有其他模式），它们有不同的默认设置。'
- en: The three primary performance options are `opt-level`, `codegen-units`, and
    `lto`. The `opt-level` option tweaks runtime performance by telling the compiler
    how aggressively to optimize your program (`0` is “not at all,” `3` is “as much
    as you can”). The higher the setting, the more optimized your code will be, which
    *may* make it run faster. Extra optimization comes at the cost of higher compile
    times, though, which is why optimizations are generally enabled only for release
    builds.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要的性能选项是 `opt-level`、`codegen-units` 和 `lto`。`opt-level` 选项通过告诉编译器如何积极地优化程序来调整运行时性能（`0`
    是“完全不优化”，`3` 是“尽可能多地优化”）。设置越高，代码就会被优化得越多，这 *可能* 会使程序运行得更快。不过，额外的优化会带来更高的编译时间，这也是为什么通常只在发布版本中启用优化的原因。
- en: The `codegen-units` option is about compile-time performance. It tells the compiler
    how many independent compilation tasks (*code generation units*) it is allowed
    to split the compilation of a single crate into. The more pieces a large crate’s
    compilation is split into, the faster it will compile, since more threads can
    help compile the crate in parallel. Unfortunately, to achieve this speedup, the
    threads need to work more or less independently, which means code optimization
    suffers. Imagine, for example, that the segment of a crate compiling in one thread
    could benefit from inlining some code in a different segment—since the two segments
    are independent, that inlining can’t happen! This setting, then, is a trade-off
    between compile-time performance and runtime performance. By default, Rust uses
    an effectively unbounded number of codegen units in debug mode (basically, “compile
    as fast as you can”) and a smaller number (16 at the time of writing) in release
    mode.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`codegen-units` 选项关系到编译时性能。它告诉编译器允许将单个 crate 的编译拆分成多少个独立的编译任务（*代码生成单元*）。一个大
    crate 的编译被拆分成更多的部分，编译速度会更快，因为更多的线程可以帮助并行编译 crate。不幸的是，为了实现这一加速，线程需要尽可能独立工作，这意味着代码优化会受到影响。例如，假设在一个线程中编译的
    crate 部分可以通过内联其他部分的代码来受益——但由于这两个部分是独立的，内联无法发生！因此，这个设置是在编译时性能和运行时性能之间的折衷。默认情况下，Rust
    在调试模式下使用几乎没有限制的代码生成单元数量（基本上是“尽可能快地编译”），而在发布模式下使用较少的数量（写作时为 16）。'
- en: The `lto` setting toggles *link-time optimization (LTO)*, which enables the
    compiler (or the linker, if you want to get technical about it) to jointly optimize
    bits of your program, known as *compilation units*, that were originally compiled
    separately. The exact details of LTO are beyond the scope of this book, but the
    basic idea is that the output from each compilation unit includes information
    about the code that went into that unit. After all the units have been compiled,
    the linker makes another pass over all of the units and uses that additional information
    to optimize the combined compiled code. This extra pass adds to the compile time
    but recovers most of the runtime performance that may have been lost due to splitting
    the compilation into smaller parts. In particular, LTO can offer significant performance
    boosts to performance-sensitive programs that might benefit from cross-crate optimization.
    Beware, though, that cross-crate LTO can add a lot to your compile time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`lto` 设置切换 *链接时优化（LTO）*，它使得编译器（或者更技术性地说是链接器）能够共同优化程序的各个部分，这些部分原本是分别编译的，称为 *编译单元*。LTO
    的具体细节超出了本书的范围，但基本思想是，每个编译单元的输出包括了关于该单元所包含代码的信息。当所有单元编译完成后，链接器会再次遍历所有单元，并利用这些额外的信息来优化合并后的编译代码。这一额外的处理步骤会增加编译时间，但能够恢复大部分由于将编译拆分成更小部分而损失的运行时性能。特别是，LTO
    可以为性能敏感的程序提供显著的性能提升，这些程序可能从跨 crate 的优化中受益。然而，需要注意的是，跨 crate 的 LTO 可能会显著增加编译时间。'
- en: Rust performs LTO across all the codegen units within each crate by default
    in an attempt to make up for the lost optimizations caused by using many codegen
    units. Since the LTO is performed only within each crate, rather than across crates,
    this extra pass isn’t too onerous, and the added compile time should be lower
    than the amount of time saved by using a lot of codegen units. Rust also offers
    a technique known as *thin LTO*, which allows the LTO pass to be mostly parallelized,
    at the cost of missing some optimizations a “full” LTO pass would have found.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 默认在每个 crate 内的所有 codegen 单元之间执行 LTO，以弥补使用多个 codegen 单元时导致的优化损失。由于 LTO 仅在每个
    crate 内执行，而不是跨 crate 执行，因此这个额外的过程并不会太繁重，且增加的编译时间应当低于使用大量 codegen 单元所节省的时间。Rust
    还提供了一种名为*薄 LTO*（thin LTO）的方法，该方法允许 LTO 过程大部分并行化，但代价是错过一些“完整” LTO 过程会找到的优化。
- en: The `[profile]` section also supports flags that aid in debugging, such as `debug`,
    `debug-assertions`, and `overflow-checks`. The `debug` flag tells the compiler
    to include debug symbols in the compiled binary. This increases the binary size,
    but it means that you get function names and such, rather than just instruction
    addresses, in backtraces and profiles. The `debug-assertions` flag enables the
    `debug_assert!` macro and other related debug code that isn’t compiled otherwise
    (through `cfg(debug_assertions)`). Such code may make your program run slower,
    but it makes it easier to catch questionable behavior at runtime. The `overflow-checks`
    flag, as the name implies, enables overflow checks on integer operations. This
    slows them down (notice a trend here?) but can help you catch tricky bugs early
    on. By default, these are all enabled in debug mode and disabled in release mode.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`[profile]` 部分还支持有助于调试的标志，如 `debug`、`debug-assertions` 和 `overflow-checks`。`debug`
    标志告诉编译器在编译的二进制文件中包含调试符号。这会增加二进制文件的大小，但它意味着在回溯和性能分析中，你将看到函数名等，而不是仅仅是指令地址。`debug-assertions`
    标志启用 `debug_assert!` 宏和其他相关的调试代码，这些代码默认情况下不会编译（通过 `cfg(debug_assertions)`）。这些代码可能会使程序运行变慢，但它能帮助你在运行时捕捉到可疑行为。`overflow-checks`
    标志，顾名思义，会在整数操作中启用溢出检查。这会使操作变慢（注意到一个趋势了吗？），但可以帮助你早期发现棘手的 bug。默认情况下，这些选项在调试模式下是启用的，在发布模式下是禁用的。'
- en: '[profile.*.panic]'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[profile.*.panic]'
- en: 'The `[profile]` section has another flag that deserves its own subsection:
    `panic`. This option dictates what happens when code in your program calls `panic!`,
    either directly or indirectly through something like `unwrap`. You can set `panic`
    to either `unwind` (the default on most platforms) or `abort`. We’ll talk more
    about panics and unwinding in Chapter 9, but I’ll give a quick summary here.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`[profile]` 部分有一个需要单独小节讨论的标志：`panic`。这个选项决定了程序中的代码在调用 `panic!` 时（无论是直接调用还是通过类似
    `unwrap` 的间接调用）会发生什么。你可以将 `panic` 设置为 `unwind`（大多数平台的默认值）或 `abort`。我们将在第 9 章中更详细地讨论
    panic 和展开的内容，但这里我会给出一个简要总结。'
- en: Normally in Rust, when your program panics, the thread that panicked starts
    *unwinding* its stack. You can think of unwinding as forcibly returning recursively
    from the current function all the way to the bottom of that thread’s stack. That
    is, if `main` called `foo`, `foo` called `bar`, and `bar` called `baz`, a panic
    in `baz` would forcibly return from `baz`, then `bar`, then `foo`, and finally
    from `main`, resulting in the program exiting. A thread that unwinds will drop
    all values on the stack normally, which gives the values a chance to clean up
    resources, report errors, and so on. This gives the running system a chance to
    exit gracefully even in the case of a panic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，通常当程序发生 panic 时，发生 panic 的线程会开始*展开*其栈。你可以将展开理解为强制从当前函数递归返回，直到回到该线程栈的底部。也就是说，如果
    `main` 调用了 `foo`，`foo` 调用了 `bar`，`bar` 调用了 `baz`，那么 `baz` 中发生 panic 时会强制从 `baz`
    返回，然后是 `bar`，然后是 `foo`，最后是 `main`，从而导致程序退出。发生展开的线程会正常地丢弃栈上的所有值，这为这些值提供了清理资源、报告错误等的机会。这使得即使在发生
    panic 的情况下，运行中的系统也有机会优雅地退出。
- en: When a thread panics and unwinds, other threads continue running unaffected.
    Only when (and if) the thread that ran `main` exits does the program terminate.
    That is, the panic is generally isolated to the thread in which the panic occurred.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程发生 panic 并展开时，其他线程会继续运行，不受影响。只有当（如果）运行 `main` 的线程退出时，程序才会终止。也就是说，panic
    通常仅限于发生 panic 的线程。
- en: This means unwinding is a double-edged sword; the program is limping along with
    some failed components, which may cause all sorts of strange behaviors. For example,
    imagine a thread that panics halfway through updating the state in a `Mutex`.
    Any thread that subsequently acquires that `Mutex` must now be prepared to handle
    the fact that the state may be in a partially updated, inconsistent state. For
    this reason, some synchronization primitives (like `Mutex`) will remember if a
    panic occurred when they were last accessed and communicate that to any thread
    that tries to access the primitive subsequently. If a thread encounters such a
    state, it will normally also panic, which leads to a cascade that eventually terminates
    the entire program. But that is arguably better than continuing to run with corrupted
    state!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着堆栈展开是一把双刃剑；程序在某些组件失败的情况下勉强运行，这可能导致各种奇怪的行为。例如，想象一个线程在更新`Mutex`状态的过程中发生恐慌。任何后续获取该`Mutex`的线程都必须准备好处理状态可能处于部分更新、不一致的情况。因此，一些同步原语（如`Mutex`）会记住上次访问时是否发生了恐慌，并将这一信息传递给任何后续尝试访问该原语的线程。如果线程遇到这种状态，它通常也会发生恐慌，从而导致级联效应，最终终止整个程序。但可以说，这比在损坏的状态下继续运行要好得多！
- en: 'The bookkeeping needed to support unwinding is not free, and it often requires
    special support by the compiler and the target platform. For example, many embedded
    platforms cannot unwind the stack efficiently at all. Rust therefore supports
    a different panic mode: `abort` ensures the whole program simply exits immediately
    when a panic occurs. In this mode, no threads get to do any cleanup. This may
    seem severe, and it is, but it ensures that the program is never running in a
    half-working state and that errors are made visible immediately.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 支持堆栈展开所需的记录并非免费的，它通常需要编译器和目标平台的特别支持。例如，许多嵌入式平台根本无法有效地展开堆栈。因此，Rust支持一种不同的恐慌模式：`abort`，它确保当发生恐慌时，整个程序会立即退出。在这种模式下，所有线程都不会进行任何清理工作。这可能显得很严厉，确实如此，但它确保了程序永远不会在半工作状态下运行，并且错误能够立即显现出来。
- en: 'You may have noticed that when a thread panics, it tends to print a *backtrace*:
    the trail of function calls that led to where the panic occurred. This is also
    a form of unwinding, though it is separate from the unwinding panic behavior discussed
    here. You can have backtraces even with `panic=abort` by passing `-Cforce-unwind-tables`
    to `rustc`, which makes `rustc` include the information necessary to walk back
    up the stack while still terminating the program on a panic.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，当一个线程发生恐慌时，它往往会打印出*回溯*信息：导致恐慌发生的函数调用轨迹。这也是一种堆栈展开，尽管它与这里讨论的堆栈展开恐慌行为是不同的。即使使用`panic=abort`，通过传递`-Cforce-unwind-tables`给`rustc`，你仍然可以获取回溯信息，这会使`rustc`包含必要的信息，以便在终止程序的同时回溯堆栈。
- en: Conditional Compilation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件编译
- en: Most Rust code you write is universal—it’ll work the same regardless of what
    CPU or operating system it runs on. But sometimes you’ll have to do something
    special to get the code to work on Windows, on ARM chips, or when compiled against
    a particular platform application binary interface (ABI). Or maybe you want to
    write an optimized version of a particular function when a given CPU instruction
    is available, or disable some slow but uninteresting setup code when running in
    a continuous integration (CI) environment. To cater to cases like these, Rust
    provides mechanisms for *conditional compilation*, in which a particular segment
    of code is compiled only if certain conditions are true of the compilation environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的大多数Rust代码是通用的——无论它运行在什么CPU或操作系统上，都会以相同的方式工作。但有时你必须做一些特殊的事情，才能让代码在Windows上、ARM芯片上，或者在针对特定平台应用程序二进制接口（ABI）编译时正常工作。或者，可能你希望在某个特定的CPU指令可用时，编写某个函数的优化版本，或者在持续集成（CI）环境中禁用一些慢但无关紧要的设置代码。为了应对这些情况，Rust提供了*条件编译*机制，其中只有在特定的编译环境条件为真时，某个代码片段才会被编译。
- en: We denote conditional compilation with the `cfg` keyword that you saw earlier
    in the chapter in “Using Features in Your Crate.” It usually appears in the form
    of the `#[cfg(condition)]` attribute, which says to compile the next item only
    if `condition` is true. Rust also has `#[cfg_attr(condition, attribute)]`, which
    is compiled as `#[attribute]` if `condition` holds and is a no-op otherwise. You
    can also evaluate a `cfg` condition as a Boolean expression using the `cfg!(condition)`
    macro.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Every `cfg` construct takes a single condition made up of options, like `feature
    = "some-feature"`, and the combinators `all`, `any`, and `not`, which do what
    you would probably expect. Options are either simple names, like `unix`, or key/value
    pairs like those used by feature conditions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of interesting options you can make compilation dependent
    on. Let’s go through them, from most common to least common:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature options**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen examples of these. Feature options take the form `feature
    = "name-of-feature"` and are considered true if the named feature is enabled.
    You can check for multiple features in a single condition using the combinators.
    For example, `any(feature = "f1", feature = "f2")` is true if either feature `f1`
    or feature `f2` is enabled.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Operating system options**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'These use key/value syntax with the key `target_os` and values like `windows`,
    `macos`, and `linux`. You can also specify a family of operating systems using
    `target_family`, which takes the value `windows` or `unix`. These are common enough
    that they have received their own named short forms, so you can use `cfg(windows)`
    and `cfg(unix)` directly. For example, if you wanted a particular code segment
    to be compiled only on macOS and Windows, you would write: `#[cfg(any(windows,
    target_os = "macos"))]`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Context options**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: These let you tailor code to a particular compilation context. The most common
    of these is the `test` option, which is true only when the crate is being compiled
    under the test profile. Keep in mind that `test` is set only for the crate that
    is being tested, not for any of its dependencies. This also means that `test`
    is not set in your crate when running integration tests; it’s the integration
    tests that are compiled under the test profile, whereas your actual crate is compiled
    normally (that is, without `test` set). The same applies to the `doc` and `doctest`
    options, which are set only when building documentation or compiling doctests,
    respectively. There’s also the `debug_assertions` option, which is set in debug
    mode by default.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tool options**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Some tools, like clippy and Miri, set custom options (more on that later) that
    let you customize compilation when run under these tools. Usually, these options
    are named after the tool in question. For example, if you want a particular compute-intensive
    test not to run under Miri, you can give it the attribute `#[cfg_attr(miri, ignore)]`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Architecture options**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: These let you compile based on the CPU instruction set the compiler is targeting.
    You can specify a particular architecture with `target_arch`, which takes values
    like `x86`, `mips`, and `aarch64`, or you can specify a particular platform feature
    with `target_feature`, which takes values like `avx` or `sse2`. For very low-level
    code, you may also find the `target_endian` and `target_pointer_width` options
    useful.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些选项让你可以根据编译器目标的CPU指令集来编译代码。你可以通过`target_arch`指定特定的架构，`target_arch`接受像`x86`、`mips`、`aarch64`这样的值，或者你可以通过`target_feature`指定特定的平台特性，`target_feature`接受像`avx`或`sse2`这样的值。对于非常底层的代码，你还可能发现`target_endian`和`target_pointer_width`选项非常有用。
- en: '**Compiler options**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器选项**'
- en: These let you adapt your code to the platform ABI it is compiled against and
    are available through `target_env` with values like `gnu`, `msvc`, and `musl`.
    For historical reasons, this value is often empty, especially on GNU platforms.
    You normally need this option only if you need to interface directly with the
    environment ABI, such as when linking against an ABI-specific symbol name using
    `#[link]`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些选项让你可以将代码适配到其编译目标平台的ABI，并且可以通过`target_env`来使用，`target_env`的值包括`gnu`、`msvc`和`musl`。出于历史原因，这个值在GNU平台上通常为空。通常，只有在你需要直接与环境ABI接口时，才需要这个选项，例如在使用`#[link]`链接到ABI特定符号名称时。
- en: 'While `cfg` conditions are usually used to customize code, some can also be
    used to customize dependencies. For example, the dependency `winrt` usually makes
    sense only on Windows, and the `nix` crate is probably useful only on Unix-based
    platforms. [Listing 5-9](#listing5-9) gives an example of how you can use `cfg`
    conditions for this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`cfg`条件通常用于定制代码，但也有一些可以用于定制依赖项。例如，依赖项`winrt`通常只有在Windows系统上才有意义，而`nix` crate可能只在Unix-based平台上有用。[列表
    5-9](#listing5-9)提供了一个如何使用`cfg`条件的示例：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-9: Conditional dependencies'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-9: 条件依赖'
- en: Here, we specify that `winrt` version 0.7 should be considered a dependency
    only under `cfg(windows)` (so, on Windows), and `nix` version 0.17 only under
    `cfg(unix)` (so, on Linux, macOS, and other Unix-based platforms). One thing to
    keep in mind is that the `[dependencies]` section is evaluated very early in the
    build process, when only certain `cfg` options are available. In particular, feature
    and context options are not yet available at this point, so you cannot use this
    syntax to pull in dependencies based on features and contexts. You can, however,
    use any `cfg` that depends only on the target specification or architecture, as
    well as any options explicitly set by tools that call into `rustc` (like `cfg(miri)`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定只有在`cfg(windows)`条件下（即在Windows上），`winrt`版本0.7才应该被视为一个依赖项，而`nix`版本0.17仅在`cfg(unix)`条件下（即在Linux、macOS和其他Unix-based平台上）才被视为依赖项。需要记住的一点是，`[dependencies]`部分在构建过程中非常早期就会被评估，此时只有某些`cfg`选项可用。特别地，功能和上下文选项在此时尚不可用，因此你不能使用这种语法来根据功能和上下文拉取依赖项。然而，你可以使用仅依赖于目标规范或架构的任何`cfg`选项，以及任何显式由调用`rustc`的工具设置的选项（如`cfg(miri)`）。
- en: 'It’s also quite simple to add your own custom conditional compilation options.
    You just have to make sure that `--cfg=myoption` is passed to `rustc` when `rustc`
    compiles your crate. The easiest way to do this is to add your `--cfg` to the
    `RUSTFLAGS` environment variable. This can come in handy in CI, where you may
    want to customize your test suite depending on whether it’s being run on CI or
    on a dev machine: add `--cfg=ci` to `RUSTFLAGS` in your CI setup, and then use
    `cfg(ci)` and `cfg(not(ci))` in your code. Options set this way are also available
    in *Cargo.toml* dependencies.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 添加你自己的自定义条件编译选项也相当简单。你只需要确保在`rustc`编译你的crate时传递`--cfg=myoption`给`rustc`。最简单的做法是将你的`--cfg`添加到`RUSTFLAGS`环境变量中。这在CI中很有用，在CI中你可能希望根据测试是在CI上运行还是在开发机器上运行来定制测试套件：在CI设置中将`--cfg=ci`添加到`RUSTFLAGS`中，然后在代码中使用`cfg(ci)`和`cfg(not(ci))`。以这种方式设置的选项也可以在*Cargo.toml*依赖项中使用。
- en: Versioning
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: 'All Rust crates are versioned and are expected to follow Cargo’s implementation
    of semantic versioning. *Semantic versioning* dictates the rules for what kinds
    of changes require what kinds of version increases and for which versions are
    considered compatible, and in what ways. The RFC 1105 standard itself is well
    worth reading (it’s not horribly technical), but to summarize, it differentiates
    between three kinds of changes: breaking changes, which require a major version
    change; additions, which require a minor version change; and bug fixes, which
    require only a patch version change. RFC 1105 does a decent job of outlining what
    constitutes a breaking change in Rust, and we’ve touched on some aspects of it
    elsewhere in this book.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go into detail here about the exact semantics of the different types
    of changes. Instead, I want to highlight some less straightforward ways version
    numbers come up in the Rust ecosystem, which you need to keep in mind when deciding
    how to version your own crates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Supported Rust Version
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first Rust-ism is the *minimum supported Rust version (MSRV)*. There is
    much debate in the Rust community about what policy projects should adhere to
    when it comes to their MSRV and versioning, and there’s no truly good answer.
    The core of the problem is that some Rust users are limited to using older versions
    of Rust, often in an enterprise setting where they have little choice. If we constantly
    take advantage of newly stabilized APIs, those users will not be able to compile
    the latest versions of our crates and will be left behind.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: There are two techniques crate authors can use to make life a little easier
    for users in this position. The first is to establish an MSRV policy promising
    that new versions of a crate will always compile with any stable release from
    the last *X* months. The exact number varies, but 6 or 12 months is common. With
    Rust’s six-week release cycle, that corresponds to the latest four or eight stable
    releases, respectively. Any new code introduced to the project must compile with
    the MSRV compiler (usually checked by CI) or be held until the MSRV policy allows
    it to be merged as is. This can sometimes be a pain, as it means these crates
    cannot take advantage of the latest and greatest the language has to offer, but
    it will make life easier for your users.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The second technique is to make sure to increase the minor version number of
    your crate any time that the MSRV changes. So, if you release version 2.7.0 of
    your crate and that increases your MSRV from Rust 1.44 to Rust 1.45, then a project
    that is stuck on 1.44 and that depends on your crate can use the dependency version
    specifier `version = "2, <2.7"` to keep the project working until it can move
    on to Rust 1.45\. It’s important that you increment the minor version, not just
    the patch version, so that you can still issue critical security fixes for the
    previous MSRV release by doing another patch release if necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Some projects take their MSRV support so seriously that they consider an MSRV
    change a breaking change and increment the major version number. This means that
    downstream projects will explicitly have to opt in to an MSRV change, rather than
    opting out—but it also means that users who do not have such strict MSRV requirements
    will not see future bug fixes without updating their dependencies, which may require
    *them* to issue a breaking change as well. As I said, none of these solutions
    are without drawbacks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing an MSRV in the Rust ecosystem today is challenging. Only a small subset
    of crates provide any MSRV guarantees, and even if your dependencies do, you will
    need to constantly monitor them to know when they increase their MSRV. When they
    do, you’ll need to do a new release of your crate with the restricted version
    bounds mentioned previously to make sure your MSRV doesn’t also change. This may
    in turn force you to forego security and performance updates made to your dependencies,
    as you’ll have to continue using older versions until your MSRV policy permits
    updating. And that decision also carries over to your dependents. There have been
    proposals to build MSRV checking into Cargo itself, but nothing workable has been
    stabilized as of this writing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Minimal Dependency Versions
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you first add a dependency, it’s not always clear what version specifier
    you should give that dependency. Programmers commonly choose the latest version,
    or just the current major version, but chances are that both of those choices
    are wrong. By “wrong,” I don’t mean that your crate won’t compile, but rather
    that making that choice may cause strife for users of your crate down the line.
    Let’s look at why each of these cases is problematic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: First, consider the case where you add a dependency on `hugs = "1.7.3"`, the
    latest published version. Now imagine that a developer somewhere depends on your
    crate, but they also depend on some other crate, `foo`, that itself depends on
    `hugs`. Further imagine that the author of `foo` is really careful about their
    MSRV policy, so they depend on `hugs = "1, <1.6"`. Here, you’ll run into trouble.
    When Cargo sees `hugs = "1.7.3"`, it considers only versions `>=1.7`. But then
    it sees that `foo`’s dependency on `hugs` requires `<1.6`, so it gives up and
    reports that there is no version of `hugs` compatible with all the requirements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This is unfortunate, as it could well be that your crate compiles fine with,
    say, `hugs 1.5.6`. Maybe it even compiles fine with *any* `1.X` version! But by
    using the latest version number, you are telling Cargo to consider only versions
    at or beyond that minor version. Is the solution to use `hugs = "1"` instead,
    then? No, that’s not quite right either. It could be that your code truly does
    depend on something that was added only in `hugs 1.6`, so while `1.6.2` would
    be fine, `1.5.6` would not be. You wouldn’t notice this if you were only ever
    compiling your crate in situations where a newer version ends up getting used,
    but if some crate in the dependency graph specifies `hugs = "1, <1.5"`, your crate
    would not compile!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The right strategy is to list the earliest version that has all the things your
    crate depends on and to make sure that this remains the case even as you add new
    code to your crate. But how do you establish that beyond trawling the changelogs,
    or through trial and error? Your best bet is to use Cargo’s unstable `-Zminimal-versions`
    flag, which makes your crate use the minimum acceptable version for all dependencies,
    rather than the maximum. Then, set all your dependencies to just the latest major
    version number, try to compile, and add a minor version to any dependencies that
    don’t. Rinse and repeat until everything compiles fine, and you now have your
    minimum version requirements!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that, like with MSRV, minimal version checking faces an ecosystem
    adoption problem. While you may have set all your version specifiers correctly,
    the projects you depend on may not have. This makes the Cargo minimal versions
    flag hard to use in practice (and is why it’s still unstable). If you depend on
    `foo`, and `foo` depends on `bar` with a specifier of `bar = "1"` when it actually
    requires `bar = "1.4"`, Cargo will report that it failed to compile `foo` no matter
    how you list `foo` because the `-Z` flag tells it to always prefer minimal versions.
    You can work around this by listing `bar` directly in *your* dependencies with
    the appropriate version requirement, but these workarounds can be painful to set
    up and maintain. You may end up listing a large number of dependencies that are
    only really pulled in through your transitive dependencies, and you’ll have to
    keep that list up to date as time goes on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Changelogs
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all but the most trivial crates, I highly recommend keeping a changelog.
    There is little more frustrating than seeing that a dependency has received a
    major version bump and then having to dig through the Git logs to figure out what
    changed and how to update your code. I recommend that you do not just dump your
    Git logs into a file named *changelog*, but instead keep a manual changelog. It
    is much more likely to be useful.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A simple but good format for changelogs is the Keep a Changelog format documented
    at [https://keepachangelog.com/](https://keepachangelog.com/).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Unreleased Versions
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust considers version numbers even when the source of a dependency is a directory
    or a Git repository. This means that semantic versioning is important even when
    you have not yet published a release to *crates.io*; it matters what version is
    listed in your *Cargo.toml* between releases. The semantic versioning standard
    does not dictate how to handle this case, but I’ll provide a workflow that works
    decently well without being too onerous.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve published a release, immediately update the version number in your
    *Cargo.toml* to the next patch version with a suffix like *-alpha.1*. If you just
    released 2.0.3, make the new version 2.0.4-alpha.1\. If you just released an alpha,
    increment the alpha number instead.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: As you make changes to the code between releases, keep an eye out for additive
    or breaking changes. If one happens, and the corresponding version number has
    not changed since the last release, increment it. For example, if the last released
    version is 2.0.3, the current version is 2.0.4-alpha.2, and you make an additive
    change, make the version with the change 2.1.0-alpha.1\. If you made a breaking
    change, it becomes 3.0.0-alpha.1 instead. If the corresponding version increase
    has already been made, just increment the alpha number.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: When you make a release, remove the suffix (unless you want to do a prerelease),
    then publish, and start from the top.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: This process is effective because it makes two common workflows work much better.
    First, imagine that a developer depends on major version 2 of your crate, but
    they need a feature that’s currently available only in Git. Then you commit a
    breaking change. If you don’t increase the major version at the same time, their
    code will suddenly fail in unexpected ways, either by failing to compile or as
    a result of weird runtime issues. If you follow the procedure laid out here, they’ll
    instead be notified by Cargo that a breaking change has occurred, and they’ll
    have to either resolve that or pin a specific commit.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Next, imagine that a developer needs a feature they just contributed to your
    crate, but which isn’t part of any released version of your crate yet. They’ve
    used your crate behind a Git dependency for a while, so other developers on their
    project already have older checkouts of your crate’s repository. If you do not
    increment the major version number in Git, this developer has no way to communicate
    that their project now relies on the feature that was just merged. If they push
    their change, their fellow developers will find that the project no longer compiles,
    since Cargo will reuse the old checkout. If, on the other hand, the developer
    can increment the minor version number for the Git dependency, then Cargo will
    realize that the old checkout is outdated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: This workflow is by no means perfect. It doesn’t provide a good way to communicate
    multiple minor or major changes between releases, and you still need to do a bit
    of work to keep track of the versions. However, it does address two of the most
    common issues Rust developers run into when they work against Git dependencies,
    and even if you make multiple such changes between releases, this workflow will
    still catch many of the issues.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not too worried about small or consecutive version numbers in releases,
    you can improve this suggested workflow by simply always incrementing the appropriate
    part of the version number. Be aware, though, that depending on how frequently
    you make such changes, this may make your version numbers quite large!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at a number of mechanisms for configuring, organizing,
    and publishing crates, for both your own benefit and that of others. We’ve also
    gone over some common gotchas when working with dependencies and features in Cargo
    that now hopefully won’t catch you out in the future. In the next chapter we’ll
    turn to testing and dig into how you go beyond Rust’s simple `#[test]` functions
    that we know and love.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
