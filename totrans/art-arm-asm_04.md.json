["```\n .data \nbb:  .byte    0 \n     .byte    1,2,3 \n\nu:   .word    1 \n     .dword   5,2,10 \n\nc:   .byte    0 \n     .byte    'a', 'b', 'c', 'd', 'e', 'f' \n\nbn:  .byte    0 \n     .byte    true  // Assumes true is defined as 1 \n```", "```\n.section .rodata, \"\"\n```", "```\n .section  .rodata, \"\"\npi:      .single   3.141592653589793 // (rounded) \ne:       .single   2.718281828459045 // (rounded) \nMaxU16:  .hword    65535 \nMaxI16:  .hword    32767 \n```", "```\n .section  .rodata, \"\"\nroArray: .byte     0 \n         .byte     1, 2, 3, 4, 5 \ndwVal:   .dword    1 \n         .dword    0 \n```", "```\n .bss \nUninitUns32: .word  0 \ni:           .word  0 \ncharacter:   .byte  0 \nbb:          .byte  0 \n```", "```\n .bss \nUninitUns32: .word  .-. \ni:           .word  .-. \ncharacter:   .byte  .-. \nbb:          .byte  .-. \n```", "```\n .equ   _, 0  // \"_\" is a legitimate identifier \n             .bss \nUninitUns32: .word  _\ni:           .word  _\ncharacter:   .byte  _\nbb:          .byte  _\n```", "```\n.section `identifier`, `flags` \n```", "```\n.section aDataSection, \"adw\" // Typical data section \n.section .const, \"\"          // Like .rodata \n.section .code, \"x\"          // Code section (like .text) \n```", "```\n .data\ni_static:   .word     0\n\n            .bss\ni_uninit:   .word     .-.\n\n .section  .rodata, \"\"\ni_readonly: .word     5\n\n            .data\nj:          .word     0\n\n            .section  .rodata, \"\"\ni2:         .word     9\n\n            .bss\nc:          .byte     .-.\n\n            .bss\nd:          .word     .-.\n\n            .text\n\n`Code goes here.`\n```", "```\nldr w0, someWordVar  // Assume someWordVar is in .data \n```", "```\nerror: unknown AArch64 fixup kind! \n```", "```\nrelocation truncated to fit: R_AARCH64_LD_PREL_LO19 against `.data' \n```", "```\nldr reg, =constant \n```", "```\nldr reg, =largeConstant \n```", "```\n ldr x0, a64_bit_constant \n    ldr w0, a32_bit_constant \n     . \n     . \n     . \n// Somewhere in the .text section that will never \n// be executed as code: \n\na64_bit_constant: .dword  `The_Actual_64bit_Constant_Value` \na32_bit_constant: .word   `The_Actual_32bit_Constant_Value` \n```", "```\n .data\nbb: .byte  0        // Location counter = 0, size = 1\ns:  .hword 0        // Location counter = 1, size = 2\nw:  .word  0        // Location counter = 3, size = 4\nd:  .dword 0        // Location counter = 7, size = 8\nq:  .qword 0        // Location counter = 15, size = 16\n                    // Location counter is now 31.\n```", "```\n .data\nbb: .byte    0\n\n    .section .rodata, \"\"\nw:  .word    0x1234\n\n    .bss\nd:  .dword   .-.\n```", "```\n .data\nbb: .byte   0\n\n    .data\nw:  .word   0x1234\n\n    .data\nd:  .dword  0\n```", "```\nrev16 `reg`dest`, reg`src \n```", "```\nldr     w1, =0x12345678 \nrev16   w1, w1 \n```", "```\nrev32 `reg`dest, `reg`src \n```", "```\n .data \nw:  .word  0 \nbb: .byte  0 \ns:  .hword 0 \nw2: .word  0 \ns2: .hword 0 \nb2: .byte  0 \ndw: .dword 0 \n```", "```\n // Start Adrs       Length \nw:    .word   0      //    4096            4 \nbb:   .byte   0      //    4100            1 \ns:    .hword  0      //    4101            2 \nw2:   .word   0      //    4103            4 \ns2:   .hword  0      //    4107            2 \nb2:   .byte   0      //    4109            1 \ndw:   .dword  0      //    4110            8 \n```", "```\n .data \ndw:   .dword  0 \nw:    .word   0 \nw2:   .word   0 \ns:    .hword  0 \ns2:   .hword  0 \nbb:   .byte   0 \nb2:   .byte   0 \n```", "```\n //  Start Adrs     Length \ndw:    .dword  0   //     4096          8 \nw2:    .word   0   //     4104          4 \nw3:    .word   0   //     4108          4 \ns:     .hword  0   //     4112          2 \ns2:    .hword  0   //     4114          2 \nbb:    .byte   0   //     4116          1 \nb2:    .byte   0   //     4117          1 \n```", "```\n.align  pwr2Alignment, padValue \n.balign alignment, padValue \n```", "```\n .data \n     .align  2   // Align on 4-byte boundary. \nw:   .word   0 \nbb:  .byte   0 \n     .align  1   // Align on 2-byte boundary. \ns:   .hword  0 \n     .align  2   // Align on 4-byte boundary. \nw2:  .word   0 \ns2:  .hword  0 \nb2:  .byte   0 \n     .align  3   // Align on 8-byte boundary. \ndw:  .dword  0 \n```", "```\n ldr w0, wordVar \n           . \n           . \n           . \nwordVar: .word 12345 \n```", "```\nldr x0, [x1] \n```", "```\nldr x1, =12345678 \nldr x0, [x1]    // Attempts to access location 12345678 \n```", "```\nlea x1, j \n```", "```\nbVar:  .byte 0, 1, 2, 3 \n```", "```\nldrb w1, [x1]   // Load byte at bVar (0) into W1\\. \n```", "```\n[X`n`|SP, #`signed_expression`] \n```", "```\nldrb  w0, [x1, #1] // Fetch byte at address X1 + 1\\. \n```", "```\nadd  x2, x1, #2000  // Access location X1 + 2000\\. \nldrb w2, [x2] \n```", "```\n[X`n`|SP, #`unsigned_expression`] \n```", "```\nldr  w0, [X2, #16] \n```", "```\n[X`n`|SP, #`signed_expression`]!  // X`n`|SP has the usual meaning. \n```", "```\nbVar:  .byte 0, 1, 2, 3 \n         . \n         . \n         . \n        lea  x0, bVar-1  // Initialize with adrs of bVar – 1\\. \n        mov  x1, 4 \nloop:   ldrb w2, [x0, #1]! \n\n `Do something with the byte in W2.` \n\n        subs x1, x1, #1 \n        bne  loop \n```", "```\n[X`n`|SP], #`signed_expression` // X`n`|SP has the usual meaning. \n```", "```\nbVar:  .byte 0, 1, 2, 3 \n         . \n         . \n         . \n        lea  x0, bVar \n        mov  x1, 4 \nloop:   ldrb w2, [x0], #1 \n\n `Do something with the byte in W2.` \n\n        subs x1, x1, #1 \n        bne  loop \n```", "```\n[X`n`|SP, X`i`] \n[X`n`|SP, W`i`, `extend`] \n[X`n`|SP, X`i`, `extend`] \n```", "```\n[X`n`, W`i`, `extend`] \n```", "```\n[X`n`|SP, W`i`, uxtw] \n[X`n`|SP, W`i`, sxtw] \n```", "```\nldrb  W`d`, [X`n`|SP, W`i`, sxtw #0]  // #0 is optional; \nldrb  W`d`, [X`n`|SP, W`i`, uxtw #0]  // 0 is default shift. \nldrb  W`d`, [X`n`|SP, X`i`, lsl #0] \n\nldrsb W`d`, [X`n`|SP, W`i`, sxtw #0] \nldrsb W`d`, [X`n`|SP, W`i`, uxtw #0] \nldrsb W`d`, [X`n`|SP, X`i`, lsl #0] \n\nstrb  W`s`, [X`n`|SP, W`i`, sxtw #0] \nstrb  W`s`, [X`n`|SP, W`i`, uxtw #0] \nstrb  W`s`, [X`n`|SP, X`i`, lsl #0] \n```", "```\nldrb  W`d`, [X`n`|SP, W`i`, sxtw] \nldrb  W`d`, [X`n`|SP, W`i`, uxtw] \nldrb  W`d`, [X`n`|SP, X`i`] \n\nldrsb W`d`, [X`n`|SP, W`i`, sxtw] \nldrsb W`d`, [X`n`|SP, W`i`, uxtw] \nldrsb W`d`, [X`n`|SP, X`i`] \n\nstrb  W`s`, [X`n`|SP, W`i`, sxtw] \nstrb  W`s`, [X`n`|SP, W`i`, uxtw] \nstrb  W`s`, [X`n`|SP, X`i`] \n```", "```\nldrh  W`d`, [X`n`|SP, W`i`, sxtw #1]  // #0 is also legal, or \nldrh  W`d`, [X`n`|SP, W`i`, uxtw #1]  // no immediate value (which \nldrh  W`d`, [X`n`|SP, X`i`, lsl #1]   // defaults to 0). \n\nldrsh W`d`, [X`n`|SP, W`i`, sxtw #1] \nldrsh W`d`, [X`n`|SP, W`i`, uxtw #1] \nldrsh W`d`, [X`n`|SP, X`i`, lsl #1] \n\nstrh  W`s`, [X`n`|SP, W`i`, sxtw #1] \nstrh  W`s`, [X`n`|SP, W`i`, uxtw #1] \nstrh  W`s`, [X`n`|SP, X`i`, lsl #1] \n```", "```\nldr  W`d`, [X`n`|SP, W`i`, sxtw #2]  // #0 is also legal, or \nldr  W`d`, [X`n`|SP, W`i`, uxtw #2]  // no immediate value (which \nldr  W`d`, [X`n`|SP, X`i`, lsl #2]   // defaults to 0). \n\nstr  W`s`, [X`n`|SP, W`i`, sxtw #2] \nstr  W`s`, [X`n`|SP, W`i`, uxtw #2] \nstr  W`s`, [X`n`|SP, X`i`, lsl #2] \n```", "```\nldr  X`d`, [X`n`|SP, W`i`, sxtw #3]  // #0 is also legal, or \nldr  X`d`, [X`n`|SP, W`i`, uxtw #3]  // no immediate value (which \nldr  X`d`, [X`n`|SP, X`i`, lsl #3]   // defaults to 0). \n\nstr  X`s`, [X`n`|SP, W`i`, sxtw #3] \nstr  X`s`, [X`n`|SP, W`i`, uxtw #3] \nstr  X`s`, [X`n`|SP, X`i`, lsl #3] \n```", "```\n`varName` + `offset`\n```", "```\nldr w0, i + 4\n```", "```\nldr w0, X + 2*4\n```", "```\n2 × 4\n```", "```\n// Listing3-1.S\n//\n// Demonstrates address expressions\n\n#include \"aoaa.inc\"\n\n            .data\nsaveLR:     .dword      0\noutputVal:  .word       0\n\nttlStr:     .asciz      \"Listing 3-1\"\nfmtStr1:    .asciz      \"i[0]=%d \"\nfmtStr2:    .asciz      \"i[1]=%d \"\nfmtStr3:    .asciz      \"i[2]=%d \"\nfmtStr4:    .asciz      \"i[3]=%d\\n\"\n\n            .text\n            .extern     printf\n\n            .align      2\ni:          .word       0, 1, 2, 3\n\n// Return program title to C++ program:\n\n            .global     getTitle\ngetTitle:\n            lea         x0, ttlStr\n            ret\n\n// Here is the asmMain function:\n\n            .global     asmMain\nasmMain:\n\n// \"Magic\" instruction offered without\n// explanation at this point:\n\n            sub     sp, sp, #256\n\n// Save LR so we can return to the C++\n// program later:\n\n            lea     x0, saveLR\n            str     lr, [x0]\n\n// Demonstrate the use of address expressions:\n\n            lea     x0, fmtStr1\n          ❶ ldr     w1, i + 0\n            lea     x2, outputVal\n            str     w1, [x2]\n            vparm2  outputVal\n            bl      printf\n\n            lea     x0, fmtStr2\n          ❷ ldr     w1, i + 4\n            lea     x2, outputVal\n            str     w1, [x2]\n            vparm2  outputVal\n            bl      printf\n\n            lea     x0, fmtStr3\n          ❸ ldr     w1, i + 8\n            lea     x2, outputVal\n            str     w1, [x2]\n            vparm2  outputVal\n            bl      printf\n\n            lea     x0, fmtStr4\n          ❹ ldr     w1, i + 12\n            lea     x2, outputVal\n            str     w1, [x2]\n            vparm2  outputVal\n            bl      printf\n\n            lea     x0, saveLR\n            ldr     lr, [x0]\n            add     sp, sp, #256\n            ret\n```", "```\n$ ./build Listing3-1\n$ ./Listing3-1\nCalling Listing3-1:\ni[0]=0 i[1]=1 i[2]=2 i[3]=3\nListing3-1 terminated\n```", "```\nadr  X`d`, `label`\n```", "```\nadrp X`d`, `label`\n```", "```\nadrp X`d`, `label`\nadd  X`d`, X`d`, `page_offset_of_label`\n```", "```\nadrp x0, `label`\nadd  x0, x0, :lo12:`label`\n```", "```\nadrp x0, `label`@PAGE\nadd  x0, x0, `label`@PAGEOFF\n```", "```\nldp  X`d`1, X`d`2, `mem`  // `mem` is any addressing mode\nldp  W`d`1, W`d`2, `mem`  // except PC-relative.\n```", "```\nstp  X`d`1, X`d`2, `mem`  // Store X`d`1 to mem, X`d`2 to mem + 8.\nstp  W`d`1, W`d`2, `mem`  // Store W`d`1 to mem, W`d`2 to mem + 4.\n                   // `mem` is any addressing mode except\n                   // PC-relative.\n```", "```\nstr X`s`, [sp, #-16]! \n```", "```\nSP := SP - 16 \n[SP] := X`s` \n```", "```\nstr x0, [sp, #-16]! \n```", "```\nldr X`d`, [sp], #16 \n```", "```\nstp  x0, x7, [sp, #-16]!\n .\n .   // Use X0 and X7 for other purposes.\n .\nldp  x0, x7, [sp], #16  // Restore X0 and X7.\n```", "```\nsub  sp, sp, #16   // Make room for X0 and X7.\nstp  x0, x7, [sp]\n .\n .   // Use X0 and X7 for other purposes.\n .\nldp  x0, x7, [sp]\nadd  sp, sp, #16\n```", "```\n`Some instructions that use the X20 register.`\n\n`Some instructions that need to use X20, for a`\n`different purpose than the above instructions.`\n\n`Some instructions that need the original value in X20.`\n```", "```\n`Some instructions that use the X20 register.`\n\n     str x20, [sp, #-16]!\n\n`Some instructions that need to use X20, for a`\n`different purpose than the above instructions.`\n\n ldr x20, [sp], #16\n\n`Some instructions that need the original value in X20.`\n```", "```\nlea  x0, saveLR\nstr  lr, [x0]\n .\n .\n .\nlea  x0, saveLR\nldr  lr, [x0]\nret\n```", "```\nstr  lr, [sp, #-16]!\n .\n .\n .\nldr  lr, [sp], #16\nret\n```", "```\nstr  x0, [sp, #-16]!\nstr  x1, [sp, #-16]!\n   `Code that uses X0 and X1 goes here.`\nldr  x0, [sp], #16\nldr  x1, [sp], #16\n```", "```\nstr  x0, [sp, #-16]!\nstr  x1, [sp, #-16]!\n   `Code that uses X0 and X1 goes here.`\nldr  x1, [sp], #16\nldr  x0, [sp], #16\n```", "```\nstr  x0, [sp, #-16]!  // Push X0\\. \nstr  x1, [sp, #-16]!  // Push X1\\. \n\n`Some code that winds up computing some values we want` \n`to keep in X0 and X1.` \n\nif(`Calculation_was_performed`) then \n\n      // Whoops, we don't want to pop X0 and X1! \n      // What to do here? \n\nelse \n\n      // No calculation, so restore X1, X0\\. \n\n      ldr  x1, [sp], #16 \n      ldr  x0, [sp], #16 \n\nendif; \n```", "```\nstr  x0, [sp, #-16]!  // Push X0 \nstr  x1, [sp, #-16]!  // Push X1 \n\n`Some code that winds up computing some values we want to keep` \n`into rax and rbx.` \n\nif(`Calculation_was_performed`) then \n\n     // Remove unneeded X0/X1 values \n     // from the stack. \n\n     add  sp, sp, #32 \n\nelse \n\n     // No calculation, so restore X1, X0\\. \n\n ldr  x1, [sp], #16 \n     ldr  x0, [sp], #16 \n\nendif; \n```", "```\nstp  x0, x1, [sp, #-16]!  // Push X0 and X1\\. \n```", "```\nldr  x1, [sp, #8] \n```", "```\nstp  x0, x1, [sp, #-16]! \n\n`Some code that winds up computing some values we want` \n`to keep into X0 and X1.` \n\nif(Calculation_was_performed) then \n\n     // Overwrite saved values on the stack with \n     // new X0/X1 values (so the pops that \n     // follow won't change the values in X0/X1). \n\n     stp  x0, x1, [sp] \n\nendif; \nldp  x0, x1, [sp], #16 \n```"]