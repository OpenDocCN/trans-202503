<html><head></head><body>
<h2 class="h2c" id="ch06"><span epub:type="pagebreak" id="page_119"/><span class="big1"><strong>6</strong></span><br/><strong>READING FROM AND WRITING TO GAME MEMORY</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">Earlier chapters discussed how memory is structured as well as how to scan and modify memory using Cheat Engine and OllyDbg. Working with memory will be essential when you begin to write bots, and your code will need to know how to do so.</p>&#13;
<p class="indent">This chapter digs into the code-level details of memory manipulation. First, you’ll learn how to use code to locate and obtain handles to game processes. Next, you’ll learn how to use those handles to read from and write to memory both from remote processes and from injected code. To wrap up, you’ll learn bypasses for a certain memory protection technique, complete with a small example of code injection. You’ll find the example code for this chapter in the <em>GameHackingExamples/Chapter6_AccessingMemory</em> directory in this book’s source files.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>When I talk about API functions in this chapter (and in later ones), I’m referring to the Windows API unless otherwise specified. If I don’t mention a header file for the library, you can assume it is</em> Windows.h.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec120"><span epub:type="pagebreak" id="page_120"/><strong>Obtaining the Game’s Process Identifier</strong></h3>&#13;
<p class="noindent">To read from or write to a game’s memory, you need its <em>process identifier (PID)</em>, a number that uniquely identifies an active process. If the game has a visible window, you can obtain the PID of the process that created that window by calling <span class="literal">GetWindowThreadProcessId()</span>. This function takes the window’s handle as the first parameter and outputs the PID to the second parameter. You can find the window’s handle by passing its title (the text on the taskbar) as the second parameter to <span class="literal">FindWindow()</span>, as shown in <a href="ch06.xhtml#ch6exe1">Listing 6-1</a>.</p>&#13;
<p class="programs">HWND myWindow =<br/>    FindWindow(NULL, "<span class="codeitalic">Title of the game window here</span>");<br/>DWORD PID;<br/>GetWindowThreadProcessId(myWindow, &amp;PID);</p>&#13;
<p class="listt"><a id="ch6exe1"/><em>Listing 6-1: Fetching a window’s handle to obtain a PID</em></p>&#13;
<p class="indent">With the window handle secured, all you have to do is create a place to store the PID and call <span class="literal">GetWindowThreadProcessId()</span>, as shown in this example.</p>&#13;
<p class="indent">If a game isn’t windowed or the window name isn’t predictable, you can find the game’s PID by enumerating all processes and looking for the name of the game binary. <a href="ch06.xhtml#ch6exe2">Listing 6-2</a> does this using the API functions <span class="literal">CreateToolhelp32Snapshot()</span>, <span class="literal">Process32First()</span>, and <span class="literal">Process32Next()</span> from <em>tlhelp32.h.</em></p>&#13;
<p class="programs">#include &lt;tlhelp32.h&gt;<br/><br/>PROCESSENTRY32 entry;<br/>entry.dwSize = sizeof(PROCESSENTRY32); <br/>HANDLE snapshot =<br/>    CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);<br/>if (Process32First(snapshot, &amp;entry) == TRUE) {<br/>    while (Process32Next(snapshot, &amp;entry) == TRUE) {<br/>        wstring binPath = entry.szExeFile;<br/>        if (binPath.find(L"game.exe") != wstring::npos) {<br/>            printf("game pid is %d\n", entry.th32ProcessID);<br/>            break;<br/>        }<br/>    }<br/>} <br/>CloseHandle(snapshot);</p>&#13;
<p class="listt"><a id="ch6exe2"/><em>Listing 6-2: Fetching a game’s PID without the window name</em></p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6exe2">Listing 6-2</a> might look a bit more complex than <a href="ch06.xhtml#ch6exe1">Listing 6-1</a>, but underneath all that code, the function is actually like a canonical <span class="literal">for (<span class="codeitalic">iterator</span>; <span class="codeitalic">comparator</span>; <span class="codeitalic">increment</span>)</span> loop. The <span class="literal">CreateToolhelp32Snapshot()</span> function obtains a list of processes named <span class="literal">snapshot</span>, and <span class="literal">entry</span> is an <em>iterator</em> over that list. The value returned by <span class="literal">Process32First()</span> initializes the iterator, while <span class="literal">Process32Next()</span> <em>increments</em> it. Finally, the Boolean return value of <span epub:type="pagebreak" id="page_121"/><span class="literal">Process32Next()</span> is the <em>comparator</em>. This code just iterates over a snapshot of every running process, looks for one whose binary path contains the text <em>game.exe</em>, and prints its PID.</p>&#13;
<h4 class="h4" id="ch00lev1sec121"><strong><em>Obtaining Process Handles</em></strong></h4>&#13;
<p class="noindent">Once you know a game’s PID, you can obtain a handle to the process itself using an API function called <span class="literal">OpenProcess()</span>. This function allows you to fetch handles with the access levels you need to read from and write to memory. This is crucial to game hacking, as any function that operates on a process will require a handle with proper access.</p>&#13;
<p class="indent">Let’s take a look at the prototype of <span class="literal">OpenProcess()</span>:</p>&#13;
<p class="programs">HANDLE OpenProcess(DWORD DesiredAccess, BOOL InheritHandle, DWORD ProcessId);</p>&#13;
<p class="indent">The first parameter, <span class="literal">DesiredAccess</span>, expects one or a mixture of process access flags to set on the handle that <span class="literal">OpenProcess()</span> returns. There are many flags you can use, but these are the most common in game hacking:</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">PROCESS_VM_OPERATION</span></span> The returned handle can be used with <span class="literal">VirtualAllocEx()</span>, <span class="literal">VirtualFreeEx()</span>, and <span class="literal">VirtualProtectEx()</span> to allocate, free, and protect chunks of memory, respectively.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">PROCESS_VM_READ</span></span> The returned handle can be used with <span class="literal">ReadProcessMemory()</span>.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">PROCESS_VM_WRITE</span></span> The returned handle can be used with <span class="literal">WriteProcessMemory()</span>, but it must also have <span class="literal">PROCESS_VM_OPERATION</span> rights. You can set both flags by passing <span class="literal">PROCESS_VM_OPERATION | PROCESS_VM_WRITE</span> as the <span class="literal">DesiredAccess</span> parameter.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">PROCESS_CREATE_THREAD</span></span> The returned handle can be used with <span class="literal">CreateRemoteThread()</span>.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">PROCESS_ALL_ACCESS</span></span> The returned handle can be used to do anything. Avoid using this flag, as it can only be used by processes with debug privileges enabled and has compatibility issues with older versions of Windows.</p>&#13;
<p class="indentt">When fetching a handle to a game, you can typically just set the <span class="literal">OpenProcess()</span> function’s second parameter, <span class="literal">InheritHandle</span>, to <span class="literal">false</span>. The third parameter, <span class="literal">ProcessId</span>, expects the PID of the process to be opened.</p>&#13;
<h4 class="h4" id="ch00lev1sec122"><strong><em>Working with OpenProcess()</em></strong></h4>&#13;
<p class="noindent">Now let’s walk through an example call to <span class="literal">OpenProcess()</span> that uses a handle with access permissions allowing it to read from and write to memory:</p>&#13;
<p class="programs">   DWORD PID = getGamePID();<br/>   HANDLE process = OpenProcess(<br/>       PROCESS_VM_OPERATION |<br/>           PROCESS_VM_READ |<br/>           PROCESS_VM_WRITE,<br/><span epub:type="pagebreak" id="page_122"/><br/>       FALSE,<br/>       PID <br/>   );<br/><span class="ent">➊</span> if (process == INVALID_HANDLE_VALUE) {<br/>      printf("Failed to open PID %d, error code %d",<br/>             PID, GetLastError());<br/>   }</p>&#13;
<p class="indent">First, the call to <span class="literal">getGamePID()</span> fetches the PID you’re looking for. (The function is something you’ll have to write yourself, though it could just be one of the snippets I showed in <a href="ch06.xhtml#ch6exe1">Listings 6-1</a> and <a href="ch06.xhtml#ch6exe2">6-2</a>, fleshed out into a fullblown function.) Then, the code calls <span class="literal">OpenProcess()</span> with three flags: the <span class="literal">PROCESS_VM_OPERATION</span> flag gives this handle memory access permissions, and the other two combined give it read and write permissions. This example also contains an error-handling case <span class="ent">➊</span>, but as long as you have the correct PID, you have valid access flags, and your code is running under the same or higher permissions as the game (for example, if you start your bot using Run As Admin), the call should never fail.</p>&#13;
<p class="indent">Once you’re done using a handle, clean it up using <span class="literal">CloseHandle()</span> as follows:</p>&#13;
<p class="programs">CloseHandle(process);</p>&#13;
<p class="indent">You can reuse handles as much as you want, so you can leave one open until you’re completely done using it or until your bot is exited.</p>&#13;
<p class="indent">Now that you’ve seen how to open a process handle in preparation for manipulating game memory, let’s dig into how to actually access the memory of that process.</p>&#13;
<h3 class="h3" id="ch00lev1sec123"><strong>Accessing Memory</strong></h3>&#13;
<p class="noindent">The Windows API exposes two functions that are crucial to memory access: <span class="literal">ReadProcessMemory()</span> and <span class="literal">WriteProcessMemory()</span>. You can use these functions to externally manipulate a game’s memory.</p>&#13;
<h4 class="h4" id="ch00lev1sec124"><strong><em>Working with ReadProcessMemory() and WriteProcessMemory()</em></strong></h4>&#13;
<p class="noindent">The prototypes for these two functions (shown in <a href="ch06.xhtml#ch6exe3">Listing 6-3</a>) resemble each other closely, and you’ll follow almost exactly the same steps to use them.</p>&#13;
<p class="programs">BOOL ReadProcessMemory(<br/>    HANDLE Process, LPVOID Address,<br/>    LPVOID Buffer, DWORD Size,<br/>    DWORD *NumberOfBytesRead <br/>);<br/>BOOL WriteProcessMemory(<br/>    HANDLE Process, LPVOID Address,<br/>    LPCVOID Buffer, DWORD Size,<br/><span epub:type="pagebreak" id="page_123"/><br/>    DWORD *NumberOfBytesWritten <br/>);</p>&#13;
<p class="listt"><a id="ch6exe3"/><em>Listing 6-3:</em> <span class="literal"><span class="codeitalic">ReadProcessMemory()</span></span> <em>and</em> <span class="literal"><span class="codeitalic">WriteProcessMemory()</span></span> <em>prototypes</em></p>&#13;
<p class="indent">Both functions expect <span class="literal">Process</span> to be a process handle and <span class="literal">Address</span> to be the target memory address. When the function is reading from memory, <span class="literal">Buffer</span> is expected to point to an object that will hold the read data. When the function is writing to memory, <span class="literal">Buffer</span> is expected to point to the data to write. In both cases, <span class="literal">Size</span> defines the size of <span class="literal">Buffer</span>, in bytes. The final parameter to both functions is used to optionally return the number of bytes that were accessed; you can safely set it to <span class="literal">NULL</span>. Unless the function fails, the value returned in the final parameter should be equal to <span class="literal">Size</span>.</p>&#13;
<h4 class="h4" id="ch00lev1sec125"><strong><em>Accessing a Value in Memory with ReadProcessMemory() and WriteProcessMemory()</em></strong></h4>&#13;
<p class="noindent">The code in <a href="ch06.xhtml#ch6exe4">Listing 6-4</a> shows how you might use these functions to access a value in memory.</p>&#13;
<p class="programs">DWORD val;<br/>ReadProcessMemory(proc, adr, &amp;val, sizeof(DWORD), 0);<br/>printf("Current mem value is %d\n", val);<br/><br/>val++;<br/><br/>WriteProcessMemory(proc, adr, &amp;val, sizeof(DWORD), 0);<br/>ReadProcessMemory(proc, adr, &amp;val, sizeof(DWORD), 0);<br/>printf("New mem value is confirmed as %d\n", val);</p>&#13;
<p class="listt"><a id="ch6exe4"/><em>Listing 6-4: Reading from and writing to process memory using the Windows API</em></p>&#13;
<p class="indent">Before code like this appears in a program, you need to find the PID (<span class="literal">proc</span>) as described in “<a href="ch06.xhtml#ch00lev1sec120">Obtaining the Game’s Process Identifier</a>” on <a href="ch06.xhtml#page_120">page 120</a>, as well as the memory address (<span class="literal">adr</span>) you want to read from or write to. With those values in place, the <span class="literal">ReadProcessMemory()</span> function stores a fetched value from memory in <span class="literal">val</span>. Then, the code increments <span class="literal">val</span> and replaces the original value by calling <span class="literal">WriteProcessMemory()</span>. After the write takes place, <span class="literal">ReadProcessMemory()</span> is called on the same address to confirm the new memory value. Notice that <span class="literal">val</span> isn’t actually a buffer. Passing <span class="literal">&amp;val</span> as the <span class="literal">Buffer</span> parameter works because it can be a pointer to any static memory structure, as long as <span class="literal">Size</span> matches.</p>&#13;
<h4 class="h4" id="ch00lev1sec126"><strong><em>Writing Templated Memory Access Functions</em></strong></h4>&#13;
<p class="noindent">Of course, the example in <a href="ch06.xhtml#ch6exe4">Listing 6-4</a> assumes you already know what type of memory you’re dealing with, and it hardcodes the type as <span class="literal">DWORD</span>. To be a versatile game hacker, it’s better to have some generic code in your toolbox to avoid duplicating code for different types. Generic memory reading and writing functions that support different types might look like <a href="ch06.xhtml#ch6exe5">Listing 6-5</a>.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_124"/><br/>template&lt;typename T&gt;<br/>T readMemory(HANDLE proc, LPVOID adr) {<br/>    T val;<br/>    ReadProcessMemory(proc, adr, &amp;val, sizeof(T), NULL);<br/>    return val;<br/>}<br/><br/>template&lt;typename T&gt;<br/>void writeMemory(HANDLE proc, LPVOID adr, T val) {<br/>    WriteProcessMemory(proc, adr, &amp;val, sizeof(T), NULL);<br/>}</p>&#13;
<p class="listt"><a id="ch6exe5"/><em>Listing 6-5: Generic memory functions</em></p>&#13;
<p class="indent">These functions use C++ templates to accept arbitrary types as arguments. They allow you to access memory with whatever types you like in a very clean way. For example, given these <span class="literal">readMemory()</span> and <span class="literal">writeMemory()</span> templates I just showed, you could make the calls in <a href="ch06.xhtml#ch6exe6">Listing 6-6</a>.</p>&#13;
<p class="programs">DWORD value = readMemory&lt;DWORD&gt;(proc, adr); // read<br/>writeMemory&lt;DWORD&gt;(proc, adr, value++);     // increment and write</p>&#13;
<p class="listt"><a id="ch6exe6"/><em>Listing 6-6: Calling templated memory access functions</em></p>&#13;
<p class="indent">Compare this to the calls to <span class="literal">WriteProcessMemory()</span> and <span class="literal">ReadProcessMemory()</span> in <a href="ch06.xhtml#ch6exe4">Listing 6-4</a>. This code still reads a value, increments it, and writes the new value to memory. But since the templated functions let you specify the type when you call them, you don’t need a new <span class="literal">readMemory()</span> and <span class="literal">writeMemory()</span> function for every data type you might need to work with. That’s much cleaner, since you’ll often want to work with all kinds of data.</p>&#13;
<h3 class="h3" id="ch00lev1sec127"><strong>Memory Protection</strong></h3>&#13;
<p class="noindent">When memory is allocated by a game (or any program), it is placed in a <em>page</em>. In x86 Windows, pages are chunks of 4,096 bytes that store data. Because all memory must be within a page, the minimal allocation unit is 4,096 bytes. The operating system can place memory chunks smaller than 4,096 bytes as a subset of an existing page that has enough uncommitted space, in a newly allocated page, or across two contiguous pages that have the same attributes.</p>&#13;
<p class="indent">Memory chunks 4,096 bytes or larger span <em>n</em> pages, where <em>n</em> is</p>&#13;
<div class="image"><img src="../images/f0124-01.jpg" alt="image"/></div>&#13;
<p class="indent">The operating system typically looks for room in existing pages when allocating memory, but it allocates new pages on demand if necessary.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It’s also possible for large chunks to span</em> n <em>+ 1 pages, as there’s no guarantee that a chunk begins at the start of a page.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>The important thing to understand about memory pages is that each page has a set of specific attributes. Most of these attributes are transparent in user mode, but there’s one you should be extra conscious of when working with memory: protection.</p>&#13;
<h4 class="h4" id="ch00lev1sec128"><strong><em>Differentiating x86 Windows Memory Protection Attributes</em></strong></h4>&#13;
<p class="noindent">The memory-reading techniques you’ve learned so far are very basic. They assume that the memory you’re accessing is protected with the <span class="literal">PAGE_READWRITE</span> attribute. While this assumption is correct for variable data, other types of data exist on pages with different types of protection. <a href="ch06.xhtml#ch6tab1">Table 6-1</a> describes the different types of memory protection in x86 Windows.</p>&#13;
<p class="tablecap"><a id="ch6tab1"/><strong>Table 6-1:</strong> Memory Protection Types</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Protection type</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Read permission?</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Write permission?</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Execute permission?</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Special permissions?</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PAGE_NOACCESS</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x01</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">PAGE_READONLY</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x02</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PAGE_READWRITE</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x04</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">PAGE_WRITECOPY</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x08</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes, copy on write</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PAGE_EXECUTE</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x10</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">PAGE_EXECUTE_READ</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PAGE_EXECUTE_READWRITE</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x40</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">PAGE_EXECUTE_WRITECOPY</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x80</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Yes, copy on write</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PAGE_GUARD</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x100</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Yes, guard page</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">If a protection type in <a href="ch06.xhtml#ch6tab1">Table 6-1</a> has a <em>Yes</em> in any permission column, it means the action in question can be performed on that page of memory. For example, if a page is <span class="literal">PAGE_READONLY</span>, then a program can read the memory on that page, but the program cannot write to that memory.</p>&#13;
<p class="indent">Constant strings, for example, are usually stored with <span class="literal">PAGE_READONLY</span> protection. Other constant data, such as virtual function tables and a module’s entire <em>Portable Executable (PE)</em> header (which contains information about a program, such as the kind of application it is, library functions it uses, its size, and so on), are also stored on read-only pages. Assembly code, on the other hand, is stored on pages protected with <span class="literal">PAGE_EXECUTE_READ</span>.</p>&#13;
<p class="indent">Most protection types involve only some combination of read, write, and execute protection. For now, you can safely ignore special protection types; I cover them in “Special Protection Types” on <a href="ch06.xhtml#page_126">page 126</a> if you’re curious, but only very advanced hacks will ever require knowledge of them. The basic protection types, though, will be prevalent in your game-hacking adventures.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_126"/><strong>SPECIAL PROTECTION TYPES</strong></p>&#13;
<p class="noindent">Two protection types in <a href="ch06.xhtml#ch6tab1">Table 6-1</a> include <em>copy-on-write</em> protection. When multiple processes have pages of memory that are identical (such as pages with mapped system DLLs), copy-on-write protection is used to conserve memory. The actual data is stored in only one physical place, and the operating system virtually maps all memory pages containing that data to the physical location. If a process sharing the memory makes a change to it, a copy of the data will be made in physical memory, the change will be applied, and the memory page(s) for that process will be remapped to the new physical memory. When a copy on write happens, the protection for all affected pages changes accordingly; <span class="literal">PAGE_WRITECOPY</span> will become <span class="literal">PAGE_READWRITE</span>, and <span class="literal">PAGE_EXECUTE_WRITECOPY</span> will become <span class="literal">PAGE_EXECUTE_READWRITE</span>. I’ve found no game hacking–specific uses for copy-on-write pages, but it’s useful to understand them.</p>&#13;
<p class="indent">Pages can also be created with <em>guard</em> protection. Guarded pages must have a secondary protection, defined like <span class="literal">PAGE_GUARD | PAGE_READONLY</span>. When the program tries to access a guarded page, the operating system will throw a <span class="literal">STATUS_GUARD_PAGE_VIOLATION</span> exception. Once the exception is handled, the guard protection is removed from the page, leaving only the secondary protection. One way in which the operating system uses this type of protection is to dynamically expand the call stack by placing a guarded page at the top and allocating more memory when that guarded page is hit. Some memory analysis tools place guarded pages after heap memory to detect heap corruption bugs. In the context of game hacking, a guarded page can be used as a trip wire that tells you when a game might be attempting to detect your code within its memory.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec129"><strong><em>Changing Memory Protection</em></strong></h4>&#13;
<p class="noindent">When you want to hack a game, you’ll sometimes need to access memory in a way that is forbidden by the memory page’s protection, making it important to be able to change memory protection at will. Luckily, the Windows API provides the <span class="literal">VirtualProtectEx()</span> function for this purpose. This is the function’s prototype:</p>&#13;
<p class="programs">BOOL VirtualProtectEx(<br/>    HANDLE Process, LPVOID Address,<br/>    DWORD Size, DWORD NewProtect,<br/>    PDWORD OldProtect <br/>);</p>&#13;
<p class="indent">The parameters <span class="literal">Process</span>, <span class="literal">Address</span>, and <span class="literal">Size</span> take the same input as they do in the <span class="literal">ReadProcessMemory()</span> and <span class="literal">WriteProcessMemory()</span> functions. <span class="literal">NewProtect</span> should specify the new protection flags for the memory, and <span class="literal">OldProtect</span> can optionally point to a <span class="literal">DWORD</span> where the old protection flags will be stored.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_127"/>The most granular scale for memory protection is per page, which means <span class="literal">VirtualProtectEx()</span> will set the new protection to every page that is on or between <span class="literal">Address</span> and <span class="literal">Address + Size - 1</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The</em> <span class="literal"><span class="codeitalic">VirtualProtectEx()</span></span> <em>function has a sister called</em> <span class="literal"><span class="codeitalic">VirtualProtect()</span></span><em>. They work the same way, but</em> <span class="literal"><span class="codeitalic">VirtualProtect()</span></span> <em>operates only on the process calling it and, thus, does not have a process handle parameter.</em></p>&#13;
</div>&#13;
<p class="indent">When you’re writing your own code to change memory protections, I suggest making it flexible by creating a template. A generic wrapped function for <span class="literal">VirtualProtectEx()</span> should look something like <a href="ch06.xhtml#ch6exe7">Listing 6-7</a>.</p>&#13;
<p class="programs">template&lt;typename T&gt;<br/>DWORD protectMemory(HANDLE proc, LPVOID adr, DWORD prot) {<br/>    DWORD oldProt;<br/>    VirtualProtectEx(proc, adr, sizeof(T), prot, &amp;oldProt);<br/>    return oldProt;<br/>}</p>&#13;
<p class="listt"><a id="ch6exe7"/><em>Listing 6-7: A generic function to change memory protection</em></p>&#13;
<p class="indent">With this template in place, if you wanted to, say, write a <span class="literal">DWORD</span> to a memory page without write permission, you might do something like this:</p>&#13;
<p class="programs">protectMemory&lt;DWORD&gt;(process, address, PAGE_READWRITE)<br/>writeMemory&lt;DWORD&gt;(process, address, newValue)</p>&#13;
<p class="indent">First, this sets the protection on the memory to change to <span class="literal">PAGE_READWRITE</span>. With write permission granted, the door is open to call <span class="literal">writeMemory()</span> and change the data at <span class="literal">address</span>.</p>&#13;
<p class="indent">When you’re changing memory protection, it’s best practice to let the change persist only as long as needed and restore the original protection as soon as possible. This is less efficient, but it ensures that a game doesn’t detect your bot (for example, by noticing that some of its assembly code pages have become writable).</p>&#13;
<p class="indent">A typical write operation on read-only memory should look like this:</p>&#13;
<p class="programs">DWORD oldProt =<br/>    protectMemory&lt;DWORD&gt;(process, address, PAGE_READWRITE);<br/>writeMemory&lt;DWORD&gt;(process, address, newValue);<br/>protectMemory&lt;DWORD&gt;(process, address, oldProt);</p>&#13;
<p class="indent">This code calls the <span class="literal">protectMemory()</span> function from <a href="ch06.xhtml#ch6exe7">Listing 6-7</a> to change the protection to <span class="literal">PAGE_READWRITE</span>. It then writes <span class="literal">newValue</span> to the memory before changing the protection back to <span class="literal">oldProt</span>, which was set to the page’s original protection by the initial call to <span class="literal">protectMemory()</span>. The <span class="literal">writeMemory()</span> function used here is the same one defined in <a href="ch06.xhtml#ch6exe5">Listing 6-5</a>.</p>&#13;
<p class="indent">A final important point is that when you’re manipulating a game’s memory, it’s entirely possible that the game will access the memory at the same time as you. If the new protection that you set is not compatible <span epub:type="pagebreak" id="page_128"/>with the original protection, the game process will get an <span class="literal">ACCESS_VIOLATION</span> exception and crash. For instance, if you change memory protection from <span class="literal">PAGE_EXECUTE</span> to <span class="literal">PAGE_READWRITE</span>, the game might try to execute the code on the page(s) when the memory is not marked as executable. In this case, you’d want to instead set the memory protection to <span class="literal">PAGE_EXECUTE_READWRITE</span> to ensure that you can operate on the memory while still allowing the game to execute it.</p>&#13;
<h3 class="h3" id="ch00lev1sec130"><strong>Address Space Layout Randomization</strong></h3>&#13;
<p class="noindent">So far, I’ve described memory addresses as static integers that change only as the binary changes. This model is correct on Windows XP and earlier. On later Windows systems, however, memory addresses are only static relative to the base address of the game binary, because these systems enable a feature called <em>address space layout randomization (ASLR)</em> for supported binaries. When a binary is compiled with ASLR support (enabled by default on MSVC++ 2010 and many other compilers), its base address can be different every time it is run. Conversely, non-ASLR binaries will always have a base address of 0x400000.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Since ASLR doesn’t work on XP, I’ll call 0x400000 the</em> XP-base.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec131"><strong><em>Disabling ASLR to Simplify Bot Development</em></strong></h4>&#13;
<p class="noindent">To keep development simple, you can disable ASLR and use addresses with the transparent XP-base. To do so, enter a single command in the Visual Studio Command Prompt:</p>&#13;
<p class="programs">&gt; <span class="codestrong">editbin /DYNAMICBASE:NO "</span><span class="codeitalic"><span class="codestrong">C:\path\to\game.exe</span></span><span class="codestrong">"</span></p>&#13;
<p class="indent">To re-enable it, enter:</p>&#13;
<p class="programs">&gt; <span class="codestrong">editbin /DYNAMICBASE "</span><span class="codeitalic"><span class="codestrong">C:\path\to\game.exe</span></span><span class="codestrong">"</span></p>&#13;
<h4 class="h4" id="ch00lev1sec132"><strong><em>Bypassing ASLR in Production</em></strong></h4>&#13;
<p class="noindent">Disabling ASLR is suitable for bot development, but it is a no-no for production; end users cannot be expected to turn off ALSR. Instead, you can write a function to dynamically rebase addresses at runtime. If you use addresses with the XP-base, the code to do a rebase would look like this:</p>&#13;
<p class="programs">DWORD rebase(DWORD address, DWORD newBase) {<br/>    DWORD diff = address - 0x400000;<br/>    return diff + newBase;<br/>}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_129"/>When you know the base address of the game (<span class="literal">newBase</span>), this function allows you to essentially ignore ASLR by rebasing <span class="literal">address</span>.</p>&#13;
<p class="indent">To find <span class="literal">newBase</span>, however, you need to use the <span class="literal">GetModuleHandle()</span> function. When the parameter to <span class="literal">GetModuleHandle()</span> is <span class="literal">NULL</span>, it always returns a handle to the main binary in a process. The function’s returned type is <span class="literal">HMODULE</span>, but the value is actually just the address where the binary is mapped. This is the base address, so you can directly cast it to a <span class="literal">DWORD</span> to get <span class="literal">newBase</span>. Since you’re looking for the base address in another process, though, you need a way to execute the function in the context of that process.</p>&#13;
<p class="indent">To do this, call <span class="literal">GetModuleHandle()</span> using the <span class="literal">CreateRemoteThread()</span> API function, which can be used to spawn threads and execute code in a remote process. It has the prototype shown in <a href="ch06.xhtml#ch6exe8">Listing 6-8</a>.</p>&#13;
<p class="programs">HANDLE CreateRemoteThread(<br/>    HANDLE Process,<br/>    LPSECURITY_ATTRIBUTES ThreadAttributes,<br/>    DWORD StackSize,<br/>    LPTHREAD_START_ROUTINE StartAddress,<br/>    LPVOID Param,<br/>    DWORD CreationFlags,<br/>    LPDWORD ThreadId <br/>);</p>&#13;
<p class="listt"><a id="ch6exe8"/><em>Listing 6-8: A function that spawns a thread</em></p>&#13;
<p class="indent">The spawned thread will start execution on <span class="literal">StartAddress</span>, treating it as a single-parameter function with <span class="literal">Param</span> as input and setting the value returned as the thread exit code. This is ideal, as the thread can be started with <span class="literal">StartAddress</span> pointing to the address of <span class="literal">GetModuleHandle()</span> and <span class="literal">Param</span> set to <span class="literal">NULL</span>. You can then use the API function <span class="literal">WaitForSingleObject()</span> to wait until the thread is done executing and get the returned base address using the API function <span class="literal">GetExitCodeThread()</span>.</p>&#13;
<p class="indent">Once all of these things are tied together, the code to get <span class="literal">newBase</span> from an external bot should look like <a href="ch06.xhtml#ch6exe9">Listing 6-9</a>.</p>&#13;
<p class="programs">DWORD newBase;<br/><br/>// get the address of kernel32.dll<br/>HMODULE k32 = GetModuleHandle("kernel32.dll");<br/><br/>// get the address of GetModuleHandle()<br/>LPVOID funcAdr = GetProcAddress(k32, "GetModuleHandleA");<br/>if (!funcAdr)<br/>    funcAdr = GetProcAddress(k32, "GetModuleHandleW");<br/><br/>// create the thread<br/>HANDLE thread =<br/>    CreateRemoteThread(process, NULL, NULL,<br/>        (LPTHREAD_START_ROUTINE)funcAdr,<br/>        NULL, NULL, NULL);<br/><span epub:type="pagebreak" id="page_130"/><br/>// let the thread finish<br/>WaitForSingleObject(thread, INFINITE);<br/><br/>// get the exit code<br/>GetExitCodeThread(thread, &amp;newBase);<br/><br/>// clean up the thread handle<br/>CloseHandle(thread);</p>&#13;
<p class="listt"><a id="ch6exe9"/><em>Listing 6-9: Finding the base address of a game with API functions</em></p>&#13;
<p class="indent">The <span class="literal">GetModuleHandle()</span> function is part of <em>kernel32.dll</em>, which has the same base address in every process, so first this code gets the address for <em>kernel32.dll</em>. Since the base address of <em>kernel32.dll</em> is the same in every process, the address of <span class="literal">GetModuleHandle()</span> will be the same in the game as it is in the external bot. Given the base address of <em>kernel32.dll</em>, this code finds the address of <span class="literal">GetModuleHandle()</span> easily with the API function <span class="literal">GetProcAddress()</span>. From there, it calls the <span class="literal">CreateRemoteThread()</span> function from <a href="ch06.xhtml#ch6exe8">Listing 6-8</a>, lets the thread do its job, and fetches the exit code to obtain <span class="literal">newBase</span>.</p>&#13;
<h3 class="h3" id="ch00lev1sec133"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">Now that you’ve seen how to manipulate memory from your own code, I’ll show you how to apply the skills from Parts I and II to games. These skills are paramount to the concepts you’ll explore in the coming chapters, so make sure you have a firm grasp on what’s happening. If you’re having trouble, play with the example code as you review concepts, as it provides a safe sandbox for testing and tweaking how the methods in this and earlier chapters behave.</p>&#13;
<p class="indent">The way <a href="ch06.xhtml#ch6exe9">Listing 6-9</a> tricks the game into executing <span class="literal">GetModuleHandle()</span> is a form of code injection. But that’s just a glimpse into what injection can do. If you’re excited to learn more about it, dive into <a href="ch07.xhtml#ch07">Chapter 7</a>, which explores this topic in detail.</p>&#13;
</body></html>