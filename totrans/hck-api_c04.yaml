- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your API Hacking System
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter will walk you through setting up your API hacking toolkit. We’ll
    cover three especially useful tools for API hackers: Chrome DevTools, Burp Suite,
    and Postman.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to exploring features included in the paid Burp Suite Pro version,
    I’ll provide a list of tools that can compensate for the features missing from
    the free Burp Suite Community Edition, as well as several other tools useful for
    discovering and exploiting API vulnerabilities. At the end of this chapter, we’ll
    walk through a lab in which you’ll learn to use some of these tools to interact
    with our first APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we’ll run tools and labs using Kali, an open-source Debian-based
    distribution of Linux. Kali is built for penetration testing and comes with many
    useful tools already installed. You can download Kali at [https://www.kali.org/downloads](https://www.kali.org/downloads).
    Plenty of guides can walk you through setting up your hypervisor of choice and
    installing Kali onto it. I recommend using Null Byte’s “How to Get Started with
    Kali Linux” or the tutorial at [https://www.kali.org/docs/installation](https://www.kali.org/docs/installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'After your instance of Kali is set up, open a terminal and perform an update
    and upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install Git, Python 3, and Golang (Go), which you’ll need to use some
    of the other tools in your hacking box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With these basics installed, you should be prepared to set up the remainder
    of the API hacking tools.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Web Apps with DevTools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chrome’s DevTools is a suite of developer tools built into the Chrome browser
    that allows you to view what your web browser is running from a web developer’s
    perspective. DevTools is an often-underrated resource, but it can be very useful
    for API hackers. We’ll use it for our first interactions with target web applications
    to discover APIs; interact with web applications using the console; view headers,
    previews, and responses; and analyze web application source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Chrome, which includes DevTools, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can launch Chrome through the command line with the `google-chrome` command.
    Once you have Chrome running, navigate to the URL you want to investigate and
    launch DevTools by using either ctrl-shift-I or F12 or navigating to **Settings**▶**More
    Tools** and selecting the **Developer Tools** menu. Next, refresh your current
    page to update the information in the DevTools panels. You can do this by using
    the ctrl-R shortcut. In the Network panel, you should see the various resources
    requested from APIs (see [Figure 4-1](#figure4-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a DevTools panel populated with a list of requests that have
    200 status codes](image_fi/502444c04/F04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: The Chrome DevTools Network panel'
  prefs: []
  type: TYPE_NORMAL
- en: Switch panels by selecting the desired tab at the top. The DevTools panel lists
    the functionality of the different table options. I’ve summarized these in [Table
    4-1](#table4-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: DevTools Panels'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Panel** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Elements | Allows you to view the current page’s CSS and Document Object
    Model (DOM), which enables you to inspect the HTML that constructs the web page.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Console | Provides you with alerts and lets you interact with the JavaScript
    debugger to alter the current web page. |'
  prefs: []
  type: TYPE_TB
- en: '| Sources | Contains the directories that make up the web application and the
    content of the source files. |'
  prefs: []
  type: TYPE_TB
- en: '| Network | Lists all the source file requests that make up the client’s perspective
    of the web application. |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Provides a way to record and analyze all the events that take
    place when loading a web page. |'
  prefs: []
  type: TYPE_TB
- en: '| Memory | Lets you record and analyze how the browser is interacting with
    your system’s memory. |'
  prefs: []
  type: TYPE_TB
- en: '| Application | Provides you with the application manifest, storage items (like
    cookies and session information), cache, and background services. |'
  prefs: []
  type: TYPE_TB
- en: '| Security | Provides insight regarding the transit encryption, source content
    origins, and certificate details. |'
  prefs: []
  type: TYPE_TB
- en: When we first begin interacting with a web application, we’ll usually start
    with the Network panel to get an overview of the resources that power the web
    application. In [Figure 4-1](#figure4-1), each of the items listed represents
    a request that was made for a specific resource. Using the Network panel, you
    can drill down into each request to see the request method that was used, the
    response status code, the headers, and the response body. To do this, click the
    name of the URL of interest once under the Name column. This will open up a panel
    on the right side of the DevTools. Now you can review the request that was made
    under the Headers tab and see how the server responded under the Response tab.
  prefs: []
  type: TYPE_NORMAL
- en: Diving deeper into the web application, you can use the Sources panel to inspect
    the source files being used in the app. In capture-the-flag (CTF) events (and
    occasionally in reality) you may find API keys or other hardcoded secrets here.
    The Sources panel comes equipped with strong search functionality that will help
    you easily discover the inner workings of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Console panel is useful for running and debugging the web page’s JavaScript.
    You can use it to detect errors, view warnings, and execute commands. You will
    get an opportunity to use the Console panel in the lab in Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: We will spend the majority of our time in the Console, Sources, and Network
    panels. However, the other panels can be useful as well. For example, the Performance
    panel is mainly used to improve a website’s speed, but we could also use it to
    observe at what point a web application interacts with an API, as shown in [Figure
    4-2](#figure4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a DevTools graph on which a point is labeled “client_event.json
    (api.twitter.com).”](image_fi/502444c04/F04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: The DevTool’s Performance tab showing the exact moment the Twitter
    application interacted with the Twitter API'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 4-2](#figure4-2) we see that, 1,700 milliseconds in, a client event
    triggered the Twitter application to interact with the API. As the client, we
    would then be able to correlate that event to an action we took on the page, such
    as authenticating to the web app, to know what the web application is using the
    API for. The more information we can gather before attacking an API, the better
    our odds will be at finding and exploiting vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about DevTools, check out the Google Developers documentation
    at [https://developers.google.com/web/tools/chrome-devtools](https://developers.google.com/web/tools/chrome-devtools).
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and Modifying Requests with Burp Suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Burp Suite is a magnificent set of web application–testing tools developed and
    continuously improved on by PortSwigger. All web app cybersecurity professionals,
    bug bounty hunters, and API hackers should learn to use Burp, which allows you
    to capture API requests, spider web applications, fuzz APIs, and so much more.
  prefs: []
  type: TYPE_NORMAL
- en: '*Spidering*, or *web crawling*, is a method that bots use to automatically
    detect the URL paths and resources of a host. Typically, spidering is done by
    scanning the HTML of web pages for hyperlinks. Spidering is a good way to get
    a basic idea of the contents of a web page, but it won’t be able to find *hidden*
    paths, or the ones that do not have links found within web pages. To find hidden
    paths, we’ll need to use a tool like Kiterunner that effectively performs directory
    brute-force attacks. In such an attack, an application will request various possible
    URL paths and validate whether they actually exist based on the host’s responses.'
  prefs: []
  type: TYPE_NORMAL
- en: As described by the OWASP community page on the topic, *fuzzing* is “the art
    of automatic bug finding.” Using this attack technique, we’d send various types
    of input in HTTP requests, trying to find an input or payload that causes an application
    to respond in unexpected ways and reveal a vulnerability. For example, if you
    were attacking an API and discovered you could post data to the API provider,
    you could then attempt to send it various SQL commands. If the provider doesn’t
    sanitize this input, there is a chance you could receive a response that indicates
    that a SQL database is in use.
  prefs: []
  type: TYPE_NORMAL
- en: Burp Suite Pro, the paid edition of Burp, provides all the features without
    restrictions, but if using the free Burp Suite Community Edition (CE) is your
    only option, you can make it work. However, once you’ve obtained a bug bounty
    reward or as soon as you can convince your employer, you should make the jump
    to Burp Suite Pro. This chapter includes a “Supplemental Tools” section that will
    help replace the functionality missing in Burp Suite CE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Burp Suite CE is included standard with the latest version of Kali. If for
    whatever reason it is not installed, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we will prepare our API hacking rig to use Burp Suite,
    look at an overview of the various Burp modules, learn how to intercept HTTP requests,
    dive deeper into the Intruder module, and go over some of the sweet extensions
    you can use to enhance Burp Suite Pro.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up FoxyProxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of Burp Suite’s key features is the ability to intercept HTTP requests.
    In other words, Burp Suite receives your requests before forwarding them to the
    server and then receives the server’s responses before sending them to the browser,
    allowing you to view and interact with those requests and responses. For this
    feature to work, we’ll need to regularly send requests from the browser to Burp
    Suite. This is done with the use of a web proxy. The proxy is a way for us to
    reroute web browser traffic to Burp before it is sent to the API provider. To
    simplify this process, we’ll add a tool called FoxyProxy to our browsers to help
    us proxy traffic with a click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Web browsers have proxy functionality built in, but changing and updating these
    settings every time you want to use Burp would be a time-consuming pain. Instead,
    we’ll use a browser add-on called FoxyProxy that lets you switch your proxy on
    and off with a simple click of a button. FoxyProxy is available for both Chrome
    and Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to install FoxyProxy:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to your browser’s add-on or plug-in store and search **FoxyProxy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install FoxyProxy Standard and add it to your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the fox icon at the top-right corner of your browser (next to your URL)
    and select **Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Proxies**▶**Add New Proxy**▶**Manual Proxy Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **127.0.0.1** as the host IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the port to **8080** (Burp Suite’s default proxy settings).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the General tab, rename the proxy to **Hackz** (I will refer to this proxy
    setting throughout the labs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you’ll only need to click the browser add-on and select the proxy you want
    to use to send your traffic to Burp. When you’ve finished intercepting requests,
    you can turn the proxy off by selecting the Disable FoxyProxy option.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Burp Suite Certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*HTTP Strict Transport Security (HSTS)* is a common web application security
    policy that prevents Burp Suite from being able to intercept requests. Whether
    using Burp Suite CE or Burp Suite Pro, you will need to install Burp Suite’s certificate
    authority (CA) certificate. To add this certificate, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Burp Suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your browser of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using FoxyProxy, select the Hackz proxy. Navigate to *http://burpsuite*, as
    seen in [Figure 4-3](#figure4-3), and click **CA Certificate**. This will initiate
    the download of the Burp Suite CA certificate.![F04003](image_fi/502444c04/F04003.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4-3: The landing page you should see when downloading Burp Suite’s CA
    certificate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the certificate somewhere you can find it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your browser and import the certificate. In Firefox, open **Preferences**
    and use the search bar to look up **certificates**. Import the certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Chrome, open **Settings**, use the search bar to look up **certificates**,
    select **More**▶**Manage Certificates**▶**Authorities**, and import the certificate
    (see [Figure 4-4](#figure4-4)). If you do not see the certificate, you may need
    to expand the file type options to “DER” or “All files.”![F04004](image_fi/502444c04/F04004.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4-4: The Chrome Certificate Manager with the Authorities tab selected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have the PortSwigger CA certificate added to your browser, you
    should be able to intercept traffic without experiencing issues.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating Burp Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-5](#figure4-5), at the top of Burp are 13 modules.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of menu items including Comparer, Logger, Extender, Project options,
    User options, Learn, Dashboard, Target, Proxy, Intruder, Repeater, Sequencer,
    and Decoder](image_fi/502444c04/F04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: The Burp Suite modules'
  prefs: []
  type: TYPE_NORMAL
- en: The *Dashboard* gives you an overview of the event log and scans you have run
    against your targets. The Dashboard is more useful in Burp Suite Pro than in CE
    because it will also display any issues detected during testing.
  prefs: []
  type: TYPE_NORMAL
- en: The *Proxy* tab is where we will begin capturing requests and responses from
    your web browser and Postman. The proxy we set up will send any web traffic destined
    for your browser here. We will typically choose to forward or drop captured traffic
    until we find the targeted site that we want to interact with. From Proxy we will
    forward the request or response to other modules for interaction and tampering.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Target* tab,we can see a site’s map and manage the targets we intend
    to attack. You can also use this tab to configure the scope of your testing by
    selecting the Scope tab and including or excluding URLs. Including URLs within
    scope will limit the URLs being attacked to only those you have authorization
    to attack.
  prefs: []
  type: TYPE_NORMAL
- en: While using the Target tab, you should be able to locate the *Site Map*, where
    you can see all the URLs Burp Suite has detected during your current Burp Suite
    session. As you perform scans, crawl, and proxy traffic, Burp Suite will start
    compiling a list of the target web applications and discovered directories. This
    is another place you can add or remove URLs from scope.
  prefs: []
  type: TYPE_NORMAL
- en: The *Intruder* tab is where we’ll perform fuzzing and brute-force attacks against
    web applications. Once you’ve captured an HTTP request, you can forward it to
    Intruder, where you can select the exact parts of the request that you want to
    replace with the payload of your choice before sending it to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The *Repeater* is a module that lets you make hands-on adjustments to HTTP requests,
    send them to the targeted web server, and analyze the content of the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: The *Sequencer* tool will automatically send hundreds of requests and then perform
    an analysis of entropy to determine how random a given string is. We will primarily
    use this tool to analyze whether cookies, tokens, keys, and other parameters are
    actually random.
  prefs: []
  type: TYPE_NORMAL
- en: The *Decoder* is a quick way to encode and decode HTML, base64, ASCII hex, hexadecimal,
    octal, binary, and Gzip.
  prefs: []
  type: TYPE_NORMAL
- en: The *Comparer* can be used to compare different requests. Most often, you’ll
    want to compare two similar requests and find the sections of the request that
    have been removed, added, and modified.
  prefs: []
  type: TYPE_NORMAL
- en: If Burp Suite is too bright for your hacker eyes, navigate to **User options**▶**Display**
    and change **Look and Feel** to **Darcula**. Within the User Options tab, you
    can also find additional connection configurations, TLS settings, and miscellaneous
    options to learn hotkey shortcuts or configure your own hotkeys. You can then
    save your preferred settings using Project Options, which allows you to save and
    load specific configurations you like to use per project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Learn* is an awesome set of resources to help you learn how to use Burp Suite.
    This tab contains video tutorials, the Burp Suite Support Center, a guided tour
    of Burp’s features, and a link to the PortSwigger Web Security Academy. Definitely
    check these resources out if you are new to Burp!'
  prefs: []
  type: TYPE_NORMAL
- en: Under the Dashboard you can find the Burp Suite Pro Scanner. *Scanner* is Burp
    Suite Pro’s web application vulnerability scanner. It lets you automatically crawl
    web applications and scan for weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: The*Extender* is where we’ll obtain and use Burp Suite extensions. Burp has
    an app store that allows you to find add-ons to simplify web app testing. Many
    extensions require Burp Suite Pro, but we will make the most of the free extensions
    to turn Burp into an API hacking powerhouse.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Burp Suite session will usually begin with intercepting traffic. If you’ve
    set up FoxyProxy and the Burp Suite certificate correctly, the following process
    should work smoothly. You can use these instructions to intercept any HTTP traffic
    with Burp Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Burp Suite and change the Intercept option to **Intercept is** **on**
    ‌(see [Figure 4-6](#figure4-6)).![F04006](image_fi/502444c04/F04006.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4-6: Intercept is on in Burp Suite.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In your browser, select the Hackz proxy using FoxyProxy and browse to your target,
    such as [https://twitter.com](https://twitter.com) (see [Figure 4-7](#figure4-7)).
    This web page will not load in the browser because it was never sent to the server;
    instead, the request should be waiting for you in Burp Suite.![F04007](image_fi/502444c04/F04007.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4-7: The request to Twitter gets sent to Burp Suite via the Hackz proxy.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Burp Suite, you should see something much like [Figure 4-8](#figure4-8).
    This should let you know that you’ve successfully intercepted an HTTP request.![F04008](image_fi/502444c04/F04008.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4-8: An HTTP request to Twitter intercepted by Burp Suite'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you’ve captured a request, you can select an action to perform with it,
    such as forwarding the intercepted request to the various Burp Suite modules.
    You perform actions by clicking the Action button above the request pane or by
    right-clicking the request window. You will then have the option to forward the
    request to one of the other modules, such as Repeater (see [Figure 4-9](#figure4-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the an HTTP request and corresponding response in a Burp Suite
    interface with a Send button](image_fi/502444c04/F04009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9: Burp Suite Repeater'
  prefs: []
  type: TYPE_NORMAL
- en: The Repeater module is the best way to see how a web server responds to a single
    request. This is useful for seeing what sort of response you can expect to get
    from an API before initiating an attack. It’s also helpful when you need to make
    minor changes to a request and want to see how the server responds.
  prefs: []
  type: TYPE_NORMAL
- en: Altering Requests with Intruder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already mentioned that Intruder is a web application fuzzing and scanning
    tool. It works by letting you create variables within an intercepted HTTP request,
    replace those variables with different sets of payloads, and send a series of
    requests to an API provider.
  prefs: []
  type: TYPE_NORMAL
- en: Any part of a captured HTTP request can be transformed into a variable, or *attack
    position*, by surrounding it with **§** symbols. Payloads can be anything from
    a wordlist to a set of numbers, symbols, and any other type of input that will
    help you test how an API provider will respond. For example, in [Figure 4-10](#figure4-10),
    we’ve selected the password as the attack position, as indicated by the § symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Burp Suite Positions tab with a payload position set around
    the password field and the Sniper attack type selected](image_fi/502444c04/F04010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-10: An Intruder attack against api.twitter.com'
  prefs: []
  type: TYPE_NORMAL
- en: This means that `SuperPass321!` will be replaced with values from the list of
    strings found in Payloads. Navigate to the Payloads tab to see these strings,
    shown in [Figure 4-11](#figure4-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Burp Suite Payloads tab with a Payload Options box that
    lists strings such as Password1, Password2, APIhacking4tw, and more](image_fi/502444c04/F04011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-11: The Intruder Payloads with a list of passwords'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the payload list shown here, Intruder will perform one request per
    payload listed for a total of nine requests. When an attack is started, each of
    the strings under Payload Options will replace `SuperPass123!` in turn and generate
    a request to the API provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Intruder attack types determine how the payloads are processed. As you
    can see in [Figure 4-12](#figure4-12), there are four different attack types:
    sniper, battering ram, pitchfork, and cluster bomb.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Burp Suite Positions Tab with Sniper selected in the Attack
    type field](image_fi/502444c04/F04012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-12: The Intruder attack types'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sniper* is the simplest attack type; it replaces the added attack position
    with a string provided from a single set of payloads. A sniper attack is limited
    to using a single payload, but it can have several attack positions. A sniper
    attack will replace one attack position per request, cycling through the different
    attack positions in each request. If you were attacking three different variables
    with a single payload, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Battering ram* is like the sniper attack in that it also uses one payload,
    but it will use that payload across all attack positions in a request. If you
    were testing for SQL injection across several input positions within a request,
    you could fuzz them all simultaneously with battering ram.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pitchfork* is used for testing multiple payload combinations at the same time.
    For example, if you have a list of leaked usernames and password combinations,
    you could use two payloads together to test whether any of the credentials were
    used with the application being tested. However, this attack doesn’t try out different
    combinations of payloads; it will only cycle through the payload sets like this:
    *user1:pass1*, *user2:pass2*, *user3:pass3*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cluster bomb* will cycle through all possible combinations of the payloads
    provided. If you provide two usernames and three passwords, the payloads would
    be used in the following pairs: *user1:pass1*, *user1:pass2*, *user1:pass3*, *user2:pass1*,
    *user2:pass2*, *user2:pass3*.'
  prefs: []
  type: TYPE_NORMAL
- en: The attack type to use depends on your situation. If you’re fuzzing a single
    attack position, use sniper. If you’re fuzzing several attack positions at once,
    use battering ram. When you need to test set combinations of payloads, use pitchfork.
    For password-spraying efforts, use cluster bomb.
  prefs: []
  type: TYPE_NORMAL
- en: Intruder should help you find API vulnerabilities such as broken object level
    authorization, excessive data exposure, broken authentication, broken function
    level authorization, mass assignment, injection, and improper assets management.
    Intruder is essentially a smart fuzzing tool that provides a list of results containing
    the individual requests and responses. You can interact with the request you’d
    like to fuzz and replace the attack position with the input of your choice. These
    API vulnerabilities are typically discovered by sending the right payload to the
    right location.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an API were vulnerable to authorization attacks like BOLA, we
    would be able to replace requested resource IDs with a payload containing a list
    of possible resource IDs. We could then start the attack with Intruder, which
    would make all the requests and provide us with a list of results to review. I
    will cover API fuzzing in Chapter 9 and API authorization attacks in Chapter 10.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting API Requests in Postman, an API Browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll use Postman to help us craft API requests and visualize responses. You
    can think of Postman as a web browser built for interacting with APIs. Originally
    designed as a REST API client, it now has all sorts of capabilities for interacting
    with REST, SOAP, and GraphQL. The application is packed with features for creating
    HTTP requests, receiving responses, scripting, chaining requests together, creating
    automated testing, and managing API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using Postman as our browser of choice for sending API requests to
    a server, rather than defaulting to Firefox or Chrome. This section covers the
    Postman features that matter the most and includes instructions for using the
    Postman request builder, an overview of working with collections, and some basics
    around building request tests. Later in this chapter, we will configure Postman
    to work seamlessly with Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Postman on Kali, open your terminal and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If everything has gone as planned, you should be able to launch Postman by entering
    `postman` in your terminal. Sign up for a free account using an email address,
    username, and password. Postman uses accounts for collaboration and to synchronize
    information across devices. Alternatively, you can skip the login screen by clicking
    the **Skip signing in and take me straight to the app** button.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need to go through the FoxyProxy setup process a second time (refer
    to the “Setting Up FoxyProxy” section earlier in this chapter) so that Postman
    can intercept requests. Return to step 4 and add a new proxy. Add the same host
    IP address, **127.0.0.1**, and set the port to **5555**, the default port for
    Postman’s proxy. Update the name of the proxy under the General tab to **Postman**
    and save. Your FoxyProxy tab should now resemble [Figure 4-13](#figure4-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the FoxyProxy interface with the Hackz, Postman, and Default
    proxies enabled](image_fi/502444c04/F04013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-13: FoxyProxy with the Hackz and Postman proxies set up'
  prefs: []
  type: TYPE_NORMAL
- en: From the launchpad, open a new tab just like you would in any other browser
    by clicking the new tab button (+) or using the ctrl-T shortcut. As you can see
    in [Figure 4-14](#figure4-14), Postman’s interface can be a little overwhelming
    if you aren’t familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman interface with many windows and menu items displaying
    GET requests and JSON data](image_fi/502444c04/F04014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-14: The main landing page of Postman with a response from an API collection'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by discussing the request builder, which you’ll see when you open
    a new tab.
  prefs: []
  type: TYPE_NORMAL
- en: The Request Builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request builder, shown in [Figure 4-15](#figure4-15), is where you can craft
    each request by adding parameters, authorization headers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of Postman interface with a form field for entering a request
    URL, a drop-down menu allowing you to select an HTTP method, and a Send button](image_fi/502444c04/F04015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-15: The Postman request builder'
  prefs: []
  type: TYPE_NORMAL
- en: The request builder contains several tabs useful for precisely constructing
    the parameters, headers, and body of a request. The *Params* tab is where you
    can add query and path parameters to a request. Essentially, this allows you to
    enter in various key/value pairs along with a description of those parameters.
    A great feature of Postman is that you can leverage the power of variables when
    creating your requests. If you import an API and it contains a variable like *:company*
    in *http://example.com/****:company****/profile*, Postman will automatically detect
    this and allow you to update the variable to a different value, such as the actual
    company name. We’ll discuss collections and environments later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The *Authorization* tab includes many standard forms of authorization headers
    for you to include in your request. If you’ve saved a token in an environment,
    you can select the type of token and use the variable’s name to include it. By
    hovering your mouse over a variable name, you can see the associated credentials.
    Several authorization options are available under the Type field that will help
    you automatically format the authorization header. Authorization types include
    several expected options such as no auth, API key, Bearer Token, and Basic Auth.
    In addition, you could use the authorization that is set for the entire collection
    by selecting **inherit auth from parent**.
  prefs: []
  type: TYPE_NORMAL
- en: The *Headers* tab includes the key and value pairs required for certain HTTP
    requests. Postman has some built-in functionality to automatically create necessary
    headers and to suggest common headers with preset options.
  prefs: []
  type: TYPE_NORMAL
- en: In Postman, values for parameters, headers, and parts of body work can be added
    by entering information within the Key column and the corresponding Value column
    (see [Figure 4-16](#figure4-16)). Several headers will automatically be created,
    but you can add your own headers when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Within the keys and values, you also have the ability to use collection variables
    and environmental variables. (We’ll cover collections later in this section.)
    For example, we’ve represented the value for the password key using the variable
    name `{admin_creds}`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman Headers tab displaying a table with two columns,
    Key and Value. The Key column includes headers such as User-Agent and Content-Type,
    and the values include endpoints, such as PostmanRuntime/7.28.3.](image_fi/502444c04/F04016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-16: Postman key and value headers'
  prefs: []
  type: TYPE_NORMAL
- en: The request builder can also run pre-request scripts, which can chain together
    different requests that depend on each other. For example, if request 1 issues
    a resource value that is needed for the following request, you can script that
    resource value to automatically be added to request 2.
  prefs: []
  type: TYPE_NORMAL
- en: Within Postman’s request builder, you can use several panels to craft proper
    API requests and review responses. Once you’ve sent a request, the response will
    show up in the response panel (see [Figure 4-17](#figure4-17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of Postman interface showing Body and Headers tabs and a Status
    Code bar](image_fi/502444c04/F04017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-17: The Postman request and response panels'
  prefs: []
  type: TYPE_NORMAL
- en: You can set the response panel either to the right or below the request panel.
    By pressing ctrl-alt-V, you can switch the request and response panels between
    single-pane and split-pane views.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 4-2](#table4-2), I have separated the items into the request panels
    and the response panels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-2: Request Builder Panels'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Panel** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *Request* |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP request method | The request method is found to the left of the request
    URL bar (at the top left of [Figure 4-17](#figure4-17) where there is a drop-down
    menu for GET). The options include all the standard requests: GET, POST, PUT,
    PATCH, DELETE, HEAD, and OPTIONS. It also includes several other request methods
    such as COPY, LINK, UNLINK, PURGE, LOCK, UNLOCK, PROPFIND, and VIEW. |'
  prefs: []
  type: TYPE_TB
- en: '| Body | In [Figure 4-17](#figure4-17), this is the third tab in the request
    pane. This allows for adding body data to the request, which is primarily used
    for adding or updating data when using PUT, POST, or PATCH. |'
  prefs: []
  type: TYPE_TB
- en: '| Body options | Body options are the format of the response. These are found
    below the Body tab when it is selected. The options currently include none, form-data,
    x-www-formurlencoded, raw, binary, and GraphQL. These options let you view response
    data in various forms. |'
  prefs: []
  type: TYPE_TB
- en: '| Pre-request script | JavaScript-based scripts that can be added and executed
    before a request is sent. This can be used to create variables, help troubleshoot
    errors, and change request parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| Test | This space allows for writing JavaScript-based tests used to analyze
    and test the API response. This is used to make sure the API responses are functioning
    as anticipated. |'
  prefs: []
  type: TYPE_TB
- en: '| Settings | Various settings for how Postman will handle requests. |'
  prefs: []
  type: TYPE_TB
- en: '| *Response* |'
  prefs: []
  type: TYPE_TB
- en: '| Response body | The body of the HTTP response. If Postman were a typical
    web browser, this would be the main window to view the requested information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Cookies | This shows all the cookies, if any, included with the HTTP response.
    This tab will include information about the cookie type, cookie value, path, expiration,
    and cookie security flags. |'
  prefs: []
  type: TYPE_TB
- en: '| Headers | This is where all the HTTP response headers are located. |'
  prefs: []
  type: TYPE_TB
- en: '| Test results | If you created any tests for your request, this is where you
    can view the results of those tests. |'
  prefs: []
  type: TYPE_TB
- en: Environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *environment* provides a way to store and use the same variables across APIs.
    An *environmental variable* is a value that will replace a variable across an
    environment. For example, say you’re attacking a production API but discover a
    *test* version of the production API as well; you’ll likely want to use an environment
    to share values between your requests to the two APIs. After all, there is a chance
    the production and test APIs share values such as API tokens, URL paths, and resource
    IDs.
  prefs: []
  type: TYPE_NORMAL
- en: To create environmental variables, find **Environment** at the top right of
    the request builder (the drop-down menu that says “No Environment” by default)
    and then press ctrl-N to bring up the **Create New** panel and select **Environment**,
    as shown in [Figure 4-18](#figure4-18).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman Create New menu with the Environment option highlighted](image_fi/502444c04/F04018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-18: The Create New panel in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: You can give an environment variable both an initial value and a current value
    (see [Figure 4-19](#figure4-19)). An *initial value* will be shared if you share
    your Postman environment with a team, whereas a current value is not shared and
    is only stored locally. For example, if you have a private key, you can store
    the private key as the current value. Then you will be able to use the variable
    in places where you would have to paste the private key.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman Manage Environments window with the admin_credz
    variable and its current value](image_fi/502444c04/F04019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-19: The Manage Environments window in Postman showing the variable
    `admin_creds` with a current value of `This_``i``s_hidd3n`'
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Collections* are groups of API requests that can be imported into Postman.
    If an API provider offers a collection, you won’t have to physically type in every
    single request. Instead, you can just import its collection. The best way to understand
    this functionality is to download a public API collection to your Postman from
    [https://www.postman.com/explore/collections](https://www.postman.com/explore/collections).
    For examples throughout this section, I will be referencing the Age of Empires
    II collection.'
  prefs: []
  type: TYPE_NORMAL
- en: The Import button lets you import collections, environments, and API specifications.
    Currently, Postman supports OpenAPI 3.0, RAML 0.8, RAML 1.0, GraphQL, cURL, WADL,
    Swagger 1.2, Swagger 2.0, Runscope, and DHC. You can make your testing quite a
    bit easier if you can import your target API specification. Doing this will save
    you the time of having to craft all the API requests by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Collections, environments, and specifications can all be imported as a file,
    folder, link, or raw test or through linking your GitHub account. For example,
    you can import the API for the classic PC game *Age of Empires II* from *https://age-of-empires-2-api.herokuapp.com/apispec.json*
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Import** button found at the top left of Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Link** tab (see [Figure 4-20](#figure4-20)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the URL to the API specification and click **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Confirm Your Import screen, click **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman Import Link tab with a form field for entering
    a URL and a Continue button](image_fi/502444c04/F04020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-20: Importing an API specification in Postman using the Link tab in
    the Import panel'
  prefs: []
  type: TYPE_NORMAL
- en: Once this is complete, you should have the Age of Empires II collection saved
    in Postman. Now test it out. Select one of the requests in the collection shown
    in [Figure 4-21](#figure4-21) and click **Send**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman interface populated with requests from the Age
    of Empires 2 collection and a list of what each does](image_fi/502444c04/F04021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-21: The Collections sidebar with the imported Age of Empires II API
    GET requests'
  prefs: []
  type: TYPE_NORMAL
- en: For the request to work, you might have to first check the collection’s variables
    to make sure they’re set to the correct values. To see a collection’s variables,
    you will need to navigate to the Edit Collection window by selecting **Edit**
    within the **View More Actions** button (represented by three circles, as shown
    in [Figure 4-22](#figure4-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a GET request selected in the Postman interface and the Edit
    option highlighted in a pop-up menu](image_fi/502444c04/F04022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-22: Editing a collection within Postman'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re in the Edit Collection window, select **Variables**, as shown in
    [Figure 4-23](#figure4-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Variables tab in Postman with the baseURL variable selected](image_fi/502444c04/F04023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-23: The Age of Empires II API collection variables'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Age of Empires II API collection uses the variable `{{baseUrl}}`.
    The problem with the current `{{baseUrl}}` is that there are no values. We need
    to update this variable to the full URL of the public API, *https://age-of-empires-2-api.herokuapp.com/api/v1*.
    Add the full URL and click **Save** to update your changes (see [Figure 4-24](#figure4-24)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Variables tab in Postman with the initial value of the
    baseURL set to https://age-of-empires-2-api.herokuapp.com/api/v1](image_fi/502444c04/F04024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-24: The updated `baseURL` variable'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the variable is updated, you can choose one of the requests and click
    **Send**. If you are successful, you should receive a response similar to that
    shown in [Figure 4-25](#figure4-25).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman interface populated with an HTTP response](image_fi/502444c04/F04025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-25: Successfully using the Age of Empires II API collection in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you import a collection and run into errors, you can use this process
    to troubleshoot the collection’s variables. Also be sure to check that you haven’t
    omitted any authorization requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The Collection Runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Collection Runner allows you to run all the saved requests in a collection
    (see [Figure 4-26](#figure4-26)). You can select the collection you want to run,
    the environment you want to pair it with, how many times you want to run the collection,
    and a delay in case there are rate-limiting requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman Collection Runner listing a variety of GET and
    POST requests](image_fi/502444c04/F04026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-26: The Postman Collection Runner'
  prefs: []
  type: TYPE_NORMAL
- en: The requests can also be put into a specific order. Once the Collection Runner
    has run, you can review the Run Summary to see how each request was handled. For
    instance, if I open the Collection Runner, select Twitter API v2, and run the
    Collection Runner, I can see an overview of all API requests in that collection.
  prefs: []
  type: TYPE_NORMAL
- en: Code Snippets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the panels, you should also be aware of the code snippets feature.
    At the top-right of the request pane, you’ll see a Code button. This button can
    be used to translate the built request into many different formats, including
    cURL, Go, HTTP, JavaScript, NodeJS, PHP, and Python. This is a helpful feature
    when we craft a request with Postman and then need to pivot to another tool. You
    can craft a complicated API request in Postman, generate a cURL request, and then
    use that with other command line tools.
  prefs: []
  type: TYPE_NORMAL
- en: The Tests Panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Tests panel allows you to create scripts that will be run against responses
    to your requests. If you are not a programmer, you will appreciate that Postman
    has made prebuilt code snippets available on the right side of the Tests panel.
    You can easily build a test by finding a prebuilt code snippet, clicking it, and
    adjusting the test to fit your testing needs. I suggest checking out the following
    snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Status code: Code is 200`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Response time is less than 200ms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Response body: contains string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These JavaScript code snippets are fairly straightforward. For instance, the
    test for `Status code: Code is 200` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the name of the test that will be displayed in the test results
    is “Status code is 200.” The function is checking to make sure the Postman response
    has the status 200\. We can easily adjust JavaScript to check for any status code
    by simply updating the `(200)` to our desired status code and changing the test
    name to fit. For example, if we wanted to check for the status code 400, we could
    change the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It’s as simple as that! You really don’t have to be a programmer to understand
    these JavaScript code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-27](#figure4-27) shows a series of tests included with the API request
    to the AOE2 public API. The tests include a check for a 200 status code, less
    than 200 ms latency, and “Persians” within the response string.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman Tests panel in which a test is written and a list
    of requests are labeled “Pass”](image_fi/502444c04/F04027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-27: AOE2 public API tests'
  prefs: []
  type: TYPE_NORMAL
- en: After your tests are configured, you can check the Test Results tab of a response
    to see if the tests succeeded or failed. A good practice with creating tests is
    to make sure the tests fail. Tests are only effective if they pass and fail when
    they are supposed to. Therefore, send a request that would create conditions you
    would expect to pass or fail the test to ensure it is functioning properly. For
    more information about creating test scripts, check out the Postman documentation
    ([https://learning.postman.com/docs/writing-scripts/test-scripts](https://learning.postman.com/docs/writing-scripts/test-scripts)).
  prefs: []
  type: TYPE_NORMAL
- en: You now have many other options to explore in Postman. Like Burp Suite, Postman
    has a Learning Center ([https://learning.postman.com](https://learning.postman.com))
    for online resources for those who want to develop a deeper understanding of the
    software. Alternatively, if you would like to review the Postman documentation,
    you can find it at [https://learning.postman.com/docs/getting-started/introduction](https://learning.postman.com/docs/getting-started/introduction).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Postman to Work with Burp Suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Postman is useful for interacting with APIs, and Burp Suite is a powerhouse
    for web application testing. If you combine these applications, you can configure
    and test an API in Postman and then proxy the traffic over to Burp Suite to brute-force
    directories, tamper with parameters, and fuzz all the things.
  prefs: []
  type: TYPE_NORMAL
- en: 'As when you set up FoxyProxy, you’ll need to configure the Postman proxy to
    send traffic over to Burp Suite using the following steps (see [Figure 4-28](#figure4-28)):'
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman settings by pressing ctrl-, (comma) or navigating to **File**▶**Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Proxy** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the checkbox for adding a custom proxy configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to set the proxy server to **127.0.0.1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the proxy server port to **8080**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **General** tab and turn SSL certificate verification **Off**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Burp Suite, select the **Proxy** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the button to turn Intercept **On**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman Settings Proxy tab with the following checkboxes
    selected: use the system proxy, add a custom proxy configuration, HTTP, and HTTPS](image_fi/502444c04/F04028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-28: Postman’s proxy settings configured to interact with Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: Try sending a request using Postman; if it is intercepted by Burp Suite, you’ve
    properly configured everything. Now you can leave the proxy on and toggle Burp
    Suite’s “turn Intercept on” function when you want to capture requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Supplemental Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is meant to provide additional options and to aid those who are
    limited by the features available in Burp Suite CE. The following tools are excellent
    at what they do, open source, and free. In particular, the API scanning tools
    covered here serve several purposes when you’re actively testing your target.
    Tools such as Nikto and OWASP ZAP can help you actively discover API endpoints,
    security misconfigurations, and interesting paths, and they provide some surface-level
    testing of an API. In other words, they are useful when you start actively engaging
    with a target, whereas tools such as Wfuzz and Arjun will be more useful once
    you’ve discovered an API and want to narrow the focus of your testing. Use these
    tools to actively test APIs to discover unique paths, parameters, files, and functionality.
    Each of these tools has its own unique focus and purpose that will supplement
    functionality lacking in the free Burp Suite Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Reconnaissance with OWASP Amass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OWASP Amass is an open-source information-gathering tool that can be used for
    passive and active reconnaissance. This tool was created as a part of the OWASP
    Amass project, led by Jeff Foley. We will be using Amass to discover the attack
    surface of our target organizations. With as little as a target’s domain name,
    you can use Amass to scan through many internet sources for your target’s associated
    domains and subdomains to get a list of potential target URLs and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If OWASP Amass is not installed, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Amass is pretty effective without much setup. However, you can make it into
    an information collection powerhouse by setting it up with API keys from various
    sources. I recommend at least setting up accounts with GitHub, Twitter, and Censys.
    Once you’ve set up these accounts, you can generate API keys for these services
    and plug them into Amass by adding them to Amass’s configuration file, *config.ini*.
    The Amass GitHub repository has a template *config.ini* file that you can use
    at [https://github.com/OWASP/Amass/blob/master/examples/config.ini](https://github.com/OWASP/Amass/blob/master/examples/config.ini).
  prefs: []
  type: TYPE_NORMAL
- en: 'On Kali, Amass will attempt to automatically find the *config.ini* file at
    the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To download the content of the sample *config.ini* file and save it to the
    default Amass config file location, run the following command from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have that file downloaded, you can edit it and add the API keys you
    would like to include. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can remove the comment (`#`) and simply paste in the API
    key for whichever service you would like to use. The *config.ini* file even indicates
    which keys are free. You can find a list of the sources with APIs you can use
    to enhance Amass at [https://github.com/OWASP/Amass](https://github.com/OWASP/Amass).
    Although it will be a little time-consuming, I recommend taking advantage of at
    least all the free sources listed under APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering API Endpoints with Kiterunner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kiterunner ([https://github.com/assetnote/kiterunner](https://github.com/assetnote/kiterunner))
    is a content discovery tool designed specifically for finding API resources. Kiterunner
    is built with Go, and while it can scan at a speed of 30,000 requests per second,
    it takes into account the fact that load balancers and web application firewalls
    will likely enforce rate limiting.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to APIs, Kiterunner’s search techniques outperform other content
    discovery tools such as dirbuster, dirb, Gobuster, and dirsearch because this
    tool was built with API awareness. Its wordlists, request methods, parameters,
    headers, and path structures are all focused on finding API endpoints and resources.
    Of note, the tool includes data from 67,500 Swagger files. Kiterunner has also
    been designed to detect the signature of different APIs, including Django, Express,
    FastAPI, Flask, Nginx, Spring, and Tomcat (just to name a few).
  prefs: []
  type: TYPE_NORMAL
- en: One of the tool’s most useful capabilities, which we’ll leverage in Chapter
    6, is the request replay feature. If Kiterunner detects endpoints when scanning,
    it will display this result on the command line. You can then dive deeper into
    the result by exploring the exact request that triggered the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Kiterunner, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should then be able to use Kiterunner from the command line by entering
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can supply Kiterunner with various wordlists, which it then uses as payloads
    for a series of requests. These requests will help you discover interesting API
    endpoints. Kiterunner allows you to use Swagger JSON files, Assetnote’s *.kites*
    files, and *.txt* wordlists. Currently, Assetnote releases its wordlists, which
    contain search terms collected from its internet-wide scans, on a monthly basis.
    All of the wordlists are hosted at [https://wordlists.assetnote.io](https://wordlists.assetnote.io).
    Create an API wordlists directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then select your desired wordlists and download them to the */api/wordlists*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can replace *httparchive_apiroutes_2021_06_028.txt* with whichever wordlists
    suit you best. Alternatively, download all the Assetnote wordlists at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Be warned that downloading all of the Assetnote wordlists takes up about 2.2GB
    of space, but storing them is definitely worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for Vulnerabilities with Nikto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nikto is a command line web application vulnerability scanner that is quite
    effective at information gathering. I use Nikto immediately after discovering
    the existence of a web application, as it can point me toward the application’s
    interesting aspects. Nikto will provide you with information about the target
    web server, security misconfigurations, and other web application vulnerabilities.
    Since Nikto is included in Kali, it should not require any special setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To scan a domain, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To see the additional Nikto options, enter `nikto -Help` on the command line.
    A few options you may find useful include `-output` `filename` for saving the
    Nikto results to a specified file and `-maxtime` `#ofseconds` to limit how long
    a Nikto scan will take.
  prefs: []
  type: TYPE_NORMAL
- en: The results from a Nikto scan will include an app’s allowed HTTP methods, interesting
    header information, potential API endpoints, and other directories that could
    be worth checking out. For additional information about Nikto, review the documentation
    found at *https://cirt.net/nikto2-docs*.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for Vulnerabilities with OWASP ZAP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OWASP developed ZAP, an open-source web application scanner, and it’s another
    essential web application security testing tool. OWASP ZAP should be included
    in Kali, but if it isn’t, you can clone it from GitHub at [https://github.com/zaproxy/zaproxy](https://github.com/zaproxy/zaproxy).
  prefs: []
  type: TYPE_NORMAL
- en: 'ZAP has two components: automated scan and manual explore. ZAP’s *automated
    scan* performs web crawling, detects vulnerabilities, and tests web application
    responses by altering request parameters. Automated scan is great for detecting
    the surface directories of a web application, which includes discovering API endpoints.
    To run it, enter the target URL into the ZAP interface and click the button to
    start the attack. Once the scan has run its course, you’ll receive a list of alerts
    that are categorized by the severity of the finding. The issue with ZAP’s automated
    scan is that it can be riddled with false positives, so it is important to examine
    and validate the alerts. The testing is also limited to the surface of a web application.
    Unless there are unintentionally exposed directories, ZAP will not be able to
    infiltrate beyond authentication requirements. This is where the ZAP manual explore
    option comes in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: ZAP *manual explore* is especially useful for exploring beyond the surface of
    the web application. Also known as the ZAP Heads Up Display (ZAP HUD), manual
    explore proxies your web browser’s traffic through ZAP while you browse. To launch
    it, enter the URL to explore and open a browser of your choice. When the browser
    launches, it will appear that you are browsing the site as you normally would;
    however, ZAP alerts and functions will overlay the web page. This allows you to
    have much more control over when to start crawling, when to run active scans,
    and when to turn on “attack mode.” For example, you can go through the user account
    creation process and authentication/authorization process with the ZAP scanner
    running to automatically detect flaws in these processes. Any vulnerabilities
    you detect will pop up like gaming achievements. We will be using ZAP HUD to discover
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing with Wfuzz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wfuzz is an open-source Python-based web application fuzzing framework. Wfuzz
    should come with the latest version of Kali, but you can install it from GitHub
    at [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz).
  prefs: []
  type: TYPE_NORMAL
- en: You can use Wfuzz to inject a payload within an HTTP request by replacing occurrences
    of the word *FUZZ* with words from a wordlist; Wfuzz will then rapidly perform
    many requests (around 900 requests per minute) with the specified payload. Since
    so much of the success of fuzzing depends on the use of a good wordlist, we’ll
    spend a decent amount of time discussing wordlists in Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic request format of Wfuzz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To run Wfuzz, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command replaces *FUZZ* in the URL *http://targetname.com/FUZZ* with words
    from */usr/share/wordlists/list.txt*. The `-z` option specifies a type of payload
    followed by the actual payload. In this example, we specified that the payload
    is a file and then provided the wordlist’s file path. We could also use `-z` with
    `list` or `range`. Using the `list` option means that we will specify the payload
    in the request, whereas `range` refers to a range of numbers. For example, you
    can use the `list` option to test an endpoint for a list of HTTP verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `-X` option specifies the HTTP request method. In the previous example,
    Wfuzz will perform a POST request with the wordlist used as the path in place
    of the *FUZZ* placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `range` option to easily scan a series of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically fuzz all numbers from 500 to 1000\. This will come in
    handy when we test for BOLA vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify multiple attack positions, you can list off several `-z` flags and
    then number the corresponding `FUZZ` placeholders, such as `FUZZ`, `FUZ1`, `FUZ2`,
    `FUZ3`, and so on, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running Wfuzz against a target can generate a ton of results, which can make
    it difficult to find anything interesting. Therefore, you should familiarize yourself
    with the Wfuzz filter options. The following filters display only certain results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--sc` Only shows responses with specific HTTP response codes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--sl` Only shows responses with a certain number of lines'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--sw` Only shows responses with a certain number of words'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--sh` Only shows responses with a certain number of characters'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, Wfuzz will scan the target and only show results
    that include a status code of 200:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following filters hide certain results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--hc` Hides responses with specific HTTP status codes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--hl` Hides responses with a specified number of lines'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--hw` Hides responses with a specified number of words'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--hh` Hides responses with specified number of characters'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, Wfuzz will scan the target and hide all results that
    have a status code of 404 and hide results that have 950 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Wfuzz is a powerful multipurpose fuzzing tool you can use to thoroughly test
    endpoints and find their weaknesses. For more information about Wfuzz, check out
    the documentation at [https://wfuzz.readthedocs.io/en/latest](https://wfuzz.readthedocs.io/en/latest).
  prefs: []
  type: TYPE_NORMAL
- en: Discovering HTTP Parameters with Arjun
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arjun is another open source Python-based API fuzzer developed specifically
    to discover web application parameters. We will use Arjun to discover basic API
    functionality, find hidden parameters, and test API endpoints. You can use it
    as a great first scan for an API endpoint during black box testing or as an easy
    way to see how well an API’s documented parameters match up with the scan’s findings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arjun comes configured with a wordlist containing nearly 26,000 parameters,
    and unlike Wfuzz, it does some of the filtering for you using its preconfigured
    anomaly detection. To set up Arjun, first clone it from GitHub (you’ll need a
    GitHub account to do this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Arjun works by first performing a standard request to the target API endpoint.
    If the target responds with HTML forms, Arjun will add the form names to the parameter
    list during its scan. Arjun then sends a request with parameters it expects to
    return responses for nonexistent resources. This is done to note the behavior
    of a failed parameter request. Arjun then kicks off 25 requests containing the
    payload of nearly 26,000 parameters, compares the API endpoint’s responses, and
    begins additional scans of the anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Arjun, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to have the output results in a certain format, use the `-o`
    option with your desired file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you come across a target with rate limiting, Arjun may trigger the rate
    limit and cause a security control to block you. Arjun even has built-in suggestions
    for when a target does not cooperate. Arjun may prompt you with an error message
    such as “Target is unable to process requests, try --stable switch.” If this happens,
    simply add the `--stable` flag. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Arjun can scan multiple targets at once. Use the `-i` flag to specify
    a list of target URLs. If you’ve been proxying traffic with Burp Suite, you can
    select all URLs within the sitemap, use the Copy Selected URLs option, and paste
    that list to a text file. Then run Arjun against all Burp Suite targets simultaneously,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you set up the various tools we’ll use to hack APIs throughout
    this book. Additionally, we spent some time digging into feature-rich applications
    such as DevTools, Burp Suite, and Postman. Being comfortable with the API hacking
    toolbox will help you know when to use which tool and when to pivot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lab #1: Enumerating the User Accounts in a REST API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Welcome to your first lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this lab, our goal is simple: find the total number of user accounts in
    *reqres.in*, a REST API designed for testing, using the tools discussed in this
    chapter. You could easily figure this out by guessing the total number of accounts
    and then checking for that number, but we will discover the answer much more quickly
    using the power of Postman and Burp Suite. When testing actual targets, you could
    use this process to discover whether there was a basic BOLA vulnerability present.'
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to [http://reqres.in](http://reqres.in) to see if API documentation
    is available. On the landing page, we find the equivalent of API documentation
    and can see a sample request that consists of making a request to the */api/users/2*
    endpoint (see [Figure 4-29](#figure4-29)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the web page at https://reqres.in featuring a list of GET requests
    and their purposes, as well as the JSON data returned from one of the requests](image_fi/502444c04/F04029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-29: API documentation found at [https://reqres.in](https://reqres.in)
    with instructions for requesting `user id:2`'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice a List Users endpoint; we’ll ignore this for the purposes of the
    lab, as it won’t help you learn the intended concepts. Instead, we’ll be using
    the Single User endpoint because it will help you build the skills needed to discover
    vulnerabilities like BOLA and BFLA. The suggested API request for Single User
    is meant to provide the consumer with the requested user’s account information
    by sending a GET request to */api/users/*. We can easily assume that user accounts
    are organized in the *user* directory by their `id` number.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test this theory by attempting to send a request to a user with a different
    ID number. Since we’ll be interacting with an API, let’s set up the API request
    using Postman. Set the method to GET and add the URL *http://reqres.in/api/users/1*.
    Click **Send** and make sure you get a response. If you requested the user with
    an ID of 1, the response should reveal the user information for George Bluth,
    as seen in [Figure 4-30](#figure4-30).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a GET request to the http://reqres.in/api/users/1 endpoint
    in Postman showing the JSON data from the response body. The JSON data includes
    details about a user named George.](image_fi/502444c04/F04030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-30: A standard API request made using Postman to retrieve user 1 from
    the [https://reqres.in](https://reqres.in) database'
  prefs: []
  type: TYPE_NORMAL
- en: To efficiently retrieve the data of all users by following this method, we’ll
    use Burp’s Intruder. Proxy the traffic from the *reqres.in* endpoint over to Burp
    Suite and submit the same request in Postman. Migrate over to Burp Suite, where
    you should see the intercepted traffic in Burp Suite’s Proxy tab (see [Figure
    4-31](#figure4-31)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The intercepted request shown in Burp Suite Proxy](image_fi/502444c04/F04031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-31: The intercepted request made using Postman to retrieve user 1'
  prefs: []
  type: TYPE_NORMAL
- en: Use the shortcut Ctrl-I or right-click the intercepted request and select **Send
    to Intruder**. Select the **Intruder**▶**Positions** tab to select the payload
    positions. First, select **Clear §** to remove the automatic payload positioning.
    Then select the number at the end of the URL and click the button labeled **Add
    §** (see [Figure 4-32](#figure4-32)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of Burp Intruder’s Positions tab with the Sniper attack type selected
    and the UserID portion of the endpoint selected as the attack position](image_fi/502444c04/F04032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-32: Burp Suite’s Intruder configured with the attack position set
    around the *UserID* portion of the path'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve selected the attack position, select the **Payloads** tab (see [Figure
    4-33](#figure4-33)). Since our goal is to find out how many user accounts exist,
    we want to replace the user ID with a series of numbers. Change the payload type
    to **Numbers**. Update the range of numbers to test from 0 to 25, stepping by
    1\. The Step option indicates to Burp how many numbers to increase with each payload.
    By selecting 1, we are letting Burp do the heavy lifting of creating all the payloads
    on the fly. This will help us discover all the users with an ID between 0 and
    25\. With these settings, Burp will send a total of 26 requests, each one with
    a number from 0 to 25.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Burp Suite Payloads tab showing one payload set, the payload
    type set to numbers, and the payloads ranging from 0 to 25](image_fi/502444c04/F04033.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-33: Intruder’s Payloads tab with the payload type set to numbers'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click **Start Attack** to send the 26 requests to *reqres.in*. Analyzing
    the results should give you a clear indication of all the live users. The API
    provider responds with a status 200 for user accounts between 1 and 12 and a status
    of 404 for the subsequent requests. Judging by the results, we can conclude that
    this API has a total of 12 valid user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this was just practice. The values you replace in a future API hacking
    engagement could be user ID numbers, but they could just as easily be bank account
    numbers, phone numbers, company names, or email addresses. This lab has prepared
    you to take on the world of basic BOLA vulnerabilities; we will expand on this
    knowledge in Chapter 10.
  prefs: []
  type: TYPE_NORMAL
- en: As a further exercise, try performing this same scan using Wfuzz.
  prefs: []
  type: TYPE_NORMAL
