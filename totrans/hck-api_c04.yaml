- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Your API Hacking System
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 API 黑客系统
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'This chapter will walk you through setting up your API hacking toolkit. We’ll
    cover three especially useful tools for API hackers: Chrome DevTools, Burp Suite,
    and Postman.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导您设置 API 黑客工具包。我们将介绍三个特别有用的 API 黑客工具：Chrome 开发者工具、Burp Suite 和 Postman。
- en: In addition to exploring features included in the paid Burp Suite Pro version,
    I’ll provide a list of tools that can compensate for the features missing from
    the free Burp Suite Community Edition, as well as several other tools useful for
    discovering and exploiting API vulnerabilities. At the end of this chapter, we’ll
    walk through a lab in which you’ll learn to use some of these tools to interact
    with our first APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了探索付费版本 Burp Suite Pro 中的功能外，我还将提供一份工具列表，用于弥补免费版 Burp Suite Community Edition
    中缺失的功能，以及一些其他有助于发现和利用 API 漏洞的工具。在本章末，我们将通过一个实验室，您将学习如何使用这些工具与我们的第一个 API 进行交互。
- en: Kali Linux
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kali Linux
- en: Throughout this book, we’ll run tools and labs using Kali, an open-source Debian-based
    distribution of Linux. Kali is built for penetration testing and comes with many
    useful tools already installed. You can download Kali at [https://www.kali.org/downloads](https://www.kali.org/downloads).
    Plenty of guides can walk you through setting up your hypervisor of choice and
    installing Kali onto it. I recommend using Null Byte’s “How to Get Started with
    Kali Linux” or the tutorial at [https://www.kali.org/docs/installation](https://www.kali.org/docs/installation).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 Kali 运行工具和实验，Kali 是基于 Debian 的开源 Linux 发行版，专为渗透测试设计，已经安装了许多有用的工具。您可以在
    [https://www.kali.org/downloads](https://www.kali.org/downloads) 下载 Kali。很多教程可以指导您设置所选的虚拟化平台并安装
    Kali。我推荐 Null Byte 的《如何开始使用 Kali Linux》或 [https://www.kali.org/docs/installation](https://www.kali.org/docs/installation)
    上的教程。
- en: 'After your instance of Kali is set up, open a terminal and perform an update
    and upgrade:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Kali 实例设置完成后，打开终端并执行更新和升级：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, install Git, Python 3, and Golang (Go), which you’ll need to use some
    of the other tools in your hacking box:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 Git、Python 3 和 Golang（Go），这些工具是您在使用某些黑客工具时需要的：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With these basics installed, you should be prepared to set up the remainder
    of the API hacking tools.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这些基础工具后，您应该准备好设置剩余的 API 黑客工具。
- en: Analyzing Web Apps with DevTools
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 DevTools 分析 Web 应用
- en: Chrome’s DevTools is a suite of developer tools built into the Chrome browser
    that allows you to view what your web browser is running from a web developer’s
    perspective. DevTools is an often-underrated resource, but it can be very useful
    for API hackers. We’ll use it for our first interactions with target web applications
    to discover APIs; interact with web applications using the console; view headers,
    previews, and responses; and analyze web application source files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 的开发者工具（DevTools）是内置于 Chrome 浏览器中的一套开发工具，允许您从 Web 开发者的角度查看您的浏览器正在运行的内容。DevTools
    是一个常被低估的资源，但它对 API 黑客来说非常有用。我们将使用它与目标 Web 应用进行首次交互，以发现 API；通过控制台与 Web 应用进行交互；查看请求头、预览和响应；分析
    Web 应用的源代码文件。
- en: 'To install Chrome, which includes DevTools, run the following commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装包含 DevTools 的 Chrome，请运行以下命令：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can launch Chrome through the command line with the `google-chrome` command.
    Once you have Chrome running, navigate to the URL you want to investigate and
    launch DevTools by using either ctrl-shift-I or F12 or navigating to **Settings**▶**More
    Tools** and selecting the **Developer Tools** menu. Next, refresh your current
    page to update the information in the DevTools panels. You can do this by using
    the ctrl-R shortcut. In the Network panel, you should see the various resources
    requested from APIs (see [Figure 4-1](#figure4-1)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过命令行使用 `google-chrome` 命令启动 Chrome。一旦 Chrome 启动，导航到您想要调查的 URL，并通过按 ctrl-shift-I
    或 F12 或进入 **设置**▶**更多工具**，选择 **开发者工具** 菜单来启动 DevTools。接下来，刷新当前页面以更新 DevTools 面板中的信息。您可以通过
    ctrl-R 快捷键来实现此操作。在网络面板中，您应该看到从 API 请求的各种资源（见 [图 4-1](#figure4-1)）。
- en: '![Screenshot of a DevTools panel populated with a list of requests that have
    200 status codes](image_fi/502444c04/F04001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![带有 200 状态码请求列表的 DevTools 面板截图](image_fi/502444c04/F04001.png)'
- en: 'Figure 4-1: The Chrome DevTools Network panel'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：Chrome DevTools 网络面板
- en: Switch panels by selecting the desired tab at the top. The DevTools panel lists
    the functionality of the different table options. I’ve summarized these in [Table
    4-1](#table4-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择顶部的选项卡切换面板。开发者工具面板列出了不同选项卡的功能。我已在[表 4-1](#table4-1)中总结了这些内容。
- en: 'Table 4-1: DevTools Panels'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1：开发者工具面板
- en: '| **Panel** | **Function** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **面板** | **功能** |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Elements | Allows you to view the current page’s CSS and Document Object
    Model (DOM), which enables you to inspect the HTML that constructs the web page.
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 允许你查看当前页面的 CSS 和文档对象模型（DOM），从而使你能够检查构建网页的 HTML。 |'
- en: '| Console | Provides you with alerts and lets you interact with the JavaScript
    debugger to alter the current web page. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 控制台 | 提供警告信息并让你与 JavaScript 调试器互动，以修改当前网页。 |'
- en: '| Sources | Contains the directories that make up the web application and the
    content of the source files. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 源代码 | 包含构成 web 应用程序的目录以及源文件的内容。 |'
- en: '| Network | Lists all the source file requests that make up the client’s perspective
    of the web application. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | 列出了构成客户端视角的 web 应用程序的所有源文件请求。 |'
- en: '| Performance | Provides a way to record and analyze all the events that take
    place when loading a web page. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 提供记录和分析加载网页时发生的所有事件的方法。 |'
- en: '| Memory | Lets you record and analyze how the browser is interacting with
    your system’s memory. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | 让你记录和分析浏览器如何与系统内存互动。 |'
- en: '| Application | Provides you with the application manifest, storage items (like
    cookies and session information), cache, and background services. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序 | 提供应用程序清单、存储项（如 cookies 和会话信息）、缓存和后台服务。 |'
- en: '| Security | Provides insight regarding the transit encryption, source content
    origins, and certificate details. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 提供关于传输加密、源内容来源和证书详细信息的洞察。 |'
- en: When we first begin interacting with a web application, we’ll usually start
    with the Network panel to get an overview of the resources that power the web
    application. In [Figure 4-1](#figure4-1), each of the items listed represents
    a request that was made for a specific resource. Using the Network panel, you
    can drill down into each request to see the request method that was used, the
    response status code, the headers, and the response body. To do this, click the
    name of the URL of interest once under the Name column. This will open up a panel
    on the right side of the DevTools. Now you can review the request that was made
    under the Headers tab and see how the server responded under the Response tab.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次开始与 web 应用程序交互时，通常会从网络面板开始，以概览支持 web 应用程序的资源。在[图 4-1](#figure4-1)中，每一项都表示为特定资源发出的请求。通过网络面板，你可以深入每个请求，查看使用的请求方法、响应状态码、头部信息和响应体。为此，只需在名称栏下点击感兴趣的
    URL 名称。这将打开开发者工具右侧的面板。现在你可以在“头部”标签下查看发出的请求，并在“响应”标签下查看服务器的回应。
- en: Diving deeper into the web application, you can use the Sources panel to inspect
    the source files being used in the app. In capture-the-flag (CTF) events (and
    occasionally in reality) you may find API keys or other hardcoded secrets here.
    The Sources panel comes equipped with strong search functionality that will help
    you easily discover the inner workings of the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 深入分析 web 应用程序时，你可以使用源代码面板来检查应用程序中使用的源文件。在抓旗（CTF）事件中（有时在现实中也是如此），你可能会在这里发现 API
    密钥或其他硬编码的密钥。源代码面板配备了强大的搜索功能，可以帮助你轻松发现应用程序的内部工作原理。
- en: The Console panel is useful for running and debugging the web page’s JavaScript.
    You can use it to detect errors, view warnings, and execute commands. You will
    get an opportunity to use the Console panel in the lab in Chapter 6.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台面板对于运行和调试网页的 JavaScript 非常有用。你可以使用它来检测错误、查看警告并执行命令。你将在第六章的实验中使用控制台面板。
- en: We will spend the majority of our time in the Console, Sources, and Network
    panels. However, the other panels can be useful as well. For example, the Performance
    panel is mainly used to improve a website’s speed, but we could also use it to
    observe at what point a web application interacts with an API, as shown in [Figure
    4-2](#figure4-2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数时间会花在控制台、源代码和网络面板中。不过，其他面板也同样有用。例如，性能面板主要用于提升网站速度，但我们也可以使用它来观察 web 应用程序何时与
    API 互动，如[图 4-2](#figure4-2)所示。
- en: '![Screenshot of a DevTools graph on which a point is labeled “client_event.json
    (api.twitter.com).”](image_fi/502444c04/F04002.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![DevTools 图表截图，其中一个点标注为“client_event.json (api.twitter.com)”。](image_fi/502444c04/F04002.png)'
- en: 'Figure 4-2: The DevTool’s Performance tab showing the exact moment the Twitter
    application interacted with the Twitter API'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：DevTool 性能标签页，显示 Twitter 应用与 Twitter API 交互的确切时刻
- en: In [Figure 4-2](#figure4-2) we see that, 1,700 milliseconds in, a client event
    triggered the Twitter application to interact with the API. As the client, we
    would then be able to correlate that event to an action we took on the page, such
    as authenticating to the web app, to know what the web application is using the
    API for. The more information we can gather before attacking an API, the better
    our odds will be at finding and exploiting vulnerabilities.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-2](#figure4-2)中，我们看到 1,700 毫秒时，一个客户端事件触发了 Twitter 应用与 API 的交互。作为客户端，我们可以将这个事件与我们在页面上执行的操作相关联，例如登录到
    Web 应用，以了解 Web 应用如何使用 API。我们能在攻击 API 前收集到的信息越多，找到并利用漏洞的机会就越大。
- en: For more information about DevTools, check out the Google Developers documentation
    at [https://developers.google.com/web/tools/chrome-devtools](https://developers.google.com/web/tools/chrome-devtools).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多有关 DevTools 的信息，请查看 Google 开发者文档：[https://developers.google.com/web/tools/chrome-devtools](https://developers.google.com/web/tools/chrome-devtools)。
- en: Capturing and Modifying Requests with Burp Suite
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Burp Suite 捕获和修改请求
- en: Burp Suite is a magnificent set of web application–testing tools developed and
    continuously improved on by PortSwigger. All web app cybersecurity professionals,
    bug bounty hunters, and API hackers should learn to use Burp, which allows you
    to capture API requests, spider web applications, fuzz APIs, and so much more.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 是一套由 PortSwigger 开发并不断改进的精彩 Web 应用测试工具。所有 Web 应用安全专家、漏洞奖励猎人和 API
    黑客都应该学习使用 Burp，它允许你捕获 API 请求、爬取 Web 应用、模糊测试 API 等等。
- en: '*Spidering*, or *web crawling*, is a method that bots use to automatically
    detect the URL paths and resources of a host. Typically, spidering is done by
    scanning the HTML of web pages for hyperlinks. Spidering is a good way to get
    a basic idea of the contents of a web page, but it won’t be able to find *hidden*
    paths, or the ones that do not have links found within web pages. To find hidden
    paths, we’ll need to use a tool like Kiterunner that effectively performs directory
    brute-force attacks. In such an attack, an application will request various possible
    URL paths and validate whether they actually exist based on the host’s responses.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*爬虫*，或称 *网页爬取*，是一种自动检测主机 URL 路径和资源的方法。通常，爬虫是通过扫描网页 HTML 中的超链接来完成的。爬虫是了解网页内容的一个好方法，但它无法找到
    *隐藏的* 路径，或者那些在网页中没有超链接的路径。要找到隐藏路径，我们需要使用像 Kiterunner 这样的工具，它能有效执行目录暴力攻击。在这种攻击中，应用会请求各种可能的
    URL 路径，并根据主机的响应验证这些路径是否存在。'
- en: As described by the OWASP community page on the topic, *fuzzing* is “the art
    of automatic bug finding.” Using this attack technique, we’d send various types
    of input in HTTP requests, trying to find an input or payload that causes an application
    to respond in unexpected ways and reveal a vulnerability. For example, if you
    were attacking an API and discovered you could post data to the API provider,
    you could then attempt to send it various SQL commands. If the provider doesn’t
    sanitize this input, there is a chance you could receive a response that indicates
    that a SQL database is in use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如 OWASP 社区页面所述，*模糊测试*是“自动寻找漏洞的艺术”。使用这种攻击技术，我们会向 HTTP 请求发送各种类型的输入，试图找到能够使应用以意外方式响应并暴露漏洞的输入或负载。例如，如果你在攻击
    API 时发现可以向 API 提供者发送数据，那么你可以尝试发送各种 SQL 命令。如果提供者没有对这些输入进行过滤，就有可能收到一个响应，表明 SQL 数据库正在使用中。
- en: Burp Suite Pro, the paid edition of Burp, provides all the features without
    restrictions, but if using the free Burp Suite Community Edition (CE) is your
    only option, you can make it work. However, once you’ve obtained a bug bounty
    reward or as soon as you can convince your employer, you should make the jump
    to Burp Suite Pro. This chapter includes a “Supplemental Tools” section that will
    help replace the functionality missing in Burp Suite CE.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite Pro 是 Burp 的付费版，提供所有功能且没有限制，但如果你只能使用免费的 Burp Suite Community Edition（CE），也是可以工作的。然而，一旦你获得了漏洞奖励，或者一旦能说服你的雇主，你应该升级到
    Burp Suite Pro。本章包含一个“补充工具”部分，帮助替代 Burp Suite CE 中缺失的功能。
- en: 'Burp Suite CE is included standard with the latest version of Kali. If for
    whatever reason it is not installed, run the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite CE已包含在最新版本的Kali中。如果由于某种原因未安装，可以运行以下命令：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the following sections, we will prepare our API hacking rig to use Burp Suite,
    look at an overview of the various Burp modules, learn how to intercept HTTP requests,
    dive deeper into the Intruder module, and go over some of the sweet extensions
    you can use to enhance Burp Suite Pro.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将准备我们的API攻击工具来使用Burp Suite，了解Burp各个模块的概况，学习如何拦截HTTP请求，深入研究Intruder模块，并了解一些可以用来增强Burp
    Suite Pro的扩展插件。
- en: Setting Up FoxyProxy
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置FoxyProxy
- en: One of Burp Suite’s key features is the ability to intercept HTTP requests.
    In other words, Burp Suite receives your requests before forwarding them to the
    server and then receives the server’s responses before sending them to the browser,
    allowing you to view and interact with those requests and responses. For this
    feature to work, we’ll need to regularly send requests from the browser to Burp
    Suite. This is done with the use of a web proxy. The proxy is a way for us to
    reroute web browser traffic to Burp before it is sent to the API provider. To
    simplify this process, we’ll add a tool called FoxyProxy to our browsers to help
    us proxy traffic with a click of a button.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite的一个关键特性是能够拦截HTTP请求。换句话说，Burp Suite会在将请求转发到服务器之前接收你的请求，然后在将服务器的响应发送到浏览器之前接收服务器的响应，这样你就可以查看并与这些请求和响应进行交互。为了使此功能正常工作，我们需要定期将请求从浏览器发送到Burp
    Suite。这是通过使用网络代理实现的。代理是一种将网页浏览器流量重定向到Burp的方式，然后再发送给API提供者。为了简化这个过程，我们将在浏览器中添加一个名为FoxyProxy的工具，帮助我们通过点击按钮来代理流量。
- en: Web browsers have proxy functionality built in, but changing and updating these
    settings every time you want to use Burp would be a time-consuming pain. Instead,
    we’ll use a browser add-on called FoxyProxy that lets you switch your proxy on
    and off with a simple click of a button. FoxyProxy is available for both Chrome
    and Firefox.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器自带代理功能，但每次想使用Burp时都要修改和更新这些设置会很麻烦。相反，我们将使用一个名为FoxyProxy的浏览器插件，它可以让你通过简单点击按钮开启和关闭代理。FoxyProxy支持Chrome和Firefox浏览器。
- en: 'Follow these steps to install FoxyProxy:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装FoxyProxy：
- en: Navigate to your browser’s add-on or plug-in store and search **FoxyProxy**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你的浏览器插件或扩展商店，搜索**FoxyProxy**。
- en: Install FoxyProxy Standard and add it to your browser.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装FoxyProxy Standard并将其添加到你的浏览器。
- en: Click the fox icon at the top-right corner of your browser (next to your URL)
    and select **Options**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击浏览器右上角的狐狸图标（在URL旁边），然后选择**选项**。
- en: Select **Proxies**▶**Add New Proxy**▶**Manual Proxy Configuration**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**代理**▶**添加新代理**▶**手动代理配置**。
- en: Add **127.0.0.1** as the host IP address.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**127.0.0.1**作为主机IP地址。
- en: Update the port to **8080** (Burp Suite’s default proxy settings).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新端口为**8080**（Burp Suite的默认代理设置）。
- en: Under the General tab, rename the proxy to **Hackz** (I will refer to this proxy
    setting throughout the labs).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“常规”标签下，将代理重命名为**Hackz**（在整个实验中我会引用这个代理设置）。
- en: Now you’ll only need to click the browser add-on and select the proxy you want
    to use to send your traffic to Burp. When you’ve finished intercepting requests,
    you can turn the proxy off by selecting the Disable FoxyProxy option.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要点击浏览器插件并选择你想使用的代理，将流量发送到Burp。当你完成拦截请求后，可以通过选择禁用FoxyProxy选项来关闭代理。
- en: Adding the Burp Suite Certificate
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加Burp Suite证书
- en: '*HTTP Strict Transport Security (HSTS)* is a common web application security
    policy that prevents Burp Suite from being able to intercept requests. Whether
    using Burp Suite CE or Burp Suite Pro, you will need to install Burp Suite’s certificate
    authority (CA) certificate. To add this certificate, follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP严格传输安全（HSTS）*是常见的Web应用程序安全策略，它阻止Burp Suite拦截请求。无论是使用Burp Suite CE还是Burp
    Suite Pro，你都需要安装Burp Suite的证书授权（CA）证书。要添加此证书，请按照以下步骤操作：'
- en: Start Burp Suite.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Burp Suite。
- en: Open your browser of choice.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你选择的浏览器。
- en: Using FoxyProxy, select the Hackz proxy. Navigate to *http://burpsuite*, as
    seen in [Figure 4-3](#figure4-3), and click **CA Certificate**. This will initiate
    the download of the Burp Suite CA certificate.![F04003](image_fi/502444c04/F04003.png)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用FoxyProxy，选择Hackz代理。导航至*http://burpsuite*，如[图4-3](#figure4-3)所示，点击**CA证书**。这将启动下载Burp
    Suite CA证书。![F04003](image_fi/502444c04/F04003.png)
- en: 'Figure 4-3: The landing page you should see when downloading Burp Suite’s CA
    certificate'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4-3：下载Burp Suite CA证书时应看到的登录页面
- en: Save the certificate somewhere you can find it.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将证书保存在你可以找到的位置。
- en: Open your browser and import the certificate. In Firefox, open **Preferences**
    and use the search bar to look up **certificates**. Import the certificate.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并导入证书。在 Firefox 中，打开 **偏好设置**，使用搜索框查找 **证书**，然后导入证书。
- en: In Chrome, open **Settings**, use the search bar to look up **certificates**,
    select **More**▶**Manage Certificates**▶**Authorities**, and import the certificate
    (see [Figure 4-4](#figure4-4)). If you do not see the certificate, you may need
    to expand the file type options to “DER” or “All files.”![F04004](image_fi/502444c04/F04004.png)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Chrome 中，打开 **设置**，使用搜索框查找 **证书**，选择 **更多**▶**管理证书**▶**授权机构**，然后导入证书（见 [图
    4-4](#figure4-4)）。如果没有看到证书，你可能需要将文件类型选项扩展为 “DER” 或 “所有文件”。![F04004](image_fi/502444c04/F04004.png)
- en: 'Figure 4-4: The Chrome Certificate Manager with the Authorities tab selected'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-4：选择了 Authorities 标签的 Chrome 证书管理器
- en: Now that you have the PortSwigger CA certificate added to your browser, you
    should be able to intercept traffic without experiencing issues.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 PortSwigger CA 证书添加到浏览器中，你应该能够正常拦截流量而不会遇到问题。
- en: Navigating Burp Suite
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览 Burp Suite
- en: As you can see in [Figure 4-5](#figure4-5), at the top of Burp are 13 modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [图 4-5](#figure4-5) 中所见，Burp 的顶部有 13 个模块。
- en: '![Screenshot of menu items including Comparer, Logger, Extender, Project options,
    User options, Learn, Dashboard, Target, Proxy, Intruder, Repeater, Sequencer,
    and Decoder](image_fi/502444c04/F04005.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![包含 Comparer、Logger、Extender、项目选项、用户选项、学习、Dashboard、Target、Proxy、Intruder、Repeater、Sequencer
    和 Decoder 的菜单项截图](image_fi/502444c04/F04005.png)'
- en: 'Figure 4-5: The Burp Suite modules'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：Burp Suite 模块
- en: The *Dashboard* gives you an overview of the event log and scans you have run
    against your targets. The Dashboard is more useful in Burp Suite Pro than in CE
    because it will also display any issues detected during testing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dashboard* 提供了对事件日志和你针对目标运行的扫描的概览。在 Burp Suite Pro 中，Dashboard 比在 CE 中更有用，因为它还会显示测试过程中检测到的任何问题。'
- en: The *Proxy* tab is where we will begin capturing requests and responses from
    your web browser and Postman. The proxy we set up will send any web traffic destined
    for your browser here. We will typically choose to forward or drop captured traffic
    until we find the targeted site that we want to interact with. From Proxy we will
    forward the request or response to other modules for interaction and tampering.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Proxy* 标签是我们开始捕获来自 Web 浏览器和 Postman 的请求和响应的地方。我们设置的代理将把任何发往你浏览器的 Web 流量发送到这里。我们通常会选择转发或丢弃捕获的流量，直到找到我们希望与之交互的目标站点。从
    Proxy，我们将请求或响应转发到其他模块进行交互和篡改。'
- en: In the *Target* tab,we can see a site’s map and manage the targets we intend
    to attack. You can also use this tab to configure the scope of your testing by
    selecting the Scope tab and including or excluding URLs. Including URLs within
    scope will limit the URLs being attacked to only those you have authorization
    to attack.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Target* 标签中，我们可以看到网站的地图并管理我们打算攻击的目标。你还可以使用此标签通过选择 Scope 标签来配置测试范围，并包括或排除
    URL。将 URL 包含在范围内将限制被攻击的 URL 仅限于你有权限攻击的那些。
- en: While using the Target tab, you should be able to locate the *Site Map*, where
    you can see all the URLs Burp Suite has detected during your current Burp Suite
    session. As you perform scans, crawl, and proxy traffic, Burp Suite will start
    compiling a list of the target web applications and discovered directories. This
    is another place you can add or remove URLs from scope.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Target 标签时，你应该能够找到 *Site Map*，在这里你可以看到 Burp Suite 在当前会话中检测到的所有 URL。当你执行扫描、爬虫或代理流量时，Burp
    Suite 会开始编译目标 Web 应用程序和已发现目录的列表。这是另一个可以添加或移除 URL 的地方。
- en: The *Intruder* tab is where we’ll perform fuzzing and brute-force attacks against
    web applications. Once you’ve captured an HTTP request, you can forward it to
    Intruder, where you can select the exact parts of the request that you want to
    replace with the payload of your choice before sending it to the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*Intruder* 标签是我们将执行模糊测试和暴力破解攻击的地方。一旦你捕获了 HTTP 请求，就可以将其转发到 Intruder，在那里你可以选择请求中要替换为有效载荷的具体部分，然后再将其发送到服务器。'
- en: The *Repeater* is a module that lets you make hands-on adjustments to HTTP requests,
    send them to the targeted web server, and analyze the content of the HTTP response.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*Repeater* 是一个模块，允许你对 HTTP 请求进行实际操作，发送它们到目标 Web 服务器，并分析 HTTP 响应的内容。'
- en: The *Sequencer* tool will automatically send hundreds of requests and then perform
    an analysis of entropy to determine how random a given string is. We will primarily
    use this tool to analyze whether cookies, tokens, keys, and other parameters are
    actually random.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sequencer* 工具将自动发送数百个请求，并通过熵分析来判断给定字符串的随机性。我们主要使用该工具分析 cookies、令牌、密钥和其他参数是否真正具有随机性。'
- en: The *Decoder* is a quick way to encode and decode HTML, base64, ASCII hex, hexadecimal,
    octal, binary, and Gzip.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*Decoder* 是一种快速编码和解码 HTML、base64、ASCII 十六进制、十六进制、八进制、二进制和 Gzip 的方式。'
- en: The *Comparer* can be used to compare different requests. Most often, you’ll
    want to compare two similar requests and find the sections of the request that
    have been removed, added, and modified.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Comparer* 可用于比较不同的请求。通常情况下，你会希望比较两个相似的请求，并找出其中被移除、添加或修改的部分。'
- en: If Burp Suite is too bright for your hacker eyes, navigate to **User options**▶**Display**
    and change **Look and Feel** to **Darcula**. Within the User Options tab, you
    can also find additional connection configurations, TLS settings, and miscellaneous
    options to learn hotkey shortcuts or configure your own hotkeys. You can then
    save your preferred settings using Project Options, which allows you to save and
    load specific configurations you like to use per project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Burp Suite 对你的黑客眼睛来说太亮了，可以前往 **用户选项**▶**显示**，将 **外观** 改为 **Darcula**。在用户选项标签下，你还可以找到其他连接配置、TLS
    设置以及一些杂项选项，用来学习快捷键或配置你自己的快捷键。然后，你可以通过项目选项保存你的首选设置，这允许你为每个项目保存和加载特定的配置。
- en: '*Learn* is an awesome set of resources to help you learn how to use Burp Suite.
    This tab contains video tutorials, the Burp Suite Support Center, a guided tour
    of Burp’s features, and a link to the PortSwigger Web Security Academy. Definitely
    check these resources out if you are new to Burp!'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*Learn* 是一套精彩的资源，帮助你学习如何使用 Burp Suite。这个标签包含视频教程、Burp Suite 支持中心、Burp 功能的引导式介绍，以及
    PortSwigger Web 安全学院的链接。如果你是 Burp 新手，强烈建议你查看这些资源！'
- en: Under the Dashboard you can find the Burp Suite Pro Scanner. *Scanner* is Burp
    Suite Pro’s web application vulnerability scanner. It lets you automatically crawl
    web applications and scan for weaknesses.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在仪表板下，你可以找到 Burp Suite Pro 扫描器。*Scanner* 是 Burp Suite Pro 的 web 应用漏洞扫描器。它可以自动爬取
    web 应用并扫描漏洞。
- en: The*Extender* is where we’ll obtain and use Burp Suite extensions. Burp has
    an app store that allows you to find add-ons to simplify web app testing. Many
    extensions require Burp Suite Pro, but we will make the most of the free extensions
    to turn Burp into an API hacking powerhouse.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*Extender* 是我们获取和使用 Burp Suite 扩展的地方。Burp 有一个应用商店，允许你找到简化 Web 应用测试的插件。许多扩展需要
    Burp Suite Pro，但我们将充分利用免费的扩展，将 Burp 打造成一个 API 破解强大工具。'
- en: Intercepting Traffic
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拦截流量
- en: 'A Burp Suite session will usually begin with intercepting traffic. If you’ve
    set up FoxyProxy and the Burp Suite certificate correctly, the following process
    should work smoothly. You can use these instructions to intercept any HTTP traffic
    with Burp Suite:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一次 Burp Suite 会话通常从拦截流量开始。如果你已经正确设置了 FoxyProxy 和 Burp Suite 证书，那么以下过程应该会顺利进行。你可以按照这些步骤用
    Burp Suite 拦截任何 HTTP 流量：
- en: Start Burp Suite and change the Intercept option to **Intercept is** **on**
    ‌(see [Figure 4-6](#figure4-6)).![F04006](image_fi/502444c04/F04006.png)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Burp Suite 并将拦截选项更改为 **拦截已开启** ‌（参见 [图 4-6](#figure4-6)）。![F04006](image_fi/502444c04/F04006.png)
- en: 'Figure 4-6: Intercept is on in Burp Suite.'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-6：Burp Suite 中拦截已开启。
- en: In your browser, select the Hackz proxy using FoxyProxy and browse to your target,
    such as [https://twitter.com](https://twitter.com) (see [Figure 4-7](#figure4-7)).
    This web page will not load in the browser because it was never sent to the server;
    instead, the request should be waiting for you in Burp Suite.![F04007](image_fi/502444c04/F04007.png)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，使用 FoxyProxy 选择 Hackz 代理并访问你的目标网站，比如 [https://twitter.com](https://twitter.com)（参见
    [图 4-7](#figure4-7)）。该网页不会在浏览器中加载，因为它从未发送到服务器；相反，请求应该会等待你在 Burp Suite 中处理。![F04007](image_fi/502444c04/F04007.png)
- en: 'Figure 4-7: The request to Twitter gets sent to Burp Suite via the Hackz proxy.'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-7：通过 Hackz 代理，向 Burp Suite 发送的 Twitter 请求。
- en: In Burp Suite, you should see something much like [Figure 4-8](#figure4-8).
    This should let you know that you’ve successfully intercepted an HTTP request.![F04008](image_fi/502444c04/F04008.png)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Burp Suite 中，你应该会看到类似于 [图 4-8](#figure4-8) 的内容。这应该能告诉你，你已成功拦截了一个 HTTP 请求。![F04008](image_fi/502444c04/F04008.png)
- en: 'Figure 4-8: An HTTP request to Twitter intercepted by Burp Suite'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-8：Burp Suite 拦截的 Twitter HTTP 请求
- en: Once you’ve captured a request, you can select an action to perform with it,
    such as forwarding the intercepted request to the various Burp Suite modules.
    You perform actions by clicking the Action button above the request pane or by
    right-clicking the request window. You will then have the option to forward the
    request to one of the other modules, such as Repeater (see [Figure 4-9](#figure4-9)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获请求后，你可以选择对其执行某些操作，比如将截获的请求转发到Burp Suite的其他模块。你可以通过点击请求窗格上方的“操作”按钮，或者右键点击请求窗口来执行操作。然后，你将有机会将请求转发到其他模块，例如Repeater（参见[图4-9](#figure4-9)）。
- en: '![Screenshot of the an HTTP request and corresponding response in a Burp Suite
    interface with a Send button](image_fi/502444c04/F04009.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite界面中显示HTTP请求和对应响应的截图，包含发送按钮](image_fi/502444c04/F04009.png)'
- en: 'Figure 4-9: Burp Suite Repeater'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-9：Burp Suite Repeater
- en: The Repeater module is the best way to see how a web server responds to a single
    request. This is useful for seeing what sort of response you can expect to get
    from an API before initiating an attack. It’s also helpful when you need to make
    minor changes to a request and want to see how the server responds.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Repeater模块是查看Web服务器如何响应单个请求的最佳方式。这对于在发起攻击之前了解API可能的响应非常有用。它也有助于你在需要对请求进行细微修改并查看服务器响应时使用。
- en: Altering Requests with Intruder
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Intruder修改请求
- en: We’ve already mentioned that Intruder is a web application fuzzing and scanning
    tool. It works by letting you create variables within an intercepted HTTP request,
    replace those variables with different sets of payloads, and send a series of
    requests to an API provider.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，Intruder是一个Web应用程序模糊测试和扫描工具。它的工作原理是让你在截获的HTTP请求中创建变量，将这些变量替换为不同的Payload集，并向API提供者发送一系列请求。
- en: Any part of a captured HTTP request can be transformed into a variable, or *attack
    position*, by surrounding it with **§** symbols. Payloads can be anything from
    a wordlist to a set of numbers, symbols, and any other type of input that will
    help you test how an API provider will respond. For example, in [Figure 4-10](#figure4-10),
    we’ve selected the password as the attack position, as indicated by the § symbols.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获的HTTP请求的任何部分都可以通过用**§**符号将其包围来转换为变量或*攻击位置*。Payload可以是从字典列表到一组数字、符号，甚至是任何其他有助于你测试API响应类型的输入。例如，在[图4-10](#figure4-10)中，我们已将密码选择为攻击位置，正如§符号所示。
- en: '![Screenshot of the Burp Suite Positions tab with a payload position set around
    the password field and the Sniper attack type selected](image_fi/502444c04/F04010.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Positions标签页的截图，密码字段周围设置了Payload位置，并选择了Sniper攻击类型](image_fi/502444c04/F04010.png)'
- en: 'Figure 4-10: An Intruder attack against api.twitter.com'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-10：针对api.twitter.com的Intruder攻击
- en: This means that `SuperPass321!` will be replaced with values from the list of
    strings found in Payloads. Navigate to the Payloads tab to see these strings,
    shown in [Figure 4-11](#figure4-11).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`SuperPass321!`将会被从Payloads中的字符串列表中替换。前往Payloads标签页查看这些字符串，如[图4-11](#figure4-11)所示。
- en: '![Screenshot of the Burp Suite Payloads tab with a Payload Options box that
    lists strings such as Password1, Password2, APIhacking4tw, and more](image_fi/502444c04/F04011.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Payloads标签页的截图，显示一个列出字符串（如Password1、Password2、APIhacking4tw等）的Payload
    Options框](image_fi/502444c04/F04011.png)'
- en: 'Figure 4-11: The Intruder Payloads with a list of passwords'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-11：Intruder的Payloads，显示了一系列密码列表
- en: Based on the payload list shown here, Intruder will perform one request per
    payload listed for a total of nine requests. When an attack is started, each of
    the strings under Payload Options will replace `SuperPass123!` in turn and generate
    a request to the API provider.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这里展示的Payload列表，Intruder会针对列出的每个Payload执行一次请求，总共进行九次请求。当攻击开始时，Payload选项下的每个字符串会依次替换`SuperPass123!`，并生成请求发送到API提供者。
- en: 'The Intruder attack types determine how the payloads are processed. As you
    can see in [Figure 4-12](#figure4-12), there are four different attack types:
    sniper, battering ram, pitchfork, and cluster bomb.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Intruder攻击类型决定了Payload如何处理。正如在[图4-12](#figure4-12)中所见，攻击类型有四种：狙击手、重锤、叉子和集束炸弹。
- en: '![Screenshot of the Burp Suite Positions Tab with Sniper selected in the Attack
    type field](image_fi/502444c04/F04012.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Positions标签页的截图，攻击类型字段中选择了Sniper](image_fi/502444c04/F04012.png)'
- en: 'Figure 4-12: The Intruder attack types'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-12：Intruder攻击类型
- en: '*Sniper* is the simplest attack type; it replaces the added attack position
    with a string provided from a single set of payloads. A sniper attack is limited
    to using a single payload, but it can have several attack positions. A sniper
    attack will replace one attack position per request, cycling through the different
    attack positions in each request. If you were attacking three different variables
    with a single payload, it would look something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*狙击手*是最简单的攻击类型；它将新增的攻击位置替换为从单一有效载荷集合中提供的字符串。狙击手攻击仅使用单一的有效载荷，但可以有多个攻击位置。狙击手攻击将在每个请求中替换一个攻击位置，循环通过每个请求中的不同攻击位置。如果你用单一有效载荷攻击三个不同的变量，它可能会是这样：'
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Battering ram* is like the sniper attack in that it also uses one payload,
    but it will use that payload across all attack positions in a request. If you
    were testing for SQL injection across several input positions within a request,
    you could fuzz them all simultaneously with battering ram.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*冲击锤*类似于狙击手攻击，因为它也使用单一的有效载荷，但它会在请求中的所有攻击位置上使用该有效载荷。如果你正在测试请求中的多个输入位置上的SQL注入漏洞，你可以通过冲击锤同时对它们进行模糊测试。'
- en: '*Pitchfork* is used for testing multiple payload combinations at the same time.
    For example, if you have a list of leaked usernames and password combinations,
    you could use two payloads together to test whether any of the credentials were
    used with the application being tested. However, this attack doesn’t try out different
    combinations of payloads; it will only cycle through the payload sets like this:
    *user1:pass1*, *user2:pass2*, *user3:pass3*.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*叉形攻击*用于同时测试多个有效载荷组合。例如，如果你有一个泄露的用户名和密码组合列表，你可以将两个有效载荷一起使用，测试这些凭证是否在正在测试的应用程序中被使用。然而，这种攻击并不会尝试不同的有效载荷组合；它只会按以下方式循环通过有效载荷集：*user1:pass1*，*user2:pass2*，*user3:pass3*。'
- en: '*Cluster bomb* will cycle through all possible combinations of the payloads
    provided. If you provide two usernames and three passwords, the payloads would
    be used in the following pairs: *user1:pass1*, *user1:pass2*, *user1:pass3*, *user2:pass1*,
    *user2:pass2*, *user2:pass3*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*集群炸弹*会循环通过所有提供的有效载荷的可能组合。如果你提供了两个用户名和三个密码，以下的组合会被使用：*user1:pass1*，*user1:pass2*，*user1:pass3*，*user2:pass1*，*user2:pass2*，*user2:pass3*。'
- en: The attack type to use depends on your situation. If you’re fuzzing a single
    attack position, use sniper. If you’re fuzzing several attack positions at once,
    use battering ram. When you need to test set combinations of payloads, use pitchfork.
    For password-spraying efforts, use cluster bomb.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种攻击类型取决于你的情况。如果你正在模糊测试单一的攻击位置，使用狙击手。如果你要同时对多个攻击位置进行模糊测试，使用冲击锤。当你需要测试一组有效载荷的组合时，使用叉形攻击。对于密码喷射攻击，使用集群炸弹。
- en: Intruder should help you find API vulnerabilities such as broken object level
    authorization, excessive data exposure, broken authentication, broken function
    level authorization, mass assignment, injection, and improper assets management.
    Intruder is essentially a smart fuzzing tool that provides a list of results containing
    the individual requests and responses. You can interact with the request you’d
    like to fuzz and replace the attack position with the input of your choice. These
    API vulnerabilities are typically discovered by sending the right payload to the
    right location.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Intruder 应该帮助你找到 API 漏洞，如破损的对象级授权、过度的数据暴露、破损的身份验证、破损的功能级授权、大规模赋值、注入和不当的资产管理。Intruder
    本质上是一个智能模糊测试工具，它提供包含单个请求和响应的结果列表。你可以与你想要模糊测试的请求进行交互，并用你选择的输入替换攻击位置。这些 API 漏洞通常是通过将正确的有效载荷发送到正确的位置来发现的。
- en: For example, if an API were vulnerable to authorization attacks like BOLA, we
    would be able to replace requested resource IDs with a payload containing a list
    of possible resource IDs. We could then start the attack with Intruder, which
    would make all the requests and provide us with a list of results to review. I
    will cover API fuzzing in Chapter 9 and API authorization attacks in Chapter 10.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个 API 对像 BOLA 这样的授权攻击存在漏洞，我们就能够用一个包含可能资源 ID 列表的有效载荷来替换请求的资源 ID。然后我们可以用
    Intruder 发起攻击，Intruder 会发出所有请求并为我们提供一个结果列表供审查。我将在第 9 章讨论 API 模糊测试，第 10 章讨论 API
    授权攻击。
- en: Crafting API Requests in Postman, an API Browser
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Postman 中构造 API 请求，一个 API 浏览器
- en: We’ll use Postman to help us craft API requests and visualize responses. You
    can think of Postman as a web browser built for interacting with APIs. Originally
    designed as a REST API client, it now has all sorts of capabilities for interacting
    with REST, SOAP, and GraphQL. The application is packed with features for creating
    HTTP requests, receiving responses, scripting, chaining requests together, creating
    automated testing, and managing API documentation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Postman 来帮助我们构建 API 请求并可视化响应。您可以将 Postman 看作是一个专为与 API 交互而设计的 Web 浏览器。最初作为
    REST API 客户端设计，它现在具备与 REST、SOAP 和 GraphQL 交互的各种能力。该应用程序具有创建 HTTP 请求、接收响应、脚本编写、链式请求、自动化测试和管理
    API 文档等众多功能。
- en: We’ll be using Postman as our browser of choice for sending API requests to
    a server, rather than defaulting to Firefox or Chrome. This section covers the
    Postman features that matter the most and includes instructions for using the
    Postman request builder, an overview of working with collections, and some basics
    around building request tests. Later in this chapter, we will configure Postman
    to work seamlessly with Burp Suite.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Postman 作为我们发送 API 请求到服务器的首选浏览器，而不是默认使用 Firefox 或 Chrome。本节将介绍 Postman
    中最重要的功能，并包括使用 Postman 请求构建器的说明、与集合合作的概述，以及构建请求测试的一些基础知识。稍后在本章中，我们将配置 Postman 以便与
    Burp Suite 无缝协作。
- en: 'To set up Postman on Kali, open your terminal and enter the following commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kali 上设置 Postman，请打开终端并输入以下命令：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If everything has gone as planned, you should be able to launch Postman by entering
    `postman` in your terminal. Sign up for a free account using an email address,
    username, and password. Postman uses accounts for collaboration and to synchronize
    information across devices. Alternatively, you can skip the login screen by clicking
    the **Skip signing in and take me straight to the app** button.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，您应该能够通过在终端中输入`postman`来启动 Postman。使用电子邮件地址、用户名和密码注册一个免费帐户。Postman
    使用帐户进行协作并在设备之间同步信息。或者，您可以通过点击**跳过登录并直接进入应用程序**按钮跳过登录界面。
- en: Next, you’ll need to go through the FoxyProxy setup process a second time (refer
    to the “Setting Up FoxyProxy” section earlier in this chapter) so that Postman
    can intercept requests. Return to step 4 and add a new proxy. Add the same host
    IP address, **127.0.0.1**, and set the port to **5555**, the default port for
    Postman’s proxy. Update the name of the proxy under the General tab to **Postman**
    and save. Your FoxyProxy tab should now resemble [Figure 4-13](#figure4-13).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要再次完成 FoxyProxy 设置过程（请参考本章前面的“设置 FoxyProxy”部分），以便 Postman 可以拦截请求。返回到步骤
    4 并添加一个新代理。添加相同的主机 IP 地址，**127.0.0.1**，并将端口设置为**5555**，这是 Postman 代理的默认端口。在常规选项卡下更新代理的名称为**Postman**并保存。您的
    FoxyProxy 标签现在应类似于[图 4-13](#figure4-13)。
- en: '![Screenshot of the FoxyProxy interface with the Hackz, Postman, and Default
    proxies enabled](image_fi/502444c04/F04013.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![FoxyProxy 界面截图，显示了启用了 Hackz、Postman 和默认代理](image_fi/502444c04/F04013.png)'
- en: 'Figure 4-13: FoxyProxy with the Hackz and Postman proxies set up'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-13：配置 Hackz 和 Postman 代理的 FoxyProxy
- en: From the launchpad, open a new tab just like you would in any other browser
    by clicking the new tab button (+) or using the ctrl-T shortcut. As you can see
    in [Figure 4-14](#figure4-14), Postman’s interface can be a little overwhelming
    if you aren’t familiar with it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从启动板打开一个新标签页，就像在其他浏览器中一样，通过点击新标签按钮（+）或使用 ctrl-T 快捷键。如[图 4-14](#figure4-14)所示，如果您不熟悉
    Postman 的界面，它可能会有点令人不知所措。
- en: '![Screenshot of the Postman interface with many windows and menu items displaying
    GET requests and JSON data](image_fi/502444c04/F04014.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 界面截图，显示了许多窗口和菜单项，展示了 GET 请求和 JSON 数据](image_fi/502444c04/F04014.png)'
- en: 'Figure 4-14: The main landing page of Postman with a response from an API collection'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-14：Postman 的主登录页面，显示来自 API 集合的响应
- en: Let’s start by discussing the request builder, which you’ll see when you open
    a new tab.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论请求构建器开始，当您打开一个新标签时，您将看到它。
- en: The Request Builder
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求构建器
- en: The request builder, shown in [Figure 4-15](#figure4-15), is where you can craft
    each request by adding parameters, authorization headers, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请求构建器，如[图 4-15](#figure4-15)所示，是您可以通过添加参数、授权头等来构建每个请求的地方。
- en: '![Screenshot of Postman interface with a form field for entering a request
    URL, a drop-down menu allowing you to select an HTTP method, and a Send button](image_fi/502444c04/F04015.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 界面截图，显示了输入请求 URL 的表单字段、允许选择 HTTP 方法的下拉菜单和一个发送按钮](image_fi/502444c04/F04015.png)'
- en: 'Figure 4-15: The Postman request builder'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-15：Postman 请求构建器
- en: The request builder contains several tabs useful for precisely constructing
    the parameters, headers, and body of a request. The *Params* tab is where you
    can add query and path parameters to a request. Essentially, this allows you to
    enter in various key/value pairs along with a description of those parameters.
    A great feature of Postman is that you can leverage the power of variables when
    creating your requests. If you import an API and it contains a variable like *:company*
    in *http://example.com/****:company****/profile*, Postman will automatically detect
    this and allow you to update the variable to a different value, such as the actual
    company name. We’ll discuss collections and environments later in this section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请求构建器包含几个有助于精确构建请求参数、头信息和正文的标签。*Params* 标签是您可以在请求中添加查询和路径参数的地方。基本上，这允许您输入各种键值对，并附上这些参数的描述。Postman
    的一个优秀功能是，当创建请求时，您可以利用变量的强大功能。如果您导入了一个 API，并且它包含像 *:company* 这样的变量，出现在 *http://example.com/****:company****/profile*
    中，Postman 会自动检测到这一点，并允许您将变量更新为不同的值，例如实际的公司名称。我们将在本节稍后讨论集合和环境。
- en: The *Authorization* tab includes many standard forms of authorization headers
    for you to include in your request. If you’ve saved a token in an environment,
    you can select the type of token and use the variable’s name to include it. By
    hovering your mouse over a variable name, you can see the associated credentials.
    Several authorization options are available under the Type field that will help
    you automatically format the authorization header. Authorization types include
    several expected options such as no auth, API key, Bearer Token, and Basic Auth.
    In addition, you could use the authorization that is set for the entire collection
    by selecting **inherit auth from parent**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Authorization* 标签页包含多种标准的授权头，供您在请求中使用。如果您已在环境中保存了一个令牌，您可以选择令牌类型，并使用变量名称来包含它。将鼠标悬停在变量名称上时，您可以看到相关的凭据。在
    Type 字段下，有几种授权选项可以帮助您自动格式化授权头。授权类型包括一些常见的选项，如无身份验证、API 密钥、Bearer Token 和 Basic
    Auth。此外，您还可以选择通过选择 **inherit auth from parent** 来使用为整个集合设置的授权。'
- en: The *Headers* tab includes the key and value pairs required for certain HTTP
    requests. Postman has some built-in functionality to automatically create necessary
    headers and to suggest common headers with preset options.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*Headers* 标签页包含某些 HTTP 请求所需的键值对。Postman 具有一些内置功能，可以自动创建必要的头信息，并提供常见头信息的预设选项。'
- en: In Postman, values for parameters, headers, and parts of body work can be added
    by entering information within the Key column and the corresponding Value column
    (see [Figure 4-16](#figure4-16)). Several headers will automatically be created,
    but you can add your own headers when necessary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中，参数、头信息和正文部分的值可以通过在 Key 列和相应的 Value 列中输入信息来添加（请参见 [图 4-16](#figure4-16)）。一些头信息会自动创建，但在必要时您可以添加自己的头信息。
- en: Within the keys and values, you also have the ability to use collection variables
    and environmental variables. (We’ll cover collections later in this section.)
    For example, we’ve represented the value for the password key using the variable
    name `{admin_creds}`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在键值对中，您还可以使用集合变量和环境变量。（我们稍后会介绍集合。）例如，我们使用变量名称 `{admin_creds}` 来表示密码键的值。
- en: '![Screenshot of the Postman Headers tab displaying a table with two columns,
    Key and Value. The Key column includes headers such as User-Agent and Content-Type,
    and the values include endpoints, such as PostmanRuntime/7.28.3.](image_fi/502444c04/F04016.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Postman Headers 标签页的截图，显示了一个包含两个列（Key 和 Value）的表格。Key 列包括 User-Agent 和 Content-Type
    等标题，Value 列包括 PostmanRuntime/7.28.3 等端点。](image_fi/502444c04/F04016.png)'
- en: 'Figure 4-16: Postman key and value headers'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-16：Postman 键值头信息
- en: The request builder can also run pre-request scripts, which can chain together
    different requests that depend on each other. For example, if request 1 issues
    a resource value that is needed for the following request, you can script that
    resource value to automatically be added to request 2.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请求构建器还可以运行预请求脚本，这可以将不同的请求链式连接在一起，互相依赖。例如，如果请求 1 返回一个资源值，而该资源值是后续请求所需的，您可以通过脚本将该资源值自动添加到请求
    2 中。
- en: Within Postman’s request builder, you can use several panels to craft proper
    API requests and review responses. Once you’ve sent a request, the response will
    show up in the response panel (see [Figure 4-17](#figure4-17)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '在Postman的请求构建器中，你可以使用多个面板来构造合适的API请求并查看响应。一旦你发送了请求，响应会显示在响应面板中（见[图4-17](#figure4-17)）。 '
- en: '![Screenshot of Postman interface showing Body and Headers tabs and a Status
    Code bar](image_fi/502444c04/F04017.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Postman界面的截图，显示正文和请求头标签以及状态码栏](image_fi/502444c04/F04017.png)'
- en: 'Figure 4-17: The Postman request and response panels'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-17：Postman请求和响应面板
- en: You can set the response panel either to the right or below the request panel.
    By pressing ctrl-alt-V, you can switch the request and response panels between
    single-pane and split-pane views.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将响应面板设置为位于请求面板的右侧或下方。通过按ctrl-alt-V，你可以在单窗格视图和拆分窗格视图之间切换请求和响应面板。
- en: In [Table 4-2](#table4-2), I have separated the items into the request panels
    and the response panels.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表4-2](#table4-2)中，我已将项目分为请求面板和响应面板。
- en: 'Table 4-2: Request Builder Panels'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2：请求构建器面板
- en: '| **Panel** | **Purpose** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **面板** | **用途** |'
- en: '| --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *Request* |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| *请求* |'
- en: '| HTTP request method | The request method is found to the left of the request
    URL bar (at the top left of [Figure 4-17](#figure4-17) where there is a drop-down
    menu for GET). The options include all the standard requests: GET, POST, PUT,
    PATCH, DELETE, HEAD, and OPTIONS. It also includes several other request methods
    such as COPY, LINK, UNLINK, PURGE, LOCK, UNLOCK, PROPFIND, and VIEW. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| HTTP请求方法 | 请求方法位于请求URL栏的左侧（在[图4-17](#figure4-17)的左上角，有一个GET的下拉菜单）。选项包括所有标准请求：GET、POST、PUT、PATCH、DELETE、HEAD和OPTIONS。它还包括其他一些请求方法，如COPY、LINK、UNLINK、PURGE、LOCK、UNLOCK、PROPFIND和VIEW。
    |'
- en: '| Body | In [Figure 4-17](#figure4-17), this is the third tab in the request
    pane. This allows for adding body data to the request, which is primarily used
    for adding or updating data when using PUT, POST, or PATCH. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 正文 | 在[图4-17](#figure4-17)中，这是请求面板中的第三个标签页。它允许向请求中添加正文数据，主要用于在使用PUT、POST或PATCH时添加或更新数据。
    |'
- en: '| Body options | Body options are the format of the response. These are found
    below the Body tab when it is selected. The options currently include none, form-data,
    x-www-formurlencoded, raw, binary, and GraphQL. These options let you view response
    data in various forms. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 正文选项 | 正文选项是响应的格式。这些选项位于选中正文标签时下面。目前的选项包括无、表单数据、x-www-formurlencoded、原始、二进制和GraphQL。这些选项让你以不同的形式查看响应数据。
    |'
- en: '| Pre-request script | JavaScript-based scripts that can be added and executed
    before a request is sent. This can be used to create variables, help troubleshoot
    errors, and change request parameters. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 请求前脚本 | 基于JavaScript的脚本，可以在发送请求之前添加并执行。这可用于创建变量、帮助排查错误以及更改请求参数。 |'
- en: '| Test | This space allows for writing JavaScript-based tests used to analyze
    and test the API response. This is used to make sure the API responses are functioning
    as anticipated. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 这个区域允许编写基于JavaScript的测试，用于分析和测试API响应。它用于确保API响应按预期工作。 |'
- en: '| Settings | Various settings for how Postman will handle requests. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 设置 | 各种设置，用于控制Postman如何处理请求。 |'
- en: '| *Response* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| *响应* |'
- en: '| Response body | The body of the HTTP response. If Postman were a typical
    web browser, this would be the main window to view the requested information.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 响应正文 | HTTP响应的正文。如果Postman是一个典型的网页浏览器，这将是查看请求信息的主窗口。 |'
- en: '| Cookies | This shows all the cookies, if any, included with the HTTP response.
    This tab will include information about the cookie type, cookie value, path, expiration,
    and cookie security flags. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| Cookies | 这显示了HTTP响应中包含的所有cookie（如果有的话）。该标签会包含关于cookie类型、cookie值、路径、过期时间和cookie安全标志的信息。
    |'
- en: '| Headers | This is where all the HTTP response headers are located. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 请求头 | 这是所有HTTP响应头所在的位置。 |'
- en: '| Test results | If you created any tests for your request, this is where you
    can view the results of those tests. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 测试结果 | 如果你为请求创建了任何测试，可以在这里查看这些测试的结果。 |'
- en: Environments
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境
- en: An *environment* provides a way to store and use the same variables across APIs.
    An *environmental variable* is a value that will replace a variable across an
    environment. For example, say you’re attacking a production API but discover a
    *test* version of the production API as well; you’ll likely want to use an environment
    to share values between your requests to the two APIs. After all, there is a chance
    the production and test APIs share values such as API tokens, URL paths, and resource
    IDs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*环境*提供了一种在多个 API 之间存储和使用相同变量的方法。*环境变量*是一个值，它将在环境中替代一个变量。例如，假设你正在攻击一个生产环境的 API，但发现了一个生产环境的*测试*版本；你可能会希望使用环境来在两个
    API 的请求之间共享值。毕竟，生产 API 和测试 API 可能共享诸如 API 令牌、URL 路径和资源 ID 等值。'
- en: To create environmental variables, find **Environment** at the top right of
    the request builder (the drop-down menu that says “No Environment” by default)
    and then press ctrl-N to bring up the **Create New** panel and select **Environment**,
    as shown in [Figure 4-18](#figure4-18).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建环境变量，找到请求构建器右上角的**环境**（默认显示为“无环境”的下拉菜单），然后按 ctrl-N 打开**创建新**面板并选择**环境**，如[图
    4-18](#figure4-18)所示。
- en: '![Screenshot of the Postman Create New menu with the Environment option highlighted](image_fi/502444c04/F04018.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 创建新菜单的截图，突出显示了环境选项](image_fi/502444c04/F04018.png)'
- en: 'Figure 4-18: The Create New panel in Postman'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-18：Postman 中的创建新面板
- en: You can give an environment variable both an initial value and a current value
    (see [Figure 4-19](#figure4-19)). An *initial value* will be shared if you share
    your Postman environment with a team, whereas a current value is not shared and
    is only stored locally. For example, if you have a private key, you can store
    the private key as the current value. Then you will be able to use the variable
    in places where you would have to paste the private key.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为环境变量设置初始值和当前值（参见[图 4-19](#figure4-19)）。*初始值*会在你与团队共享 Postman 环境时共享，而当前值则不会共享，仅保存在本地。例如，如果你有一个私钥，你可以将私钥存储为当前值。这样，你就能在需要粘贴私钥的地方使用该变量。
- en: '![Screenshot of the Postman Manage Environments window with the admin_credz
    variable and its current value](image_fi/502444c04/F04019.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 管理环境窗口的截图，展示了 admin_credz 变量及其当前值](image_fi/502444c04/F04019.png)'
- en: 'Figure 4-19: The Manage Environments window in Postman showing the variable
    `admin_creds` with a current value of `This_``i``s_hidd3n`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-19：Postman 中的管理环境窗口，展示了变量 `admin_creds`，其当前值为 `This_``i``s_hidd3n`
- en: Collections
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: '*Collections* are groups of API requests that can be imported into Postman.
    If an API provider offers a collection, you won’t have to physically type in every
    single request. Instead, you can just import its collection. The best way to understand
    this functionality is to download a public API collection to your Postman from
    [https://www.postman.com/explore/collections](https://www.postman.com/explore/collections).
    For examples throughout this section, I will be referencing the Age of Empires
    II collection.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是可以导入到 Postman 中的一组 API 请求。如果 API 提供者提供了集合，你就不必手动输入每个请求。相反，你只需要导入它的集合。理解这个功能的最佳方式是从
    [https://www.postman.com/explore/collections](https://www.postman.com/explore/collections)
    下载一个公共 API 集合到你的 Postman。在本节的示例中，我将引用《帝国时代 II》集合。'
- en: The Import button lets you import collections, environments, and API specifications.
    Currently, Postman supports OpenAPI 3.0, RAML 0.8, RAML 1.0, GraphQL, cURL, WADL,
    Swagger 1.2, Swagger 2.0, Runscope, and DHC. You can make your testing quite a
    bit easier if you can import your target API specification. Doing this will save
    you the time of having to craft all the API requests by hand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 导入按钮允许你导入集合、环境和 API 规范。目前，Postman 支持 OpenAPI 3.0、RAML 0.8、RAML 1.0、GraphQL、cURL、WADL、Swagger
    1.2、Swagger 2.0、Runscope 和 DHC。如果你能导入目标 API 规范，你的测试工作将变得更轻松。这样做可以节省你手动编写所有 API
    请求的时间。
- en: 'Collections, environments, and specifications can all be imported as a file,
    folder, link, or raw test or through linking your GitHub account. For example,
    you can import the API for the classic PC game *Age of Empires II* from *https://age-of-empires-2-api.herokuapp.com/apispec.json*
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 集合、环境和规范都可以作为文件、文件夹、链接或原始文本导入，或者通过连接你的 GitHub 账户进行导入。例如，你可以从 *https://age-of-empires-2-api.herokuapp.com/apispec.json*
    导入经典 PC 游戏 *帝国时代 II* 的 API，如下所示：
- en: Click the **Import** button found at the top left of Postman.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击位于 Postman 左上角的**导入**按钮。
- en: Select the **Link** tab (see [Figure 4-20](#figure4-20)).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**链接**标签（见[图 4-20](#figure4-20)）。
- en: Paste the URL to the API specification and click **Continue**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粘贴 API 规范的 URL 并点击**继续**。
- en: On the Confirm Your Import screen, click **Import**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“确认导入”页面，点击**导入**。
- en: '![Screenshot of the Postman Import Link tab with a form field for entering
    a URL and a Continue button](image_fi/502444c04/F04020.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 导入链接标签的截图，带有一个输入 URL 的表单字段和一个继续按钮](image_fi/502444c04/F04020.png)'
- en: 'Figure 4-20: Importing an API specification in Postman using the Link tab in
    the Import panel'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-20：在 Postman 中使用导入面板中的链接标签导入 API 规范
- en: Once this is complete, you should have the Age of Empires II collection saved
    in Postman. Now test it out. Select one of the requests in the collection shown
    in [Figure 4-21](#figure4-21) and click **Send**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，你应该已将帝国时代 II 集合保存到 Postman 中。现在进行测试。选择[图 4-21](#figure4-21)中显示的集合中的一个请求并点击**发送**。
- en: '![Screenshot of the Postman interface populated with requests from the Age
    of Empires 2 collection and a list of what each does](image_fi/502444c04/F04021.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 界面的截图，显示了来自帝国时代 II 集合的请求以及每个请求的功能列表](image_fi/502444c04/F04021.png)'
- en: 'Figure 4-21: The Collections sidebar with the imported Age of Empires II API
    GET requests'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-21：导入的帝国时代 II API GET 请求的集合侧边栏
- en: For the request to work, you might have to first check the collection’s variables
    to make sure they’re set to the correct values. To see a collection’s variables,
    you will need to navigate to the Edit Collection window by selecting **Edit**
    within the **View More Actions** button (represented by three circles, as shown
    in [Figure 4-22](#figure4-22)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使请求正常工作，你可能需要先检查集合的变量，以确保它们设置为正确的值。要查看集合的变量，你需要通过点击**查看更多操作**按钮（由三个圆圈表示，如[图
    4-22](#figure4-22)所示）进入“编辑集合”窗口。
- en: '![Screenshot of a GET request selected in the Postman interface and the Edit
    option highlighted in a pop-up menu](image_fi/502444c04/F04022.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 界面截图，选中了一个 GET 请求，并在弹出菜单中突出显示了编辑选项](image_fi/502444c04/F04022.png)'
- en: 'Figure 4-22: Editing a collection within Postman'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-22：在 Postman 中编辑集合
- en: Once you’re in the Edit Collection window, select **Variables**, as shown in
    [Figure 4-23](#figure4-23).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入“编辑集合”窗口，选择**变量**，如[图 4-23](#figure4-23)所示。
- en: '![Screenshot of the Variables tab in Postman with the baseURL variable selected](image_fi/502444c04/F04023.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 中的变量标签截图，选中了 baseURL 变量](image_fi/502444c04/F04023.png)'
- en: 'Figure 4-23: The Age of Empires II API collection variables'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-23：帝国时代 II API 集合变量
- en: For example, the Age of Empires II API collection uses the variable `{{baseUrl}}`.
    The problem with the current `{{baseUrl}}` is that there are no values. We need
    to update this variable to the full URL of the public API, *https://age-of-empires-2-api.herokuapp.com/api/v1*.
    Add the full URL and click **Save** to update your changes (see [Figure 4-24](#figure4-24)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，帝国时代 II API 集合使用变量`{{baseUrl}}`。当前`{{baseUrl}}`的问题是没有值。我们需要将此变量更新为公共 API
    的完整 URL，*https://age-of-empires-2-api.herokuapp.com/api/v1*。添加完整的 URL 并点击**保存**来更新你的更改（见[图
    4-24](#figure4-24)）。
- en: '![Screenshot of the Variables tab in Postman with the initial value of the
    baseURL set to https://age-of-empires-2-api.herokuapp.com/api/v1](image_fi/502444c04/F04024.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 中变量标签的截图，baseURL 的初始值设置为 https://age-of-empires-2-api.herokuapp.com/api/v1](image_fi/502444c04/F04024.png)'
- en: 'Figure 4-24: The updated `baseURL` variable'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-24：更新后的`baseURL`变量
- en: Now that the variable is updated, you can choose one of the requests and click
    **Send**. If you are successful, you should receive a response similar to that
    shown in [Figure 4-25](#figure4-25).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量已更新，你可以选择其中一个请求并点击**发送**。如果成功，你应该会收到类似于[图 4-25](#figure4-25)所示的响应。
- en: '![Screenshot of the Postman interface populated with an HTTP response](image_fi/502444c04/F04025.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 界面的截图，显示了一个 HTTP 响应](image_fi/502444c04/F04025.png)'
- en: 'Figure 4-25: Successfully using the Age of Empires II API collection in Postman'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-25：在 Postman 中成功使用帝国时代 II API 集合
- en: Whenever you import a collection and run into errors, you can use this process
    to troubleshoot the collection’s variables. Also be sure to check that you haven’t
    omitted any authorization requirements.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你导入一个集合并遇到错误时，可以使用此过程来排查集合的变量问题。也请确保检查是否遗漏了任何授权要求。
- en: The Collection Runner
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合运行器
- en: The Collection Runner allows you to run all the saved requests in a collection
    (see [Figure 4-26](#figure4-26)). You can select the collection you want to run,
    the environment you want to pair it with, how many times you want to run the collection,
    and a delay in case there are rate-limiting requirements.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 集合运行器允许你运行集合中所有保存的请求（见[图 4-26](#figure4-26)）。你可以选择你想运行的集合、与之配对的环境、你希望运行集合的次数，以及如果有速率限制要求时的延迟。
- en: '![Screenshot of the Postman Collection Runner listing a variety of GET and
    POST requests](image_fi/502444c04/F04026.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 集合运行器截图，列出了多种 GET 和 POST 请求](image_fi/502444c04/F04026.png)'
- en: 'Figure 4-26: The Postman Collection Runner'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-26：Postman 集合运行器
- en: The requests can also be put into a specific order. Once the Collection Runner
    has run, you can review the Run Summary to see how each request was handled. For
    instance, if I open the Collection Runner, select Twitter API v2, and run the
    Collection Runner, I can see an overview of all API requests in that collection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请求还可以按特定顺序排列。一旦集合运行器执行完毕，你可以查看运行摘要，了解每个请求是如何处理的。例如，如果我打开集合运行器，选择 Twitter API
    v2 并运行集合运行器，我可以看到该集合中所有 API 请求的概览。
- en: Code Snippets
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码片段
- en: In addition to the panels, you should also be aware of the code snippets feature.
    At the top-right of the request pane, you’ll see a Code button. This button can
    be used to translate the built request into many different formats, including
    cURL, Go, HTTP, JavaScript, NodeJS, PHP, and Python. This is a helpful feature
    when we craft a request with Postman and then need to pivot to another tool. You
    can craft a complicated API request in Postman, generate a cURL request, and then
    use that with other command line tools.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了面板外，你还应注意代码片段功能。在请求面板的右上角，你会看到一个代码按钮。这个按钮可以用来将已构建的请求转换为多种不同的格式，包括 cURL、Go、HTTP、JavaScript、NodeJS、PHP
    和 Python。当我们使用 Postman 构建请求后，如果需要切换到其他工具，这个功能非常有用。你可以在 Postman 中构建复杂的 API 请求，生成一个
    cURL 请求，然后将其与其他命令行工具一起使用。
- en: The Tests Panel
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试面板
- en: 'The Tests panel allows you to create scripts that will be run against responses
    to your requests. If you are not a programmer, you will appreciate that Postman
    has made prebuilt code snippets available on the right side of the Tests panel.
    You can easily build a test by finding a prebuilt code snippet, clicking it, and
    adjusting the test to fit your testing needs. I suggest checking out the following
    snippets:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 测试面板允许你创建将在响应中运行的脚本。如果你不是程序员，你会欣赏 Postman 在测试面板右侧提供了预构建的代码片段。你可以通过找到一个预构建的代码片段、点击它，并调整测试以适应你的测试需求，轻松构建一个测试。我建议查看以下代码片段：
- en: '`Status code: Code is 200`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态码：代码为 200`'
- en: '`Response time is less than 200ms`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`响应时间小于 200 毫秒`'
- en: '`Response body: contains string`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`响应体：包含字符串`'
- en: 'These JavaScript code snippets are fairly straightforward. For instance, the
    test for `Status code: Code is 200` is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 JavaScript 代码片段相当直接。例如，`状态码：代码为 200` 的测试如下：
- en: '[PRE6]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see that the name of the test that will be displayed in the test results
    is “Status code is 200.” The function is checking to make sure the Postman response
    has the status 200\. We can easily adjust JavaScript to check for any status code
    by simply updating the `(200)` to our desired status code and changing the test
    name to fit. For example, if we wanted to check for the status code 400, we could
    change the code as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，将在测试结果中显示的测试名称是“状态码为 200”。该功能正在检查以确保 Postman 响应的状态是 200。我们可以轻松调整 JavaScript
    代码，通过简单地将 `(200)` 更新为我们所需的状态码，并更改测试名称以适应。例如，如果我们想检查状态码 400，可以按如下方式修改代码：
- en: '[PRE7]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s as simple as that! You really don’t have to be a programmer to understand
    these JavaScript code snippets.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！你真的不需要是程序员就能理解这些 JavaScript 代码片段。
- en: '[Figure 4-27](#figure4-27) shows a series of tests included with the API request
    to the AOE2 public API. The tests include a check for a 200 status code, less
    than 200 ms latency, and “Persians” within the response string.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-27](#figure4-27) 显示了一系列与 AOE2 公共 API 请求一起包含的测试。这些测试包括检查 200 状态码、小于 200
    毫秒的延迟，以及响应字符串中包含“波斯人”。'
- en: '![Screenshot of the Postman Tests panel in which a test is written and a list
    of requests are labeled “Pass”](image_fi/502444c04/F04027.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 测试面板截图，测试已编写，且一列请求标记为“通过”](image_fi/502444c04/F04027.png)'
- en: 'Figure 4-27: AOE2 public API tests'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-27：AOE2 公共 API 测试
- en: After your tests are configured, you can check the Test Results tab of a response
    to see if the tests succeeded or failed. A good practice with creating tests is
    to make sure the tests fail. Tests are only effective if they pass and fail when
    they are supposed to. Therefore, send a request that would create conditions you
    would expect to pass or fail the test to ensure it is functioning properly. For
    more information about creating test scripts, check out the Postman documentation
    ([https://learning.postman.com/docs/writing-scripts/test-scripts](https://learning.postman.com/docs/writing-scripts/test-scripts)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好测试后，你可以查看响应的测试结果标签，了解测试是成功还是失败。创建测试的一个好习惯是确保测试会失败。测试只有在通过和失败时按预期发生时才有效。因此，发送一个请求，创建你预期通过或失败的条件，以确保测试功能正常。关于创建测试脚本的更多信息，请查阅Postman文档（[https://learning.postman.com/docs/writing-scripts/test-scripts](https://learning.postman.com/docs/writing-scripts/test-scripts)）。
- en: You now have many other options to explore in Postman. Like Burp Suite, Postman
    has a Learning Center ([https://learning.postman.com](https://learning.postman.com))
    for online resources for those who want to develop a deeper understanding of the
    software. Alternatively, if you would like to review the Postman documentation,
    you can find it at [https://learning.postman.com/docs/getting-started/introduction](https://learning.postman.com/docs/getting-started/introduction).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在Postman中探索许多其他选项。像Burp Suite一样，Postman有一个学习中心（[https://learning.postman.com](https://learning.postman.com)），为那些想要深入了解该软件的用户提供在线资源。或者，如果你想查阅Postman文档，可以访问[https://learning.postman.com/docs/getting-started/introduction](https://learning.postman.com/docs/getting-started/introduction)。
- en: Configuring Postman to Work with Burp Suite
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Postman以与Burp Suite配合使用
- en: Postman is useful for interacting with APIs, and Burp Suite is a powerhouse
    for web application testing. If you combine these applications, you can configure
    and test an API in Postman and then proxy the traffic over to Burp Suite to brute-force
    directories, tamper with parameters, and fuzz all the things.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Postman用于与API交互，而Burp Suite是一个强大的网页应用测试工具。如果你将这两个应用结合使用，你可以在Postman中配置并测试API，然后通过代理将流量传送到Burp
    Suite进行目录暴力破解、篡改参数以及进行模糊测试。
- en: 'As when you set up FoxyProxy, you’ll need to configure the Postman proxy to
    send traffic over to Burp Suite using the following steps (see [Figure 4-28](#figure4-28)):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如同设置FoxyProxy时，你需要配置Postman代理，通过以下步骤将流量发送到Burp Suite（见[图 4-28](#figure4-28)）：
- en: Open Postman settings by pressing ctrl-, (comma) or navigating to **File**▶**Settings**.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下ctrl-,（逗号）或导航到**文件**▶**设置**以打开Postman设置。
- en: Click the **Proxy** tab.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**代理**选项卡。
- en: Click the checkbox for adding a custom proxy configuration.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选添加自定义代理配置的复选框。
- en: Make sure to set the proxy server to **127.0.0.1**.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将代理服务器设置为**127.0.0.1**。
- en: Set the proxy server port to **8080**.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代理服务器端口设置为**8080**。
- en: Select the **General** tab and turn SSL certificate verification **Off**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**常规**选项卡并关闭SSL证书验证**关闭**。
- en: In Burp Suite, select the **Proxy** tab.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Burp Suite中，选择**代理**选项卡。
- en: Click the button to turn Intercept **On**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮以启用拦截**开启**。
- en: '![Screenshot of the Postman Settings Proxy tab with the following checkboxes
    selected: use the system proxy, add a custom proxy configuration, HTTP, and HTTPS](image_fi/502444c04/F04028.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Postman设置代理选项卡的截图，选中以下复选框：使用系统代理，添加自定义代理配置，HTTP和HTTPS](image_fi/502444c04/F04028.png)'
- en: 'Figure 4-28: Postman’s proxy settings configured to interact with Burp Suite'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-28：Postman的代理设置已配置为与Burp Suite交互
- en: Try sending a request using Postman; if it is intercepted by Burp Suite, you’ve
    properly configured everything. Now you can leave the proxy on and toggle Burp
    Suite’s “turn Intercept on” function when you want to capture requests and responses.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Postman发送请求；如果请求被Burp Suite拦截，则说明你已正确配置一切。现在你可以保持代理开启，并在需要捕获请求和响应时切换Burp
    Suite的“开启拦截”功能。
- en: Supplemental Tools
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补充工具
- en: This section is meant to provide additional options and to aid those who are
    limited by the features available in Burp Suite CE. The following tools are excellent
    at what they do, open source, and free. In particular, the API scanning tools
    covered here serve several purposes when you’re actively testing your target.
    Tools such as Nikto and OWASP ZAP can help you actively discover API endpoints,
    security misconfigurations, and interesting paths, and they provide some surface-level
    testing of an API. In other words, they are useful when you start actively engaging
    with a target, whereas tools such as Wfuzz and Arjun will be more useful once
    you’ve discovered an API and want to narrow the focus of your testing. Use these
    tools to actively test APIs to discover unique paths, parameters, files, and functionality.
    Each of these tools has its own unique focus and purpose that will supplement
    functionality lacking in the free Burp Suite Community Edition.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在提供额外的选项，并帮助那些受到 Burp Suite CE 功能限制的用户。以下工具在其领域表现优秀，且是开源免费的。特别是这里介绍的 API
    扫描工具在你积极测试目标时发挥了多重作用。像 Nikto 和 OWASP ZAP 这样的工具可以帮助你主动发现 API 端点、安全配置错误和有趣的路径，并提供一些
    API 的表面测试。换句话说，当你开始积极与目标互动时，这些工具非常有用，而像 Wfuzz 和 Arjun 这样的工具则在你发现 API 并希望集中测试时更为有用。使用这些工具积极测试
    API，发现独特的路径、参数、文件和功能。每个工具都有自己独特的关注点和目的，能够补充免费版 Burp Suite Community Edition 中缺失的功能。
- en: Performing Reconnaissance with OWASP Amass
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OWASP Amass 进行侦察
- en: OWASP Amass is an open-source information-gathering tool that can be used for
    passive and active reconnaissance. This tool was created as a part of the OWASP
    Amass project, led by Jeff Foley. We will be using Amass to discover the attack
    surface of our target organizations. With as little as a target’s domain name,
    you can use Amass to scan through many internet sources for your target’s associated
    domains and subdomains to get a list of potential target URLs and APIs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP Amass 是一个开源信息收集工具，可用于被动和主动侦察。这个工具是 OWASP Amass 项目的一部分，由 Jeff Foley 领导。我们将使用
    Amass 来发现目标组织的攻击面。只需目标的域名，你就可以使用 Amass 扫描许多互联网资源，查找与目标相关的域名和子域名，获取潜在的目标 URL 和
    API 列表。
- en: 'If OWASP Amass is not installed, use the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未安装 OWASP Amass，请使用以下命令：
- en: '[PRE8]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Amass is pretty effective without much setup. However, you can make it into
    an information collection powerhouse by setting it up with API keys from various
    sources. I recommend at least setting up accounts with GitHub, Twitter, and Censys.
    Once you’ve set up these accounts, you can generate API keys for these services
    and plug them into Amass by adding them to Amass’s configuration file, *config.ini*.
    The Amass GitHub repository has a template *config.ini* file that you can use
    at [https://github.com/OWASP/Amass/blob/master/examples/config.ini](https://github.com/OWASP/Amass/blob/master/examples/config.ini).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Amass 在没有太多设置的情况下也非常有效。然而，通过设置来自各种源的 API 密钥，你可以将它打造成一个信息收集的强大工具。我建议至少注册 GitHub、Twitter
    和 Censys 的帐户。设置好这些帐户后，你可以为这些服务生成 API 密钥，并通过将其添加到 Amass 的配置文件 *config.ini* 中，插入到
    Amass 中。Amass 的 GitHub 仓库有一个 *config.ini* 文件模板，你可以在 [https://github.com/OWASP/Amass/blob/master/examples/config.ini](https://github.com/OWASP/Amass/blob/master/examples/config.ini)
    找到。
- en: 'On Kali, Amass will attempt to automatically find the *config.ini* file at
    the following location:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 上，Amass 将尝试在以下位置自动查找 *config.ini* 文件：
- en: '[PRE9]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To download the content of the sample *config.ini* file and save it to the
    default Amass config file location, run the following command from the terminal:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载示例 *config.ini* 文件的内容并将其保存到默认的 Amass 配置文件位置，请从终端运行以下命令：
- en: '[PRE10]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you have that file downloaded, you can edit it and add the API keys you
    would like to include. It should look something like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下载该文件后，你可以编辑它并添加你想要包含的 API 密钥。它应该类似于以下内容：
- en: '[PRE11]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, you can remove the comment (`#`) and simply paste in the API
    key for whichever service you would like to use. The *config.ini* file even indicates
    which keys are free. You can find a list of the sources with APIs you can use
    to enhance Amass at [https://github.com/OWASP/Amass](https://github.com/OWASP/Amass).
    Although it will be a little time-consuming, I recommend taking advantage of at
    least all the free sources listed under APIs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以删除注释（`#`），然后简单地粘贴你想使用的服务的 API 密钥。*config.ini* 文件中甚至指明了哪些密钥是免费的。你可以在
    [https://github.com/OWASP/Amass](https://github.com/OWASP/Amass) 查找到可以用来增强 Amass
    的 API 源列表。虽然这可能需要一些时间，但我建议至少利用所有在 APIs 下列出的免费源。
- en: Discovering API Endpoints with Kiterunner
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Kiterunner 发现 API 端点
- en: Kiterunner ([https://github.com/assetnote/kiterunner](https://github.com/assetnote/kiterunner))
    is a content discovery tool designed specifically for finding API resources. Kiterunner
    is built with Go, and while it can scan at a speed of 30,000 requests per second,
    it takes into account the fact that load balancers and web application firewalls
    will likely enforce rate limiting.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Kiterunner ([https://github.com/assetnote/kiterunner](https://github.com/assetnote/kiterunner))
    是一款专门为发现 API 资源而设计的内容发现工具。Kiterunner 是用 Go 编写的，虽然它能够以每秒 30,000 个请求的速度进行扫描，但它会考虑到负载均衡器和
    Web 应用防火墙可能会执行速率限制的因素。
- en: When it comes to APIs, Kiterunner’s search techniques outperform other content
    discovery tools such as dirbuster, dirb, Gobuster, and dirsearch because this
    tool was built with API awareness. Its wordlists, request methods, parameters,
    headers, and path structures are all focused on finding API endpoints and resources.
    Of note, the tool includes data from 67,500 Swagger files. Kiterunner has also
    been designed to detect the signature of different APIs, including Django, Express,
    FastAPI, Flask, Nginx, Spring, and Tomcat (just to name a few).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 API 时，Kiterunner 的搜索技术优于其他内容发现工具，如 dirbuster、dirb、Gobuster 和 dirsearch，因为该工具是针对
    API 进行优化的。它的字典文件、请求方法、参数、头部和路径结构都专注于发现 API 端点和资源。值得注意的是，该工具包含了来自 67,500 个 Swagger
    文件的数据。Kiterunner 还被设计用来检测不同 API 的特征，包括 Django、Express、FastAPI、Flask、Nginx、Spring
    和 Tomcat（仅举几个例子）。
- en: One of the tool’s most useful capabilities, which we’ll leverage in Chapter
    6, is the request replay feature. If Kiterunner detects endpoints when scanning,
    it will display this result on the command line. You can then dive deeper into
    the result by exploring the exact request that triggered the result.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具最有用的功能之一是请求重放功能，我们将在第六章中利用它。如果 Kiterunner 在扫描时检测到端点，它会在命令行中显示此结果。你可以进一步探索触发该结果的确切请求，从而深入分析。
- en: 'To install Kiterunner, run the following commands:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Kiterunner，请运行以下命令：
- en: '[PRE12]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should then be able to use Kiterunner from the command line by entering
    the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该能够通过在命令行输入以下命令来使用 Kiterunner：
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can supply Kiterunner with various wordlists, which it then uses as payloads
    for a series of requests. These requests will help you discover interesting API
    endpoints. Kiterunner allows you to use Swagger JSON files, Assetnote’s *.kites*
    files, and *.txt* wordlists. Currently, Assetnote releases its wordlists, which
    contain search terms collected from its internet-wide scans, on a monthly basis.
    All of the wordlists are hosted at [https://wordlists.assetnote.io](https://wordlists.assetnote.io).
    Create an API wordlists directory as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 Kiterunner 提供各种字典文件，然后它会将这些字典作为有效载荷用于一系列请求。这些请求将帮助你发现有趣的 API 端点。Kiterunner
    允许你使用 Swagger JSON 文件、Assetnote 的 *.kites* 文件和 *.txt* 字典。目前，Assetnote 每月发布包含从其全球网络扫描中收集的搜索词的字典文件。所有字典文件都托管在
    [https://wordlists.assetnote.io](https://wordlists.assetnote.io) 上。你可以按照如下方式创建一个
    API 字典目录：
- en: '[PRE14]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then select your desired wordlists and download them to the */api/wordlists*
    directory:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以选择你需要的字典文件并将它们下载到 */api/wordlists* 目录中：
- en: '[PRE15]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can replace *httparchive_apiroutes_2021_06_028.txt* with whichever wordlists
    suit you best. Alternatively, download all the Assetnote wordlists at once:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用任何适合你的字典文件替换 *httparchive_apiroutes_2021_06_028.txt*。或者，直接一次性下载所有的 Assetnote
    字典文件：
- en: '[PRE16]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Be warned that downloading all of the Assetnote wordlists takes up about 2.2GB
    of space, but storing them is definitely worth it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，下载所有 Assetnote 字典文件需要大约 2.2GB 的空间，但保存它们绝对是值得的。
- en: Scanning for Vulnerabilities with Nikto
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Nikto 扫描漏洞
- en: Nikto is a command line web application vulnerability scanner that is quite
    effective at information gathering. I use Nikto immediately after discovering
    the existence of a web application, as it can point me toward the application’s
    interesting aspects. Nikto will provide you with information about the target
    web server, security misconfigurations, and other web application vulnerabilities.
    Since Nikto is included in Kali, it should not require any special setup.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Nikto 是一款命令行 Web 应用漏洞扫描工具，对于信息收集非常有效。我通常在发现 Web 应用存在后立即使用 Nikto，因为它能指引我关注应用程序的有趣部分。Nikto
    会提供关于目标 Web 服务器、安全配置错误和其他 Web 应用漏洞的信息。由于 Nikto 已包含在 Kali 中，因此应该不需要任何特殊设置。
- en: 'To scan a domain, use the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描一个域名，可以使用以下命令：
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To see the additional Nikto options, enter `nikto -Help` on the command line.
    A few options you may find useful include `-output` `filename` for saving the
    Nikto results to a specified file and `-maxtime` `#ofseconds` to limit how long
    a Nikto scan will take.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Nikto 的额外选项，请在命令行中输入 `nikto -Help`。你可能会发现一些有用的选项，包括 `-output` `filename`
    用于将 Nikto 结果保存到指定文件，以及 `-maxtime` `#ofseconds` 用于限制 Nikto 扫描的持续时间。
- en: The results from a Nikto scan will include an app’s allowed HTTP methods, interesting
    header information, potential API endpoints, and other directories that could
    be worth checking out. For additional information about Nikto, review the documentation
    found at *https://cirt.net/nikto2-docs*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Nikto 扫描的结果将包括应用程序允许的 HTTP 方法、有趣的头部信息、潜在的 API 端点和其他可能值得检查的目录。有关 Nikto 的更多信息，请查阅文档
    *https://cirt.net/nikto2-docs*。
- en: Scanning for Vulnerabilities with OWASP ZAP
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OWASP ZAP 扫描漏洞
- en: OWASP developed ZAP, an open-source web application scanner, and it’s another
    essential web application security testing tool. OWASP ZAP should be included
    in Kali, but if it isn’t, you can clone it from GitHub at [https://github.com/zaproxy/zaproxy](https://github.com/zaproxy/zaproxy).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP 开发了 ZAP，这是一个开源的 Web 应用程序扫描工具，它是另一个重要的 Web 应用程序安全测试工具。OWASP ZAP 应该已经包含在
    Kali 中，但如果没有，你可以从 GitHub 克隆它，地址是 [https://github.com/zaproxy/zaproxy](https://github.com/zaproxy/zaproxy)。
- en: 'ZAP has two components: automated scan and manual explore. ZAP’s *automated
    scan* performs web crawling, detects vulnerabilities, and tests web application
    responses by altering request parameters. Automated scan is great for detecting
    the surface directories of a web application, which includes discovering API endpoints.
    To run it, enter the target URL into the ZAP interface and click the button to
    start the attack. Once the scan has run its course, you’ll receive a list of alerts
    that are categorized by the severity of the finding. The issue with ZAP’s automated
    scan is that it can be riddled with false positives, so it is important to examine
    and validate the alerts. The testing is also limited to the surface of a web application.
    Unless there are unintentionally exposed directories, ZAP will not be able to
    infiltrate beyond authentication requirements. This is where the ZAP manual explore
    option comes in handy.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ZAP 有两个组件：自动扫描和手动探索。ZAP 的*自动扫描*会执行 Web 抓取、检测漏洞，并通过更改请求参数来测试 Web 应用程序响应。自动扫描非常适合检测
    Web 应用程序的表面目录，包括发现 API 端点。要运行它，输入目标 URL 到 ZAP 界面并点击按钮开始攻击。一旦扫描完成，你将收到一个按发现严重性分类的警报列表。ZAP
    自动扫描的问题在于，它可能充满了误报，因此检查和验证警报非常重要。该测试也仅限于 Web 应用程序的表面。除非有无意暴露的目录，否则 ZAP 无法突破身份验证要求深入扫描。这时，ZAP
    的手动探索选项就派上了用场。
- en: ZAP *manual explore* is especially useful for exploring beyond the surface of
    the web application. Also known as the ZAP Heads Up Display (ZAP HUD), manual
    explore proxies your web browser’s traffic through ZAP while you browse. To launch
    it, enter the URL to explore and open a browser of your choice. When the browser
    launches, it will appear that you are browsing the site as you normally would;
    however, ZAP alerts and functions will overlay the web page. This allows you to
    have much more control over when to start crawling, when to run active scans,
    and when to turn on “attack mode.” For example, you can go through the user account
    creation process and authentication/authorization process with the ZAP scanner
    running to automatically detect flaws in these processes. Any vulnerabilities
    you detect will pop up like gaming achievements. We will be using ZAP HUD to discover
    APIs.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ZAP的*手动探索*功能对于深入探索 Web 应用程序非常有用。它也被称为 ZAP Heads Up Display（ZAP HUD），手动探索将你的
    Web 浏览器流量通过 ZAP 代理，当你浏览时，ZAP 会显示警报和功能覆盖在网页上。启动时，输入要探索的 URL 并打开你选择的浏览器。当浏览器启动时，看起来就像你正常地浏览该站点；然而，ZAP
    的警报和功能会叠加在网页上。这使你能够更好地控制何时开始抓取、何时运行主动扫描，以及何时开启“攻击模式”。例如，你可以在 ZAP 扫描器运行时完成用户账户创建过程和身份验证/授权过程，以自动检测这些过程中的漏洞。你检测到的任何漏洞都会像游戏成就一样弹出。我们将使用
    ZAP HUD 来发现 API。
- en: Fuzzing with Wfuzz
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Wfuzz 进行模糊测试
- en: Wfuzz is an open-source Python-based web application fuzzing framework. Wfuzz
    should come with the latest version of Kali, but you can install it from GitHub
    at [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Wfuzz 是一个基于 Python 的开源 Web 应用程序模糊测试框架。Wfuzz 应该已经包含在最新版本的 Kali 中，但你也可以从 GitHub
    上安装它，地址是 [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)。
- en: You can use Wfuzz to inject a payload within an HTTP request by replacing occurrences
    of the word *FUZZ* with words from a wordlist; Wfuzz will then rapidly perform
    many requests (around 900 requests per minute) with the specified payload. Since
    so much of the success of fuzzing depends on the use of a good wordlist, we’ll
    spend a decent amount of time discussing wordlists in Chapter 6.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic request format of Wfuzz:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To run Wfuzz, use the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command replaces *FUZZ* in the URL *http://targetname.com/FUZZ* with words
    from */usr/share/wordlists/list.txt*. The `-z` option specifies a type of payload
    followed by the actual payload. In this example, we specified that the payload
    is a file and then provided the wordlist’s file path. We could also use `-z` with
    `list` or `range`. Using the `list` option means that we will specify the payload
    in the request, whereas `range` refers to a range of numbers. For example, you
    can use the `list` option to test an endpoint for a list of HTTP verbs:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `-X` option specifies the HTTP request method. In the previous example,
    Wfuzz will perform a POST request with the wordlist used as the path in place
    of the *FUZZ* placeholder.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `range` option to easily scan a series of numbers:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will automatically fuzz all numbers from 500 to 1000\. This will come in
    handy when we test for BOLA vulnerabilities.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify multiple attack positions, you can list off several `-z` flags and
    then number the corresponding `FUZZ` placeholders, such as `FUZZ`, `FUZ1`, `FUZ2`,
    `FUZ3`, and so on, like so:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running Wfuzz against a target can generate a ton of results, which can make
    it difficult to find anything interesting. Therefore, you should familiarize yourself
    with the Wfuzz filter options. The following filters display only certain results:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`--sc` Only shows responses with specific HTTP response codes'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--sl` Only shows responses with a certain number of lines'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--sw` Only shows responses with a certain number of words'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--sh` Only shows responses with a certain number of characters'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, Wfuzz will scan the target and only show results
    that include a status code of 200:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following filters hide certain results:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '`--hc` Hides responses with specific HTTP status codes'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--hl` Hides responses with a specified number of lines'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--hw` Hides responses with a specified number of words'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--hh` Hides responses with specified number of characters'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, Wfuzz will scan the target and hide all results that
    have a status code of 404 and hide results that have 950 characters:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Wfuzz is a powerful multipurpose fuzzing tool you can use to thoroughly test
    endpoints and find their weaknesses. For more information about Wfuzz, check out
    the documentation at [https://wfuzz.readthedocs.io/en/latest](https://wfuzz.readthedocs.io/en/latest).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Discovering HTTP Parameters with Arjun
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arjun is another open source Python-based API fuzzer developed specifically
    to discover web application parameters. We will use Arjun to discover basic API
    functionality, find hidden parameters, and test API endpoints. You can use it
    as a great first scan for an API endpoint during black box testing or as an easy
    way to see how well an API’s documented parameters match up with the scan’s findings.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Arjun 是另一个基于 Python 的开源 API 模糊测试工具，专门用于发现 Web 应用程序参数。我们将使用 Arjun 来发现基本的 API
    功能、查找隐藏参数以及测试 API 端点。你可以将其作为黑盒测试中 API 端点的首选扫描工具，或者用它轻松查看 API 的文档参数是否与扫描结果相符。
- en: 'Arjun comes configured with a wordlist containing nearly 26,000 parameters,
    and unlike Wfuzz, it does some of the filtering for you using its preconfigured
    anomaly detection. To set up Arjun, first clone it from GitHub (you’ll need a
    GitHub account to do this):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Arjun 配备了一个包含近 26,000 个参数的词汇表，且与 Wfuzz 不同，它使用预配置的异常检测为你进行部分过滤。要设置 Arjun，首先从
    GitHub 克隆它（你需要一个 GitHub 账户）：
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Arjun works by first performing a standard request to the target API endpoint.
    If the target responds with HTML forms, Arjun will add the form names to the parameter
    list during its scan. Arjun then sends a request with parameters it expects to
    return responses for nonexistent resources. This is done to note the behavior
    of a failed parameter request. Arjun then kicks off 25 requests containing the
    payload of nearly 26,000 parameters, compares the API endpoint’s responses, and
    begins additional scans of the anomalies.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Arjun 的工作原理是，首先向目标 API 端点发送标准请求。如果目标返回 HTML 表单，Arjun 会将表单名称添加到参数列表中。然后，Arjun
    会发送一个包含预期返回不存在资源的参数请求。这样做是为了记录失败的参数请求的行为。接着，Arjun 会启动 25 个请求，其中包含近 26,000 个参数的有效负载，比较
    API 端点的响应，并开始对异常进行进一步扫描。
- en: 'To run Arjun, use the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Arjun，请使用以下命令：
- en: '[PRE26]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you would like to have the output results in a certain format, use the `-o`
    option with your desired file type:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望输出结果以某种特定格式呈现，可以使用`-o`选项并指定所需的文件类型：
- en: '[PRE27]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you come across a target with rate limiting, Arjun may trigger the rate
    limit and cause a security control to block you. Arjun even has built-in suggestions
    for when a target does not cooperate. Arjun may prompt you with an error message
    such as “Target is unable to process requests, try --stable switch.” If this happens,
    simply add the `--stable` flag. Here’s an example:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到有速率限制的目标，Arjun 可能会触发速率限制并导致安全控制机制阻止你。Arjun 甚至在目标不配合时会给出内建的建议。Arjun 可能会弹出错误信息，如“目标无法处理请求，请尝试
    --stable 开关。”如果发生这种情况，只需添加`--stable`标志。以下是一个示例：
- en: '[PRE28]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, Arjun can scan multiple targets at once. Use the `-i` flag to specify
    a list of target URLs. If you’ve been proxying traffic with Burp Suite, you can
    select all URLs within the sitemap, use the Copy Selected URLs option, and paste
    that list to a text file. Then run Arjun against all Burp Suite targets simultaneously,
    like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Arjun 可以同时扫描多个目标。使用`-i`标志来指定目标 URL 列表。如果你使用 Burp Suite 代理流量，你可以选择站点地图中的所有
    URL，使用“复制选定的 URL”选项，将该列表粘贴到文本文件中。然后像这样同时对所有 Burp Suite 目标运行 Arjun：
- en: '[PRE29]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you set up the various tools we’ll use to hack APIs throughout
    this book. Additionally, we spent some time digging into feature-rich applications
    such as DevTools, Burp Suite, and Postman. Being comfortable with the API hacking
    toolbox will help you know when to use which tool and when to pivot.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置本书中用于破解 API 的各种工具。此外，我们还花了一些时间深入探讨了功能丰富的应用程序，如 DevTools、Burp Suite
    和 Postman。熟悉这些 API 破解工具将帮助你知道何时使用哪个工具，以及何时需要调整策略。
- en: 'Lab #1: Enumerating the User Accounts in a REST API'
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '实验 #1：枚举 REST API 中的用户账户'
- en: Welcome to your first lab.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到你的第一个实验。
- en: 'In this lab, our goal is simple: find the total number of user accounts in
    *reqres.in*, a REST API designed for testing, using the tools discussed in this
    chapter. You could easily figure this out by guessing the total number of accounts
    and then checking for that number, but we will discover the answer much more quickly
    using the power of Postman and Burp Suite. When testing actual targets, you could
    use this process to discover whether there was a basic BOLA vulnerability present.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们的目标很简单：使用本章中讨论的工具，找出 *reqres.in* 这个 REST API 中的用户账户总数。你本可以通过猜测账户总数并检查这个数字来轻松得出答案，但我们将通过
    Postman 和 Burp Suite 的强大功能，更快速地找到答案。当测试实际目标时，你可以使用这个过程来发现是否存在基本的 BOLA 漏洞。
- en: First, navigate to [http://reqres.in](http://reqres.in) to see if API documentation
    is available. On the landing page, we find the equivalent of API documentation
    and can see a sample request that consists of making a request to the */api/users/2*
    endpoint (see [Figure 4-29](#figure4-29)).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the web page at https://reqres.in featuring a list of GET requests
    and their purposes, as well as the JSON data returned from one of the requests](image_fi/502444c04/F04029.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-29: API documentation found at [https://reqres.in](https://reqres.in)
    with instructions for requesting `user id:2`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice a List Users endpoint; we’ll ignore this for the purposes of the
    lab, as it won’t help you learn the intended concepts. Instead, we’ll be using
    the Single User endpoint because it will help you build the skills needed to discover
    vulnerabilities like BOLA and BFLA. The suggested API request for Single User
    is meant to provide the consumer with the requested user’s account information
    by sending a GET request to */api/users/*. We can easily assume that user accounts
    are organized in the *user* directory by their `id` number.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test this theory by attempting to send a request to a user with a different
    ID number. Since we’ll be interacting with an API, let’s set up the API request
    using Postman. Set the method to GET and add the URL *http://reqres.in/api/users/1*.
    Click **Send** and make sure you get a response. If you requested the user with
    an ID of 1, the response should reveal the user information for George Bluth,
    as seen in [Figure 4-30](#figure4-30).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a GET request to the http://reqres.in/api/users/1 endpoint
    in Postman showing the JSON data from the response body. The JSON data includes
    details about a user named George.](image_fi/502444c04/F04030.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-30: A standard API request made using Postman to retrieve user 1 from
    the [https://reqres.in](https://reqres.in) database'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: To efficiently retrieve the data of all users by following this method, we’ll
    use Burp’s Intruder. Proxy the traffic from the *reqres.in* endpoint over to Burp
    Suite and submit the same request in Postman. Migrate over to Burp Suite, where
    you should see the intercepted traffic in Burp Suite’s Proxy tab (see [Figure
    4-31](#figure4-31)).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![The intercepted request shown in Burp Suite Proxy](image_fi/502444c04/F04031.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-31: The intercepted request made using Postman to retrieve user 1'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Use the shortcut Ctrl-I or right-click the intercepted request and select **Send
    to Intruder**. Select the **Intruder**▶**Positions** tab to select the payload
    positions. First, select **Clear §** to remove the automatic payload positioning.
    Then select the number at the end of the URL and click the button labeled **Add
    §** (see [Figure 4-32](#figure4-32)).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of Burp Intruder’s Positions tab with the Sniper attack type selected
    and the UserID portion of the endpoint selected as the attack position](image_fi/502444c04/F04032.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-32: Burp Suite’s Intruder configured with the attack position set
    around the *UserID* portion of the path'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-32：Burp Suite的Intruder配置，攻击位置设置在路径的*UserID*部分
- en: Once you’ve selected the attack position, select the **Payloads** tab (see [Figure
    4-33](#figure4-33)). Since our goal is to find out how many user accounts exist,
    we want to replace the user ID with a series of numbers. Change the payload type
    to **Numbers**. Update the range of numbers to test from 0 to 25, stepping by
    1\. The Step option indicates to Burp how many numbers to increase with each payload.
    By selecting 1, we are letting Burp do the heavy lifting of creating all the payloads
    on the fly. This will help us discover all the users with an ID between 0 and
    25\. With these settings, Burp will send a total of 26 requests, each one with
    a number from 0 to 25.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了攻击位置，点击**Payloads**选项卡（见[图4-33](#figure4-33)）。由于我们的目标是找出存在多少个用户账户，我们希望用一系列数字替换用户ID。将载荷类型更改为**数字**。更新数字范围，测试从0到25，每次递增1。步长选项告诉Burp每次载荷增加多少数字。选择1意味着我们让Burp自动生成所有的载荷。这将帮助我们发现ID在0到25之间的所有用户。通过这些设置，Burp将发送总共26个请求，每个请求包含一个从0到25的数字。
- en: '![Screenshot of the Burp Suite Payloads tab showing one payload set, the payload
    type set to numbers, and the payloads ranging from 0 to 25](image_fi/502444c04/F04033.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Payloads选项卡的截图，显示了一个有效载荷集，载荷类型设置为数字，载荷范围从0到25](image_fi/502444c04/F04033.png)'
- en: 'Figure 4-33: Intruder’s Payloads tab with the payload type set to numbers'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-33：Intruder的Payloads选项卡，载荷类型设置为数字
- en: Finally, click **Start Attack** to send the 26 requests to *reqres.in*. Analyzing
    the results should give you a clear indication of all the live users. The API
    provider responds with a status 200 for user accounts between 1 and 12 and a status
    of 404 for the subsequent requests. Judging by the results, we can conclude that
    this API has a total of 12 valid user accounts.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击**开始攻击**将26个请求发送到*reqres.in*。分析结果应该能清楚地显示所有的活跃用户。API提供者对于用户账户1到12的请求返回状态200，而对随后的请求返回404状态。根据这些结果，我们可以得出结论，这个API总共有12个有效用户账户。
- en: Of course, this was just practice. The values you replace in a future API hacking
    engagement could be user ID numbers, but they could just as easily be bank account
    numbers, phone numbers, company names, or email addresses. This lab has prepared
    you to take on the world of basic BOLA vulnerabilities; we will expand on this
    knowledge in Chapter 10.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是练习。你在未来的API攻击中替换的值可能是用户ID号码，但它们也可以是银行账户号码、电话号码、公司名称或电子邮件地址。本实验室已经帮助你了解了基本的BOLA漏洞；我们将在第10章进一步扩展这些知识。
- en: As a further exercise, try performing this same scan using Wfuzz.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的练习，尝试使用Wfuzz执行相同的扫描。
