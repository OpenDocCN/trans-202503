<html><head></head><body>
  <h2 class="h2" id="app02"><a id="page_225"/><strong>B</strong></h2>

  <p class="h2c"><strong>BITCOIN PROGRAMMING WITH BITCOINJ</strong></p>

  <p class="noindent">In <a href="../Text/app01.html#app01">Appendix A</a>, we dabbled with JavaScript code that could perform some basic actions with a Bitcoin wallet by automating a preexisting wallet. In this appendix, we’ll write far more powerful programs that directly insert themselves into the Bitcoin network. As discussed previously, Bitcoin programs written this way—meaning those that do not rely on APIs from external companies and avoid dependencies on separate wallet programs—are usually the smartest solution for serious Bitcoin development projects.</p>

  <h3 class="h3" id="ch00leve1sec155"><strong>The Best Programming Language for Connecting to the Bitcoin Network</strong></h3>

  <p class="noindent">If you’re an experienced programmer, most likely you have a favorite programming language you would prefer to use to write your Bitcoin programs. However, only a few mature libraries currently exist that can connect <a id="page_226"/>directly to the Bitcoin network. One is the C++ reference implementation with which all the first full clients of the Bitcoin system were written.<sup><a id="footnote_37"/><a href="../Text/footnote.html#footnote37">1</a></sup> Large enterprise companies interested in supporting bitcoins should use this library. However, working with C++ is difficult for novices.</p>

  <p class="indent">Another mature library is written in Java and is called bitcoinJ.<sup><a id="footnote_38"/><a href="../Text/footnote.html#footnote38">2</a></sup> Because Java is easier to work with than C++, it is the library we’ll use. (The bitcoinJ library can also be used easily from languages built on top of the Java Virtual Machine, such as Scala or Clojure.)</p>

  <p class="indent">Currently, the options for other languages are rather limited. By searching the Internet, you <em>will</em> find Bitcoin libraries for other languages, such as Ruby, C#, and Python. However, most of these libraries are either in extremely early development or simply use the more limited JSON-RPC interface, which was discussed in <a href="../Text/app01.html#app01">Appendix A</a>.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>Some serious attempts are being made to offer full Bitcoin client support within the Go programming language. However, at the time of this writing, these libraries are either still in early development (such as gocoin<sup><a id="footnote_39"/><a href="../Text/footnote.html#footnote39">3</a></sup>) or are missing major features (such as btcd <sup><a id="footnote_40"/><a href="../Text/footnote.html#footnote40">4</a></sup>).</em></p>

  <p class="indent">No matter which library you choose, keep in mind that you must be vigilant about security. Essentially, when you use any of these libraries, you’ll be giving the library authors the keys to your Bitcoin kingdom. As we warned previously, technically it would be relatively easy to introduce rogue code into one of these libraries to steal all your money!</p>

  <h3 class="h3" id="ch00leve1sec156"><strong>Installing Java, Maven, and the BitcoinJ Library</strong></h3>

  <p class="noindent">Let’s ready your computer to do Java and bitcoinJ programming. The following steps should work on any major OS: Windows, Mac, or Linux.</p>

  <h4 class="h4" id="ch00leve1sec157"><em><strong>Step 1: Installing Java</strong></em></h4>

  <p class="noindent">The Java programming language is maintained by Oracle Corporation. Your computer may already have Java installed, but if you’ve never done Java development, your computer may only contain the Java JRE (Java Runtime Engine), which can run Java programs but is not adequate for developing them. Instead, you need the Java JDK (Java Development Kit). To download the JDK, do a Google search for <em>Java JDK</em>. The first link (which should be a link on the official Oracle website) should direct you to the right place to access the download.</p>

  <p class="note"><a id="page_227"/><strong>NOTE</strong><br/>
  <em><strong>Linux developers:</strong> Some versions of Linux may install the OpenJDK version of Java by default. At the time of this writing, this unofficial Java variant is missing some components that this tutorial depends on. Instead, look online for information about installing the Oracle JDK on your version of Linux and make it the default Java version on your system.</em></p>

  <h4 class="h4" id="ch00leve1sec158"><em><strong>Step 2: Installing Maven</strong></em></h4>

  <p class="noindent">Maven is a packaging tool for Java. Essentially, you specify which libraries your program needs, and Maven automatically downloads them from the Internet and makes them available to your program. This is analogous to the Node Package Manager used in <a href="../Text/app01.html#app01">Appendix A</a>.</p>

  <p class="indent">You can download Maven and find instructions for installing Maven on each OS at <em><a href="https://maven.apache.org/">https://maven.apache.org/</a></em>. Just follow the instructions at the main Maven website to install it or search Google for tutorials. Because more than a million other people have had to install Maven, if you run into installation problems, just type your problem into Google. It is very likely you’ll get helpful information on how to solve your problem.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em><strong>Windows users:</strong> At the time of this writing, detailed instructions for installing Maven on Windows are cleverly hidden at the very bottom of</em> <a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a>. <em><strong>Mac/Linux users:</strong> You can use your package managers here: brew install maven for Mac and sudo apt-get install maven for Debian Linux</em>.</p>

  <p class="indent">To ensure Maven is properly installed, a version message should display when you type <code>mvn --version</code> from a console.</p>

  <p class="indent">For typical Java programming, we could stop here because any needed additional libraries could be downloaded through the Maven package system. However, because we’re writing programs that work with money, the bitcoinJ maintainers require all developers to take a few extra precautions and install a couple of additional tools that directly relate to security issues.</p>

  <h4 class="h4" id="ch00leve1sec159"><em><strong>Step 3: Installing Git</strong></em></h4>

  <p class="noindent">For security reasons, we’ll install Git, which is a popular source code management tool. But it also offers features for securely downloading source code from online repositories that we’ll rely on. Download Git from <em><a href="http://git-scm.com/">http://git-scm.com/</a></em>.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>Once again, Mac and Linux users can use their package managers: brew install git and apt-get install git, respectively. Do you see a pattern?</em></p>

  <h4 class="h4" id="ch00leve1sec160"><em><strong>Step 4: Installing BitcoinJ</strong></em></h4>

  <p class="noindent">BitcoinJ is a Bitcoin library that can “talk bitcoin” and can connect directly to the Bitcoin network. By calling functions in this library, we can send and receive bitcoins in real time.</p>

  <p class="indent"><a id="page_228"/>We’ll build bitcoinJ directly from its authoritative source. Navigate to a directory from the console where you want to install the bitcoinJ library (your <em>Home</em> directory would be a good place).</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>A new subdirectory will be created, so other existing files in this directory will not be affected by this installation.</em></p>

  <p class="indent">Enter the following into your console (on Windows you may need to use the special Git Bash console that was installed when you installed Git):</p>
  <pre class="programs">
<span class="codestrong">&gt; git clone https://github.com/bitcoinj/bitcoinj.git <span class="ent">➊</span></span><br/><span class="codestrong">&gt; cd bitcoinj</span><br/><span class="codestrong">&gt; git checkout cbbb1a2 <span class="ent">➋</span></span><br/><span class="codestrong">&gt; mvn install <span class="ent">➌</span></span>
</pre>

  <p class="indent">The first line downloads the bitcoinJ code from the authoritative website <span class="ent">➊</span>. Then, we use git to switch to an older version of this library using the <code>git checkout</code> command <span class="ent">➋</span>. During this tutorial, this command will shield us from any problems that might be caused by newer versions of the library. However, when you’ve completed the tutorials, you can switch to the newest version of bitcoinJ (<code>git checkout master</code>) to experiment with its shiny new features. The last line installs the package into the local Maven package repository <span class="ent">➌</span>. When we reference bitcoinJ from our programs, Maven will fetch it from this repository (instead of grabbing it from the Internet), and we can be confident we’re using an uncorrupted version of this library.</p>

  <p class="indent">Now we can finally start programming!</p>

  <h3 class="h3" id="ch00leve1sec161"><strong>Creating a Starter Project for hello-money</strong></h3>

  <p class="noindent">In <a href="../Text/app01.html#app01">Appendix A</a>, we created a JavaScript program called <code>Hello Money!</code> that detects when money is sent to a Bitcoin address. Now, we’ll write a more sophisticated program with Java and bitcoinJ that accomplishes the same task. From the console, navigate to a directory where you want your new program to live, such as your computer’s <em>Home</em> or <em>Documents</em> folder. A subdirectory will be created in this place.</p>

  <p class="indent">Now type the following to have Maven create an empty starter project:</p>
  <pre class="programs">
mvn archetype:generate -DgroupId=hellomoney -DartifactId=hello-money<br/>   -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
</pre>

  <p class="indent">These commands create a directory called <em>hello-money</em> at the current location with the <code>hello-money</code> starter project.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>If Maven prompts you for answers during this process, just keep pressing ENTER to use the default setting.</em></p>

  <p class="indent"><a id="page_229"/>Next, we need to inform Maven that this program will use a couple of external libraries. We do this by editing the file <em>pom.xml</em>, which should now exist in the new directory. Also in this file should be a section named <code>&lt;dependencies&gt;</code> where we’ll add bitcoinJ as a new dependency. After the previous dependency (i.e., <em>after</em> the line that reads <code>&lt;/dependency&gt;</code> singular), add the following:</p>
  <pre class="programs">
&lt;dependency&gt;<br/>  &lt;groupId&gt;com.google&lt;/groupId&gt;<br/>  &lt;artifactId&gt;bitcoinj&lt;/artifactId&gt;<br/>  &lt;version&gt;0.8&lt;/version&gt;<br/>  &lt;scope&gt;compile&lt;/scope&gt;<br/>&lt;/dependency&gt;
</pre>

  <p class="indent">Now we’ll add a plug-in called <code>exec-maven-plugin</code> to our program. A <em>plug-in</em> is a special type of library. The <code>exec-maven-plugin</code> will make it easier to run our finished program from the command line.</p>

  <p class="indent">At the very bottom of the projects in <em>pom.xml</em> (i.e., <em>after</em> the line that reads <code>&lt;/dependencies&gt;</code> plural), add the following lines:</p>
  <pre class="programs">
&lt;build&gt;<br/>  &lt;plugins&gt;<br/>    &lt;plugin&gt;<br/>      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br/>      &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;<br/>      &lt;version&gt;1.2.1&lt;/version&gt;<br/>      &lt;configuration&gt;<br/>        &lt;arguments&gt;<br/>        &lt;/arguments&gt;<br/>        &lt;mainClass&gt;hellomoney.App&lt;/mainClass&gt;<br/>      &lt;/configuration&gt;<br/>    &lt;/plugin&gt;<br/>  &lt;/plugins&gt;<br/>&lt;/build&gt;
</pre>

  <p class="indent">Now we’re ready to run this <em>empty</em> program for the first time as a test. To do this, execute the following lines from the console in the program’s directory:</p>
  <pre class="programs">
<span class="codestrong">&gt; mvn install <span class="ent">➊</span></span><br/><span class="codestrong">&gt; mvn exec:java <span class="ent">➋</span></span><br/><br/>Hello World!
</pre>

  <p class="indent">The first line <span class="ent">➊</span> loads all the necessary libraries into the project and builds the program into a Java bytecode file. The second line <span class="ent">➋</span> actually runs the program.</p>

  <p class="indent">If the program runs successfully, you should see <code>Hello World!</code> printed on the screen. This means Maven has successfully created a functioning Java program and that we’re now ready to start writing the core Bitcoin code.</p>

  <h3 class="h3" id="ch00leve1sec162"><a id="page_230"/><strong>Writing the Code for hello-money</strong></h3>

  <p class="noindent">The entirety of the code for our <code>hello-money</code> program follows. To add this to the project, open the file <em>src/main/java/hellomoney/App.java</em> and replace its contents with this program:</p>
  <pre class="programs">
package hellomoney;<br/>import com.google.bitcoin.core.*;<br/>import com.google.bitcoin.store.*;<br/>import com.google.bitcoin.discovery.DnsDiscovery;<br/>import java.io.File;<br/>import java.math.BigInteger;<br/><br/>public class App<br/>{<br/>    public static void main( String[] args ) throws BlockStoreException<br/>    {<br/>        NetworkParameters params = NetworkParameters.prodNet();<br/>        Wallet wallet = new Wallet(params);<br/>        ECKey key = new ECKey();<br/>        System.out.println("Public address: " +<br/>            key.toAddress(params).toString());<br/>        System.out.println("Private key: " +<br/>            key.getPrivateKeyEncoded(params).toString());<br/>        wallet.addKey(key);<br/>        File file = new File("my-blockchain");<br/>        SPVBlockStore store=new SPVBlockStore(params, file);<br/>        BlockChain chain = new BlockChain(params, wallet, store);<br/>        PeerGroup peerGroup = new PeerGroup(params, chain);<br/>        peerGroup.addPeerDiscovery(new DnsDiscovery(params));<br/>        peerGroup.addWallet(wallet);<br/>        peerGroup.start();<br/>        peerGroup.downloadBlockChain();<br/>        wallet.addEventListener(new AbstractWalletEventListener()<br/>            {<br/>                public void onCoinsReceived(Wallet wallet,<br/>                      Transaction tx, BigInteger prevBalance,<br/>                      BigInteger newBalance)<br/>                {<br/>                    System.out.println("Hello Money! Balance: "<br/>                        + newBalance + " satoshis");<br/>                }<br/>            });<br/>         while(true){}<br/>    }<br/>}
</pre>

  <p class="indent">Next, run the command <code>mvn install</code>, which checks the syntax of this new program code and builds it into a program file. If the build works, the message <code>BUILD SUCCESS</code> should appear (along with tons of other esoteric messages).</p>

  <p class="indent">Before we run the program, let’s walk through it step-by-step to see what it does.</p>

  <h4 class="h4" id="ch00leve1sec163"><a id="page_231"/><em><strong>Declarations at the Top of the Program</strong></em></h4>

  <p class="noindent">The first line in the program declares the name of the package:</p>
  <pre class="programs">
package hellomoney;
</pre>

  <p class="indent">Next, we declare all the libraries the program will reference:</p>
  <pre class="programs">
import com.google.bitcoin.core.*;<br/>import com.google.bitcoin.store.*;<br/>import com.google.bitcoin.discovery.DnsDiscovery;<br/>import java.io.File;<br/>import java.math.BigInteger;
</pre>

  <p class="indent">Three of these references are for Bitcoin classes: First, we’ll use the core libraries to access basic Bitcoin classes (such as classes for wallets and keys). Second, we need classes for storing the blockchain (called a <em>block store</em> in BitcoinJ lingo). Third, we need to use the <code>DnsDiscovery</code> class, which helps us find other nodes participating in the Bitcoin network. We import the <code>java.io.File</code> class because we’ll be writing our block store to a file, and we import the <code>java.math.BigInteger</code> class to work with, well, big integers.</p>

  <p class="indent">Now let’s define the Java class that holds the program:</p>
  <pre class="programs">
public class App<br/>{<br/>    public static void main( String[] args ) throws BlockStoreException<br/>    {
</pre>

  <p class="indent">The program code is stored in a new class called <code>App</code>, which contains a single member function <code>main</code>. We mentioned this <code>hellomoney.App</code> class in the <em>pom.xml</em> file, declaring it as the <em>main class</em> of the program.</p>

  <p class="indent">Let’s look at individual lines in the main function.</p>

  <h4 class="h4" id="ch00leve1sec164"><em><strong>Initializing Our Java Objects</strong></em></h4>

  <p class="noindent">Here is the code that initializes the Java object we need from the bitcoinJ library.</p>
  <pre class="programs">
NetworkParameters params = NetworkParameters.prodNet();<span class="ent">➊</span><br/>Wallet wallet = new Wallet(params);<span class="ent">➋</span><br/>ECKey key = new ECKey();<span class="ent">➌</span><br/>System.out.println("Public address: " +<span class="ent">➍</span><br/>    key.toAddress(params).toString());<br/>System.out.println("Private key: " +<span class="ent">➎</span><br/>    key.getPrivateKeyEncoded(params).toString());<br/>wallet.addKey(key);<span class="ent">➏</span>
</pre>

  <p class="indent">We start by fetching the network parameters for the main, production Bitcoin network <span class="ent">➊</span>. Although only one true Bitcoin network is actually used for transactions, it’s difficult to test the Bitcoin system thoroughly with real money; therefore, Bitcoin developers also maintain a second Bitcoin <a id="page_232"/>network called <em>TestNet</em> for testing only. The <code>NetworkParameters</code> structure contains information about the genesis block (the first block in the block-chain) as well as information about the maximum number of coins and several other assorted details, which may differ between the main Bitcoin network and the TestNet. By having all this information packed in the <code>NetworkParameters</code> data structure, it’s easy to connect our program to another network besides the main Bitcoin network, such as the TestNet, as desired.</p>

  <p class="indent">Next, we create a new, empty wallet that we’ll set up to receive our coins <span class="ent">➋</span>. As discussed earlier, Bitcoin wallets contain one or more Bitcoin addresses, and each Bitcoin address consists of a public and a private key. Here <span class="ent">➌</span>, the bitcoinJ library creates a new key pair for us. Then, we print out the public address and private keys that were generated <span class="ent">➍</span><span class="ent">➎</span>. Finally, we add our new key pair to the wallet <span class="ent">➏</span>.</p>

  <p class="note"><strong>WARNING</strong><br/>
  <em>Usually, when using bitcoinJ, you should reuse the same wallet every time the program runs and load/save it every time the program starts/stops or your program can lose track of money. This is not an issue for the simple hello-money program. However, before you build more sophisticated bitcoinJ programs, read “<a href="../Text/app02.html#ch00leve1sec173">Gotchas When Using Wallets in BitcoinJ</a>” on <a href="../Text/app02.html#page_239">page 239</a>.</em></p>

  <p class="indent">Not only does a Bitcoin app need a wallet, it also needs a blockchain. The following lines initialize a new blockchain for us:</p>
  <pre class="programs">
File file = new File("my-blockchain");<span class="ent">➊</span><br/>SPVBlockStore store = new SPVBlockStore(params, file);<span class="ent">➋</span><br/>BlockChain chain = new BlockChain(params, wallet, store);<span class="ent">➌</span>
</pre>

  <p class="indent">Because blockchains consume lots of space, we’ll write it to a file named <em>my-blockchain</em> <span class="ent">➊</span>. Next, we create a block store, which is an object that manages the data for our copious blockchain data <span class="ent">➋</span>. BitcoinJ offers several block store types, all with different feature and performance trade-offs. In this example, we’ll use an <code>SPVBlockStore</code> object, which is usually the best choice for most apps.</p>

  <p class="indent">So what are the trade-offs you need to know about? Well, the biggest performance challenge any app that works with bitcoins has to deal with is that the official Bitcoin blockchain is larger than 10GB in size. Do most Bitcoin apps <em>really</em> need all 10GB of the blockchain?</p>

  <p class="indent">To answer this question, let’s consider why the blockchain exists. At a simplified level, a Bitcoin blockchain is responsible for two main jobs:</p>

  <p class="ordert">1. Figuring out how much money everyone on the network has</p>

  <p class="order">2. Figuring out whether new transactions broadcast across the network are valid</p>

  <p class="indentt">For the first task, the blockchain allows us to examine all the historical blocks in the blockchain and compile comprehensive data about every Bitcoin address ever used and how much money each contains. For the second task, it allows us to examine new blocks of transactions created by the <a id="page_233"/>network and then to verify that these blocks have the appropriate hashing information that proves they are correctly mined blocks according to the latest difficulty requirements.</p>

  <p class="indent">But consider the first job of the blockchain: Do most apps need to discern how much money is in every wallet in existence? No, most apps only need to identify the amount of money in <em>one</em> or a small number of wallets. Therefore, not all 10GB of data are needed. The prescient Satoshi, in his original Bitcoin whitepaper, was able to see that in this case, an optimization called <em>Simplified Payment Verification (SPV)</em> was possible.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>We also covered SPV a bit in <a href="../Text/ch09.html#ch09">Chapter 9</a>, when comparing different types of Bitcoin wallets.</em></p>

  <p class="indent">Here’s a quick refresher of how SPV works: If you know you’re interested in a single wallet ahead of time, you can just tally up how much money is in that one wallet as you pull the entire historical blockchain off the Bitcoin network. At that point, you only need to store header information of blocks and can ignore information in older blocks entirely in most situations, which is what <code>SPVBlockStore</code> does. In doing so, the <code>SPVBlockStore</code> (as of 2014) is less than 1GB in size, less than a one-tenth the size of the official blockchain, and this is why we use <code>SPVBlockChain</code> to store our data.</p>

  <p class="indent">Once we’ve created the block store, we can use it to create a <code>BlockChain</code> object <span class="ent">➌</span>. Notice that when we create this <code>BlockChain</code> object, we must pass in our wallet as created. Because we’re not downloading all 10GB, the block-chain object needs to know ahead of time which wallets (and their addresses) are important to us so it can select the right blockchain data to download.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>Even though SPVBlockStore is much smaller than the full blockchain, it can still take a long time for your app to download all the needed data from the network—usually, about 20 minutes. However, it will write this data to a file, and an SPVBlockStore object is smart enough to check the supplied file to see whether any data has already been downloaded since the last time the program was run. If so, it downloads only new data that has arrived after the program was last run.</em></p>

  <h4 class="h4" id="ch00leve1sec165"><em><strong>Connecting to the Bitcoin Network</strong></em></h4>

  <p class="noindent">With a wallet and a place to store the blockchain data, we can now connect to the actual Bitcoin network. A Bitcoin node connects to the Bitcoin network by connecting to several semirandom peer nodes. Here is the code that fires up a connection to several peers:</p>
  <pre class="programs">
PeerGroup peerGroup = new PeerGroup(params, chain);<span class="ent">➊</span><br/>peerGroup.addPeerDiscovery(new DnsDiscovery(params));<span class="ent">➋</span><br/>peerGroup.addWallet(wallet);<span class="ent">➌</span><br/>peerGroup.start();<span class="ent">➍</span><br/>peerGroup.downloadBlockChain();<span class="ent">➎</span>
</pre>

  <p class="indent">First we create a <code>PeerGroup</code> object <span class="ent">➊</span> that manages these connections. Next, we choose some random peers to connect to. We do this by adding <a id="page_234"/>a peer discovery algorithm to the <code>PeerGroup</code> <span class="ent">➋</span>. The <code>DnsDiscovery</code> class basically uses the URLs of some well-established and trusted nodes as a starting point to discover peers that are willing to accept new connections. Then we add our wallet to the <code>PeerGroup</code> object <span class="ent">➌</span>.</p>

  <p class="indent">Now we’re finally ready to inject the app into the Bitcoin network! We do this by calling <code>PeerGroup.start</code> <span class="ent">➍</span>, which will find and connect to some nodes and perform the appropriate handshake operations via network sockets. And, like any Bitcoin node, we request that the peers send us the blockchain so we can become a fully functional node <span class="ent">➎</span>. As mentioned previously, this step will take a while to run, but only the first time we run the program.</p>

  <h4 class="h4" id="ch00leve1sec166"><em><strong>Listening for New Money</strong></em></h4>

  <p class="noindent">One last feature we need to add to the <code>hello-money</code> program is a hook to detect when money has arrived:</p>
  <pre class="programs">
wallet.addEventListener(new AbstractWalletEventListener()<span class="ent">➊</span><br/>    {<br/>        public void onCoinsReceived(Wallet wallet, Transaction tx,<span class="ent">➋</span><br/>           BigInteger prevBalance, BigInteger newBalance)<br/>        {<br/>            System.out.println("Hello Money! Balance: "<br/>                + newBalance + " satoshis");<br/>        }<br/>    });
</pre>

  <p class="indent">The bitcoinJ wallet object has an <code>addEventListener</code> member function, and we can create an anonymous class of type <code>EventListener</code>, which intercepts and listens to different events that might happen to a wallet <span class="ent">➊</span>. In our app, we’re interested in the <code>onCoinsReceived</code> function <span class="ent">➋</span>, which will be called every time money is received by this wallet. Let’s explore in more detail exactly what this means.</p>

  <p class="indent">Because the program lives directly in the Bitcoin network, it can listen to the <em>bitcoin firehose</em>, a stream of data that contains every Bitcoin transaction happening anywhere in the world in close to real time. Each transaction is examined to see whether it involves receiving money into any Bitcoin address contained in our wallet. In our app, the wallet contains only one address. As soon as this transaction arrives (even before it has been incorporated into a mined block), our function <code>onCoinsReceved</code> will be called.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>In the hello-money program, we won’t worry about capturing confirmation events on the money received; we’ll only listen for the transmission of new, unconfirmed transactions. However, if we were interested in confirmations, we could capture them via the onTransactionConfidenceChanged function. Because we’re running a full Bitcoin client, we can do what we want, whereas in <a href="../Text/app01.html#app01">Appendix A</a> we were</em> forced <em>to look only at confirmed transactions due to the limitations of the JSON-RPC interface.</em></p>

  <p class="indent">The <code>onCoinsReceived</code> function has four parameters passed into it <span class="ent">➋</span>: the wallet object, a transaction object, the previous balance in the wallet, <a id="page_235"/>and the new balance. The bitcoinJ library uses the Java <code>BigInteger</code> class to encode Bitcoin balances, because this numerical type can handle very large integers precisely. If you’ve written financial software before, you’ll know why the <code>BigInteger</code> class is used (or you may recall how the bank heist was done in the movie <em>Office Space</em>). The fact is that it’s very easy to botch a financial transaction due to rounding errors, and using big, precise integers prevents this problem. Hence, bitcoinJ performs all Bitcoin math using satoshis, the smallest unit of bitcoins, which are worth one one-hundred-millionth of a bitcoin.</p>

  <p class="note"><strong>NOTE</strong><br/>
  <em>Because we added the event listener</em> after <em>we downloaded the initial blockchain, the onCoinsReceived function will be called</em> only <em>when new transactions appear as the program is running. If we had declared it before downloading the initial blockchain, the design of bitcoinJ is such that onCoinsReceived would also have been called on relevant historical transactions.</em></p>

  <p class="indent">Finally, we put the program into an infinite loop, so the program continues running as we wait for money to arrive:</p>
  <pre class="programs">
while(true){}
</pre>

  <h3 class="h3" id="ch00leve1sec167"><strong>Running and Testing the hello-money Java Program</strong></h3>

  <p class="noindent">We’re ready to run and test the program! As before, we first compile and then run the program:</p>
  <pre class="programs">
<span class="codestrong">&gt; mvn install</span><br/><span class="codestrong">&gt; mvn exec:java</span>
</pre>

  <p class="indent">Some messages should then appear as your program connects to the Bitcoin network and downloads the blockchain. The first time the program is run, this may take a while:</p>
  <pre class="programs">
Public address: 16YavT6SmJCuJpZgzRa6XG9WefPEu2M45<br/>Private key: L3eoA1rXiD8kWFUzdxw744NWjoZNB5BGsxhzVas6y5KJgVteZ4uD<br/>Downloading block chain of size 265184. This may take a while.<br/>Chain download 1% done with 262532 blocks to go, block date Feb 1, 2009 5:09:55 PM<br/>Chain download 2% done with 259880 blocks to go, block date Feb 22, 2009 11:32:14 PM<br/>Chain download 3% done with 257228 blocks to go, block date Mar 18, 2009 9:59:38 PM<br/>Chain download 4% done with 254576 blocks to go, block date Apr 11, 2009 4:27:52 PM<br/>Chain download 5% done with 251924 blocks to go, block date May 4, 2009 9:23:54 AM<br/>...<br/>Done downloading block chain
</pre>

  <p class="indent">After the blockchain has finished downloading, you can test the <code>hello-money</code> program and send it some tiny sum from your favorite wallet app. Simply send 0.0002 BTC to the public address and record the private key <a id="page_236"/>(we’ll be using this money in the follow-up example program later in this appendix). The program should detect when the money arrives and display a message like this:</p>
  <pre class="programs">
Hello Money! Balance: 20000 satoshis
</pre>

  <p class="indent">The new balance in the wallet should display in satoshis (divide by 100,000,000 to see that this number is indeed 0.0002 BTC).</p>

  <p class="indent">You’ve successfully written a bitcoinJ program that creates a Bitcoin wallet and reports on any money received. Now let’s write a second program that uses the newly stored money!</p>

  <h3 class="h3" id="ch00leve1sec168"><strong>Bye-Bye Money</strong></h3>

  <p class="noindent">Now, let’s write a brand-new program that can <em>send</em> money from an arbitrary Bitcoin address. To create a new <code>bye-bye-money</code> program, run the following from your top-level program directory:</p>
  <pre class="programs">
mvn archetype:generate -DgroupId=byebyemoney -DartifactId=bye-bye-money<br/>   -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
</pre>

  <p class="indent">Then, make the exact additions to the <em>pom.xml</em> file as we did in the <code>hello-money</code> example, except for the line that reads <code>&lt;mainClass&gt;hellomoney.App&lt;/mainClass&gt;</code>. Change that line to <code>&lt;mainClass&gt;byebyemoney.App&lt;/mainClass&gt;</code>. (These steps are analogous to those we followed for our <code>hello-money</code> program in “<a href="../Text/app02.html#ch00leve1sec161">Creating a Starter Project for hello-money</a>” on <a href="../Text/app02.html#page_228">page 228</a>.)</p>

  <p class="indent">Just as before, open the file <em>src/main/java/byebyemoney/App.java</em> and replace its contents with the following program:</p>
  <pre class="programs">
package byebyemoney;<br/><br/>import com.google.bitcoin.core.*;<br/>import com.google.bitcoin.store.*;<br/>import com.google.bitcoin.discovery.DnsDiscovery;<br/>import java.util.concurrent.ExecutionException;<br/>import java.io.File;<br/>import java.math.BigInteger;<br/><br/>public class App<br/>{<br/>    public static void main( String[] args )<br/>        throws BlockStoreException, AddressFormatException,<br/>                    InterruptedException, ExecutionException<br/>    {<br/>        NetworkParameters params = NetworkParameters.prodNet();<br/>        Wallet wallet = new Wallet(params);<br/>        DumpedPrivateKey key = new DumpedPrivateKey(params,<br/>               "L1vJHdDqQ5kcY5q4QoY124zD21UVgFe6NL2835mp8UgG2FNU94Sy");<br/>        wallet.addKey(key.getKey());<br/>        BlockChain chain = new BlockChain(params, wallet,<br/>               new MemoryBlockStore(params));<br/>     PeerGroup<a id="page_237"/> peerGroup = new PeerGroup(params, chain);<br/>     peerGroup.addPeerDiscovery(new DnsDiscovery(params));<br/>     peerGroup.addWallet(wallet);<br/>     peerGroup.start();<br/>     peerGroup.downloadBlockChain();<br/>     BigInteger balance = wallet.getBalance();<br/>     System.out.println("Wallet balance: " + balance);<br/>     Address destinationAddress = new Address(params,<br/>               "1BTCorgHwCg6u2YSAWKgS17qUad6kHmtQW");<br/>     BigInteger fee=BigInteger.valueOf(10000);<br/>     Wallet.SendRequest req = Wallet.SendRequest.to(<br/>              destinationAddress,balance.subtract(fee));<br/>     req.fee = fee;<br/>     Wallet.SendResult result = wallet.sendCoins(peerGroup, req);<br/>     if(result != null)<br/>         {<br/>             result.broadcastComplete.get();<br/>             System.out.println("The money was sent!");<br/>         }<br/>     else<br/>         {<br/>             System.out.println("Something went wrong sending the money.");<br/>         }<br/>   }<br/>}
</pre>

  <p class="indent">Many of the lines in this new program are shared with our previous <code>hello-money</code> program, but let’s look carefully at the new parts.</p>

  <h4 class="h4" id="ch00leve1sec169"><em><strong>Importing a Private Key</strong></em></h4>

  <p class="noindent">To send money from our program, we need to import the private key of the Bitcoin address from the previous example. Here is the code that does this:</p>
  <pre class="programs">
DumpedPrivateKey key = new DumpedPrivateKey(params,<span class="ent">➊</span><br/>          "<span class="codeitalic">L1vJHdDqQ5kcY5q4QoY124zD21UVgFe6NL2835mp8UgG2FNU94Sy</span>");<br/>wallet.addKey(key.getKey());<span class="ent">➋</span><br/>BlockChain chain = new BlockChain(params, wallet,<span class="ent">➌</span><br/>          new MemoryBlockStore(params));
</pre>

  <p class="indent">In the first lines, we’re explicitly adding a new, preexisting private key to our wallet <span class="ent">➊</span><span class="ent">➋</span>. This is the key associated with the Bitcoin address that received the money in the <code>hello-money</code> program. You need to replace the private key shown on this line with the private key you wrote down when running the previous example. Also, in this new program we’re not using the <code>SPVBlockStore</code> function; instead, we’re using bitcoinJ’s <code>MemoryBlockStore</code> <span class="ent">➌</span> function for variety. This block store won’t create a file, but by using it, our program will need to redownload the blockchain every time the program runs. (This also guarantees that bitcoinJ will assign the correct balance to the wallet. We’ll discuss why in “Gotchas When Using Wallets in BitcoinJ” on <a href="../Text/app02.html#page_239">page 239</a>.)</p>

  <h4 class="h4" id="ch00leve1sec170"><a id="page_238"/><em><strong>Sending the Money</strong></em></h4>

  <p class="noindent">Now let’s look at the code that actually sends the money:</p>
  <pre class="programs">
BigInteger balance = wallet.getBalance();<span class="ent">➊</span><br/>System.out.println("Wallet balance: " + balance);<span class="ent">➋</span><br/>Address destinationAddress = new Address(params,<span class="ent">➌</span><br/>     "<span class="codeitalic">1BTCorgHwCg6u2YSAWKgS17qUad6kHmtQW</span>");<br/>BigInteger fee = BigInteger.valueOf(10000);<span class="ent">➍</span><br/>Wallet.SendRequest req = Wallet.SendRequest.to(<span class="ent">➎</span><br/>     destinationAddress,balance.subtract(fee));<br/>req.fee = fee;<span class="ent">➏</span><br/>Wallet.SendResult result = wallet.sendCoins(peerGroup, req);<span class="ent">➐</span>
</pre>

  <p class="indent">First, we get the balance contained in the wallet <span class="ent">➊</span> and display it <span class="ent">➋</span>. Next, we declare the destination address the money should be sent to <span class="ent">➌</span>. In this example, we input the main donation address for the Bitcoin Foundation; feel free to substitute a public address of one of your own wallets.</p>

  <p class="indent">Nowadays, it’s best to include a transaction fee when sending bitcoins, which we declare to be 10,000 satoshis <span class="ent">➍</span>. Next, we create a <code>SendRequest</code> object <span class="ent">➎</span>, which is a structure to hold the basic information about what we’re sending and includes the destination address and the amount to be sent (which is the balance minus the fee). Then, we set the fee on this object <span class="ent">➏</span> and send our money <span class="ent">➐</span>!</p>

  <h4 class="h4" id="ch00leve1sec171"><em><strong>Ensuring the Money Transmission</strong></em></h4>

  <p class="noindent">If we try to send more money than we have, if the fee is inadequate, or if the Internet connection drops out at the wrong moment, the money might never be accepted by the network. Therefore, we need to write code that waits and ensures that the money we sent is transmitted to the network. Here’s what we’ll add to do this:</p>
  <pre class="programs">
result.broadcastComplete.get();<span class="ent">➊</span><br/>System.out.println("The money was sent!");<span class="ent">➋</span>
</pre>

  <p class="indent">The first line of code <span class="ent">➊</span> retrieves a Java <em>future</em> object, which indicates that the send transaction has been properly broadcast to the network. (A standard in Java, futures retrieve information about a separate execution thread—in this case the thread that monitors communication with the Bitcoin network.) If this line completes without throwing an exception, we display a message indicating that the money was sent <span class="ent">➋</span>.</p>

  <h4 class="h4" id="ch00leve1sec172"><em><strong>Running bye-bye-money</strong></em></h4>

  <p class="noindent">We can run <code>bye-bye-money</code> in the usual way (remember to input your own private key):</p>
  <pre class="programs">
<span class="codestrong">&gt; mvn install</span><br/><span class="codestrong">&gt; mvn exec:java</span>
</pre>

  <div class="sidebar">
    <p class="sidebart"><a id="page_239"/><strong>EXCEPTION TYPES IN BITCOINJ</strong></p>

    <p class="noindent">One feature we skimped on in this example is error handling: The main function simply rethrows a variety of different exceptions for operations that can go wrong as we attempt to send our money. These include the following exceptions:</p>

    <p class="bullt">• <code>BlockStoreException</code>: This is thrown when the block store cannot be created (most commonly, this happens with block store types that write to a file when something corrupts the file).</p>

    <p class="bull">• <code>AddressFormatException</code>: This is thrown when the format of the address is incorrect.</p>

    <p class="bull">• <code>InterruptedException</code>: This is thrown when network connection problems occur.</p>

    <p class="bull">• <code>ExecutionException</code>: This is thrown when we’re using a future object and an exception occurs in the other thread (as happens when we check for completion of the transaction broadcast).</p>

    <p class="indentt">In a more sophisticated Bitcoin app, you should catch all of these exception types separately and add more descriptive error messages for your app’s users.</p>
  </div>

  <p class="indent">Because this program churns through the blockchain in memory, you’ll need to wait a few minutes or more for it to complete (even when you rerun it). If the program is successful, you’ll see the message <em>The money was sent!</em>, and the money should arrive at the destination wallet. You can also access a blockchain information site (such as <em><a href="http://blockchain.info/">http://blockchain.info/</a></em>), enter the source or destination address, and see that the details of the transaction are part of the public record.</p>

  <p class="indent">Congratulations! You now understand the basics of writing a Bitcoin application!</p>

  <h3 class="h3" id="ch00leve1sec173"><strong>Gotchas When Using Wallets in BitcoinJ</strong></h3>

  <p class="noindent">To the novice, the way wallets and the <code>BlockChain</code> object work in bitcoinJ can be very confusing. If you don’t fully understand bitcoinJ’s behavior, bitcoinJ can also report incorrect wallet balances.</p>

  <p class="indent">This happens because bitcoinJ is optimized around the concept of an SPV blockchain. The performance benefits of SPV blockchains were discussed earlier, but because they contain only limited blockchain data, you need to follow a few basic rules to ensure they work properly for you in bitcoinJ:</p>

  <p class="ordert">1. If your app’s wallet already has money in it, bitcoinJ needs to know the amount <em>before</em> the blockchain is downloaded from the network.</p>

  <p class="order"><a id="page_240"/>2. After the blockchain is loaded, bitcoinJ will perform the necessary tasks to ensure the wallet’s accuracy as new transactions appear on the network.</p>

  <p class="order">3. If you use a block store type that supports saving to a disk file, your app is responsible for saving the wallet to a file, as well (it is also responsible for loading the block store and wallet data).</p>

  <p class="indentt">As you saw when we constructed a <code>BlockChain</code> object, bitcoinJ expects the app to pass in a wallet object. This allows the wallet to be updated when relevant <em>historical</em> transactions are found in downloaded blocks and allows rule #1 to be enforced: <em>Be sure not to add additional keys to your wallet after the fact and expect your wallet to work without redownloading the blockchain.</em></p>

  <p class="indent">Similarly, when we initialized the <code>PeerGroup</code> object, we called <code>addWallet()</code> to add our wallet to the peer group. By doing so, bitcoinJ keeps the wallet balance in sync with any <em>new</em> transactions that appear in the Bitcoin network as the program is running, enforcing rule #2.</p>

  <p class="indent">To make sure rule #3 is adhered to, you can use the <code>Wallet.loadFromFile()</code> and <code>Wallet.saveToFile()</code>functions. A <code>Wallet.autoSaveToFile()</code> function is also available that can help with loading and saving the block store and wallet data. To learn how to use these functions properly, look at the example programs in the bitcoinJ repository.</p>

  <p class="indent">If you keep the previously listed three basic tenets in mind, you’ll avoid most of the pitfalls that accompany mastering bitcoinJ.</p>

  <h3 class="h3" id="ch00leve1sec174"><strong>Conclusion</strong></h3>

  <p class="noindent">We hope you’ve enjoyed this tour of bitcoinJ programming, and we look forward to seeing any awesome new apps that you build. After all, the app you build just might completely reinvent how people interact with their money in the Internet age!</p>
</body></html>