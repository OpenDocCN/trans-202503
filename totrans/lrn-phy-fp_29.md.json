["```\n{-# OPTIONS -Wall #-}\n\nmodule Current where\n\nimport SimpleVec\n    ( R, Vec, sumV, (><), (*^) )\nimport CoordinateSystems\n    ( VectorField, rVF, cyl, phiHat )\nimport Geometry\n    ( Curve(..), Surface(..), Volume(..) )\nimport ElectricField\n    ( CurveApprox, curveSample, surfaceSample, volumeSample\n    , vectorSurfaceIntegral, vectorVolumeIntegral )\n```", "```\ntype Current = R\n```", "```\ndata CurrentDistribution\n  = LineCurrent    Current    Curve\n  | SurfaceCurrent VectorField Surface\n  | VolumeCurrent  VectorField Volume\n  | MultipleCurrents [CurrentDistribution]\n```", "```\ncircularCurrentLoop :: R  -- radius\n                    -> R  -- current\n                    -> CurrentDistribution\ncircularCurrentLoop radius i\n    = LineCurrent i (Curve (\\phi -> cyl radius phi 0) 0 (2*pi))\n```", "```\nwireSolenoid :: R  -- radius\n             -> R  -- length\n             -> R  -- turns/length\n             -> R  -- current\n             -> CurrentDistribution\nwireSolenoid radius len n i\n    = LineCurrent i (Curve (\\phi -> cyl radius phi (phi/(2*pi*n)))\n                               (-pi*n*len) (pi*n*len))\n```", "```\nsheetSolenoid :: R  -- radius\n              -> R  -- length\n              -> R  -- turns/length\n              -> R  -- current\n              -> CurrentDistribution\nsheetSolenoid radius len n i\n    = SurfaceCurrent (\\r -> (n*i) *^ phiHat r)\n      (Surface (\\(phi,z) -> cyl radius phi z)\n       0 (2*pi) (const $ -len/2) (const $ len/2))\n```", "```\nwireToroid :: R  -- small radius\n           -> R  -- big radius\n           -> R  -- number of turns\n           -> R  -- current\n           -> CurrentDistribution\nwireToroid smallR bigR n i\n    = let alpha phi = n * phi\n          curve phi = cyl (bigR + smallR * cos (alpha phi)) phi\n                      (smallR * sin (alpha phi))\n      in LineCurrent i (Curve curve 0 (2*pi))\n```", "```\ncrossedLineIntegral :: CurveApprox -> VectorField -> Curve -> Vec\ncrossedLineIntegral approx vF c\n    = sumV [vF r' >< dl' | (r',dl') <- approx c]\n```", "```\nmagneticDipoleMoment :: CurrentDistribution -> Vec\nmagneticDipoleMoment (LineCurrent    i c)\n    = crossedLineIntegral   (curveSample  1000) (\\r -> 0.5 *^ i *^ rVF r) c\nmagneticDipoleMoment (SurfaceCurrent k s)\n    = vectorSurfaceIntegral (surfaceSample 200) (\\r -> 0.5 *^ (rVF r >< k r)) s\nmagneticDipoleMoment (VolumeCurrent  j v)\n    = vectorVolumeIntegral  (volumeSample   50) (\\r -> 0.5 *^ (rVF r >< j r)) v\nmagneticDipoleMoment (MultipleCurrents ds    )\n    = sumV [magneticDipoleMoment d | d <- ds]\n```", "```\nhelmholtzCoil :: R  -- radius\n              -> R  -- current\n              -> CurrentDistribution\nhelmholtzCoil radius i = undefined radius i\n```", "```\nlongStraightWire :: R  -- wire length\n                 -> R  -- current\n                 -> CurrentDistribution\nlongStraightWire len i = undefined len i\n```", "```\ntorus :: R -> R -> Surface\ntorus smallR bigR\n    = Surface (\\(phi,alpha) -> cyl (bigR + smallR * cos alpha) phi\n                               (smallR * sin alpha))\n      0 (2*pi) (const 0) (const $ 2*pi)\n```", "```\ntotalCurrent :: VectorField  -- volume current density\n             -> Surface\n             -> Current      -- total current through surface\ntotalCurrent j s = undefined j s\n```"]