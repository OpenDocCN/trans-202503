- en: '**8 Basics of JTAG and ICSP**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JTAG interface is a very low-level way of communicating with a microcontroller,
    either for debugging or for initial programming at the device factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'JTAG consists of four mandatory signals: TDI, TDO, TCK, and TMS. TDI and TDO
    (Test Data In/Out) ferry data in and out of a chip, while TCK provides a clock
    for that data and TMS (Test Mode Select) directs the state of a chip. An optional
    fifth signal, TRST, can reset the testing logic.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also some reduced-pin variants of JTAG, such as single wire debug
    (SWD) for ARM and spy-bi-wire for MSP430\. These are convenient in that they require
    fewer pins, and are sometimes easier to implement than the 4-wire variants of
    the protocols.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t yet dig into the intricate details of these protocols, but it’s worth
    understanding a bit of history. JTAG began as a way to test connectivity on a
    PCB, and only later was extended to debugging microcontrollers. Debugging access
    to a chip is often very low level, and must be implemented differently for different
    revisions of a chip.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to JTAG, many microcontroller vendors have their own serial interfaces
    for programming or debugging. The PIC and AVR lines from Microchip call this in-circuit
    serial programming (ICSP).
  prefs: []
  type: TYPE_NORMAL
- en: '**JTAG Adapters and Software**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JTAG began as just a physical layer, but a whole ecosystem of software and tools
    have been built above it. Some of this is documented; some of this is secret or
    proprietary. That’s why the choice of tools is so confusing.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that most embedded developers don’t know off-hand the number
    of pipeline stages of their favorite microcontroller, they rarely need to bother
    with implementing JTAG from scratch. For the purposes of firmware extraction,
    we should remember the difference between using an off-the-shelf adapter and writing
    a new adapter from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: On the hardware front, most popular microcontroller vendors offer their own,
    semi-proprietary adapters. These can be expensive, but there is a loophole in
    that the same adapters are included on development boards, and often a very cheap
    evaluation kit (EVK) can be rewired for debugging any chip, not just the model
    that it shipped with.
  prefs: []
  type: TYPE_NORMAL
- en: There are also vendors who specialize in JTAG adapters that work for a wide
    variety of boards. Segger’s J-Link is particularly popular, available in models
    ranging from a cheap student kit to fiendishly expensive models. The fancy adapters
    are capable not just of debugging code, but also of tracing it live with little
    or no performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: And finally there are open source adapters, such as my old GoodFET for the MSP430\.
    A popular solution is to use an FTDI chip to big-bang IO for debugging a wide
    variety of targets. You might also use the GPIO pins of a Raspberry Pi, as those
    pins have far less latency than a USB adapter.
  prefs: []
  type: TYPE_NORMAL
- en: On the software front, both proprietary and open software exists. Proprietary
    software often offers advantages in recording power usage and execution tracing,
    and it is sometimes better integrated into the commercial development tools. While
    the propriety software can be directed through developer APIs, open source alternatives
    include scripts for a wide variety of chips and can often be very quickly adapted
    to new targets. OpenOCD is not the only open source adapter, but it’s usually
    a good target for getting a GDB debugging session on a new chip.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovering the Pinout**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a known chip in a convenient package with good documentation, it’s little
    trouble to trace out the JTAG pins, which should be clearly marked on the datasheet.
    But what should you do when the pinout is unknown, or the chip itself undocumented?
    Luckily, we have some options.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, many PCB designers use an industry-standard JTAG connectors
    for their architecture. If you see a header in two rows near your chip of interest
    with 10, 14 or 20 pins, it’s a good bet that’s JTAG. The bet gets stronger if
    the ground pins match the standard and the data pins go directly to your chip.
    PIC and AVR chips don’t support JTAG, but they have their own six pin standards.
    See [Figure 8.1](ch08.xhtml#ch8fig1) for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Violations of the standards occur, of course. In security-themed devices like
    the HID iClass readers in [Chapter 12](ch12.xhtml#ch12), this might be to frustrate
    reverse engineering. You’ll also see deviations from the standard layouts for
    other reasons, with pins swapped by accident or by the PCB designer’s confusion
    between the wide variety of 14-pin debugger standards.
  prefs: []
  type: TYPE_NORMAL
- en: Heinz (2006) describes an AVR firmware, GTK GUI, and algorithm for identifying
    the JTAG signals from candidate pins, which works by using the 1-bit BYPASS register
    to echo a signal back from the target. That project is no longer maintained, but
    Grand (2014) describes the JTAGulator, a modern open-source JTAG pinout finder
    built around the Parallax Propeller chip.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0094-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Common JTAG and ICSP Pinouts'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0094-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: JTAGulator from Grand (2014)'
  prefs: []
  type: TYPE_NORMAL
- en: If we can find the pins automatically, and if JTAG is really just a way to shuffle
    some registers back and forth, it ought to be possible to enumerate the registers,
    dumping a list for further investigation. Domke (2009) provides an algorithm and
    examples for doing exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: In factories, JTAG not only programs chips, but it also verifies the connections
    between them, ensuring that all pins have been soldered. Skowronek (2007) describes
    an algorithm for recovering the pin connections between many chips, which was
    successfully used to reverse engineer video processing boards that he had rescued
    from a scrap heap, allowing him to build a cracker for searching the 8-character
    keyspace of SHA-1 and MD5 in about a day.
  prefs: []
  type: TYPE_NORMAL
- en: '**Total JTAG Locks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve covered how JTAG works, how its pins can be found, and which
    JTAG hardware and software to use, let’s cover the protection mechanisms used
    in specific chips. Later in this book, we’ll dedicate whole chapters to bypassing
    individual protections.
  prefs: []
  type: TYPE_NORMAL
- en: The MSP430 is a good example of JTAG with a total lock. Early chips, such as
    the MSP430F1xx, MSP430F2xx, and MSP430-F4xx, burn a fuse to enable protection
    mode. Just after the JTAG debugger connects, a fuse check sequence measures the
    protection state of the chip. In later chips, the electromigration fuse was replaced
    with a special word of flash memory, but the concept of total lockout was retained.
    These details are described in Texas Instruments (2010), more or less well enough
    to implement a JTAG programmer from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, total lockouts don’t seem to give us much room to work with,
    or leave much attack surface to explore. How can we unlock a chip that only exposes
    a useless BYPASS register?
  prefs: []
  type: TYPE_NORMAL
- en: One method is to avoid it entirely by attacking its bootloader. The MSP430,
    like many other chips, has a mask ROM bootloader that remains enabled even after
    JTAG is locked. [Chapter E.8](app05.xhtml#app05_8) describes an attack that does
    just this, glitching the bootloader of the MSP430F5172 to dump the firmware even
    when JTAG is totally disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is fault injection to falsify the result of the fuse check. We
    can glitch the chip at the moment of the fuse check so that the check passes when
    it ought to fail. See [Chapter 20](ch20.xhtml#ch20) for details of glitching the
    fuse check of older MSP430 chips by injecting the light of a camera flash.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial JTAG Locks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Total JTAG locks are simple to implement, but they make designers nervous because
    they leave precious little room for failure analysis. If Bob’s widget fails, he
    wants to know as quickly as possible whether it was the fault of the hardware
    or the firmware, and without a debugger he won’t have much to work with. So rather
    than have Bob implement his own custom backdoor, many chip manufacturers allow
    for a partial lockout, attempting to protect Bob’s intellectual property while
    still allowing new firmware to be written into the chip.
  prefs: []
  type: TYPE_NORMAL
- en: The nRF51 chip from Nordic Semiconductor is a very popular chip for Bluetooth
    Low Energy (BLE). It uses a partial protection mechanism built around its memory
    protection unit (MPU), which disallows any memory access from the debugger. You
    can single-step existing code, reading and writing CPU registers to your heart’s
    content, but you’ll be disconnected the very clock cycle that you try to directly
    fetch a word from RAM or flash memory. Kris Brosch discovered a loophole, in that
    while you cannot read from flash memory yourself, you can find a gadget in flash
    memory that will do the work for you. See [Chapter 9](ch09.xhtml#ch09).
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F0 family also provides a partial debug lock. After JTAG begins to
    debug the CPU, flash memory will be disconnected from the bus whenever *any* access
    to flash is performed, whether by the debugger itself or by the CPU code. You
    can’t reuse flash code to fetch the instructions for you, because executing from
    flash will also trigger the lockout if a debugger is attached. Luckily for an
    attacker, this lockout occurs just one clock cycle too late, so it’s possible
    to read exactly one word of flash memory after every JTAG connection, and with
    many thousands of connections, the entire firmware can be extracted. See [Chapter
    10](ch10.xhtml#ch10) for details.
  prefs: []
  type: TYPE_NORMAL
- en: Some other STM32 devices have a partial lockout that is not vulnerable to the
    first-word exposure of the STM32F0\. On these devices, there is a devilishly clever
    loophole in which a separate memory bus is used for accessing the interrupt vector
    table (IVT) during an interrupt call. Normally this table is at the very beginning
    of flash memory, but an attacker can use the vector table offset register (VTOR)
    to slide the interrupt table, dumping words of protected memory by triggering
    interrupt calls and then reading back the program counter! See [Chapter 11](ch11.xhtml#ch11).
  prefs: []
  type: TYPE_NORMAL
- en: Even when we don’t have a JTAG exploit for the chip in question, a partial JTAG
    lock can be useful for other purposes. Often, SRAM can be freely read when flash
    memory is locked, or shell-code can be written into unused portions of SRAM to
    be executed by a software bug after the next boot. And the complexity of a modern
    CPU, even that of a microcontroller, is such that nifty corner cases must exist
    somewhere, if only we look closely enough to find them.
  prefs: []
  type: TYPE_NORMAL
