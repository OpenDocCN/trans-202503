- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: MEMORY ORGANIZATION AND ACCESS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存组织与访问**'
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/comm1.jpg)'
- en: 'This chapter describes the basic components of a computer system: the CPU,
    memory, I/O, and the bus that connects them. We’ll begin by discussing bus organization
    and memory organization. These two hardware components may have as large a performance
    impact on your software as the CPU’s speed. Understanding memory performance characteristics,
    data locality, and cache operation can help you design software that runs as fast
    as possible.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了计算机系统的基本组件：CPU、内存、I/O以及连接它们的总线。我们将首先讨论总线组织和内存组织。这两个硬件组件对软件的性能影响可能与CPU的速度一样大。了解内存性能特性、数据局部性和缓存操作可以帮助你设计出尽可能快速运行的软件。
- en: '**6.1 The Basic System Components**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.1 基本系统组件**'
- en: 'The basic operational design of a computer system is called its *architecture*.
    John von Neumann, a pioneer in computer design, is credited with the principal
    architecture in use today. For example, the 80x86 family uses the *[von Neumann
    architecture (VNA)](gloss01.xhtml#gloss01_260)*. A typical VNA has three major
    components: the *[central processing unit (CPU)](gloss01.xhtml#gloss01_46)*, *memory*,
    and *input/output (I/O)*, as shown in [Figure 6-1](ch06.xhtml#ch06fig01).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统的基本操作设计称为其*架构*。计算机设计的先驱约翰·冯·诺依曼被认为是今天使用的主要架构的创立者。例如，80x86系列采用了*[冯·诺依曼架构（VNA）](gloss01.xhtml#gloss01_260)*。典型的VNA包含三个主要组件：*[中央处理单元（CPU）](gloss01.xhtml#gloss01_46)*、*内存*和*输入/输出（I/O）*，如[图6-1](ch06.xhtml#ch06fig01)所示。
- en: '![image](../images/06fig01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig01.jpg)'
- en: '*Figure 6-1: Typical von Neumann machine*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：典型的冯·诺依曼机器*'
- en: In VNA machines, like the 80x86 systems, all computations occur within the CPU.
    Data and machine instructions reside in memory until the CPU requires them, at
    which point the system transfers the data into the CPU. To the CPU, most I/O devices
    look like memory; the major difference between them is that I/O devices are generally
    located in the outside world, whereas memory is located within the same machine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在VNA机器中，如80x86系统，所有计算都在CPU内部进行。数据和机器指令存储在内存中，直到CPU需要它们为止，此时系统会将数据传输到CPU中。对于CPU而言，大多数I/O设备看起来像内存；它们之间的主要区别在于，I/O设备通常位于外部世界，而内存则位于同一台机器内。
- en: '***6.1.1 The System Bus***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.1.1 系统总线***'
- en: 'The *[system bus](gloss01.xhtml#gloss01_243)* connects the various components
    of a VNA machine. A *bus* is a collection of wires on which electrical signals
    pass between system components. Most CPUs have three major buses: the *data* bus,
    the *address* bus, and the *control* bus. These buses vary from processor to processor,
    but each bus carries comparable information on most CPUs. For example, the data
    buses on the Pentium and 80386 have different implementations, but both variants
    carry data between the processor, I/O, and memory.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*[系统总线](gloss01.xhtml#gloss01_243)*连接VNA机器的各个组件。*总线*是一组电线，电信号通过这些电线在系统组件之间传递。大多数CPU有三条主要总线：*数据*总线、*地址*总线和*控制*总线。这些总线在不同处理器之间有所不同，但每条总线在大多数CPU中传输相似的信息。例如，Pentium和80386的数据信号总线有不同的实现，但这两种变体都在处理器、I/O和内存之间传输数据。'
- en: '**6.1.1.1 The Data Bus**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.1.1.1 数据总线**'
- en: CPUs use the data bus to shuttle data between the various components in a computer
    system. The size of this bus varies widely among CPUs. Indeed, bus size (or *width*)
    is one of the main attributes that defines the “size” of the processor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CPU使用数据总线在计算机系统的各个组件之间传输数据。这个总线的大小在不同CPU之间差异很大。实际上，总线大小（或*宽度*）是定义处理器“大小”的主要属性之一。
- en: Most modern, general-purpose CPUs (such as those in PCs) employ a 32-bit-wide
    or, more commonly, 64-bit-wide data bus. Some processors use 8-bit or 16-bit data
    buses, and there may well be some CPUs with 128-bit data buses by the time you
    read this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代通用CPU（如PC中的CPU）采用32位宽或更常见的64位宽数据总线。有些处理器使用8位或16位数据总线，到你读到这本书的时候，也许已经有128位数据总线的CPU了。
- en: 'You’ll often hear the terms *8-*, *16-*, *32-*, or *64-bit processor*. Processor
    size is determined by whichever value is smaller: the number of data lines on
    the processor or the size of the largest general-purpose integer register. For
    example, older Intel 80x86 CPUs all have 64-bit buses but only 32-bit general-purpose
    integer registers, so they’re classified as 32-bit processors. The AMD (and newer
    Intel) x86-64 processors support 64-bit integer registers and a 64-bit bus, so
    they’re 64-bit processors.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会听到 *8 位*、*16 位*、*32 位* 或 *64 位处理器* 这样的术语。处理器的大小由较小的值决定：处理器的数据线数量或最大通用整数寄存器的大小。例如，旧的
    Intel 80x86 CPU 都有 64 位总线，但只有 32 位的通用整数寄存器，因此它们被归类为 32 位处理器。AMD（以及更新的 Intel）x86-64
    处理器支持 64 位整数寄存器和 64 位总线，因此它们是 64 位处理器。
- en: Although the 80x86 family members with 8-, 16-, 32-, and 64-bit data buses can
    process data blocks up to the bit width of the bus, they can also access smaller
    memory units of 8, 16, or 32 bits. Therefore, anything you can do with a small
    data bus can be done with a larger data bus as well; the larger data bus, however,
    may access memory faster and can access larger chunks of data in one memory operation.
    You’ll read about the exact nature of these memory accesses a little later in
    this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具有 8 位、16 位、32 位和 64 位数据总线的 80x86 系列处理器可以处理与总线位宽相同大小的数据块，但它们也可以访问更小的内存单元（8
    位、16 位或 32 位）。因此，任何小数据总线可以完成的任务，大数据总线也能完成；然而，较大的数据总线可能能更快地访问内存，并且能在一次内存操作中访问更大的数据块。你将在本章稍后了解这些内存访问的具体性质。
- en: '**6.1.1.2 The Address Bus**'
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.1.1.2 地址总线**'
- en: The data bus on an 80x86 family processor transfers information between a particular
    memory location or I/O device and the CPU. *Which* memory location or I/O device
    is where the address bus comes in. The system designer assigns each memory location
    and I/O device a unique memory address. When the software wants to access a particular
    memory location or I/O device, it places the corresponding address on the address
    bus. Circuitry within the device checks the address and, if it matches, transfers
    data. All other memory locations ignore the request on the address bus.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 系列处理器的数据总线在特定的内存位置或 I/O 设备与 CPU 之间传输信息。*哪个*内存位置或 I/O 设备就是地址总线的作用所在。系统设计师为每个内存位置和
    I/O 设备分配一个唯一的内存地址。当软件想要访问特定的内存位置或 I/O 设备时，它将相应的地址放到地址总线上。设备内部的电路检查该地址，如果匹配，则传输数据。所有其他内存位置会忽略地址总线上的请求。
- en: 'With a single address bus line, a processor can access exactly two unique addresses:
    0 and 1\. With *n* address lines, the processor can access 2^(*n*) unique addresses
    (because there are 2^(*n*) unique values in an *n*-bit binary number). The number
    of bits on the address bus determines the *maximum* number of addressable memory
    and I/O locations. Early 80x86 processors, for example, provided only 20 lines
    on the address bus. Therefore, they could access only up to 1,048,576 (or 2^(20))
    memory locations. Larger address buses can access more memory (see [Table 6-1](ch06.xhtml#ch06tab01)).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单个地址总线线，处理器可以访问两个唯一地址：0 和 1。通过 *n* 根地址线，处理器可以访问 2^(*n*) 个唯一地址（因为 *n* 位二进制数中有
    2^(*n*) 个唯一值）。地址总线的位数决定了*最大*可寻址的内存和 I/O 位置数量。例如，早期的 80x86 处理器仅提供 20 根地址总线线。因此，它们最多只能访问
    1,048,576（或 2^(20)）个内存位置。更大的地址总线可以访问更多的内存（请参见 [表 6-1](ch06.xhtml#ch06tab01)）。
- en: '**Table 6-1:** 80x86 Addressing Capabilities'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1:** 80x86 地址能力'
- en: '| **Processor** | **Address bus size** | **Maximum addressable memory** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **处理器** | **地址总线大小** | **最大可寻址内存** |'
- en: '| 8088, 8086, 80186, 80188 | 20 | 1,048,576 (1MB) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 8088, 8086, 80186, 80188 | 20 | 1,048,576 (1MB) |'
- en: '| 80286, 80386sx | 24 | 16,777,216 (16MB) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 80286, 80386sx | 24 | 16,777,216 (16MB) |'
- en: '| 80386dx | 32 | 4,294,976,296 (4GB) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 80386dx | 32 | 4,294,976,296 (4GB) |'
- en: '| 80486, Pentium | 32 | 4,294,976,296 (4GB) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 80486, Pentium | 32 | 4,294,976,296 (4GB) |'
- en: '| Pentium Pro, II, III, IV | 36 | 68,719,476,736 (64GB) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Pentium Pro, II, III, IV | 36 | 68,719,476,736 (64GB) |'
- en: '| Core, i3, i5, i7, i9 | ≥ 40 | ≥1,099,511,627,776 (≥1TB) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| Core, i3, i5, i7, i9 | ≥ 40 | ≥1,099,511,627,776 (≥1TB) |'
- en: Newer processors will support larger address buses. Many other processors (such
    as ARM and IA-64) already provide much larger addresses buses and, in fact, support
    addresses up to 64 bits in the software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的处理器将支持更大的地址总线。许多其他处理器（如 ARM 和 IA-64）已经提供了更大的地址总线，实际上，在软件中支持高达 64 位的地址。
- en: A 64-bit address range is truly infinite as far as memory is concerned. No one
    will ever put 2^(64) bytes of memory into a computer system and feel that they
    need more. Of course, people have made claims like this in the past. A few years
    ago, no one ever thought a computer would need 1GB of memory, yet computers with
    64GB of memory (or more) are very common today. However, 2^(64) is effectively
    infinity for one simple reason—it’s physically impossible to build that much memory
    based on estimates of the current size (about 2^(86) different elementary particles)
    of the universe. Unless you can attach 1 byte of memory to every elementary particle
    on the planet, you won’t even come close to approaching 2^(64) bytes of memory
    on a given computer system. Then again, maybe we really will use whole planets
    as computer systems one day, as Douglas Adams predicted in *The Hitchhiker’s Guide
    to the Galaxy*. Who knows?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就内存而言，64位地址范围实际上是无限的。没有人会在计算机系统中放入2^(64)字节的内存，并感到还需要更多。当然，过去人们曾做过类似的预测。几年前，没有人会认为计算机需要1GB的内存，而如今配备64GB内存（或更多）的计算机已经非常常见。然而，2^(64)实际上等同于无限，原因很简单——根据当前宇宙的估计大小（大约是2^(86)个不同的基本粒子），物理上是不可能构建出这么多内存的。除非你能将每个基本粒子连接1字节的内存，否则即使是整个地球上的所有内存也无法接近2^(64)字节的内存。当然，也许有一天我们真会像道格拉斯·亚当斯在《银河系漫游指南》中预测的那样，使用整个行星作为计算机系统，谁知道呢？
- en: While the newer 64-bit processors have an internal 64-bit address space, they
    rarely bring out 64 address lines on the chip. This is because pins are a precious
    commodity on large CPUs, and it doesn’t make sense to bring out extra address
    pins that will never be used. Currently, 40- to 52-bit address buses are the upper
    limit. In the distant future, this may expand a bit, but it’s hard to imagine
    the need for, or even possibility of, a physical 64-bit address bus.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然较新的64位处理器具有64位的内部地址空间，但它们很少在芯片上引出64条地址线。这是因为在大型CPU中引脚是宝贵资源，没必要引出那些永远不会使用的额外地址引脚。目前，40到52位地址总线是上限。在遥远的未来，可能会有所扩展，但很难想象会有需要或甚至可能实现物理64位地址总线的情况。
- en: On modern processors, CPU manufacturers are building memory controllers directly
    onto the CPU. Instead of having a traditional address and data bus to which you
    connect arbitrary memory devices, newer CPUs contain specialized buses intended
    to talk to very specific *dynamic random-access memory (DRAM)* modules. A typical
    CPU’s memory controller connects to only a certain number of DRAM modules; thus,
    the maximum DRAM you can easily connect to a CPU is a function of the memory control
    built into the CPU rather than the size of the external address bus. This is why
    some older laptops have a 16MB or 32MB maximum memory limitation even though they
    have 64-bit CPUs.^([1](footnotes.xhtml#fn6_1a))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代处理器中，CPU制造商将内存控制器直接集成到CPU中。新型CPU不再采用传统的地址和数据总线来连接任意内存设备，而是包含专用的总线，用于与非常特定的*动态随机存取内存（DRAM）*模块进行通信。典型的CPU内存控制器仅连接到一定数量的DRAM模块；因此，您可以轻松连接到CPU的最大DRAM容量，取决于集成在CPU中的内存控制，而不是外部地址总线的大小。这也是为什么一些较旧的笔记本电脑即便拥有64位CPU，仍然存在16MB或32MB最大内存限制的原因。^([1](footnotes.xhtml#fn6_1a))
- en: '**6.1.1.3 The Control Bus**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.1.1.3 控制总线**'
- en: The control bus is an eclectic collection of signals that control how the processor
    communicates with the rest of the system. To understand its importance, consider
    the data bus for a moment. The CPU uses the data bus to move data between itself
    and memory. The system uses two lines on the control bus, *read* and *write*,
    to determine the data flow direction (CPU to memory, or memory to CPU). So, when
    the CPU wants to write data to memory, it *asserts* (places a signal on) the write
    control line. When the CPU wants to read data from memory, it asserts the read
    control line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 控制总线是一个多样化的信号集合，用于控制处理器如何与系统的其余部分进行通信。为了理解它的重要性，先考虑一下数据总线。CPU使用数据总线在自己与内存之间传输数据。系统通过控制总线上的两条线，*读取*和*写入*，来确定数据流动的方向（从CPU到内存，或从内存到CPU）。因此，当CPU想要将数据写入内存时，它会*激活*（在控制线中放置信号）写入控制线。当CPU想要从内存读取数据时，它会激活读取控制线。
- en: Although the exact composition of the control bus varies among processors, some
    control lines—like the system clock lines, interrupt lines, status lines, and
    byte enable lines—are common to all processors. The byte enable lines appear on
    the control bus of some CPUs that support byte-addressable memory. These control
    lines allow 16-, 32-, and 64-bit processors to deal with smaller chunks of data
    by communicating the size of the accompanying data. Additional details appear
    in the sections “16-Bit Data Buses” on page [138](#page_138) and “32-Bit Data
    Buses” on [page 140](#page_140).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管控制总线的确切组成在不同的处理器之间有所不同，但一些控制线——如系统时钟线、 interrupt线、状态线和字节使能线——在所有处理器中都是共同的。字节使能线出现在一些支持字节可寻址内存的CPU的控制总线上。这些控制线允许16位、32位和64位处理器通过传递伴随数据的大小来处理更小的数据块。更多细节请参见“16位数据总线”章节，位于[第138页](#page_138)和“32位数据总线”章节，位于[第140页](#page_140)。
- en: 'On the 80x86 family of processors, the control bus also contains a signal that
    helps distinguish between address spaces. The 80x86 family, unlike many other
    processors, provides two distinct address spaces: one for memory and one for I/O.
    However, it has only one physical address bus, shared between I/O and memory,
    so additional control lines decide which component the address is intended for.
    When these signals are active, the I/O devices use the address on the LO 16 bits
    of the address bus. When they’re inactive, the I/O devices ignore them, and the
    memory subsystem takes over at that point.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在80x86系列处理器中，控制总线还包含一个信号，用于区分不同的地址空间。与许多其他处理器不同，80x86系列提供了两个不同的地址空间：一个用于内存，另一个用于I/O。然而，它只有一个物理地址总线，I/O和内存共享这个总线，因此需要额外的控制线来决定该地址指向哪个组件。当这些信号处于激活状态时，I/O设备使用地址总线的低16位地址；当它们处于非激活状态时，I/O设备忽略这些信号，内存子系统接管地址总线。
- en: '**6.2 Physical Organization of Memory**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.2 内存的物理组织**'
- en: A typical CPU addresses a maximum of 2^(*n*) different memory locations, where
    *n* is the number of bits on the address bus (most computer systems built around
    80x86 family CPUs do not include the maximum addressable amount of memory). But
    what exactly is a memory location? The 80x86, as an example, supports *[byte-addressable
    memory](gloss01.xhtml#gloss01_40)*. Therefore, the basic memory unit is a byte.
    With address buses containing 20, 24, 32, 36, or 40 address lines, the 80x86 processors
    can address 1MB, 16MB, 4GB, 64GB, or 1TB of memory, respectively. Some CPU families
    do not provide byte-addressable memory; instead, they commonly address memory
    only in double-word or even quad-word chunks. However, because of the vast amount
    of software that *assumes* memory is byte-addressable (such as all those C/C++
    programs out there), even CPUs that don’t support byte-addressable memory in hardware
    still use byte addresses and simulate byte addressing in software. We’ll return
    to this topic shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的CPU最多可以寻址2^(*n*)个不同的内存位置，其中 *n* 是地址总线上的位数（大多数基于80x86系列CPU构建的计算机系统并不包括最大可寻址的内存量）。但内存位置究竟是什么呢？以80x86为例，它支持*[字节可寻址内存](gloss01.xhtml#gloss01_40)*。因此，基本的内存单元是字节。80x86处理器通过包含20、24、32、36或40条地址线的地址总线，可以分别寻址1MB、16MB、4GB、64GB或1TB的内存。一些CPU系列不提供字节可寻址内存；相反，它们通常仅以双字或甚至四字块寻址内存。然而，由于大量软件*假设*内存是字节可寻址的（比如所有C/C++程序），即使是那些硬件上不支持字节可寻址内存的CPU，仍然会使用字节地址并在软件中模拟字节寻址。稍后我们会回到这个话题。
- en: 'Think of memory as an array of bytes. The address of the first byte is 0 and
    the address of the last byte is 2^(*n*) – 1\. For a CPU with a 20-bit address
    bus, the following pseudo-Pascal array declaration is a good approximation of
    memory:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存视为一个字节数组。第一个字节的地址是0，最后一个字节的地址是2^(*n*) – 1。对于一个具有20位地址总线的CPU，以下伪Pascal数组声明可以很好地近似内存的组织：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To execute the equivalent of the Pascal statement `Memory [125] := 0;` the CPU
    places the value `0` on the data bus, places the address `125` on the address
    bus, and asserts the write line on the control bus, as shown in [Figure 6-2](ch06.xhtml#ch06fig02).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行等效的Pascal语句 `Memory [125] := 0;`，CPU将值`0`放置到数据总线上，将地址`125`放置到地址总线上，并在控制总线上激活写操作线，如[图6-2](ch06.xhtml#ch06fig02)所示。
- en: '![image](../images/06fig02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig02.jpg)'
- en: '*Figure 6-2: Memory write operation*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：内存写操作*'
- en: To execute the equivalent of `CPU := Memory [125];` the CPU places the address
    `125` on the address bus, asserts the read line on the control bus, and then reads
    the resulting data from the data bus (see [Figure 6-3](ch06.xhtml#ch06fig03)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行相当于`CPU := Memory [125];`的操作，CPU将地址`125`放置在地址总线上，激活控制总线上的读线，然后从数据总线上读取相应的数据（参见[图6-3](ch06.xhtml#ch06fig03)）。
- en: '![image](../images/06fig03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig03.jpg)'
- en: '*Figure 6-3: Memory read operation*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：内存读操作*'
- en: This discussion applies *only* when the processor is accessing a single byte
    in memory. What happens when it accesses a word or a double word? Because memory
    consists of an array of bytes, how can we possibly deal with values larger than
    8 bits?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个讨论*仅*适用于处理器在访问内存中的单个字节时。那么当它访问一个字或双字时会发生什么呢？因为内存由字节数组组成，我们怎么处理大于8位的值呢？
- en: Different computer systems have different solutions to this problem. The 80x86
    family stores the LO byte of a word at the address specified and the HO byte at
    the next location. Therefore, a word consumes two consecutive memory addresses
    (as you would expect, because a word consists of 2 bytes). Similarly, a double
    word consumes four consecutive memory locations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的计算机系统对于这个问题有不同的解决方案。80x86系列将一个字的低字节存储在指定的地址，并将高字节存储在下一个位置。因此，一个字消耗两个连续的内存地址（正如你所期望的，因为一个字由2个字节组成）。类似地，一个双字消耗四个连续的内存位置。
- en: The address for a word or a double word is the address of its LO byte. The remaining
    bytes follow this LO byte, with the HO byte appearing at the address of the word
    plus 1 or the address of the double word plus 3 (see [Figure 6-4](ch06.xhtml#ch06fig04)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字或双字的地址是其低字节（LO byte）的地址。其余的字节紧跟在低字节之后，高字节（HO byte）出现在字的地址加1或双字的地址加3的位置（参见[图6-4](ch06.xhtml#ch06fig04)）。
- en: It is quite possible for byte, word, and double-word values to overlap in memory.
    For example, in [Figure 6-4](ch06.xhtml#ch06fig04), you could have a word variable
    beginning at address 193, a byte variable at address 194, and a double-word value
    beginning at address 192\. Bytes, words, and double words may begin at *any* valid
    address in memory. We’ll soon see, however, that starting larger objects at an
    arbitrary address is not a good idea.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 字节、字和双字的值在内存中可能会重叠。例如，在[图6-4](ch06.xhtml#ch06fig04)中，你可能会有一个从地址193开始的字变量，一个从地址194开始的字节变量，以及一个从地址192开始的双字变量。字节、字和双字可能从内存中的*任何*有效地址开始。然而，我们很快会看到，从任意地址开始较大的对象并不是一个好主意。
- en: '![image](../images/06fig04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig04.jpg)'
- en: '*Figure 6-4: Byte, word, and double-word storage in memory (on an 80x86)*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：内存中的字节、字和双字存储（在80x86上）*'
- en: '***6.2.1 8-Bit Data Buses***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.1 8位数据总线***'
- en: A processor with an 8-bit bus (like the old 8088 CPU) can transfer 8 bits of
    data at a time. Because each memory address corresponds to an 8-bit byte, an 8-bit
    bus turns out to be the most convenient architecture (from the hardware perspective),
    as [Figure 6-5](ch06.xhtml#ch06fig05) shows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有8位总线的处理器（如老旧的8088 CPU）一次可以传输8位数据。因为每个内存地址对应一个8位字节，所以8位总线被证明是最方便的架构（从硬件角度看），正如[图6-5](ch06.xhtml#ch06fig05)所示。
- en: '![image](../images/06fig05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig05.jpg)'
- en: '*Figure 6-5: An 8-bit CPU <–> memory interface*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：8位CPU <–> 内存接口*'
- en: The term *byte-addressable memory array* means that the CPU can address memory
    in chunks as small as a single byte. It also means that this is the *smallest*
    unit of memory you can access at once with the processor. That is, if the processor
    wants to access a 4-bit value, it must read 8 bits and then ignore the extra 4
    bits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*字节寻址内存阵列*的术语意味着CPU可以以最小为单个字节的块来寻址内存。这也意味着这是你可以一次通过处理器访问的*最小*内存单元。也就是说，如果处理器想要访问一个4位的值，它必须读取8位，然后忽略额外的4位。'
- en: Byte addressability *does not* imply that the CPU can access 8 bits starting
    at any arbitrary bit boundary. When you specify address 125 in memory, you get
    the entire 8 bits at that address—nothing less, nothing more. Addresses are integers;
    you cannot specify, for example, address 125.5 to fetch fewer than 8 bits or to
    fetch a byte straddling two byte addresses.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 字节寻址*并不*意味着CPU可以从任何任意的位边界开始访问8位。当你在内存中指定地址125时，你将获取该地址的所有8位——不多也不少。地址是整数；例如，你不能指定地址125.5来获取少于8位的内容，或者获取跨越两个字节地址的字节。
- en: Although CPUs with an 8-bit data bus conveniently manipulate byte values, they
    can also manipulate word and double-word values. However, this requires multiple
    memory operations, because these processors can move only 8 bits of data at once.
    Loading a word requires two memory operations; loading a double word requires
    four memory operations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然具有8位数据总线的CPU可以方便地操作字节值，但它们也能够操作字和双字值。然而，这需要多次内存操作，因为这些处理器每次只能移动8位数据。加载一个字需要两次内存操作；加载一个双字需要四次内存操作。
- en: '***6.2.2 16-Bit Data Buses***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.2 16位数据总线***'
- en: 'Some CPUs (such as the 8086, the 80286, and variants of the ARM processor family)
    have a 16-bit data bus. This allows these processors to access twice as much memory
    in the same amount of time as their 8-bit counterparts. These processors organize
    memory into two *banks*: an “even” bank and an “odd” bank (see [Figure 6-6](ch06.xhtml#ch06fig06)).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一些CPU（例如8086、80286以及ARM处理器家族的变种）有16位数据总线。这使得这些处理器在相同时间内可以访问比其8位对手多一倍的内存。这些处理器将内存组织成两个*银行*：一个是“偶数”银行，另一个是“奇数”银行（见[图6-6](ch06.xhtml#ch06fig06)）。
- en: '![image](../images/06fig06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig06.jpg)'
- en: '*Figure 6-6: Byte addressing in word memory*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：字节寻址中的字内存*'
- en: '[Figure 6-7](ch06.xhtml#ch06fig07) illustrates the data bus connection to the
    CPU. In this figure, the data bus lines D0 through D7 transfer the LO byte of
    the word, while bus lines D8 through D15 transfer the HO byte of the word.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-7](ch06.xhtml#ch06fig07)展示了数据总线与CPU的连接。在此图中，数据总线线路D0至D7传输字的LO字节，而数据总线线路D8至D15传输字的HO字节。'
- en: The 16-bit members of the 80x86 family can load a word from any arbitrary address.
    As mentioned earlier, the processor fetches the LO byte of the value from the
    address specified and the HO byte from the next consecutive address. However,
    this creates a subtle problem. What happens when you access a word that begins
    on an odd address? Suppose you want to read a word from location 125\. The LO
    byte of the word comes from location 125 and the HO byte of the word comes from
    location 126\. It turns out that there are actually *two* problems with this approach.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86家族的16位处理器可以从任何任意地址加载字。如前所述，处理器从指定地址获取字的LO字节，从下一个连续地址获取字的HO字节。然而，这会产生一个微妙的问题。当你访问一个从奇数地址开始的字时，会发生什么呢？假设你要从位置125读取一个字。该字的LO字节来自位置125，HO字节来自位置126。事实证明，这种方法实际上存在*两个*问题。
- en: '![image](../images/06fig07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig07.jpg)'
- en: '*Figure 6-7: A 16-bit processor memory organization*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：16位处理器内存组织*'
- en: As you can see in [Figure 6-7](ch06.xhtml#ch06fig07), data bus lines 8 through
    15 (the HO byte) connect to the odd bank, and data bus lines 0 through 7 (the
    LO byte) connect to the even bank. Accessing memory location 125 will transfer
    data to the CPU on lines D8 through D15 of the data bus, placing the data in the
    HO byte, yet we need this in the LO byte! Fortunately, the 80x86 CPUs automatically
    recognize and handle this situation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图6-7](ch06.xhtml#ch06fig07)中看到的，数据总线线路8至15（HO字节）连接到奇数银行，而数据总线线路0至7（LO字节）连接到偶数银行。访问内存位置125时，会通过数据总线的D8至D15线路将数据传输到CPU，数据会放置在HO字节中，但我们需要将数据放在LO字节！幸运的是，80x86
    CPU会自动识别并处理这种情况。
- en: The second problem is even more obscure. When accessing words, we’re really
    accessing two separate bytes, each of which has its own byte address. So, what
    address appears on the address bus? The 16-bit 80x86 CPUs always place even addresses
    on the bus. Bytes at even addresses always appear on data lines D0 through D7,
    and bytes at odd addresses always appear on data lines D8 through D15\. If you
    access a word at an even address, the CPU can bring in the entire 16-bit chunk
    in one memory operation. Likewise, if you access a single byte, the CPU activates
    the appropriate bank (using a byte-enable control line) and transfers that byte
    on the appropriate data lines for its address.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题更为隐晦。当访问字时，我们实际上是在访问两个独立的字节，每个字节都有自己的字节地址。那么，地址总线上会出现什么地址呢？16位的80x86 CPU始终将偶数地址放置在总线上。位于偶数地址的字节总是出现在数据线路D0至D7上，而位于奇数地址的字节总是出现在数据线路D8至D15上。如果你访问偶数地址处的字，CPU可以通过一次内存操作将整个16位数据块加载进来。同样，如果你访问一个字节，CPU会激活适当的银行（使用字节使能控制线），并通过适当的数据线路传输该字节。
- en: But what happens when the CPU accesses a word at an odd address, like the example
    given earlier? The CPU can’t place address 125 on the address bus and read the
    16 bits from memory. There are no odd addresses coming out of a 16-bit 80x86 CPU—they’re
    always even. Therefore, if you try to put 125 on the address bus, 124 is what
    will actually appear there. Were you to read the 16 bits at this address, you
    would get the word at addresses 124 (LO byte) and 125 (HO byte)—not what you’d
    expect. Accessing a word at an odd address requires two memory operations (just
    as with the 8-bit bus on the 8088/80188). First, the CPU must read the byte at
    address 125, and then the byte at address 126\. Second, it needs to swap the positions
    of these bytes internally because both entered the CPU on the wrong half of the
    data bus.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当CPU以奇数地址访问一个字时会发生什么呢？就像之前给出的例子那样？CPU不能将地址125放入地址总线并从内存读取16位数据。16位80x86 CPU不会有奇数地址——它们总是偶数。因此，如果你尝试将125放入地址总线，实际上显示的是124。如果你在这个地址读取16位数据，你会得到地址124（低字节）和地址125（高字节）处的字——这并不是你预期的。访问奇数地址的字需要两次内存操作（就像8088/80188上的8位总线一样）。首先，CPU必须读取地址125处的字节，然后读取地址126处的字节。其次，它需要在内部交换这两个字节的位置，因为它们都进入了CPU的错误数据总线半部分。
- en: Fortunately, the 16-bit 80x86 CPUs hide these details from you. Your programs
    can access words at *any* address and the CPU will properly access and swap (if
    necessary) the data in memory. However, because of the two operations it requires,
    accessing words at odd addresses on a 16-bit processor is slower than accessing
    words at even addresses. By carefully arranging how you use memory, you can improve
    the speed of your programs on these CPUs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，16位的80x86 CPU将这些细节对你隐藏起来。你的程序可以访问*任何*地址的字，CPU会正确地访问并交换（如果需要）内存中的数据。然而，由于需要两次操作，在16位处理器上访问奇数地址的字比访问偶数地址的字要慢。通过精心安排内存使用方式，你可以提高程序在这些CPU上的运行速度。
- en: '***6.2.3 32-Bit Data Buses***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.3 32位数据总线***'
- en: Accessing 32-bit quantities always takes at least two memory operations on the
    16-bit processors. To access a 32-bit quantity at an odd address, a 16-bit processor
    may require three memory operations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在16位处理器上，访问32位数据总是至少需要两次内存操作。要在奇数地址访问32位数据，16位处理器可能需要三次内存操作。
- en: The 80x86 processors with a 32-bit data bus, such as the Pentium and Core processors,
    use four banks of memory connected to the 32-bit data bus (see [Figure 6-8](ch06.xhtml#ch06fig08)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 具有32位数据总线的80x86处理器，如奔腾和Core处理器，使用四个内存银行连接到32位数据总线（见[图6-8](ch06.xhtml#ch06fig08)）。
- en: '![image](../images/06fig08.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig08.jpg)'
- en: '*Figure 6-8: 32-bit processor memory interface*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：32位处理器内存接口*'
- en: With a 32-bit memory interface, the 80x86 CPU can access any single byte with
    one memory operation. With a 16-bit memory interface, the address placed on the
    address bus is always an even number; and with a 32-bit memory interface, it’s
    always some multiple of 4\. Using various byte-enable control lines, the CPU can
    select which of the 4 bytes at that address the software wants to access. As with
    the 16-bit processor, the CPU will automatically rearrange bytes as necessary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位内存接口下，80x86 CPU可以通过一次内存操作访问任意单字节。而在16位内存接口下，放入地址总线的地址总是偶数；而在32位内存接口下，地址总是4的倍数。通过各种字节使能控制线，CPU可以选择该地址上4个字节中的哪个进行访问。与16位处理器一样，CPU会根据需要自动重新排列字节。
- en: A 32-bit CPU can also access a word at most memory addresses using a single
    memory operation, though word accesses at certain addresses will take two memory
    operations (see [Figure 6-9](ch06.xhtml#ch06fig09)). This is the same problem
    we encountered with the 16-bit processor attempting to retrieve a word with an
    odd address, except it occurs half as often—only when the address divided by 4
    leaves a remainder of 3.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 32位CPU也可以通过单次内存操作访问最多一个字的内存地址，尽管在某些地址上的字访问需要进行两次内存操作（见[图6-9](ch06.xhtml#ch06fig09)）。这是我们在16位处理器尝试以奇数地址取字时遇到的相同问题，只是它发生的频率是原来的一半——只有当地址除以4余3时才会出现。
- en: '![image](../images/06fig09.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig09.jpg)'
- en: '*Figure 6-9: Accessing a word on a 32-bit processor at (address mod 4) = 3*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：在32位处理器上访问一个字，地址模4余3*'
- en: A 32-bit CPU can access a double word in a single memory operation *only if*
    the address of that value is evenly divisible by 4\. If not, the CPU may require
    two memory operations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 32位CPU只能在目标值的地址能够被4整除的情况下，单次内存操作访问一个双字。如果不能整除，CPU可能需要两次内存操作。
- en: Once again, the 80x86 CPU handles all this automatically. However, there’s a
    performance benefit to proper data alignment. Generally, the LO byte of word values
    should always be placed at even addresses, and the LO byte of double-word values
    should always be placed at addresses that are evenly divisible by 4.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，80x86 CPU会自动处理这一切。然而，正确的数据对齐仍然能带来性能上的好处。通常，字值的低字节应始终放置在偶数地址，而双字值的低字节应始终放置在能够被4整除的地址上。
- en: '***6.2.4 64-Bit Data Buses***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.4 64位数据总线***'
- en: The Pentium and later processors, like Intel i-Series, provide a 64-bit data
    bus and special cache memory that reduces the impact of nonaligned data access.
    Although there may still be a penalty for accessing data at an inappropriate address,
    modern x86 CPUs suffer from the problem less frequently than the earlier CPUs.
    We’ll look at the details in “Cache Memory” on page [151](#page_151).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 像英特尔i系列这样的奔腾及之后的处理器，提供了64位的数据总线和特殊的缓存内存，这减少了非对齐数据访问的影响。尽管访问不适当地址的数据可能仍会带来一定的性能损失，但现代x86
    CPU在此问题上的表现要优于早期的CPU。我们将在“缓存内存”一节中进一步讨论，详见第[151](#page_151)页。
- en: '***6.2.5 Small Accesses on Non-80x86 Processors***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.5 非80x86处理器上的小数据访问***'
- en: Although the 80x86 processor is not the only processor that will let you access
    a byte, word, or double-word object at an arbitrary byte address, most processors
    created in the past 30 years do *not* allow it. For example, the 68000 processor
    found in the original Apple Macintosh system would allow you to access a byte
    at any address, but raised an exception if you attempted to access a word at an
    odd address.^([2](footnotes.xhtml#fn6_2a)) Many processors require that you access
    an object at an address that is a multiple of the object’s size, or they’ll raise
    an exception.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管80x86处理器并不是唯一允许你在任意字节地址访问字节、字或双字对象的处理器，但过去30年中大多数处理器都*不*允许这样做。例如，最初的Apple
    Macintosh系统中使用的68000处理器允许你在任何地址访问字节，但如果你尝试在奇数地址访问字，则会引发异常。^([2](footnotes.xhtml#fn6_2a))
    许多处理器要求你在对象大小的倍数地址上访问该对象，否则会抛出异常。
- en: Most RISC processors, including those found in modern smartphones and tablets
    (typically ARM processors), do not allow you to access byte and word objects at
    all. Most RISC CPUs require that all data accesses be the same size as the data
    bus (or general-purpose integer register size, whichever is smaller). This is
    generally a double-word (32-bit) or quad-word (64-bit) access. If you want to
    access bytes or words on such a machine, you have to treat them as packed fields
    and use the shift and mask techniques to extract or insert byte and word data
    in a double word. Although it’s nearly impossible to avoid byte accesses in software
    that does any character and string processing, if you expect your software to
    run efficiently on various modern RISC CPUs, you should avoid word data types
    (and the performance penalty for accessing them) in favor of double words.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数RISC处理器，包括现代智能手机和平板电脑中使用的ARM处理器，并不允许你访问字节或字对象。大多数RISC CPU要求所有的数据访问大小与数据总线（或通用整数寄存器大小，以较小者为准）相同。通常情况下，这是双字（32位）或四字（64位）的访问。如果你想在这样的机器上访问字节或字，你必须将其视为打包字段，并使用移位和掩码技术在双字中提取或插入字节和字数据。虽然在进行字符和字符串处理的软件中几乎无法避免字节访问，但如果你期望软件能够在各种现代RISC
    CPU上高效运行，应该避免使用字数据类型（及其访问带来的性能损失），而倾向于使用双字。
- en: '**6.3 Big-Endian vs. Little-Endian Organization**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.3 大端与小端存储方式**'
- en: Earlier, you read that the 80x86 CPU family stores the LO byte of a word or
    double-word value at a particular address in memory and the successive HO bytes
    at successively higher addresses. Now we’ll look in more depth at how different
    processors store multibyte objects in byte-addressable memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你读到过80x86 CPU系列将一个字或双字值的低字节存储在内存中的某个特定地址，而后续的高字节则存储在更高的地址。现在我们将更深入地探讨不同处理器如何在字节可寻址的内存中存储多字节对象。
- en: Almost every CPU whose “bit size” is some power of 2 (8, 16, 32, 64, and so
    on) numbers the bits and nibbles as shown in the previous chapters. There are
    some exceptions, but they are rare, and most of the time they represent a notational
    change, not a functional change (meaning you can safely ignore the difference).
    Once you start dealing with objects larger than 8 bits, however, things become
    more complicated. Different CPUs organize the bytes in a multibyte object differently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个“位大小”是 2 的幂（8、16、32、64 等）的 CPU 都按前几章所示的方式对位和半字节进行编号。虽然有一些例外，但它们很少见，而且大多数情况下它们代表的是符号的变化，而不是功能上的变化（这意味着你可以安全地忽略差异）。然而，一旦开始处理大于
    8 位的对象，事情变得更加复杂。不同的 CPU 对多字节对象中的字节进行不同的组织。
- en: Consider the layout of the bytes in a double word on an 80x86 CPU (see [Figure
    6-10](ch06.xhtml#ch06fig10) ). The LO byte, which contributes the smallest component
    of a binary number, sits in bit positions 0 through 7 and appears at the lowest
    address in memory. It seems reasonable that the bits that contribute the least
    would be located at the lowest address in memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 80x86 CPU 上双字节的字节布局（见 [图 6-10](ch06.xhtml#ch06fig10)）。LO 字节，作为二进制数中最小的组成部分，位于第
    0 到第 7 位，并出现在内存中最低的地址位置。似乎最少贡献的位应当位于内存中的最低地址。
- en: '![image](../images/06fig10.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig10.jpg)'
- en: '*Figure 6-10: Byte layout in a double word on the 80x86 processor*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10：80x86 处理器中的双字节布局*'
- en: This is not the only possible organization, however. Some CPUs reverse the memory
    addresses of all the bytes in a double word, using the organization shown in [Figure
    6-11](ch06.xhtml#ch06fig11).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是唯一的组织方式。某些 CPU 会反转双字节中所有字节的内存地址，使用 [图 6-11](ch06.xhtml#ch06fig11) 所示的组织方式。
- en: '![image](../images/06fig11.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig11.jpg)'
- en: '*Figure 6-11: Alternate byte layout in a double word*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：双字的替代字节布局*'
- en: The original Apple Macintosh (68000 and PowerPC) and most non-80x86 Unix boxes
    use the data organization shown in [Figure 6-11](ch06.xhtml#ch06fig11). Even on
    80x86 systems, certain protocols (such as network transmissions) specify this
    data organization. Therefore, this isn’t some rare and esoteric convention; it’s
    quite common, and not something you can ignore if you work on PCs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的苹果 Macintosh（68000 和 PowerPC）以及大多数非 80x86 Unix 机器使用 [图 6-11](ch06.xhtml#ch06fig11)
    所示的数据组织方式。即便是在 80x86 系统上，某些协议（如网络传输）也规定了这种数据组织方式。因此，这并不是某种罕见的、深奥的约定；它相当常见，如果你在
    PC 上工作，是不容忽视的。
- en: The byte organization that Intel uses is whimsically known as the *[little-endian
    byte organization](gloss01.xhtml#gloss01_137)*. The alternate form is known as
    *[big-endian byte organization](gloss01.xhtml#gloss01_27)*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔使用的字节组织方式被戏谑地称为 *[小端字节组织方式](gloss01.xhtml#gloss01_137)*。另一种形式则称为 *[大端字节组织方式](gloss01.xhtml#gloss01_27)*。
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*These terms come from Jonathan Swift’s* Gulliver’s Travels; *the Lilliputians
    were arguing over whether one should open an egg by cracking it on the little
    end or the big end—a parody of the arguments the Catholics and Protestants were
    having over their respective doctrines when Swift was writing.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些术语来自 Jonathan Swift 的* 《格列佛游记》；*小人国的人们争论是否应该从小端还是大端打开鸡蛋——这是对当时天主教徒和新教徒在
    Swift 写作时对各自教义争论的讽刺。*'
- en: The time for arguing over which format is superior was back before there were
    several different CPUs created using different *[endianness](gloss01.xhtml#gloss01_88)*.
    Today, that argument is irrelevant. Regardless of which format is better or worse,
    we have to deal with the fact that different CPUs sport different endianness,
    and we have to take care when writing software if we want our programs to run
    on both types of processors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪种格式更优的争论，早在多种使用不同 *[字节序](gloss01.xhtml#gloss01_88)* 的 CPU 被创造出来之前就已经过时了。今天，这种争论已经没有意义。无论哪种格式更好或更差，我们都必须面对不同
    CPU 存在不同字节序的事实，并且在编写软件时要小心，以确保我们的程序能够在这两种类型的处理器上运行。
- en: 'We encounter the big-endian versus little-endian problem when we try to pass
    binary data between two computers. For example, the double-word binary representation
    of 256 on a little-endian machine has the following byte values:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在两台计算机之间传递二进制数据时，就会遇到大端与小端的问题。例如，在小端机上，256 的双字二进制表示具有以下字节值：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you assemble these 4 bytes on a little-endian machine, their layout takes
    this form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在小端机器上组装这 4 个字节，它们的布局将呈现以下形式：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On a big-endian machine, however, the layout takes the following form:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大端机上，布局呈现以下形式：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that if you take a 32-bit value from one of these machines and attempt
    to use it on the other machine (with a different endianness), you won’t get correct
    results. For example, if you take a big-endian version of the value 256 and interpret
    it as little-endian, you’ll discover that it has a `1` in bit position 16, and
    a little-endian machine will think that the value is actually 65,536 (that is,
    `%1_0000_0000_0000_0000`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你从一台机器获取一个32位值并试图在另一台具有不同字节序的机器上使用它，你将无法得到正确的结果。例如，如果你将一个大端版本的256值作为小端格式来解释，你会发现它在第16位上有一个`1`，而小端机器会认为该值实际上是65,536（即`%1_0000_0000_0000_0000`）。
- en: When you’re exchanging data between two different machines, the best solution
    is to convert your values to some canonical form and then convert the canonical
    form back to the local format if the local and canonical formats are not the same.
    Exactly what constitutes a “canonical” format depends, usually, on the transmission
    medium. For example, when you are transmitting data across networks, the canonical
    form is usually big-endian because TCP/IP and some other network protocols use
    the big-endian format. When you’re transmitting data across the Universal Serial
    Bus (USB), the canonical format is little-endian. Of course, if you control the
    software on both ends, the choice of canonical form is arbitrary; still, you should
    attempt to use the appropriate form for the transmission medium to avoid confusion
    down the road.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在两台不同的机器之间交换数据时，最佳的解决方案是将数据转换为某种规范形式（canonical form），然后在本地格式和规范格式不一致的情况下，将规范格式转换回本地格式。什么构成“规范”格式通常取决于传输介质。例如，当你通过网络传输数据时，规范格式通常是大端字节序（big-endian），因为TCP/IP和其他一些网络协议使用大端格式。当你通过通用串行总线（USB）传输数据时，规范格式是小端字节序（little-endian）。当然，如果你能控制两端的软件，选择规范格式是可以任意的；不过，为了避免今后出现混淆，仍然应该尝试使用适合传输介质的格式。
- en: 'To convert between the endian forms, you must do a *mirror-image swap* of the
    bytes in the object: first swap the bytes at opposite ends of the binary number,
    and then work your way toward the middle of the object, swapping pairs of bytes
    as you go along. For example, to convert between the big-endian and little-endian
    format within a double word, you’d first swap bytes 0 and 3, then you’d swap bytes
    1 and 2 (see [Figure 6-12](ch06.xhtml#ch06fig12)).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字节序之间转换，你必须进行*镜像交换*，即交换对象中二进制数字两端的字节，然后逐步向对象的中间移动，交换字节对。例如，要在双字之间转换大端和小端格式，你首先交换字节0和字节3，然后交换字节1和字节2（参见[图
    6-12](ch06.xhtml#ch06fig12)）。
- en: '![image](../images/06fig12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig12.jpg)'
- en: '*Figure 6-12: Endian conversion in a double word*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：双字的字节序转换*'
- en: For word values, all you need to do is swap the HO and LO bytes to change the
    endianness. For quad-word values, you need to swap bytes 0 and 7, 1 and 6, 2 and
    5, and 3 and 4\. Because very little software deals with 128-bit integers, you
    probably won’t need to worry about long-word endianness conversion, but the concept
    is the same if you do.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字（word）值，你只需要交换高位字节（HO）和低位字节（LO）来改变字节序。对于四字（quad-word）值，你需要交换字节0和字节7、字节1和字节6、字节2和字节5、字节3和字节4。因为很少有软件处理128位整数，你可能不需要担心长字（long-word）字节序转换，但如果需要，概念是相同的。
- en: Note that the endianness conversion process is *reflexive*; that is, the same
    algorithm that converts big-endian to little-endian also converts little-endian
    to big-endian. If you run the algorithm twice, you wind up with the data in the
    original format.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字节序转换过程是*自反的*；也就是说，将大端字节序转换为小端字节序的相同算法，也可以将小端字节序转换为大端字节序。如果你运行该算法两次，数据将恢复为原始格式。
- en: Even if you’re not writing software that exchanges data between two computers,
    the issue of endianness may arise. Some programs assemble larger objects from
    discrete bytes by assigning those bytes to specific positions within the larger
    value. If the software puts the LO byte into bit positions 0 through 7 (little-endian
    format) on a big-endian machine, the program will not produce correct results.
    Therefore, if the software needs to run on different CPUs that have different
    byte organizations, it will have to determine the endianness of the machine it’s
    running on and adjust how it assembles larger objects from bytes accordingly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有编写用于在两台计算机之间交换数据的软件，字节序的问题仍然可能出现。有些程序通过将离散的字节分配到较大值的特定位置来组装较大的对象。如果软件在大端机器上将低位字节放置在第0到7位（小端格式），程序将无法产生正确的结果。因此，如果软件需要在具有不同字节组织方式的不同CPU上运行，它必须确定运行的机器的字节序，并相应地调整如何从字节中组装较大的对象。
- en: To illustrate how to build larger objects from discrete bytes, we’ll start with
    a short example that demonstrates how you could assemble a 32-bit object from
    4 individual bytes. The most common way to do this is to create a *[discriminant
    union](gloss01.xhtml#gloss01_76)* structure that contains a 32-bit object and
    a 4-byte array.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何从离散字节构建较大的对象，我们将通过一个简单示例开始，展示如何从4个独立字节组装一个32位对象。最常见的方法是创建一个*[判别联合体](gloss01.xhtml#gloss01_76)*结构，它包含一个32位对象和一个4字节数组。
- en: '**NOTE**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many languages, but not all, support the discriminant union data type. For
    example, in Pascal, you would instead use a case variant record. See your language
    reference manual for details.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多语言（但并非全部）支持判别联合数据类型。例如，在Pascal中，你会使用一种称为“case variant”的记录。详情请参阅你的语言参考手册。*'
- en: 'Unions are similar to records or structures except the compiler allocates the
    storage for each field of the union at the same address in memory. Consider the
    following two declarations from the C programming language:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体类似于记录或结构，唯一的不同是编译器在内存中的同一地址为联合体的每个字段分配存储空间。考虑以下来自C语言的两个声明：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As [Figure 6-13](ch06.xhtml#ch06fig13) shows, the `RECORDvar` object consumes
    8 bytes in memory, and the fields do not share their memory with any other fields
    (that is, each field starts at a different offset from the base address of the
    record). The `UNIONvar` object, on the other hand, overlays all the fields in
    the union in the same memory locations. Therefore, writing a value to the `i`
    field of the union also overwrites the value of the `u` field as well as 2 bytes
    of the `r` field (whether they are the LO or HO bytes depends entirely on the
    endianness of the CPU).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图6-13](ch06.xhtml#ch06fig13)所示，`RECORDvar`对象在内存中占用8个字节，且各字段的内存不与其他字段共享（也就是说，每个字段从记录的基地址开始有不同的偏移量）。另一方面，`UNIONvar`对象将联合体中的所有字段叠加在相同的内存位置。因此，向联合体中的`i`字段写入一个值，也会覆盖`u`字段的值以及`r`字段的2个字节（无论是低字节还是高字节，完全取决于CPU的字节序）。
- en: '![image](../images/06fig13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig13.jpg)'
- en: '*Figure 6-13: Layout of a union versus a record (struct) in memory*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：联合体与记录（结构）在内存中的布局*'
- en: 'In the C programming language, you can use this behavior to access the individual
    bytes of a 32-bit object. Consider the following union declaration in C:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在C编程语言中，你可以利用这种行为来访问32位对象的单个字节。考虑以下C语言中的联合体声明：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates the data type shown in [Figure 6-14](ch06.xhtml#ch06fig14) on a
    little-endian machine, and the structure shown in [Figure 6-15](ch06.xhtml#ch06fig15)
    on a big-endian machine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在小端机器上创建[图6-14](ch06.xhtml#ch06fig14)所示的数据类型，而在大端机器上则创建[图6-15](ch06.xhtml#ch06fig15)所示的结构。
- en: '![image](../images/06fig14.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig14.jpg)'
- en: '*Figure 6-14: A C union on a little-endian machine*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：在小端机器上的C联合体*'
- en: '![image](../images/06fig15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig15.jpg)'
- en: '*Figure 6-15: A C union on a big-endian machine*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：在大端机器上的C联合体*'
- en: 'To assemble a 32-bit object from 4 discrete bytes on a little-endian machine,
    you’d use code like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在小端机器上，从4个离散字节组装一个32位对象，你可以使用如下代码：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code functions properly because C allocates the first byte of an array
    at the lowest address in memory (corresponding to bits 0..7 in the `theValue.bits32`
    object on a little-endian machine); the second byte of the array follows (bits
    8..15), then the third (bits 16..23), and finally the HO byte (occupying the highest
    address in memory, corresponding to bits 24..31).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能够正常工作，因为C语言将数组的第一个字节分配到内存中最低的地址（对应小端机器上`theValue.bits32`对象的第0到7位）；数组的第二个字节紧随其后（第8到15位），然后是第三个字节（第16到23位），最后是最高字节（占用内存中的最高地址，对应第24到31位）。
- en: 'However, on a big-endian machine, this code won’t work properly because `theValue.bytes[0]`
    corresponds to bits 24 through 31 of the 32-bit value rather than bits 0 through
    7\. To assemble this 32-bit value properly on a big-endian system, you’d need
    to use code like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大端机器上，这段代码无法正常工作，因为`theValue.bytes[0]`对应的是32位值的第24到31位，而不是第0到7位。要在大端系统上正确组装这个32位值，您需要使用如下代码：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But how do you determine if your code is running on a little-endian or big-endian
    machine? This is actually a simple task. Consider the following C code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如何判断你的代码是在小端还是大端机器上运行呢？这其实是一个简单的任务。考虑以下C代码：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On a big-endian machine, this code sequence will store the value `1` into bit
    16, producing a 32-bit value that is definitely not equal to 256, whereas on a
    little-endian machine this code will store the value `1` into bit 8, producing
    a 32-bit value equal to 256\. Therefore, you can test the `isLittleEndian` variable
    to determine whether the current machine is little-endian (`true`) or big-endian
    (`false`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在大端机器上，这段代码将把值`1`存储到第16位，产生一个32位值，该值肯定不等于256；而在小端机器上，这段代码将把值`1`存储到第8位，产生一个等于256的32位值。因此，您可以测试`isLittleEndian`变量，以确定当前机器是小端（`true`）还是大端（`false`）。
- en: '**6.4 The System Clock**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.4 系统时钟**'
- en: 'Although modern computers are quite fast and getting faster all the time, they
    still require time to accomplish even the smallest tasks. On von Neumann machines,
    most operations are *serialized*, which means that the computer executes commands
    in a prescribed order.^([3](footnotes.xhtml#fn6_3a)) It wouldn’t do, in the following
    code sequence, to execute the Pascal statement `I := I * 5 + 2;` before the statement
    `I := J;` finishes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现代计算机速度非常快，并且一直在不断加快，但它们仍然需要时间来完成即使是最小的任务。在冯·诺依曼结构的机器中，大多数操作都是*串行化*的，这意味着计算机按规定的顺序执行命令。（见注释^[3](footnotes.xhtml#fn6_3a)）在以下代码序列中，如果在`I
    := J;`语句完成之前执行`I := I * 5 + 2;`，那是行不通的：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These operations do not occur instantaneously. Moving a copy of `J` into `I`
    takes a certain amount of time. Likewise, multiplying `I` by 5 and then adding
    2 and storing the result back into `I` takes time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作并不是瞬间完成的。将`J`的副本移动到`I`中需要一定的时间。同样，乘以5后再加2并将结果存回`I`也需要时间。
- en: To execute statements in the proper order, the processor relies on the *system
    clock*, which serves as the timing standard within the system. To understand why
    certain operations take longer than others, you must first understand how the
    system clock functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按正确的顺序执行语句，处理器依赖于*系统时钟*，该时钟作为系统内部的时序标准。要理解为什么某些操作需要比其他操作更长的时间，您首先必须理解系统时钟是如何工作的。
- en: The system clock is an electrical signal on the control bus that alternates
    between 0 and 1 periodically (see [Figure 6-16](ch06.xhtml#ch06fig16)). All activity
    within the CPU is synchronized with the edges (rising or falling) of this clock
    signal.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 系统时钟是控制总线上的电信号，它周期性地在0和1之间切换（见[图6-16](ch06.xhtml#ch06fig16)）。CPU内的所有活动都与该时钟信号的边缘（上升沿或下降沿）同步。
- en: '![image](../images/06fig16.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig16.jpg)'
- en: '*Figure 6-16: The system clock*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-16：系统时钟*'
- en: The rate at which the system clock alternates between 0 and 1 is the *system
    clock frequency*, and the time it takes for the system clock to switch from 0
    to 1 and back to 0 is the *clock period* or *clock cycle*. On most modern systems,
    the system clock frequency exceeds several billion cycles per second. A typical
    Pentium IV chip, circa 2004, runs at speeds of three billion cycles per second
    or faster. *Hertz (Hz)* is the unit corresponding to one cycle per second, so
    the aforementioned Pentium chip runs at between 3,000 and 4,000 million hertz,
    or 3,000 to 4,000 megahertz (MHz), or 3 to 4 gigahertz (GHz, or one billion cycles
    per second). Typical frequencies for 80x86 parts range from 5 MHz up to several
    gigahertz and beyond.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 系统时钟在0和1之间切换的速率被称为*系统时钟频率*，而系统时钟从0切换到1再回到0所需的时间称为*时钟周期*或*时钟周期*。在大多数现代系统中，系统时钟频率超过数十亿个周期每秒。典型的Pentium
    IV处理器，大约在2004年左右，运行速度为每秒三十亿个周期或更快。*赫兹（Hz）*是每秒一个周期对应的单位，因此前述的Pentium芯片运行在3000到4000百万赫兹之间，或3000到4000兆赫（MHz），或3到4吉赫（GHz，或每秒十亿个周期）。80x86系列的典型频率范围从5
    MHz到数吉赫赫兹及以上。
- en: The clock period is the reciprocal of the clock frequency. For example, a 1
    MHz (MHz or one million cycles per second) clock would have a clock period of
    1 microsecond (one millionth of a second, µs^([4](footnotes.xhtml#fn6_4a))). A
    CPU running at 1 GHz would have a clock period of one nanosecond (ns), or one
    billionth of a second. Clock periods are usually expressed in microseconds or
    nanoseconds.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟周期是时钟频率的倒数。例如，1 MHz（兆赫，或每秒一百万个周期）的时钟，其时钟周期为1微秒（百万分之一秒，µs^([4](footnotes.xhtml#fn6_4a)))。一颗运行在1
    GHz的CPU，其时钟周期为1纳秒（ns），即十亿分之一秒。时钟周期通常以微秒或纳秒为单位表示。
- en: To ensure synchronization, most CPUs start an operation on either the *[falling
    edge](gloss01.xhtml#gloss01_93)* (when the clock goes from 1 to 0) or the *[rising
    edge](gloss01.xhtml#gloss01_217)* (when the clock goes from 0 to 1). The system
    clock spends most of its time at either 0 or 1 and very little time switching
    between the two. Therefore, a clock edge is the perfect synchronization point.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保同步，大多数CPU在时钟的*[下降沿](gloss01.xhtml#gloss01_93)*（时钟从1变为0时）或*[上升沿](gloss01.xhtml#gloss01_217)*（时钟从0变为1时）启动一个操作。系统时钟大部分时间处于0或1状态，而在两者之间切换的时间非常短暂。因此，时钟沿是一个完美的同步点。
- en: Because all CPU operations are synchronized with the clock, the CPU cannot perform
    tasks any faster than the clock runs. However, just because a CPU is running at
    some clock frequency doesn’t mean that it executes that many operations each second.
    Many operations take multiple clock cycles to complete, so the CPU often performs
    operations at a significantly slower rate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有CPU操作都与时钟同步，因此CPU的任务执行速度不能超过时钟的运行速度。然而，仅仅因为CPU运行在某个时钟频率上，并不意味着它每秒执行那么多操作。许多操作需要多个时钟周期才能完成，因此CPU的操作速度往往比时钟速度慢得多。
- en: '***6.4.1 Memory Access and the System Clock***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.4.1 内存访问和系统时钟***'
- en: Memory access is an operation that is synchronized with the system clock; that
    is, memory access occurs no more than once every clock cycle. On some older processors,
    it takes several clock cycles to access a memory location. The *[memory access
    time](gloss01.xhtml#gloss01_149)* is the number of clock cycles between a memory
    request (read or write) and when the memory operation completes. This is an important
    value, because longer memory access times result in lower performance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内存访问是一个与系统时钟同步的操作；也就是说，内存访问每个时钟周期最多只发生一次。在一些旧的处理器中，访问一个内存位置需要多个时钟周期。*[内存访问时间](gloss01.xhtml#gloss01_149)*是从内存请求（读取或写入）到内存操作完成之间的时钟周期数。这是一个重要的值，因为更长的内存访问时间会导致较低的性能。
- en: Modern CPUs are much faster than memory devices, so systems built around these
    CPUs often use a second clock, the *bus clock*, which is some fraction of the
    CPU speed. For example, typical processors in the 100 MHz to 4 GHz range can use
    1600 MHz, 800 MHz, 500 MHz, 400 MHz, 133 MHz, 100 MHz, or 66 MHz bus clocks (a
    given CPU generally supports several different bus speeds, and the exact range
    it supports depends upon that CPU).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU的速度远快于内存设备，因此以这些CPU为基础的系统通常使用第二个时钟，即*总线时钟*，其频率是CPU速度的一部分。例如，典型的100 MHz到4
    GHz范围的处理器可以使用1600 MHz、800 MHz、500 MHz、400 MHz、133 MHz、100 MHz或66 MHz的总线时钟（某个特定的CPU通常支持多种不同的总线速度，具体支持的范围取决于该CPU）。
- en: When reading from memory, the memory access time is the time between when the
    CPU places an address on the address bus and the time when the CPU takes the data
    off the data bus. On typical 80x86 CPUs with a one-cycle memory access time, the
    timing of a read operation looks something like [Figure 6-17](ch06.xhtml#ch06fig17).
    The timing of writing data to memory is similar (see [Figure 6-18](ch06.xhtml#ch06fig18)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取内存时，内存访问时间是CPU将地址放到地址总线上的时间与CPU从数据总线上取数据的时间之间的间隔。在典型的80x86 CPU中，内存访问时间为一个周期，读取操作的时序大致如下[图6-17](ch06.xhtml#ch06fig17)。将数据写入内存的时序类似（见[图6-18](ch06.xhtml#ch06fig18)）。
- en: '![image](../images/06fig17.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig17.jpg)'
- en: '*Figure 6-17: A typical memory read cycle*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-17：典型的内存读取周期*'
- en: '![image](../images/06fig18.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig18.jpg)'
- en: '*Figure 6-18: A typical memory write cycle*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：典型的内存写入周期*'
- en: The CPU doesn’t wait for memory. The access time is specified by the bus clock
    frequency. If the memory subsystem doesn’t work fast enough to keep up with the
    CPU’s expected access time, the CPU will read garbage data on a memory read operation
    and will not properly store the data on a memory write. This will surely cause
    the system to fail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: CPU不会等待内存。访问时间由总线时钟频率指定。如果内存子系统的工作速度不足以跟上CPU预期的访问时间，CPU在内存读取操作时将读取到垃圾数据，在内存写入时也无法正确存储数据。这肯定会导致系统失败。
- en: Memory devices have various ratings, but the two major ones are capacity and
    speed. Typical dynamic RAM (random access memory) devices have capacities of 16GB
    (or more) and speeds of 0.1 to 100 ns. A typical 4 GHz Intel system uses 1600
    MHz (1.6 GHz, or 0.625 ns) memory devices.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 内存设备有各种不同的评级，但主要有两个参数：容量和速度。典型的动态RAM（随机存取内存）设备的容量为16GB（或更大），速度为0.1到100纳秒。一个典型的4
    GHz英特尔系统使用1600 MHz（1.6 GHz，或0.625纳秒）内存设备。
- en: Now, I just said that the memory speed must match the bus speed or the system
    will fail. At 4 GHz the clock period is roughly 0.25 ns. So how can a system designer
    get away with using 0.625 ns memory? The answer is *[wait states](gloss01.xhtml#gloss01_261)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我刚才提到内存速度必须与总线速度匹配，否则系统将会失败。在4 GHz下，时钟周期大约为0.25纳秒。那么，系统设计师如何使用0.625纳秒的内存呢？答案是*
    [等待状态](gloss01.xhtml#gloss01_261)*。
- en: '***6.4.2 Wait States***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.4.2 等待状态***'
- en: A wait state is an extra clock cycle that gives a device additional time to
    respond to the CPU. For example, a 100 MHz Pentium system has a 10 ns clock period,
    implying that you need 10 ns memory. In fact, you need even faster memory devices
    because in many computer systems there’s additional decoding and buffering logic
    between the CPU and memory, and this circuitry introduces its own delays. In [Figure
    6-19](ch06.xhtml#ch06fig19), you can see that buffering and decoding costs the
    system an additional 10 ns. If the CPU needs the data back in 10 ns, the memory
    must respond in 0 ns (which is impossible).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 等待状态是一个额外的时钟周期，给设备额外的时间来响应CPU。例如，一个100 MHz的Pentium系统有10纳秒的时钟周期，这意味着你需要10纳秒的内存。实际上，你需要更快的内存设备，因为在许多计算机系统中，CPU和内存之间有额外的解码和缓冲逻辑，这些电路会引入自己的延迟。在[图6-19](ch06.xhtml#ch06fig19)中，你可以看到缓冲和解码使系统多出了10纳秒的延迟。如果CPU需要在10纳秒内获得数据，内存必须在0纳秒内响应（这显然是不可能的）。
- en: '![image](../images/06fig19.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig19.jpg)'
- en: '*Figure 6-19: Decoding and buffer delays*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-19：解码和缓冲延迟*'
- en: If cost-effective memory won’t work with a fast processor, how do companies
    manage to sell fast PCs? One part of the answer is the wait state. For example,
    if you have a 100 MHz processor with a memory cycle time of 10 ns and you lose
    2 ns to buffering and decoding, you’ll need 8 ns memory. What if your system can
    only support 20 ns memory, though? By adding wait states to extend the memory
    cycle to 20 ns, you can solve this problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果具有成本效益的内存无法与快速处理器配合使用，那么公司如何销售快速PC呢？其中一个答案就是等待状态。例如，如果你有一个100 MHz的处理器，内存周期时间为10纳秒，而你因为缓冲和解码损失了2纳秒，你将需要8纳秒的内存。然而，如果你的系统只能支持20纳秒的内存怎么办？通过添加等待状态来延长内存周期到20纳秒，你就能解决这个问题。
- en: Almost every general-purpose CPU in existence provides a pin (whose signal appears
    on the control bus) that allows you to insert wait states. If necessary, the memory
    address decoding circuitry asserts this signal to give the memory sufficient access
    time (see [Figure 6-20](ch06.xhtml#ch06fig20)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有通用CPU都提供一个引脚（其信号出现在控制总线上），允许你插入等待状态。如果需要，内存地址解码电路会触发该信号，以便为内存提供足够的访问时间（见[图6-20](ch06.xhtml#ch06fig20)）。
- en: '![image](../images/06fig20.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig20.jpg)'
- en: '*Figure 6-20: Inserting a wait state into a memory read operation*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-20：在内存读取操作中插入等待状态*'
- en: From the system performance point of view, wait states are *not* a good thing.
    As long as the CPU is waiting for data from memory, it can’t operate on that data.
    Adding a wait state typically *doubles* (or worse, on some systems) the amount
    of time required to access memory. Running with a wait state on every memory access
    is almost like cutting the processor clock frequency in half. You’ll get less
    work done in the same amount of time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统性能的角度来看，等待状态*并不是*好事。只要CPU在等待来自内存的数据，它就无法对数据进行操作。添加一个等待状态通常会*加倍*（或者在某些系统上更糟糕）访问内存所需的时间。在每次内存访问时都加上一个等待状态几乎就像是将处理器的时钟频率减半。在相同的时间内，你完成的工作会更少。
- en: However, we’re not doomed to slow execution because of added wait states. There
    are several tricks hardware designers can employ to achieve zero wait states *most*
    of the time. The most common is the use of *cache* (pronounced “cash”) memory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于增加了等待状态，我们并不注定会遭遇慢速执行。硬件设计师可以采取几种技巧，在*大多数*时间里实现零等待状态。最常见的做法是使用*缓存*（发音为“cash”）内存。
- en: '***6.4.3 Cache Memory***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.4.3 缓存内存***'
- en: 'A typical program tends to access the same memory locations repeatedly (known
    as *[temporal locality of reference](gloss01.xhtml#gloss01_245)*), and to access
    adjacent memory locations (*spatial locality of reference*). Both forms of locality
    occur in the following Pascal code segment:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的程序倾向于反复访问相同的内存位置（称为*[时间局部性](gloss01.xhtml#gloss01_245)*），并访问相邻的内存位置（*空间局部性*）。这两种局部性在以下Pascal代码段中都出现了。
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are two occurrences each of spatial and temporal locality of reference
    within this loop. Let’s consider the obvious ones first.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，有两个空间局部性和时间局部性的出现。我们先来看一下显而易见的情况。
- en: In this Pascal code, the program references the variable `i` several times.
    The `for` loop compares `i` against `10` to see if the loop is complete. It also
    increments `i` by 1 at the bottom of the loop. The assignment statement also uses
    `i` as an array index. This shows temporal locality of reference in action.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段Pascal代码中，程序多次引用变量`i`。`for`循环将`i`与`10`进行比较，以检查循环是否完成。它还会在循环的底部将`i`加1。赋值语句也使用`i`作为数组索引。这显示了时间局部性的实际应用。
- en: The loop itself zeros out the elements of array `A` by writing a `0` to the
    first location in `A`, then to the second location in `A`, and so on. Because
    Pascal stores the elements of `A` in consecutive memory locations, each loop iteration
    accesses adjacent memory locations. This shows spatial locality of reference.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 循环本身通过将`0`写入`A`的第一个位置，再写入`A`的第二个位置，以此类推，从而将数组`A`的元素清零。由于Pascal将数组`A`的元素存储在连续的内存位置中，每次循环迭代都访问相邻的内存位置。这显示了空间局部性。
- en: What about the second occurrences of temporal and spatial locality? Machine
    instructions also reside in memory, and the CPU fetches these instructions sequentially
    from memory and executes them repeatedly, once for each loop iteration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，时间和空间局部性的第二次出现呢？机器指令也存储在内存中，CPU从内存中顺序获取这些指令，并在每次循环迭代时重复执行它们。
- en: If you look at the execution profile of a typical program, you’ll probably discover
    that the program executes less than half the statements. Generally, a program
    might use only 10 to 20 percent of the memory allotted to it. At any given time,
    a 1MB program might access only 4KB to 8KB of data and code. So, if you paid an
    outrageous sum of money for expensive zero-wait-state RAM, you’d be using only
    a tiny fraction of it at any given time. Wouldn’t it be nice if you could buy
    a small amount of fast RAM and dynamically reassign its addresses as the program
    executes? This is exactly what cache memory does for you.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一个典型程序的执行概况，你可能会发现程序执行的语句不到一半。通常，程序可能只使用分配给它的内存的10%到20%。在任何给定时刻，一个1MB的程序可能只访问4KB到8KB的数据和代码。因此，如果你花费一笔天价买了昂贵的零等待状态RAM，在任何时刻你只会使用其中的极小一部分。如果你能购买少量快速RAM，并在程序执行时动态重新分配其地址，岂不是很好？这正是缓存内存为你做的事情。
- en: Cache memory is a small amount of very fast memory that sits between the CPU
    and main memory. Unlike in normal memory, the bytes within a cache do not have
    fixed addresses. Cache memory can dynamically reassign addresses, which allows
    the system to keep recently accessed values in the cache. Addresses that the CPU
    has never accessed, or hasn’t accessed in some time, remain in main (slow) memory.
    Because most memory accesses are to recently accessed variables (or to locations
    near a recently accessed location), the data generally appears in cache memory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存内存是一种位于CPU和主内存之间的少量非常快速的内存。与普通内存不同，缓存中的字节没有固定的地址。缓存内存可以动态地重新分配地址，这使得系统能够将最近访问过的值保留在缓存中。CPU从未访问过的地址，或长时间未访问的地址，仍然保留在主（慢）内存中。由于大多数内存访问是访问最近使用的变量（或接近最近访问位置的地址），因此数据通常出现在缓存内存中。
- en: A *[cache hit](gloss01.xhtml#gloss01_41)* occurs whenever the CPU accesses memory
    and finds the data in the cache. In such a case, the CPU can usually access data
    with zero wait states. A *[cache miss](gloss01.xhtml#gloss01_43)* occurs if the
    data cannot be found in the cache. In that case, the CPU has to read the data
    from main memory, incurring a performance loss. To take advantage of temporal
    locality of reference, the CPU copies data into the cache whenever it accesses
    an address that’s not present in the cache. Because the system will likely access
    that address shortly, it can save wait states on future accesses by having that
    data in the cache.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU访问内存并在缓存中找到数据时，就会发生*[缓存命中](gloss01.xhtml#gloss01_41)*。在这种情况下，CPU通常可以零等待状态地访问数据。如果数据无法在缓存中找到，则会发生*[缓存未命中](gloss01.xhtml#gloss01_43)*。在这种情况下，CPU必须从主内存中读取数据，从而带来性能损失。为了利用时间局部性，CPU每次访问缓存中没有的地址时，会将数据复制到缓存中。因为系统可能会很快访问该地址，所以通过将数据存储在缓存中，它可以在未来的访问中节省等待状态。
- en: Cache memory does not eliminate the need for wait states. Although a program
    may spend considerable time executing code in one area of memory, eventually it
    will call a procedure or wander off to some section of code outside cache memory.
    When that happens, the CPU has to go to main memory to fetch the data. Because
    main memory is slow, this will require the insertion of wait states. However,
    once the CPU accesses the data, it will be available in the cache for future use.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存内存并不能消除等待状态的需要。尽管程序可能会在内存的某个区域花费大量时间执行代码，但最终它会调用一个过程或跳转到缓存内存以外的某个代码段。当这种情况发生时，CPU必须去主内存获取数据。由于主内存较慢，这将需要插入等待状态。然而，一旦CPU访问了数据，它将会被存储在缓存中，以便将来使用。
- en: We’ve discussed how cache memory handles the temporal aspects of memory access,
    but not the spatial aspects. Caching memory locations *when you access them* won’t
    speed up the program if you constantly access consecutive locations that you’ve
    never accessed before. To solve this problem, when a cache miss occurs, most caching
    systems will read several consecutive bytes of main memory (which engineers call
    a *cache line*). For example, 80x86 CPUs read between 16 and 64 bytes upon a cache
    miss. Most memory chips available today have special modes that let you quickly
    access several consecutive memory locations on the chip. The cache exploits this
    capability to reduce the average number of wait states needed to access sequential
    memory locations. Although reading 16 bytes on each cache miss is expensive if
    you access only a few bytes in the corresponding cache line, cache memory systems
    work quite well in the average case.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了缓存内存如何处理内存访问的时间方面，但尚未涉及空间方面。*当你访问它们时*，缓存内存位置并不会加速程序，如果你不断访问一些你以前从未访问过的连续位置。为了解决这个问题，当发生缓存未命中时，大多数缓存系统会读取主内存中的几个连续字节（工程师称之为*缓存行*）。例如，80x86系列CPU在缓存未命中时会读取16到64个字节。今天大多数内存芯片都有特殊模式，可以让你快速访问芯片上几个连续的内存位置。缓存利用这个功能来减少访问顺序内存位置时所需的平均等待状态数量。尽管每次缓存未命中时读取16个字节是昂贵的，如果你只访问对应缓存行中的少数几个字节，但缓存内存系统在平均情况下表现得相当好。
- en: The ratio of cache hits to misses increases with the size (in bytes) of the
    cache memory subsystem. The 80486 CPU, for example, has 8,192 bytes of on-chip
    cache. Intel claims to get an 80 to 95 percent hit rate with this cache (meaning
    80 to 95 percent of the time the CPU finds the data in the cache). This sounds
    very impressive, but let’s play around with the numbers a little bit. Suppose
    we pick the 80 percent figure. This means that one out of every five memory accesses,
    on average, will not be in the cache. If you have a 50 MHz processor (20 ns period)
    and a 90 ns memory access time, four out of five memory accesses require only
    20 ns (one clock cycle) because they are in the cache, and the fifth will require
    about four wait states (20 ns for a normal memory access plus 80 additional ns,
    or four wait states, to get at least 90 ns). However, the cache always reads 16
    consecutive bytes (4 double words) from memory. Most 80486-era memory subsystems
    let you read consecutive addresses in about 40 ns after accessing the first location.
    Therefore, the 80486 will require an additional six clock cycles to read the remaining
    3 double words, for a total of 220 ns. This corresponds to 11 clock cycles (at
    20 ns each), which is one normal memory cycle plus 10 wait states.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存命中率与缓存内存子系统的大小（以字节为单位）成正比。例如，80486 CPU有8,192字节的片上缓存。英特尔声称使用这个缓存时，命中率可以达到80%到95%（意味着80%到95%的时间CPU会在缓存中找到数据）。这听起来非常令人印象深刻，但让我们稍微调整一下数据。假设我们选择80%的命中率。意味着平均每五次内存访问中，就有一次不会在缓存中找到。如果你有一个50
    MHz的处理器（20 ns周期）和90 ns的内存访问时间，四分之三的内存访问只需要20 ns（一个时钟周期），因为它们在缓存中，剩下的那一次访问将需要大约四个等待状态（正常内存访问需要20
    ns，加上额外的80 ns或四个等待状态，才能确保至少达到90 ns）。然而，缓存总是从内存中读取16个连续的字节（4个双字）。大多数80486时代的内存子系统，在访问第一个位置后大约40
    ns内就可以读取连续地址。因此，80486将需要额外的六个时钟周期来读取剩余的3个双字，总共需要220 ns。这相当于11个时钟周期（每个时钟周期20 ns），即一个正常的内存周期加上10个等待状态。
- en: Altogether, the system will require 15 clock cycles to access five memory locations,
    or 3 clock cycles per access, on average. That’s equivalent to two wait states
    added to every memory access. Doesn’t sound so impressive, does it? It gets even
    worse as you move up to faster processors and the difference in speed between
    the CPU and memory increases.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，系统需要15个时钟周期来访问五个内存位置，或者平均每次访问需要3个时钟周期。这相当于每次内存访问都增加了两个等待状态。听起来并不那么令人印象深刻，对吧？当你升级到更快的处理器，并且CPU和内存之间的速度差异增大时，情况会变得更糟。
- en: To improve the hit ratio, you can add more cache memory. Alas, you can’t pull
    an Intel i9 chip apart and solder more cache onto the chip. However, modern Intel
    CPUs have a significantly larger cache than the 80486 and operate with fewer average
    wait states. This improves the cache hit ratio. For example, increasing the hit
    ratio from 80 percent to 90 percent lets you access 10 memory locations in 20
    cycles. This reduces the average number of wait states per memory access to one
    wait state—a substantial improvement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高命中率，你可以添加更多的缓存内存。遗憾的是，你不能拆开英特尔i9芯片，然后在芯片上焊接更多的缓存。然而，现代英特尔CPU的缓存比80486大得多，并且操作时的平均等待状态更少。这提高了缓存命中率。例如，将命中率从80%提高到90%可以让你在20个周期内访问10个内存位置。这将每次内存访问的平均等待状态数减少到一个等待状态——这是一个显著的改进。
- en: Another way to improve performance is to build a *two-level* (L2) caching system.
    Many Intel CPUs work in this fashion. The first level is the on-chip 8,192-byte
    cache. The next level, between the on-chip cache and main memory, is a secondary
    cache (see [Figure 6-21](ch06.xhtml#ch06fig21)). On newer processors, the first-
    and second-level caches generally appear in the same packaging as the CPU. This
    allows the CPU designers to build a higher-performance CPU/memory interface, allowing
    the CPU to move data between caches and the CPU (as well as main memory) much
    more rapidly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 改善性能的另一种方法是构建一个*二级*（L2）缓存系统。许多英特尔CPU采用这种方式。第一层是片上8,192字节的缓存。接下来的层级位于片上缓存和主内存之间，是一个二级缓存（见[图
    6-21](ch06.xhtml#ch06fig21)）。在更新的处理器中，一级和二级缓存通常与CPU在同一个封装内。这使得CPU设计人员能够构建更高性能的CPU/内存接口，从而使CPU能够更快速地在缓存和CPU（以及主内存）之间传输数据。
- en: '![image](../images/06fig21.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig21.jpg)'
- en: '*Figure 6-21: A two-level caching system*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-21：二级缓存系统*'
- en: A typical on-CPU secondary cache contains anywhere from 32,768 bytes to over
    2MB of memory.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的CPU二级缓存包含从32,768字节到超过2MB的内存。
- en: Secondary cache generally does not operate at zero wait states. The circuitry
    to support that much fast memory would be *very* expensive, so most system designers
    use slower memory, which requires one or two wait states. This is still much faster
    than main memory. Combined with the existing on-chip L1 cache, you can get better
    performance from the system with a L2 caching system.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 二级缓存通常无法在零等待周期下运行。支持如此高速内存的电路将是 *非常* 昂贵的，因此大多数系统设计师使用较慢的内存，这需要一个或两个等待周期。尽管如此，这仍然比主内存要快得多。结合现有的片上
    L1 缓存，使用 L2 缓存系统可以提升系统性能。
- en: Today, many CPUs incorporate a *three-level (L3) cache*. Though the performance
    improvement afforded by an L3 cache is nowhere near what you get with an L1 or
    L2 cache subsystem, L3 cache subsystems can be quite large (usually several megabytes^([5](footnotes.xhtml#fn6_5a)))
    and work well for large systems with gigabytes of main memory. For programs that
    manipulate considerable data yet exhibit locality of reference, an L3 caching
    subsystem can be very effective.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多 CPU 集成了 *三级 (L3) 缓存*。尽管 L3 缓存带来的性能提升远不及 L1 或 L2 缓存子系统，但 L3 缓存子系统通常可以非常大（通常为数兆字节^([5](footnotes.xhtml#fn6_5a)))，并且在拥有数GB主内存的大型系统中表现良好。对于那些处理大量数据但具有局部性特征的程序，L3
    缓存子系统非常有效。
- en: '**6.5 CPU Memory Access**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.5 CPU 内存访问**'
- en: Most CPUs have two or three different ways to access memory. The most common
    *[memory addressing modes](gloss01.xhtml#gloss01_150)* modern CPUs support are
    *direct*, *indirect*, and *indexed*. A few CPUs (like the 80x86) support additional
    addressing modes like *scaled-index*, while some RISC CPUs support only indirect
    access to memory. Having additional memory addressing modes makes memory access
    more flexible. Sometimes a particular addressing mode will allow you to access
    data in a complex data structure with a single instruction, where otherwise two
    or more instructions would be required.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CPU 有两种或三种不同的内存访问方式。现代 CPU 支持的最常见 *[内存寻址模式](gloss01.xhtml#gloss01_150)*
    包括 *直接*、*间接* 和 *索引*。一些 CPU（如 80x86）支持额外的寻址模式，如 *缩放索引*，而某些 RISC CPU 仅支持间接内存访问。拥有额外的内存寻址模式使得内存访问更加灵活。有时，某种特定的寻址模式允许你使用一条指令访问复杂数据结构中的数据，而否则可能需要两条或更多的指令。
- en: RISC processors can often take three to five instructions to do what a single
    80x86 instruction does. However, this does not mean that an 80x86 program will
    run three to five times faster. Don’t forget that access to memory is very slow,
    usually requiring wait states. Whereas the 80x86 frequently accesses memory, RISC
    processors rarely do. Therefore, that RISC processor can probably execute the
    first four instructions, which do not access memory at all, while the single 80x86
    instruction, which does access memory, is spinning on some wait states. In the
    fifth instruction the RISC CPU might access memory and incur wait states of its
    own. If both processors execute an average of one instruction per clock cycle
    and have to insert 30 wait states for a main memory access, we’re talking about
    31 clock cycles (80x86) versus 35 clock cycles (RISC), only about a 12 percent
    difference.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: RISC 处理器通常需要三到五条指令才能完成一条 80x86 指令的工作。然而，这并不意味着 80x86 程序将运行得快三到五倍。不要忘记，内存访问非常慢，通常需要等待周期。而
    80x86 经常访问内存，而 RISC 处理器则很少这样做。因此，RISC 处理器可能能执行前四条指令，而这些指令根本不访问内存，而 80x86 指令则在等待内存访问时等待某些周期。在第五条指令时，RISC
    CPU 可能会访问内存，并可能需要自己的等待周期。如果两个处理器每个时钟周期执行一条指令，并且都需要为主内存访问插入 30 个等待周期，我们就谈到 31 个时钟周期（80x86）对
    35 个时钟周期（RISC），差距大约为 12%。
- en: Choosing an appropriate addressing mode often enables an application to compute
    the same result with fewer instructions and with fewer memory accesses, thus improving
    performance. Therefore, if you want to write fast and compact code, it’s important
    to understand how an application can use the different addressing modes a CPU
    provides.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适当的寻址模式通常可以使应用程序以更少的指令和内存访问计算相同的结果，从而提高性能。因此，如果你想编写快速且紧凑的代码，理解应用程序如何使用 CPU
    提供的不同寻址模式非常重要。
- en: '***6.5.1 The Direct Memory Addressing Mode***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.1 直接内存寻址模式***'
- en: 'The direct addressing mode encodes a variable’s memory address as part of the
    actual machine instruction that accesses the variable. On the 80x86, direct addresses
    are 32-bit values appended to the instruction’s encoding. Generally, a program
    uses the direct addressing mode to access global static variables. Here’s an example
    in HLA assembly language:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 直接寻址模式将变量的内存地址编码为访问变量的实际机器指令的一部分。在80x86上，直接地址是附加到指令编码的32位值。通常，程序使用直接寻址模式来访问全局静态变量。以下是HLA汇编语言的一个示例：
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you’re accessing variables whose memory address is known prior to the program’s
    execution, the direct addressing mode is ideal. With a single instruction, you
    can reference the memory location associated with the variable. On those CPUs
    that don’t support a direct addressing mode, you may need an extra instruction
    (or more) to load a register with the variable’s memory address prior to accessing
    that variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问那些程序执行前已知内存地址的变量时，直接寻址模式是理想的选择。通过一条指令，您可以引用与变量关联的内存位置。在那些不支持直接寻址模式的CPU上，您可能需要额外的指令（或更多指令）来在访问该变量之前将寄存器加载到变量的内存地址。
- en: '***6.5.2 The Indirect Addressing Mode***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.2 间接寻址模式***'
- en: The indirect addressing mode typically uses a register to hold a memory address
    (there are a few CPUs that use memory locations to hold the indirect address,
    but this form of indirect addressing is rare in modern CPUs).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 间接寻址模式通常使用一个寄存器来保存内存地址（有一些CPU使用内存位置来保存间接地址，但这种形式的间接寻址在现代CPU中很少见）。
- en: There are a couple of advantages of the indirect addressing mode over the direct
    addressing mode. First, you can modify the value of an indirect address (the value
    being held in a register) at runtime. Second, encoding which register specifies
    the indirect address takes far fewer bits than encoding a 32-bit (or 64-bit) direct
    address, so the instructions are smaller. One disadvantage is that it may take
    one or more instructions to load a register with an address before you can access
    that address.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 间接寻址模式相比于直接寻址模式有几个优点。首先，您可以在运行时修改间接地址的值（该值保存在寄存器中）。其次，编码指定间接地址的寄存器所需的位数远少于编码32位（或64位）直接地址，因此指令更小。缺点是在访问该地址之前可能需要一条或多条指令将寄存器加载到地址中。
- en: 'The following HLA sequence uses an 80x86 indirect addressing mode (brackets
    around the register name denote the use of indirect addressing):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下HLA序列使用了80x86间接寻址模式（在寄存器名称周围的括号表示使用间接寻址）：
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The indirect addressing mode is useful for many operations, such as accessing
    objects referenced by a pointer variable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 间接寻址模式对许多操作很有用，例如访问由指针变量引用的对象。
- en: '***6.5.3 The Indexed Addressing Mode***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.3 索引寻址模式***'
- en: The indexed addressing mode combines the direct and indirect addressing modes.
    Specifically, the machine instructions using this addressing mode encode both
    an offset (direct address) and a register in the bits that make up the instruction.
    At runtime, the CPU computes the sum of these two address components to create
    an *[effective address](gloss01.xhtml#gloss01_87)*. This addressing mode is great
    for accessing array elements and for indirect access to objects like structures
    and records. Though the instruction encoding is usually larger than for the indirect
    addressing mode, the indexed addressing mode has the advantage that you can specify
    an address directly within an instruction without having to use a separate instruction
    to load the address into a register.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式结合了直接和间接寻址模式。具体来说，使用这种寻址模式的机器指令在编码中同时包含偏移量（直接地址）和寄存器。在运行时，CPU计算这两个地址组件的和以创建一个*[有效地址](gloss01.xhtml#gloss01_87)*。这种寻址模式非常适合访问数组元素和间接访问结构和记录等对象。尽管指令编码通常比间接寻址模式更大，但索引寻址模式的优势在于您可以在指令中直接指定地址，而无需使用单独的指令将地址加载到寄存器中。
- en: 'Here’s a typical example of an HLA sequence that uses an 80x86 indexed addressing
    mode:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的使用80x86索引寻址模式的HLA序列的示例：
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `byteArray[ebx]` instruction in this short program demonstrates the indexed
    addressing mode. The effective address is the address of the `byteArray` variable
    plus the current value in the EBX register.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短程序中，`byteArray[ebx]`指令演示了索引寻址模式。有效地址是`byteArray`变量的地址加上EBX寄存器的当前值。
- en: 'To avoid wasting space encoding a 32-bit or 64-bit address into every instruction
    that uses an indexed addressing mode, many CPUs provide a shorter form that encodes
    an 8-bit or 16-bit offset as part of the instruction. When using this smaller
    form, the register provides the base address of the object in memory, and the
    offset provides a fixed displacement into that data structure in memory. This
    is useful, for example, for accessing fields of a record or structure in memory
    via a pointer to that structure. The earlier HLA example encodes the address of
    `byteArray` using a 4-byte address. Compare that with the following use of the
    indexed addressing mode:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在每条使用索引寻址模式的指令中浪费空间编码32位或64位地址，许多CPU提供了一种更短的形式，将8位或16位偏移量编码为指令的一部分。在使用这种更小的形式时，寄存器提供内存中对象的基址，而偏移量则提供数据结构在内存中的固定位移。例如，这对于通过指向结构的指针访问内存中记录或结构的字段非常有用。前面的HLA示例使用4字节地址编码了`byteArray`的地址。与此相比，下面是使用索引寻址模式的示例：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This last instruction encodes the displacement value using a single byte (rather
    than 4 bytes); hence, the instruction is shorter and more efficient.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令使用一个字节（而不是4个字节）编码位移值；因此，这条指令更短且更高效。
- en: '***6.5.4 The Scaled-Index Addressing Modes***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.4 缩放索引寻址模式***'
- en: 'The scaled-index addressing mode, available on several CPUs, provides two facilities
    above and beyond the indexed addressing mode:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可在多个CPU上使用的缩放索引寻址模式提供了比索引寻址模式更多的两个功能：
- en: The ability to use two registers (plus an offset) to compute the effective address
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个寄存器（加上偏移量）来计算有效地址的能力
- en: The ability to multiply one of those two registers’ values by a constant (typically
    1, 2, 4, or 8) prior to computing the effective address.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算有效地址之前，能够将这两个寄存器中的一个寄存器的值乘以一个常数（通常是1、2、4或8）。
- en: This addressing mode is especially useful for accessing elements of arrays whose
    element sizes match one of the scaling constants (see the discussion of arrays
    in [Chapter 7](ch07.xhtml#ch07) for the reasons).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种寻址模式对于访问数组元素尤其有用，前提是数组元素的大小与某个缩放常数匹配（有关原因，请参见[第7章](ch07.xhtml#ch07)中关于数组的讨论）。
- en: 'The 80x86 provides a scaled-index addressing mode that takes one of several
    forms, as shown in the following HLA statements:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86提供了一种缩放索引寻址模式，它有几种不同的形式，如下所示的HLA语句所示：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**6.6 For More Information**'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.6 获取更多信息**'
- en: 'Hennessy, John L., and David A. Patterson. *Computer Architecture: A Quantitative
    Approach*. 5th ed. Waltham, MA: Elsevier, 2012.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hennessy, John L., 和 David A. Patterson. *计算机架构：定量方法*. 第5版. Waltham, MA: Elsevier,
    2012.'
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hyde, Randall. *汇编语言的艺术*. 第2版. San Francisco: No Starch Press, 2010.'
- en: 'Patterson, David A., and John L. Hennessy. *Computer Organization and Design:
    The Hardware/Software Interface*. 5th ed. Waltham, MA: Elsevier, 2014.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'Patterson, David A., 和 John L. Hennessy. *计算机组织与设计：硬件/软件接口*. 第5版. Waltham,
    MA: Elsevier, 2014.'
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Chapter 11](ch11.xhtml#ch11) in this book provides additional information
    about cache memory and memory architecture.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*[第11章](ch11.xhtml#ch11)在本书中提供了关于缓存内存和内存架构的额外信息。*'
