<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Selinux"><div class="titlepage"><div><div><h1 class="title"><a id="selinux-id00027"/>Chapter 12. Selinux</h1></div></div></div><p><a id="iddle1510" class="indexterm"/><a id="iddle1635" class="indexterm"/><a id="iddle2175" class="indexterm"/><a id="iddle2188" class="indexterm"/><a id="iddle2706" class="indexterm"/><a id="iddle2727" class="indexterm"/><a id="iddle2746" class="indexterm"/>While previous chapters mentioned Security-Enhanced Linux (SELinux) and its Android integration, our discussion of Android’s security model up until now has focused on Android’s “traditional” sandbox implementation, which relies heavily on Linux’s default discretionary access control (DAC). The Linux DAC is lightweight and well understood, but it has certain disadvantages, most notably the coarse granularity of DAC permissions, the potential for misconfigured programs to leak data, and the inability to apply fine-grained privilege constraints to processes that run as the root user. (While POSIX capabilities, which are implemented as an extension to the traditional DAC in Linux, offer a way to grant only certain privileges to root processes, the granularity of POSIX capabilities is fairly coarse and the granted privileges extend to all objects accessed by the process.)</p><p><span class="emphasis"><em>Mandatory access control (MAC)</em></span>, as implemented by SELinux, seeks to overcome these limitations of Linux’s DAC by enforcing a systemwide, more finely grained security policy that can be changed only by the system administrator, and not by unprivileged users and programs. This chapter <a id="iddle2145" class="indexterm"/><a id="iddle2166" class="indexterm"/><a id="iddle2738" class="indexterm"/>first gives a brief overview of the architecture and concepts used in SELinux and then describes the major modifications made to SELinux in order to support Android. Finally, we give an overview of the SELinux policy that’s deployed in the current version of Android.</p><div class="sect1" title="SELinux Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="selinux_introduction"/>SELinux Introduction</h1></div></div></div><p>SELinux is a mandatory access control mechanism for the Linux kernel, implemented as a Linux security module. The Linux Security Modules (LSM) framework allows third-party access control mechanisms to be linked into the kernel and to modify the default DAC implementation. LSM is implemented as a series of security function hooks (upcalls) and related data structures that are integrated into the various modules of the Linux kernel responsible for access control.</p><p>Some of the main kernel services that have LSM hooks inserted are program execution, file and inode operations, netlink messaging, and socket operations. If no security module is installed, Linux uses its built-in DAC mechanism to regulate access to kernel objects managed by these services. If a security module is installed, Linux consults it in addition to the DAC in order to reach a final security decision when access to a kernel object is requested.</p><p>Besides providing hooks into major kernel services, the LSM framework also extends the procfs virtual filesystem (<span class="emphasis"><em>/proc</em></span>) to include per-process and per-task (thread) security attributes, and adds support for using filesystem extended attributes as persistent security attribute storage. SELinux was the first LSM module integrated into the Linux kernel and has been officially available since version 2.6 (previous SELinux implementations were distributed as a set of patches). Since the integration of SELinux, other security modules have also been accepted into the mainline kernel, which as of this writing includes AppArmor, Smack, and TOMOYO Linux as well. These modules provide alternative MAC implementations and are based on different security models than those of SELinux.</p><p>We’ll explore the SELinux security model and architecture in the next sections.</p><div class="sect2" title="SELinux Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="selinux_architecture"/>SELinux Architecture</h2></div></div></div><p>While the SELinux architecture is quite complex, at a high level it consists of four main components: object managers (OM), an access vector cache (AVC), a security server, and a security policy, as shown in <a class="xref" href="ch12.html#selinux_components" title="Figure 12-1. SELinux components">Figure 12-1</a>.</p><p>When a subject asks to perform an action on an SELinux object (for example, when a process tries to read a file), the associated object manager queries the AVC to see if the attempted action is allowed. If the AVC contains a cached security decision for the request, the AVC returns it to the OM, which enforces the decision by allowing or denying the action (steps 1, 2, and 5 in <a class="xref" href="ch12.html#selinux_components" title="Figure 12-1. SELinux components">Figure 12-1</a>). If the cache does not contain a matching security decision, the AVC contacts the security server, which makes a security decision based on the currently loaded policy and returns it to the AVC, which caches it. The AVC in turn returns it to the OM, which ultimately enforces <a id="iddle2176" class="indexterm"/><a id="iddle2189" class="indexterm"/><a id="iddle2216" class="indexterm"/><a id="iddle2237" class="indexterm"/><a id="iddle2917" class="indexterm"/><a id="iddle2947" class="indexterm"/>the decision (steps 1, 2, 3, 4, and 5 in <a class="xref" href="ch12.html#selinux_components" title="Figure 12-1. SELinux components">Figure 12-1</a>). The security server is part of the kernel, while the policy is loaded from userspace via a series of functions contained in the supporting userspace library.</p><div class="figure"><a id="selinux_components"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00071"/><img src="figs/web/12fig01.png.jpg" alt="SELinux components"/></div></div><p class="title">Figure 12-1. SELinux components</p></div><p>The OM and AVC can reside either in kernel space (when the OM is managing kernel-level objects) or userspace (when the OM is part of a so-called SELinux-aware application, which has built-in MAC support).</p></div><div class="sect2" title="Mandatory Access Control"><div class="titlepage"><div><div><h2 class="title"><a id="mandatory_access_control"/>Mandatory Access Control</h2></div></div></div><p>SELinux’s MAC model is based on three main concepts: subjects, objects, and actions. In this model, subjects are the active actors that perform actions on objects, and the action is carried out only if the security policy allows it.</p><p>In practice, subjects are usually running processes (a process can also be an object), and objects are OS-level resources managed by the kernel, such as files and sockets. Both subjects and objects have a set of security attributes (collectively known as the <span class="emphasis"><em>security context</em></span>, discussed in the next section), which the OS queries in order to decide whether the requested action should be allowed or not. When SELinux is enabled, subjects cannot bypass or influence policy rules; therefore, the policy is mandatory.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note01"/>Note</h3><p><span class="emphasis"><em>The MAC policy is only consulted if the DAC allows access to a resource. If the DAC denies access (for example, based on file permissions), the denial is taken as the final security decision.</em></span></p></div><p>SELinux supports two forms of MAC: <span class="emphasis"><em>type enforcement (TE)</em></span> and <span class="emphasis"><em>multilevel security (MLS)</em></span>. MLS is typically used to enforce different levels of access to restricted information and is not used in Android. The type enforcement <a id="iddle2130" class="indexterm"/><a id="iddle2701" class="indexterm"/><a id="iddle2747" class="indexterm"/><a id="iddle2748" class="indexterm"/>implemented in SELinux requires that all subjects and objects have an associated type and SELinux uses this type to enforce the rules of its security policy.</p><p>In SELinux, a <span class="emphasis"><em>type</em></span> is simply a string that’s defined in the policy and associated with objects or subjects. Subject types reference processes or groups of processes and are also referred to as <span class="emphasis"><em>domains</em></span>. Types referring to objects usually specify the role an object plays within the policy, such as system file, application data file, and so on. The type (or domain) is an integral part of the security context, as discussed in “<a class="xref" href="ch12.html#security_contexts" title="Security Contexts">Security Contexts</a>” below.</p></div><div class="sect2" title="SELinux Modes"><div class="titlepage"><div><div><h2 class="title"><a id="selinux_modes"/>SELinux Modes</h2></div></div></div><p>SELinux has three modes of operation: disabled, permissive, and enforcing. When SELinux is disabled, no policy is loaded and only the default DAC security is enforced. In permissive mode, the policy is loaded and object access is checked, but access denial is only logged—not enforced. Finally, in enforcing mode, the security policy is both loaded and enforced, with violations logged.</p><p>In Android, the SELinux mode can be checked and changed with the <code class="literal">getenforce</code> and <code class="literal">setenforce</code> commands, as shown in <a class="xref" href="ch12.html#using_the_getenforceandsetenforcecommand" title="Example 12-1. Using the getenforce and setenforce commands">Example 12-1</a>. However, the mode set with <code class="literal">setenforce</code> is not persistent and will be reset to the default mode when the device reboots.</p><div class="example"><a id="using_the_getenforceandsetenforcecommand"/><p class="title">Example 12-1. Using the <span class="emphasis"><em>getenforce and setenforce commands</em></span></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>getenforce</strong></span>
Enforcing
# <span class="strong"><strong>setenforce 0</strong></span>
# <span class="strong"><strong>getenforce</strong></span>
Permissive</pre></div></div><p>Additionally, even when SELinux is in enforcing mode, the policy can specify permissive mode per domain (process) using the <code class="literal">permissive</code> statement. (See “<a class="xref" href="ch12.html#object_class_and_permission_statements" title="Object Class and Permission Statements">Object Class and Permission Statements</a>” for an example.)</p></div><div class="sect2" title="Security Contexts"><div class="titlepage"><div><div><h2 class="title"><a id="security_contexts"/>Security Contexts</h2></div></div></div><p>In SELinux, a <span class="emphasis"><em>security context</em></span> (also referred to as a <span class="emphasis"><em>security label</em></span>, or just <span class="emphasis"><em>label</em></span>) is a string with four fields delimited with colons: username, role, type, and an optional MLS security range. An SELinux username is typically associated with a group or class of users; for example, <span class="emphasis"><em>user_u</em></span> for unprivileged users and <span class="emphasis"><em>admin_u</em></span> for administrators.</p><p>Users can be associated with one or more roles in order to implement role-based access control, where each role is associated with one or more domain types. The type is used to group processes in a domain or to specify an object logical type.</p><p><a id="iddle2164" class="indexterm"/><a id="iddle2539" class="indexterm"/><a id="iddle3161" class="indexterm"/>The security range (or level) is used to implement MLS and specifies the security levels a subject is allowed to access. As of this writing, Android only uses the type field of the security context, and the user and security range are always set to <span class="emphasis"><em>u</em></span> and <span class="emphasis"><em>s0</em></span>. The role is set to either <span class="emphasis"><em>r</em></span> for domains (processes) or to the built-in <span class="emphasis"><em>object_r</em></span> role for objects.</p><p>The security context of processes can be displayed by specifying the <code class="literal">-Z</code> option to the <code class="literal">ps</code> command, as shown in <a class="xref" href="ch12.html#process_security_contexts_in_android" title="Example 12-2. Process security contexts in Android">Example 12-2</a> (in the <code class="literal">LABEL</code> column).</p><div class="example"><a id="process_security_contexts_in_android"/><p class="title">Example 12-2. Process security contexts in Android</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ps -Z</strong></span>
LABEL                                   USER    PID    PPID     NAME
u:r:init:s0➊                            root    1      0        /init
u:r:kernel:s0                           root    2      0        kthreadd
u:r:kernel:s0                           root    3      2        ksoftirqd/0
--<span class="emphasis"><em>snip</em></span>--
u:r:healthd:s0➋              root    175    1        /sbin/healthd
u:r:servicemanager:s0➌       system  176    1        /system/bin/
servicemanager
u:r:vold:s0➍                 root    177    1        /system/bin/vold
u:r:init:s0                             nobody  178    1        /system/bin/rmt_storage
u:r:netd:s0                             root    179    1        /system/bin/netd
u:r:debuggerd:s0                        root    180    1        /system/bin/debuggerd
u:r:rild:s0                             radio   181    1        /system/bin/rild
--<span class="emphasis"><em>snip</em></span>--
u:r:platform_app:s0                     u0_a12  950    183      com.android.systemui
u:r:media_app:s0                        u0_a5   1043   183      android.process.media
u:r:radio:s0                            radio   1141   183      com.android.phone
u:r:nfc:s0                              nfc     1163   183      com.android.nfc
u:r:untrusted_app:s0                    u0_a7   1360   183      com.google.android.gms
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Similarly, the context of files can be viewed by passing the <code class="literal">-Z</code> to the <code class="literal">ls</code> command, as shown in <a class="xref" href="ch12.html#file_and_directory_security_contexts_in" title="Example 12-3. File and directory security contexts in Android">Example 12-3</a>.</p><div class="example"><a id="file_and_directory_security_contexts_in"/><p class="title">Example 12-3. File and directory security contexts in Android</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -Z</strong></span>
drwxr-xr-x root        root              u:object_r:cgroup:s0 acct
drwxrwx--- system      cache             u:object_r:cache_file:s0 cache
-rwxr-x--- root        root              u:object_r:rootfs:s0 charger
--<span class="emphasis"><em>snip</em></span>--
drwxrwx--x system      system            u:object_r:system_data_file:s0 data
-rw-r--r-- root        root              u:object_r:rootfs:s0 default.prop
drwxr-xr-x root        root              u:object_r:device:s0 dev
lrwxrwxrwx root        root              u:object_r:rootfs:s0 etc -&gt; /system/etc
-rw-r--r-- root        root              u:object_r:rootfs:s0 file_contexts
dr-xr-x--- system      system            u:object_r:sdcard_external:s0 firmware
-rw-r----- root        root              u:object_r:rootfs:s0 fstab.hammerhead
-rwxr-x--- root        root              u:object_r:rootfs:s0 init
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect2" title="Security Context Assignment and Persistence"><div class="titlepage"><div><div><h2 class="title"><a id="security_context_assignment_and_persiste"/>Security Context Assignment and Persistence</h2></div></div></div><p><a id="iddle1768" class="indexterm"/><a id="iddle2702" class="indexterm"/><a id="iddle2749" class="indexterm"/><a id="iddle2751" class="indexterm"/>We’ve established that all subject and objects have a security context, but how is the context assigned and persisted? For objects (which are usually associated with a file on the filesystem), the security context is persistent and is usually stored as an extended attribute in the file’s metadata.</p><p>Extended attributes are not interpreted by the filesystem and can contain arbitrary data (though any such data is usually limited in size). The <span class="emphasis"><em>ext4</em></span> filesystem, the default in most Linux distributions and current versions of Android, supports extended attributes in the form of name-value pairs, where the name is a null-terminated string. SELinux uses the <span class="emphasis"><em>security.selinux</em></span> name to store the security context of file objects. The security context of objects can be set explicitly as part of a filesystem initialization (also called <span class="emphasis"><em>labeling</em></span>), or be implicitly assigned when an object is created. Objects typically inherit the type label of their parent (for example, newly created files in a directory inherit the label of the directory). However, if the security policy allows, objects can receive a label that’s different from that of their parent, a process referred to as <span class="emphasis"><em>type transition</em></span>.</p><p>Like objects, subjects (processes) inherit the security context of their parent process, or they can change their context via <span class="emphasis"><em>domain transition</em></span>, if allowed by the security policy. The policy can specify automatic domain transition as well, which automatically sets the domain of newly started processes based on the domain of their parent and the type of the executed binary. For example, because all system daemons are started by the <span class="emphasis"><em>init</em></span> process, which has the <span class="emphasis"><em>u:r:init:s0</em></span> security context (➊ in <a class="xref" href="ch12.html#process_security_contexts_in_android" title="Example 12-2. Process security contexts in Android">Example 12-2</a>), they would normally inherit this context, but Android’s SELinux policy uses automatic domain transitions to set a dedicated domain to each daemon as needed (➋, ➌, and ➍ in <a class="xref" href="ch12.html#process_security_contexts_in_android" title="Example 12-2. Process security contexts in Android">Example 12-2</a>).</p></div><div class="sect2" title="Security Policy"><div class="titlepage"><div><div><h2 class="title"><a id="security_policy"/>Security Policy</h2></div></div></div><p>The SELinux security policy is used by the security server in the kernel to allow or disallow access to kernel objects at runtime. For performance reasons, the policy is typically in a binary form generated by compiling a number of policy source files. The policy source files are written in a dedicated policy language, which consists of statements and rules. <span class="emphasis"><em>Statements</em></span> define policy entities such as types, users, and roles. <span class="emphasis"><em>Rules</em></span> allow or deny access to objects (access vector rules); specify the type of transitions allowed (type enforcement rules); and designate how default users, roles, and types are assigned (default rules). A thorough discussion of SELinux’s policy grammar is beyond the scope of this book, but the following sections will introduce some of the most widely used statements and rules.</p></div><div class="sect2" title="Policy Statements"><div class="titlepage"><div><div><h2 class="title"><a id="policy_statements"/>Policy Statements</h2></div></div></div><p>The SELinux policy language supports various types of statements, but type, attribute, and permission statements make up the bulk of a security policy. We introduce these three types of statements in the following sections.</p><div class="sect3" title="Type and Attribute Statements"><div class="titlepage"><div><div><h3 class="title"><a id="type_and_attribute_statements"/>Type and Attribute Statements</h3></div></div></div><p><a id="iddle1238" class="indexterm"/><a id="iddle1519" class="indexterm"/><a id="iddle1662" class="indexterm"/><a id="iddle1811" class="indexterm"/><a id="iddle2753" class="indexterm"/><a id="iddle2754" class="indexterm"/><a id="iddle2895" class="indexterm"/><a id="iddle2952" class="indexterm"/><a id="iddle2979" class="indexterm"/><a id="iddle3027" class="indexterm"/><code class="literal">type</code> and <code class="literal">attribute</code> statements declare types and their attributes, as shown in <a class="xref" href="ch12.html#type_and_attribute_statements-id00028" title="Example 12-4. type and attribute statements">Example 12-4</a>.</p><div class="example"><a id="type_and_attribute_statements-id00028"/><p class="title">Example 12-4. <code class="literal">type</code> and <code class="literal">attribute statements</code></p><div class="example-contents"><pre class="programlisting">attribute file_type;➊
attribute domain;➋

type system_data_file, file_type, data_file_type;➌
type untrusted_app, domain;➍</pre></div></div><p>Here, the first ➊ and second ➋ statements declare the <code class="literal">file_type</code> and <code class="literal">domain</code> attributes, and the next statement ➌ declares the <code class="literal">system_data_file</code> type and associates it with the <code class="literal">file_type</code> and <code class="literal">data_file_type</code> attributes. The code at ➍ declares the <code class="literal">untrusted_app</code> type and associates it with the <code class="literal">domain</code> attribute (which marks all types used for processes).</p><p>Depending on its granularity, an SELinux policy can have dozens or even hundreds of type and attribute declarations spread across multiple source files. However, because access to all kernel objects needs to be checked against the policy at runtime, a large policy can have a negative impact on performance. The effect on performance is especially apparent when running on devices with limited computing resources, and that is why Android strives to keep its SELinux policy relatively small.</p></div><div class="sect3" title="User and Role Statements"><div class="titlepage"><div><div><h3 class="title"><a id="user_and_role_statements"/>User and Role Statements</h3></div></div></div><p>The <code class="literal">user</code> statement declares an SELinux user identifier, associates it with its role(s), and optionally specifies its default security level and the range of security levels that the user can access. <a class="xref" href="ch12.html#declarations_of_the_default_selinux_user" title="Example 12-5. Declarations of the default SELinux user identifier in Android">Example 12-5</a> shows the declarations of the default and only user identifier in Android.</p><div class="example"><a id="declarations_of_the_default_selinux_user"/><p class="title">Example 12-5. Declarations of the default SELinux user identifier in Android</p><div class="example-contents"><pre class="programlisting">user u roles { r } level s0 range s0 - mls_systemhigh;</pre></div></div><p>As you can see in <a class="xref" href="ch12.html#declarations_of_the_default_selinux_user" title="Example 12-5. Declarations of the default SELinux user identifier in Android">Example 12-5</a>, the <span class="emphasis"><em>u</em></span> user is associated with the <span class="emphasis"><em>r</em></span> role (inside the braces), which in turn is declared using the <code class="literal">role</code> statement ➊ as shown in <a class="xref" href="ch12.html#declaration_of_the_default_selinux_role" title="Example 12-6. Declaration of the default SELinux role in Android">Example 12-6</a>.</p><div class="example"><a id="declaration_of_the_default_selinux_role"/><p class="title">Example 12-6. Declaration of the default SELinux role in Android</p><div class="example-contents"><pre class="programlisting">role r;➊
role r types domain;➋</pre></div></div><p>The second statement ➋ associates the <span class="emphasis"><em>r</em></span> role with the <code class="literal">domain</code> attribute, which marks it as a role assigned to processes (domains).</p></div><div class="sect3" title="Object Class and Permission Statements"><div class="titlepage"><div><div><h3 class="title"><a id="object_class_and_permission_statements"/>Object Class and Permission Statements</h3></div></div></div><p><a id="iddle1012" class="indexterm"/><a id="iddle1251" class="indexterm"/><a id="iddle1391" class="indexterm"/><a id="iddle1392" class="indexterm"/><a id="iddle1405" class="indexterm"/><a id="iddle1951" class="indexterm"/><a id="iddle2473" class="indexterm"/><a id="iddle2752" class="indexterm"/>The <code class="literal">permissive</code> statement allows a named domain to run in permissive mode (a mode that only logs MAC policy violations but doesn’t actually enforce the policy, as discussed next), even if SELinux is running in enforcing mode. As we will see in “<a class="xref" href="ch12.html#enforcing_domains" title="Enforcing Domains">Enforcing Domains</a>”, most domains in Android’s current base policy are permissive. For example, processes in the <span class="emphasis"><em>adbd</em></span> domain (in practice <span class="emphasis"><em>adbd</em></span> daemon processes) run in permissive mode, as shown in <a class="xref" href="ch12.html#setting_a_named_domain_to_permissive_mod" title="Example 12-7. Setting a named domain to permissive mode">Example 12-7</a> ➊.</p><div class="example"><a id="setting_a_named_domain_to_permissive_mod"/><p class="title">Example 12-7. Setting a named domain to permissive mode</p><div class="example-contents"><pre class="programlisting">type adbd, domain;
permissive adbd;➊
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>The <code class="literal">class</code> statement defines an SELinux object class, as shown in <a class="xref" href="ch12.html#object_class_declarations_in_the_securit" title="Example 12-8. Object class declarations in the security_classes file">Example 12-8</a>. Object classes and their associated permissions are determined by the respective object manager implementations in the Linux kernel, and are static within a policy. Object classes are usually defined in the <span class="emphasis"><em>security_classes</em></span> policy source file.</p><div class="example"><a id="object_class_declarations_in_the_securit"/><p class="title">Example 12-8. Object class declarations in the <span class="roman">security_classes</span> <span class="emphasis"><em>file</em></span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
# file-related classes
class filesystem
class file
class dir
class fd
class lnk_file
class chr_file
class blk_file
class sock_file
class fifo_file
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>SELinux permissions (also referred to as <span class="emphasis"><em>access vectors</em></span>) are usually defined and associated with object classes in a policy source file called <span class="emphasis"><em>access_vectors</em></span>. Permissions can be either class-specific (defined with the <code class="literal">class</code> keyword) or inheritable by one or more object classes, in which case they’re defined with the <code class="literal">common</code> keyword. <a class="xref" href="ch12.html#permission_definitions_in_the_accessunde" title="Example 12-9. Permission definitions in the access_vectors file">Example 12-9</a> shows the definition of the set of permissions common to all file objects ➊, and the association of the <code class="literal">dir</code> class (which represents directories) with all common file permissions (using the <code class="literal">inherits</code> keyword), and a set of directory-specific permissions (<span class="emphasis"><em>add_name</em></span>, <span class="emphasis"><em>remove_name</em></span>, and so on) ➋.</p><div class="example"><a id="permission_definitions_in_the_accessunde"/><p class="title">Example 12-9. Permission definitions in the <span class="roman">access_vectors</span> file</p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
common file
{
    ioctl
    read

    write
    create
    getattr
    setattr
    lock
    --<span class="emphasis"><em>snip</em></span>--
}➊
--<span class="emphasis"><em>snip</em></span>--
class dir
inherits file
{

    add_name
    remove_name
    reparent
    search
    rmdir
    --<span class="emphasis"><em>snip</em></span>--
}➋
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div></div><div class="sect2" title="Type Transition Rules"><div class="titlepage"><div><div><h2 class="title"><a id="type_transition_rules"/>Type Transition Rules</h2></div></div></div><p><a id="iddle2755" class="indexterm"/><a id="iddle2953" class="indexterm"/><a id="iddle3114" class="indexterm"/><a id="iddle3131" class="indexterm"/><a id="iddle3133" class="indexterm"/>Type enforcement rules and access vector rules (discussed in “<a class="xref" href="ch12.html#domain_transition_rules" title="Domain Transition Rules">Domain Transition Rules</a>” and “<a class="xref" href="ch12.html#access_vector_rules" title="Access Vector Rules">Access Vector Rules</a>”) typically make the bulk of an SELinux policy. In turn, the most commonly used type of enforcement rule is the <code class="literal">type_transition</code> rule, which specifies when domain and type transitions are allowed. For example, the <span class="emphasis"><em>wpa_supplicant</em></span> daemon, which manages Wi-Fi connections in Android, uses the type transition rule shown in <a class="xref" href="ch12.html#type_transitions_in_the_wpa_domain_left" title="Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)">Example 12-10</a> at ➍ in order to associate the control sockets it creates in the <span class="emphasis"><em>/data/misc/wifi/</em></span> directory with the <code class="literal">wpa_socket</code> type. In the absence of this rule, the sockets would inherit the type of their parent directory: <code class="literal">wifi_data_file</code>.</p><div class="example"><a id="type_transitions_in_the_wpa_domain_left"/><p class="title">Example 12-10. Type transitions in the <span class="roman">wpa</span> domain (from <span class="roman">wpa_supplicant.te</span>)</p><div class="example-contents"><pre class="programlisting"># wpa - wpa supplicant or equivalent
type wpa, domain;
permissive wpa;➊
type wpa_exec, exec_type, file_type;

init_daemon_domain(wpa)➋
unconfined_domain(wpa)➌
type_transition wpa wifi_data_file:sock_file wpa_socket;➍</pre></div></div><p>Here, <code class="literal">wpa</code>, <code class="literal">wifi_data_file:sock_file</code>, and <code class="literal">wpa_socket</code> are the source type (in this case, the domain of the <span class="emphasis"><em>wpa_supplicant</em></span> process), the target type and class (the type and class of the object before the transition), and the type of the object after the transition, respectively.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note02"/>Note</h3><p><a id="iddle1663" class="indexterm"/><a id="iddle1664" class="indexterm"/><a id="iddle1952" class="indexterm"/><a id="iddle2740" class="indexterm"/><span class="emphasis"><em>In order to be able to create the socket file and change its label, the <code class="literal">wpa</code> domain needs additional permissions on the parent directory and the socket file itself—the <code class="literal">type_transition</code> rule alone is not sufficient. However, because the <code class="literal">wpa</code> domain is both permissive</em></span> ➊ <span class="emphasis"><em>and unconfined (granted most permissions by default)</em></span> ➌<span class="emphasis"><em>, the transition is allowed without explicitly allowing each required permission.</em></span></p></div></div><div class="sect2" title="Domain Transition Rules"><div class="titlepage"><div><div><h2 class="title"><a id="domain_transition_rules"/>Domain Transition Rules</h2></div></div></div><p>In Android, native system daemons like <span class="emphasis"><em>wpa_supplicant</em></span> are started by the <span class="emphasis"><em>init</em></span> process, and therefore inherit its security context by default. However, most daemons are associated with a dedicated domain and use domain transitions to switch their domain when started. This is typically accomplished using the <code class="literal">init_daemon_domain()</code> macro (➋ in <a class="xref" href="ch12.html#type_transitions_in_the_wpa_domain_left" title="Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)">Example 12-10</a>), which under the hood is implemented using the <code class="literal">type_transition</code> keyword, just like type transitions.</p><p>The binary SELinux policy build process uses the <code class="literal">m4</code> macro preprocessor<sup>[<a id="ch12fn01" href="#ftn.ch12fn01" class="footnote">132</a>]</sup> to expand macros before merging all source files in order to create the binary policy file. The <code class="literal">init_daemon_domain()</code> macro takes one parameter (the new domain of the process) and is defined in the <span class="emphasis"><em>te_macros</em></span> file using two other macros: <code class="literal">domain_trans()</code> and <code class="literal">domain_auto_trans()</code>, which are used to allow transition to a new domain and to execute the transition automatically, respectively. <a class="xref" href="ch12.html#domain_transition_macros_definition_in_t" title="Example 12-11. Domain transition macros definition in the te_macros file">Example 12-11</a> shows the definitions of these three macros (➊, ➋, and ➌). The lines beginning with the <code class="literal">allow</code> keyword are access vector (AV) rules, which we discuss in the next section.</p><div class="example"><a id="domain_transition_macros_definition_in_t"/><p class="title">Example 12-11. Domain transition macros definition in the <span class="roman">te_macros</span> <code class="literal">file</code></p><div class="example-contents"><pre class="programlisting"># domain_trans(olddomain, type, newdomain)
define(`domain_trans', `
allow $1 $2:file { getattr open read execute };
allow $1 $3:process transition;
allow $3 $2:file { entrypoint read execute };
allow $3 $1:process sigchld;
dontaudit $1 $3:process noatsecure;
allow $1 $3:process { siginh rlimitinh };
')➊
# domain_auto_trans(olddomain, type, newdomain)
define(`domain_auto_trans', `
domain_trans($1,$2,$3)
type_transition $1 $2:process $3;
')➋
# init_daemon_domain(domain)
 define(`init_daemon_domain', `
domain_auto_trans(init, $1_exec, $1)
tmpfs_domain($1)
')➌
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect2" title="Access Vector Rules"><div class="titlepage"><div><div><h2 class="title"><a id="access_vector_rules"/>Access Vector Rules</h2></div></div></div><p><a id="iddle1013" class="indexterm"/><a id="iddle1014" class="indexterm"/><a id="iddle1132" class="indexterm"/><a id="iddle1316" class="indexterm"/><a id="iddle1322" class="indexterm"/><a id="iddle2726" class="indexterm"/><a id="iddle2728" class="indexterm"/><a id="iddle2729" class="indexterm"/>AV rules define what privileges processes have at runtime by specifying the set of permissions they have over their target objects. <a class="xref" href="ch12.html#format_of_av_rules" title="Example 12-12. Format of AV rules">Example 12-12</a> shows the general format of an AV rule.</p><div class="example"><a id="format_of_av_rules"/><p class="title">Example 12-12. Format of AV rules</p><div class="example-contents"><pre class="programlisting">rule_name source_type target_type : class perm_set;</pre></div></div><p>The <code class="literal">rule_name</code> can be <code class="literal">allow</code>, <code class="literal">dontaudit</code>, <code class="literal">auditallow</code>, or <code class="literal">neverallow</code>. To form a rule, the <code class="literal">source_type</code> and <code class="literal">target_type</code> elements are replaced with one or more previously defined <code class="literal">type</code> or <code class="literal">attribute</code> identifiers, where <code class="literal">source_type</code> is the identifier of a subject (process), and <code class="literal">target_type</code> is the identifier of an object the process is trying to access. The <code class="literal">class</code> element is replaced with the object class of the target, and <code class="literal">perm_set</code> specifies the set of permissions that the source process has over the target object. You can specify multiple types, classes, and permissions by enclosing them in braces (<code class="literal">{}</code>). In addition, some rules support use of the wildcard (<code class="literal">*</code>) and complement (<code class="literal">~</code>) operators, which allow you to specify that all types should be included or that all types except those explicitly listed should be included, respectively.</p><div class="sect3" title="allow Rules"><div class="titlepage"><div><div><h3 class="title"><a id="allow_rules"/>allow Rules</h3></div></div></div><p>The most commonly used rule is <code class="literal">allow</code>, which specifies the operations that a subject (process) of the specified source type is allowed to perform on an object of the target type and class specified in the rule. Let’s take the SELinux policy for the <span class="emphasis"><em>vold</em></span> daemon (see <a class="xref" href="ch12.html#allow_rules_for_the_vold_domain_left_par" title="Example 12-13. allow rules for the vold domain (from vold.te)">Example 12-13</a>) as an example to illustrate how to use the <code class="literal">allow</code> rule.</p><div class="example"><a id="allow_rules_for_the_vold_domain_left_par"/><p class="title">Example 12-13. <code class="literal">allow</code> rules for the <code class="literal">vold</code> domain (from <span class="roman">vold.te</span>)</p><div class="example-contents"><pre class="programlisting">type vold, domain;
type vold_exec, exec_type, file_type;
init_daemon_domain(vold)
--<span class="emphasis"><em>snip</em></span>--
allow vold sdcard_type:filesystem { mount remount unmount };➊
--<span class="emphasis"><em>snip</em></span>--
allow vold self:capability { sys_ptrace kill };➋
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>In this listing, rule ➊ allows the <span class="emphasis"><em>vold</em></span> daemon (which runs in the <code class="literal">vold</code> domain) to mount, unmount, and remount filesystems of type <code class="literal">sdcard_type</code>. Rule ➋ allows the daemon to use the <code class="literal">CAP_SYS_PTRACE</code> (which allows <code class="literal">ptrace()</code> to be called on any process) and <code class="literal">CAP_KILL</code> (which allows signals to be sent to any process) Linux capabilities, which correspond to the permission set specified in the rule (inside the <code class="literal">{}</code>). In rule ➋, the <code class="literal">self</code> keyword means that the target domain is the same as the source, which in this case is <code class="literal">vold</code>.</p></div><div class="sect3" title="auditallow Rules"><div class="titlepage"><div><div><h3 class="title"><a id="auditallow_rules"/>auditallow Rules</h3></div></div></div><p><a id="iddle1015" class="indexterm"/><a id="iddle1016" class="indexterm"/><a id="iddle1017" class="indexterm"/><a id="iddle1239" class="indexterm"/><a id="iddle1321" class="indexterm"/><a id="iddle1665" class="indexterm"/><a id="iddle2292" class="indexterm"/><a id="iddle2730" class="indexterm"/><a id="iddle2731" class="indexterm"/><a id="iddle2732" class="indexterm"/><a id="iddle2741" class="indexterm"/>The <code class="literal">auditallow</code> rule is used with <code class="literal">allow</code> to record audit events when an operation is allowed. This is useful because by default, SELinux logs only access denied events. However, <code class="literal">auditallow</code> itself doesn’t grant access, and therefore a matching <code class="literal">allow</code> rule must be used in order to grant the necessary permissions.</p></div><div class="sect3" title="dontaudit Rules"><div class="titlepage"><div><div><h3 class="title"><a id="dontaudit_rules"/>dontaudit Rules</h3></div></div></div><p>The <code class="literal">dontaudit</code> rule is used to suppress the auditing of denial messages when a specified event is known to be safe. For example, the rule at ➊ in <a class="xref" href="ch12.html#dontaudit_rule_for_the_installd_domain_l" title="Example 12-14. dontaudit rule for the installd domain (from installd.te)">Example 12-14</a> specifies that no audit log be created if the <span class="emphasis"><em>installd</em></span> daemon is denied the <code class="literal">CAP_SYS_ADMIN</code> capability. However, <code class="literal">dontaudit</code> rules can mask program errors and the use of <code class="literal">dontaudit</code> is discouraged.</p><div class="example"><a id="dontaudit_rule_for_the_installd_domain_l"/><p class="title">Example 12-14. <code class="literal">dontaudit</code> rule for the <span class="roman">installd</span> domain (from <span class="roman">installd.te</span>)</p><div class="example-contents"><pre class="programlisting">type installd, domain;
--<span class="emphasis"><em>snip</em></span>--
dontaudit installd self:capability sys_admin;➊
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect3" title="neverallow Rules"><div class="titlepage"><div><div><h3 class="title"><a id="neverallow_rules"/>neverallow Rules</h3></div></div></div><p>The <code class="literal">neverallow</code> rule says that the declared operation should never be allowed, even if an explicit <code class="literal">allow</code> rule that allows it exists. For example, the rule shown in <a class="xref" href="ch12.html#neverallow_rule_that_forbids_domains_oth" title="Example 12-15. neverallow rule that forbids domains other than init from loading the SELinux policy (from domain.te)">Example 12-15</a> forbids all domains but the <code class="literal">init</code> domain to load the SELinux policy.</p><div class="example"><a id="neverallow_rule_that_forbids_domains_oth"/><p class="title">Example 12-15. <code class="literal">neverallow</code> rule that forbids domains other than <span class="roman">init</span> from loading the SELinux policy (from <span class="roman">domain.te</span>)</p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
neverallow { domain -init } kernel:security load_policy;</pre></div></div><div class="note" title="Note"><h3 class="title"><a id="ch12note03"/>Note</h3><p><span class="emphasis"><em>This section provides only a brief overview of SELinux, focusing on the features used in Android. For a more detailed discussion of the architecture and implementation of SELinux, as well its policy language, see the</em></span> SELinux Notebook.<sup>[<a id="ch12fn02" href="#ftn.ch12fn02" class="footnote">133</a>]</sup></p></div></div></div></div><div class="sect1" title="Android Implementation"><div class="titlepage"><div><div><h1 class="title"><a id="android_implementation-id00029"/>Android Implementation</h1></div></div></div><p>As discussed in <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a> and <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>, Android’s sandboxing security model relies heavily on the use of separate Linux UIDs for system daemons and applications. Process isolation and access control is ultimately enforced by <a id="iddle2177" class="indexterm"/><a id="iddle2190" class="indexterm"/><a id="iddle2743" class="indexterm"/>the Linux kernel based on process UID and GIDs. Because SELinux is also part of the Linux kernel, SELinux is a natural candidate for hardening the Android sandboxing model using a MAC policy.</p><p>As SELinux is integrated into the mainline Linux kernel, it would seem that enabling it in Android should be a simple matter of configuring the kernel and designing an appropriate MAC policy. However, because Android introduces some unique extensions to the Linux kernel and its userspace structure is quite different from that of desktop and server Linux distributions, several changes in both kernel and userspace were needed in order to integrate and enable SELinux into Android. While the initial work required to integrate SELinux was started by Google, most of the required changes were implemented in the Security Enhancements for Android project (formally Security-Enhanced Android, or SEAndroid),<sup>[<a id="ch12fn03" href="#ftn.ch12fn03" class="footnote">134</a>]</sup> and were later integrated into the mainline Android source tree. The following sections survey these major changes. For a comprehensive list of changes and the rationale behind them, see the <span class="emphasis"><em>Security Enhanced (SE) Android: Bringing Flexible MAC to Android</em></span> paper by the original authors of the SEAndroid project.<sup>[<a id="ch12fn04" href="#ftn.ch12fn04" class="footnote">135</a>]</sup></p><div class="sect2" title="Kernel Changes"><div class="titlepage"><div><div><h2 class="title"><a id="kernel_changes"/>Kernel Changes</h2></div></div></div><p>Recall from earlier that SELinux is a security module that implements the various LSM hooks inserted in kernel services related to object access control. Android’s Binder IPC mechanism is also implemented as a kernel driver, but because its implementation originally did not contain any LSM hooks, its runtime behavior could not be controlled by an SELinux policy. In order to add SELinux support to Binder, LSM hooks were inserted into the Binder driver, and support for the <code class="literal">binder</code> object class and related permissions was added to SELinux code.</p><p>SELinux security hooks are declared in <span class="emphasis"><em>include/linux/security.h</em></span>, and <a class="xref" href="ch12.html#binder_security_hooks_declarations_in_in" title="Example 12-16. Binder security hooks declarations in include/linux/security.h">Example 12-16</a> shows the Binder-related declarations added to support Android.</p><div class="example"><a id="binder_security_hooks_declarations_in_in"/><p class="title">Example 12-16. Binder security hooks declarations in <span class="roman">include/linux/security.h</span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
int security_binder_set_context_mgr(struct task_struct *mgr);➊
int security_binder_transaction(struct task_struct *from,
                                struct task_struct * to);➋
int security_binder_transfer_binder(struct task_struct *from,
                                    struct task_struct *to);➌
int security_binder_transfer_file(struct task_struct *from,
                                  struct task_struct *to, struct file *file);➍
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle2745" class="indexterm"/>The first hook ➊ controls what process can become the binder context manager, and the second one ➋ controls the ability of a process to invoke a binder transaction. The next two functions are used to regulate who can transfer a Binder reference to another process ➌, and transfer an open file to another process ➍ using Binder.</p><p>In order to allow the SELinux policy to set restrictions for Binder, support for the <code class="literal">binder</code> object class and its permissions (<code class="literal">impersonate</code>, <code class="literal">call</code>, <code class="literal">set_context_mgr</code>, and <code class="literal">transfer</code>) was also added to the kernel, as shown in <a class="xref" href="ch12.html#binder_object_class_and_permission_decla" title="Example 12-17. Binder object class and permission declaration in selinux/include/classmap.h">Example 12-17</a>.</p><div class="example"><a id="binder_object_class_and_permission_decla"/><p class="title">Example 12-17. Binder object class and permission declaration in <span class="roman">selinux/include/classmap.h</span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
struct security_class_mapping secclass_map[] = {
    --<span class="emphasis"><em>snip</em></span>--
    {"binder", {"impersonate", "call", "set_context_mgr", "transfer", NULL} },
    { NULL }
  };</pre></div></div></div><div class="sect2" title="Userspace Changes"><div class="titlepage"><div><div><h2 class="title"><a id="userspace_changes"/>Userspace Changes</h2></div></div></div><p>In addition to kernel changes, a number of userspace modifications and extensions were also required in order to integrate SELinux into Android. Among these, the most important ones are support for filesystem labeling in the core C library (bionic); extensions to <span class="emphasis"><em>init</em></span> and the core native daemons and executables; framework-level SELinux APIs; and modifications to core framework services to make them SELinux-aware. This section describes each change and how it’s integrated into the Android runtime.</p><div class="sect3" title="Libraries and Tools"><div class="titlepage"><div><div><h3 class="title"><a id="libraries_and_tools"/>Libraries and Tools</h3></div></div></div><p>Because SELinux uses extended attributes to store the security contexts of filesystem objects, wrapper functions for the system calls used to manage extended attributes (<code class="literal">listxattr()</code>, <code class="literal">getxattr()</code>, <code class="literal">setxattr()</code>, and so on) were first added to Android’s C library in order to be able to get and set the security labels of files and directories.</p><p>In order to be able to take advantage of SELinux features from user-space, SEAndroid added an Android-compatible port of the <span class="emphasis"><em>libselinux</em></span> library, as well as a set of utility commands to manage labeling, the security policy, and to switch the SELinux mode between enforcing and permissive. Like most Android command-line utilities, SELinux tools are implemented in the <code class="literal">toolbox</code> binary and are installed as symbolic links to it. <a class="xref" href="ch12.html#selinux_command-line_utilities" title="Table 12-1. SELinux Command-Line Utilities">Table 12-1</a> summarizes the added or modified command-line tools.</p><div class="table"><a id="selinux_command-line_utilities"/><p class="title">Table 12-1. SELinux Command-Line Utilities</p><div class="table-contents"><table summary="SELinux Command-Line Utilities" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1368" class="indexterm"/><a id="iddle1867" class="indexterm"/><a id="iddle1885" class="indexterm"/><a id="iddle1946" class="indexterm"/><a id="iddle2146" class="indexterm"/><a id="iddle2165" class="indexterm"/><a id="iddle2540" class="indexterm"/><a id="iddle2606" class="indexterm"/><a id="iddle2642" class="indexterm"/><a id="iddle2673" class="indexterm"/><a id="iddle2772" class="indexterm"/><a id="iddle2775" class="indexterm"/><a id="iddle2790" class="indexterm"/><a id="iddle3162" class="indexterm"/>Command</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">chcon</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Changes a file’s security context</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">getenforce</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Gets the current SELinux mode</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">getsebool</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Gets policy Boolean values</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">id</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Displays a process’s security context</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">load_policy</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Loads a policy file</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">ls -Z</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Displays the security context of a file</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">ps -Z</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Displays the security context of running processes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">restorecon</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Restores the security context of a file(s)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">runcon</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Runs a program in the specified security context</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">setenforce</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Sets the enforcing mode</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">setsebool</code></p></td><td style="" valign="top"><p>Sets the value of a policy Boolean</p></td></tr></tbody></table></div></div></div><div class="sect3" title="System Initialization"><div class="titlepage"><div><div><h3 class="title"><a id="system_initialization"/>System Initialization</h3></div></div></div><p>As in traditional Linux systems, in Android all userspace daemons and programs are started by the <span class="emphasis"><em>init</em></span> process, the first process the kernel starts (PID=1). However, unlike other Linux-based systems, Android’s initialization scripts (<span class="emphasis"><em>init.rc</em></span> and its variants) are not interpreted by a general-purpose shell, but by <span class="emphasis"><em>init</em></span> itself. Each initialization script contains built-in commands that are executed by <span class="emphasis"><em>init</em></span> as it reads the script. SEAndroid extends Android’s <span class="emphasis"><em>init</em></span> language with a number of new commands required to initialize SELinux and set the security contexts of services and files, as summarized in <a class="xref" href="ch12.html#init_built-in_commands_for_selinux_suppo" title="Table 12-2. init Built-in Commands for SELinux Support">Table 12-2</a>.</p><div class="table"><a id="init_built-in_commands_for_selinux_suppo"/><p class="title">Table 12-2. init Built-in Commands for SELinux Support</p><div class="table-contents"><table summary="init Built-in Commands for SELinux Support" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>init Built-In Command</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">seclabel</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Sets the security context of a service</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">restorecon</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Restores the security context of a file or directory</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">setcon</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Set the security context of the <span class="emphasis"><em>init</em></span> process</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">setenforce</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Sets the enforcing mode</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">setsebool</code></p></td><td style="" valign="top"><p>Sets the value of a policy Boolean</p></td></tr></tbody></table></div></div><p>When <span class="emphasis"><em>init</em></span> starts, it loads the SELinux policy from the <span class="emphasis"><em>/sepolicy</em></span> binary policy file, and then sets the enforcing mode based on the value of the <span class="emphasis"><em>ro.boot.selinux</em></span> system property (which <span class="emphasis"><em>init</em></span> sets based on the value of the <span class="emphasis"><em>androidboot.selinux</em></span> kernel command-line parameter). When the property value is <span class="emphasis"><em>permissive</em></span>, SELinux goes into permissive mode; when set to any other value or not set at all, the mode is set to enforcing.</p><p><a id="iddle2674" class="indexterm"/><a id="iddle2704" class="indexterm"/><a id="iddle2954" class="indexterm"/>Next, <span class="emphasis"><em>init</em></span> loads and parses the <span class="emphasis"><em>init.rc</em></span> file and executes the commands specified there. <a class="xref" href="ch12.html#selinux_initialization_in_initdotrc" title="Example 12-18. SELinux initialization in init.rc">Example 12-18</a> shows an excerpt of <span class="emphasis"><em>init.rc</em></span>, focusing on the parts responsible for SELinux initialization.</p><div class="example"><a id="selinux_initialization_in_initdotrc"/><p class="title">Example 12-18. SELinux initialization in <span class="roman">init.rc</span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
on early-init
    --<span class="emphasis"><em>snip</em></span>--
    setcon u:r:init:s0➊
    start ueventd
--<span class="emphasis"><em>snip</em></span>--
on post-fs-data
    chown system system /data
    chmod 0771 /data
    restorecon /data➋
--<span class="emphasis"><em>snip</em></span>--
service ueventd /sbin/ueventd
    class core
    critical
    seclabel u:r:ueventd:s0➌
--<span class="emphasis"><em>snip</em></span>--
on property:selinux.reload_policy=1➍
    restart ueventd
    restart installd
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>In this example, <span class="emphasis"><em>init</em></span> sets its own security context using the <code class="literal">setcon</code> command ➊ before starting the core system daemons. Because a child process inherits the security context of its parent, <span class="emphasis"><em>init</em></span> explicitly sets the security context of the <span class="emphasis"><em>ueventd</em></span> daemon (the first daemon to be started) to <span class="emphasis"><em>u:r:ueventd:s0</em></span> ➌ using the <code class="literal">seclabel</code> command. Most other native services have their domain set automatically by type transition rules defined in the policy (as in <a class="xref" href="ch12.html#type_transitions_in_the_wpa_domain_left" title="Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)">Example 12-10</a>). (The <code class="literal">seclabel</code> command is only used to set the security contexts of processes that start very early in the system initialization process.)</p><p>When writable filesystems are mounted, <span class="emphasis"><em>init</em></span> uses the <code class="literal">restorecon</code> command to restore the default labels of their mount points, because a factory reset could have cleared their labels. <a class="xref" href="ch12.html#selinux_initialization_in_initdotrc" title="Example 12-18. SELinux initialization in init.rc">Example 12-18</a> shows the command ➋ that labels the <span class="emphasis"><em>userdata</em></span> partition’s mount point—<span class="emphasis"><em>/data</em></span>.</p><p>Finally, because a policy reload can be triggered by setting the <span class="emphasis"><em>selinux.reload_policy</em></span> system property to 1 ➍, <span class="emphasis"><em>init</em></span> restarts the <span class="emphasis"><em>ueventd</em></span> and <span class="emphasis"><em>installd</em></span> daemons when this property is set so that the new policy can take effect.</p></div><div class="sect3" title="Labeling Files"><div class="titlepage"><div><div><h3 class="title"><a id="labeling_files"/>Labeling Files</h3></div></div></div><p>Recall that persistent SELinux objects, such as files, have a persistent security context that is typically saved in a file’s extended attribute. In Android, the initial security context of all files is defined in a text file called <span class="emphasis"><em>file_contexts</em></span>, which might look like <a class="xref" href="ch12.html#contents_of_the_fileunderscorecontexts_f" title="Example 12-19. Contents of the file_contexts file">Example 12-19</a>.</p><div class="example"><a id="contents_of_the_fileunderscorecontexts_f"/><p class="title">Example 12-19. Contents of the <span class="roman">file_contexts</span> file</p><div class="example-contents"><pre class="programlisting">/                            u:object_r:rootfs:s0➊
/adb_keys                    u:object_r:rootfs:s0
/default.prop                u:object_r:rootfs:s0
/fstab\..*                   u:object_r:rootfs:s0
--<span class="emphasis"><em>snip</em></span>--
/dev(/.*)?                   u:object_r:device:s0➋
/dev/akm8973.*               u:object_r:akm_device:s0
/dev/accelerometer           u:object_r:accelerometer_device:s0
--<span class="emphasis"><em>snip</em></span>--
/system(/.*)?                u:object_r:system_file:s0➌
/system/bin/ash              u:object_r:shell_exec:s0
/system/bin/mksh             u:object_r:shell_exec:s0
--<span class="emphasis"><em>snip</em></span>--
/data(/.*)?                  u:object_r:system_data_file:s0➍
/data/backup(/.*)?           u:object_r:backup_data_file:s0
/data/secure/backup(/.*)?    u:object_r:backup_data_file:s0
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle2607" class="indexterm"/><a id="iddle2705" class="indexterm"/>As you can see, the file contains a list of paths (sometimes using wildcard characters) and their associated security contexts, each on a new line. The <span class="emphasis"><em>file_contexts</em></span> file is consulted at various times during Android’s build and bootup process. For example, because on-memory filesystems such as Android’s root filesystem (mounted at <span class="emphasis"><em>/</em></span>) and the device filesystem (mounted at <span class="emphasis"><em>/dev</em></span>) are not persistent, all files are usually associated with the same security context as specified in the <span class="emphasis"><em>genfs_contexts</em></span> file, or assigned using the <code class="literal">context=</code> mount option. In order to assign individual security contexts to specific files in such filesystems, <span class="emphasis"><em>init</em></span> uses the <code class="literal">restorecon</code> command to look up the security context of each file in <span class="emphasis"><em>file_contexts</em></span> (➊ for the root file-system, and ➋ as the default for the device filesystem) and sets it accordingly. When building Android from source, the <code class="literal">make_ext4fs</code> command also consults <span class="emphasis"><em>file_contexts</em></span> in order to set the initial contexts of files on the <span class="emphasis"><em>system</em></span> (mounted at <span class="emphasis"><em>/system</em></span> ➌) and <span class="emphasis"><em>userdata</em></span> partition (mounted at <span class="emphasis"><em>/data</em></span> ➍) images. The security contexts of data partitions’ mount points are also restored on each boot (as shown in <a class="xref" href="ch12.html#selinux_initialization_in_initdotrc" title="Example 12-18. SELinux initialization in init.rc">Example 12-18</a>) in order to make sure they’re in a consistent state. Finally, Android’s recovery OS also includes a copy of <span class="emphasis"><em>file_contexts</em></span>, which is used to set the correct labels of files created by the recovery during system updates. This guarantees that the system remains in a securely labeled stated across updates and avoids the need for full relabeling after each update.</p></div><div class="sect3" title="Labeling System Properties"><div class="titlepage"><div><div><h3 class="title"><a id="labeling_system_properties"/>Labeling System Properties</h3></div></div></div><p>Android uses global system properties that are visible to all processes for various purposes such as communicating hardware state, starting or stopping system services, triggering disk encryption, and even reloading the SELinux policy. Access to read-only system properties isn’t restricted, but because changing the values of key read-write properties alters the behavior of the system, write access to these properties is restricted and allowed only to system processes running under privileged UIDs, such as <span class="emphasis"><em>system</em></span> and <a id="iddle1505" class="indexterm"/><a id="iddle2507" class="indexterm"/><a id="iddle2703" class="indexterm"/><a id="iddle3076" class="indexterm"/><a id="iddle3163" class="indexterm"/><a id="iddle3166" class="indexterm"/><span class="emphasis"><em>radio</em></span>. SEAndroid augments this UID-based access control by adding MAC rules that regulate write access to system properties based on the domain of the process attempting property modification. In order for this to work, system properties (which are not native SELinux objects) must be associated with security contexts. This is accomplished by listing the security contexts of properties in a <span class="emphasis"><em>property_contexts</em></span> file, much the same way that <span class="emphasis"><em>file_contexts</em></span> specifies the security labels of files. The file is loaded into memory by the <span class="emphasis"><em>property_service</em></span> (part of <span class="emphasis"><em>init</em></span>), and the resulting security context lookup table is used to determine whether a process should be allowed access to a specific property based on the security contexts of both the process (subject) and the property (object). The SELinux policy defines a new <code class="literal">property_service</code> object class, with a single permission, <code class="literal">set</code>, which is used to specify access rules, as shown in <a class="xref" href="ch12.html#system_property_access_rules_in_volddott" title="Example 12-20. System property access rules in vold.te">Example 12-20</a>.</p><div class="example"><a id="system_property_access_rules_in_volddott"/><p class="title">Example 12-20. System property access rules in <span class="roman">vold.te</span></p><div class="example-contents"><pre class="programlisting">type vold, domain;
--<span class="emphasis"><em>snip</em></span>--
allow vold vold_prop:property_service set;➊
allow vold powerctl_prop:property_service set;➋
allow vold ctl_default_prop:property_service set;➌
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>In this listing, the <code class="literal">vold</code> domain is allowed to set system properties of type <code class="literal">vold_prop</code> ➊, <code class="literal">powerctl_prop</code> ➋, and <code class="literal">ctl_default_prop</code> ➌.</p><p>These types are associated with actual properties based on the property name in <span class="emphasis"><em>property_contexts</em></span>, as shown in <a class="xref" href="ch12.html#association_of_property_names_with_their" title="Example 12-21. Association of property names with their security contexts in property_contexts">Example 12-21</a>.</p><div class="example"><a id="association_of_property_names_with_their"/><p class="title">Example 12-21. Association of property names with their security contexts in <span class="roman">property_contexts</span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
vold.                     u:object_r:vold_prop:s0➊
sys.powerctl              u:object_r:powerctl_prop:s0➋
ctl.                      u:object_r:ctl_default_prop:s0➌
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>The effect of this policy is that <span class="emphasis"><em>vold</em></span> can set the values of all properties whose name starts with <code class="literal">vold.</code> ➊, <code class="literal">sys.powerctl</code> ➋, or <code class="literal">ctl.</code> ➌.</p></div><div class="sect3" title="Labeling Application Processes"><div class="titlepage"><div><div><h3 class="title"><a id="labeling_application_processes"/>Labeling Application Processes</h3></div></div></div><p>Recall from <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a> that all app processes in Android are forked from the <span class="emphasis"><em>zygote</em></span> process in order to reduce memory usage and improve application startup time. The <span class="emphasis"><em>system_server</em></span> process, which runs as the <span class="emphasis"><em>system</em></span> user and hosts most system services, is also forked from <span class="emphasis"><em>zygote</em></span>, albeit via a slightly different interface.</p><p>The <span class="emphasis"><em>zygote</em></span> process, which runs as root, is responsible for setting each app process’s DAC credentials (UID, GID, and supplementary GIDs), as well as its capabilities and resource limits. In order to support SELinux, <span class="emphasis"><em>zygote</em></span> has been extended to check the security context of its clients (implemented in the <code class="literal">ZygoteConnection</code> class) and set the security context of each <a id="iddle1997" class="indexterm"/>app process that it forks. The security context is determined according to the assignment rules specified in the <span class="emphasis"><em>seapp_contexts</em></span> configuration file, according to the app’s UID, its package name, a flag that marks the system server process, and an SELinux-specific string attribute called <code class="literal">seinfo</code>. The <span class="emphasis"><em>seapp_contexts</em></span> configuration file contains security context assignment rules (one per line) that consist of input selector attributes and output attributes. In order for a rule to be matched, all input selectors should match (logical AND). <a class="xref" href="ch12.html#contents_of_the_seappunderscorecontexts" title="Example 12-22. Contents of the seapp_contexts file">Example 12-22</a> shows the contents of the <span class="emphasis"><em>seapp_contexts</em></span> file in the reference Android SELinux policy as of version 4.4.3.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note04"/>Note</h3><p><span class="emphasis"><em>The</em></span> seapp_contexts<span class="emphasis"><em>, like all files in the reference policy, can be found in the</em></span> external/sepolicy/ <span class="emphasis"><em>directory of Android’s source tree. See the file’s comments for the full list of input selectors, the selector matching precedence rules, and outputs.</em></span></p></div><div class="example"><a id="contents_of_the_seappunderscorecontexts"/><p class="title">Example 12-22. Contents of the <span class="roman">seapp_contexts</span> file</p><div class="example-contents"><pre class="programlisting">isSystemServer=true domain=system➊
user=system domain=system_app type=system_data_file➋
user=bluetooth domain=bluetooth type=bluetooth_data_file
user=nfc domain=nfc type=nfc_data_file
user=radio domain=radio type=radio_data_file
user=_app domain=untrusted_app type=app_data_file levelFrom=none➌
user=_app seinfo=platform domain=platform_app type=platform_app_data_file➍
user=_app seinfo=shared domain=shared_app type=platform_app_data_file➎
user=_app seinfo=media domain=media_app type=platform_app_data_file
user=_app seinfo=release domain=release_app type=platform_app_data_file
user=_isolated domain=isolated_app➏
user=shell domain=shell type=shell_data_file</pre></div></div><p>The first line ➊ in this listing specifies the domain of the system server (<code class="literal">system</code>), because the <code class="literal">isSystemServer</code> selector (which can be used only once) is set to <code class="literal">true</code>. Because Android uses a fixed SELinux user identifier, role and security level, the resulting security context becomes <span class="emphasis"><em>u:r:system:s0</em></span>.</p><p>The second assignment rule ➋ matches the <code class="literal">user</code> selector against the target process’s username, which is derived from its UID. If a process runs as one of the built-in Android Linux users (<span class="emphasis"><em>system</em></span>, <span class="emphasis"><em>radio</em></span>, <span class="emphasis"><em>nfc</em></span>, and so on, as defined in <span class="emphasis"><em>android_filesystem_config.h</em></span>), the associated name is used when matching the <code class="literal">user</code> selector. Isolated services are given the <span class="emphasis"><em>_isolated</em></span> user-name string, and any other process is given the <span class="emphasis"><em>_app</em></span> username string. Thus, system apps that match this selector are assigned the <code class="literal">system_app</code> domain.</p><p>The <code class="literal">type</code> attribute specifies the object type that’s assigned to files owned by the target process. Because in this case the type is <code class="literal">system_data_file</code>, the security context of system files becomes <span class="emphasis"><em>u:object_r:system_data_file:s0</em></span>.</p><p>Rule ➌ matches all apps that execute under a non-system UID and assigns their processes to the <code class="literal">untrusted_app</code> domain. The private app data directory of each untrusted app is recursively assigned the <code class="literal">app_data_file</code> object type, which results in the <span class="emphasis"><em>u:object_r:app_data_file:s0</em></span> security context. The security context of the data directory is set by the <span class="emphasis"><em>installd</em></span> daemon when it creates it as part of the app install process (see <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>).</p><p><a id="iddle2212" class="indexterm"/><a id="iddle2219" class="indexterm"/><a id="iddle2725" class="indexterm"/>Rules ➍ and ➎ use the <code class="literal">seinfo</code> selector to differentiate between non-system apps and assign them to different domains: apps processes that match <code class="literal">seinfo=platform</code> are assigned the <code class="literal">platform_app</code> domain, and those matching <code class="literal">seinfo=shared</code> are assigned the <code class="literal">shared_app</code> domain. (As we’ll see in the next section, an app’s <code class="literal">seinfo</code> attribute is determined by its signing certificate, so in effect, rules ➍ and ➎ use each app’s signing certificate as a process domain selector.)</p><p>Finally, rule ➏ assigns the <code class="literal">isolated_app</code> domain to all isolated services. (Isolated services run under a UID separate from their hosting app’s UID and cannot access any system services.)</p></div><div class="sect3" title="Middleware MAC"><div class="titlepage"><div><div><h3 class="title"><a id="middleware_mac"/>Middleware MAC</h3></div></div></div><p>The <code class="literal">seinfo</code> attribute introduced in the previous section is part of an SEAndroid feature called <span class="emphasis"><em>middleware MAC (MMAC)</em></span>, which is a higher-level access control scheme, separate from the kernel-level MAC (implemented in the SELinux LSM module).</p><p>The MMAC was designed to provide MAC restrictions over Android’s permission model, which works at the framework level and cannot be easily mapped to the default kernel-level MAC. The original implementation includes an install-time MAC feature, which restricts the permissions that can be granted to each package based on its package name and signing certificate, regardless of a user’s permission grant decision. That is, even if a user decides to grant an app all the permissions it requests, the install can still be blocked by the MMAC if the policy doesn’t allow certain permissions to be granted.</p><p>SEAndroid’s MMAC implementation also includes an intent MMAC feature that uses a policy to control which intents can be exchanged between applications. Another SEAndroid feature is the content provider MMAC, which defines a policy for content provider data access. However, the original SEAndroid MMAC implementation has been merged in mainline Android only partially, and the only supported feature is <code class="literal">seinfo</code> assignment based on the app signing certificate.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note05"/>Note</h3><p><span class="emphasis"><em>As of version 4.3, Android has an experimental</em></span> intent firewall <span class="emphasis"><em>feature that restricts what intents can be sent and received using “firewall”-style rules. This feature is similar to SEAndroid’s intent MMAC but is not integrated with the SELinux implementation.</em></span></p></div><p>The MMAC configuration file is called <span class="emphasis"><em>mac_permission.xml</em></span> and resides in the <span class="emphasis"><em>/system/etc/security/</em></span> directory on the device. <a class="xref" href="ch12.html#template_for_the_macunderscorepermission" title="Example 12-23. Template for the mac_permission.xml file">Example 12-23</a> shows the template used to generate this file, typically stored as <span class="emphasis"><em>external/sepolicy/ mac_permission.xml</em></span> in Android’s source tree.</p><div class="example"><a id="template_for_the_macunderscorepermission"/><p class="title">Example 12-23. Template for the <span class="roman">mac_permission.xml</span> file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;policy&gt;

    &lt;!-- Platform dev key in AOSP --&gt;
    &lt;signer signature="@PLATFORM" &gt;➊
      &lt;seinfo value="platform" /&gt;
    &lt;/signer&gt;

    &lt;!-- Media dev key in AOSP --&gt;
    &lt;signer signature="@MEDIA" &gt;➋
      &lt;seinfo value="media" /&gt;
    &lt;/signer&gt;

    &lt;!-- shared dev key in AOSP --&gt;
    &lt;signer signature="@SHARED" &gt;➌
      &lt;seinfo value="shared" /&gt;
    &lt;/signer&gt;

    &lt;!-- release dev key in AOSP --&gt;
    &lt;signer signature="@RELEASE" &gt;➍
      &lt;seinfo value="release" /&gt;
    &lt;/signer&gt;

    &lt;!-- All other keys --&gt;
    &lt;default&gt;➎
      &lt;seinfo value="default" /&gt;
    &lt;/default&gt;

&lt;/policy&gt;</pre></div></div><p><a id="iddle2200" class="indexterm"/><a id="iddle2405" class="indexterm"/><a id="iddle2497" class="indexterm"/><a id="iddle2591" class="indexterm"/><a id="iddle2742" class="indexterm"/><a id="iddle2813" class="indexterm"/>Here, the <span class="emphasis"><em>@PLATFORM</em></span> ➊, <span class="emphasis"><em>@MEDIA</em></span> ➋, <span class="emphasis"><em>@SHARED</em></span> ➌, and <span class="emphasis"><em>@RELEASE</em></span> ➍ macros represent the four platform signing certificates used in Android (<span class="emphasis"><em>platform</em></span>, <span class="emphasis"><em>media</em></span>, <span class="emphasis"><em>shared</em></span>, and <span class="emphasis"><em>release</em></span>) and are replaced with their respective certificates, encoded as hexadecimal strings, when building the SELinux policy.</p><p>When scanning each installed package, the system <code class="literal">PackageManagerService</code> matches its signing certificate against the contents of the <span class="emphasis"><em>mac_permission.xml</em></span> file and assigns the specified <code class="literal">seinfo</code> value to the package if it finds a match. If no match is found, it assigns the <span class="emphasis"><em>default</em></span> <code class="literal">seinfo</code> value as specified by the <code class="literal">&lt;default&gt;</code> tag ➎.</p></div></div><div class="sect2" title="Device Policy Files"><div class="titlepage"><div><div><h2 class="title"><a id="device_policy_files"/>Device Policy Files</h2></div></div></div><p>Android’s SELinux policy consists of a binary policy file and four supporting configuration files, which are used for process, app, system property, and file labeling, as well as for MMAC initialization. <a class="xref" href="ch12.html#android_selinux_policy_files" title="Table 12-3. Android SELinux Policy Files">Table 12-3</a> shows where each of these files is located on a device and provides a brief description of the file’s purpose and contents.</p><div class="table"><a id="android_selinux_policy_files"/><p class="title">Table 12-3. Android SELinux Policy Files</p><div class="table-contents"><table summary="Android SELinux Policy Files" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1240" class="indexterm"/><a id="iddle2733" class="indexterm"/><a id="iddle2744" class="indexterm"/>Policy File</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>/sepolicy</em></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Binary kernel policy</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>/file_contexts</em></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>File security contexts, used for labeling filesystems</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>/property_contexts</em></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>System property security contexts</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>/seapp_contexts</em></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Used to derive security contexts of app processes and files</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>/system/etc/security/mac_permissions.xml</em></span></p></td><td style="" valign="top"><p>Maps app signing certificates to <code class="literal">seinfo</code> values</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="ch12note06"/>Note</h3><p><span class="emphasis"><em>SELinux-enabled Android releases before version 4.4.3 supported overriding the default policy files shown in <a class="xref" href="ch12.html#android_selinux_policy_files" title="Table 12-3. Android SELinux Policy Files">Table 12-3</a> with their counterparts stored in the</em></span> /data/ security/current/ <span class="emphasis"><em>and</em></span> /data/system/ <span class="emphasis"><em>(for the MMAC configuration file) directories in order to enable online policy updates without a full OTA update. However, Android 4.4.3 removed this feature because it could create discrepancies between the security labels set on the filesystem and the labels referenced from the new policy. Policy files are now loaded only from the default, read-only locations shown in <a class="xref" href="ch12.html#android_selinux_policy_files" title="Table 12-3. Android SELinux Policy Files">Table 12-3</a>.</em></span></p></div></div><div class="sect2" title="Policy Event Logging"><div class="titlepage"><div><div><h2 class="title"><a id="policy_event_logging"/>Policy Event Logging</h2></div></div></div><p>Access denial and access grants that have matching <code class="literal">auditallow</code> rules are logged to the kernel log buffer and can be viewed using <code class="literal">dmesg</code>, as shown in <a class="xref" href="ch12.html#selinux_access_denials_logged_in_the_ker" title="Example 12-24. SELinux access denials logged in the kernel log buffer">Example 12-24</a>.</p><div class="example"><a id="selinux_access_denials_logged_in_the_ker"/><p class="title">Example 12-24. SELinux access denials logged in the kernel log buffer</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>dmesg |grep 'avc:'</strong></span>
--<span class="emphasis"><em>snip</em></span>--
&lt;5&gt;[18743.725707] type=1400 audit(1402061801.158:256): avc: denied { getattr
} for pid=9574 comm="zygote" path="socket:[8692]" dev="sockfs" ino=8692
scontext=u:r:untrusted_app:s0 tcontext=u:r:zygote:s0 tclass=unix_stream_socket
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Here, the audit log shows that a third-party application (source security context <span class="emphasis"><em>u:r:untrusted_app:s0</em></span>) was denied access to the <span class="emphasis"><em>getattr</em></span> permission on the <span class="emphasis"><em>zygote</em></span> Unix domain socket (target context <span class="emphasis"><em>u:r:zygote:s0</em></span>, object class <code class="literal">unix_stream_socket</code>).</p></div></div><div class="sect1" title="Android 4.4 SELinux Policy"><div class="titlepage"><div><div><h1 class="title"><a id="android_4dot4_selinux_policy"/>Android 4.4 SELinux Policy</h1></div></div></div><p>Android 4.2 was the first release to contain SELinux code, but SELinux was disabled at compile time in release builds. Android 4.3 enabled SELinux in all builds, but its default mode was set to permissive. Additionally, all domains were also individually set to permissive and were based on the <code class="literal">unconfined</code> domain, essentially allowing them full access (within the confines of DAC), even if the global SELinux mode was set to enforcing.</p><p><a id="iddle2719" class="indexterm"/><a id="iddle2722" class="indexterm"/><a id="iddle2736" class="indexterm"/><a id="iddle2766" class="indexterm"/><a id="iddle2918" class="indexterm"/><a id="iddle2948" class="indexterm"/>Android 4.4 was the first version to ship with SELinux in enforcing mode, and it included enforcing domains for core system daemons. This section gives an overview of Android’s SELinux policy, as deployed in version 4.4, and introduces some of the major domains that make up the policy.</p><div class="sect2" title="Policy Overview"><div class="titlepage"><div><div><h2 class="title"><a id="policy_overview"/>Policy Overview</h2></div></div></div><p>The source code of Android’s base SELinux policy is hosted in the <span class="emphasis"><em>external/ sepolicy/</em></span> directory of the Android source tree. Besides the files introduced in this chapter so far (<span class="emphasis"><em>access_vectors</em></span>, <span class="emphasis"><em>file_contexts</em></span>, <span class="emphasis"><em>mac_permissions.xml</em></span>, and so on), the policy source consists mostly of type enforcement (TE) statements and rules split into multiple <span class="emphasis"><em>.te</em></span> files, typically one for each defined domain. These files are combined to produce the binary policy file <span class="emphasis"><em>sepolicy</em></span>, which is included in the root of the boot image as <span class="emphasis"><em>/sepolicy</em></span>.</p><p>You can examine the binary policy file using standard SELinux tools such as <code class="literal">seinfo</code>, <code class="literal">sesearch</code>, <code class="literal">sedispol</code>, and so on. For example, we can use the <code class="literal">seinfo</code> command to get a summary of the number of policy objects and rules, as shown in <a class="xref" href="ch12.html#querying_a_binary_policy_file_using_the" title="Example 12-25. Querying a binary policy file using the seinfo command">Example 12-25</a>.</p><div class="example"><a id="querying_a_binary_policy_file_using_the"/><p class="title">Example 12-25. Querying a binary policy file using the <code class="literal">seinfo</code> command</p><div class="example-contents"><pre class="programlisting">$<span class="strong"><strong>seinfo sepolicy</strong></span>

Statistics for policy file: sepolicy
Policy Version &amp; Type: v.26 (binary, mls)

   Classes:                84    Permissions:     249
   Sensitivities:           1    Categories:     1024
   Types:                 267    Attributes:       21
   Users:                   1    Roles:             2
   Booleans:                1    Cond. Expr.:       1
   Allow:                1140    Neverallow:        0
   Auditallow:              0    Dontaudit:        36
   Type_trans:            132    Type_change:       0
   Type_member:             0    Role allow:        0
   Role_trans:              0    Range_trans:       0
   Constraints:            63    Validatetrans:     0
   Initial SIDs:           27    Fs_use:           14
   Genfscon:               10    Portcon:           0
   Netifcon:                0    Nodecon:           0
   Permissives:            42    Polcap:            2</pre></div></div><p>As you can see, the policy is fairly complex: it defines 84 classes, 267 types, and 1,140 allow rules.</p><p>You can get additional information about policy objects by specifying filtering options to the <code class="literal">seinfo</code> command. For example, because all domains are associated with the <code class="literal">domain</code> attribute, the command shown in <a class="xref" href="ch12.html#getting_a_list_of_all_defined_domains_us" title="Example 12-26. Getting a list of all defined domains using the seinfo command">Example 12-26</a> lists all domains defined in the policy.</p><div class="example"><a id="getting_a_list_of_all_defined_domains_us"/><p class="title">Example 12-26. Getting a list of all defined domains using the <code class="literal">seinfo</code> command</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>seinfo -adomain -x sepolicy</strong></span>
   domain
      nfc
      platform_app
      media_app
      clatd
      netd
      sdcardd
      zygote
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle1961" class="indexterm"/><a id="iddle2272" class="indexterm"/><a id="iddle2735" class="indexterm"/><a id="iddle2767" class="indexterm"/><a id="iddle3075" class="indexterm"/><a id="iddle3167" class="indexterm"/>You can search for policy rules using the <code class="literal">sesearch</code> command. For example, all <code class="literal">allow</code> rules that have the <code class="literal">zygote</code> domain as their source can be displayed using the command shown in <a class="xref" href="ch12.html#searching_for_policy_rules_using_the_ses" title="Example 12-27. Searching for policy rules using the sesearch commands">Example 12-27</a>.</p><div class="example"><a id="searching_for_policy_rules_using_the_ses"/><p class="title">Example 12-27. Searching for policy rules using the <code class="literal">sesearch</code> commands</p><div class="example-contents"><pre class="programlisting">$<span class="strong"><strong>sesearch --allow -s zygote -d sepolicy</strong></span>
Found 40 semantic av rules:
   allow zygote zygote_exec : file { read execute execute_no_trans entrypoint open } ;
   allow zygote init : process sigchld ;
   allow zygote rootfs : file { ioctl read getattr lock open } ;
   allow zygote rootfs : dir { ioctl read getattr mounton search open } ;
   allow zygote tmpfs : filesystem mount ;
   allow zygote tmpfs : dir { write create setattr mounton add_name search } ;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><div class="note" title="Note"><h3 class="title"><a id="ch12note07"/>Note</h3><p><span class="emphasis"><em>For details about building and customizing the SELinux policy, see the</em></span> Validating Security-Enhanced Linux in Android <span class="emphasis"><em>document.</em></span><sup>[<a id="ch12fn05" href="#ftn.ch12fn05" class="footnote">136</a>]</sup></p></div></div><div class="sect2" title="Enforcing Domains"><div class="titlepage"><div><div><h2 class="title"><a id="enforcing_domains"/>Enforcing Domains</h2></div></div></div><p>Even though SELinux is deployed in enforcing mode in Android 4.4, only the domains assigned to a few core daemons are currently enforcing, namely: <span class="emphasis"><em>installd</em></span> (responsible for creating application data directories), <span class="emphasis"><em>netd</em></span> (responsible for managing network connections and routes), <span class="emphasis"><em>vold</em></span> (responsible for mounting external storage and secure containers), and <span class="emphasis"><em>zygote</em></span>. All of these daemons run as root or are granted special capabilities because they need to perform administrative operations such as changing directory ownership (<span class="emphasis"><em>installd</em></span>), manipulating packet filtering and routing rules (<span class="emphasis"><em>netd</em></span>), mounting filesystems (<span class="emphasis"><em>vold</em></span>), and changing process credentials (<span class="emphasis"><em>zygote</em></span>) on behalf of other processes.</p><p>Because they have elevated privileges, these daemons have been the target of various privilege escalation exploits, which have allowed non-privileged processes to obtain root access on a device. Therefore, <a id="iddle2590" class="indexterm"/>specifying a restrictive MAC policy for the domains associated with these system daemons is an important step towards strengthening Android’s sandboxing security model and preventing similar exploits in the future.</p><p>Let’s look at the type enforcement rules defined for the <code class="literal">installd</code> domain (in <span class="emphasis"><em>instald.te</em></span>) to see how SELinux restricts what system daemons can access (see <a class="xref" href="ch12.html#installd_type_enforcement_policy_left_pa" title="Example 12-28. installd type enforcement policy (from installd.te)">Example 12-28</a>).</p><div class="example"><a id="installd_type_enforcement_policy_left_pa"/><p class="title">Example 12-28. <span class="roman">installd</span> type enforcement policy (from <span class="roman">installd.te</span>)</p><div class="example-contents"><pre class="programlisting">type installd, domain;
type installd_exec, exec_type, file_type;

init_daemon_domain(installd)➊
relabelto_domain(installd)➋
typeattribute installd mlstrustedsubject;➌
allow installd self:capability { chown dac_override fowner fsetid setgid setuid };➍
--<span class="emphasis"><em>snip</em></span>--
allow installd dalvikcache_data_file:file create_file_perms;➎
allow installd data_file_type:dir create_dir_perms;➏
allow installd data_file_type:dir { relabelfrom relabelto };➐
allow installd data_file_type:{ file_class_set } { getattr unlink };➑
allow installd apk_data_file:file r_file_perms;➒
--<span class="emphasis"><em>snip</em></span>--
allow installd system_file:file x_file_perms;➓
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>In this listing, the <span class="emphasis"><em>installd</em></span> daemon is first automatically transitioned to a dedicated domain (also named <code class="literal">installd</code>) when started ➊ using the <code class="literal">init_daemon_domain()</code> macro. It is then granted the <code class="literal">relabelto</code> permission so that it can set the security labels of the files and directories it creates ➋. Next, the domain is associated with the <code class="literal">mlstrustedsubject</code> attribute ➌, which allows it to bypass MLS access rules. Because <span class="emphasis"><em>installd</em></span> needs to set the owner of the files and directories it creates to that of their owner application, it’s granted the <code class="literal">chown</code>, <code class="literal">dac_override</code>, and other capabilities pertaining to file ownership ➍.</p><p>As part of the app install process, <span class="emphasis"><em>installd</em></span> also triggers the DEX optimization process, which creates ODEX files in the <span class="emphasis"><em>/data/dalvik-cache/</em></span> directory (security context <span class="emphasis"><em>u:object_r:dalvikcache_data_file:s0</em></span>), which is why the installer daemon is granted permission to create files in that directory ➎. Next, because <span class="emphasis"><em>installd</em></span> creates private data directories for applications in the <span class="emphasis"><em>/data/</em></span> directory, it is given permission to create and relabel directories (➏ and ➐), as well as get the attributes and delete files ➑ under <span class="emphasis"><em>/data/</em></span> (which is associated with the <code class="literal">data_file_type</code> attribute). Because <span class="emphasis"><em>installd</em></span> also needs to read downloaded APK files in order to perform DEX optimization, it’s granted access to APK files stored under <span class="emphasis"><em>/data/app/</em></span> ➒, a directory associated with the <code class="literal">apk_data_file</code> type (security context <span class="emphasis"><em>u:object_r:apk_data_file:s0</em></span>).</p><p>Finally, <span class="emphasis"><em>installd</em></span> is allowed to execute system commands (security context <span class="emphasis"><em>u:object_r:system_file:s0</em></span>) ➓ in order to start the DEX optimization process. <a class="xref" href="ch12.html#installd_type_enforcement_policy_left_pa" title="Example 12-28. installd type enforcement policy (from installd.te)">Example 12-28</a> omits a few of them, but the remaining policy rules follow the <a id="iddle1148" class="indexterm"/><a id="iddle1157" class="indexterm"/><a id="iddle2737" class="indexterm"/><a id="iddle2970" class="indexterm"/>same principle: allow <span class="emphasis"><em>installd</em></span> the least amount of privileges it needs to complete package installation. As a result, even if the daemon is compromised and a malicious program is executed under <span class="emphasis"><em>installd</em></span>’s privileges, it would only have access to a limited number of files and directories, and would be denied any permissions not explicitly allowed by the MAC policy.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note08"/>Note</h3><p><span class="emphasis"><em>While Android 4.4 has only four enforcing domains, as the platform evolves and the base SELinux policy is refined, eventually all domains are likely to be deployed in enforcing mode. For example, as of this writing, in the base policy in the master branch of the Android Open Source Project (AOSP), all domains are set to enforcing mode in release builds and the permissive domains are only used in development builds.</em></span></p></div><p>Even if a domain is in enforcing mode, it can be allowed effectively unrestricted access if it’s derived from a base domain that is granted all or most access permissions. In Android’s SELinux policy, such a domain is the <code class="literal">unconfineddomain</code> domain, which we discuss next.</p></div><div class="sect2" title="Unconfined Domains"><div class="titlepage"><div><div><h2 class="title"><a id="unconfined_domains"/>Unconfined Domains</h2></div></div></div><p>Android’s SELinux policy contains a base (also referred to as template) domain called <code class="literal">unconfineddomain</code>, which is allowed almost all system privileges and is used as a parent for other policy domains. As of Android 4.4, the <code class="literal">unconfineddomain</code> is defined as shown in <a class="xref" href="ch12.html#unconfineddomain_domain_definition_in_an" title="Example 12-29. unconfineddomain domain definition in Android 4.4">Example 12-29</a>.</p><div class="example"><a id="unconfineddomain_domain_definition_in_an"/><p class="title">Example 12-29. <code class="literal">unconfineddomain</code> domain definition in Android 4.4</p><div class="example-contents"><pre class="programlisting">allow unconfineddomain self:capability_class_set *;➊
allow unconfineddomain kernel:security ~load_policy;➋
allow unconfineddomain kernel:system *;
allow unconfineddomain self:memprotect *;
allow unconfineddomain domain:process *;➌
allow unconfineddomain domain:fd *;
allow unconfineddomain domain:dir r_dir_perms;
allow unconfineddomain domain:lnk_file r_file_perms;
allow unconfineddomain domain:{ fifo_file file } rw_file_perms;
allow unconfineddomain domain:socket_class_set *;
allow unconfineddomain domain:ipc_class_set *;
allow unconfineddomain domain:key *;
allow unconfineddomain fs_type:filesystem *;
allow unconfineddomain {fs_type dev_type file_type}:{ dir blk_file lnk_file sock_file fifo_file
} ~relabelto;
allow unconfineddomain {fs_type dev_type file_type}:{ chr_file file } ~{entrypoint relabelto};
allow unconfineddomain node_type:node *;
allow unconfineddomain node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
allow unconfineddomain netif_type:netif *;
allow unconfineddomain port_type:socket_class_set name_bind;
allow unconfineddomain port_type:{ tcp_socket dccp_socket } name_connect;
allow unconfineddomain domain:peer recv;
allow unconfineddomain domain:binder { call transfer set_context_mgr };
allow unconfineddomain property_type:property_service set;</pre></div></div><p><a id="iddle1165" class="indexterm"/><a id="iddle1166" class="indexterm"/><a id="iddle2734" class="indexterm"/><a id="iddle2885" class="indexterm"/><a id="iddle3168" class="indexterm"/>As you can see, the <code class="literal">unconfineddomain</code> domain is allowed all kernel capabilities ➊, full access to the SELinux security server ➋ (except for loading the MAC policy), all process-related permissions ➌, and so on. Other domains “inherit” the permissions of this domain via the <code class="literal">unconfined_domain()</code> macro, which assigns the <code class="literal">unconfineddomain</code> attribute to the domain passed as an argument. In Android 4.4’s SELinux policy, all permissive domains are also unconfined, and thus are granted practically unrestricted access (within the limits of the DAC).</p><div class="note" title="Note"><h3 class="title"><a id="ch12note09"/>Note</h3><p><span class="emphasis"><em>While the <code class="literal">unconfineddomain</code> still exists in AOSP’s master branch, it has been considerably restricted and is no longer used as an unrestricted domain, but as the base policy for system daemons and other privileged Android components. As more domains are switched to enforcing mode and their policies are fine-tuned, <code class="literal">unconfineddomain</code> is expected to be removed.</em></span></p></div></div><div class="sect2" title="App Domains"><div class="titlepage"><div><div><h2 class="title"><a id="app_domains"/>App Domains</h2></div></div></div><p>Recall that SEAndroid assigns several different domains to application processes based on their process UID or signing certificate. These application domains are assigned common permissions by inheriting the base <code class="literal">appdomain</code> using the <code class="literal">app_domain()</code> macro which, as defined in <span class="emphasis"><em>app.te</em></span>, includes rules that allow the common operations all Android apps require. <a class="xref" href="ch12.html#appdomain_policy_excerpt_left_parenthesi" title="Example 12-30. appdomain policy excerpt (from app.te)">Example 12-30</a> shows an excerpt from the <span class="emphasis"><em>app.te</em></span> file.</p><div class="example"><a id="appdomain_policy_excerpt_left_parenthesi"/><p class="title">Example 12-30. <code class="literal">appdomain</code> policy excerpt (from app.te)</p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
allow appdomain zygote:fd use;➊
allow appdomain zygote_tmpfs:file read;➋
--<span class="emphasis"><em>snip</em></span>--
allow appdomain system:fifo_file rw_file_perms;
allow appdomain system:unix_stream_socket { read write setopt };
binder_call(appdomain, system)➌

allow appdomain surfaceflinger:unix_stream_socket { read write setopt };
binder_call(appdomain, surfaceflinger)➍

allow appdomain app_data_file:dir create_dir_perms;
allow appdomain app_data_file:notdevfile_class_set create_file_perms;➎
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>This policy allows the <code class="literal">appdomain</code> to receive and use file descriptors from <span class="emphasis"><em>zygote</em></span> ➊; read system properties managed by <span class="emphasis"><em>zygote</em></span> ➋; communicate with the <span class="emphasis"><em>system_server</em></span> via pipes, local sockets, or Binder ➌; communicate with the <span class="emphasis"><em>surfaceflinger</em></span> daemon (responsible for drawing on screen) ➍; and create files and directories in its sandbox data directory ➎. The rest of the policy defines rules that allow other required permissions, such as network access, access to downloaded files, and Binder access to core system services. Operations <a id="iddle2980" class="indexterm"/>that apps do not typically require, such as raw block device access, kernel memory access, and SELinux domain transitions, are explicitly prohibited using <code class="literal">neverallow</code> rules.</p><p>Concrete app domains such as <code class="literal">untrusted_app</code> (which is assigned to all non-system applications according to the assignment rules in <span class="emphasis"><em>seapp_contexts</em></span> shown in <a class="xref" href="ch12.html#contents_of_the_seappunderscorecontexts" title="Example 12-22. Contents of the seapp_contexts file">Example 12-22</a>) extend <code class="literal">appdomain</code> and add additional access rules, as required by the target application(s). <a class="xref" href="ch12.html#untrustedunderscoreapp_domain_policy_exc" title="Example 12-31. untrusted_app domain policy excerpt (from untrusted_app.te)">Example 12-31</a> shows an excerpt from <span class="emphasis"><em>untrusted_app.te</em></span>.</p><div class="example"><a id="untrustedunderscoreapp_domain_policy_exc"/><p class="title">Example 12-31. <code class="literal">untrusted_app</code> domain policy excerpt (from <span class="roman">untrusted_app.te</span>)</p><div class="example-contents"><pre class="programlisting">type untrusted_app, domain;
permissive untrusted_app;➊
app_domain(untrusted_app)➋
net_domain(untrusted_app)➌
bluetooth_domain(untrusted_app)➍

allow untrusted_app tun_device:chr_file rw_file_perms;➎

allow untrusted_app sdcard_internal:dir create_dir_perms;
allow untrusted_app sdcard_internal:file create_file_perms;➏

allow untrusted_app sdcard_external:dir create_dir_perms;
allow untrusted_app sdcard_external:file create_file_perms;➐

allow untrusted_app asec_apk_file:dir { getattr };
allow untrusted_app asec_apk_file:file r_file_perms;➑
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>In this policy file, the <code class="literal">untrusted_app</code> domain is set to permissive mode ➊, after which it inherits the policies of <code class="literal">appdomain</code> ➋, <code class="literal">netdomain</code> ➌, and <code class="literal">bluetoothdomain</code> ➍ via the respective macros. The domain is then allowed access to tunnel devices (used for VPNs) ➎, external storage (SD cards, ➏ and ➐), and encrypted application containers ➑. The rest of the rules (not shown) grant access to sockets, pseudoterminals, and a few other needed OS resources.</p><p>All other app domains (<code class="literal">isolated_app</code>, <code class="literal">media_app</code>, <code class="literal">platform_app</code>, <code class="literal">release_app</code>, and <code class="literal">shared_app</code> in version 4.4) also inherit from <code class="literal">appdomain</code> and add additional <code class="literal">allow</code> rules, either directly or by extending additional domains. In Android 4.4, all app domains are set to permissive mode.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note10"/>Note</h3><p><span class="emphasis"><em>The SELinux policy in AOSP’s mater branch simplifies the app domain hierarchy by removing the dedicated <code class="literal">media_app</code>, <code class="literal">shared_app</code>, and <code class="literal">release_app</code> domains and merging them into the <code class="literal">untrusted_app</code> domain. Additionally, only the <code class="literal">system_app</code> domain is unconfined.</em></span></p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00030"/>Summary</h1></div></div></div><p>As of version 4.3, Android has integrated SELinux in order to reinforce the default sandbox model using the mandatory access control (MAC) available in the Linux kernel. Unlike the default discretionary access control (DAC), MAC offers a fine-grained object and permission model and a flexible security policy that cannot be overridden or changed by malicious processes (as long as the kernel itself isn’t compromised).</p><p>Android 4.4 is the first version to switch SELinux to enforcing mode in release builds, but all domains other than a few highly privileged core daemons are set to permissive mode in order to maintain compatibility with existing applications. Android’s base SELinux policy continues to be refined with each release, and future releases will likely switch most domains to enforcing mode and remove the supporting unconfined domain, which is currently inherited by the majority of domains associated with privileged services.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch12fn01" href="#ch12fn01" class="para">132</a>] </sup>Free Software Foundation, Inc., “GNU M4 - GNU Project - Free Software Foundation (FSF),” <span class="emphasis"><em><a class="ulink" href="https://www.gnu.org/software/m4/">https://www.gnu.org/software/m4/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch12fn02" href="#ch12fn02" class="para">133</a>] </sup>Richard Haines, <span class="emphasis"><em>The SELinux Notebook: The Foundations</em></span>, 3rd edition, 2012, <span class="emphasis"><em><a class="ulink" href="http://www.freetechbooks.com/efiles/selinuxnotebook/The_SELinux_Notebook_The_Foundations_3rd_Edition.pdf">http://www.freetechbooks.com/efiles/selinuxnotebook/The_SELinux_Notebook_The_Foundations_3rd_Edition.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch12fn03" href="#ch12fn03" class="para">134</a>] </sup>Security Enhancements for Android, <span class="emphasis"><em><a class="ulink" href="https://bitbucket.org/seandroid/manifests/">https://bitbucket.org/seandroid/manifests/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch12fn04" href="#ch12fn04" class="para">135</a>] </sup>Craig Smalley, <span class="emphasis"><em>Security Enhanced (SE) Android: Bringing Flexible MAC to Android</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.internetsociety.org/sites/default/files/02_4.pdf">http://www.internetsociety.org/sites/default/files/02_4.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch12fn05" href="#ch12fn05" class="para">136</a>] </sup>Google, “Validating Security-Enhanced Linux in Android,” <span class="emphasis"><em><a class="ulink" href="http://source.android.com/devices/tech/security/se-linux.html">http://source.android.com/devices/tech/security/se-linux.html</a></em></span></p></div></div></div></body></html>