- en: '**4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CROSS-SITE REQUEST FORGERY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A *cross-site request forgery (CSRF)* attack occurs when an attacker can make
    a target’s browser send an HTTP request to another website. That website then
    performs an action as though the request were valid and sent by the target. Such
    an attack typically relies on the target being previously authenticated on the
    vulnerable website where the action is submitted and occurs without the target’s
    knowledge. When a CSRF attack is successful, the attacker is able to modify server-side
    information and might even take over a user’s account. Here is a basic example,
    which we’ll walk through shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: Bob logs into his banking website to check his balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When he’s finished, Bob checks his email account on a different domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob has an email with a link to an unfamiliar website and clicks the link to
    see where it leads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When loaded, the unfamiliar site instructs Bob’s browser to make an HTTP request
    to Bob’s banking website, requesting a money transfer from his account to the
    attacker’s.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob’s banking website receives the HTTP request initiated from the unfamiliar
    (and malicious) website. But because the banking website doesn’t have any CSRF
    protections, it processes the transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Authentication**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CRSF attacks, like the one I just described, take advantage of weaknesses in
    the process websites use to authenticate requests. When you visit a website that
    requires you to log in, usually with a username and password, that site will typically
    authenticate you. The site will then store that authentication in your browser
    so you don’t have to log in every time you visit a new page on that site. It can
    store the authentication in two ways: using the basic authentication protocol
    or a cookie.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can identify a site that uses basic authorization when HTTP requests include
    a header that looks like this: `Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l`.
    The random-looking string is a base64-encoded username and password separated
    by a colon. In this case, `QWxhZGRpbjpPcGVuU2VzYW1l` decodes to `Aladdin:OpenSesame`.
    We won’t focus on basic authentication in this chapter, but you can use many of
    the techniques covered here to exploit CSRF vulnerabilities that use basic authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cookies* are small files that websites create and store in the user’s browser.
    Websites use cookies for various purposes, such as for storing information like
    user preferences or the user’s history of visiting a website. Cookies have certain
    *attributes*, which are standardized pieces of information. Those details tell
    browsers about the cookies and how to treat them. Some cookie attributes can include
    `domain`, `expires`, `max-age`, `secure`, and `httponly`, which you’ll learn about
    later in this chapter. In addition to attributes, cookies can contain a *name/value
    pair*, which consists of an identifier and an associated value that is passed
    to a website (the cookie’s `domain` attribute defines the site to pass this information
    to).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsers define the number of cookies that a site can set. But typically, single
    sites can set anywhere from 50 to 150 cookies in common browsers, and some reportedly
    support upward of 600\. Browsers generally allow sites to use a maximum of 4KB
    per cookie. There is no standard for cookie names or values: sites are free to
    choose their own name/value pairs and purposes. For example, a site could use
    a cookie named `sessionId` to remember who a user is rather than having them enter
    their username and password for every page they visit or action they perform.
    (Recall that HTTP requests are stateless, as described in [Chapter 1](ch01.xhtml#ch01).
    Stateless means that with every HTTP request, a website doesn’t know who a user
    is, so it must reauthenticate that user for every request.)'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, a name/value pair in a cookie could be `sessionId=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`
    and the cookie could have a `domain` of `.`site`.com`. Consequently, the `sessionId`
    cookie will be sent to every *.<site>.com* site a user visits, such as *foo.<site>.com*,
    *bar.<site>.com*, *www.<site>.com*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `secure` and `httponly` attributes tell browsers when and how to send and
    read cookies. These attributes don’t contain values; instead, they act as flags
    that are either present in the cookie or are not. When a cookie contains the `secure`
    attribute, browsers will only send that cookie when visiting HTTPS sites. For
    example, if you visited *http://www.<site>.com/* (an HTTP site) with a secure
    cookie, your browser wouldn’t send the cookie to that site. The reason is to protect
    your privacy, because HTTPS connections are encrypted and HTTP connections are
    not. The `httponly` attribute, which will become important when you learn about
    cross-site scripting in [Chapter 7](ch07.xhtml#ch07), tells the browser to read
    a cookie only through HTTP and HTTPS requests. Therefore, browsers won’t allow
    any scripting languages, such as JavaScript, to read that cookie’s value. When
    the `secure` and `httponly` attributes are not set in cookies, those cookies could
    be sent legitimately but read maliciously. A cookie without the `secure` attribute
    can be sent to a non-HTTPS site; likewise, a cookie without `httponly` set can
    be read by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The `expires` and `max-age` attributes indicate when a cookie should expire
    and the browser should destroy it. The `expires` attribute simply tells the browser
    to destroy a cookie on a specific date. For example, a cookie could set the attribute
    to `expires=Wed, 18 Dec 2019 12:00:00 UTC`. In contrast, the `max-age` is the
    number of seconds until the cookie expires and is formatted as an integer (`max-age=300`).
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, if the banking site Bob visits uses cookies, the site will store
    his authentication with the following process. Once Bob visits the site and logs
    in, the bank will respond to his HTTP request with an HTTP response, which includes
    a cookie that identifies Bob. In turn, Bob’s browser will automatically send that
    cookie with all other HTTP requests to the banking website.
  prefs: []
  type: TYPE_NORMAL
- en: After finishing his banking, Bob doesn’t log out when he leaves the banking
    website. Note this important detail, because when you log out of a site, that
    site will typically respond with an HTTP response that expires your cookie. As
    a result, when you revisit the site, you’ll have to log in again.
  prefs: []
  type: TYPE_NORMAL
- en: When Bob checks his email and clicks the link to visit the unknown site, he
    is inadvertently visiting a malicious website. That website is designed to perform
    a CSRF attack by instructing Bob’s browser to make a request to his banking website.
    This request will also send cookies from his browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**CSRF with GET Requests**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way the malicious site exploits Bob’s banking site depends on whether the
    bank accepts transfers via `GET` or `POST` requests. If Bob’s banking site accepts
    transfers via `GET` requests, the malicious site will send the HTTP request with
    either a hidden form or an `<img>` tag. The `GET` and `POST` methods both rely
    on HTML to make browsers send the required HTTP request, and both methods can
    use the hidden form technique, but only the `GET` method can use the `<img>` tag
    technique. In this section, we’ll look at how the attack works with the HTML `<img>`
    tag technique when using the `GET` request method, and we’ll look at the hidden
    form technique in the next section, “[CSRF with `POST` Requests](ch04.xhtml#ch04lev1sec3).”
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker needs to include Bob’s cookies in any transfer HTTP request to
    Bob’s banking website. But because the attacker has no way of reading Bob’s cookies,
    the attacker can’t just create an HTTP request and send it to the banking site.
    Instead, the attacker can use the HTML `<img>` tag to create a `GET` request that
    also includes Bob’s cookies. An `<img>` tag renders images on a web page and includes
    an `src` attribute, which tells browsers where to locate image files. When a browser
    renders an `<img>` tag, it will make an HTTP `GET` request to the `src` attribute
    in the tag and include any existing cookies in that request. So, let’s say that
    the malicious site uses a URL like the following that transfers $500 from Bob
    to Joe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the malicious `<img>` tag would use this URL as its source value, as in
    the following tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As a result, when Bob visits the attacker-owned site, it includes the `<img>`
    tag in its HTTP response, and the browser then makes the HTTP `GET` request to
    the bank. The browser sends Bob’s authentication cookies to get what it thinks
    should be an image. But in fact, the bank receives the request, processes the
    URL in the tag’s `src` attribute, and creates the transfer request.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this vulnerability, developers should never use HTTP `GET` requests
    to perform any backend data-modifying requests, such as transferring money. But
    any request that is read-only should be safe. Many common web frameworks used
    to build websites, such as Ruby on Rails, Django, and so on, will expect developers
    to follow this principle, and so they’ll automatically add CSRF protections to
    `POST` requests but not `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**CSRF with POST Requests**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the bank performs transfers with `POST` requests, you’ll need to use a different
    approach to create a CSRF attack. An attacker couldn’t use an `<img>` tag, because
    an `<img>` tag can’t invoke a `POST` request. Instead, the attacker’s strategy
    will depend on the contents of the `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest situation involves a `POST` request with the content-type `application/x-www-form-urlencoded`
    or `text/plain`. The content-type is a header that browsers might include when
    sending HTTP requests. The header tells the recipient how the body of the HTTP
    request is encoded. Here is an example of a `text/plain` content-type request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The content-type ➊ is labeled, and its type is listed along with the character
    encoding of the request. The content-type is important because browsers treat
    types differently (which I’ll get to in a second).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, it’s possible for a malicious site to create a hidden HTML
    form and submit it silently to the vulnerable site without the target’s knowledge.
    The form can submit a `POST` or `GET` request to a URL and can even submit parameter
    values. Here is an example of some harmful code in the website that the malicious
    link would direct Bob to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re making an HTTP `POST` request ➋ to Bob’s bank with a form (which
    is denoted by the action attribute in the `<form>` tag). Because the attacker
    doesn’t want Bob to see the form, each of the `<input>` elements ➌ are given the
    type `'hidden'`, which makes them invisible on the web page Bob sees. As the final
    step, the attacker includes some JavaScript inside a `<script>` tag to automatically
    submit the form when the page is loaded ➍. The JavaScript does this by calling
    the `getElementByID()` method on the HTML document with the ID of the form (`"csrf-form"`)
    that we set in the second line ➋ as an argument. As with a `GET` request, once
    the form is submitted, the browser makes the HTTP `POST` request to send Bob’s
    cookies to the bank site, which invokes a transfer. Because `POST` requests send
    an HTTP response back to the browser, the attacker hides the response in an iFrame
    using the `display:none` attribute ➊. As a result, Bob doesn’t see it and doesn’t
    realize what has happened.
  prefs: []
  type: TYPE_NORMAL
- en: In other scenarios, a site might expect the `POST` request to be submitted with
    the content-type `application/json` instead. In some cases, a request that is
    an `application/json` type will have a *CSRF token*. This token is a value that
    is submitted with the HTTP request so the legitimate site can validate that the
    request originated from itself, not from another, malicious site. Sometimes the
    HTTP body of the `POST` request includes the token, but at other times the `POST`
    request has a custom header with a name like `X-CSRF-TOKEN`. When a browser sends
    an `application/json POST` request to a site, it will send an `OPTIONS` HTTP request
    before the `POST` request. The site then returns a response to the `OPTIONS` call
    indicating which types of HTTP requests it accepts and from what trusted origins.
    This is referred to as a preflight `OPTIONS` call. The browser reads this response
    and then makes the appropriate HTTP request, which in our bank example would be
    a `POST` request for the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If implemented correctly, the preflight `OPTIONS` call protects against some
    CSRF vulnerabilities: the malicious sites won’t be listed as trusted sites by
    the server, and browsers will only allow specific websites (known as *white-listed
    websites*) to read the HTTP `OPTIONS` response. As a result, because the malicious
    site can’t read the `OPTIONS` response, browsers won’t send the malicious `POST`
    request.'
  prefs: []
  type: TYPE_NORMAL
- en: The set of rules defining when and how websites can read responses from each
    other is called *cross-origin resource sharing (CORS)*. CORS restricts resource
    access, including JSON response access, from a domain outside that which served
    the file or is allowed by the site being tested. In other words, when developers
    use CORS to protect a site, you can’t submit an `application/json` request to
    call the application being tested, read the response, and make another call unless
    the site being tested allows it. In some situations, you can bypass these protections
    by changing the `content-type` header to `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain`. Browsers don’t send preflight `OPTIONS`
    calls for any of these three content-types when making a `POST` request, so a
    CSRF request might work. If it doesn’t, look at the `Access-Control-Allow-Origin`
    header in the server’s HTTP responses to double-check that the server is not trusting
    arbitrary origins. If that response header changes when requests are sent from
    arbitrary origins, the site might have bigger problems because it allows any origin
    to read responses from its server. This allows for CSRF vulnerabilities but might
    also allow malicious attackers to read any sensitive data returned in the server’s
    HTTP responses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defenses Against CSRF Attacks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can mitigate CSRF vulnerabilities in a number of ways. One of the most
    popular forms of protection against CSRF attacks is the CSRF token. Protected
    sites require the CSRF token when requests are submitted that could potentially
    alter data (that is, `POST` requests). In such a situation, a web application
    (like Bob’s bank) would generate a token with two parts: one that Bob would receive
    and one that the application would retain. When Bob attempts to make transfer
    requests, he would have to submit his token, which the bank would then validate
    with its side of the token. The design of these tokens makes them unguessable
    and only accessible to the specific user they’re assigned to (like Bob). In addition,
    they aren’t always obviously named, but some potential examples of names include
    `X-CSRF-TOKEN`, `lia-token`, `rt`, or `form-id`. Tokens can be included in HTTP
    request headers, in an HTTP `POST` body, or as a hidden field, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the site could get the CSRF token from a cookie, an embedded
    script on the website, or as part of the content delivered from the site. Regardless
    of the method, only the target’s web browser would know and be able to read the
    value. Because the attacker couldn’t submit the token, they wouldn’t be able to
    successfully submit a `POST` request and wouldn’t be able to carry out a CSRF
    attack. However, just because a site uses CSRF tokens doesn’t mean it’s a dead
    end when you’re searching for vulnerabilities to exploit. Try removing the token,
    changing its value, and so on to confirm the token has been properly implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The other way sites protect themselves is by using CORS; however, this isn’t
    foolproof because it relies on browser security and ensuring proper CORS configurations
    to determine when third-party sites can access responses. Attackers can sometimes
    bypass CORS by changing the content-type from `application/json` to `application/x-www-form-urlencoded`
    or by using a `GET` request instead of a `POST` request because of misconfigurations
    on the server side. The reason the bypass works is that browsers will automatically
    send an `OPTIONS HTTP` request when the content type is `application/json` but
    won’t automatically send an `OPTIONS HTTP` request if it’s a `GET` request or
    the content type is `application/x-www-form-urlencoded`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, there are two additional and less common CSRF mitigation strategies.
    First, the site could check the value of the `Origin` or `Referer` header submitted
    with an HTTP request and ensure it contains the expected value. For example, in
    some cases, Twitter will check the `Origin` header and, if it’s not included,
    check the `Referer` header. This works because browsers control these headers
    and attackers can’t set or change them remotely (obviously, this excludes exploiting
    a vulnerability in browsers or browser plug-ins that might allow an attacker to
    control either header). Second, browsers are now beginning to implement support
    for a new cookie attribute called `samesite`. This attribute can be set as `strict`
    or `lax`. When set as `strict`, the browser will not send the cookie with any
    HTTP request that doesn’t originate from the site. This includes even simple HTTP
    `GET` requests. For example, if you were logged into Amazon and it used `strict
    samesite` cookies, the browser would not submit your cookies if you were following
    a link from another site. Also, Amazon would not recognize you as logged in until
    you visited another Amazon web page and the cookies were then submitted. In contrast,
    setting the `samesite` attribute as `lax` instructs browsers to send cookies with
    initial `GET` requests. This supports the design principle that `GET` requests
    should never alter data on the server side. In this case, if you were logged into
    Amazon and it used `lax samesite` cookies, the browser would submit your cookies
    and Amazon would recognize you as logged in if you had been redirected there from
    another site.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shopify Twitter Disconnect**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://www.hackerone.com/reports/111216/](https://www.hackerone.com/reports/111216/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** January 17, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re looking for potential CSRF vulnerabilities, be on the lookout for
    `GET` requests that modify server-side data. For example, a hacker discovered
    a vulnerability in a Shopify feature that integrated Twitter into the site to
    let shop owners tweet about their products. The feature also allowed users to
    disconnect a Twitter account from a connected shop. The URL to disconnect a Twitter
    account was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As it turns out, visiting this URL would send a `GET` request to disconnect
    the account, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In addition, when the link was originally implemented, Shopify wasn’t validating
    the legitimacy of the `GET` requests sent to it, making the URL vulnerable to
    CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hacker WeSecureApp, who filed the report, provided the following proof-of-concept
    HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When opened, this HTML document would cause the browser to send an HTTP `GET`
    request to *https://twitter-commerce.shopifyapps.com* through the `<img>` tag’s
    `src` attribute ➊. If someone with a Twitter account connected to Shopify visited
    a web page with this `<img>` tag, their Twitter account would be disconnected
    from Shopify.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keep an eye out for HTTP requests that perform some action on the server, such
    as disconnecting a Twitter account, via a `GET` request. As mentioned earlier,
    `GET` requests should never modify any data on the server. In this situation,
    you could have found the vulnerability by using a proxy server, such as Burp or
    OWASP’s ZAP, to monitor the HTTP requests being sent to Shopify.
  prefs: []
  type: TYPE_NORMAL
- en: '**Change Users Instacart Zones**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://admin.instacart.com/api/v2/zones/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/157993/](https://hackerone.com/reports/157993/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** August 9, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $100'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re looking at the attack surface, remember to consider a website’s
    API endpoints as well as its web pages. Instacart is a grocery delivery app that
    allows its deliverers to define the zones they work in. The site updated these
    zones with a `POST` request to the Instacart admin subdomain. A hacker discovered
    that the zone’s endpoint on this subdomain was vulnerable to CSRF. For example,
    you could modify a target’s zone with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the hacker created an HTML form to send an HTTP `POST` request
    to the `/api/v2/zones` endpoint ➊. The hacker included two hidden inputs: one
    to set the user’s new zone to the ZIP code `10001` ➋ and one to set the API’s
    `override` parameter to `true` ➌ so the user’s current `zip` value was replaced
    with the hacker’s submitted value. Additionally, the hacker included a submit
    button to make the `POST` request ➍, unlike the Shopify example, which used an
    auto-submitting JavaScript function.'
  prefs: []
  type: TYPE_NORMAL
- en: Although this example is still successful, the hacker could improve the exploit
    by using the techniques described earlier, such as using a hidden iFrame to auto-submit
    the request on the target’s behalf. This would demonstrate to the Instacart bug
    bounty triagers how an attacker could use this vulnerability with less target
    action; vulnerabilities that are entirely attacker controlled are more likely
    to be successfully exploited than those that aren’t.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re looking for exploits, broaden your attack scope and look beyond
    just a website’s pages to include its API endpoints, which offer great potential
    for vulnerabilities. Occasionally, developers forget that hackers can discover
    and exploit API endpoints, because they aren’t readily available like web pages.
    For example, mobile applications often make HTTP requests to API endpoints, which
    you can monitor with Burp or ZAP just as you do websites.
  prefs: []
  type: TYPE_NORMAL
- en: '**Badoo Full Account Takeover**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://www.badoo.com/](https://www.badoo.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/127703/](https://hackerone.com/reports/127703/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 1, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $852'
  prefs: []
  type: TYPE_NORMAL
- en: Although developers often use CSRF tokens to protect against CSRF vulnerabilities,
    in some cases, attackers can steal the tokens, as you’ll see in this bug. If you
    explore the social networking website *[https://www.badoo.com/](https://www.badoo.com/)*,
    you’ll see that it uses CSRF tokens. More specifically, it uses a URL parameter,
    `rt`, which is unique to each user. When Badoo’s bug bounty program went live
    on HackerOne, I couldn’t find a way to exploit it. However, the hacker Mahmoud
    Jamal did.
  prefs: []
  type: TYPE_NORMAL
- en: Jamal recognized the `rt` parameter and its significance. He also noticed that
    the parameter was returned in almost all JSON responses. Unfortunately, this wasn’t
    helpful because CORS protects Badoo from attackers reading those responses, since
    they’re encoded as `application/json` content types. But Jamal kept digging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jamal eventually found the JavaScript file *[https://eu1.badoo.com/worker-scope/chrome-service-worker.js](https://eu1.badoo.com/worker-scope/chrome-service-worker.js)*,
    which contained a variable called `url_stats` and was set to the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `url_stats` variable stored a URL that contained the user’s unique `rt`
    value as a parameter when the user’s browser accessed the JavaScript file ➊. Even
    better, to obtain the user’s `rt` value, an attacker would just need the target
    to visit a malicious web page that would access the JavaScript file. CORS does
    not block this because browsers are allowed to read and embed remote JavaScript
    files from external sources. The attacker could then use the `rt` value to link
    any social media account with the user’s Badoo account. As a result, the attacker
    could invoke HTTP `POST` requests to modify the target’s account. Here’s the HTML
    page Jamal used to accomplish this exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When a target loads this page, the page will load the Badoo JavaScript by referencing
    it as the `src` attribute in a `<script>` tag ➊. Having loaded the script, the
    web page then calls the JavaScript function `window.onload`, which defines an
    anonymous JavaScript function ➌. Browsers call the `onload` event handler when
    a web page loads; because the function Jamal defined is in the `window.onload`
    handler, his function will always be called when the page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Jamal created a `csrf_code` variable ➍ and assigned it the return value
    of a function he defined at ➋ called `getCSRFcode`. The `getCSRFcode` function
    takes and splits a string into an array of strings at each `''=''` character.
    It then returns the value of the third member of the array. When the function
    parses the variable `url_stats` from Badoo’s vulnerable JavaScript file at ➍,
    it splits the string into the following array value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then the function returns the third member of the array, which is the `rt` value,
    and assigns that to `csrf_code`.
  prefs: []
  type: TYPE_NORMAL
- en: Once he had the CSRF token, Jamal created the `csrf_url` variable, which stores
    a URL to Badoo’s */google/verify.phtml* web page. The web page links his own Google
    account to the target’s Badoo account ➎. This page requires some parameters, which
    are hardcoded into the URL string. I won’t cover them in detail here because they’re
    specific to Badoo. However, note the final `rt` parameter, which doesn’t have
    a hardcoded value. Instead, `csrf_code` is concatenated to the end of the URL
    string so it’s passed as the `rt` parameter’s value. Jamal then makes an HTTP
    request by invoking `window.location` ➏ and assigns it to `csrf_url`, which redirects
    the visiting user’s browser to the URL at ➎. This results in a `GET` request to
    Badoo, which validates the `rt` parameter and processes the request to link the
    target’s Badoo account to Jamal’s Google account, thereby completing the account
    takeover.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Where there’s smoke, there’s fire. Jamal noticed that the `rt` parameter was
    being returned in different locations, particularly in JSON responses. For that
    reason, he rightly guessed that `rt` might show up someplace where an attacker
    could access and exploit it, which in this case was a JavaScript file. If you
    feel like a site might be vulnerable, keep digging. In this case, I thought it
    was odd that the CSRF token would only be five digits long and included in URLs.
    Normally, tokens are much longer, making them harder to guess, and included in
    HTTP `POST` request bodies, not URLs. Use a proxy and check all the resources
    that are being called when you visit a site or application. Burp allows you to
    search through all your proxy history to look for specific terms or values, which
    would have revealed the `rt` value included in the JavaScript files here. You
    might find an information leak with sensitive data, such as a CSRF token.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSRF vulnerabilities represent another attack vector that attackers can execute
    without the target even knowing or actively performing an action. Finding CSRF
    vulnerabilities can take some ingenuity and a willingness to test all functionality
    on a site.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, application frameworks, such as Ruby on Rails, are increasingly protecting
    web forms if the site is performing `POST` requests; however, this isn’t the case
    for `GET` requests. Therefore, be sure to keep an eye out for any `GET` HTTP calls
    that change server-side user data (like disconnecting Twitter accounts). Also,
    although I didn’t include an example of it, if you see that a site is sending
    a CSRF token with a `POST` request, you can try changing the CSRF token value
    or removing it entirely to ensure the server is validating its existence.
  prefs: []
  type: TYPE_NORMAL
