- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**READING AND WRITING FILES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now I’ll cover one more fundamental aspect of working with R: loading and saving
    data in an active workspace by reading and writing files. Typically, to work with
    a large data set, you’ll need to read in the data from an external file, whether
    it’s stored as plain text, in a spreadsheet file, or on a website. R provides
    command line functions you can use to import these data sets, usually as a data
    frame object. You can also export data frames from R by writing a new file on
    your computer, plus you can save any plots you create as image files. In this
    chapter, I’ll go over some useful command-based read and write operations for
    importing and exporting data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1 R-Ready Data Sets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s take a brief look at some of the data sets that are built into
    the software or are part of user-contributed packages. These data sets are useful
    samples to practice with and to experiment with functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `data()` at the prompt to bring up a window listing these ready-to-use
    data sets along with a one-line description. These data sets are organized in
    alphabetical order by name and grouped by package (the exact list that appears
    will depend on what contributed packages have been installed from CRAN; see [Section
    A.2](app01.xhtml#app01lev1sec97)).
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.1 Built-in Data Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a number of data sets contained within the built-in, automatically
    loaded package `datasets`. To see a summary of the data sets contained in the
    package, you can use the `library` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: R-ready data sets have a corresponding help file where you can find important
    details about the data and how it’s organized. For example, one of the built-in
    data sets is named `ChickWeight`. If you enter `?ChickWeight` at the prompt, you’ll
    see the window in [Figure 8-1](ch08.xhtml#ch8fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: The help file for the* `ChickWeight` *data set*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this file explains the variables and their values; it notes
    that the data are stored in a data frame with 578 rows and 4 columns. Since the
    objects in `datasets` are built in, all you have to do to access `ChickWeight`
    is enter its name at the prompt. Let’s look at the first 15 records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can treat this data set like any other data frame you’ve created in R—note
    the use of `[1:15,]` to access the desired rows from such an object, as detailed
    in [Section 5.2.1](ch05.xhtml#ch05lev2sec52).
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.2 Contributed Data Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are many more R-ready data sets that come as part of contributed packages.
    To access them, first install and load the relevant package. Consider the data
    set `ice.river`, which is in the contributed package `tseries` by Trapletti and
    Hornik ([2013](ref.xhtml#ref67)). First, you have to install the package, which
    you can do by running the line `install.packages("tseries")` at the prompt. Then,
    to access the components of the package, load it using `library`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can enter `library(help="tseries")` to see the list of data sets in
    this package, and you can enter `?ice.river` to find more details about the data
    set you want to work with here. The help file describes `ice.river` as a “time
    series object” comprised of river flow, precipitation, and temperature measurements—data
    initially reported in Tong ([1990](ref.xhtml#ref66)). To access this object itself,
    you must explicitly load it using the `data` function. Then you can work with
    `ice.river` in your workspace as usual. Here are the first five records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The availability and convenience of these R-ready data sets make it easy to
    test code, and I’ll use them in subsequent chapters for demonstrations. To analyze
    your own data, however, you’ll often have to import them from some external file.
    Let’s see how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2 Reading in External Data Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R has a variety of functions for reading characters from stored files and making
    sense of them. You’ll look at how to read *table-format* files, which are among
    the easiest for R to read and import.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.2.1 The Table Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Table-format files are best thought of as plain-text files with three key features
    that fully define how R should read the data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Header** If a *header* is present, it’s always the first line of the file.
    This optional feature is used to provide names for each column of data. When importing
    a file into R, you need to tell the software whether a header is present so that
    it knows whether to treat the first line as variable names or, alternatively,
    observed data values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delimiter** The all-important *delimiter* is a character used to separate
    the entries in each line. The delimiter character cannot be used for anything
    else in the file. This tells R when a specific entry begins and ends (in other
    words, its exact position in the table).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Missing value** This is another unique character string used exclusively
    to denote a missing value. When reading the file, R will turn these entries into
    the form it recognizes: `NA`.'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, these files have a *.txt* extension (highlighting the plain-text
    style) or *.csv* (for *comma-separated values*).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try an example, using a variation on the data frame `mydata` as defined
    at the end of [Section 5.2.2](ch05.xhtml#ch05lev2sec53). [Figure 8-2](ch08.xhtml#ch8fig2)
    shows an appropriate table-format file called *mydatafile.txt*, which has the
    data from that data frame with a few values now marked as missing. This data file
    can be found on the book’s website at *[https://www.nostarch.com/bookofr/](https://www.nostarch.com/bookofr/)*,
    or you can create it yourself from [Figure 8-2](ch08.xhtml#ch8fig2) using a text
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: A plain-text table-format file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the first line is the header, the values are delimited with a single
    space, and missing values are denoted with an asterisk (`*`). Also, note that
    each new record is required to start on a new line. Suppose you’re handed this
    plain-text file for data analysis in R. The ready-to-use command `read.table`
    imports table-format files, producing a data frame object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In a call to `read.table`, `file` takes a character string with the filename
    and folder location (using forward slashes), `header` is a logical value telling
    R whether `file` has a header (`TRUE` in this case), `sep` takes a character string
    providing the delimiter (a single space, `" "`, in this case), and `na.strings`
    requests the characters used to denote missing values (`"*"` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re reading in multiple files and don’t want to type the entire folder
    location each time, it’s possible to first set your working directory via `setwd`
    ([Section 1.2.3](ch01.xhtml#ch01lev2sec08)) and then simply use the filename and
    its extension as the character string supplied to the `file` argument. However,
    both approaches require you to know exactly where your file is located when you’re
    working at the R prompt. Fortunately, R possesses some useful additional tools
    should you forget your file’s precise location. You can view textual output of
    the contents of any folder by using `list.files`. The following example betrays
    the messiness of my local user directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One important feature to note here, though, is that it can be difficult to distinguish
    between files and folders. Files will typically have an extension, and folders
    won’t; however, `WISE-P2L` is a file that happens to have no extension and looks
    no different from any of the listed folders.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find files interactively from R. The `file.choose` command opens
    your filesystem viewer directly from the R prompt—just as any other program does
    when you want to open something. Then, you can navigate to the folder of interest,
    and after you select your file (see [Figure 8-3](ch08.xhtml#ch8fig3)), only a
    character string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f08-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: My local file navigator opened as the result of a call to* `file.choose`*.
    When the file of interest is opened, the R command returns the full file path
    to that file as a character string.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is particularly useful, as it returns the character string of
    the directory in precisely the format that’s required for a command such as `read.table`.
    So, calling the following line and selecting *mydatafile.txt*, as in [Figure 8-3](ch08.xhtml#ch8fig3),
    will produce an identical result to the explicit use of the file path in `file`,
    shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If your file has been successfully loaded, you should be returned to the R prompt
    without receiving any error messages. You can check this with a call to `mydatafile`,
    which should return the data frame. When importing data into data frames, keep
    in mind the difference between character string observations and factor observations.
    No factor attribute information is stored in the plain-text file, but `read.table`
    will convert non-numeric values into factors by default. Here, you want to keep
    some of your data saved as strings, so set `stringsAsFactors=FALSE`, which prevents
    R from treating all non-numeric elements as factors. This way, `person`, `sex`,
    and `funny` are all stored as character strings.
  prefs: []
  type: TYPE_NORMAL
- en: You can then overwrite `sex` and `funny` with factor versions of themselves
    if you want them as that data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '***8.2.2 Spreadsheet Workbooks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s examine some ubiquitous spreadsheet software file formats. The standard
    file format for Microsoft Office Excel is *.xls* or *.xlsx*. In general, these
    files are not directly compatible with R. There are some contributed package functions
    that attempt to bridge this gap—see, for example, `gdata` by Warnes et al. ([2014](ref.xhtml#ref71))
    or `XLConnect` by Mirai Solutions GmbH ([2014](ref.xhtml#ref47))—but it’s generally
    preferable to first export the spreadsheet file to a table format, such as CSV.
    Consider the hypothetical data from [Exercise 7.1](ch07.xhtml#ch7exc1) (b), which
    has been stored in an Excel file called *spreadsheetfile.xlsx*, shown in [Figure
    8-4](ch08.xhtml#ch8fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: A spreadsheet file of the data from [Exercise 7.1](ch07.xhtml#ch7exc1)
    (b)*'
  prefs: []
  type: TYPE_NORMAL
- en: To read this spreadsheet with R, you should first convert it to a table format.
    In Excel, File → Save As... provides a wealth of options. Save the spreadsheet
    as a comma-separated file, called *spreadsheet.csv*. R has a shortcut version
    of `read.table`, `read.csv`, for these files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `file` argument again specifies the desired file, which has no header,
    so `header=FALSE`. You set `stringsAsFactors=TRUE` because you do want to treat
    the `sex` variable (the only non-numeric variable) as a factor. There are no missing
    values, so you don’t need to specify `na.strings` (though if there were, this
    argument is simply used in the same way as earlier), and by definition, *.csv*
    files are comma-delimited, which `read.csv` correctly implements by default, so
    you don’t need the `sep` argument. The resulting data frame, `spread`, can then
    be printed in your R console.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, reading tabular data into R is fairly straightforward—you just
    need to be aware of how the data file is headed and delimited and how missing
    entries are identified. The simple table format is a natural and common way for
    data sets to be stored, but if you need to read in a file with a more complicated
    structure, R and its contributed packages make available some more sophisticated
    functions. See, for example, the documentation for the `scan` and `readLines`
    functions, which provide advanced control over how to parse a file. You can also
    find documentation on `read.table` and `read.csv` by accessing `?read.table` from
    the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.2.3 Web-Based Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With an Internet connection, R can read in files from a website with the same
    `read.table` command. All the same rules concerning headers, delimiters, and missing
    values remain in place; you just have to specify the URL address of the file instead
    of a local folder location.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you’ll use the online repository of data sets made available
    by the *Journal of Statistics Education (JSE)* through the American Statistical
    Association at *[http://www.amstat.org/publications/jse/jse_data_archive.htm](http://www.amstat.org/publications/jse/jse_data_archive.htm)*.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first files linked to at the top of this page is the table-format
    data set *4cdata.txt* (*[http://www.amstat.org/publications/jse/v9n2/4cdata.txt](http://www.amstat.org/publications/jse/v9n2/4cdata.txt)*),
    which contains data on the characteristics of 308 diamonds from an analysis by
    Chu ([2001](ref.xhtml#ref13)) based on an advertisement in a Singaporean newspaper.
    [Figure 8-5](ch08.xhtml#ch8fig5) shows the data.
  prefs: []
  type: TYPE_NORMAL
- en: You can look at the documentation file (*4c.txt*) and the accompanying article
    linked from the JSE site for details on what is recorded in this table. Note that
    of the five columns, the first and fifth are numeric, and the others would be
    well represented by factors. The delimiter is blank whitespace, there’s no header,
    and there are no missing values (so you don’t have to specify a value used to
    represent them).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: A table-format data file found online*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, you can create a data frame directly from the R prompt simply
    with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you haven’t supplied any extra values in this call to `read.table`
    because the defaults all work just fine. Because there’s no header in the table,
    you can leave the default `header` value `FALSE`. The default value for `sep`
    is `""`, meaning whitespace (not to be confused with `" "`, meaning an explicit
    space character), which is exactly what this table uses. The default value for
    `stringsAsFactors` is `TRUE`, which is what you want for your character string
    columns. Following the import, you can supply names (based on the information
    in the documentation) to each column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the first five records shows that the data frame is displayed as you
    intended.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.2.4 Other File Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are other file formats besides *.txt* or *.csv* files that can be read
    into R, such as the data file format *.dat*. These files can also be imported
    using `read.table`, though they may contain extra information at the top that
    must be skipped using the optional `skip` argument. The `skip` argument asks for
    the number of lines at the top of the file that should be ignored before R begins
    the import.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Section 8.2.2](ch08.xhtml#ch08lev2sec74), there are also contributed
    packages that can cope with other statistical software files; however, if there
    are multiple worksheets within a file it can complicate things. The R package
    `foreign` ([R Core Team, 2015](ref.xhtml#ref52)), available from CRAN, provides
    support for reading data files used by statistical programs such as Stata, SAS,
    Minitab, and SPSS.
  prefs: []
  type: TYPE_NORMAL
- en: Other contributed packages on CRAN can help R handle files from various database
    management systems (DBMSs). For example, the `RODBC` package ([Ripley and Lapsley,
    2013](ref.xhtml#ref54)) lets you query Microsoft Access databases and return the
    results as a data frame object. Other interfaces include the packages `RMySQL`
    ([James and DebRoy, 2012](ref.xhtml#ref35)) and `RJDBC` ([Urbanek, 2013](ref.xhtml#ref68)).
  prefs: []
  type: TYPE_NORMAL
- en: '**8.3 Writing Out Data Files and Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing out new files from data frame objects with R is just as easy as reading
    in files. R’s vector-oriented behavior is a fast and convenient way to recode
    data sets, so it’s perfect for reading in data, restructuring it, and writing
    it back out to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.3.1 Data Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The function for writing table-format files to your computer is `write.table`.
    You supply a data frame object as `x`, and this function writes its contents to
    a new file with a specified name, delimiter, and missing value string. For example,
    the following line takes the `mydatafile` object from [Section 8.2](ch08.xhtml#ch08lev1sec28)
    and writes it to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You provide `file` with the folder location, ending in the filename you want
    for your new data file. This command creates a new table-format file called *somenewfile.txt*
    in the specified folder location, delimited by `@` and with missing values denoted
    with `??` (because you’re actually creating a new file, the `file.choose` command
    doesn’t tend to be used here). Since `mydatafile` has variable names, these are
    automatically written to the file as a header. The optional logical argument `quote`
    determines whether to encapsulate each non-numeric entry in double quotes (if
    you explicitly need them in your file for, say, formatting requirements of other
    software); request no quotes by setting the argument to `FALSE`. Another optional
    logical argument, `row.names`, asks whether to include the row names of `mydatafile`
    (in this example, this would just be the numbers `1` to `6`), which you also omit
    with `FALSE`. The resulting file, shown in [Figure 8-6](ch08.xhtml#ch8fig6), can
    be opened in a text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Like `read.csv`, `write.csv` is a shortcut version of the `write.table` function
    designed specifically for *.csv* files.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: The contents of* somenewfile.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '***8.3.2 Plots and Graphics Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Plots can also be written directly to a file. In [Chapter 7](ch07.xhtml#ch07),
    you created and displayed plots in an active graphics device. This graphics device
    needn’t be a screen window; it can be a specified file. Instead of displaying
    the plot immediately on the screen, you can have R follow these steps: open a
    “file” graphics device, run any plotting commands to create the final plot, and
    close the device. R supports direct writing to *.jpeg*, *.bmp*, *.png*, and *.tiff*
    files using functions of the same names. For example, the following code uses
    these three steps to create a *.jpeg* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The file graphics device is opened by a call to `jpeg`, where you provide the
    intended name of the file and its folder location as `filename`. By default, the
    dimensions of the device are set to 480 × 480 pixels, but here you change them
    to 600 × 600\. You could also set these dimensions by supplying other units (inches,
    centimeters, or millimeters) to `width` and `height` and by specifying the unit
    with an optional `units` argument. Once the file is opened, you execute any R
    plotting commands you need in order to create the image—this example plots some
    points and then includes some additional points with a second command. The final
    graphical result is silently written to the specified file just as it would have
    been displayed on the screen. When you’ve finished plotting, you must explicitly
    close the file device with a call to `dev.off()`, which prints information on
    the remaining active device (here, “null device” can be loosely interpreted as
    “nothing is left open”). If `dev.off()` isn’t called, then R will continue to
    output any subsequent plotting commands to the file, and possibly overwrite what
    you have there. The left plot in [Figure 8-7](ch08.xhtml#ch8fig7) shows the resulting
    file created in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: R plots that have been written directly to disk: a* .jpeg *version
    (left) and a* .pdf *version (right) of the same plotting commands*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also store R plots as other file types, such as PDFs (using the `pdf`
    function) and EPS files (using the `postscript` function). Though some argument
    names and default values are different for these functions, they follow the same
    basic premise. You specify a folder location, a filename, and width and height
    dimensions; enter your plotting commands; and then close the device with `dev.off()`.
    The right panel of [Figure 8-7](ch08.xhtml#ch8fig7) shows the *.pdf* file created
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, you use the same plotting commands as before, and there are just a few
    minor differences in the code. The argument for the file is `file` (as opposed
    to `filename`), and the units for `width` and `height` default to inches in `pdf`.
    The difference of appearance between the two images in [Figure 8-7](ch08.xhtml#ch8fig7)
    results primarily from these differences in width and height.
  prefs: []
  type: TYPE_NORMAL
- en: This same process also works for `ggplot2` images. True to style, however, `ggplot2`
    provides a convenient alternative. The `ggsave` function can be used to write
    the most recently plotted `ggplot2` graphic to file and performs the device open/close
    action in one line.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following code creates and displays a `ggplot2` object from
    a simple data set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to save this plot to a file, all you need is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This writes the image to a *.png* file in the specified `filename` directory.
    (Note that dimensions are reported if you don’t explicitly set them using `width`
    and `height`; these will vary depending on the size of your graphics device.)
    The result is shown in [Figure 8-8](ch08.xhtml#ch8fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: The* .png *file created using* `ggplot2`*’s* `ggsave` *command*'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond just being concise, `ggsave` is convenient in a few other ways. For one,
    you can use the same command to create a variety of image file types—the type
    is simply determined by the extension you supply in the `filename` argument. Also,
    `ggsave` has a range of optional arguments if you want to control the size of
    the image and the quality or scaling of the graphic.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on saving images from base R graphics, see the `?jpeg`, `?pdf`,
    and `?postscript` help files. You can consult `?ggsave` for more on saving images
    with `ggplot2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.4 Ad Hoc Object Read/Write Operations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the typical R user, the most common input/output operations will probably
    revolve around data sets and plot images. But if you need to read or write other
    kinds of R objects, such as lists or arrays, you’ll need the `dput` and `dget`
    commands, which can handle objects in a more ad hoc style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for example, you create this list in the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This object can itself be written to a file, which is useful if you want to
    pass it to a colleague or open it in a new R session elsewhere. Using `dput`,
    the following line stores the object as a plain-text file that is interpretable
    by R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In technical terms, this command creates an American Standard Code for Information
    Interchange (ASCII) representation of the object. As you call `dput`, the object
    you want to write is specified as `x`, and the folder location and name of the
    new plain-text file are passed to `file`. [Figure 8-9](ch08.xhtml#ch8fig9) shows
    the contents of the resulting file.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9:* myRobject.txt *created by using* `dput` *on* `somelist`'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `dput` stores all of the members of the object plus any other relevant
    information, such as attributes. The third element of `somelist`, for example,
    is an ordered factor, so it isn’t enough to simply represent it in the text file
    as a stand-alone vector.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s say you want to import this list into an R workspace. If a file has
    been created with `dput`, then it can be read into any other workspace using `dget`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You read the object from the *myRobject.txt* file using `dget` and assign it
    to `newobject`. This object is the same as the original R object `somelist`, with
    all structures and attributes present.
  prefs: []
  type: TYPE_NORMAL
- en: There are some drawbacks to using these commands. For starters, `dput` is not
    as reliable a command as `write.table` because it’s sometimes quite difficult
    for R to create the necessary plain-text representation for an object (fundamental
    object classes typically cause no problems, but complex user-defined classes can).
    Also, because they need to store structural information, files created using `dput`
    are relatively inefficient both in terms of required space and in terms of how
    long it takes to execute read and write operations. This becomes more noticeable
    for objects that contain a lot of data. Nevertheless, `dput` and `dget` are useful
    ways to store or transfer specific objects without having to save an entire workspace.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In R’s built-in `datasets` library is the data frame `quakes`. Make sure you
    can access this object and view the corresponding help file to get an idea of
    what this data represents. Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select only those records that correspond to a magnitude (`mag`) of greater
    than or equal to `5` and write them to a table-format file called *q5.txt* in
    an existing folder on your machine. Use a delimiting character of `!` and do not
    include any row names.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the file back into your R workspace, naming the object `q5.dframe`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the contributed package `car`, there’s a data frame called `Duncan`, which
    provides historical data on perceived job prestige in 1950\. Install the `car`
    package and access the `Duncan` data set and its help file. Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write R code that will plot `education` on the *x*-axis and `income` on the
    *y*-axis, with both *x*- and *y*-axis limits fixed to be [0,100]. Provide appropriate
    axis labels. For jobs with a `prestige` value of less than or equal to `80`, use
    a black ○ as the point character. For jobs with `prestige` greater than 80, use
    a blue •.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a legend explaining the difference between the two types of points and then
    save a 500 × 500 pixel *.png* file of the image.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a list called `exer` that contains the three data sets `quakes`, `q5.dframe`,
    and `Duncan`. Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the list object directly to disk, calling it *Exercise8-1.txt*. Briefly
    inspect the contents of the file in a text editor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Read *Exercise8-1.txt* back into your workspace; call the resulting object `list.of.dataframes`.
    Check that `list.of.dataframes` does indeed contain the three data frame objects.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Section 7.4.3](ch07.xhtml#ch07lev2sec70), you created a `ggplot2` graphic
    of 20 observations displayed as the bottom image of [Figure 7-11](ch07.xhtml#ch7fig11)
    on [page 144](ch07.xhtml#page_144). Use `ggsave` to save a copy of this plot as
    a *.tiff* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | Load contributed data set | [Section 8.1.2](ch08.xhtml#ch08lev2sec72),
    [p. 149](ch08.xhtml#page_149) |'
  prefs: []
  type: TYPE_TB
- en: '| `read.table` | Import table-format data file | [Section 8.2.1](ch08.xhtml#ch08lev2sec73),
    [p. 151](ch08.xhtml#page_151) |'
  prefs: []
  type: TYPE_TB
- en: '| `list.files` | Print specific folder contents | [Section 8.2.1](ch08.xhtml#ch08lev2sec73),
    [p. 151](ch08.xhtml#page_151) |'
  prefs: []
  type: TYPE_TB
- en: '| `file.choose` | Interactive file selection | [Section 8.2.1](ch08.xhtml#ch08lev2sec73),
    [p. 152](ch08.xhtml#page_152) |'
  prefs: []
  type: TYPE_TB
- en: '| `read.csv` | Import comma-delimited file | [Section 8.2.2](ch08.xhtml#ch08lev2sec74),
    [p. 153](ch08.xhtml#page_153) |'
  prefs: []
  type: TYPE_TB
- en: '| `write.table` | Write table-format file to disk | [Section 8.3.1](ch08.xhtml#ch08lev2sec77),
    [p. 156](ch08.xhtml#page_156) |'
  prefs: []
  type: TYPE_TB
- en: '| `jpeg`, `bmp`, `png`, `tiff` | Write image/plot file to disk | [Section 8.3.2](ch08.xhtml#ch08lev2sec78),
    [p. 157](ch08.xhtml#page_157) |'
  prefs: []
  type: TYPE_TB
- en: '| `dev.off` | Close file graphics device | [Section 8.3.2](ch08.xhtml#ch08lev2sec78),
    [p. 157](ch08.xhtml#page_157) |'
  prefs: []
  type: TYPE_TB
- en: '| `pdf`, `postscript` | Write image/plot file to disk | [Section 8.3.2](ch08.xhtml#ch08lev2sec78),
    [p. 158](ch08.xhtml#page_158) |'
  prefs: []
  type: TYPE_TB
- en: '| `ggsave` | Write `ggplot2` plot file to disk | [Section 8.3.2](ch08.xhtml#ch08lev2sec78),
    [p. 159](ch08.xhtml#page_159) |'
  prefs: []
  type: TYPE_TB
- en: '| `dput` | Write R object to file (ASCII) | [Section 8.4](ch08.xhtml#ch08lev1sec30),
    [p. 160](ch08.xhtml#page_160) |'
  prefs: []
  type: TYPE_TB
- en: '| `dget` | Import ASCII object file | [Section 8.4](ch08.xhtml#ch08lev1sec30),
    [p. 161](ch08.xhtml#page_161) |'
  prefs: []
  type: TYPE_TB
