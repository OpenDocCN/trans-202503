<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_335"/><strong><span class="big">12</span><br/>DEADLOCKS AND RACE CONDITIONS</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">We’ve talked about <em>multitasking</em>, or computers doing more than one thing at a time. Originally we were just pretending that computers could do this, because really there was only one computer switching between tasks. But now that multicore processors are the norm, computers <em>are</em> actually doing more than one thing at a time. Multiprocessing isn’t a particularly new concept; single-core processors have long been connected together to achieve higher performance. It’s just easier and more common now. A multiprocessor system isn’t an expensive special-purpose machine anymore—it’s your phone.</p>
<p class="indent">Sometimes the order in which things are done is important. For example, let’s say you have a joint bank account (one that you share with someone else) that has a balance of $100. The other account owner goes to an ATM to withdraw $75 at the same time that you go into the bank to withdraw $50. This is what’s known as a <em>race condition</em>. The bank software needs to be able to <em>lock</em> one of you out so that only one withdrawal can <span epub:type="pagebreak" id="page_336"/>be processed at a time to prevent the account from becoming overdrawn. This essentially means turning off multitasking for certain operations. It’s tricky to do that without losing the benefits of multitasking, however, as this chapter will show.</p>
<h3 class="h3" id="ch12lev1sec1"><strong>What Is a Race Condition?</strong></h3>
<p class="noindent">A race condition occurs when two (or more) programs access the same resource and the outcome is dependent on timing. Take a look at <a href="ch12.xhtml#ch12fig01">Figure 12-1</a>, where two programs are trying to deposit money into a bank account.</p>
<div class="image"><a id="ch12fig01"/><img src="../images/12fig01.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-1: Race condition example</em></p>
<p class="indent">The <em>shared resource</em> in this example is the account balance. As you can see, the result depends on the timing of the two programs accessing this resource.</p>
<p class="indent">Another way of looking at it is best expressed by the T-shirt shown in <a href="ch12.xhtml#ch12fig02">Figure 12-2</a>.</p>
<div class="image"><a id="ch12fig02"/><img src="../images/12fig02.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-2: Racing attire</em></p>
<h3 class="h3" id="ch12lev1sec2"><span epub:type="pagebreak" id="page_337"/><strong>Shared Resources</strong></h3>
<p class="noindent">What resources can be shared? Pretty much anything. In the previous section, we saw memory being shared. Memory is always involved in sharing, even if the end result of the sharing isn’t memory. That’s because there must be some indication that a shared resource is in use. This memory may not be what we typically think of as memory; it may just be a bit in some piece of input/output (I/O) device hardware.</p>
<p class="indent">Sharing I/O devices is also very common—for example, sharing a printer. It obviously wouldn’t work very well to mix pieces of different documents together. I mentioned back in “<a href="ch05.xhtml#ch05lev1sec8">System and User Space</a>” on <a href="ch05.xhtml#page_133">page 133</a> that operating systems handle I/O for user programs. That really only applies to I/O devices that are part of the machine, like the USB controller. While the operating system ensures that USB-connected devices communicate correctly, it often leaves the control of these devices up to user programs.</p>
<p class="indent"><em>Field-programmable gate arrays</em>, or <em>FPGAs</em> (see “<a href="ch03.xhtml#ch03lev1sec6">Hardware vs. Software</a>” on <a href="ch03.xhtml#page_90">page 90</a>), are an exciting frontier in resource sharing. You might want to program an FPGA to provide a special hardware function to speed up a particular piece of software. You’d want to make sure that nothing replaces the hardware programming that’s expected by the software.</p>
<p class="indent">It’s less obvious that programs running on different computers communicating with each other can also share resources.</p>
<h3 class="h3" id="ch12lev1sec3"><strong>Processes and Threads</strong></h3>
<p class="noindent">How can multiple programs get access to the same data? We briefly touched on operating systems back in “<a href="ch05.xhtml#ch05lev1sec5">Relative Addressing</a>” on <a href="ch05.xhtml#page_128">page 128</a>. One of the functions of an operating system is to manage multiple tasks.</p>
<p class="indent">Operating systems manage <em>processes</em>, which are programs running in <em>user space</em> (see “<a href="ch05.xhtml#ch05lev1sec8">System and User Space</a>” on <a href="ch05.xhtml#page_133">page 133</a>). Multiple programs can be running simultaneously with multicore processors, but that’s not enough for a race condition by itself—programs must have shared resources.</p>
<p class="indent">There’s no magic way, at least since Thor took the Tesseract back to Asgard, for processes to share resources; they must have some kind of arrangement to do so. This implies that processes sharing resources must somehow communicate, and this communication can take many forms. It must be prearranged either by being built into a program or via some sort of configuration information.</p>
<p class="indent">Sometimes a process needs to pay attention to multiple things. A good example is a <em>print server</em>—a program that other programs can communicate with to get things printed. Before networking, it was difficult to use a printer that wasn’t connected to an I/O port on the machine you wanted to print from. The networking code developed in the 1980s at the University of California, Berkeley, made it easier to for computers to communicate with each other by adding several system calls. In essence, a program could wait for incoming activity from multiple sources and run the appropriate handler <span epub:type="pagebreak" id="page_338"/>code. This approach worked pretty well, mainly because the handler code was fairly simple and was run before waiting for the next activity. Print server code could print an entire document before worrying about the next one.</p>
<p class="indent">Interactive programs with graphical user interfaces changed all that. Activity handlers were no longer simple tasks that ran from start to finish; they may have to pause and wait for user input in multiple places. Although programs could be implemented as a swarm of cooperating processes, that’s pretty cumbersome because they need to share a lot of data.</p>
<p class="indent">What’s needed is a way for handlers to be interruptible—that is, for them to be able to stop where they are, saving their state so that they can resume execution where they left off at a later time. Well, this is nothing new. Where is that state? On the stack. Problem is, there’s only one stack per process, and it sounds like we need one for every handler in a process. Enter threads of execution. We saw how operating systems arrange process memory in “<a href="ch05.xhtml#ch05lev1sec11">Arranging Data in Memory</a>” on <a href="ch05.xhtml#page_136">page 136</a>. A <em>thread</em> is a piece of a program that shares the static data and heap but has its own stack, as shown in <a href="ch12.xhtml#ch12fig03">Figure 12-3</a>. Each thread believes it has sole access to the CPU registers, so the <em>thread scheduler</em> must save and restore them when switching from one thread to another, in a manner similar to what the OS does when switching from one process to another. Threads are also called <em>lightweight processes</em> because they have much less context than a regular process, so switching between threads is faster than switching between processes.</p>
<div class="image"><a id="ch12fig03"/><img src="../images/12fig03.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-3: Memory layout for threads</em></p>
<p class="indent">Early implementations of threads involved some custom assembly language code that was by definition machine specific. Threads turned out to be sufficiently useful that a machine-independent API was standardized. <span epub:type="pagebreak" id="page_339"/>Threads are interesting to us here because they make race conditions within a single process possible. Not only is this an issue in low-level C programs, but JavaScript event handlers are also threads.</p>
<p class="indent">But just because threads exist doesn’t mean they’re the right solution for everything. Thread abuse is responsible for a lot of bad user experience. When Microsoft first introduced Windows, it was a program that ran on top of MS-DOS, which was not a state-of-the-art operating system that supported multitasking. As a result, Microsoft built parts of an operating system into each of its applications so that users could, for example, have several documents open at once. Unfortunately, some people brought this approach to programs running on complete operating systems. This method shows up in tabbed applications (for example, LibreOffice and Firefox) and user interfaces (for example, GNOME).</p>
<p class="indent">Why is that a bad idea? First of all, threads share data, so it’s a security issue. Second, as you’ve probably experienced, a bug or problem with one tab often kills the entire process, resulting in lost work in what should be unrelated tasks. Third, as you’ve also likely experienced, a thread that takes a long time to complete prevents all other threads from running, so, for example, a slow-loading web page often hangs multiple browser instances.</p>
<p class="indent">The moral of the story here is to code smartly. Use the operating system; that’s why it’s there. If it doesn’t perform as needed or is missing a critical feature, fix that. Don’t make a mess of everything else.</p>
<h3 class="h3" id="ch12lev1sec4"><strong>Locks</strong></h3>
<p class="noindent">The problem at hand isn’t really sharing resources. It’s how to make operations <em>atomic</em> (that is, indivisible, uninterruptible) when they’re made up of a series of smaller operations.</p>
<p class="indent">We wouldn’t be having this discussion if computers had instructions like <code>adjust the bank balance</code>. But of course they don’t, because we’d need an infinite number of such instructions. Instead, we have to make critical sections of code appear atomic using some sort of <em>mutual exclusion</em> mechanism. We do that by creating <em>advisory locks</em> that programs follow to avoid conflicts (see <a href="ch12.xhtml#ch12fig04">Figure 12-4</a>).</p>
<div class="image"><a id="ch12fig04"/><img src="../images/12fig04.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-4: Advisory lock</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_340"/>As you can see in <a href="ch12.xhtml#ch12fig04">Figure 12-4</a>, the upper program grabbed the lock first, so the lower program had to wait until the lock was released. The lock is <em>advisory</em> because it’s up to the programs to follow it; there is no enforcement mechanism. This might seem pretty useless because it wouldn’t stop anyone from robbing a bank. But it’s a matter of where the lock resides. As you can see in <a href="ch12.xhtml#ch12fig05">Figure 12-5</a>, the lock is at the bank, which does the enforcement, so that makes it work.</p>
<div class="image"><a id="ch12fig05"/><img src="../images/12fig05.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-5: Lock location</em></p>
<p class="indent">This solves one problem but creates others. What happens if the communication between program #1 and the bank is slow? Clearly, program #2 is going to have to wait a while, which means we’re losing some of the benefits of multitasking. And what happens if program #1 dies or just behaves badly and never releases the lock? What does program #2 do while it’s waiting?</p>
<p class="indent">We’ll look at these issues in the next few sections.</p>
<h4 class="h4" id="ch12lev2sec1"><strong><em>Transactions and Granularity</em></strong></h4>
<p class="noindent">Every operation performed by program #1 in <a href="ch12.xhtml#ch12fig05">Figure 12-5</a> requires some sort of communication with the bank. This needs to be two-way communication because we need to know whether or not each operation succeeds before doing the next. The easy way to improve the performance is to bundle the set of operations into a <em>transaction</em>, which is a group of operations that either all succeed or all fail (see <a href="ch12.xhtml#ch12fig06">Figure 12-6</a>). The term <em>transaction</em> stems from the database world. Rather than sending each operation separately, we’ll bundle them.</p>
<div class="image"><a id="ch12fig06"/><img src="../images/12fig06.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-6: Transactions</em></p>
<p class="indent">An obvious guideline is to minimize the amount of time in which something is locked, because that reduces concurrency. One guideline that’s not quite so obvious, however, is to minimize the <em>granularity</em> of locks—that is, the amount of stuff covered by the lock. We’re locking the balance in our example; it’s implied that we’re just locking the balance of one account. Locking the entire bank every time one customer needs to update a balance <span epub:type="pagebreak" id="page_341"/>would not be a great solution. The X Window System is an example of poorly designed locking. Although it has many types of locks, there are many instances where locking everything is the only option, but that eliminates concurrency.</p>
<p class="indent">Locks that cover a small part of a system are called <em>fine-grained</em>; locks covering larger parts are called <em>coarse-grained</em>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Processor interrupt handling includes a locking mechanism. When an interrupt is received, a</em> mask <em>is set that prevents the processor from receiving any more interrupts of the same type, unless explicitly allowed, until the interrupt handler is done.</em></p>
</div>
<h4 class="h4" id="ch12lev2sec2"><strong><em>Waiting for a Lock</em></strong></h4>
<p class="noindent">It doesn’t do a lot of good to use transactions and fine-grained locks if a program waiting for a lock can’t do anything useful while waiting. After all, the “multi” is the whole point of multitasking.</p>
<p class="indent">Sometimes there’s nothing useful to do while waiting for a lock, which is why you have to stand in the rain waiting for an ATM to respond. There are two ways of doing nothing, though. We can <em>spin</em>, which means we can try the lock over and over until we successfully grab it. Spinning often involves using a timer to space out the tries. Going full speed on a machine chews up a lot of power unnecessarily. Going full speed on a network can be like having a mob of people trying to get into a store on Black Friday. In some circumstances—and this is the second way of doing nothing—an entity requesting a lock can <em>register</em> that request with the lock authority and <em>get notified</em> when the request is granted. This allows the requestor to go do something more useful while waiting. This approach doesn’t scale particularly well and is explicitly not supported by the architecture of the internet, although it can be layered on top.</p>
<p class="indent">We learned in <a href="ch06.xhtml#ch06">Chapter 6</a> that Ethernet takes an interesting approach to waiting. It doesn’t have locks, but if multiple devices collide while trying to access the shared resource (the wire), they each wait a random amount of time and then try again.</p>
<p class="indent">Some operating systems provide locking functionality, usually associated with a handle similar to a file descriptor. Locking can be attempted in blocking or nonblocking modes. <em>Blocking</em> means that the system suspends the calling program (that is, stops it from executing) until the lock is available. <em>Nonblocking</em> means that the program keeps running and receives some indication that it did not get the lock.</p>
<h4 class="h4" id="ch12lev2sec3"><strong><em>Deadlocks</em></strong></h4>
<p class="noindent">You’ve seen that programs must do some sort of waiting around when they need locks that aren’t available. Complicated systems often have multiple locks, though, so what happens in the case shown in <a href="ch12.xhtml#ch12fig07">Figure 12-7</a>?</p>
<p class="indent">Program #1 successfully grabs Lock A, and program #2 successfully grabs Lock B. Next, program #1 tries to grab Lock B but can’t because program #2 has it. Likewise, program #2 tries to grab Lock A but can’t because <span epub:type="pagebreak" id="page_342"/>program #1 has it. Neither program can proceed to the point where it releases the locks it holds. This is situation is called a <em>deadlock</em>, which is not a multi-threaded hairstyle.</p>
<div class="image"><a id="ch12fig07"/><img src="../images/12fig07.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-7: Deadlock</em></p>
<p class="indent">There are few great solutions to deadlocks other than to write code well. In some situations, it’s possible to manually clear a lock without causing a lot of damage. You’ve probably come across some situation where a program refuses to run because it can’t get a lock and prompts you as to whether or not you’d like to clear it. This situation arises when a program that holds a lock croaks unexpectedly without releasing it.</p>
<h4 class="h4" id="ch12lev2sec4"><strong><em>Short-Term Lock Implementation</em></strong></h4>
<p class="noindent">There is really only one way to implement locks, but there are many ways to present them to programs. Lock implementation requires hardware support in the form of special instructions to support locking. Software solutions designed decades ago no longer work due to advances in processor technology, such as out-of-order execution and multiple cores.</p>
<p class="indent">Many processors have a <em>test and set</em> instruction that exists explicitly for locking. This is an atomic instruction that tests to see whether a memory location is <code>0</code> and sets it to <code>1</code> if it isn’t. It returns a <code>1</code> if it was successful in changing the value and <code>0</code> otherwise. Thus, it directly implements a lock.</p>
<p class="indent">An alternate version that works better in situations where lots of programs are contending for a lock is <em>compare and swap</em>. This instruction is similar to test and set, but instead of just using a single value, the invoker provides both an old and a new value. If the old value matches what’s in the memory location, it’s replaced by the new value and the lock is grabbed.</p>
<p class="indent">Use of these instructions is usually restricted to system mode, so they’re not available to user programs. Some of the more recent language standards, such as C11, have added user-level support for atomic operations. Various locking operations have also been standardized and made available in libraries.</p>
<p class="indent">Additional code can be attached to locks to make them more efficient. For example, queues can be associated with locks to register programs waiting for locks.</p>
<h4 class="h4" id="ch12lev2sec5"><span epub:type="pagebreak" id="page_343"/><strong><em>Long-Term Lock Implementation</em></strong></h4>
<p class="noindent">We’ve mostly been talking about locks that are held for as short a time as possible, but sometimes we want to hold a lock for a long time. This is usually in situations where access by multiple programs is never permitted—for example, a word processor that’s designed to prevent multiple parties from editing the same document at the same time.</p>
<p class="indent">Long-term locks need to be kept in more persistent storage than memory. They’re often implemented through files. System calls exist that allow exclusive file creation, and whatever program gets there first succeeds. This is equivalent to acquiring a lock. Note that system calls are a high-level abstraction that uses atomic instructions underneath the hood.</p>
<h3 class="h3" id="ch12lev1sec5"><strong>Browser JavaScript</strong></h3>
<p class="noindent">Writing JavaScript programs that run in a browser is the first place where, as a new programmer, you’re likely to have to pay attention to concurrency. This may sound surprising if you’ve read any JavaScript documentation, because JavaScript is defined as single-threaded. So how can concurrency be an issue?</p>
<p class="indent">The reason is that JavaScript wasn’t originally designed for the uses it’s being put to today. One of its original purposes was to provide faster user feedback and to reduce internet traffic, back when the internet was much slower. For example, imagine a web page containing a field for a credit card number. Before JavaScript, the number would have to be sent to a web server that would verify that it contained only digits and either send an error response or further process the number if it was okay. JavaScript allowed the credit card number to be checked for digits in the web browser. This meant that the user didn’t have to wait in the event of a typo and that no internet traffic was required in order to detect and report the typo. Of course, there’s still lots of bad JavaScript out there that can’t handle spaces in card numbers, as you’ve probably discovered.</p>
<p class="indent">Since JavaScript was created to run short programs in response to user events, it’s implemented using an <em>event loop</em> model, the workings of which are shown in <a href="ch12.xhtml#ch12fig08">Figure 12-8</a>.</p>
<div class="image"><a id="ch12fig08"/><img src="../images/12fig08.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-8: JavaScript event loop</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_344"/>What happens is that tasks to be performed are added to the <em>event queue</em>. JavaScript pulls these tasks from the queue one at a time and executes them. These tasks are not interruptible because JavaScript is single-threaded. But you as the programmer don’t have control over the order in which events are added to the queue. For example, say you have an event handler for each mouse button. You don’t control the order in which mouse buttons are clicked, so you can’t control the ordering of events. Your program must reliably deal with events in any order.</p>
<p class="indent">Asynchronous communications weren’t designed into JavaScript when it debuted in 1995. Up until that point, browsers submitted forms and servers returned web pages. Two things changed that. First came the publication of the Document Object Model (DOM) in 1997, although it didn’t become stable (more or less) until around 2004. The DOM allowed existing web pages to be modified instead of just being replaced. Second, the XMLHttpRequest (XHR) arrived on the scene in 2000, which became the basis of AJAX. It provided background browser-server communications outside of the existing “load a page” model.</p>
<p class="indent">These changes triggered a dramatic increase in the complexity of web pages. Much more JavaScript was written, making it a mainstream programming language. Web pages became increasingly reliant on background asynchronous communication with servers. There were a lot of growing pains, because this wasn’t something JavaScript was designed to do, especially because the single-threaded model was at odds with asynchronous communications.</p>
<p class="indent">Let’s contrive a simple web application to display the art for an album by an artist. We’ll use some hypothetical website that first requires us to convert the album and artist name into an album identifier and then uses that identifier to fetch the album art. You may try writing the program as shown in <a href="ch12.xhtml#ch12list01">Listing 12-1</a>, where the code in italics is supplied by the user.</p>
<pre>var album_id;<br/>
var album_art_url;<br/>
<br/>
// Send the artist name and album name to the server and get back the album identifier.<br/>
<br/>
$.post("some_web_server", { artist: <span class="codeitalic1">artist_name</span>, album: <span class="codeitalic1">album_name</span> }, function(data) {<br/>
  var decoded = JSON.parse(data);<br/>
  album_id = decoded.album_id;<br/>
});<br/>
<br/>
// Send the album identifier to the server and get back the URL of the album art image.<br/>
// Add an image element to the document to display the album art.<br/>
<br/>
$.post("some_web_server", { id: album_id }, function(data) {<br/>
  var decoded = JSON.parse(data);<br/>
  album_art_url = decoded.url;<br/>
});<br/>
<br/>
$(body).append('&lt;img src="' + album_art_url + '"/&gt;');</pre>
<p class="listing" id="ch12list01"><em>Listing 12-1: First-try album art program</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_345"/>The jQuery <code>post</code> function sends the data from the second argument to the URL in the first argument, and calls the function that’s the third argument when it gets a response. Note that it doesn’t really call the function—it adds the function to the event queue, so that the function gets called when it reaches the front.</p>
<p class="indent">This seems like a nice, simple, orderly program. But it won’t work reliably. Why not? Let’s look at what’s happening in detail. Check out <a href="ch12.xhtml#ch12fig09">Figure 12-9</a>.</p>
<div class="image"><a id="ch12fig09"/><img src="../images/12fig09.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 12-9: Album art program flow</em></p>
<p class="indent">As you can see, the program doesn’t execute in order. The <code>post</code> operations start threads internally that wait for the server to respond. When the response is received, the callback functions are added to the event queue. The program shows the second post responding first, but it could just as easily be the first post responding first; that’s out of our control.</p>
<p class="indent">There’s a good chance, then, that our program will request the album art before it obtains the <code>album_id</code> from the first post. And it’s almost guaranteed that it will append the image to the web page before it obtains the <code>album_art_url</code>. That’s because, although JavaScript itself is single-threaded, we have concurrent interactions with web servers. Put another way: although the JavaScript interpreter presents a single-threaded model to the programmer, it’s actually multithreaded internally.</p>
<p class="indent"><a href="ch12.xhtml#ch12list02">Listing 12-2</a> shows a working version.</p>
<span epub:type="pagebreak" id="page_346"/>
<pre>$.post("some_web_server", { artist: <span class="codeitalic1">artist_name</span>, album: <span class="codeitalic1">album_name</span> }, function(data) {<br/>
  var decoded = JSON.parse(data);<br/>
<br/>
  $.post("some_web_server", { id: decoded.id }, function(data) {<br/>
    var decoded = JSON.parse(data);<br/>
    $(body).append('&lt;img src="' + decoded.url + '"/&gt;');<br/>
  });<br/>
});</pre>
<p class="listing" id="ch12list02"><em>Listing 12-2: Second-try album art program</em></p>
<p class="indent">Now we’ve moved the image <code>append</code> to be inside of the second <code>post</code> callback, and we’ve moved the second <code>post</code> callback to be inside of the first <code>post</code> callback. This means we won’t make the second <code>post</code> until the first one has completed.</p>
<p class="indent">As you can see, nesting is required to ensure that the dependencies are met. And it gets uglier with error handling, which I didn’t show. The next section covers a different way to approach this issue.</p>
<h3 class="h3" id="ch12lev1sec6"><strong>Asynchronous Functions and Promises</strong></h3>
<p class="noindent">There’s absolutely nothing wrong with the program in <a href="ch12.xhtml#ch12list02">Listing 12-2</a>. It works correctly because jQuery implemented the <code>post</code> function correctly. But just because jQuery did it correctly doesn’t mean other libraries do, especially in the Node.js world, where bad libraries are being created at an astonishing rate. Programs that use libraries that don’t properly implement callbacks are very difficult to debug. That’s become a problem because, as I mentioned in the book’s introduction, so much of programming is now taught as if it’s just the process of gluing together functions in libraries.</p>
<p class="indent">JavaScript has recently addressed this by adding a new construct called a <em>promise</em>. The computing concept of a promise stems from the mid-1970s and is having a renaissance since its addition to JavaScript. Promises move the mechanics of asynchronous callbacks into the language proper so that libraries can’t screw them up. Of course, it’s a moving target because you can’t add to the language every time a programmer makes a mistake. This particular case, however, seemed common enough to be worthwhile.</p>
<p class="indent">Explanations of JavaScript promises can be hard to understand because two independent things are jumbled together. Promises are easier to understand if these components are separated out. The important part is that there’s a better chance that libraries for asynchronous operations will function correctly if they use promises. The less important part, which gets talked about more, is a change in the programming paradigm. There’s a lot of “religion” around programming paradigms, which I talk about more in the final chapter. At some level, the promise construct is <em>syntactic sugar</em>, a sweetener that makes certain types of programming easier at the expense of fattening the programming language.</p>
<p class="indent">Taken to extremes, code for JavaScript asynchronous requests starts to look like what some call the <em>pyramid of doom</em>, as shown in <a href="ch12.xhtml#ch12list03">Listing 12-3</a>. I personally don’t see anything wrong with writing code this way. If indenting <span epub:type="pagebreak" id="page_347"/>offends you, then stay away from the Python programming language; it’ll bite your legs off.</p>
<pre>$.post("server", { parameters }, function() {<br/>
  $.post("server", { parameters }, function() {<br/>
    $.post("server", { parameters }, function() {<br/>
      $.post("server", { parameters }, function() {<br/>
        ...<br/>
      });<br/>
    });<br/>
  });<br/>
});</pre>
<p class="listing" id="ch12list03"><em>Listing 12-3: Pyramid of doom</em></p>
<p class="indent">Of course, some of this results from the way the program was written. The anonymous functions require all the code to be written inline. These can be eliminated, as shown in <a href="ch12.xhtml#ch12list04">Listing 12-4</a>, which eliminates the pyramid of doom but is harder to follow.</p>
<pre>$.post("some_web_server", { artist: <span class="codeitalic1">artist_name</span>, album: <span class="codeitalic1">album_name</span> }, got_id);<br/>
<br/>
function<br/>
got_id(data)<br/>
{<br/>
  var decoded = JSON.parse(data);<br/>
  $.post("some_web_server", { id: decoded.id }, got_album_art);<br/>
}<br/>
<br/>
function<br/>
got_album_art(data)<br/>
{<br/>
  var decoded = JSON.parse(data);<br/>
  $(body).append('&lt;img src="' + decoded.url + '"/&gt;');<br/>
}</pre>
<p class="listing" id="ch12list04"><em>Listing 12-4: Rewrite eliminating anonymous functions</em></p>
<p class="indent">What programmers really want is a more straightforward way of writing code. This is easy in many other programming languages but difficult in JavaScript because of its single-threaded model. In a hypothetical multithreaded version of JavaScript, we would just create a new thread to run the code in <a href="ch12.xhtml#ch12list05">Listing 12-5</a>. This code assumes that the <code>post</code> blocks until completed; it’s synchronous instead of asynchronous. The code is clear and easy to follow.</p>
<pre>var data = $.post("some_web_server", { artist: <span class="codeitalic1">artist_name</span>, album: <span class="codeitalic1">album_name</span> } );<br/>
var decoded = JSON.parse(data);<br/>
<br/>
var data = $.post("some_web_server", { id: decoded.id }, got_album_art);<br/>
var decoded = JSON.parse(data);<br/>
<br/>
$(body).append('&lt;img src="' + decoded.url + '"/&gt;');</pre>
<p class="listing" id="ch12list05"><em>Listing 12-5: Hypothetical blocking JavaScript example</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_348"/>If you could write code like this in JavaScript, it wouldn’t work well. The single-threaded nature of JavaScript would prevent other code from running while the <code>post</code>s were waiting, which means that event handlers for mouse clicks and other user interactions wouldn’t get run in a timely manner.</p>
<p class="indent">JavaScript promises have some similarity to <a href="ch12.xhtml#ch12list04">Listing 12-4</a> in that the definition of a promise is akin to the function definitions; the definition of a promise is separated out from its execution.</p>
<p class="indent">A promise is created as shown in <a href="ch12.xhtml#ch12list06">Listing 12-6</a>. Although this doesn’t look much different from other JavaScript code, such as a jQuery <code>post</code> that takes a function as an argument, the function is not executed. This is the setup phase of a promise.</p>
<pre>var promise = new Promise(function(resolve, reject) {<br/>
  if (<span class="codeitalic1">whatever it does is successful</span>)<br/>
    resolve(<span class="codeitalic1">return_value</span>);<br/>
  else<br/>
    reject(<span class="codeitalic1">return_value</span>);<br/>
});</pre>
<p class="listing" id="ch12list06"><em>Listing 12-6: Promise creation</em></p>
<p class="indent">Let’s look at this in more detail. You supply the promise with a function that performs some asynchronous operation. That function has two arguments that are also functions: one (<code>resolve</code> in <a href="ch12.xhtml#ch12list06">Listing 12-6</a>) that’s appended to the JavaScript event queue when the asynchronous operation completes successfully, and one (<code>reject</code> in <a href="ch12.xhtml#ch12list06">Listing 12-6</a>) that’s added to the JavaScript event queue if the asynchronous operation fails.</p>
<p class="indent">The program executes a promise using its <code>then</code> method, as shown in <a href="ch12.xhtml#ch12list07">Listing 12-7</a>. This method takes a pair of functions as arguments that are matched to the <code>resolve</code> and <code>reject</code> functions supplied during promise creation.</p>
<pre>promise.then(<br/>
  function(value) {<br/>
    <span class="codeitalic1">do something with the</span> <span class="codeitalic1">return_value from</span> resolve<br/>
  },<br/>
  function(value) {<br/>
    <span class="codeitalic1">do something with the</span> <span class="codeitalic1">return_value from</span> reject<br/>
  }<br/>
);</pre>
<p class="listing" id="ch12list07"><em>Listing 12-7: Promise execution</em></p>
<p class="indent">This isn’t very exciting. We could write code to do this without using promises, as we did before. So why bother? Promises come with a bit of syntactic sugar called <em>chaining</em>. It allows code to be written in a <span class="codeitalic">something</span><code>().</code><span class="codeitalic">then</span><code>().</code><span class="codeitalic">then</span><code>().</code><span class="codeitalic">then</span><code>()</code> . . . style. This works because the <code>then</code> method <span epub:type="pagebreak" id="page_349"/>returns another promise. Note that, in a manner similar to exceptions, the second argument to <code>then</code> can be omitted and errors can be fielded with a <code>catch</code>. <a href="ch12.xhtml#ch12list08">Listing 12-8</a> shows the album art program rewritten using promise chaining.</p>
<pre>function<br/>
post(host, args)<br/>
{<br/>
  return (new Promise(function(resolve, reject) {<br/>
    $.post(host, args, function(data) {<br/>
      if (success)<br/>
        resolve(JSON.parse(data));<br/>
      else<br/>
        reject('failed');<br/>
    });<br/>
  }));<br/>
}<br/>
<br/>
post("<span class="codeitalic1">some-web-server</span>, { artist: <span class="codeitalic1">artist_name</span>, album: <span class="codeitalic1">album_name</span> } ).then(function(data) {<br/>
  if (data.id)<br/>
    return (post("<span class="codeitalic1">some-web-server</span>, { id: data.id });<br/>
  else<br/>
    throw ("nothing found for " + artist_name + " and " + album_name);<br/>
}).then(function(data) {<br/>
  if (data.url)<br/>
    $(body).append('&lt;img src="' + data.url + '"/&gt;');<br/>
  else<br/>
    throw (`nothing found for ${data.id}`);<br/>
}).catch(alert);</pre>
<p class="listing" id="ch12list08"><em>Listing 12-8: Album art program using promise chaining</em></p>
<p class="indent">Now, I don’t find this code easier to follow than the pyramid-of-doom version, but you may feel differently. The versions of code in <a href="ch12.xhtml#ch12list02">Listings 12-2</a> and <a href="ch12.xhtml#ch12list08">12-8</a> raise another point about the art of programming: trading off the ease of code development versus maintenance. In the grand scheme of a product’s lifecycle, maintainability is more important than writing code in some personally preferred style. I talk about this a little more in <a href="ch15.xhtml#ch15">Chapter 15</a>. Promise chaining allows you to write code in a <span class="codeitalic">function</span><code>().</code><span class="codeitalic">function</span><code>().</code><span class="codeitalic">function</span><code>()</code> . . . style instead of the pyramid-of-doom style. While the first style makes keeping track of parentheses slightly easier, JavaScript—unlike Ruby, for example—was designed with the second style, and having two styles in the same language likely increases confusion, resulting in decreased programmer productivity. Although promises might reduce the instances of one class of programming errors, don’t mistake them as a cure-all for poorly written code.</p>
<p class="indent">Promises are syntactic sugar that reduce the amount of nesting. But if we really want code that’s easier to follow, we want something more like <a href="ch12.xhtml#ch12list05">Listing 12-5</a>. JavaScript includes yet another way to write “asynchronous” programs that builds on promises but mirrors the synchronous coding style: <code>async</code> and <code>await</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_350"/><a href="ch12.xhtml#ch12list09">Listing 12-9</a> shows an implementation of the album art program using <code>async</code> and <code>await</code>.</p>
<pre>function<br/>
post(host, args)<br/>
{<br/>
  return (new Promise(function(resolve, reject) {<br/>
    $.post(host, args, function(data) {<br/>
      if (success)<br/>
        resolve(JSON.parse(data));<br/>
      else<br/>
        reject('failed');<br/>
    });<br/>
  }));<br/>
}<br/>
<br/>
async function<br/>
get_album_art()<br/>
{<br/>
  var data = await post("<span class="codeitalic1">some-web-server</span>, { artist: <span class="codeitalic1">artist_name</span>, album: <span class="codeitalic1">album_name</span> } );<br/>
<br/>
  if (data.id) {<br/>
    var data = await post("<span class="codeitalic1">some-web-server</span>, { id: data.id });<br/>
<br/>
    if (data.url)<br/>
      $(body).append('&lt;img src="' + data.url + '"/&gt;');<br/>
  }<br/>
}</pre>
<p class="listing" id="ch12list09"><em>Listing 12-9: Album art program using <span class="codeitalic">async</span> and <span class="codeitalic">await</span></em></p>
<p class="indent">To me, this looks more straightforward than <a href="ch12.xhtml#ch12list08">Listing 12-8</a>.</p>
<p class="indent">Of course, what’s going on here is that the single-threaded JavaScript model has been severely bent, if not broken. Asynchronous functions are essentially threads that are not interruptible.</p>
<h3 class="h3" id="ch12lev1sec7"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you learned about some of the issues that result from using shared resources. You learned about race conditions and deadlocks, and about processes and threads. You also learned a little bit about concurrency in JavaScript and new ways in which it’s being approached. At this point, we’ve covered the basics. We’ll move on to one of our two advanced topics—security—in the next chapter, which uses many of the technologies that you’ve learned about so far.</p>
</body></html>